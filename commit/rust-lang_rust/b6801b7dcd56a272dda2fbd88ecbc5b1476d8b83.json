{"sha": "b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ODAxYjdkY2Q1NmEyNzJkZGEyZmJkODhlY2JjNWIxNDc2ZDhiODM=", "commit": {"author": {"name": "Stefan Lankes", "email": "stlankes@users.noreply.github.com", "date": "2019-10-20T08:48:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-20T08:48:58Z"}, "message": "Merge branch 'master' into rusty-hermit", "tree": {"sha": "c77cecd79f214f1a3a5cbdee0dd8eb934ea86c3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c77cecd79f214f1a3a5cbdee0dd8eb934ea86c3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdrB96CRBK7hj4Ov3rIwAAdHIIABb5jhvyIcDD4GYbVjtmw9c7\nyO3QxzhwuN3PJ9mVAbZ3FIUoMk2qJd/Fb217Ib2DWxDMS4Uyeef0sXck9rqBsaeF\naiZfcS6TON1IytqaesLjHnxJcm4gJuQKgCQhX9kc2oD9ZbkoyhjX+NaCRkrEqCmm\nCDL/NfKJFh2SVV0Xmfl+xpW4wXfBzALTMBCpK/vgZS/oMVhTCQpaTw6GzpKvRpxY\n+JCwRNdIHKnWE0Z/YjjexgBJ4YLa82zhtjU+g60/cpi8CNLh9Gm1D9UKNpYqp7KS\ntavQHmWaVg0aONO5C7h3hxvDsN9I11Y5obYpUuhnDn0Y32hLyR/hZM6MEdPoEbA=\n=4l/s\n-----END PGP SIGNATURE-----\n", "payload": "tree c77cecd79f214f1a3a5cbdee0dd8eb934ea86c3b\nparent 5ebd4d9c27bf8fee4f7d664d76c41832745dff43\nparent e66a6282275802fcb0a29ba58ddc445fc64ac8ef\nauthor Stefan Lankes <stlankes@users.noreply.github.com> 1571561338 +0200\ncommitter GitHub <noreply@github.com> 1571561338 +0200\n\nMerge branch 'master' into rusty-hermit"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "html_url": "https://github.com/rust-lang/rust/commit/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "html_url": "https://github.com/rust-lang/rust/commit/5ebd4d9c27bf8fee4f7d664d76c41832745dff43"}, {"sha": "e66a6282275802fcb0a29ba58ddc445fc64ac8ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/e66a6282275802fcb0a29ba58ddc445fc64ac8ef", "html_url": "https://github.com/rust-lang/rust/commit/e66a6282275802fcb0a29ba58ddc445fc64ac8ef"}], "stats": {"total": 28036, "additions": 17735, "deletions": 10301}, "files": [{"sha": "e3708bc485399fd42b32c6a1c24491771afa1a04", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,40 +1,3 @@\n # The Rust Code of Conduct\n \n-A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n-\n-## Conduct\n-\n-**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n-\n-* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n-* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n-* Please be kind and courteous. There's no need to be mean or rude.\n-* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n-* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n-* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n-\n-## Moderation\n-\n-\n-These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please contact the [Rust moderation team][mod_team].\n-\n-1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n-2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n-3. Moderators will first respond to such remarks with a warning.\n-4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n-5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n-6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.\n-7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, **in private**. Complaints about bans in-channel are not allowed.\n-8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.\n-\n-In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.\n-\n-And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.\n-\n-The enforcement policies listed above apply to all official Rust venues; including all communication channels (Rust Discord server, Rust Zulip server); GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org (users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n-\n-*Adapted from the [Node.js Policy on Trolling](https://blog.izs.me/2012/08/policy-on-trolling) as well as the [Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*\n-\n-[mod_team]: https://www.rust-lang.org/team.html#Moderation-team\n+The Code of Conduct for this repository [can be found online](https://www.rust-lang.org/conduct.html)."}, {"sha": "f05550abdc344321084554c4f12fcce97d11709e", "filename": "Cargo.lock", "status": "modified", "additions": 155, "deletions": 52, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -107,6 +107,12 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b671c8fb71b457dd4ae18c4ba1e59aa81793daacc361d82fcd410cef0d491875\"\n+\n [[package]]\n name = \"backtrace\"\n version = \"0.3.37\"\n@@ -550,9 +556,9 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.23\"\n+version = \"0.3.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eb783fe7afb90ec3d3e49ccaf9196d29ab63c6ed61d4b0695839daa580ae3a3d\"\n+checksum = \"676a74b493d50ac33cacd83fd536597e6b52c0b46b9856f7b9c809d82fef4ac0\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -659,6 +665,16 @@ dependencies = [\n  \"crossbeam-utils 0.6.5\",\n ]\n \n+[[package]]\n+name = \"crossbeam-deque\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b18cd2e169ad86297e6bc0ad9aa679aee9daa4f19e8163860faf7c164e4f5a71\"\n+dependencies = [\n+ \"crossbeam-epoch 0.7.2\",\n+ \"crossbeam-utils 0.6.5\",\n+]\n+\n [[package]]\n name = \"crossbeam-epoch\"\n version = \"0.3.1\"\n@@ -993,7 +1009,7 @@ dependencies = [\n  \"proc-macro2 0.4.30\",\n  \"quote 0.6.12\",\n  \"syn 0.15.35\",\n- \"synstructure\",\n+ \"synstructure 0.10.2\",\n ]\n \n [[package]]\n@@ -1259,7 +1275,7 @@ version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n dependencies = [\n- \"hashbrown\",\n+ \"hashbrown 0.5.0\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"pest\",\n@@ -1276,10 +1292,19 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6587d09be37fb98a11cb08b9000a3f592451c1b1b613ca69d949160e313a430a\"\n+dependencies = [\n+ \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n- \"serde\",\n ]\n \n [[package]]\n@@ -1316,9 +1341,9 @@ checksum = \"023b39be39e3a2da62a94feb433e91e8bcd37676fbc8bea371daf52b7a769a3e\"\n \n [[package]]\n name = \"home\"\n-version = \"0.5.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c07c315e106bd6f83f026a20ddaeef2706782e490db1dcdd37caad38a0e895b3\"\n+checksum = \"a3753954f7bd71f0e671afb8b5a992d1724cf43b7f95a563cd4a0bde94659ca8\"\n dependencies = [\n  \"scopeguard 1.0.0\",\n  \"winapi 0.3.6\",\n@@ -2643,9 +2668,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.27\"\n+version = \"2.1.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dde22b84ab75220015cbd91240222402bf885cbe3a5dc856475771abb82533ae\"\n+checksum = \"acc70369054bad4ad0c16a3f45cd73e0695361a3af35c7b465e619ac2674f064\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -2802,22 +2827,22 @@ dependencies = [\n \n [[package]]\n name = \"rayon\"\n-version = \"1.1.0\"\n+version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a4b0186e22767d5b9738a05eab7c6ac90b15db17e5b5f9bd87976dd7d89a10a4\"\n+checksum = \"83a27732a533a1be0a0035a111fe76db89ad312f6f0347004c220c57f209a123\"\n dependencies = [\n- \"crossbeam-deque 0.6.3\",\n+ \"crossbeam-deque 0.7.1\",\n  \"either\",\n  \"rayon-core\",\n ]\n \n [[package]]\n name = \"rayon-core\"\n-version = \"1.5.0\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ebbe0df8435ac0c397d467b6cad6d25543d06e8a019ef3f6af3c384597515bd2\"\n+checksum = \"98dcf634205083b17d0861252431eb2acbfb698ab7478a2d20de07954f47ec7b\"\n dependencies = [\n- \"crossbeam-deque 0.6.3\",\n+ \"crossbeam-deque 0.7.1\",\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n  \"lazy_static 1.3.0\",\n@@ -3085,8 +3110,8 @@ dependencies = [\n  \"num_cpus\",\n  \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon 0.3.0\",\n+ \"rustc-rayon-core 0.3.0\",\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3098,30 +3123,31 @@ dependencies = [\n  \"serialize\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f59b76d334bd533f3fdc5c651c27678c5e80fac67c6f7da22ba21a58878c55f5\"\n+checksum = \"a623fd4805842e9bd0bb6e6dace63efede0ee22de4522a0b03b7c3d15a22f009\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e632ef08ca17458acfd46d2ead3d541a1c249586cd5329f5fe333dacfab6142\"\n+checksum = \"ee549ade784b444ef10c0240c3487ed785aa65d711071f7984246b15329a17b6\"\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e89e2c7be68185418f3cd56af3df8b29007a59a1cebefa63612d055f9bcb1a36\"\n+checksum = \"ca545744a5a9b42e3d0410d6290d40de96dd567253fe77f310c1de4afd213dd4\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n@@ -3130,21 +3156,22 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot 0.7.1\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-ap-graphviz\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon 0.2.0\",\n+ \"rustc-rayon-core 0.2.0\",\n  \"smallvec\",\n  \"stable_deref_trait\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1e47cb380abeb72b01e42b2342d592f7eeea7d536c2f1f0d0e550dc509e46333\"\n+checksum = \"a6967a41ed38ef4bce0f559fe9a4801d8ba12ac032f40a12a55e72f79d52c9bb\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n@@ -3157,64 +3184,75 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_index\"\n+version = \"606.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"457a5c204ae2fdaa5bdb5b196e58ca59896870d80445fe423063c9453496e3ea\"\n+dependencies = [\n+ \"rustc-ap-serialize\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"494cfaf67f49217d67d0774eeecbba61ac89acf478db97ef11f113ed8a959305\"\n+checksum = \"ed0c064676f8a08e42a36b0d4e4a102465fb0f4b75e11436cb7f66d2c3fa7139\"\n dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e5d36becc59b4497f9cbd3ae0610081de0207a1d0e95c066369167b14f486f\"\n+checksum = \"b2d77e46159c5288c585decbcdc9d742889c65e307c31e104c7a36d63fe1f5d0\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"proc-macro2 0.4.30\",\n  \"quote 0.6.12\",\n  \"syn 0.15.35\",\n- \"synstructure\",\n+ \"synstructure 0.10.2\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7bfc5f96dfc3b9f8d5b57884f7f37467ecff6776cd4b8b491a7daece6fdd7c2\"\n+checksum = \"86ca895350b0de14d064b499168c93fa183958d5462eb042c927d93623e41ec1\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n ]\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2bb9ee231cf79eded39c56647499f83d6136ff5c8c0baaa9e21b6febee00f4f6\"\n+checksum = \"92679240e86f4583cc05f8dcf6439bdab87bac9e6555718469176de9bd52ba20\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3827fc208814efbde82d613e31d11b4250ce9e8cf8afe4a4d47bbbd099632c9\"\n+checksum = \"0a0c30f8e38c847dbfd9e2f1e472ab06d0bd0a23ab53ae4c5a44912842ce834e\"\n dependencies = [\n  \"bitflags\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_target\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n@@ -3224,13 +3262,14 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"930ed81c34f325e512cc315c04d676fa84a373879d5c43bb54054a0522b05213\"\n+checksum = \"2bdaa0fb40143b4b878256ac4e2b498885daafc269502504d91929eab4744bf4\"\n dependencies = [\n  \"cfg-if\",\n  \"rustc-ap-arena\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-serialize\",\n  \"scoped-tls\",\n@@ -3274,7 +3313,18 @@ checksum = \"0d2e07e19601f21c59aad953c2632172ba70cb27e685771514ea66e4062b3363\"\n dependencies = [\n  \"crossbeam-deque 0.2.0\",\n  \"either\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon-core 0.2.0\",\n+]\n+\n+[[package]]\n+name = \"rustc-rayon\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f32767f90d938f1b7199a174ef249ae1924f6e5bbdb9d112fea141e016f25b3a\"\n+dependencies = [\n+ \"crossbeam-deque 0.7.1\",\n+ \"either\",\n+ \"rustc-rayon-core 0.3.0\",\n ]\n \n [[package]]\n@@ -3289,6 +3339,19 @@ dependencies = [\n  \"num_cpus\",\n ]\n \n+[[package]]\n+name = \"rustc-rayon-core\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea2427831f0053ea3ea73559c8eabd893133a51b251d142bacee53c62a288cb3\"\n+dependencies = [\n+ \"crossbeam-deque 0.7.1\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils 0.6.5\",\n+ \"lazy_static 1.3.0\",\n+ \"num_cpus\",\n+]\n+\n [[package]]\n name = \"rustc-serialize\"\n version = \"0.3.24\"\n@@ -3376,6 +3439,7 @@ dependencies = [\n  \"rustc_target\",\n  \"serialize\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n  \"tempfile\",\n ]\n@@ -3409,8 +3473,8 @@ dependencies = [\n  \"log\",\n  \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon 0.3.0\",\n+ \"rustc-rayon-core 0.3.0\",\n  \"rustc_index\",\n  \"serialize\",\n  \"smallvec\",\n@@ -3490,7 +3554,7 @@ dependencies = [\n  \"log\",\n  \"once_cell\",\n  \"rustc\",\n- \"rustc-rayon\",\n+ \"rustc-rayon 0.3.0\",\n  \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n@@ -3508,6 +3572,7 @@ dependencies = [\n  \"serialize\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_ext\",\n  \"syntax_pos\",\n  \"tempfile\",\n@@ -3557,10 +3622,10 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"synstructure\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+ \"synstructure 0.12.1\",\n ]\n \n [[package]]\n@@ -3579,6 +3644,7 @@ dependencies = [\n  \"smallvec\",\n  \"stable_deref_trait\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3624,7 +3690,10 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_index\",\n+ \"rustc_target\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3642,6 +3711,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_metadata\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3670,6 +3740,7 @@ dependencies = [\n  \"rustc_metadata\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3767,7 +3838,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"minifier\",\n  \"pulldown-cmark 0.5.3\",\n- \"rustc-rayon\",\n+ \"rustc-rayon 0.3.0\",\n  \"tempfile\",\n ]\n \n@@ -3806,7 +3877,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.8\"\n+version = \"1.4.9\"\n dependencies = [\n  \"annotate-snippets\",\n  \"bytecount\",\n@@ -4254,6 +4325,18 @@ dependencies = [\n  \"unicode-xid 0.1.0\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+ \"unicode-xid 0.2.0\",\n+]\n+\n [[package]]\n name = \"syntax\"\n version = \"0.0.0\"\n@@ -4272,6 +4355,25 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"syntax_expand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"lazy_static 1.3.0\",\n+ \"log\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_index\",\n+ \"rustc_lexer\",\n+ \"rustc_target\",\n+ \"scoped-tls\",\n+ \"serialize\",\n+ \"smallvec\",\n+ \"syntax\",\n+ \"syntax_pos\",\n+]\n+\n [[package]]\n name = \"syntax_ext\"\n version = \"0.0.0\"\n@@ -4283,6 +4385,7 @@ dependencies = [\n  \"rustc_target\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n "}, {"sha": "b8071b98f707f43e7da2b4bb9410b876af1575e4", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -817,12 +817,22 @@ impl<'a> Builder<'a> {\n \n         let mut rustflags = Rustflags::new(&target);\n         if stage != 0 {\n+            if let Ok(s) = env::var(\"CARGOFLAGS_NOT_BOOTSTRAP\") {\n+                cargo.args(s.split_whitespace());\n+            }\n             rustflags.env(\"RUSTFLAGS_NOT_BOOTSTRAP\");\n         } else {\n+            if let Ok(s) = env::var(\"CARGOFLAGS_BOOTSTRAP\") {\n+                cargo.args(s.split_whitespace());\n+            }\n             rustflags.env(\"RUSTFLAGS_BOOTSTRAP\");\n             rustflags.arg(\"--cfg=bootstrap\");\n         }\n \n+        if let Ok(s) = env::var(\"CARGOFLAGS\") {\n+            cargo.args(s.split_whitespace());\n+        }\n+\n         match mode {\n             Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {"}, {"sha": "592477df02f4dafe98982b580dbea0acbb6c050c", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1126,7 +1126,7 @@ impl Build {\n         }\n \n         let mut paths = Vec::new();\n-        let contents = t!(fs::read(stamp));\n+        let contents = t!(fs::read(stamp), &stamp);\n         // This is the method we use for extracting paths from the stamp file passed to us. See\n         // run_cargo for more information (in compile.rs).\n         for part in contents.split(|b| *b == 0) {"}, {"sha": "fb308bc35ebc5e8519bb1a2b487b213f071f03e0", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -157,6 +157,7 @@ impl Step for Llvm {\n            .define(\"WITH_POLLY\", \"OFF\")\n            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+           .define(\"LLVM_ENABLE_BINDINGS\", \"OFF\")\n            .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n            .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n@@ -169,15 +170,6 @@ impl Step for Llvm {\n             }\n         }\n \n-        // By default, LLVM will automatically find OCaml and, if it finds it,\n-        // install the LLVM bindings in LLVM_OCAML_INSTALL_PATH, which defaults\n-        // to /usr/bin/ocaml.\n-        // This causes problem for non-root builds of Rust. Side-step the issue\n-        // by setting LLVM_OCAML_INSTALL_PATH to a relative path, so it installs\n-        // in the prefix.\n-        cfg.define(\"LLVM_OCAML_INSTALL_PATH\",\n-            env::var_os(\"LLVM_OCAML_INSTALL_PATH\").unwrap_or_else(|| \"usr/lib/ocaml\".into()));\n-\n         let want_lldb = builder.config.lldb_enabled && !self.emscripten;\n \n         // This setting makes the LLVM tools link to the dynamic LLVM library,"}, {"sha": "bb94fb2b755f53342b76fd3dbd28e0e223510196", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -21,6 +21,13 @@ macro_rules! t {\n             Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n         }\n     };\n+    // it can show extra info in the second parameter\n+    ($e:expr, $extra:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => panic!(\"{} failed with {} ({:?})\", stringify!($e), e, $extra),\n+        }\n+    };\n }\n \n // Because Cargo adds the compiler's dylib path to our library search path, llvm-config may"}, {"sha": "4442afc98e4064f22ccdb68a9eb1599ee9047491", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -124,14 +124,14 @@ jobs:\n         IMAGE: dist-x86_64-netbsd\n         DEPLOY: 1\n \n-      asmjs:\n-        IMAGE: asmjs\n       i686-gnu:\n         IMAGE: i686-gnu\n       i686-gnu-nopt:\n         IMAGE: i686-gnu-nopt\n       test-various:\n         IMAGE: test-various\n+      wasm32:\n+        IMAGE: wasm32\n       x86_64-gnu:\n         IMAGE: x86_64-gnu\n       x86_64-gnu-full-bootstrap:"}, {"sha": "a2d83eca24b0a6eb3634f17771d51072612e67be", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -165,18 +165,17 @@ For targets: `arm-unknown-linux-gnueabihf`\n For targets: `armv7-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Suffix to the arch-part = v7\n - Target options > Architecture level = armv7-a -- (+)\n - Target options > Use specific FPU = vfpv3-d16 -- (\\*)\n - Target options > Floating point = hardware (FPU) -- (\\*)\n - Target options > Default instruction set mode = thumb -- (\\*)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n (\\*) These options have been selected to match the configuration of the arm"}, {"sha": "e27a2a529a8ca8995fe35bda4f560dcacc25ddfc", "filename": "src/ci/docker/disabled/asmjs/Dockerfile", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -24,10 +24,15 @@ ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n-ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=asmjs-unknown-emscripten\n \n+# Use -O1 optimizations in the link step to reduce time spent optimizing JS.\n+ENV EMCC_CFLAGS=-O1\n+\n+# Emscripten installation is user-specific\n+ENV NO_CHANGE_USER=1\n+\n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n \n # This is almost identical to the wasm32-unknown-emscripten target, so", "previous_filename": "src/ci/docker/asmjs/Dockerfile"}, {"sha": "417171a861d4a01be92f41a29a6f7ceaa6499777", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n+COPY dist-armv7-linux/crosstool-ng.sh /scripts/\n RUN sh /scripts/crosstool-ng.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-armv7-linux/patches/ /tmp/patches/\n COPY dist-armv7-linux/build-toolchains.sh dist-armv7-linux/armv7-linux-gnueabihf.config /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "81b3d7477ec8d1537a5a9d787ca2bc6dc947a949", "filename": "src/ci/docker/dist-armv7-linux/armv7-linux-gnueabihf.config", "status": "modified", "additions": 493, "deletions": 306, "changes": 799, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,9 +1,32 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_python_3_4_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_dtc=y\n+CT_CONFIGURE_has_svn=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -21,40 +44,46 @@ CT_MODULES=y\n # Paths\n #\n CT_LOCAL_TARBALLS_DIR=\"\"\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -90,86 +119,81 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv7-a\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"vfpv3-d16\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-CT_ARCH_FLOAT_HW=y\n-# CT_ARCH_FLOAT_SW is not set\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"thumb\"\n+# CT_ARCH_ARM_MODE_ARM is not set\n+CT_ARCH_ARM_MODE_THUMB=y\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"v7\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv7-a\"\n+CT_ARCH_FPU=\"vfpv3-d16\"\n # CT_ARCH_FLOAT_AUTO is not set\n+CT_ARCH_FLOAT_HW=y\n # CT_ARCH_FLOAT_SOFTFP is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"hard\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"thumb\"\n-# CT_ARCH_ARM_MODE_ARM is not set\n-CT_ARCH_ARM_MODE_THUMB=y\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n-\n #\n # Toolchain options\n #\n@@ -182,7 +206,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -216,227 +242,279 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_29 is not set\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -465,97 +543,206 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+# CT_MPC_V_1_1 is not set\n+CT_MPC_V_1_0=y\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.0.3\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_older=y\n+CT_MPC_older_than_1_1_0=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_3_1=y\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"3.1.6\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_4_0_0_or_older=y\n+CT_MPFR_older_than_4_0_0=y\n+CT_MPFR_REQUIRE_older_than_4_0_0=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "ae737d9677d8716a60c4b667735f0a6a485f1ef9", "filename": "src/ci/docker/dist-armv7-linux/crosstool-ng.sh", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -0,0 +1,12 @@\n+set -ex\n+\n+# Mirrored from https://github.com/crosstool-ng/crosstool-ng/archive/crosstool-ng-1.24.0.tar.gz\n+url=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/crosstool-ng-1.24.0.tar.gz\"\n+curl -Lf $url | tar xzf -\n+cd crosstool-ng-crosstool-ng-1.24.0\n+./bootstrap\n+./configure --prefix=/usr/local\n+make -j$(nproc)\n+make install\n+cd ..\n+rm -rf crosstool-ng-crosstool-ng-1.24.0"}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armv7-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "bb72e33def21c107c7b4deb432629b72f2c4b424", "filename": "src/ci/docker/scripts/cross-apt-packages.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -22,5 +22,6 @@ apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   sudo \\\n   texinfo \\\n+  unzip \\\n   wget \\\n   xz-utils"}, {"sha": "1be80741594cc930619dcef37fd5768513e4c21f", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -21,13 +21,3 @@ git clone https://github.com/emscripten-core/emsdk.git /emsdk-portable\n cd /emsdk-portable\n hide_output ./emsdk install 1.38.46-upstream\n ./emsdk activate 1.38.46-upstream\n-\n-# Compile and cache libc\n-source ./emsdk_env.sh\n-echo \"main(){}\" > a.c\n-HOME=/emsdk-portable/ emcc a.c\n-rm -f a.*\n-\n-# Make emsdk usable by any user\n-cp /root/.emscripten /emsdk-portable\n-chmod a+rxw -R /emsdk-portable"}, {"sha": "a0f35afd995b3f1bb69e1f00664616e395fb13b8", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "renamed", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -24,11 +24,17 @@ ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n-ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=wasm32-unknown-emscripten\n \n-# FIXME: Re-enable these tests once Cargo stops trying to execute wasms\n+# Use -O1 optimizations in the link step to reduce time spent optimizing.\n+ENV EMCC_CFLAGS=-O1\n+\n+# Emscripten installation is user-specific\n+ENV NO_CHANGE_USER=1\n+\n+# FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n+# is picked up by CI\n ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n     --exclude src/libcore \\\n     --exclude src/liballoc \\", "previous_filename": "src/ci/docker/disabled/wasm32/Dockerfile"}, {"sha": "9bb8b161963fcebc9d9ccd732ba26f42108016d5", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1 +1 @@\n-Subproject commit 04806c80be0f54b1290287e3f85e84bdfc0b6ec7\n+Subproject commit 9bb8b161963fcebc9d9ccd732ba26f42108016d5"}, {"sha": "5004ad30d69f93553ceef74439fea2159d1f769e", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1 +1 @@\n-Subproject commit 4374786f0b4bf0606b35d5c30a9681f342e5707b\n+Subproject commit 5004ad30d69f93553ceef74439fea2159d1f769e"}, {"sha": "5b9d2fcefadfc32fceafacfc0dd9441d9b57dd94", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1 +1 @@\n-Subproject commit 320d232b206edecb67489316f71a14e31dbc6c08\n+Subproject commit 5b9d2fcefadfc32fceafacfc0dd9441d9b57dd94"}, {"sha": "0b111eaae36cc4b4997684be853882a59e2c7ca7", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1 +1 @@\n-Subproject commit a6288e7407a6c4c19ea29de6d43f40c803883f21\n+Subproject commit 0b111eaae36cc4b4997684be853882a59e2c7ca7"}, {"sha": "d5564fd798f39f373724269a1b029ceaf444ff98", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -10,6 +10,7 @@\n         - [Warn-by-default lints](lints/listing/warn-by-default.md)\n         - [Deny-by-default lints](lints/listing/deny-by-default.md)\n - [Codegen options](codegen-options/index.md)\n+- [JSON Output](json.md)\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)"}, {"sha": "b2cc65c11fd2ce5afe1444d19dcc256fc00a31ec", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -92,6 +92,7 @@ information about editions may be found in the [edition guide].\n [edition guide]: ../edition-guide/introduction.html\n \n ## `--emit`: specifies the types of output files to generate\n+ <a id=\"option-emit\"></a>\n \n This flag controls the types of output files generated by the compiler. It\n accepts a comma-separated list of values, and may be specified multiple times.\n@@ -241,12 +242,13 @@ The \"sysroot\" is where `rustc` looks for the crates that come with the Rust\n distribution; this flag allows that to be overridden.\n \n ## `--error-format`: control how errors are produced\n+ <a id=\"option-error-format\"></a>\n \n This flag lets you control the format of messages. Messages are printed to\n stderr. The valid options are:\n \n - `human` \u2014 Human-readable output. This is the default.\n-- `json` \u2014 Structured JSON output.\n+- `json` \u2014 Structured JSON output. See [the JSON chapter] for more detail.\n - `short` \u2014 Short, one-line messages.\n \n ## `--color`: configure coloring of output\n@@ -273,6 +275,7 @@ pathname syntax. For example `--remap-path-prefix foo=bar` will match\n `foo/lib.rs` but not `./foo/lib.rs`.\n \n ## `--json`: configure json messages printed by the compiler\n+ <a id=\"option-json\"></a>\n \n When the `--error-format=json` option is passed to rustc then all of the\n compiler's diagnostic output will be emitted in the form of JSON blobs. The\n@@ -305,9 +308,13 @@ to customize the output:\n Note that it is invalid to combine the `--json` argument with the `--color`\n argument, and it is required to combine `--json` with `--error-format=json`.\n \n+See [the JSON chapter] for more detail.\n+\n ## `@path`: load command-line flags from a path\n \n If you specify `@path` on the command-line, then it will open `path` and read\n command line options from it. These options are one per line; a blank line indicates\n an empty option. The file can use Unix or Windows style line endings, and must be\n encoded as UTF-8.\n+\n+[the JSON chapter]: json.md"}, {"sha": "b737849516310478fbfad3cfa86224b9c380e13d", "filename": "src/doc/rustc/src/json.md", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -0,0 +1,231 @@\n+# JSON Output\n+\n+This chapter documents the JSON structures emitted by `rustc`. JSON may be\n+enabled with the [`--error-format=json` flag][option-error-format]. Additional\n+options may be specified with the [`--json` flag][option-json] which can\n+change which messages are generated, and the format of the messages.\n+\n+JSON messages are emitted one per line to stderr.\n+\n+If parsing the output with Rust, the\n+[`cargo_metadata`](https://crates.io/crates/cargo_metadata) crate provides\n+some support for parsing the messages.\n+\n+When parsing, care should be taken to be forwards-compatible with future changes\n+to the format. Optional values may be `null`. New fields may be added. Enumerated\n+fields like \"level\" or \"suggestion_applicability\" may add new values.\n+\n+## Diagnostics\n+\n+Diagnostic messages provide errors or possible concerns generated during\n+compilation. `rustc` provides detailed information about where the diagnostic\n+originates, along with hints and suggestions.\n+\n+Diagnostics are arranged in a parent/child relationship where the parent\n+diagnostic value is the core of the diagnostic, and the attached children\n+provide additional context, help, and information.\n+\n+Diagnostics have the following format:\n+\n+```javascript\n+{\n+    /* The primary message. */\n+    \"message\": \"unused variable: `x`\",\n+    /* The diagnostic code.\n+       Some messages may set this value to null.\n+    */\n+    \"code\": {\n+        /* A unique string identifying which diagnostic triggered. */\n+        \"code\": \"unused_variables\",\n+        /* An optional string explaining more detail about the diagnostic code. */\n+        \"explanation\": null\n+    },\n+    /* The severity of the diagnostic.\n+       Values may be:\n+       - \"error\": A fatal error that prevents compilation.\n+       - \"warning\": A possible error or concern.\n+       - \"note\": Additional information or context about the diagnostic.\n+       - \"help\": A suggestion on how to resolve the diagnostic.\n+       - \"failure-note\": A note attached to the message for further information.\n+       - \"error: internal compiler error\": Indicates a bug within the compiler.\n+    */\n+    \"level\": \"warning\",\n+    /* An array of source code locations to point out specific details about\n+       where the diagnostic originates from. This may be empty, for example\n+       for some global messages, or child messages attached to a parent.\n+\n+       Character offsets are offsets of Unicode Scalar Values.\n+    */\n+    \"spans\": [\n+        {\n+            /* The file where the span is located.\n+               For spans located within a macro expansion, this will be the\n+               name of the expanded macro in the format \"<MACRONAME macros>\".\n+            */\n+            \"file_name\": \"lib.rs\",\n+            /* The byte offset where the span starts (0-based, inclusive). */\n+            \"byte_start\": 21,\n+            /* The byte offset where the span ends (0-based, exclusive). */\n+            \"byte_end\": 22,\n+            /* The first line number of the span (1-based, inclusive). */\n+            \"line_start\": 2,\n+            /* The last line number of the span (1-based, inclusive). */\n+            \"line_end\": 2,\n+            /* The first character offset of the line_start (1-based, inclusive). */\n+            \"column_start\": 9,\n+            /* The last character offset of the line_end (1-based, exclusive). */\n+            \"column_end\": 10,\n+            /* Whether or not this is the \"primary\" span.\n+\n+               This indicates that this span is the focal point of the\n+               diagnostic.\n+\n+               There are rare cases where multiple spans may be marked as\n+               primary. For example, \"immutable borrow occurs here\" and\n+               \"mutable borrow ends here\" can be two separate primary spans.\n+\n+               The top (parent) message should always have at least one\n+               primary span, unless it has zero spans. Child messages may have\n+               zero or more primary spans.\n+            */\n+            \"is_primary\": true,\n+            /* An array of objects showing the original source code for this\n+               span. This shows the entire lines of text where the span is\n+               located. A span across multiple lines will have a separate\n+               value for each line.\n+            */\n+            \"text\": [\n+                {\n+                    /* The entire line of the original source code. */\n+                    \"text\": \"    let x = 123;\",\n+                    /* The first character offset of the line of\n+                       where the span covers this line (1-based, inclusive). */\n+                    \"highlight_start\": 9,\n+                    /* The last character offset of the line of\n+                       where the span covers this line (1-based, exclusive). */\n+                    \"highlight_end\": 10\n+                }\n+            ],\n+            /* An optional message to display at this span location.\n+               This is typically null for primary spans.\n+            */\n+            \"label\": null,\n+            /* An optional string of a suggested replacement for this span to\n+               solve the issue. Tools may try to replace the contents of the\n+               span with this text.\n+            */\n+            \"suggested_replacement\": null,\n+            /* An optional string that indicates the confidence of the\n+               \"suggested_replacement\". Tools may use this value to determine\n+               whether or not suggestions should be automatically applied.\n+\n+               Possible values may be:\n+               - \"MachineApplicable\": The suggestion is definitely what the\n+                 user intended. This suggestion should be automatically\n+                 applied.\n+               - \"MaybeIncorrect\": The suggestion may be what the user\n+                 intended, but it is uncertain. The suggestion should result\n+                 in valid Rust code if it is applied.\n+               - \"HasPlaceholders\": The suggestion contains placeholders like\n+                 `(...)`. The suggestion cannot be applied automatically\n+                 because it will not result in valid Rust code. The user will\n+                 need to fill in the placeholders.\n+               - \"Unspecified\": The applicability of the suggestion is unknown.\n+            */\n+            \"suggestion_applicability\": null,\n+            /* An optional object indicating the expansion of a macro within\n+               this span.\n+\n+               If a message occurs within a macro invocation, this object will\n+               provide details of where within the macro expansion the message\n+               is located.\n+            */\n+            \"expansion\": {\n+                /* The span of the macro invocation.\n+                   Uses the same span definition as the \"spans\" array.\n+                */\n+                \"span\": {/*...*/}\n+                /* Name of the macro, such as \"foo!\" or \"#[derive(Eq)]\". */\n+                \"macro_decl_name\": \"some_macro!\",\n+                /* Optional span where the relevant part of the macro is\n+                  defined. */\n+                \"def_site_span\": {/*...*/},\n+            }\n+        }\n+    ],\n+    /* Array of attached diagnostic messages.\n+       This is an array of objects using the same format as the parent\n+       message. Children are not nested (children do not themselves\n+       contain \"children\" definitions).\n+    */\n+    \"children\": [\n+        {\n+            \"message\": \"`#[warn(unused_variables)]` on by default\",\n+            \"code\": null,\n+            \"level\": \"note\",\n+            \"spans\": [],\n+            \"children\": [],\n+            \"rendered\": null\n+        },\n+        {\n+            \"message\": \"consider prefixing with an underscore\",\n+            \"code\": null,\n+            \"level\": \"help\",\n+            \"spans\": [\n+                {\n+                    \"file_name\": \"lib.rs\",\n+                    \"byte_start\": 21,\n+                    \"byte_end\": 22,\n+                    \"line_start\": 2,\n+                    \"line_end\": 2,\n+                    \"column_start\": 9,\n+                    \"column_end\": 10,\n+                    \"is_primary\": true,\n+                    \"text\": [\n+                        {\n+                            \"text\": \"    let x = 123;\",\n+                            \"highlight_start\": 9,\n+                            \"highlight_end\": 10\n+                        }\n+                    ],\n+                    \"label\": null,\n+                    \"suggested_replacement\": \"_x\",\n+                    \"suggestion_applicability\": \"MachineApplicable\",\n+                    \"expansion\": null\n+                }\n+            ],\n+            \"children\": [],\n+            \"rendered\": null\n+        }\n+    ],\n+    /* Optional string of the rendered version of the diagnostic as displayed\n+       by rustc. Note that this may be influenced by the `--json` flag.\n+    */\n+    \"rendered\": \"warning: unused variable: `x`\\n --> lib.rs:2:9\\n  |\\n2 |     let x = 123;\\n  |         ^ help: consider prefixing with an underscore: `_x`\\n  |\\n  = note: `#[warn(unused_variables)]` on by default\\n\\n\"\n+}\n+```\n+\n+## Artifact notifications\n+\n+Artifact notifications are emitted when the [`--json=artifacts`\n+flag][option-json] is used. They indicate that a file artifact has been saved\n+to disk. More information about emit kinds may be found in the [`--emit`\n+flag][option-emit] documentation.\n+\n+```javascript\n+{\n+    /* The filename that was generated. */\n+    \"artifact\": \"libfoo.rlib\",\n+    /* The kind of artifact that was generated. Possible values:\n+       - \"link\": The generated crate as specified by the crate-type.\n+       - \"dep-info\": The `.d` file with dependency information in a Makefile-like syntax.\n+       - \"metadata\": The Rust `.rmeta` file containing metadata about the crate.\n+       - \"save-analysis\": A JSON file emitted by the `-Zsave-analysis` feature.\n+    */\n+    \"emit\": \"link\"\n+}\n+```\n+\n+[option-emit]: command-line-arguments.md#option-emit\n+[option-error-format]: command-line-arguments.md#option-error-format\n+[option-json]: command-line-arguments.md#option-json"}, {"sha": "5688e90ada129a8fa0fdc9942be4acff461767ae", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -222,3 +222,28 @@ error: invalid `crate_type` value\n   | ^^^^^^^^^^^^^^^^^^^^\n   |\n ```\n+\n+## const-err\n+\n+This lint detects expressions that will always panic at runtime and would be an\n+error in a `const` context.\n+\n+```rust,ignore\n+let _ = [0; 4][4];\n+```\n+\n+This will produce:\n+\n+```text\n+error: index out of bounds: the len is 4 but the index is 4\n+ --> src/lib.rs:1:9\n+  |\n+1 | let _ = [0; 4][4];\n+  |         ^^^^^^^^^\n+  |\n+```\n+\n+## order-dependent-trait-objects\n+\n+This lint detects a trait coherency violation that would allow creating two\n+trait impls for the same dynamic trait object involving marker traits."}, {"sha": "d066f4a9cf59c1040c8691b803b3d650f399944c", "filename": "src/doc/rustc/src/profile-guided-optimization.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -125,6 +125,17 @@ RUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n     cargo build --release --target=x86_64-unknown-linux-gnu\n ```\n \n+### Troubleshooting\n+\n+- It is recommended to pass `-Cllvm-args=-pgo-warn-missing-function` during the\n+  `-Cprofile-use` phase. LLVM by default does not warn if it cannot find\n+  profiling data for a given function. Enabling this warning will make it\n+  easier to spot errors in your setup.\n+\n+- There is a [known issue](https://github.com/rust-lang/cargo/issues/7416) in\n+  Cargo prior to version 1.39 that will prevent PGO from working correctly. Be\n+  sure to use Cargo 1.39 or newer when doing PGO.\n+\n ## Further Reading\n \n `rustc`'s PGO support relies entirely on LLVM's implementation of the feature"}, {"sha": "ed4e9c6b56842cef485f063c14092500e23c58f5", "filename": "src/doc/unstable-book/src/compiler-flags/report-time.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -0,0 +1,80 @@\n+# `report-time`\n+\n+The tracking issue for this feature is: [#64888]\n+\n+[#64888]: https://github.com/rust-lang/rust/issues/64888\n+\n+------------------------\n+\n+The `report-time` feature adds a possibility to report execution time of the\n+tests generated via `libtest`.\n+\n+This is unstable feature, so you have to provide `-Zunstable-options` to get\n+this feature working.\n+\n+Sample usage command:\n+\n+```sh\n+./test_executable -Zunstable-options --report-time\n+```\n+\n+Available options:\n+\n+```sh\n+--report-time [plain|colored]\n+                Show execution time of each test. Awailable values:\n+                plain = do not colorize the execution time (default);\n+                colored = colorize output according to the `color`\n+                parameter value;\n+                Threshold values for colorized output can be\n+                configured via\n+                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`\n+                and\n+                `RUST_TEST_TIME_DOCTEST` environment variables.\n+                Expected format of environment variable is\n+                `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+                Not available for --format=terse\n+--ensure-time \n+                Treat excess of the test execution time limit as\n+                error.\n+                Threshold values for this option can be configured via\n+                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`\n+                and\n+                `RUST_TEST_TIME_DOCTEST` environment variables.\n+                Expected format of environment variable is\n+                `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+                `CRITICAL_TIME` here means the limit that should not be\n+                exceeded by test.\n+```\n+\n+Example of the environment variable format:\n+\n+```sh\n+RUST_TEST_TIME_UNIT=100,200\n+```\n+\n+where 100 stands for warn time, and 200 stands for critical time.\n+\n+## Examples\n+\n+```sh\n+cargo test --tests -- -Zunstable-options --report-time\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n+     Running target/debug/deps/example-27fb188025bec02c\n+\n+running 3 tests\n+test tests::unit_test_quick ... ok <0.000s>\n+test tests::unit_test_warn ... ok <0.055s>\n+test tests::unit_test_critical ... ok <0.110s>\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+     Running target/debug/deps/tests-cedb06f6526d15d9\n+\n+running 3 tests\n+test unit_test_quick ... ok <0.000s>\n+test unit_test_warn ... ok <0.550s>\n+test unit_test_critical ... ok <1.100s>\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+```"}, {"sha": "afc11a2b9492cfa8ef06de26bebf2a1662a2d195", "filename": "src/doc/unstable-book/src/language-features/track-caller.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -0,0 +1,5 @@\n+# `track_caller`\n+\n+The tracking issue for this feature is: [#47809](https://github.com/rust-lang/rust/issues/47809).\n+\n+------------------------"}, {"sha": "567b8ea722491edbe2c9bfe9218b1632038dbc92", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -142,6 +142,9 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        if layout.size() == 0 {\n+            return Box(NonNull::dangling().into())\n+        }\n         let ptr = unsafe {\n             Global.alloc(layout)\n                 .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n@@ -182,9 +185,16 @@ impl<T> Box<[T]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let ptr = unsafe { alloc::alloc(layout) };\n-        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n-        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        let ptr = if layout.size() == 0 {\n+            NonNull::dangling()\n+        } else {\n+            unsafe {\n+                Global.alloc(layout)\n+                    .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+                    .cast()\n+            }\n+        };\n+        let slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), len) };\n         Box(Unique::from(slice))\n     }\n }\n@@ -871,11 +881,33 @@ impl<I: Iterator + ?Sized> Iterator for Box<I> {\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n         (**self).nth(n)\n     }\n+    fn last(self) -> Option<I::Item> {\n+        BoxIter::last(self)\n+    }\n+}\n+\n+trait BoxIter {\n+    type Item;\n+    fn last(self) -> Option<Self::Item>;\n+}\n+\n+impl<I: Iterator + ?Sized> BoxIter for Box<I> {\n+    type Item = I::Item;\n+    default fn last(self) -> Option<I::Item> {\n+        #[inline]\n+        fn some<T>(_: Option<T>, x: T) -> Option<T> {\n+            Some(x)\n+        }\n+\n+        self.fold(None, some)\n+    }\n }\n \n+/// Specialization for sized `I`s that uses `I`s implementation of `last()`\n+/// instead of the default.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator + Sized> Iterator for Box<I> {\n-    fn last(self) -> Option<I::Item> where I: Sized {\n+impl<I: Iterator> BoxIter for Box<I> {\n+    fn last(self) -> Option<I::Item> {\n         (*self).last()\n     }\n }"}, {"sha": "f0796354e00c384076f8a47a59f62b849556cd1e", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 119, "deletions": 120, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,7 +2,7 @@\n // to TreeMap\n \n use core::borrow::Borrow;\n-use core::cmp::Ordering::{self, Less, Greater, Equal};\n+use core::cmp::Ordering::{Less, Greater, Equal};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n@@ -109,6 +109,77 @@ pub struct Range<'a, T: 'a> {\n     iter: btree_map::Range<'a, T, ()>,\n }\n \n+/// Core of SymmetricDifference and Union.\n+/// More efficient than btree.map.MergeIter,\n+/// and crucially for SymmetricDifference, nexts() reports on both sides.\n+#[derive(Clone)]\n+struct MergeIterInner<I>\n+    where I: Iterator,\n+          I::Item: Copy,\n+{\n+    a: I,\n+    b: I,\n+    peeked: Option<MergeIterPeeked<I>>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum MergeIterPeeked<I: Iterator> {\n+    A(I::Item),\n+    B(I::Item),\n+}\n+\n+impl<I> MergeIterInner<I>\n+    where I: ExactSizeIterator + FusedIterator,\n+          I::Item: Copy + Ord,\n+{\n+    fn new(a: I, b: I) -> Self {\n+        MergeIterInner { a, b, peeked: None }\n+    }\n+\n+    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n+        let mut a_next = match self.peeked {\n+            Some(MergeIterPeeked::A(next)) => Some(next),\n+            _ => self.a.next(),\n+        };\n+        let mut b_next = match self.peeked {\n+            Some(MergeIterPeeked::B(next)) => Some(next),\n+            _ => self.b.next(),\n+        };\n+        let ord = match (a_next, b_next) {\n+            (None, None) => Equal,\n+            (_, None) => Less,\n+            (None, _) => Greater,\n+            (Some(a1), Some(b1)) => a1.cmp(&b1),\n+        };\n+        self.peeked = match ord {\n+            Less => b_next.take().map(MergeIterPeeked::B),\n+            Equal => None,\n+            Greater => a_next.take().map(MergeIterPeeked::A),\n+        };\n+        (a_next, b_next)\n+    }\n+\n+    fn lens(&self) -> (usize, usize) {\n+        match self.peeked {\n+            Some(MergeIterPeeked::A(_)) => (1 + self.a.len(), self.b.len()),\n+            Some(MergeIterPeeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n+            _ => (self.a.len(), self.b.len()),\n+        }\n+    }\n+}\n+\n+impl<I> Debug for MergeIterInner<I>\n+    where I: Iterator + Debug,\n+          I::Item: Copy + Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MergeIterInner\")\n+            .field(&self.a)\n+            .field(&self.b)\n+            .finish()\n+    }\n+}\n+\n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n ///\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n@@ -120,6 +191,7 @@ pub struct Range<'a, T: 'a> {\n pub struct Difference<'a, T: 'a> {\n     inner: DifferenceInner<'a, T>,\n }\n+#[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n         // iterate all of self and some of other, spotting matches along the way\n@@ -137,21 +209,7 @@ enum DifferenceInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => f\n-                .debug_tuple(\"Difference\")\n-                .field(&self_iter)\n-                .field(&other_iter)\n-                .finish(),\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set: _,\n-            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n-            DifferenceInner::Iterate(iter) => f.debug_tuple(\"Difference\").field(&iter).finish(),\n-        }\n+        f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n }\n \n@@ -163,18 +221,12 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"SymmetricDifference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"SymmetricDifference\").field(&self.0).finish()\n     }\n }\n \n@@ -189,6 +241,7 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n pub struct Intersection<'a, T: 'a> {\n     inner: IntersectionInner<'a, T>,\n }\n+#[derive(Debug)]\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n         // iterate similarly sized sets jointly, spotting matches along the way\n@@ -206,23 +259,7 @@ enum IntersectionInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            IntersectionInner::Stitch {\n-                a,\n-                b,\n-            } => f\n-                .debug_tuple(\"Intersection\")\n-                .field(&a)\n-                .field(&b)\n-                .finish(),\n-            IntersectionInner::Search {\n-                small_iter,\n-                large_set: _,\n-            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n-            IntersectionInner::Answer(answer) => {\n-                f.debug_tuple(\"Intersection\").field(&answer).finish()\n-            }\n-        }\n+        f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n }\n \n@@ -234,18 +271,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Union\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"Union\").field(&self.0).finish()\n     }\n }\n \n@@ -355,19 +386,16 @@ impl<T: Ord> BTreeSet<T> {\n                     self_iter.next_back();\n                     DifferenceInner::Iterate(self_iter)\n                 }\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        DifferenceInner::Search {\n-                            self_iter: self.iter(),\n-                            other_set: other,\n-                        }\n-                    } else {\n-                        DifferenceInner::Stitch {\n-                            self_iter: self.iter(),\n-                            other_iter: other.iter().peekable(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    DifferenceInner::Search {\n+                        self_iter: self.iter(),\n+                        other_set: other,\n                     }\n                 }\n+                _ => DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n             },\n         }\n     }\n@@ -396,10 +424,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn symmetric_difference<'a>(&'a self,\n                                     other: &'a BTreeSet<T>)\n                                     -> SymmetricDifference<'a, T> {\n-        SymmetricDifference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Visits the values representing the intersection,\n@@ -447,24 +472,22 @@ impl<T: Ord> BTreeSet<T> {\n                 (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n                 (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n                 (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: self.iter(),\n-                            large_set: other,\n-                        }\n-                    } else if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: other.iter(),\n-                            large_set: self,\n-                        }\n-                    } else {\n-                        IntersectionInner::Stitch {\n-                            a: self.iter(),\n-                            b: other.iter(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: self.iter(),\n+                        large_set: other,\n+                    }\n+                }\n+                _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: other.iter(),\n+                        large_set: self,\n                     }\n                 }\n+                _ => IntersectionInner::Stitch {\n+                    a: self.iter(),\n+                    b: other.iter(),\n+                },\n             },\n         }\n     }\n@@ -489,10 +512,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Clears the set, removing all values.\n@@ -1166,15 +1186,6 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None, _) => short,\n-        (_, None) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n@@ -1261,10 +1272,7 @@ impl<T: Ord> FusedIterator for Difference<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n     fn clone(&self) -> Self {\n-        SymmetricDifference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        SymmetricDifference(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1273,19 +1281,19 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => return self.b.next(),\n+            let (a_next, b_next) = self.0.nexts();\n+            if a_next.and(b_next).is_none() {\n+                return a_next.or(b_next);\n             }\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.a.len() + self.b.len()))\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add, because even if a and b refer to the same set,\n+        // and T is an empty type, the storage overhead of sets limits\n+        // the number of elements to less than half the range of usize.\n+        (0, Some(a_len + b_len))\n     }\n }\n \n@@ -1311,7 +1319,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n-                IntersectionInner::Answer(answer) => IntersectionInner::Answer(answer.clone()),\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(*answer),\n             },\n         }\n     }\n@@ -1365,30 +1373,21 @@ impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {\n     fn clone(&self) -> Self {\n-        Union {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        Union(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-            Less => self.a.next(),\n-            Equal => {\n-                self.b.next();\n-                self.a.next()\n-            }\n-            Greater => self.b.next(),\n-        }\n+        let (a_next, b_next) = self.0.nexts();\n+        a_next.or(b_next)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add - see SymmetricDifference::size_hint.\n         (max(a_len, b_len), Some(a_len + b_len))\n     }\n }"}, {"sha": "0bf573f5e2539fc8d84ddbc2a1c295c1fdb36626", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -10,8 +10,8 @@\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n-use core::iter::{repeat_with, FromIterator, FusedIterator};\n-use core::mem;\n+use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n+use core::mem::{self, replace};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -57,11 +57,88 @@ pub struct VecDeque<T> {\n     buf: RawVec<T>,\n }\n \n+/// PairSlices pairs up equal length slice parts of two deques\n+///\n+/// For example, given deques \"A\" and \"B\" with the following division into slices:\n+///\n+/// A: [0 1 2] [3 4 5]\n+/// B: [a b] [c d e]\n+///\n+/// It produces the following sequence of matching slices:\n+///\n+/// ([0 1], [a b])\n+/// ([2], [c])\n+/// ([3 4], [d e])\n+///\n+/// and the uneven remainder of either A or B is skipped.\n+struct PairSlices<'a, 'b, T> {\n+    a0: &'a mut [T],\n+    a1: &'a mut [T],\n+    b0: &'b [T],\n+    b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+        let (a0, a1) = to.as_mut_slices();\n+        let (b0, b1) = from.as_slices();\n+        PairSlices { a0, a1, b0, b1 }\n+    }\n+\n+    fn has_remainder(&self) -> bool {\n+        !self.b0.is_empty()\n+    }\n+\n+    fn remainder(self) -> impl Iterator<Item=&'b [T]> {\n+        once(self.b0).chain(once(self.b1))\n+    }\n+}\n+\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T>\n+{\n+    type Item = (&'a mut [T], &'b [T]);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // Get next part length\n+        let part = cmp::min(self.a0.len(), self.b0.len());\n+        if part == 0 {\n+            return None;\n+        }\n+        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n+        let (q0, q1) = self.b0.split_at(part);\n+\n+        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n+        self.a0 = p1;\n+        self.b0 = q1;\n+        if self.a0.is_empty() {\n+            self.a0 = replace(&mut self.a1, &mut []);\n+        }\n+        if self.b0.is_empty() {\n+            self.b0 = replace(&mut self.b1, &[]);\n+        }\n+        Some((p0, q0))\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.truncate(other.len());\n+\n+        let mut iter = PairSlices::from(self, other);\n+        while let Some((dst, src)) = iter.next() {\n+            dst.clone_from_slice(&src);\n+        }\n+\n+        if iter.has_remainder() {\n+            for remainder in iter.remainder() {\n+                self.extend(remainder.iter().cloned());\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2209,6 +2286,16 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         final_res\n     }\n \n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n@@ -2327,6 +2414,16 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         back.iter_mut().fold(accum, &mut f)\n     }\n \n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<&'a mut T> {\n         self.next_back()"}, {"sha": "d578ee0dac493fa922bd7d6d72f7c36f8d3184f8", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -361,6 +361,29 @@ fn test_vec_from_vecdeque() {\n     }\n }\n \n+#[test]\n+fn test_clone_from() {\n+    let m = vec![1; 8];\n+    let n = vec![2; 12];\n+    for pfv in 0..8 {\n+        for pfu in 0..8 {\n+            for longer in 0..2 {\n+                let (vr, ur) = if longer == 0 { (&m, &n) } else { (&n, &m) };\n+                let mut v = VecDeque::from(vr.clone());\n+                for _ in 0..pfv {\n+                    v.push_front(1);\n+                }\n+                let mut u = VecDeque::from(ur.clone());\n+                for _ in 0..pfu {\n+                    u.push_front(2);\n+                }\n+                v.clone_from(&u);\n+                assert_eq!(&v, &u);\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn issue_53529() {\n     use crate::boxed::Box;"}, {"sha": "cbfc55233a1e0e3902444dd66e3bd182cec11c17", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 198, "deletions": 191, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -80,24 +80,210 @@\n //! arguments which have names. Like with positional parameters, it is not\n //! valid to provide named parameters that are unused by the format string.\n //!\n-//! ## Argument types\n+//! # Formatting Parameters\n+//!\n+//! Each argument being formatted can be transformed by a number of formatting\n+//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters affect the string representation of what's being formatted.\n+//!\n+//! ## Width\n+//!\n+//! ```\n+//! // All of these print \"Hello x    !\"\n+//! println!(\"Hello {:5}!\", \"x\");\n+//! println!(\"Hello {:1$}!\", \"x\", 5);\n+//! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n+//! ```\n+//!\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space (see below).\n+//!\n+//! The value for the width can also be provided as a [`usize`] in the list of\n+//! parameters by adding a postfix `$`, indicating that the second argument is\n+//! a [`usize`] specifying the width.\n+//!\n+//! Referring to an argument with the dollar syntax does not affect the \"next\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n+//!\n+//! ## Fill/Alignment\n+//!\n+//! ```\n+//! assert_eq!(format!(\"Hello {:<5}!\", \"x\"),  \"Hello x    !\");\n+//! assert_eq!(format!(\"Hello {:-<5}!\", \"x\"), \"Hello x----!\");\n+//! assert_eq!(format!(\"Hello {:^5}!\", \"x\"),  \"Hello   x  !\");\n+//! assert_eq!(format!(\"Hello {:>5}!\", \"x\"),  \"Hello     x!\");\n+//! ```\n+//!\n+//! The optional fill character and alignment is provided normally in conjunction with the\n+//! [`width`](#width) parameter. It must be defined before `width`, right after the `:`.\n+//! This indicates that if the value being formatted is smaller than\n+//! `width` some extra characters will be printed around it.\n+//! Filling comes in the following variants for different alignments:\n+//!\n+//! * `[fill]<` - the argument is left-aligned in `width` columns\n+//! * `[fill]^` - the argument is center-aligned in `width` columns\n+//! * `[fill]>` - the argument is right-aligned in `width` columns\n+//!\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the `0` flag (see below) is specified for numerics, then the implicit fill character is\n+//! `0`.\n+//!\n+//! Note that alignment may not be implemented by some types. In particular, it\n+//! is not generally implemented for the `Debug` trait.  A good way to ensure\n+//! padding is applied is to format your input, then pad this resulting string\n+//! to obtain your output:\n+//!\n+//! ```\n+//! println!(\"Hello {:^15}!\", format!(\"{:?}\", Some(\"hi\"))); // => \"Hello   Some(\"hi\")   !\"\n+//! ```\n+//!\n+//! ## Sign/`#`/`0`\n+//!\n+//! ```\n+//! assert_eq!(format!(\"Hello {:+}!\", 5), \"Hello +5!\");\n+//! assert_eq!(format!(\"{:#x}!\", 27), \"0x1b!\");\n+//! assert_eq!(format!(\"Hello {:05}!\", 5),  \"Hello 00005!\");\n+//! assert_eq!(format!(\"Hello {:05}!\", -5), \"Hello -0005!\");\n+//! assert_eq!(format!(\"{:#010x}!\", 27), \"0x0000001b!\");\n+//! ```\n+//!\n+//! These are all flags altering the behavior of the formatter.\n+//!\n+//! * `+` - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n+//!         should always be printed.\n+//! * `-` - Currently not used\n+//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. The alternate forms are:\n+//!     * `#?` - pretty-print the [`Debug`] formatting\n+//!     * `#x` - precedes the argument with a `0x`\n+//!     * `#X` - precedes the argument with a `0x`\n+//!     * `#b` - precedes the argument with a `0b`\n+//!     * `#o` - precedes the argument with a `0o`\n+//! * `0` - This is used to indicate for integer formats that the padding to `width` should\n+//!         both be done with a `0` character as well as be sign-aware. A format\n+//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n+//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         and before the digits. When used together with the `#` flag, a similar\n+//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         the digits. The prefix is included in the total width.\n+//!\n+//! ## Precision\n+//!\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and that truncated\n+//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n+//!\n+//! For integral types, this is ignored.\n+//!\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! 1. An integer `.N`:\n+//!\n+//!    the integer `N` itself is the precision.\n+//!\n+//! 2. An integer or name followed by dollar sign `.N$`:\n+//!\n+//!    use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! 3. An asterisk `.*`:\n+//!\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n+//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n+//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n+//!\n+//! ```\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+//! ```\n //!\n-//! Each argument's type is dictated by the format string.\n-//! There are various parameters which require a particular type, however.\n-//! An example is the `{:.*}` syntax, which sets the number of decimal places\n-//! in floating-point types:\n+//! While these:\n //!\n //! ```\n-//! let formatted_number = format!(\"{:.*}\", 2, 1.234567);\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n //!\n-//! assert_eq!(\"1.23\", formatted_number)\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! Hello, `     123` has 3 right-aligned characters\n //! ```\n //!\n-//! If this syntax is used, then the number of characters to print precedes the\n-//! actual object being formatted, and the number of characters must have the\n-//! type [`usize`].\n+//! # Escaping\n+//!\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n //!\n-//! ## Formatting traits\n+//! ```\n+//! assert_eq!(format!(\"Hello {{}}\"), \"Hello {}\");\n+//! assert_eq!(format!(\"{{ Hello\"), \"{ Hello\");\n+//! ```\n+//!\n+//! # Syntax\n+//!\n+//! To summarize, here you can find the full grammar of format strings.\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with Python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n+//!\n+//! ```text\n+//! format_string := <text> [ maybe-format <text> ] *\n+//! maybe-format := '{' '{' | '}' '}' | <format>\n+//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! argument := integer | identifier\n+//!\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n+//! fill := character\n+//! align := '<' | '^' | '>'\n+//! sign := '+' | '-'\n+//! width := count\n+//! precision := count | '*'\n+//! type := identifier | '?' | ''\n+//! count := parameter | integer\n+//! parameter := argument '$'\n+//! ```\n+//!\n+//! # Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n@@ -220,7 +406,7 @@\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n //!\n-//! ## Related macros\n+//! # Related macros\n //!\n //! There are a number of related macros in the [`format!`] family. The ones that\n //! are currently implemented are:\n@@ -300,185 +486,6 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! # Syntax\n-//!\n-//! The syntax for the formatting language used is drawn from other languages,\n-//! so it should not be too alien. Arguments are formatted with Python-like\n-//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n-//! `%`. The actual grammar for the formatting syntax is:\n-//!\n-//! ```text\n-//! format_string := <text> [ maybe-format <text> ] *\n-//! maybe-format := '{' '{' | '}' '}' | <format>\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n-//! argument := integer | identifier\n-//!\n-//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n-//! fill := character\n-//! align := '<' | '^' | '>'\n-//! sign := '+' | '-'\n-//! width := count\n-//! precision := count | '*'\n-//! type := identifier | '?' | ''\n-//! count := parameter | integer\n-//! parameter := argument '$'\n-//! ```\n-//!\n-//! # Formatting Parameters\n-//!\n-//! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted.\n-//!\n-//! ## Fill/Alignment\n-//!\n-//! The fill character is provided normally in conjunction with the\n-//! [`width`](#width)\n-//! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra\n-//! characters are specified by `fill`, and the alignment can be one of the\n-//! following options:\n-//!\n-//! * `<` - the argument is left-aligned in `width` columns\n-//! * `^` - the argument is center-aligned in `width` columns\n-//! * `>` - the argument is right-aligned in `width` columns\n-//!\n-//! Note that alignment may not be implemented by some types. In particular, it\n-//! is not generally implemented for the `Debug` trait.  A good way to ensure\n-//! padding is applied is to format your input, then use this resulting string\n-//! to pad your output.\n-//!\n-//! ## Sign/`#`/`0`\n-//!\n-//! These can all be interpreted as flags for a particular formatter.\n-//!\n-//! * `+` - This is intended for numeric types and indicates that the sign\n-//!         should always be printed. Positive signs are never printed by\n-//!         default, and the negative sign is only printed by default for the\n-//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n-//!         should always be printed.\n-//! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used. The alternate forms are:\n-//!     * `#?` - pretty-print the [`Debug`] formatting\n-//!     * `#x` - precedes the argument with a `0x`\n-//!     * `#X` - precedes the argument with a `0x`\n-//!     * `#b` - precedes the argument with a `0b`\n-//!     * `#o` - precedes the argument with a `0o`\n-//! * `0` - This is used to indicate for integer formats that the padding should\n-//!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n-//!         same format would yield `-0000001` for the integer `-1`. Notice that\n-//!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n-//!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n-//!         the digits.\n-//!\n-//! ## Width\n-//!\n-//! This is a parameter for the \"minimum width\" that the format should take up.\n-//! If the value's string does not fill up this many characters, then the\n-//! padding specified by fill/alignment will be used to take up the required\n-//! space.\n-//!\n-//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n-//! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n-//! the `0` flag is specified for numerics, then the implicit fill character is\n-//! `0`.\n-//!\n-//! The value for the width can also be provided as a [`usize`] in the list of\n-//! parameters by using the dollar syntax indicating that the second argument is\n-//! a [`usize`] specifying the width, for example:\n-//!\n-//! ```\n-//! // All of these print \"Hello x    !\"\n-//! println!(\"Hello {:5}!\", \"x\");\n-//! println!(\"Hello {:1$}!\", \"x\", 5);\n-//! println!(\"Hello {1:0$}!\", 5, \"x\");\n-//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n-//! ```\n-//!\n-//! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to arguments by\n-//! position, or use named arguments.\n-//!\n-//! ## Precision\n-//!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n-//! longer than this width, then it is truncated down to this many characters and that truncated\n-//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n-//!\n-//! For integral types, this is ignored.\n-//!\n-//! For floating-point types, this indicates how many digits after the decimal point should be\n-//! printed.\n-//!\n-//! There are three possible ways to specify the desired `precision`:\n-//!\n-//! 1. An integer `.N`:\n-//!\n-//!    the integer `N` itself is the precision.\n-//!\n-//! 2. An integer or name followed by dollar sign `.N$`:\n-//!\n-//!    use format *argument* `N` (which must be a `usize`) as the precision.\n-//!\n-//! 3. An asterisk `.*`:\n-//!\n-//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n-//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n-//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n-//!\n-//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n-//!\n-//! ```\n-//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n-//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n-//!\n-//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n-//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n-//!\n-//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n-//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n-//! //                          specified in first of next two args (5)}\n-//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n-//! //                          specified in its predecessor (5)}\n-//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n-//! //                          in arg \"prec\" (5)}\n-//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n-//! ```\n-//!\n-//! While these:\n-//!\n-//! ```\n-//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n-//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n-//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n-//! ```\n-//!\n-//! print two significantly different things:\n-//!\n-//! ```text\n-//! Hello, `1234.560` has 3 fractional digits\n-//! Hello, `123` has 3 characters\n-//! Hello, `     123` has 3 right-aligned characters\n-//! ```\n-//!\n-//! # Escaping\n-//!\n-//! The literal characters `{` and `}` may be included in a string by preceding\n-//! them with the same character. For example, the `{` character is escaped with\n-//! `{{` and the `}` character is escaped with `}}`.\n-//!\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html"}, {"sha": "3684162d8b18741782e38e7ede8f13fa6088c417", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -121,7 +121,6 @@\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n-#![feature(mem_take)]\n #![feature(associated_type_bounds)]\n \n // Allow testing this library\n@@ -154,7 +153,7 @@ mod boxed {\n #[cfg(test)]\n mod tests;\n pub mod collections;\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"ptr\")]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "f1c4c32e116ea74dcc59bec6eb349841517662b4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -3,8 +3,9 @@\n //!\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n-//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n-//! given value is destroyed, the pointed-to value is also destroyed.\n+//! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n+//! given allocation is destroyed, the value stored in that allocation (often\n+//! referred to as \"inner value\") is also dropped.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n //! is no exception: you cannot generally obtain a mutable reference to\n@@ -21,8 +22,10 @@\n //!\n //! The [`downgrade`][downgrade] method can be used to create a non-owning\n //! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n-//! to an [`Rc`], but this will return [`None`] if the value has\n-//! already been dropped.\n+//! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n+//! already been dropped. In other words, `Weak` pointers do not keep the value\n+//! inside the allocation alive; however, they *do* keep the allocation\n+//! (the backing store for the inner value) alive.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n //! [`Weak`] is used to break cycles. For example, a tree could have strong\n@@ -41,13 +44,13 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n-//! already been destroyed.\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n+//! already been dropped.\n //!\n //! # Cloning references\n //!\n-//! Creating a new reference from an existing reference counted pointer is done using the\n-//! `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n+//! Creating a new reference to the same allocation as an existing reference counted pointer\n+//! is done using the `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -93,7 +96,7 @@\n //!     );\n //!\n //!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n-//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // gives us a new pointer to the same `Owner` allocation, incrementing\n //!     // the reference count in the process.\n //!     let gadget1 = Gadget {\n //!         id: 1,\n@@ -110,8 +113,8 @@\n //!     // Despite dropping `gadget_owner`, we're still able to print out the name\n //!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n //!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n-//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n-//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n+//!     // live. The field projection `gadget1.owner.name` works because\n //!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n@@ -124,9 +127,9 @@\n //!\n //! If our requirements change, and we also need to be able to traverse from\n //! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n-//! to `Gadget` introduces a cycle between the values. This means that their\n-//! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n+//! to `Gadget` introduces a cycle. This means that their\n+//! reference counts can never reach 0, and the allocation will never be destroyed:\n+//! a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n@@ -193,10 +196,10 @@\n //!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n-//!         // guarantee the value is still allocated, we need to call\n+//!         // guarantee the allocation still exists, we need to call\n //!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n //!         //\n-//!         // In this case we know the value still exists, so we simply\n+//!         // In this case we know the allocation still exists, so we simply\n //!         // `unwrap` the `Option`. In a more complicated program, you might\n //!         // need graceful error handling for a `None` result.\n //!\n@@ -365,7 +368,7 @@ impl<T> Rc<T> {\n         unsafe { Pin::new_unchecked(Rc::new(value)) }\n     }\n \n-    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n     /// passed in.\n@@ -446,7 +449,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -485,7 +488,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -604,7 +607,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -625,7 +628,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -645,7 +648,7 @@ impl<T: ?Sized> Rc<T> {\n         this.weak() - 1\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -664,22 +667,22 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n-    /// this inner value.\n+    /// this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Rc`, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -710,7 +713,7 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Rc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -719,7 +722,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Rc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Rc::new`.\n@@ -745,8 +748,8 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Rc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Rc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -760,6 +763,8 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -768,12 +773,12 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n-    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// If there are other `Rc` pointers to the same allocation, then `make_mut` will\n+    /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n     /// referred to as clone-on-write.\n     ///\n-    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n-    /// pointers to this value will be dissassociated.\n+    /// If there are no other `Rc` pointers to this allocation, then [`Weak`]\n+    /// pointers to this allocation will be disassociated.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n@@ -794,12 +799,12 @@ impl<T: Clone> Rc<T> {\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n     /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n     ///\n-    /// [`Weak`] pointers will be dissassociated:\n+    /// [`Weak`] pointers will be disassociated:\n     ///\n     /// ```\n     /// use std::rc::Rc;\n@@ -837,7 +842,7 @@ impl<T: Clone> Rc<T> {\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n-        // reference to the inner value.\n+        // reference to the allocation.\n         unsafe {\n             &mut this.ptr.as_mut().value\n         }\n@@ -878,7 +883,7 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n@@ -908,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n-    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -1111,7 +1116,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n impl<T: ?Sized> Clone for Rc<T> {\n     /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -1172,6 +1177,8 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n@@ -1189,9 +1196,11 @@ impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are equal if their inner values are equal.\n+    /// Two `Rc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// always equal.\n     ///\n     /// # Examples\n@@ -1212,7 +1221,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// never unequal.\n     ///\n     /// # Examples\n@@ -1541,17 +1551,18 @@ impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n }\n \n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Rc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Rc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Rc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Rc`] pointers, since mutual owning references\n /// would never allow either [`Rc`] to be dropped. For example, a tree could\n /// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -1750,10 +1761,10 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Rc`]: struct.Rc.html\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1787,7 +1798,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1801,11 +1812,11 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of `Weak` pointers pointing to this value.\n+    /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return `None`. If\n     /// not, the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1830,14 +1841,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1869,6 +1880,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Rc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1918,7 +1931,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "08243ef7c519f1fdb500347d8249169fe183c120", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -411,20 +411,16 @@ impl<T> [T] {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(repeat_generic_slice)]\n     /// assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n     /// ```\n     ///\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n-    /// #![feature(repeat_generic_slice)]\n     /// // this will panic at runtime\n     /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n-    #[unstable(feature = \"repeat_generic_slice\",\n-               reason = \"it's on str, why not on slice?\",\n-               issue = \"48784\")]\n+    #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n         if n == 0 {\n             return Vec::new();"}, {"sha": "69f8f71197c1f24e826d62c71a2c1f179350c92a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -45,10 +45,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The type `Arc<T>` provides shared ownership of a value of type `T`,\n /// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n-/// a new `Arc` instance, which points to the same value on the heap as the\n+/// a new `Arc` instance, which points to the same allocation on the heap as the\n /// source `Arc`, while increasing a reference count. When the last `Arc`\n-/// pointer to a given value is destroyed, the pointed-to value is also\n-/// destroyed.\n+/// pointer to a given allocation is destroyed, the value stored in that allocation (often\n+/// referred to as \"inner value\") is also dropped.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n /// exception: you cannot generally obtain a mutable reference to something\n@@ -61,7 +61,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n /// counting. This means that it is thread-safe. The disadvantage is that\n /// atomic operations are more expensive than ordinary memory accesses. If you\n-/// are not sharing reference-counted values between threads, consider using\n+/// are not sharing reference-counted allocations between threads, consider using\n /// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n /// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n /// However, a library might choose `Arc<T>` in order to give library consumers\n@@ -85,8 +85,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n /// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`] if the value has already been\n-/// dropped.\n+/// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n+/// already been dropped. In other words, `Weak` pointers do not keep the value\n+/// inside the allocation alive; however, they *do* keep the allocation\n+/// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n /// [`Weak`][weak] is used to break cycles. For example, a tree could have\n@@ -121,8 +123,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n-/// already been destroyed.\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// already been dropped.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n@@ -221,17 +223,18 @@ impl<T: ?Sized> Arc<T> {\n }\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Arc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Arc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Arc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Arc`] pointers, since mutual owning references\n /// would never allow either [`Arc`] to be dropped. For example, a tree could\n /// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -345,7 +348,7 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n-    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n     /// passed in.\n@@ -426,7 +429,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -465,7 +468,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -584,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n         unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -628,7 +631,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -659,7 +662,7 @@ impl<T: ?Sized> Arc<T> {\n         if cnt == usize::MAX { 0 } else { cnt - 1 }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -710,8 +713,8 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Arc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Arc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -725,14 +728,16 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(Arc::ptr_eq(&five, &same_five));\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n@@ -761,7 +766,7 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n-    /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n+    /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -903,7 +908,7 @@ impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -965,15 +970,19 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n+    /// to ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// Note that this differs from the behavior of [`Rc::make_mut`] which disassociates\n+    /// any remaining `Weak` pointers.\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     /// [get_mut]: struct.Arc.html#method.get_mut\n+    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n     ///\n     /// # Examples\n     ///\n@@ -988,7 +997,7 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -1048,14 +1057,14 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Arc`, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`][option] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [option]: ../../std/option/enum.Option.html\n@@ -1091,7 +1100,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Arc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -1100,7 +1109,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Arc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Arc::new`.\n@@ -1424,10 +1433,10 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Arc`]: struct.Arc.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1482,7 +1491,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1497,17 +1506,17 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n-    /// value.\n+    /// allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0. If not,\n     /// the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// # Accuracy\n     ///\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n-    /// `Weak`s pointing to the same value.\n+    /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1548,14 +1557,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1587,6 +1596,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Arc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1596,7 +1607,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1726,6 +1737,8 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Arc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n@@ -1743,10 +1756,11 @@ impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are equal if their inner values are equal.\n+    /// Two `Arc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// always equal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same allocation are always equal.\n     ///\n     /// # Examples\n     ///\n@@ -1766,8 +1780,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// never unequal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same value are never unequal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "bc3d53bf30da37446fac708800e0abe71cd25962", "filename": "src/liballoc/tests/boxed.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -0,0 +1,18 @@\n+use std::ptr::NonNull;\n+use std::mem::MaybeUninit;\n+\n+#[test]\n+fn unitialized_zero_size_box() {\n+    assert_eq!(\n+        &*Box::<()>::new_uninit() as *const _,\n+        NonNull::<MaybeUninit<()>>::dangling().as_ptr(),\n+    );\n+    assert_eq!(\n+        Box::<[()]>::new_uninit_slice(4).as_ptr(),\n+        NonNull::<MaybeUninit<()>>::dangling().as_ptr(),\n+    );\n+    assert_eq!(\n+        Box::<[String]>::new_uninit_slice(0).as_ptr(),\n+        NonNull::<MaybeUninit<String>>::dangling().as_ptr(),\n+    );\n+}"}, {"sha": "e4883abc8b56c3362d1fd4726f0d73746f430971", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -221,6 +221,18 @@ fn test_symmetric_difference() {\n                                &[-2, 1, 5, 11, 14, 22]);\n }\n \n+#[test]\n+fn test_symmetric_difference_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.symmetric_difference(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(4)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(1)));\n+}\n+\n #[test]\n fn test_union() {\n     fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n@@ -235,6 +247,18 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+fn test_union_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.union(&y);\n+    assert_eq!(iter.size_hint(), (3, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (2, Some(4)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+}\n+\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n@@ -244,7 +268,7 @@ fn test_is_disjoint() {\n }\n \n #[test]\n-// Also tests the trivial function definition of is_superset\n+// Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n         let set_a = a.iter().collect::<BTreeSet<_>>();"}, {"sha": "676874c8b27df07666641a6fada446d60cc8bf1a", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,9 +2,9 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(new_uninit)]\n #![feature(option_flattening)]\n #![feature(pattern)]\n-#![feature(repeat_generic_slice)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n@@ -15,6 +15,7 @@ use std::collections::hash_map::DefaultHasher;\n \n mod arc;\n mod binary_heap;\n+mod boxed;\n mod btree;\n mod cow_str;\n mod fmt;"}, {"sha": "abcba0c2e8479a314a6ae30552ce3053e1ffd82f", "filename": "src/liballoc/tests/str.rs.rej", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Fliballoc%2Ftests%2Fstr.rs.rej", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Fliballoc%2Ftests%2Fstr.rs.rej", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs.rej?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,10 +0,0 @@\n-diff a/src/liballoc/tests/str.rs b/src/liballoc/tests/str.rs\t(rejected hunks)\n-@@ -483,7 +483,7 @@ mod slice_index {\n-     }\n- \n-     #[test]\n--    #[cfg(not(target_arch = \"asmjs\"))] // hits an OOM\n-+    #[cfg(not(target_arch = \"js\"))] // hits an OOM\n-     #[cfg(not(miri))] // Miri is too slow\n-     fn simple_big() {\n-         fn a_million_letter_x() -> String {"}, {"sha": "e2704e807d104bd42378db2b496e5d5abf1fdd7a", "filename": "src/libcore/any.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,14 +2,14 @@\n //! of any `'static` type through runtime reflection.\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used\n-//! as a trait object. As `&Any` (a borrowed trait object), it has the `is` and\n-//! `downcast_ref` methods, to test if the contained value is of a given type,\n-//! and to get a reference to the inner value as a type. As `&mut Any`, there\n+//! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n+//! and `downcast_ref` methods, to test if the contained value is of a given type,\n+//! and to get a reference to the inner value as a type. As `&mut dyn Any`, there\n //! is also the `downcast_mut` method, for getting a mutable reference to the\n-//! inner value. `Box<Any>` adds the `downcast` method, which attempts to\n+//! inner value. `Box<dyn Any>` adds the `downcast` method, which attempts to\n //! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n //!\n-//! Note that &Any is limited to testing whether a value is of a specified\n+//! Note that `&dyn Any` is limited to testing whether a value is of a specified\n //! concrete type, and cannot be used to test whether a type implements a trait.\n //!\n //! [`Box`]: ../../std/boxed/struct.Box.html\n@@ -445,6 +445,15 @@ impl TypeId {\n ///\n /// The current implementation uses the same infrastructure as compiler\n /// diagnostics and debuginfo, but this is not guaranteed.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// assert_eq!(\n+///     std::any::type_name::<Option<String>>(),\n+///     \"core::option::Option<alloc::string::String>\",\n+/// );\n+/// ```\n #[stable(feature = \"type_name\", since = \"1.38.0\")]\n #[rustc_const_unstable(feature = \"const_type_name\")]\n pub const fn type_name<T: ?Sized>() -> &'static str {"}, {"sha": "fda103a52d8bc851b8fa4d07f277eb27302d425f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -229,52 +229,6 @@ pub struct Cell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n-impl<T:Copy> Cell<T> {\n-    /// Returns a copy of the contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// let five = c.get();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> T {\n-        unsafe{ *self.value.get() }\n-    }\n-\n-    /// Updates the contained value using a function and returns the new value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(cell_update)]\n-    ///\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    /// let new = c.update(|x| x + 1);\n-    ///\n-    /// assert_eq!(new, 6);\n-    /// assert_eq!(c.get(), 6);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n-    pub fn update<F>(&self, f: F) -> T\n-    where\n-        F: FnOnce(T) -> T,\n-    {\n-        let old = self.get();\n-        let new = f(old);\n-        self.set(new);\n-        new\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n \n@@ -448,6 +402,52 @@ impl<T> Cell<T> {\n     }\n }\n \n+impl<T:Copy> Cell<T> {\n+    /// Returns a copy of the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let five = c.get();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> T {\n+        unsafe{ *self.value.get() }\n+    }\n+\n+    /// Updates the contained value using a function and returns the new value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_update)]\n+    ///\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let new = c.update(|x| x + 1);\n+    ///\n+    /// assert_eq!(new, 6);\n+    /// assert_eq!(c.get(), 6);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n+    pub fn update<F>(&self, f: F) -> T\n+    where\n+        F: FnOnce(T) -> T,\n+    {\n+        let old = self.get();\n+        let new = f(old);\n+        self.set(new);\n+        new\n+    }\n+}\n+\n impl<T: ?Sized> Cell<T> {\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///"}, {"sha": "971d89e004446e306a1ad424c43375e36f6d07b4", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 109, "deletions": 63, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -116,9 +116,9 @@ impl char {\n \n         // the code is split up here to improve execution speed for cases where\n         // the `radix` is constant and 10 or smaller\n-        let val = if radix <= 10  {\n+        let val = if radix <= 10 {\n             match self {\n-                '0' ..= '9' => self as u32 - '0' as u32,\n+                '0'..='9' => self as u32 - '0' as u32,\n                 _ => return None,\n             }\n         } else {\n@@ -130,8 +130,11 @@ impl char {\n             }\n         };\n \n-        if val < radix { Some(val) }\n-        else { None }\n+        if val < radix {\n+            Some(val)\n+        } else {\n+            None\n+        }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -303,8 +306,8 @@ impl char {\n             '\\r' => EscapeDefaultState::Backslash('r'),\n             '\\n' => EscapeDefaultState::Backslash('n'),\n             '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20' ..= '\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n+            '\\x20'..='\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode()),\n         };\n         EscapeDefault { state: init_state }\n     }\n@@ -436,30 +439,31 @@ impl char {\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n         unsafe {\n-            let len =\n-            if code < MAX_ONE_B && !dst.is_empty() {\n+            let len = if code < MAX_ONE_B && !dst.is_empty() {\n                 *dst.get_unchecked_mut(0) = code as u8;\n                 1\n             } else if code < MAX_TWO_B && dst.len() >= 2 {\n                 *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n                 *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n                 2\n-            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+            } else if code < MAX_THREE_B && dst.len() >= 3 {\n                 *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(1) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n                 3\n             } else if dst.len() >= 4 {\n                 *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n                 *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n                 4\n             } else {\n-                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf8(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             };\n             from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n         }\n@@ -515,15 +519,24 @@ impl char {\n                 *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n                 slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n             } else {\n-                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf16(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             }\n         }\n     }\n \n-    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` has the `Alphabetic` property.\n+    ///\n+    /// `Alphabetic` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -547,10 +560,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is lowercase.\n+    /// Returns `true` if this `char` has the `Lowercase` property.\n     ///\n-    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n+    /// `Lowercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -575,10 +592,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is uppercase.\n+    /// Returns `true` if this `char` has the `Uppercase` property.\n+    ///\n+    /// `Uppercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n     ///\n-    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -603,10 +624,12 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is whitespace.\n+    /// Returns `true` if this `char` has the `White_Space` property.\n     ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n-    /// Property `White_Space`.\n+    /// `White_Space` is specified in the [Unicode Character Database][ucd] [`PropList.txt`].\n+    ///\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`PropList.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n     ///\n     /// # Examples\n     ///\n@@ -630,10 +653,10 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is alphanumeric.\n+    /// Returns `true` if this `char` satisfies either [`is_alphabetic()`] or [`is_numeric()`].\n     ///\n-    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No` and the Derived Core Property `Alphabetic`.\n+    /// [`is_alphabetic()`]: #method.is_alphabetic\n+    /// [`is_numeric()`]: #method.is_numeric\n     ///\n     /// # Examples\n     ///\n@@ -655,10 +678,15 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns `true` if this `char` is a control code point.\n+    /// Returns `true` if this `char` has the general category for control codes.\n+    ///\n+    /// Control codes (code points with the general category of `Cc`) are described in Chapter 4\n+    /// (Character Properties) of the [Unicode Standard] and specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Control code point' is defined in terms of the Unicode General\n-    /// Category `Cc`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -675,19 +703,29 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns `true` if this `char` is an extended grapheme character.\n+    /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n     ///\n-    /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n-    /// Category `Grapheme_Extend`.\n+    /// `Grapheme_Extend` is described in [Unicode Standard Annex #29 (Unicode Text\n+    /// Segmentation)][uax29] and specified in the [Unicode Character Database][ucd]\n+    /// [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [uax29]: https://www.unicode.org/reports/tr29/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     #[inline]\n     pub(crate) fn is_grapheme_extended(self) -> bool {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns `true` if this `char` is numeric.\n+    /// Returns `true` if this `char` has one of the general categories for numbers.\n+    ///\n+    /// The general categories for numbers (`Nd` for decimal digits, `Nl` for letter-like numeric\n+    /// characters, and `No` for other numeric characters) are specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -713,25 +751,29 @@ impl char {\n         }\n     }\n \n-    /// Returns an iterator that yields the lowercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the lowercase mapping of this `char` as one or more\n+    /// `char`s.\n     ///\n-    /// If a character does not have a lowercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// If this `char` does not have a lowercase mapping, the iterator yields the same `char`.\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its lowercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` has a one-to-one lowercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n+    ///\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///\n@@ -774,25 +816,29 @@ impl char {\n         ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n-    /// Returns an iterator that yields the uppercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the uppercase mapping of this `char` as one or more\n+    /// `char`s.\n+    ///\n+    /// If this `char` does not have a uppercase mapping, the iterator yields the same `char`.\n+    ///\n+    /// If this `char` has a one-to-one uppercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// If a character does not have an uppercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its uppercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///"}, {"sha": "e6e3454b36f810bb96cf2c525059182aa3eb69c9", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -775,10 +775,10 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n                reason = \"recently added\",\n                issue = \"62482\")]\n     pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n-        assert!(!self.has_key, \"attempted to begin a new map entry \\\n-                                without completing the previous one\");\n-\n         self.result = self.result.and_then(|_| {\n+            assert!(!self.has_key, \"attempted to begin a new map entry \\\n+                                    without completing the previous one\");\n+\n             if self.is_pretty() {\n                 if !self.has_fields {\n                     self.fmt.write_str(\"\\n\")?;\n@@ -839,9 +839,9 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n                reason = \"recently added\",\n                issue = \"62482\")]\n     pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n-        assert!(self.has_key, \"attempted to format a map value before its key\");\n-\n         self.result = self.result.and_then(|_| {\n+            assert!(self.has_key, \"attempted to format a map value before its key\");\n+\n             if self.is_pretty() {\n                 let mut slot = None;\n                 let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n@@ -924,9 +924,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n-        assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n+        self.result.and_then(|_| {\n+            assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n \n-        self.result.and_then(|_| self.fmt.write_str(\"}\"))\n+            self.fmt.write_str(\"}\")\n+        })\n     }\n \n     fn is_pretty(&self) -> bool {"}, {"sha": "8413b2e0ac49e0f2f2aad0841f7944affe370ccb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -108,10 +108,10 @@ pub struct Error;\n /// [`io::Write`]: ../../std/io/trait.Write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n-    /// Writes a slice of bytes into this writer, returning whether the write\n+    /// Writes a string slice into this writer, returning whether the write\n     /// succeeded.\n     ///\n-    /// This method can only succeed if the entire byte slice was successfully\n+    /// This method can only succeed if the entire string slice was successfully\n     /// written, and this method will not return until all data has been\n     /// written or an error occurs.\n     ///"}, {"sha": "30e8dddff85ad47617060586fe10fd6b1fa9e047", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -127,7 +127,6 @@\n #![feature(adx_target_feature)]\n #![feature(maybe_uninit_slice)]\n #![feature(external_doc)]\n-#![feature(mem_take)]\n #![feature(associated_type_bounds)]\n \n #[prelude_import]"}, {"sha": "1320e63df0635289d00b1ba756bb35182605de92", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -520,57 +520,74 @@ macro_rules! unreachable {\n     });\n }\n \n-/// Indicates unfinished code.\n+/// Indicates unfinished code by panicking with a message of \"not yet implemented\".\n ///\n-/// This can be useful if you are prototyping and are just looking to have your\n-/// code type-check, or if you're implementing a trait that requires multiple\n-/// methods, and you're only planning on using one of them.\n+/// This allows the your code to type-check, which is useful if you are prototyping or\n+/// implementing a trait that requires multiple methods which you don't plan of using all of.\n ///\n /// There is no difference between `unimplemented!` and `todo!` apart from the\n /// name.\n ///\n /// # Panics\n ///\n-/// This will always [panic!](macro.panic.html)\n+/// This will always [panic!](macro.panic.html) because `unimplemented!` is just a\n+/// shorthand for `panic!` with a fixed, specific message.\n+///\n+/// Like `panic!`, this macro has a second form for displaying custom values.\n ///\n /// # Examples\n ///\n /// Here's an example of some in-progress code. We have a trait `Foo`:\n ///\n /// ```\n /// trait Foo {\n-///     fn bar(&self);\n+///     fn bar(&self) -> u8;\n ///     fn baz(&self);\n+///     fn qux(&self) -> Result<u64, ()>;\n /// }\n /// ```\n ///\n-/// We want to implement `Foo` on one of our types, but we also want to work on\n-/// just `bar()` first. In order for our code to compile, we need to implement\n-/// `baz()`, so we can use `unimplemented!`:\n+/// We want to implement `Foo` for 'MyStruct', but so far we only know how to\n+/// implement the `bar()` function. `baz()` and `qux()` will still need to be defined\n+/// in our implementation of `Foo`, but we can use `unimplemented!` in their definitions\n+/// to allow our code to compile.\n+///\n+/// In the meantime, we want to have our program stop running once these\n+/// unimplemented functions are reached.\n ///\n /// ```\n /// # trait Foo {\n-/// #     fn bar(&self);\n+/// #     fn bar(&self) -> u8;\n /// #     fn baz(&self);\n+/// #     fn qux(&self) -> Result<u64, ()>;\n /// # }\n /// struct MyStruct;\n ///\n /// impl Foo for MyStruct {\n-///     fn bar(&self) {\n-///         // implementation goes here\n+///     fn bar(&self) -> u8 {\n+///         1 + 1\n ///     }\n ///\n ///     fn baz(&self) {\n-///         // let's not worry about implementing baz() for now\n+///         // We aren't sure how to even start writing baz yet,\n+///         // so we have no logic here at all.\n+///         // This will display \"thread 'main' panicked at 'not yet implemented'\".\n ///         unimplemented!();\n ///     }\n+///\n+///     fn qux(&self) -> Result<u64, ()> {\n+///         let n = self.bar();\n+///         // We have some logic here,\n+///         // so we can use unimplemented! to display what we have so far.\n+///         // This will display:\n+///         // \"thread 'main' panicked at 'not yet implemented: we need to divide by 2'\".\n+///         unimplemented!(\"we need to divide by {}\", n);\n+///     }\n /// }\n ///\n /// fn main() {\n ///     let s = MyStruct;\n ///     s.bar();\n-///\n-///     // we aren't even using baz() yet, so this is fine.\n /// }\n /// ```\n #[macro_export]"}, {"sha": "c7da56aad309a976f9291effb656acda9364a1dc", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -236,7 +236,7 @@ pub fn forget_unsized<T: ?Sized>(t: T) {\n /// ```\n ///\n /// [alignment]: ./fn.align_of.html\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn size_of<T>() -> usize {\n@@ -328,7 +328,7 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// assert_eq!(4, mem::align_of::<i32>());\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn align_of<T>() -> usize {\n@@ -520,8 +520,6 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// A simple example:\n ///\n /// ```\n-/// #![feature(mem_take)]\n-///\n /// use std::mem;\n ///\n /// let mut v: Vec<i32> = vec![1, 2];\n@@ -552,8 +550,6 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// `self`, allowing it to be returned:\n ///\n /// ```\n-/// #![feature(mem_take)]\n-///\n /// use std::mem;\n ///\n /// # struct Buffer<T> { buf: Vec<T> }\n@@ -572,7 +568,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n ///\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n-#[unstable(feature = \"mem_take\", issue = \"61129\")]\n+#[stable(feature = \"mem_take\", since = \"1.40.0\")]\n pub fn take<T: Default>(dest: &mut T) -> T {\n     replace(dest, T::default())\n }"}, {"sha": "8f4ade377e312c013b384f2134c3876e50560501", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1058,7 +1058,7 @@ $EndFeature, \"\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or_else(|| {\n-                    if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n+                    if (self < 0) == (rhs < 0) {\n                         Self::max_value()\n                     } else {\n                         Self::min_value()\n@@ -1864,7 +1864,7 @@ if `self < 0`, this is equal to round towards +/- infinity.\n \n # Panics\n \n-This function will panic if `rhs` is 0.\n+This function will panic if `rhs` is 0 or the division results in overflow.\n \n # Examples\n \n@@ -1903,7 +1903,7 @@ This is done as if by the Euclidean division algorithm -- given\n \n # Panics\n \n-This function will panic if `rhs` is 0.\n+This function will panic if `rhs` is 0 or the division results in overflow.\n \n # Examples\n \n@@ -3694,6 +3694,10 @@ Since, for the positive integers, all common\n definitions of division are equal, this\n is exactly equal to `self / rhs`.\n \n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n # Examples\n \n Basic usage:\n@@ -3719,6 +3723,10 @@ Since, for the positive integers, all common\n definitions of division are equal, this\n is exactly equal to `self % rhs`.\n \n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n # Examples\n \n Basic usage:"}, {"sha": "5fe9895d8d24f94543955286541f66ae464ec06f", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -437,7 +437,7 @@ assert_eq!(n.trailing_zeros(), 3);\n             /// wrapping the truncated bits to the end of the resulting\n             /// integer.\n             ///\n-            /// Please note this isn't the same operation as the `>>` shifting\n+            /// Please note this isn't the same operation as the `<<` shifting\n             /// operator!\n             ///\n             /// # Examples\n@@ -463,7 +463,7 @@ assert_eq!(n.trailing_zeros(), 3);\n             /// wrapping the truncated bits to the beginning of the resulting\n             /// integer.\n             ///\n-            /// Please note this isn't the same operation as the `<<` shifting\n+            /// Please note this isn't the same operation as the `>>` shifting\n             /// operator!\n             ///\n             /// # Examples"}, {"sha": "47e3a0d21676f6caed5ed4c23832283215947ab5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1102,7 +1102,6 @@ impl<T: Default> Option<T> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: Deref> Option<T> {\n     /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n     ///\n@@ -1114,20 +1113,18 @@ impl<T: Deref> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inner_deref)]\n-    ///\n     /// let x: Option<String> = Some(\"hey\".to_owned());\n     /// assert_eq!(x.as_deref(), Some(\"hey\"));\n     ///\n     /// let x: Option<String> = None;\n     /// assert_eq!(x.as_deref(), None);\n     /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n     pub fn as_deref(&self) -> Option<&T::Target> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: DerefMut> Option<T> {\n     /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n     ///\n@@ -1137,14 +1134,13 @@ impl<T: DerefMut> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inner_deref)]\n-    ///\n     /// let mut x: Option<String> = Some(\"hey\".to_owned());\n     /// assert_eq!(x.as_deref_mut().map(|x| {\n     ///     x.make_ascii_uppercase();\n     ///     x\n     /// }), Some(\"HEY\".to_owned().as_mut_str()));\n     /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n     pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n         self.as_mut().map(|t| t.deref_mut())\n     }"}, {"sha": "4e79ea812044b41deb1c370c296965c7dde34f13", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -63,6 +63,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n+    #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n         unsafe {"}, {"sha": "885696e5acf49f8550c6fa85acc4eda8ec2b891a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2167,6 +2167,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline(always)]\n     // SAFETY: const sound because we transmute two types with the same layout\n+    #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n         #[repr(C)]"}, {"sha": "73d5abf1aed2378a27c50a8c56fbc271a9cfb889", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 119, "deletions": 95, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -18,11 +18,11 @@\n //!\n //! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n-//! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n+//! same as the [C++20 atomic orderings][1]. For more information see the [nomicon][2].\n //!\n //! [`Ordering`]: enum.Ordering.html\n //!\n-//! [1]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n+//! [1]: https://en.cppreference.com/w/cpp/atomic/memory_order\n //! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n@@ -113,8 +113,8 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n \n use self::Ordering::*;\n \n@@ -160,14 +160,14 @@ pub fn spin_loop_hint() {\n /// This type has the same in-memory representation as a [`bool`].\n ///\n /// [`bool`]: ../../../std/primitive.bool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n pub struct AtomicBool {\n     v: UnsafeCell<u8>,\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n@@ -177,14 +177,14 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n #[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n@@ -193,7 +193,7 @@ pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n@@ -202,10 +202,10 @@ impl<T> Default for AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -217,8 +217,8 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// operations synchronize other memory while additionally preserving a total order of such\n /// operations across all threads.\n ///\n-/// Rust's memory orderings are [the same as\n-/// LLVM's](https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n+/// Rust's memory orderings are [the same as those of\n+/// C++20](https://en.cppreference.com/w/cpp/atomic/memory_order).\n ///\n /// For more information see the [nomicon].\n ///\n@@ -231,9 +231,9 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n     ///\n-    /// Corresponds to LLVM's [`Monotonic`] ordering.\n+    /// Corresponds to [`memory_order_relaxed`] in C++20.\n     ///\n-    /// [`Monotonic`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`memory_order_relaxed`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous operations become ordered\n@@ -246,11 +246,12 @@ pub enum Ordering {\n     ///\n     /// This ordering is only applicable for operations that can perform a store.\n     ///\n-    /// Corresponds to LLVM's [`Release`] ordering.\n+    /// Corresponds to [`memory_order_release`] in C++20.\n     ///\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Release`]: #variant.Release\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Relaxed`]: #variant.Relaxed\n+    /// [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, if the loaded value was written by a store operation with\n@@ -263,48 +264,49 @@ pub enum Ordering {\n     ///\n     /// This ordering is only applicable for operations that can perform a load.\n     ///\n-    /// Corresponds to LLVM's [`Acquire`] ordering.\n+    /// Corresponds to [`memory_order_acquire`] in C++20.\n     ///\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`Relaxed`]: #variant.Relaxed\n+    /// [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n     /// Has the effects of both [`Acquire`] and [`Release`] together:\n     /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n     ///\n     /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n     /// not performing any store and hence it has just [`Acquire`] ordering. However,\n-    /// [`AcqRel`][`AcquireRelease`] will never perform [`Relaxed`] accesses.\n+    /// `AcqRel` will never perform [`Relaxed`] accesses.\n     ///\n     /// This ordering is only applicable for operations that combine both loads and stores.\n     ///\n-    /// Corresponds to LLVM's [`AcquireRelease`] ordering.\n+    /// Corresponds to [`memory_order_acq_rel`] in C++20.\n     ///\n-    /// [`AcquireRelease`]: https://llvm.org/docs/Atomics.html#acquirerelease\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`Relaxed`]: #variant.Relaxed\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n     /// operations, respectively) with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n     ///\n-    /// Corresponds to LLVM's [`SequentiallyConsistent`] ordering.\n+    /// Corresponds to [`memory_order_seq_cst`] in C++20.\n     ///\n-    /// [`SequentiallyConsistent`]: https://llvm.org/docs/Atomics.html#sequentiallyconsistent\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`AcqRel`]: https://llvm.org/docs/Atomics.html#acquirerelease\n+    /// [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`AcqRel`]: #variant.AcqRel\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An [`AtomicBool`] initialized to `false`.\n ///\n /// [`AtomicBool`]: struct.AtomicBool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n     since = \"1.34.0\",\n@@ -313,7 +315,7 @@ pub enum Ordering {\n )]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -462,7 +464,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -500,7 +502,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -551,7 +553,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -607,7 +609,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -658,7 +660,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -700,7 +702,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -753,7 +755,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -794,13 +796,13 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -951,7 +953,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -987,7 +989,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1029,7 +1031,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1089,7 +1091,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1110,7 +1112,7 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n@@ -1126,16 +1128,17 @@ impl From<bool> for AtomicBool {\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n     #[inline]\n     fn from(p: *mut T) -> Self { Self::new(p) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n-    ($stable:meta,\n+    ($cfg_cas:meta,\n+     $stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n@@ -1356,7 +1359,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1396,7 +1399,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1454,7 +1457,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1506,7 +1509,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1544,7 +1547,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1576,7 +1579,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1611,7 +1614,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1647,7 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1682,7 +1685,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1717,7 +1720,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1767,7 +1770,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1828,7 +1831,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1880,7 +1883,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1890,8 +1893,9 @@ assert_eq!(min_foo, 12);\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1906,8 +1910,9 @@ atomic_int! {\n     \"AtomicI8::new(0)\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1922,8 +1927,9 @@ atomic_int! {\n     \"AtomicU8::new(0)\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1938,8 +1944,9 @@ atomic_int! {\n     \"AtomicI16::new(0)\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1954,8 +1961,9 @@ atomic_int! {\n     \"AtomicU16::new(0)\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1970,8 +1978,9 @@ atomic_int! {\n     \"AtomicI32::new(0)\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1986,8 +1995,12 @@ atomic_int! {\n     \"AtomicU32::new(0)\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2002,8 +2015,12 @@ atomic_int! {\n     \"AtomicI64::new(0)\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2018,8 +2035,9 @@ atomic_int! {\n     \"AtomicU64::new(0)\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2034,8 +2052,9 @@ atomic_int! {\n     \"AtomicI128::new(0)\",\n     i128 AtomicI128 ATOMIC_I128_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2050,20 +2069,24 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"16\")]\n macro_rules! ptr_width {\n     () => { 2 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"32\")]\n macro_rules! ptr_width {\n     () => { 4 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"64\")]\n macro_rules! ptr_width {\n     () => { 8 }\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2078,8 +2101,9 @@ atomic_int!{\n     \"AtomicIsize::new(0)\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2096,7 +2120,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -2130,7 +2154,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -2143,7 +2167,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -2156,7 +2180,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2168,7 +2192,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n@@ -2193,7 +2217,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2218,7 +2242,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2230,7 +2254,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2242,7 +2266,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2254,7 +2278,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2267,7 +2291,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2280,7 +2304,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2293,7 +2317,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2306,7 +2330,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),\n@@ -2504,23 +2528,23 @@ pub fn compiler_fence(order: Ordering) {\n }\n \n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n impl<T> fmt::Pointer for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "6f841bd2adf41a9be45c16512042475952e85512", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -217,7 +217,7 @@ impl fmt::Debug for Context<'_> {\n /// This handle encapsulates a [`RawWaker`] instance, which defines the\n /// executor-specific wakeup behavior.\n ///\n-/// Implements [`Clone`], [`trait@Send`], and [`trait@Sync`].\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n ///\n /// [`RawWaker`]: struct.RawWaker.html\n #[repr(transparent)]"}, {"sha": "255724432816d99ea2d96ebe5dd036ad9bc6c1b3", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -319,6 +319,46 @@ mod debug_map {\n                    format!(\"{:#?}\", Bar));\n     }\n \n+    #[test]\n+    fn test_entry_err() {\n+        // Ensure errors in a map entry don't trigger panics (#65231)\n+        use std::fmt::Write;\n+\n+        struct ErrorFmt;\n+\n+        impl fmt::Debug for ErrorFmt {\n+            fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                Err(fmt::Error)\n+            }\n+        }\n+\n+        struct KeyValue<K, V>(usize, K, V);\n+\n+        impl<K, V> fmt::Debug for KeyValue<K, V>\n+        where\n+            K: fmt::Debug,\n+            V: fmt::Debug,\n+        {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let mut map = fmt.debug_map();\n+\n+                for _ in 0..self.0 {\n+                    map.entry(&self.1, &self.2);\n+                }\n+\n+                map.finish()\n+            }\n+        }\n+\n+        let mut buf = String::new();\n+\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(1, ErrorFmt, \"bar\")).is_err());\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(1, \"foo\", ErrorFmt)).is_err());\n+\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(2, ErrorFmt, \"bar\")).is_err());\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(2, \"foo\", ErrorFmt)).is_err());\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn test_invalid_key_when_entry_is_incomplete() {"}, {"sha": "f612c52d398357c5ec3591f466a3e6523842ac5f", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -25,7 +25,6 @@\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n-#![feature(mem_take)]\n #![feature(non_exhaustive)]\n #![feature(rustc_attrs)]\n #![feature(specialization)]"}, {"sha": "cf9f36ca37c90c46da392ff206de066dd34b0b22", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -18,8 +18,8 @@ jobserver = \"0.1\"\n num_cpus = \"1.0\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n-rustc-rayon = \"0.2.0\"\n-rustc-rayon-core = \"0.2.0\"\n+rustc-rayon = \"0.3.0\"\n+rustc-rayon-core = \"0.3.0\"\n polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n@@ -29,6 +29,7 @@ rustc_index = { path = \"../librustc_index\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_expand = { path = \"../libsyntax_expand\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n parking_lot = \"0.9\""}, {"sha": "3daf0fc9df7a06606cd090f84ca7d1d29cdcbaf9", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -98,7 +98,6 @@ macro_rules! arena_types {\n                 rustc::hir::def_id::DefId,\n             >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n-            [decode] generic_predicates: rustc::ty::GenericPredicates<'tcx>,\n             [few] lint_levels: rustc::lint::LintLevelMap,\n             [few] stability_index: rustc::middle::stability::Index<'tcx>,\n             [few] features: syntax::feature_gate::Features,"}, {"sha": "337cdddc432c4640ed1c8321f5e9d554a373bef2", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 89, "deletions": 94, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -3,13 +3,14 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n-use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n+use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, AtomicU64, Ordering};\n+use rustc_data_structures::sharded::{self, Sharded};\n+use std::sync::atomic::Ordering::SeqCst;\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n use std::mem;\n use crate::ty::{self, TyCtxt};\n-use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n \n use crate::ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n@@ -31,7 +32,7 @@ rustc_index::newtype_index! {\n }\n \n impl DepNodeIndex {\n-    const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n+    pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -54,7 +55,7 @@ struct DepGraphData {\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: Lock<CurrentDepGraph>,\n+    current: CurrentDepGraph,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n@@ -75,9 +76,6 @@ struct DepGraphData {\n     previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n     dep_node_debug: Lock<FxHashMap<DepNode, String>>,\n-\n-    // Used for testing, only populated when -Zquery-dep-graph is specified.\n-    loaded_from_cache: Lock<FxHashMap<DepNodeIndex, bool>>,\n }\n \n pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n@@ -99,12 +97,11 @@ impl DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n+                current: CurrentDepGraph::new(prev_graph_node_count),\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n-                loaded_from_cache: Default::default(),\n             })),\n         }\n     }\n@@ -122,13 +119,12 @@ impl DepGraph {\n     }\n \n     pub fn query(&self) -> DepGraphQuery {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n-        let nodes: Vec<_> = current_dep_graph.data.iter().map(|n| n.node).collect();\n+        let data = self.data.as_ref().unwrap().current.data.lock();\n+        let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n-        for (from, edge_targets) in current_dep_graph.data.iter()\n-                                                           .map(|d| (d.node, &d.edges)) {\n+        for (from, edge_targets) in data.iter().map(|d| (d.node, &d.edges)) {\n             for &edge_target in edge_targets.iter() {\n-                let to = current_dep_graph.data[edge_target].node;\n+                let to = data[edge_target].node;\n                 edges.push((from, to));\n             }\n         }\n@@ -207,7 +203,7 @@ impl DepGraph {\n                 read_set: Default::default(),\n             }),\n             |data, key, fingerprint, task| {\n-                data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n+                data.complete_task(key, task.unwrap(), fingerprint)\n             },\n             hash_result)\n     }\n@@ -228,7 +224,7 @@ impl DepGraph {\n         self.with_task_impl(key, cx, input, true, identity_fn,\n             |_| None,\n             |data, key, fingerprint, _| {\n-                data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n+                data.alloc_node(key, SmallVec::new(), fingerprint)\n             },\n             hash_result::<R>)\n     }\n@@ -241,7 +237,7 @@ impl DepGraph {\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n         create_task: fn(DepNode) -> Option<TaskDeps>,\n-        finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n+        finish_task_and_alloc_depnode: fn(&CurrentDepGraph,\n                                           DepNode,\n                                           Fingerprint,\n                                           Option<TaskDeps>) -> DepNodeIndex,\n@@ -260,10 +256,6 @@ impl DepGraph {\n             //  - we can get an idea of the runtime cost.\n             let mut hcx = cx.get_stable_hashing_context();\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n-\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n@@ -279,10 +271,6 @@ impl DepGraph {\n                 })\n             };\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n-            };\n-\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode(\n@@ -363,7 +351,6 @@ impl DepGraph {\n                 (r, task_deps.into_inner())\n             });\n             let dep_node_index = data.current\n-                                     .borrow_mut()\n                                      .complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n@@ -387,18 +374,17 @@ impl DepGraph {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_| None,\n             |data, key, fingerprint, _| {\n-                let mut current = data.borrow_mut();\n-                current.alloc_node(key, smallvec![], fingerprint)\n+                data.alloc_node(key, smallvec![], fingerprint)\n             },\n             hash_result)\n     }\n \n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            let current = data.current.borrow_mut();\n-            if let Some(&dep_node_index) = current.node_to_node_index.get(&v) {\n-                std::mem::drop(current);\n+            let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n+            if let Some(dep_node_index) = map.get(&v).copied() {\n+                std::mem::drop(map);\n                 data.read_index(dep_node_index);\n             } else {\n                 bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n@@ -419,8 +405,9 @@ impl DepGraph {\n             .as_ref()\n             .unwrap()\n             .current\n-            .borrow_mut()\n             .node_to_node_index\n+            .get_shard_by_value(dep_node)\n+            .lock()\n             .get(dep_node)\n             .cloned()\n             .unwrap()\n@@ -429,16 +416,20 @@ impl DepGraph {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n         if let Some(ref data) = self.data {\n-            data.current.borrow_mut().node_to_node_index.contains_key(dep_node)\n+            data.current\n+                .node_to_node_index\n+                .get_shard_by_value(&dep_node)\n+                .lock()\n+                .contains_key(dep_node)\n         } else {\n             false\n         }\n     }\n \n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let current = self.data.as_ref().expect(\"dep graph enabled\").current.borrow_mut();\n-        current.data[dep_node_index].fingerprint\n+        let data = self.data.as_ref().expect(\"dep graph enabled\").current.data.lock();\n+        data[dep_node_index].fingerprint\n     }\n \n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n@@ -492,32 +483,29 @@ impl DepGraph {\n \n     pub fn edge_deduplication_data(&self) -> Option<(u64, u64)> {\n         if cfg!(debug_assertions) {\n-            let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+            let current_dep_graph = &self.data.as_ref().unwrap().current;\n \n-            Some((current_dep_graph.total_read_count,\n-                  current_dep_graph.total_duplicate_read_count))\n+            Some((current_dep_graph.total_read_count.load(SeqCst),\n+                  current_dep_graph.total_duplicate_read_count.load(SeqCst)))\n         } else {\n             None\n         }\n     }\n \n     pub fn serialize(&self) -> SerializedDepGraph {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+        let data = self.data.as_ref().unwrap().current.data.lock();\n \n         let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n-            current_dep_graph.data.iter().map(|d| d.fingerprint).collect();\n+            data.iter().map(|d| d.fingerprint).collect();\n         let nodes: IndexVec<SerializedDepNodeIndex, _> =\n-            current_dep_graph.data.iter().map(|d| d.node).collect();\n+            data.iter().map(|d| d.node).collect();\n \n-        let total_edge_count: usize = current_dep_graph.data.iter()\n-                                                            .map(|d| d.edges.len())\n-                                                            .sum();\n+        let total_edge_count: usize = data.iter().map(|d| d.edges.len()).sum();\n \n         let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n         let mut edge_list_data = Vec::with_capacity(total_edge_count);\n \n-        for (current_dep_node_index, edges) in current_dep_graph.data.iter_enumerated()\n-                                                                .map(|(i, d)| (i, &d.edges)) {\n+        for (current_dep_node_index, edges) in data.iter_enumerated().map(|(i, d)| (i, &d.edges)) {\n             let start = edge_list_data.len() as u32;\n             // This should really just be a memcpy :/\n             edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex::new(i.index())));\n@@ -613,7 +601,11 @@ impl DepGraph {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n+            debug_assert!(!data.current\n+                               .node_to_node_index\n+                               .get_shard_by_value(dep_node)\n+                               .lock()\n+                               .contains_key(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n@@ -746,15 +738,13 @@ impl DepGraph {\n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n         let dep_node_index = {\n-            let mut current = data.current.borrow_mut();\n-\n             // Copy the fingerprint from the previous graph,\n             // so we don't have to recompute it\n             let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n \n             // We allocating an entry for the node in the current dependency graph and\n             // adding all the appropriate edges imported from the previous graph\n-            current.intern_node(*dep_node, current_deps, fingerprint)\n+            data.current.intern_node(*dep_node, current_deps, fingerprint)\n         };\n \n         // ... emitting any stored diagnostic ...\n@@ -858,6 +848,8 @@ impl DepGraph {\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n     pub fn exec_cache_promotions(&self, tcx: TyCtxt<'_>) {\n+        let _prof_timer = tcx.prof.generic_activity(\"incr_comp_query_cache_promotion\");\n+\n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n@@ -874,25 +866,6 @@ impl DepGraph {\n             }\n         }\n     }\n-\n-    pub fn mark_loaded_from_cache(&self, dep_node_index: DepNodeIndex, state: bool) {\n-        debug!(\"mark_loaded_from_cache({:?}, {})\",\n-               self.data.as_ref().unwrap().current.borrow().data[dep_node_index].node,\n-               state);\n-\n-        self.data\n-            .as_ref()\n-            .unwrap()\n-            .loaded_from_cache\n-            .borrow_mut()\n-            .insert(dep_node_index, state);\n-    }\n-\n-    pub fn was_loaded_from_cache(&self, dep_node: &DepNode) -> Option<bool> {\n-        let data = self.data.as_ref().unwrap();\n-        let dep_node_index = data.current.borrow().node_to_node_index[dep_node];\n-        data.loaded_from_cache.borrow().get(&dep_node_index).cloned()\n-    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -947,9 +920,27 @@ struct DepNodeData {\n     fingerprint: Fingerprint,\n }\n \n+/// `CurrentDepGraph` stores the dependency graph for the current session.\n+/// It will be populated as we run queries or tasks.\n+///\n+/// The nodes in it are identified by an index (`DepNodeIndex`).\n+/// The data for each node is stored in its `DepNodeData`, found in the `data` field.\n+///\n+/// We never remove nodes from the graph: they are only added.\n+///\n+/// This struct uses two locks internally. The `data` and `node_to_node_index` fields are\n+/// locked separately. Operations that take a `DepNodeIndex` typically just access\n+/// the data field.\n+///\n+/// The only operation that must manipulate both locks is adding new nodes, in which case\n+/// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n+/// acquire the lock on `data.`\n pub(super) struct CurrentDepGraph {\n-    data: IndexVec<DepNodeIndex, DepNodeData>,\n-    node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n+    data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n+\n+    /// Used to trap when a specific edge is added to the graph.\n+    /// This is used for debug purposes and is only active with `debug_assertions`.\n     #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n@@ -966,8 +957,10 @@ pub(super) struct CurrentDepGraph {\n     /// the `DepGraph` is created.\n     anon_id_seed: Fingerprint,\n \n-    total_read_count: u64,\n-    total_duplicate_read_count: u64,\n+    /// These are simple counters that are for profiling and\n+    /// debugging and only active with `debug_assertions`.\n+    total_read_count: AtomicU64,\n+    total_duplicate_read_count: AtomicU64,\n }\n \n impl CurrentDepGraph {\n@@ -1001,28 +994,28 @@ impl CurrentDepGraph {\n         let new_node_count_estimate = (prev_graph_node_count * 102) / 100 + 200;\n \n         CurrentDepGraph {\n-            data: IndexVec::with_capacity(new_node_count_estimate),\n-            node_to_node_index: FxHashMap::with_capacity_and_hasher(\n-                new_node_count_estimate,\n+            data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n+            node_to_node_index: Sharded::new(|| FxHashMap::with_capacity_and_hasher(\n+                new_node_count_estimate / sharded::SHARDS,\n                 Default::default(),\n-            ),\n+            )),\n             anon_id_seed: stable_hasher.finish(),\n             forbidden_edge,\n-            total_read_count: 0,\n-            total_duplicate_read_count: 0,\n+            total_read_count: AtomicU64::new(0),\n+            total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n     fn complete_task(\n-        &mut self,\n+        &self,\n         node: DepNode,\n         task_deps: TaskDeps,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n         self.alloc_node(node, task_deps.reads, fingerprint)\n     }\n \n-    fn complete_anon_task(&mut self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+    fn complete_anon_task(&self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n         debug_assert!(!kind.is_eval_always());\n \n         let mut hasher = StableHasher::new();\n@@ -1047,28 +1040,30 @@ impl CurrentDepGraph {\n     }\n \n     fn alloc_node(\n-        &mut self,\n+        &self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n+        debug_assert!(!self.node_to_node_index\n+                           .get_shard_by_value(&dep_node)\n+                           .lock()\n+                           .contains_key(&dep_node));\n         self.intern_node(dep_node, edges, fingerprint)\n     }\n \n     fn intern_node(\n-        &mut self,\n+        &self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert_eq!(self.node_to_node_index.len(), self.data.len());\n-\n-        match self.node_to_node_index.entry(dep_node) {\n+        match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let dep_node_index = DepNodeIndex::new(self.data.len());\n-                self.data.push(DepNodeData {\n+                let mut data = self.data.lock();\n+                let dep_node_index = DepNodeIndex::new(data.len());\n+                data.push(DepNodeData {\n                     node: dep_node,\n                     edges,\n                     fingerprint\n@@ -1087,17 +1082,17 @@ impl DepGraphData {\n             if let Some(task_deps) = icx.task_deps {\n                 let mut task_deps = task_deps.lock();\n                 if cfg!(debug_assertions) {\n-                    self.current.lock().total_read_count += 1;\n+                    self.current.total_read_count.fetch_add(1, SeqCst);\n                 }\n                 if task_deps.read_set.insert(source) {\n                     task_deps.reads.push(source);\n \n                     #[cfg(debug_assertions)]\n                     {\n                         if let Some(target) = task_deps.node {\n-                            let graph = self.current.lock();\n-                            if let Some(ref forbidden_edge) = graph.forbidden_edge {\n-                                let source = graph.data[source].node;\n+                            let data = self.current.data.lock();\n+                            if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n+                                let source = data[source].node;\n                                 if forbidden_edge.test(&source, &target) {\n                                     bug!(\"forbidden edge {:?} -> {:?} created\",\n                                         source,\n@@ -1107,7 +1102,7 @@ impl DepGraphData {\n                         }\n                     }\n                 } else if cfg!(debug_assertions) {\n-                    self.current.lock().total_duplicate_read_count += 1;\n+                    self.current.total_duplicate_read_count.fetch_add(1, SeqCst);\n                 }\n             }\n         })"}, {"sha": "3d501cacf6f4ca57d239ff26c68091b24160e186", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 120, "deletions": 196, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -259,8 +259,8 @@ trait Foo {\n This is similar to the second sub-error, but subtler. It happens in situations\n like the following:\n \n-```compile_fail\n-trait Super<A> {}\n+```compile_fail,E0038\n+trait Super<A: ?Sized> {}\n \n trait Trait: Super<Self> {\n }\n@@ -270,17 +270,21 @@ struct Foo;\n impl Super<Foo> for Foo{}\n \n impl Trait for Foo {}\n+\n+fn main() {\n+    let x: Box<dyn Trait>;\n+}\n ```\n \n Here, the supertrait might have methods as follows:\n \n ```\n-trait Super<A> {\n-    fn get_a(&self) -> A; // note that this is object safe!\n+trait Super<A: ?Sized> {\n+    fn get_a(&self) -> &A; // note that this is object safe!\n }\n ```\n \n-If the trait `Foo` was deriving from something like `Super<String>` or\n+If the trait `Trait` was deriving from something like `Super<String>` or\n `Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n `get_a()` will definitely return an object of that type.\n \n@@ -466,67 +470,6 @@ fn main() {\n ```\n \"##,\n \n-// This shouldn't really ever trigger since the repeated value error comes first\n-E0136: r##\"\n-A binary can only have one entry point, and by default that entry point is the\n-function `main()`. If there are multiple such functions, please rename one.\n-\"##,\n-\n-E0137: r##\"\n-More than one function was declared with the `#[main]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0137\n-#![feature(main)]\n-\n-#[main]\n-fn foo() {}\n-\n-#[main]\n-fn f() {} // error: multiple functions with a `#[main]` attribute\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[main]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(main)]\n-\n-#[main]\n-fn f() {} // ok!\n-```\n-\"##,\n-\n-E0138: r##\"\n-More than one function was declared with the `#[start]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0138\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n-\n-#[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n-// error: multiple 'start' functions\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[start]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n-```\n-\"##,\n-\n E0139: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -1580,8 +1523,51 @@ where\n ```\n \"##,\n \n+E0495: r##\"\n+A lifetime cannot be determined in the given situation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0495\n+fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // error!\n+        ((u,),) => u,\n+    }\n+}\n+\n+let y = Box::new((42,));\n+let x = transmute_lifetime(&y);\n+```\n+\n+In this code, you have two ways to solve this issue:\n+ 1. Enforce that `'a` lives at least as long as `'b`.\n+ 2. Use the same lifetime requirement for both input and output values.\n+\n+So for the first solution, you can do it by replacing `'a` with `'a: 'b`:\n+\n+```\n+fn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```\n+\n+In the second you can do it by simply removing `'b` so they both use `'a`:\n+\n+```\n+fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```\n+\"##,\n+\n E0496: r##\"\n-A lifetime name is shadowing another lifetime name. Erroneous code example:\n+A lifetime name is shadowing another lifetime name.\n+\n+Erroneous code example:\n \n ```compile_fail,E0496\n struct Foo<'a> {\n@@ -1613,8 +1599,11 @@ fn main() {\n \"##,\n \n E0497: r##\"\n-A stability attribute was used outside of the standard library. Erroneous code\n-example:\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A stability attribute was used outside of the standard library.\n+\n+Erroneous code example:\n \n ```compile_fail\n #[stable] // error: stability attributes may not be used outside of the\n@@ -1626,33 +1615,6 @@ It is not possible to use stability attributes outside of the standard library.\n Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n-E0512: r##\"\n-Transmute with two differently sized types was attempted. Erroneous code\n-example:\n-\n-```compile_fail,E0512\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n-    // error: cannot transmute between types of different sizes,\n-    //        or dependently-sized types\n-}\n-```\n-\n-Please use types with same size or use the expected type directly. Example:\n-\n-```\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n-    // or:\n-    unsafe { takes_u8(0u8); } // ok!\n-}\n-```\n-\"##,\n-\n E0517: r##\"\n This error indicates that a `#[repr(..)]` attribute was placed on an\n unsupported item.\n@@ -1787,6 +1749,27 @@ To understand better how closures work in Rust, read:\n https://doc.rust-lang.org/book/ch13-01-closures.html\n \"##,\n \n+E0566: r##\"\n+Conflicting representation hints have been used on a same item.\n+\n+Erroneous code example:\n+\n+```\n+#[repr(u32, u64)] // warning!\n+enum Repr { A }\n+```\n+\n+In most cases (if not all), using just one representation hint is more than\n+enough. If you want to have a representation hint depending on the current\n+architecture, use `cfg_attr`. Example:\n+\n+```\n+#[cfg_attr(linux, repr(u32))]\n+#[cfg_attr(not(linux), repr(u64))]\n+enum Repr { A }\n+```\n+\"##,\n+\n E0580: r##\"\n The `main` function was incorrectly declared.\n \n@@ -1847,84 +1830,6 @@ See [RFC 1522] for more details.\n [RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n \"##,\n \n-E0591: r##\"\n-Per [RFC 401][rfc401], if you have a function declaration `foo`:\n-\n-```\n-// For the purposes of this explanation, all of these\n-// different kinds of `fn` declarations are equivalent:\n-struct S;\n-fn foo(x: S) { /* ... */ }\n-# #[cfg(for_demonstration_only)]\n-extern \"C\" { fn foo(x: S); }\n-# #[cfg(for_demonstration_only)]\n-impl S { fn foo(self) { /* ... */ } }\n-```\n-\n-the type of `foo` is **not** `fn(S)`, as one might expect.\n-Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\n-However, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\n-so you rarely notice this:\n-\n-```\n-# struct S;\n-# fn foo(_: S) {}\n-let x: fn(S) = foo; // OK, coerces\n-```\n-\n-The reason that this matter is that the type `fn(S)` is not specific to\n-any particular function: it's a function _pointer_. So calling `x()` results\n-in a virtual call, whereas `foo()` is statically dispatched, because the type\n-of `foo` tells us precisely what function is being called.\n-\n-As noted above, coercions mean that most code doesn't have to be\n-concerned with this distinction. However, you can tell the difference\n-when using **transmute** to convert a fn item into a fn pointer.\n-\n-This is sometimes done as part of an FFI:\n-\n-```compile_fail,E0591\n-extern \"C\" fn foo(userdata: Box<i32>) {\n-    /* ... */\n-}\n-\n-# fn callback(_: extern \"C\" fn(*mut i32)) {}\n-# use std::mem::transmute;\n-# unsafe {\n-let f: extern \"C\" fn(*mut i32) = transmute(foo);\n-callback(f);\n-# }\n-```\n-\n-Here, transmute is being used to convert the types of the fn arguments.\n-This pattern is incorrect because, because the type of `foo` is a function\n-**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n-is a function pointer, which is not zero-sized.\n-This pattern should be rewritten. There are a few possible ways to do this:\n-\n-- change the original fn declaration to match the expected signature,\n-  and do the cast in the fn body (the preferred option)\n-- cast the fn item fo a fn pointer before calling transmute, as shown here:\n-\n-    ```\n-    # extern \"C\" fn foo(_: Box<i32>) {}\n-    # use std::mem::transmute;\n-    # unsafe {\n-    let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_));\n-    let f: extern \"C\" fn(*mut i32) = transmute(foo as usize); // works too\n-    # }\n-    ```\n-\n-The same applies to transmutes to `*mut fn()`, which were observed in practice.\n-Note though that use of this type is generally incorrect.\n-The intention is typically to describe a function pointer, but just `fn()`\n-alone suffices for that. `*mut fn()` is a pointer to a fn pointer.\n-(Since these values are typically just passed to C code, however, this rarely\n-makes a difference in practice.)\n-\n-[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n-\"##,\n-\n E0593: r##\"\n You tried to supply an `Fn`-based type with an incorrect number of arguments\n than what was expected.\n@@ -1941,21 +1846,6 @@ fn main() {\n ```\n \"##,\n \n-E0601: r##\"\n-No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n-\n-```\n-fn main() {\n-    // Your program will start here.\n-    println!(\"Hello world!\");\n-}\n-```\n-\n-If you don't know the basics of Rust, you can go look to the Rust Book to get\n-started: https://doc.rust-lang.org/book/\n-\"##,\n-\n E0602: r##\"\n An unknown lint was used on the command line.\n \n@@ -2115,6 +2005,24 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0697: r##\"\n+A closure has been used as `static`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0697\n+fn main() {\n+    static || {}; // used as `static`\n+}\n+```\n+\n+Closures cannot be used as `static`. They \"save\" the environment,\n+and as such a static closure would save only a static environment\n+which would consist only of variables with a static lifetime. Given\n+this it would be better to use a proper function. The easiest fix\n+is to remove the `static` keyword.\n+\"##,\n+\n E0698: r##\"\n When using generators (or async) all type variables must be bound so a\n generator can be constructed.\n@@ -2234,6 +2142,25 @@ These attributes are meant to only be used by the standard library and are\n rejected in your own crates.\n \"##,\n \n+E0736: r##\"\n+#[track_caller] and #[naked] cannot be applied to the same function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0736\n+#![feature(track_caller)]\n+\n+#[naked]\n+#[track_caller]\n+fn foo() {}\n+```\n+\n+This is primarily due to ABI incompatibilities between the two attributes.\n+See [RFC 2091] for details on this and other limitations.\n+\n+[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n+\"##,\n+\n ;\n //  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n@@ -2243,7 +2170,7 @@ rejected in your own crates.\n //  E0272, // on_unimplemented #0\n //  E0273, // on_unimplemented #1\n //  E0274, // on_unimplemented #2\n-    E0278, // requirement is not satisfied\n+//  E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied\n //  E0285, // overflow evaluation builtin bounds\n@@ -2275,25 +2202,22 @@ rejected in your own crates.\n     E0488, // lifetime of variable does not enclose its declaration\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n-    E0495, // cannot infer an appropriate lifetime due to conflicting\n-           // requirements\n-    E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n     E0628, // generators cannot have explicit parameters\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0697, // closures cannot be static\n-    E0707, // multiple elided lifetimes used in arguments of `async fn`\n+//  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported\n-    E0709, // multiple different lifetimes used in arguments of `async fn`\n+//  E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes\n //  E0702, // replaced with a generic attribute input check\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n     E0727, // `async` generators are not yet supported\n     E0728, // `await` must be in an `async` function or block\n+    E0739, // invalid track_caller application/syntax\n }"}, {"sha": "c37fec982b1160bd80d505d3f6ad3432ac721545", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -11,7 +11,7 @@ use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n \n use std::fmt::{self, Display};\n-use syntax::symbol::sym;\n+use syntax::{attr, symbol::sym};\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -103,6 +103,8 @@ impl CheckAttrVisitor<'tcx> {\n                 self.check_marker(attr, item, target)\n             } else if attr.check_name(sym::target_feature) {\n                 self.check_target_feature(attr, item, target)\n+            } else if attr.check_name(sym::track_caller) {\n+                self.check_track_caller(attr, &item, target)\n             } else {\n                 true\n             };\n@@ -135,6 +137,32 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n+    /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n+    fn check_track_caller(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) -> bool {\n+        if target != Target::Fn {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                attr.span,\n+                E0739,\n+                \"attribute should be applied to function\"\n+            )\n+            .span_label(item.span, \"not a function\")\n+            .emit();\n+            false\n+        } else if attr::contains_name(&item.attrs, sym::naked) {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                attr.span,\n+                E0736,\n+                \"cannot use `#[track_caller]` with `#[naked]`\",\n+            )\n+            .emit();\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n     fn check_non_exhaustive(\n         &self,"}, {"sha": "a071a539e01df16e1ac32fd61a864dfbcabccb2a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -6,7 +6,7 @@ use crate::ty;\n use crate::util::nodemap::DefIdMap;\n \n use syntax::ast;\n-use syntax::ext::base::MacroKind;\n+use syntax_expand::base::MacroKind;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n use rustc_macros::HashStable;"}, {"sha": "d5287fd415b7f07023244376a3211df770b41f4a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -64,14 +64,15 @@ use syntax::ast;\n use syntax::ptr::P as AstP;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::base::SpecialDerives;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax_expand::base::SpecialDerives;\n use syntax::print::pprust;\n+use syntax::parse::token::{self, Nonterminal, Token};\n+use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::sess::ParseSess;\n use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n-use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n+use syntax_pos::hygiene::ExpnId;\n use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n@@ -86,6 +87,11 @@ pub struct LoweringContext<'a> {\n \n     resolver: &'a mut dyn Resolver,\n \n+    /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n+    /// if we don't have this function pointer. To avoid that dependency so that\n+    /// librustc is independent of the parser, we use dynamic dispatch here.\n+    nt_to_tokenstream: NtToTokenstream,\n+\n     /// The items being lowered are collected here.\n     items: BTreeMap<hir::HirId, hir::Item>,\n \n@@ -180,6 +186,8 @@ pub trait Resolver {\n     fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n }\n \n+type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n+\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -236,17 +244,21 @@ pub fn lower_crate(\n     dep_graph: &DepGraph,\n     krate: &Crate,\n     resolver: &mut dyn Resolver,\n+    nt_to_tokenstream: NtToTokenstream,\n ) -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n+    let _prof_timer = sess.prof.generic_activity(\"hir_lowering\");\n+\n     LoweringContext {\n         crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n         cstore,\n         resolver,\n+        nt_to_tokenstream,\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -844,7 +856,7 @@ impl<'a> LoweringContext<'a> {\n     /// header, we convert it to an in-band lifetime.\n     fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> ParamName {\n         assert!(self.is_collecting_in_band_lifetimes);\n-        let index = self.lifetimes_to_define.len();\n+        let index = self.lifetimes_to_define.len() + self.in_scope_lifetimes.len();\n         let hir_name = ParamName::Fresh(index);\n         self.lifetimes_to_define.push((span, hir_name));\n         hir_name\n@@ -1020,7 +1032,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n             token::Interpolated(nt) => {\n-                let tts = nt.to_tokenstream(&self.sess.parse_sess, token.span);\n+                let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n                 self.lower_token_stream(tts)\n             }\n             _ => TokenTree::Token(token).into(),\n@@ -3279,10 +3291,14 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.sess.next_node_id();\n                 self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n             }\n-            // This is the normal case.\n-            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n-\n-            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n+            // `PassThrough` is the normal case.\n+            // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n+            // is unsuitable here, as these can occur from missing lifetime parameters in a\n+            // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n+            // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n+            // later, at which point a suitable error will be emitted.\n+          | AnonymousLifetimeMode::PassThrough\n+          | AnonymousLifetimeMode::ReportError => self.new_implicit_lifetime(span),\n         }\n     }\n "}, {"sha": "73d2ac5c134d3f1fa3465c2f391aa4cb5a12af2b", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -18,7 +18,7 @@ use smallvec::SmallVec;\n use syntax::attr;\n use syntax::ast::*;\n use syntax::visit::{self, Visitor};\n-use syntax::ext::base::SpecialDerives;\n+use syntax_expand::base::SpecialDerives;\n use syntax::source_map::{respan, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;"}, {"sha": "9be339be7034f2b00d1d83823d3bc79f48f10ce9", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,7 +2,7 @@ use crate::hir::map::definitions::*;\n use crate::hir::def_id::DefIndex;\n \n use syntax::ast::*;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax_expand::hygiene::ExpnId;\n use syntax::visit;\n use syntax::symbol::{kw, sym};\n use syntax::parse::token::{self, Token};\n@@ -90,7 +90,7 @@ impl<'a> DefCollector<'a> {\n         }\n     }\n \n-    pub fn visit_macro_invoc(&mut self, id: NodeId) {\n+    fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }"}, {"sha": "d2732c92d26887688ff7e83d79131d2d418e8106", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -17,7 +17,7 @@ use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax_expand::hygiene::ExpnId;\n use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -111,7 +111,7 @@ pub struct Definitions {\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n-#[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n     /// The parent path.\n     pub parent: Option<DefIndex>,\n@@ -162,13 +162,13 @@ impl DefKey {\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n-#[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n     pub disambiguator: u32\n }\n \n-#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n     /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,"}, {"sha": "f839087ec027108677776a5b816cf1fdb1afe160", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_index::vec::IndexVec;\n use syntax::ast::{self, Name, NodeId};\n use syntax::source_map::Spanned;\n-use syntax::ext::base::MacroKind;\n+use syntax_expand::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub mod blocks;\n@@ -1222,6 +1222,8 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n+    let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n+\n     // Build the reverse mapping of `node_to_hir_id`.\n     let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n         .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();"}, {"sha": "568e051aaf08fc750e618bad84e220338dde626b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -669,6 +669,12 @@ impl WhereClause {\n             Some(self.span)\n         }\n     }\n+\n+    /// The `WhereClause` under normal circumstances points at either the predicates or the empty\n+    /// space where the `where` clause should be. Only of use for diagnostic suggestions.\n+    pub fn span_for_predicates_or_empty_place(&self) -> Span {\n+        self.span\n+    }\n }\n \n /// A single predicate in a where-clause.\n@@ -989,6 +995,15 @@ pub enum RangeEnd {\n     Excluded,\n }\n \n+impl fmt::Display for RangeEnd {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            RangeEnd::Included => \"..=\",\n+            RangeEnd::Excluded => \"..\",\n+        })\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`).\n@@ -1053,6 +1068,13 @@ impl Mutability {\n             MutImmutable => MutImmutable,\n         }\n     }\n+\n+    pub fn invert(self) -> Self {\n+        match self {\n+            MutMutable => MutImmutable,\n+            MutImmutable => MutMutable,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n@@ -1359,6 +1381,10 @@ impl Body {\n             hir_id: self.value.hir_id,\n         }\n     }\n+\n+    pub fn generator_kind(&self) -> Option<GeneratorKind> {\n+        self.generator_kind\n+    }\n }\n \n /// The type of source expression that caused this generator to be created.\n@@ -1548,6 +1574,19 @@ impl Expr {\n             }\n         }\n     }\n+\n+    /// If `Self.kind` is `ExprKind::DropTemps(expr)`, drill down until we get a non-`DropTemps`\n+    /// `Expr`. This is used in suggestions to ignore this `ExprKind` as it is semantically\n+    /// silent, only signaling the ownership system. By doing this, suggestions that check the\n+    /// `ExprKind` of any given `Expr` for presentation don't have to care about `DropTemps`\n+    /// beyond remembering to call this function before doing analysis on it.\n+    pub fn peel_drop_temps(&self) -> &Self {\n+        let mut expr = self;\n+        while let ExprKind::DropTemps(inner) = &expr.kind {\n+            expr = inner;\n+        }\n+        expr\n+    }\n }\n \n impl fmt::Debug for Expr {\n@@ -2669,6 +2708,11 @@ pub struct CodegenFnAttrs {\n     /// probably isn't set when this is set, this is for foreign items while\n     /// `#[export_name]` is for Rust-defined functions.\n     pub link_name: Option<Symbol>,\n+    /// The `#[link_ordinal = \"...\"]` attribute, indicating an ordinal an\n+    /// imported function has in the dynamic library. Note that this must not\n+    /// be set when `link_name` is set. This is for foreign items with the\n+    /// \"raw-dylib\" kind.\n+    pub link_ordinal: Option<usize>,\n     /// The `#[target_feature(enable = \"...\")]` attribute and the enabled\n     /// features (only enabled features are supported right now).\n     pub target_features: Vec<Symbol>,\n@@ -2716,7 +2760,9 @@ bitflags! {\n         const USED                      = 1 << 9;\n         /// #[ffi_returns_twice], indicates that an extern function can return\n         /// multiple times\n-        const FFI_RETURNS_TWICE = 1 << 10;\n+        const FFI_RETURNS_TWICE         = 1 << 10;\n+        /// #[track_caller]: allow access to the caller location\n+        const TRACK_CALLER              = 1 << 11;\n     }\n }\n \n@@ -2728,6 +2774,7 @@ impl CodegenFnAttrs {\n             optimize: OptimizeAttr::None,\n             export_name: None,\n             link_name: None,\n+            link_ordinal: None,\n             target_features: vec![],\n             linkage: None,\n             link_section: None,"}, {"sha": "b852098d4cef7fc2a9e148c0df1def1da5659227", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,10 +1,10 @@\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::source_map::{SourceMap, Spanned};\n-use syntax::parse::ParseSess;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self, Comments, PrintState};\n+use syntax::sess::ParseSess;\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};"}, {"sha": "14d0673ecc03fe51f3677cc1ecaa98973bb85332", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -13,7 +13,7 @@ use std::cell::RefCell;\n \n use syntax::ast;\n use syntax::source_map::SourceMap;\n-use syntax::ext::hygiene::SyntaxContext;\n+use syntax_expand::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "defc3fb25bc52bb890276adcdac6d755e963b7fc", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -59,7 +59,7 @@ impl_stable_hash_for!(enum ::syntax::ast::AsmDialect {\n     Intel\n });\n \n-impl_stable_hash_for!(enum ::syntax::ext::base::MacroKind {\n+impl_stable_hash_for!(enum ::syntax_expand::base::MacroKind {\n     Bang,\n     Attr,\n     Derive,"}, {"sha": "f6068855e630cc3d514c59d13d41cc553e0a6ca0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 {\n                     sp = param.span;\n                 }\n-                (format!(\"the lifetime {} as defined on\", br.name), sp)\n+                (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n             }\n             ty::ReFree(ty::FreeRegion {\n                 bound_region: ty::BoundRegion::BrNamed(_, name),\n@@ -213,15 +213,15 @@ impl<'tcx> TyCtxt<'tcx> {\n                 {\n                     sp = param.span;\n                 }\n-                (format!(\"the lifetime {} as defined on\", name), sp)\n+                (format!(\"the lifetime `{}` as defined on\", name), sp)\n             }\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n                     self.hir().span(node),\n                 ),\n                 _ => (\n-                    format!(\"the lifetime {} as defined on\", region),\n+                    format!(\"the lifetime `{}` as defined on\", region),\n                     cm.def_span(self.hir().span(node)),\n                 ),\n             },\n@@ -935,6 +935,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         .filter(|(a, b)| a == b)\n                         .count();\n                     let len = sub1.len() - common_default_params;\n+                    let consts_offset = len - sub1.consts().count();\n \n                     // Only draw `<...>` if there're lifetime/type arguments.\n                     if len > 0 {\n@@ -981,7 +982,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     //         ^ elided type as this type argument was the same in both sides\n                     let type_arguments = sub1.types().zip(sub2.types());\n                     let regions_len = sub1.regions().count();\n-                    for (i, (ta1, ta2)) in type_arguments.take(len).enumerate() {\n+                    let num_display_types = consts_offset - regions_len;\n+                    for (i, (ta1, ta2)) in type_arguments.take(num_display_types).enumerate() {\n                         let i = i + regions_len;\n                         if ta1 == ta2 {\n                             values.0.push_normal(\"_\");\n@@ -994,6 +996,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         self.push_comma(&mut values.0, &mut values.1, len, i);\n                     }\n \n+                    // Do the same for const arguments, if they are equal, do not highlight and\n+                    // elide them from the output.\n+                    let const_arguments = sub1.consts().zip(sub2.consts());\n+                    for (i, (ca1, ca2)) in const_arguments.enumerate() {\n+                        let i = i + consts_offset;\n+                        if ca1 == ca2 {\n+                            values.0.push_normal(\"_\");\n+                            values.1.push_normal(\"_\");\n+                        } else {\n+                            values.0.push_highlighted(ca1.to_string());\n+                            values.1.push_highlighted(ca2.to_string());\n+                        }\n+                        self.push_comma(&mut values.0, &mut values.1, len, i);\n+                    }\n+\n                     // Close the type argument bracket.\n                     // Only draw `<...>` if there're lifetime/type arguments.\n                     if len > 0 {"}, {"sha": "f30f19d41509dae6fc66849778fd9e27185437b5", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -19,8 +19,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use smallvec::SmallVec;\n use std::fmt;\n use syntax_pos::Span;\n \n@@ -304,8 +304,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n-            debug!(\"expansion: constraint={:?}\", constraint);\n+        let mut process_constraint = |constraint: &Constraint<'tcx>| {\n             let (a_region, b_vid, b_data, retain) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n@@ -331,7 +330,33 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n             let changed = self.expand_node(a_region, b_vid, b_data);\n             (changed, retain)\n-        })\n+        };\n+\n+        // Using bitsets to track the remaining elements is faster than using a\n+        // `Vec` by itself (which requires removing elements, which requires\n+        // element shuffling, which is slow).\n+        let constraints: Vec<_> = self.data.constraints.keys().collect();\n+        let mut live_indices: BitSet<usize> = BitSet::new_filled(constraints.len());\n+        let mut killed_indices: BitSet<usize> = BitSet::new_empty(constraints.len());\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            for index in live_indices.iter() {\n+                let constraint = constraints[index];\n+                let (edge_changed, retain) = process_constraint(constraint);\n+                if edge_changed {\n+                    changed = true;\n+                }\n+                if !retain {\n+                    let changed = killed_indices.insert(index);\n+                    debug_assert!(changed);\n+                }\n+            }\n+            live_indices.subtract(&killed_indices);\n+\n+            // We could clear `killed_indices` here, but we don't need to and\n+            // it's cheaper not to.\n+        }\n     }\n \n     // This function is very hot in some workloads. There's a single callsite\n@@ -360,13 +385,21 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         match *b_data {\n             VarValue::Value(cur_region) => {\n                 // Identical scopes can show up quite often, if the fixed point\n-                // iteration converges slowly, skip them\n+                // iteration converges slowly. Skip them. This is purely an\n+                // optimization.\n                 if let (ReScope(a_scope), ReScope(cur_scope)) = (a_region, cur_region) {\n                     if a_scope == cur_scope {\n                         return false;\n                     }\n                 }\n \n+                // This is a specialized version of the `lub_concrete_regions`\n+                // check below for a common case, here purely as an\n+                // optimization.\n+                if let ReEmpty = a_region {\n+                    return false;\n+                }\n+\n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n@@ -407,8 +440,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let tcx = self.tcx();\n-\n         match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n@@ -468,15 +499,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n                 // otherwise, we don't know what the free region is,\n                 // so we must conservatively say the LUB is static:\n-                tcx.lifetimes.re_static\n+                self.tcx().lifetimes.re_static\n             }\n \n             (&ReScope(a_id), &ReScope(b_id)) => {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n                 let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                tcx.mk_region(ReScope(lub))\n+                self.tcx().mk_region(ReScope(lub))\n             }\n \n             (&ReEarlyBound(_), &ReEarlyBound(_))\n@@ -490,7 +521,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 if a == b {\n                     a\n                 } else {\n-                    tcx.lifetimes.re_static\n+                    self.tcx().lifetimes.re_static\n                 }\n             }\n         }\n@@ -860,29 +891,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-    where\n-        F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n-    {\n-        let mut constraints: SmallVec<[_; 16]> = self.data.constraints.keys().collect();\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            constraints.retain(|constraint| {\n-                let (edge_changed, retain) = body(constraint);\n-                if edge_changed {\n-                    debug!(\"updated due to constraint {:?}\", constraint);\n-                    changed = true;\n-                }\n-                retain\n-            });\n-        }\n-        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n-    }\n-\n     fn bound_is_met(\n         &self,\n         bound: &VerifyBound<'tcx>,"}, {"sha": "af74d13572431a147c3235666ce7ab470b9337e7", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -814,16 +814,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Executes `f` and commit the bindings.\n     pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n     where\n-        F: FnOnce() -> R,\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n-        debug!(\"commit()\");\n+        debug!(\"commit_unconditionally()\");\n         let snapshot = self.start_snapshot();\n-        let r = f();\n+        let r = f(&snapshot);\n         self.commit_from(snapshot);\n         r\n     }\n \n-    /// Executes `f` and commit the bindings if closure `f` returns `Ok(_)`.\n+    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n@@ -843,19 +843,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` in a snapshot, and commit the bindings it creates.\n-    pub fn in_snapshot<T, F>(&self, f: F) -> T\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T,\n-    {\n-        debug!(\"in_snapshot()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.commit_from(snapshot);\n-        r\n-    }\n-\n-    /// Executes `f` then unroll any bindings it creates.\n+    /// Execute `f` then unroll any bindings it creates.\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,"}, {"sha": "bd19a002fe8b7bf676e185b527bd5a034eaa574c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -733,12 +733,12 @@ where\n                 // Skip lifetime parameters of the enclosing item(s)\n                 // Also skip the witness type, because that has no free regions.\n \n-                for upvar_ty in substs.upvar_tys(def_id, self.tcx) {\n+                for upvar_ty in substs.as_generator().upvar_tys(def_id, self.tcx) {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.return_ty(def_id, self.tcx).visit_with(self);\n-                substs.yield_ty(def_id, self.tcx).visit_with(self);\n+                substs.as_generator().return_ty(def_id, self.tcx).visit_with(self);\n+                substs.as_generator().yield_ty(def_id, self.tcx).visit_with(self);\n             }\n             _ => {\n                 ty.super_visit_with(self);\n@@ -902,7 +902,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             ty::Generator(def_id, substs, movability) => {\n                 let generics = self.tcx.generics_of(def_id);\n                 let substs =\n-                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n+                    self.tcx.mk_substs(substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n@@ -912,7 +912,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                         }\n                     }));\n \n-                self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n+                self.tcx.mk_generator(def_id, substs, movability)\n             }\n \n             ty::Param(..) => {"}, {"sha": "3d069425685c7761dd67a7f10e127297e238e54b", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -14,9 +14,11 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// retain the older (arguably incorrect) behavior of the\n     /// compiler.\n     ///\n-    /// NB. The use of snapshot here is mostly an efficiency thing --\n-    /// we could search *all* region constraints, but that'd be a\n-    /// bigger set and the data structures are not setup for that. If\n+    /// NB. Although `_snapshot` isn't used, it's passed in to prove\n+    /// that we are in a snapshot, which guarantees that we can just\n+    /// search the \"undo log\" for edges. This is mostly an efficiency\n+    /// thing -- we could search *all* region constraints, but that'd be\n+    /// a bigger set and the data structures are not setup for that. If\n     /// we wind up keeping some form of this check long term, it would\n     /// probably be better to remove the snapshot parameter and to\n     /// refactor the constraint set."}, {"sha": "8943fc342c023efa22c6b9f52919df12807e799d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -35,7 +35,6 @@\n #![feature(const_transmute)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n-#![feature(inner_deref)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n@@ -57,9 +56,8 @@\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n-#![feature(proc_macro_hygiene)]\n+#![cfg_attr(bootstrap, feature(proc_macro_hygiene))]\n #![feature(log_syntax)]\n-#![feature(mem_take)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n \n@@ -102,16 +100,12 @@ pub mod lint;\n pub mod middle {\n     pub mod expr_use_visitor;\n     pub mod cstore;\n-    pub mod dead;\n     pub mod dependency_format;\n     pub mod diagnostic_items;\n-    pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;\n-    pub mod intrinsicck;\n     pub mod lib_features;\n     pub mod lang_items;\n-    pub mod liveness;\n     pub mod mem_categorization;\n     pub mod privacy;\n     pub mod reachable;"}, {"sha": "4c28f6372fe2c6db543819ea21a7d9324e4b39ba", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -21,7 +21,8 @@ declare_lint! {\n declare_lint! {\n     pub CONST_ERR,\n     Deny,\n-    \"constant evaluation detected erroneous expression\"\n+    \"constant evaluation detected erroneous expression\",\n+    report_in_external_macro: true\n }\n \n declare_lint! {\n@@ -79,6 +80,12 @@ declare_lint! {\n     \"detects unreachable patterns\"\n }\n \n+declare_lint! {\n+    pub OVERLAPPING_PATTERNS,\n+    Warn,\n+    \"detects overlapping patterns\"\n+}\n+\n declare_lint! {\n     pub UNUSED_MACROS,\n     Warn,\n@@ -368,6 +375,12 @@ pub mod parser {\n         Allow,\n         \"possible meta-variable misuse at macro definition\"\n     }\n+\n+    declare_lint! {\n+        pub INCOMPLETE_INCLUDE,\n+        Deny,\n+        \"trailing content in included file\"\n+    }\n }\n \n declare_lint! {\n@@ -416,6 +429,7 @@ declare_lint_pass! {\n         DEAD_CODE,\n         UNREACHABLE_CODE,\n         UNREACHABLE_PATTERNS,\n+        OVERLAPPING_PATTERNS,\n         UNUSED_MACROS,\n         WARNINGS,\n         UNUSED_FEATURES,"}, {"sha": "60b1b192d10db13aac2c2479fd2fff0111b5fd7f", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHa\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n+use syntax::print::pprust;\n use syntax::source_map::MultiSpan;\n use syntax::symbol::{Symbol, sym};\n \n@@ -285,7 +286,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                             tool_ident.span,\n                             E0710,\n                             \"an unknown tool name found in scoped lint: `{}`\",\n-                            meta_item.path\n+                            pprust::path_to_string(&meta_item.path),\n                         );\n                         continue;\n                     }"}, {"sha": "7443cca822a99b40a4037cf9631805b0c71e4d91", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -28,6 +28,7 @@ use crate::hir::intravisit;\n use crate::hir;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::builtin::parser::{ILL_FORMED_ATTRIBUTE_INPUT, META_VARIABLE_MISUSE};\n+use crate::lint::builtin::parser::INCOMPLETE_INCLUDE;\n use crate::session::{Session, DiagnosticMessageId};\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n@@ -38,7 +39,7 @@ use syntax::ast;\n use syntax::source_map::{MultiSpan, ExpnKind, DesugaringKind};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n-use syntax::ext::base::MacroKind;\n+use syntax_expand::base::MacroKind;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n@@ -83,6 +84,7 @@ impl Lint {\n         match lint_id {\n             BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n             BufferedEarlyLintId::MetaVariableMisuse => META_VARIABLE_MISUSE,\n+            BufferedEarlyLintId::IncompleteInclude => INCOMPLETE_INCLUDE,\n         }\n     }\n "}, {"sha": "2170a288c922bac2d84a27e2c041fdaf9694116c", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -32,6 +32,12 @@ pub struct CrateSource {\n     pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n+impl CrateSource {\n+    pub fn paths(&self) -> impl Iterator<Item = &PathBuf> {\n+        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).map(|p| &p.0)\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Copy, Clone,\n          Ord, PartialOrd, Eq, PartialEq, Debug, HashStable)]\n pub enum DepKind {\n@@ -96,6 +102,8 @@ pub enum NativeLibraryKind {\n     NativeStaticNobundle,\n     /// macOS-specific\n     NativeFramework,\n+    /// Windows dynamic library without import library.\n+    NativeRawDylib,\n     /// default way to specify a dynamic library\n     NativeUnknown,\n }\n@@ -206,7 +214,6 @@ pub trait CrateStore {\n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n-    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n "}, {"sha": "a122d84a5aa7ec84481f8a675d758075cb36723c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -708,15 +708,22 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n+                            let def_id = if let Region::EarlyBound(_ ,def_id , _) = reg {\n+                                def_id\n+                            } else {\n+                                bug!();\n+                            };\n                             if let hir::ParamName::Plain(param_name) = name {\n                                 if param_name.name == kw::UnderscoreLifetime {\n                                     // Pick the elided lifetime \"definition\" if one exists\n                                     // and use it to make an elision scope.\n+                                    self.lifetime_uses.insert(def_id.clone(), LifetimeUseSet::Many);\n                                     elision = Some(reg);\n                                 } else {\n                                     lifetimes.insert(name, reg);\n                                 }\n                             } else {\n+                                self.lifetime_uses.insert(def_id.clone(), LifetimeUseSet::Many);\n                                 lifetimes.insert(name, reg);\n                             }\n                         }\n@@ -1615,7 +1622,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => None,\n                     } {\n                         debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n-\n                         if name.name == kw::UnderscoreLifetime {\n                             continue;\n                         }"}, {"sha": "302c11f309d90b21608d8fa6eaef81eb549f94de", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -485,7 +485,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn report_unstable(\n-    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, is_soft: bool, span: Span\n+    sess: &Session,\n+    feature: Symbol,\n+    reason: Option<Symbol>,\n+    issue: u32,\n+    is_soft: bool,\n+    span: Span,\n+    soft_handler: impl FnOnce(&'static lint::Lint, Span, &str),\n ) {\n     let msg = match reason {\n         Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n@@ -511,7 +517,7 @@ pub fn report_unstable(\n     let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n     if fresh {\n         if is_soft {\n-            sess.buffer_lint(lint::builtin::SOFT_UNSTABLE, CRATE_NODE_ID, span, &msg);\n+            soft_handler(lint::builtin::SOFT_UNSTABLE, span, &msg)\n         } else {\n             emit_feature_err(\n                 &sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg\n@@ -779,10 +785,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n+        let soft_handler =\n+            |lint, span, msg: &_| self.lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg);\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue, is_soft } =>\n-                report_unstable(self.sess, feature, reason, issue, is_soft, span),\n+                report_unstable(self.sess, feature, reason, issue, is_soft, span, soft_handler),\n             EvalResult::Unmarked => {\n                 // The API could be uncallable for other reasons, for example when a private module\n                 // was referenced."}, {"sha": "d918b9ee67347e8ef4be0409e75c1c35a78da0e4", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -363,6 +363,8 @@ pub enum UndefinedBehaviorInfo {\n     UbExperimental(String),\n     /// Unreachable code was executed.\n     Unreachable,\n+    /// An enum discriminant was set to a value which was outside the range of valid values.\n+    InvalidDiscriminant(ScalarMaybeUndef),\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -373,6 +375,8 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n                 write!(f, \"{}\", msg),\n             Unreachable =>\n                 write!(f, \"entered unreachable code\"),\n+            InvalidDiscriminant(val) =>\n+                write!(f, \"encountered invalid enum discriminant {}\", val),\n         }\n     }\n }\n@@ -389,10 +393,6 @@ pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n-    /// FIXME(#64506) Error used to work around accessing projections of\n-    /// uninhabited types.\n-    UninhabitedValue,\n-\n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -404,7 +404,6 @@ pub enum UnsupportedOpInfo<'tcx> {\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n-    InvalidDiscriminant(ScalarMaybeUndef),\n     PointerOutOfBounds {\n         ptr: Pointer,\n         msg: CheckInAllocMsg,\n@@ -489,8 +488,6 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                 write!(f, \"incorrect alloc info: expected size {} and align {}, \\\n                            got size {} and align {}\",\n                     size.bytes(), align.bytes(), size2.bytes(), align2.bytes()),\n-            InvalidDiscriminant(val) =>\n-                write!(f, \"encountered invalid enum discriminant {}\", val),\n             InvalidMemoryAccess =>\n                 write!(f, \"tried to access memory through an invalid pointer\"),\n             DanglingPointerDeref =>\n@@ -556,8 +553,6 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     not a power of two\"),\n             Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n-            UninhabitedValue =>\n-                write!(f, \"tried to use an uninhabited value\"),\n         }\n     }\n }"}, {"sha": "6c31d54e081c42b9ee62c787ff815eb7e58f02c8", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -470,6 +470,14 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n+    /// Panics if the `AllocId` does not refer to a function\n+    pub fn unwrap_fn(&self, id: AllocId) -> Instance<'tcx> {\n+        match self.get(id) {\n+            Some(GlobalAlloc::Function(instance)) => instance,\n+            _ => bug!(\"expected allocation ID {} to point to a function\", id),\n+        }\n+    }\n+\n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {"}, {"sha": "bbf00cc23ae8835008e18b6fc596fdf440afe47a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -343,14 +343,19 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn check_raw(data: u128, size: u8, target_size: Size) {\n+        assert_eq!(target_size.bytes(), size as u64);\n+        assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+        Scalar::check_data(data, size);\n+    }\n+\n     /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n-                Scalar::check_data(data, size);\n+                Self::check_raw(data, size, target_size);\n                 Ok(data)\n             }\n             Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),"}, {"sha": "9ac1465cb0ba9a0f58dd773a7cdfe0591e28b73e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -15,7 +15,7 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, GeneratorSubsts, Region, Ty, TyCtxt,\n+    self, AdtDef, CanonicalUserTypeAnnotations, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n \n@@ -2189,7 +2189,7 @@ pub enum AggregateKind<'tcx> {\n     Adt(&'tcx AdtDef, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n     Closure(DefId, SubstsRef<'tcx>),\n-    Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, SubstsRef<'tcx>, hir::GeneratorMovability),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2602,7 +2602,14 @@ impl<'tcx> Debug for Constant<'tcx> {\n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"const \")?;\n-        write!(fmt, \"{}\", self.literal)\n+        // FIXME make the default pretty printing of raw pointers more detailed. Here we output the\n+        // debug representation of raw pointers, so that the raw pointers in the mir dump output are\n+        // detailed and just not '{pointer}'.\n+        if let ty::RawPtr(_) = self.literal.ty.kind {\n+            write!(fmt, \"{:?} : {}\", self.literal.val, self.literal.ty)\n+        } else {\n+            write!(fmt, \"{}\", self.literal)\n+        }\n     }\n }\n "}, {"sha": "265ac975ed7a2c1f2e699da4b2f88af94584cf7a", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -386,6 +386,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             tcx.hir().as_local_hir_id(def_id)\n                         }\n                         InstanceDef::VtableShim(..) |\n+                        InstanceDef::ReifyShim(..) |\n                         InstanceDef::Intrinsic(..) |\n                         InstanceDef::FnPtrShim(..) |\n                         InstanceDef::Virtual(..) |"}, {"sha": "e87aabf9a0566498cbe1cd615819a20a58c1a2b6", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -197,7 +197,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 let ty = place.ty(local_decls, tcx).ty;\n                 match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n-                    ty::Generator(_, substs, _) => substs.discr_ty(tcx),\n+                    ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n                     _ => {\n                         // This can only be `0`, for now, so `u8` will suffice.\n                         tcx.types.u8"}, {"sha": "fef406e8987834328e3cf3aca97d58bec78e48a2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 138, "deletions": 89, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{CanonicalUserTypeAnnotation, GeneratorSubsts, Ty};\n+use crate::ty::{CanonicalUserTypeAnnotation, Ty};\n use crate::mir::*;\n use syntax_pos::Span;\n \n@@ -158,22 +158,7 @@ macro_rules! make_mir_visitor {\n                 self.super_place_base(base, context, location);\n             }\n \n-            fn visit_projection(&mut self,\n-                                base: & $($mutability)? PlaceBase<'tcx>,\n-                                projection: & $($mutability)? [PlaceElem<'tcx>],\n-                                context: PlaceContext,\n-                                location: Location) {\n-                self.super_projection(base, projection, context, location);\n-            }\n-\n-            fn visit_projection_elem(&mut self,\n-                                     base: & $($mutability)? PlaceBase<'tcx>,\n-                                     proj_base: & $($mutability)? [PlaceElem<'tcx>],\n-                                     elem: & $($mutability)? PlaceElem<'tcx>,\n-                                     context: PlaceContext,\n-                                     location: Location) {\n-                self.super_projection_elem(base, proj_base, elem, context, location);\n-            }\n+            visit_place_fns!($($mutability)?);\n \n             fn visit_constant(&mut self,\n                               constant: & $($mutability)? Constant<'tcx>,\n@@ -230,12 +215,6 @@ macro_rules! make_mir_visitor {\n                 self.super_substs(substs);\n             }\n \n-            fn visit_generator_substs(&mut self,\n-                                      substs: & $($mutability)? GeneratorSubsts<'tcx>,\n-                                    _: Location) {\n-                self.super_generator_substs(substs);\n-            }\n-\n             fn visit_local_decl(&mut self,\n                                 local: Local,\n                                 local_decl: & $($mutability)? LocalDecl<'tcx>) {\n@@ -628,7 +607,7 @@ macro_rules! make_mir_visitor {\n                                 generator_substs,\n                                 _movability,\n                             ) => {\n-                                self.visit_generator_substs(generator_substs, location);\n+                                self.visit_substs(generator_substs, location);\n                             }\n                         }\n \n@@ -687,28 +666,6 @@ macro_rules! make_mir_visitor {\n                 );\n             }\n \n-            fn super_place(&mut self,\n-                            place: & $($mutability)? Place<'tcx>,\n-                            context: PlaceContext,\n-                            location: Location) {\n-                let mut context = context;\n-\n-                if !place.projection.is_empty() {\n-                    context = if context.is_mutating_use() {\n-                        PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                    } else {\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                    };\n-                }\n-\n-                self.visit_place_base(& $($mutability)? place.base, context, location);\n-\n-                self.visit_projection(& $($mutability)? place.base,\n-                                      & $($mutability)? place.projection,\n-                                      context,\n-                                      location);\n-            }\n-\n             fn super_place_base(&mut self,\n                                 place_base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n@@ -723,45 +680,6 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_projection(&mut self,\n-                                base: & $($mutability)? PlaceBase<'tcx>,\n-                                projection: & $($mutability)? [PlaceElem<'tcx>],\n-                                context: PlaceContext,\n-                                location: Location) {\n-                let mut cursor = projection;\n-                while let [proj_base @ .., elem] = cursor {\n-                    cursor = proj_base;\n-                    self.visit_projection_elem(base, cursor, elem, context, location);\n-                }\n-            }\n-\n-            fn super_projection_elem(&mut self,\n-                                     _base: & $($mutability)? PlaceBase<'tcx>,\n-                                     _proj_base: & $($mutability)? [PlaceElem<'tcx>],\n-                                     elem: & $($mutability)? PlaceElem<'tcx>,\n-                                     _context: PlaceContext,\n-                                     location: Location) {\n-                match elem {\n-                    ProjectionElem::Field(_field, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n-                    }\n-                    ProjectionElem::Index(local) => {\n-                        self.visit_local(\n-                            local,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                            location\n-                        );\n-                    }\n-                    ProjectionElem::Deref |\n-                    ProjectionElem::Subslice { from: _, to: _ } |\n-                    ProjectionElem::ConstantIndex { offset: _,\n-                                                    min_length: _,\n-                                                    from_end: _ } |\n-                    ProjectionElem::Downcast(_, _) => {\n-                    }\n-                }\n-            }\n-\n             fn super_local_decl(&mut self,\n                                 local: Local,\n                                 local_decl: & $($mutability)? LocalDecl<'tcx>) {\n@@ -846,10 +764,6 @@ macro_rules! make_mir_visitor {\n             fn super_substs(&mut self, _substs: & $($mutability)? SubstsRef<'tcx>) {\n             }\n \n-            fn super_generator_substs(&mut self,\n-                                      _substs: & $($mutability)? GeneratorSubsts<'tcx>) {\n-            }\n-\n             // Convenience methods\n \n             fn visit_location(&mut self, body: & $($mutability)? Body<'tcx>, location: Location) {\n@@ -868,6 +782,141 @@ macro_rules! make_mir_visitor {\n     }\n }\n \n+macro_rules! visit_place_fns {\n+    (mut) => (\n+        fn super_place(\n+            &mut self,\n+            place: &mut Place<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            self.visit_place_base(&mut place.base, context, location);\n+\n+            if let Some(new_projection) = self.process_projection(&place.projection) {\n+                place.projection = new_projection;\n+            }\n+        }\n+\n+        fn process_projection(\n+            &mut self,\n+            projection: &'a [PlaceElem<'tcx>],\n+        ) -> Option<Box<[PlaceElem<'tcx>]>> {\n+            let mut projection = Cow::Borrowed(projection);\n+\n+            for i in 0..projection.len() {\n+                if let Some(elem) = projection.get(i) {\n+                    if let Some(elem) = self.process_projection_elem(elem) {\n+                        let vec = projection.to_mut();\n+                        vec[i] = elem;\n+                    }\n+                }\n+            }\n+\n+            match projection {\n+                Cow::Borrowed(_) => None,\n+                Cow::Owned(vec) => Some(vec.into_boxed_slice()),\n+            }\n+        }\n+\n+        fn process_projection_elem(\n+            &mut self,\n+            _elem: &PlaceElem<'tcx>,\n+        ) -> Option<PlaceElem<'tcx>> {\n+            None\n+        }\n+    );\n+\n+    () => (\n+        fn visit_projection(\n+            &mut self,\n+            base: &PlaceBase<'tcx>,\n+            projection: &[PlaceElem<'tcx>],\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            self.super_projection(base, projection, context, location);\n+        }\n+\n+        fn visit_projection_elem(\n+            &mut self,\n+            base: &PlaceBase<'tcx>,\n+            proj_base: &[PlaceElem<'tcx>],\n+            elem: &PlaceElem<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            self.super_projection_elem(base, proj_base, elem, context, location);\n+        }\n+\n+        fn super_place(\n+            &mut self,\n+            place: &Place<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            let mut context = context;\n+\n+            if !place.projection.is_empty() {\n+                context = if context.is_mutating_use() {\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                } else {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                };\n+            }\n+\n+            self.visit_place_base(&place.base, context, location);\n+\n+            self.visit_projection(&place.base,\n+                                  &place.projection,\n+                                  context,\n+                                  location);\n+        }\n+\n+        fn super_projection(\n+            &mut self,\n+            base: &PlaceBase<'tcx>,\n+            projection: &[PlaceElem<'tcx>],\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            let mut cursor = projection;\n+            while let [proj_base @ .., elem] = cursor {\n+                cursor = proj_base;\n+                self.visit_projection_elem(base, cursor, elem, context, location);\n+            }\n+        }\n+\n+        fn super_projection_elem(\n+            &mut self,\n+            _base: &PlaceBase<'tcx>,\n+            _proj_base: &[PlaceElem<'tcx>],\n+            elem: &PlaceElem<'tcx>,\n+            _context: PlaceContext,\n+            location: Location,\n+        ) {\n+            match elem {\n+                ProjectionElem::Field(_field, ty) => {\n+                    self.visit_ty(ty, TyContext::Location(location));\n+                }\n+                ProjectionElem::Index(local) => {\n+                    self.visit_local(\n+                        local,\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                        location\n+                    );\n+                }\n+                ProjectionElem::Deref |\n+                ProjectionElem::Subslice { from: _, to: _ } |\n+                ProjectionElem::ConstantIndex { offset: _,\n+                                                min_length: _,\n+                                                from_end: _ } |\n+                ProjectionElem::Downcast(_, _) => {\n+                }\n+            }\n+        }\n+    );\n+}\n+\n make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n "}, {"sha": "2c407a24493ffc956560b0287ab0dc8e88743bc6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -61,7 +61,7 @@ rustc_queries! {\n         /// predicate gets in the way of some checks, which are intended\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n-        query predicates_of(key: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n+        query predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -184,12 +184,10 @@ rustc_queries! {\n         /// predicates (where-clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n-        query predicates_defined_on(_: DefId)\n-            -> &'tcx ty::GenericPredicates<'tcx> {}\n+        query predicates_defined_on(_: DefId) -> ty::GenericPredicates<'tcx> {}\n \n         /// Returns the predicates written explicitly by the user.\n-        query explicit_predicates_of(_: DefId)\n-            -> &'tcx ty::GenericPredicates<'tcx> {}\n+        query explicit_predicates_of(_: DefId) -> ty::GenericPredicates<'tcx> {}\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n@@ -201,14 +199,13 @@ rustc_queries! {\n         /// evaluate them even during type conversion, often before the\n         /// full predicates are available (note that supertraits have\n         /// additional acyclicity requirements).\n-        query super_predicates_of(key: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n+        query super_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n         }\n \n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n-        query type_param_predicates(key: (DefId, DefId))\n-            -> &'tcx ty::GenericPredicates<'tcx> {\n+        query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n             no_force\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n                 let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n@@ -231,6 +228,12 @@ rustc_queries! {\n             cycle_delay_bug\n         }\n \n+        query trivial_dropck_outlives(ty: Ty<'tcx>) -> bool {\n+            anon\n+            no_force\n+            desc { \"checking if `{:?}` has trivial dropck\", ty }\n+        }\n+\n         query adt_dtorck_constraint(\n             _: DefId\n         ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}"}, {"sha": "675e3bbd002b0e46c975d6ad0ec56f103f5dee6c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 305, "deletions": 199, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -16,14 +16,15 @@ use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n-use syntax::parse::{ParseSess, new_parser_from_source_str};\n+use syntax::parse::new_parser_from_source_str;\n use syntax::parse::token;\n+use syntax::sess::ParseSess;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::source_map::SourceMap;\n \n use errors::emitter::HumanReadableErrorType;\n-use errors::{ColorConfig, FatalError, Handler};\n+use errors::{ColorConfig, FatalError, Handler, SourceMapperDyn};\n \n use getopts;\n \n@@ -1316,10 +1317,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"enable queries of the dependency graph for regression testing\"),\n-    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n-        \"trace and profile the queries of the incremental compilation framework\"),\n-    profile_queries_and_keys: bool = (false, parse_bool, [UNTRACKED],\n-        \"trace and profile the queries and keys of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n@@ -1345,7 +1342,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     mir_opt_level: usize = (1, parse_uint, [TRACKED],\n         \"set the MIR optimization level (0-3, default: 1)\"),\n     mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"emit noalias metadata for mutable references (default: yes on LLVM >= 6)\"),\n+        \"emit noalias metadata for mutable references (default: no)\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"dump MIR state to file.\n         `val` is used to select which passes and functions to dump. For example:\n@@ -1471,6 +1468,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"which mangling version to use for symbol names\"),\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info\"),\n+    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n+        \"fix undefined behavior when a thread doesn't eventually make progress \\\n+         (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1514,22 +1514,25 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n-            let s = i.to_string();\n-            ret.insert((\n-                sym::target_has_atomic,\n-                Some(Symbol::intern(&s)),\n-            ));\n-            if &s == wordsz {\n+            let mut insert_atomic = |s| {\n                 ret.insert((\n-                    sym::target_has_atomic,\n-                    Some(Symbol::intern(\"ptr\")),\n+                    sym::target_has_atomic_load_store,\n+                    Some(Symbol::intern(s)),\n                 ));\n+                if atomic_cas {\n+                    ret.insert((\n+                        sym::target_has_atomic,\n+                        Some(Symbol::intern(s))\n+                    ));\n+                }\n+            };\n+            let s = i.to_string();\n+            insert_atomic(&s);\n+            if &s == wordsz {\n+              insert_atomic(\"ptr\");\n             }\n         }\n     }\n-    if atomic_cas {\n-        ret.insert((sym::target_has_atomic, Some(Symbol::intern(\"cas\"))));\n-    }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }\n@@ -1855,6 +1858,7 @@ struct NullEmitter;\n \n impl errors::emitter::Emitter for NullEmitter {\n     fn emit_diagnostic(&mut self, _: &errors::Diagnostic) {}\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> { None }\n }\n \n // Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n@@ -2036,11 +2040,7 @@ pub fn parse_error_format(\n     return error_format;\n }\n \n-pub fn build_session_options_and_crate_config(\n-    matches: &getopts::Matches,\n-) -> (Options, FxHashSet<(String, Option<String>)>) {\n-    let color = parse_color(matches);\n-\n+fn parse_crate_edition(matches: &getopts::Matches) -> Edition {\n     let edition = match matches.opt_str(\"edition\") {\n         Some(arg) => Edition::from_str(&arg).unwrap_or_else(|_|\n             early_error(\n@@ -2067,19 +2067,14 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n-    let (json_rendered, json_artifact_notifications) = parse_json(matches);\n-\n-    let error_format = parse_error_format(matches, color, json_rendered);\n-\n-    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n-    let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(error_format, &e[..]));\n-\n-\n-    let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n-\n-    let mut debugging_opts = build_debugging_options(matches, error_format);\n+    edition\n+}\n \n+fn check_debug_option_stability(\n+    debugging_opts: &DebuggingOptions,\n+    error_format: ErrorOutputType,\n+    json_rendered: HumanReadableErrorType,\n+) {\n     if !debugging_opts.unstable_options {\n         if let ErrorOutputType::Json { pretty: true, json_rendered } = error_format {\n             early_error(\n@@ -2095,7 +2090,13 @@ pub fn build_session_options_and_crate_config(\n             );\n         }\n     }\n+}\n \n+fn parse_output_types(\n+    debugging_opts: &DebuggingOptions,\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType,\n+) -> OutputTypes {\n     let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n@@ -2120,14 +2121,19 @@ pub fn build_session_options_and_crate_config(\n     if output_types.is_empty() {\n         output_types.insert(OutputType::Exe, None);\n     }\n+    OutputTypes(output_types)\n+}\n \n-    let mut cg = build_codegen_options(matches, error_format);\n-    let mut codegen_units = cg.codegen_units;\n+fn should_override_cgus_and_disable_thinlto(\n+    output_types: &OutputTypes,\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType,\n+    mut codegen_units: Option<usize>,\n+) -> (bool, Option<usize>) {\n     let mut disable_thinlto = false;\n-\n     // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n-    let incompatible: Vec<_> = output_types\n+    let incompatible: Vec<_> = output_types.0\n         .iter()\n         .map(|ot_path| ot_path.0)\n         .filter(|ot| !ot.is_compatible_with_codegen_units_and_single_output_file())\n@@ -2159,29 +2165,39 @@ pub fn build_session_options_and_crate_config(\n         }\n     }\n \n-    if debugging_opts.threads == 0 {\n+    if codegen_units == Some(0) {\n         early_error(\n             error_format,\n-            \"value for threads must be a positive non-zero integer\",\n+            \"value for codegen units must be a positive non-zero integer\",\n         );\n     }\n \n-    if debugging_opts.threads > 1 && debugging_opts.fuel.is_some() {\n+    (disable_thinlto, codegen_units)\n+}\n+\n+fn check_thread_count(debugging_opts: &DebuggingOptions, error_format: ErrorOutputType) {\n+    if debugging_opts.threads == 0 {\n         early_error(\n             error_format,\n-            \"optimization fuel is incompatible with multiple threads\",\n+            \"value for threads must be a positive non-zero integer\",\n         );\n     }\n \n-    if codegen_units == Some(0) {\n+    if debugging_opts.threads > 1 && debugging_opts.fuel.is_some() {\n         early_error(\n             error_format,\n-            \"value for codegen units must be a positive non-zero integer\",\n+            \"optimization fuel is incompatible with multiple threads\",\n         );\n     }\n+}\n \n-    let incremental = match (&debugging_opts.incremental, &cg.incremental) {\n-        (&Some(ref path1), &Some(ref path2)) => {\n+fn select_incremental_path(\n+    debugging_opts: &DebuggingOptions,\n+    cg: &CodegenOptions,\n+    error_format: ErrorOutputType,\n+) -> Option<PathBuf> {\n+    match (&debugging_opts.incremental, &cg.incremental) {\n+        (Some(path1), Some(path2)) => {\n             if path1 != path2 {\n                 early_error(\n                     error_format,\n@@ -2195,25 +2211,19 @@ pub fn build_session_options_and_crate_config(\n                 Some(path1)\n             }\n         }\n-        (&Some(ref path), &None) => Some(path),\n-        (&None, &Some(ref path)) => Some(path),\n-        (&None, &None) => None,\n-    }.map(|m| PathBuf::from(m));\n-\n-    if debugging_opts.profile && incremental.is_some() {\n-        early_error(\n-            error_format,\n-            \"can't instrument with gcov profiling when compiling incrementally\",\n-        );\n-    }\n-\n-    if cg.profile_generate.enabled() && cg.profile_use.is_some() {\n-        early_error(\n-            error_format,\n-            \"options `-C profile-generate` and `-C profile-use` are exclusive\",\n-        );\n-    }\n+        (Some(path), None) => Some(path),\n+        (None, Some(path)) => Some(path),\n+        (None, None) => None,\n+    }.map(|m| PathBuf::from(m))\n+}\n \n+fn collect_print_requests(\n+    cg: &mut CodegenOptions,\n+    dopts: &mut DebuggingOptions,\n+    matches: &getopts::Matches,\n+    is_unstable_enabled: bool,\n+    error_format: ErrorOutputType,\n+) -> Vec<PrintRequest> {\n     let mut prints = Vec::<PrintRequest>::new();\n     if cg.target_cpu.as_ref().map_or(false, |s| s == \"help\") {\n         prints.push(PrintRequest::TargetCPUs);\n@@ -2231,72 +2241,105 @@ pub fn build_session_options_and_crate_config(\n         prints.push(PrintRequest::CodeModels);\n         cg.code_model = None;\n     }\n-    if debugging_opts\n+    if dopts\n         .tls_model\n         .as_ref()\n         .map_or(false, |s| s == \"help\")\n     {\n         prints.push(PrintRequest::TlsModels);\n-        debugging_opts.tls_model = None;\n+        dopts.tls_model = None;\n     }\n \n-    let cg = cg;\n+    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| match &*s {\n+        \"crate-name\" => PrintRequest::CrateName,\n+        \"file-names\" => PrintRequest::FileNames,\n+        \"sysroot\" => PrintRequest::Sysroot,\n+        \"cfg\" => PrintRequest::Cfg,\n+        \"target-list\" => PrintRequest::TargetList,\n+        \"target-cpus\" => PrintRequest::TargetCPUs,\n+        \"target-features\" => PrintRequest::TargetFeatures,\n+        \"relocation-models\" => PrintRequest::RelocationModels,\n+        \"code-models\" => PrintRequest::CodeModels,\n+        \"tls-models\" => PrintRequest::TlsModels,\n+        \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n+        \"target-spec-json\" => {\n+            if is_unstable_enabled {\n+                PrintRequest::TargetSpec\n+            } else {\n+                early_error(\n+                    error_format,\n+                    \"the `-Z unstable-options` flag must also be passed to \\\n+                     enable the target-spec-json print option\",\n+                );\n+            }\n+        }\n+        req => early_error(error_format, &format!(\"unknown print request `{}`\", req)),\n+    }));\n \n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n-    let target_triple = if let Some(target) = matches.opt_str(\"target\") {\n-        if target.ends_with(\".json\") {\n+    prints\n+}\n+\n+fn parse_target_triple(matches: &getopts::Matches, error_format: ErrorOutputType) -> TargetTriple {\n+    match matches.opt_str(\"target\") {\n+        Some(target) if target.ends_with(\".json\") => {\n             let path = Path::new(&target);\n             TargetTriple::from_path(&path).unwrap_or_else(|_|\n                 early_error(error_format, &format!(\"target file {:?} does not exist\", path)))\n+        }\n+        Some(target) => TargetTriple::TargetTriple(target),\n+        _ => TargetTriple::from_triple(host_triple()),\n+    }\n+}\n+\n+fn parse_opt_level(\n+    matches: &getopts::Matches,\n+    cg: &CodegenOptions,\n+    error_format: ErrorOutputType,\n+) -> OptLevel {\n+    // The `-O` and `-C opt-level` flags specify the same setting, so we want to be able\n+    // to use them interchangeably. However, because they're technically different flags,\n+    // we need to work out manually which should take precedence if both are supplied (i.e.\n+    // the rightmost flag). We do this by finding the (rightmost) position of both flags and\n+    // comparing them. Note that if a flag is not found, its position will be `None`, which\n+    // always compared less than `Some(_)`.\n+    let max_o = matches.opt_positions(\"O\").into_iter().max();\n+    let max_c = matches.opt_strs_pos(\"C\").into_iter().flat_map(|(i, s)| {\n+        if let Some(\"opt-level\") = s.splitn(2, '=').next() {\n+            Some(i)\n         } else {\n-            TargetTriple::TargetTriple(target)\n+            None\n         }\n+    }).max();\n+    if max_o > max_c {\n+        OptLevel::Default\n     } else {\n-        TargetTriple::from_triple(host_triple())\n-    };\n-    let opt_level = {\n-        // The `-O` and `-C opt-level` flags specify the same setting, so we want to be able\n-        // to use them interchangeably. However, because they're technically different flags,\n-        // we need to work out manually which should take precedence if both are supplied (i.e.\n-        // the rightmost flag). We do this by finding the (rightmost) position of both flags and\n-        // comparing them. Note that if a flag is not found, its position will be `None`, which\n-        // always compared less than `Some(_)`.\n-        let max_o = matches.opt_positions(\"O\").into_iter().max();\n-        let max_c = matches.opt_strs_pos(\"C\").into_iter().flat_map(|(i, s)| {\n-            if let Some(\"opt-level\") = s.splitn(2, '=').next() {\n-                Some(i)\n-            } else {\n-                None\n-            }\n-        }).max();\n-        if max_o > max_c {\n-            OptLevel::Default\n-        } else {\n-            match cg.opt_level.as_ref().map(String::as_ref) {\n-                None => OptLevel::No,\n-                Some(\"0\") => OptLevel::No,\n-                Some(\"1\") => OptLevel::Less,\n-                Some(\"2\") => OptLevel::Default,\n-                Some(\"3\") => OptLevel::Aggressive,\n-                Some(\"s\") => OptLevel::Size,\n-                Some(\"z\") => OptLevel::SizeMin,\n-                Some(arg) => {\n-                    early_error(\n-                        error_format,\n-                        &format!(\n-                            \"optimization level needs to be \\\n-                             between 0-3, s or z (instead was `{}`)\",\n-                            arg\n-                        ),\n-                    );\n-                }\n+        match cg.opt_level.as_ref().map(String::as_ref) {\n+            None => OptLevel::No,\n+            Some(\"0\") => OptLevel::No,\n+            Some(\"1\") => OptLevel::Less,\n+            Some(\"2\") => OptLevel::Default,\n+            Some(\"3\") => OptLevel::Aggressive,\n+            Some(\"s\") => OptLevel::Size,\n+            Some(\"z\") => OptLevel::SizeMin,\n+            Some(arg) => {\n+                early_error(\n+                    error_format,\n+                    &format!(\n+                        \"optimization level needs to be \\\n+                            between 0-3, s or z (instead was `{}`)\",\n+                        arg\n+                    ),\n+                );\n             }\n         }\n-    };\n-    // The `-g` and `-C debuginfo` flags specify the same setting, so we want to be able\n-    // to use them interchangeably. See the note above (regarding `-O` and `-C opt-level`)\n-    // for more details.\n-    let debug_assertions = cg.debug_assertions.unwrap_or(opt_level == OptLevel::No);\n+    }\n+}\n+\n+fn select_debuginfo(\n+    matches: &getopts::Matches,\n+    cg: &CodegenOptions,\n+    error_format: ErrorOutputType,\n+) -> DebugInfo {\n     let max_g = matches.opt_positions(\"g\").into_iter().max();\n     let max_c = matches.opt_strs_pos(\"C\").into_iter().flat_map(|(i, s)| {\n         if let Some(\"debuginfo\") = s.splitn(2, '=').next() {\n@@ -2305,7 +2348,7 @@ pub fn build_session_options_and_crate_config(\n             None\n         }\n     }).max();\n-    let debuginfo = if max_g > max_c {\n+    if max_g > max_c {\n         DebugInfo::Full\n     } else {\n         match cg.debuginfo {\n@@ -2323,14 +2366,14 @@ pub fn build_session_options_and_crate_config(\n                 );\n             }\n         }\n-    };\n-\n-    let mut search_paths = vec![];\n-    for s in &matches.opt_strs(\"L\") {\n-        search_paths.push(SearchPath::from_cli_opt(&s[..], error_format));\n     }\n+}\n \n-    let libs = matches\n+fn parse_libs(\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType,\n+) -> Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> {\n+    matches\n         .opt_strs(\"l\")\n         .into_iter()\n         .map(|s| {\n@@ -2369,52 +2412,23 @@ pub fn build_session_options_and_crate_config(\n             let new_name = name_parts.next();\n             (name.to_owned(), new_name.map(|n| n.to_owned()), kind)\n         })\n-        .collect();\n-\n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n-    let test = matches.opt_present(\"test\");\n-\n-    let is_unstable_enabled = nightly_options::is_unstable_enabled(matches);\n-\n-    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| match &*s {\n-        \"crate-name\" => PrintRequest::CrateName,\n-        \"file-names\" => PrintRequest::FileNames,\n-        \"sysroot\" => PrintRequest::Sysroot,\n-        \"cfg\" => PrintRequest::Cfg,\n-        \"target-list\" => PrintRequest::TargetList,\n-        \"target-cpus\" => PrintRequest::TargetCPUs,\n-        \"target-features\" => PrintRequest::TargetFeatures,\n-        \"relocation-models\" => PrintRequest::RelocationModels,\n-        \"code-models\" => PrintRequest::CodeModels,\n-        \"tls-models\" => PrintRequest::TlsModels,\n-        \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n-        \"target-spec-json\" => {\n-            if is_unstable_enabled {\n-                PrintRequest::TargetSpec\n-            } else {\n-                early_error(\n-                    error_format,\n-                    \"the `-Z unstable-options` flag must also be passed to \\\n-                     enable the target-spec-json print option\",\n-                );\n-            }\n-        }\n-        req => early_error(error_format, &format!(\"unknown print request `{}`\", req)),\n-    }));\n+        .collect()\n+}\n \n-    let borrowck_mode = match debugging_opts.borrowck.as_ref().map(|s| &s[..]) {\n+fn parse_borrowck_mode(dopts: &DebuggingOptions, error_format: ErrorOutputType) -> BorrowckMode {\n+    match dopts.borrowck.as_ref().map(|s| &s[..]) {\n         None | Some(\"migrate\") => BorrowckMode::Migrate,\n         Some(\"mir\") => BorrowckMode::Mir,\n         Some(m) => early_error(error_format, &format!(\"unknown borrowck mode `{}`\", m)),\n-    };\n-\n-    if !cg.remark.is_empty() && debuginfo == DebugInfo::None {\n-        early_warn(\n-            error_format,\n-            \"-C remark requires \\\"-C debuginfo=n\\\" to show source locations\",\n-        );\n     }\n+}\n \n+fn parse_externs(\n+    matches: &getopts::Matches,\n+    debugging_opts: &DebuggingOptions,\n+    error_format: ErrorOutputType,\n+    is_unstable_enabled: bool,\n+) -> Externs {\n     if matches.opt_present(\"extern-private\") && !debugging_opts.unstable_options {\n         early_error(\n             ErrorOutputType::default(),\n@@ -2455,10 +2469,14 @@ pub fn build_session_options_and_crate_config(\n         // flag\n         entry.is_private_dep |= private;\n     }\n+    Externs(externs)\n+}\n \n-    let crate_name = matches.opt_str(\"crate-name\");\n-\n-    let remap_path_prefix = matches\n+fn parse_remap_path_prefix(\n+    matches: &getopts::Matches,\n+    error_format: ErrorOutputType\n+) -> Vec<(PathBuf, PathBuf)> {\n+    matches\n         .opt_strs(\"remap-path-prefix\")\n         .into_iter()\n         .map(|remap| {\n@@ -2473,42 +2491,130 @@ pub fn build_session_options_and_crate_config(\n                 ),\n             }\n         })\n-        .collect();\n+        .collect()\n+}\n \n-    (\n-        Options {\n-            crate_types,\n-            optimize: opt_level,\n-            debuginfo,\n-            lint_opts,\n-            lint_cap,\n-            describe_lints,\n-            output_types: OutputTypes(output_types),\n-            search_paths,\n-            maybe_sysroot: sysroot_opt,\n-            target_triple,\n-            test,\n-            incremental,\n-            debugging_opts,\n-            prints,\n-            borrowck_mode,\n-            cg,\n+pub fn build_session_options(matches: &getopts::Matches) -> Options {\n+    let color = parse_color(matches);\n+\n+    let edition = parse_crate_edition(matches);\n+\n+    let (json_rendered, json_artifact_notifications) = parse_json(matches);\n+\n+    let error_format = parse_error_format(matches, color, json_rendered);\n+\n+    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n+    let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n+        .unwrap_or_else(|e| early_error(error_format, &e[..]));\n+\n+    let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n+\n+    let mut debugging_opts = build_debugging_options(matches, error_format);\n+    check_debug_option_stability(&debugging_opts, error_format, json_rendered);\n+\n+    let output_types = parse_output_types(&debugging_opts, matches, error_format);\n+\n+    let mut cg = build_codegen_options(matches, error_format);\n+    let (disable_thinlto, codegen_units) = should_override_cgus_and_disable_thinlto(\n+        &output_types,\n+        matches,\n+        error_format,\n+        cg.codegen_units,\n+    );\n+\n+    check_thread_count(&debugging_opts, error_format);\n+\n+    let incremental = select_incremental_path(&debugging_opts, &cg, error_format);\n+\n+    if debugging_opts.profile && incremental.is_some() {\n+        early_error(\n             error_format,\n-            externs: Externs(externs),\n-            crate_name,\n-            alt_std_name: None,\n-            libs,\n-            unstable_features: UnstableFeatures::from_environment(),\n-            debug_assertions,\n-            actually_rustdoc: false,\n-            cli_forced_codegen_units: codegen_units,\n-            cli_forced_thinlto_off: disable_thinlto,\n-            remap_path_prefix,\n-            edition,\n-            json_artifact_notifications,\n-        },\n-        cfg,\n-    )\n+            \"can't instrument with gcov profiling when compiling incrementally\",\n+        );\n+    }\n+\n+    if cg.profile_generate.enabled() && cg.profile_use.is_some() {\n+        early_error(\n+            error_format,\n+            \"options `-C profile-generate` and `-C profile-use` are exclusive\",\n+        );\n+    }\n+\n+    let is_unstable_enabled = nightly_options::is_unstable_enabled(matches);\n+    let prints = collect_print_requests(\n+        &mut cg,\n+        &mut debugging_opts,\n+        matches,\n+        is_unstable_enabled,\n+        error_format,\n+    );\n+\n+    let cg = cg;\n+\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n+    let target_triple = parse_target_triple(matches, error_format);\n+    let opt_level = parse_opt_level(matches, &cg, error_format);\n+    // The `-g` and `-C debuginfo` flags specify the same setting, so we want to be able\n+    // to use them interchangeably. See the note above (regarding `-O` and `-C opt-level`)\n+    // for more details.\n+    let debug_assertions = cg.debug_assertions.unwrap_or(opt_level == OptLevel::No);\n+    let debuginfo = select_debuginfo(matches, &cg, error_format);\n+\n+    let mut search_paths = vec![];\n+    for s in &matches.opt_strs(\"L\") {\n+        search_paths.push(SearchPath::from_cli_opt(&s[..], error_format));\n+    }\n+\n+    let libs = parse_libs(matches, error_format);\n+\n+    let test = matches.opt_present(\"test\");\n+\n+    let borrowck_mode = parse_borrowck_mode(&debugging_opts, error_format);\n+\n+    if !cg.remark.is_empty() && debuginfo == DebugInfo::None {\n+        early_warn(\n+            error_format,\n+            \"-C remark requires \\\"-C debuginfo=n\\\" to show source locations\",\n+        );\n+    }\n+\n+    let externs = parse_externs(matches, &debugging_opts, error_format, is_unstable_enabled);\n+\n+    let crate_name = matches.opt_str(\"crate-name\");\n+\n+    let remap_path_prefix = parse_remap_path_prefix(matches, error_format);\n+\n+    Options {\n+        crate_types,\n+        optimize: opt_level,\n+        debuginfo,\n+        lint_opts,\n+        lint_cap,\n+        describe_lints,\n+        output_types,\n+        search_paths,\n+        maybe_sysroot: sysroot_opt,\n+        target_triple,\n+        test,\n+        incremental,\n+        debugging_opts,\n+        prints,\n+        borrowck_mode,\n+        cg,\n+        error_format,\n+        externs,\n+        crate_name,\n+        alt_std_name: None,\n+        libs,\n+        unstable_features: UnstableFeatures::from_environment(),\n+        debug_assertions,\n+        actually_rustdoc: false,\n+        cli_forced_codegen_units: codegen_units,\n+        cli_forced_thinlto_off: disable_thinlto,\n+        remap_path_prefix,\n+        edition,\n+        json_artifact_notifications,\n+    }\n }\n \n pub fn make_crate_type_option() -> RustcOptGroup {"}, {"sha": "061bbdc307fc4bf4d9d03b7251fec8934c1602cf", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -3,8 +3,9 @@ use crate::lint;\n use crate::middle::cstore;\n use crate::session::config::{\n     build_configuration,\n-    build_session_options_and_crate_config,\n-    to_crate_config\n+    build_session_options,\n+    to_crate_config,\n+    parse_cfgspecs,\n };\n use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n use crate::session::build_session;\n@@ -18,6 +19,16 @@ use syntax::symbol::sym;\n use syntax::edition::{Edition, DEFAULT_EDITION};\n use syntax;\n use super::Options;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub fn build_session_options_and_crate_config(\n+    matches: &getopts::Matches,\n+) -> (Options, FxHashSet<(String, Option<String>)>) {\n+    (\n+        build_session_options(matches),\n+        parse_cfgspecs(matches.opt_strs(\"cfg\")),\n+    )\n+}\n \n impl ExternEntry {\n     fn new_public<S: Into<String>,"}, {"sha": "b65bf2230b39d953681f3ec4d501b857081a1c4c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -7,11 +7,10 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n+use crate::session::config::{OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n-use crate::util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n@@ -25,11 +24,11 @@ use errors::emitter::HumanReadableErrorType;\n use errors::annotate_snippet_emitter_writer::{AnnotateSnippetEmitterWriter};\n use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n-use syntax::ext::allocator::AllocatorKind;\n+use syntax_expand::allocator::AllocatorKind;\n use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n-use syntax::parse::{self, ParseSess};\n+use syntax::sess::ParseSess;\n use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n use crate::util::profiling::{SelfProfiler, SelfProfilerRef};\n@@ -46,7 +45,7 @@ use std::fmt;\n use std::io::Write;\n use std::path::PathBuf;\n use std::time::Duration;\n-use std::sync::{Arc, mpsc};\n+use std::sync::Arc;\n \n mod code_stats;\n pub mod config;\n@@ -125,9 +124,6 @@ pub struct Session {\n     /// `-Zquery-dep-graph` is specified.\n     pub cgu_reuse_tracker: CguReuseTracker,\n \n-    /// Used by `-Z profile-queries` in `util::common`.\n-    pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n-\n     /// Used by `-Z self-profile`.\n     pub prof: SelfProfilerRef,\n \n@@ -509,13 +505,6 @@ impl Session {\n     pub fn time_extended(&self) -> bool {\n         self.opts.debugging_opts.time_passes\n     }\n-    pub fn profile_queries(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries\n-            || self.opts.debugging_opts.profile_queries_and_keys\n-    }\n-    pub fn profile_queries_and_keys(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries_and_keys\n-    }\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n@@ -637,6 +626,14 @@ impl Session {\n             .output_types\n             .contains_key(&OutputType::LlvmAssembly)\n             || self.opts.output_types.contains_key(&OutputType::Bitcode);\n+\n+        // Address sanitizer and memory sanitizer use alloca name when reporting an issue.\n+        let more_names = match self.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => true,\n+            Some(Sanitizer::Memory) => true,\n+            _ => more_names,\n+        };\n+\n         self.opts.debugging_opts.fewer_names || !more_names\n     }\n \n@@ -1162,7 +1159,7 @@ fn build_session_(\n     );\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    let parse_sess = parse::ParseSess::with_span_handler(\n+    let parse_sess = ParseSess::with_span_handler(\n         span_diagnostic,\n         source_map,\n     );\n@@ -1234,7 +1231,6 @@ fn build_session_(\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n         prof: SelfProfilerRef::new(self_profiler),\n-        profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "daa4a215a238a4623f1f73685ce4e1bb112dc4b4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 273, "deletions": 23, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -453,21 +453,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn find_similar_impl_candidates(&self,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Vec<ty::TraitRef<'tcx>>\n-    {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.skip_binder().self_ty(),\n-                                              true);\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {\n             Some(simp) => all_impls.iter().filter_map(|&def_id| {\n                 let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                let imp_simp = fast_reject::simplify_type(self.tcx,\n-                                                          imp.self_ty(),\n-                                                          true);\n+                let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n                 if let Some(imp_simp) = imp_simp {\n                     if simp != imp_simp {\n                         return None\n@@ -482,10 +478,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_similar_impl_candidates(&self,\n-                                      impl_candidates: Vec<ty::TraitRef<'tcx>>,\n-                                      err: &mut DiagnosticBuilder<'_>)\n-    {\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n         if impl_candidates.is_empty() {\n             return;\n         }\n@@ -718,12 +715,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // these notes will often be of the form\n                             //     \"the type `T` can't be frobnicated\"\n                             // which is somewhat confusing.\n-                            err.help(&format!(\"consider adding a `where {}` bound\",\n-                                              trait_ref.to_predicate()));\n-                        } else if !have_alt_message {\n-                            // Can't show anything else useful, try to find similar impls.\n-                            let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                            self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n                         }\n \n                         // If this error is due to `!: Trait` not implemented but `(): Trait` is\n@@ -955,6 +963,175 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n+    fn suggest_restricting_param_bound(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (param_ty, projection) = match &self_ty.kind {\n+            ty::Param(_) => (true, None),\n+            ty::Projection(projection) => (false, Some(projection)),\n+            _ => return,\n+        };\n+\n+        let mut suggest_restriction = |generics: &hir::Generics, msg| {\n+            let span = generics.where_clause.span_for_predicates_or_empty_place();\n+            if !span.from_expansion() && span.desugaring_kind().is_none() {\n+                err.span_suggestion(\n+                    generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+                    &format!(\"consider further restricting {}\", msg),\n+                    format!(\n+                        \"{} {} \",\n+                        if !generics.where_clause.predicates.is_empty() {\n+                            \",\"\n+                        } else {\n+                            \" where\"\n+                        },\n+                        trait_ref.to_predicate(),\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        };\n+\n+        // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n+        //        don't suggest `T: Sized + ?Sized`.\n+        let mut hir_id = body_id;\n+        while let Some(node) = self.tcx.hir().find(hir_id) {\n+            match node {\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..), ..\n+                }) if param_ty && self_ty == self.tcx.types.self_param => {\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(&generics, \"`Self`\");\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), ..\n+                }) |\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..), ..\n+                }) |\n+                hir::Node::ImplItem(hir::ImplItem {\n+                    generics,\n+                    kind: hir::ImplItemKind::Method(..), ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, _, _), ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..), ..\n+                }) if projection.is_some() => {\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\");\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Struct(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Enum(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Union(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TyAlias(_, generics), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TraitAlias(generics, _), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }), span, ..\n+                }) |\n+                hir::Node::TraitItem(hir::TraitItem { generics, span, .. }) |\n+                hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n+                if param_ty => {\n+                    // Missing generic type parameter bound.\n+                    let restrict_msg = \"consider further restricting this bound\";\n+                    let param_name = self_ty.to_string();\n+                    for param in generics.params.iter().filter(|p| {\n+                        &param_name == std::convert::AsRef::<str>::as_ref(&p.name.ident().as_str())\n+                    }) {\n+                        if param_name.starts_with(\"impl \") {\n+                            // `impl Trait` in argument:\n+                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+                            err.span_suggestion(\n+                                param.span,\n+                                restrict_msg,\n+                                // `impl CurrentTrait + MissingTrait`\n+                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else if generics.where_clause.predicates.is_empty() &&\n+                                param.bounds.is_empty()\n+                        {\n+                            // If there are no bounds whatsoever, suggest adding a constraint\n+                            // to the type parameter:\n+                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                            err.span_suggestion(\n+                                param.span,\n+                                \"consider restricting this bound\",\n+                                format!(\"{}\", trait_ref.to_predicate()),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else if !generics.where_clause.predicates.is_empty() {\n+                            // There is a `where` clause, so suggest expanding it:\n+                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+                            err.span_suggestion(\n+                                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                                &format!(\n+                                    \"consider further restricting type parameter `{}`\",\n+                                    param_name,\n+                                ),\n+                                format!(\", {}\", trait_ref.to_predicate()),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            // If there is no `where` clause lean towards constraining to the\n+                            // type parameter:\n+                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+                            let sp = param.span.with_hi(span.hi());\n+                            let span = self.tcx.sess.source_map()\n+                                .span_through_char(sp, ':');\n+                            if sp != param.span && sp != span {\n+                                // Only suggest if we have high certainty that the span\n+                                // covers the colon in `foo<T: Trait>`.\n+                                err.span_suggestion(span, restrict_msg, format!(\n+                                    \"{} + \",\n+                                    trait_ref.to_predicate(),\n+                                ), Applicability::MachineApplicable);\n+                            } else {\n+                                err.span_label(param.span, &format!(\n+                                    \"consider adding a `where {}` bound\",\n+                                    trait_ref.to_predicate(),\n+                                ));\n+                            }\n+                        }\n+                        return;\n+                    }\n+                }\n+\n+                hir::Node::Crate => return,\n+\n+                _ => {}\n+            }\n+\n+            hir_id = self.tcx.hir().get_parent_item(hir_id);\n+        }\n+    }\n+\n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n     fn suggest_borrow_on_unsized_slice(\n@@ -1081,9 +1258,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n                     let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n-                    let new_obligation = Obligation::new(ObligationCause::dummy(),\n-                                                         obligation.param_env,\n-                                                         new_trait_ref.to_predicate());\n+                    let new_obligation = Obligation::new(\n+                        ObligationCause::dummy(),\n+                        obligation.param_env,\n+                        new_trait_ref.to_predicate(),\n+                    );\n \n                     if self.predicate_may_hold(&new_obligation) {\n                         let sp = self.tcx.sess.source_map()\n@@ -1105,6 +1284,77 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Check if the trait bound is implemented for a different mutability and note it in the\n+    /// final error.\n+    fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let span = obligation.cause.span;\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .take_while(|c| *c == '&')\n+                .count();\n+            if let Some('\\'') = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .skip(refs_number)\n+                .next()\n+            { // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+            if trait_ref.has_infer_types() {\n+                // Do not ICE while trying to find if a reborrow would succeed on a trait with\n+                // unresolved bindings.\n+                return;\n+            }\n+\n+            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                let trait_type = match mutability {\n+                    hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+                };\n+\n+                let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n+                let new_trait_ref = ty::TraitRef::new(trait_ref.skip_binder().def_id, substs);\n+                let new_obligation = Obligation::new(\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                    new_trait_ref.to_predicate(),\n+                );\n+\n+                if self.evaluate_obligation_no_overflow(\n+                    &new_obligation,\n+                ).must_apply_modulo_regions() {\n+                    let sp = self.tcx.sess.source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                    if points_at_arg &&\n+                        mutability == hir::Mutability::MutImmutable &&\n+                        refs_number > 0\n+                    {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider changing this borrow's mutability\",\n+                            \"&mut \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.note(&format!(\n+                            \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n+                            trait_ref,\n+                            trait_type,\n+                            trait_ref.skip_binder().self_ty(),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "d96330bf0a9b4680b88b16328cea577577d4749b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -610,7 +610,7 @@ pub struct VtableImplData<'tcx, N> {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n-    pub substs: ty::GeneratorSubsts<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the generator\n     /// signature contains associated types.\n     pub nested: Vec<N>"}, {"sha": "d88bbe145d1fd7be647528ec025f91e8e2a78c60", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1259,7 +1259,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = vtable.substs.poly_sig(vtable.generator_def_id, selcx.tcx());\n+    let gen_sig = vtable.substs.as_generator().poly_sig(vtable.generator_def_id, selcx.tcx());\n     let Normalized {\n         value: gen_sig,\n         obligations\n@@ -1505,8 +1505,8 @@ fn assoc_ty_def(\n \n     if let Some(assoc_item) = trait_def\n         .ancestors(tcx, impl_def_id)\n-        .defs(tcx, assoc_ty_name, ty::AssocKind::Type, trait_def_id)\n-        .next() {\n+        .leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type) {\n+\n         assoc_item\n     } else {\n         // This is saying that neither the trait nor"}, {"sha": "e84c91daf293f39fbbea8dfc04592a1384406264", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -5,6 +5,7 @@ use std::iter::FromIterator;\n use syntax::source_map::Span;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::query::Providers;\n \n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -33,7 +34,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n         // Quick check: there are a number of cases that we know do not require\n         // any destructor.\n         let tcx = self.infcx.tcx;\n-        if trivial_dropck_outlives(tcx, ty) {\n+        if tcx.trivial_dropck_outlives(ty) {\n             return InferOk {\n                 value: vec![],\n                 obligations: vec![],\n@@ -207,15 +208,15 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Error => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => tcx.trivial_dropck_outlives(ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n+        ty::Tuple(ref tys) => tys.iter().all(|t| tcx.trivial_dropck_outlives(t.expect_ty())),\n         ty::Closure(def_id, ref substs) => substs\n             .as_closure()\n             .upvar_tys(def_id, tcx)\n-            .all(|t| trivial_dropck_outlives(tcx, t)),\n+            .all(|t| tcx.trivial_dropck_outlives(t)),\n \n         ty::Adt(def, _) => {\n             if Some(def.did) == tcx.lang_items().manually_drop() {\n@@ -243,3 +244,10 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n     }\n }\n+\n+crate fn provide(p: &mut Providers<'_>) {\n+    *p = Providers {\n+        trivial_dropck_outlives,\n+        ..*p\n+    };\n+}"}, {"sha": "0d426cab9b751381f3106051b92e97ca269acdc2", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     // Helper function that canonicalizes and runs the query. If an\n     // overflow results, we re-run it in the local context so we can\n     // report a nice error.\n-    fn evaluate_obligation_no_overflow(\n+    crate fn evaluate_obligation_no_overflow(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> EvaluationResult {"}, {"sha": "86a32d68fc09eca78d414b9f393028e39db53cae", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,5 +1,4 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n-use crate::traits::query::dropck_outlives::trivial_dropck_outlives;\n use crate::traits::query::dropck_outlives::DropckOutlivesResult;\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -22,7 +21,7 @@ impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n-        if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n+        if tcx.trivial_dropck_outlives(key.value.dropped_ty) {\n             Some(DropckOutlivesResult::default())\n         } else {\n             None"}, {"sha": "44d611ace77d017abf94ebce568eb950cac09fa3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2761,8 +2761,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 .collect(),\n \n             ty::Generator(def_id, ref substs, _) => {\n-                let witness = substs.witness(def_id, self.tcx());\n+                let witness = substs.as_generator().witness(def_id, self.tcx());\n                 substs\n+                    .as_generator()\n                     .upvar_tys(def_id, self.tcx())\n                     .chain(iter::once(witness))\n                     .collect()\n@@ -2818,7 +2819,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // binder moved -\\\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n-                self.infcx.in_snapshot(|_| {\n+                self.infcx.commit_unconditionally(|_| {\n                     let (skol_ty, _) = self.infcx\n                         .replace_bound_vars_with_placeholders(&ty);\n                     let Normalized {\n@@ -2931,7 +2932,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.infcx.commit_unconditionally(|snapshot| {\n             let result =\n                 self.match_projection_obligation_against_definition_bounds(\n                     obligation,\n@@ -3053,19 +3054,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             nested,\n         );\n \n-        let trait_obligations: Vec<PredicateObligation<'_>> = self.infcx.in_snapshot(|_| {\n-            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let (trait_ref, _) = self.infcx\n-                .replace_bound_vars_with_placeholders(&poly_trait_ref);\n-            let cause = obligation.derived_cause(ImplDerivedObligation);\n-            self.impl_or_trait_obligations(\n-                cause,\n-                obligation.recursion_depth + 1,\n-                obligation.param_env,\n-                trait_def_id,\n-                &trait_ref.substs,\n-            )\n-        });\n+        let trait_obligations: Vec<PredicateObligation<'_>> =\n+            self.infcx.commit_unconditionally(|_| {\n+                let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+                let (trait_ref, _) = self.infcx\n+                    .replace_bound_vars_with_placeholders(&poly_trait_ref);\n+                let cause = obligation.derived_cause(ImplDerivedObligation);\n+                self.impl_or_trait_obligations(\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    trait_def_id,\n+                    &trait_ref.substs,\n+                )\n+            });\n \n         // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n         // predicate as usual.  It won't have any effect since auto traits are coinductive.\n@@ -3088,7 +3090,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.infcx.commit_unconditionally(|snapshot| {\n             let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n@@ -3252,7 +3254,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation, alias_def_id\n         );\n \n-        self.infcx.in_snapshot(|_| {\n+        self.infcx.commit_unconditionally(|_| {\n             let (predicate, _) = self.infcx()\n                 .replace_bound_vars_with_placeholders(&obligation.predicate);\n             let trait_ref = predicate.trait_ref;\n@@ -3324,8 +3326,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         )?);\n \n         Ok(VtableGeneratorData {\n-            generator_def_id: generator_def_id,\n-            substs: substs.clone(),\n+            generator_def_id,\n+            substs,\n             nested: obligations,\n         })\n     }\n@@ -3911,9 +3913,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         closure_def_id: DefId,\n-        substs: ty::GeneratorSubsts<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n-        let gen_sig = substs.poly_sig(closure_def_id, self.tcx());\n+        let gen_sig = substs.as_generator().poly_sig(closure_def_id, self.tcx());\n \n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an generator type and hence is"}, {"sha": "c1c6eb850f591158a4a53fd63a053f7fc73b3261", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -125,7 +125,7 @@ pub fn find_associated_item<'tcx>(\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n-    match ancestors.defs(tcx, item.ident, item.kind, trait_def_id).next() {\n+    match ancestors.leaf_def(tcx, item.ident, item.kind) {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = param_env.with_reveal_all();\n@@ -419,7 +419,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String>\n \n     // The predicates will contain default bounds like `T: Sized`. We need to\n     // remove these bounds, and add `T: ?Sized` to any untouched type parameters.\n-    let predicates = &tcx.predicates_of(impl_def_id).predicates;\n+    let predicates = tcx.predicates_of(impl_def_id).predicates;\n     let mut pretty_predicates = Vec::with_capacity(\n         predicates.len() + types_without_default_bounds.len());\n "}, {"sha": "c64d6748ea97d563e47b7de484320192875c4415", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -7,7 +7,6 @@ use crate::traits;\n use crate::ty::{self, TyCtxt, TypeFoldable};\n use crate::ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Ident;\n-use crate::util::captures::Captures;\n use crate::util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n@@ -419,6 +418,35 @@ impl<'tcx> Node {\n         tcx.associated_items(self.def_id())\n     }\n \n+    /// Finds an associated item defined in this node.\n+    ///\n+    /// If this returns `None`, the item can potentially still be found in\n+    /// parents of this node.\n+    pub fn item(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_item_name: Ident,\n+        trait_item_kind: ty::AssocKind,\n+        trait_def_id: DefId,\n+    ) -> Option<ty::AssocItem> {\n+        use crate::ty::AssocKind::*;\n+\n+        tcx.associated_items(self.def_id())\n+            .find(move |impl_item| match (trait_item_kind, impl_item.kind) {\n+                | (Const, Const)\n+                | (Method, Method)\n+                | (Type, Type)\n+                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n+                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n+\n+                | (Const, _)\n+                | (Method, _)\n+                | (Type, _)\n+                | (OpaqueTy, _)\n+                => false,\n+            })\n+    }\n+\n     pub fn def_id(&self) -> DefId {\n         match *self {\n             Node::Impl(did) => did,\n@@ -427,6 +455,7 @@ impl<'tcx> Node {\n     }\n }\n \n+#[derive(Copy, Clone)]\n pub struct Ancestors<'tcx> {\n     trait_def_id: DefId,\n     specialization_graph: &'tcx Graph,\n@@ -465,32 +494,18 @@ impl<T> NodeItem<T> {\n }\n \n impl<'tcx> Ancestors<'tcx> {\n-    /// Search the items from the given ancestors, returning each definition\n-    /// with the given name and the given kind.\n-    // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n-    #[inline]\n-    pub fn defs(\n-        self,\n+    /// Finds the bottom-most (ie. most specialized) definition of an associated\n+    /// item.\n+    pub fn leaf_def(\n+        mut self,\n         tcx: TyCtxt<'tcx>,\n         trait_item_name: Ident,\n         trait_item_kind: ty::AssocKind,\n-        trait_def_id: DefId,\n-    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'tcx> + 'tcx {\n-        self.flat_map(move |node| {\n-            use crate::ty::AssocKind::*;\n-            node.items(tcx).filter(move |impl_item| match (trait_item_kind, impl_item.kind) {\n-                | (Const, Const)\n-                | (Method, Method)\n-                | (Type, Type)\n-                | (Type, OpaqueTy)\n-                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n-\n-                | (Const, _)\n-                | (Method, _)\n-                | (Type, _)\n-                | (OpaqueTy, _)\n-                => false,\n-            }).map(move |item| NodeItem { node: node, item: item })\n+    ) -> Option<NodeItem<ty::AssocItem>> {\n+        let trait_def_id = self.trait_def_id;\n+        self.find_map(|node| {\n+            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n+                .map(|item| NodeItem { node, item })\n         })\n     }\n }"}, {"sha": "d8b1effe09bf41de6cff5796c3e2856f2365991d", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -4,7 +4,6 @@ use syntax_pos::Span;\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n-use crate::traits::specialize::specialization_graph::NodeItem;\n use crate::ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use crate::ty::outlives::Component;\n use crate::ty::subst::{GenericArg, Subst, SubstsRef};\n@@ -667,8 +666,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn impl_item_is_final(self, node_item: &NodeItem<hir::Defaultness>) -> bool {\n-        node_item.item.is_final() && !self.impl_is_default(node_item.node.def_id())\n+    pub fn impl_item_is_final(self, assoc_item: &ty::AssocItem) -> bool {\n+        assoc_item.defaultness.is_final() && !self.impl_is_default(assoc_item.container.id())\n     }\n }\n "}, {"sha": "03cb4775bd83f9958fb851128773e1b10261bced", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -16,6 +16,7 @@ use std::intrinsics;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::subst::SubstsRef;\n use crate::mir::interpret::Allocation;\n+use syntax_pos::Span;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -92,16 +93,16 @@ pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n     Ok(())\n }\n \n-pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n-                                     predicates: &ty::GenericPredicates<'tcx>,\n-                                     cache: C)\n-                                     -> Result<(), E::Error>\n+pub fn encode_spanned_predicates<'tcx, E, C>(\n+    encoder: &mut E,\n+    predicates: &'tcx [(ty::Predicate<'tcx>, Span)],\n+    cache: C,\n+) -> Result<(), E::Error>\n     where E: TyEncoder,\n           C: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<ty::Predicate<'tcx>, usize>,\n {\n-    predicates.parent.encode(encoder)?;\n-    predicates.predicates.len().encode(encoder)?;\n-    for (predicate, span) in &predicates.predicates {\n+    predicates.len().encode(encoder)?;\n+    for (predicate, span) in predicates {\n         encode_with_shorthand(encoder, predicate, &cache)?;\n         span.encode(encoder)?;\n     }\n@@ -182,13 +183,15 @@ where\n }\n \n #[inline]\n-pub fn decode_predicates<D>(decoder: &mut D) -> Result<ty::GenericPredicates<'tcx>, D::Error>\n+pub fn decode_spanned_predicates<D>(\n+    decoder: &mut D,\n+) -> Result<&'tcx [(ty::Predicate<'tcx>, Span)], D::Error>\n where\n     D: TyDecoder<'tcx>,\n {\n-    Ok(ty::GenericPredicates {\n-        parent: Decodable::decode(decoder)?,\n-        predicates: (0..decoder.read_usize()?).map(|_| {\n+    let tcx = decoder.tcx();\n+    Ok(tcx.arena.alloc_from_iter(\n+        (0..decoder.read_usize()?).map(|_| {\n             // Handle shorthands first, if we have an usize > 0x80.\n             let predicate = if decoder.positioned_at_shorthand() {\n                 let pos = decoder.read_usize()?;\n@@ -202,7 +205,7 @@ where\n             Ok((predicate, Decodable::decode(decoder)?))\n         })\n         .collect::<Result<Vec<_>, _>>()?,\n-    })\n+    ))\n }\n \n #[inline]\n@@ -339,6 +342,8 @@ macro_rules! implement_ty_decoder {\n             use $crate::ty::subst::SubstsRef;\n             use $crate::hir::def_id::{CrateNum};\n \n+            use syntax_pos::Span;\n+\n             use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n@@ -393,11 +398,11 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<ty::GenericPredicates<'tcx>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx [(ty::Predicate<'tcx>, Span)]>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n-                    decode_predicates(self)\n+                                      -> Result<&'tcx [(ty::Predicate<'tcx>, Span)], Self::Error> {\n+                    decode_spanned_predicates(self)\n                 }\n             }\n "}, {"sha": "665d4c2d0696ababaf3fe164ee24ce21d534a088", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -29,7 +29,7 @@ use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{TyS, TyKind, List};\n-use crate::ty::{AdtKind, AdtDef, GeneratorSubsts, Region, Const};\n+use crate::ty::{AdtKind, AdtDef, Region, Const};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use crate::ty::RegionKind;\n use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid, ConstVid};\n@@ -43,7 +43,7 @@ use crate::ty::subst::{UserSubsts, GenericArgKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n-use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet, NodeMap};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::profiling::SelfProfilerRef;\n \n@@ -148,10 +148,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n }\n \n-pub struct Common<'tcx> {\n-    pub empty_predicates: ty::GenericPredicates<'tcx>,\n-}\n-\n pub struct CommonTypes<'tcx> {\n     pub unit: Ty<'tcx>,\n     pub bool: Ty<'tcx>,\n@@ -1039,9 +1035,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub prof: SelfProfilerRef,\n \n-    /// Common objects.\n-    pub common: Common<'tcx>,\n-\n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n@@ -1051,6 +1044,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n+    /// Resolutions of `extern crate` items produced by resolver.\n+    extern_crate_map: NodeMap<CrateNum>,\n+\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     trait_map: FxHashMap<DefIndex,\n@@ -1210,12 +1206,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(&arenas.interner);\n-        let common = Common {\n-            empty_predicates: ty::GenericPredicates {\n-                parent: None,\n-                predicates: vec![],\n-            },\n-        };\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n@@ -1270,10 +1260,10 @@ impl<'tcx> TyCtxt<'tcx> {\n             interners,\n             dep_graph,\n             prof: s.prof.clone(),\n-            common,\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n+            extern_crate_map: resolutions.extern_crate_map,\n             trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n                 let exports: Vec<_> = v.into_iter().map(|e| {\n@@ -2510,7 +2500,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_generator(self,\n                         id: DefId,\n-                        generator_substs: GeneratorSubsts<'tcx>,\n+                        generator_substs: SubstsRef<'tcx>,\n                         movability: hir::GeneratorMovability)\n                         -> Ty<'tcx> {\n         self.mk_ty(Generator(id, generator_substs, movability))\n@@ -2868,8 +2858,29 @@ impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n \n impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n-    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        Ok(f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?))\n+    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(mut iter: I, f: F)\n+            -> Self::Output {\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // The match arms are in order of frequency. The 1, 2, and 0 cases are\n+        // typically hit in ~95% of cases. We assume that if the upper and\n+        // lower bounds from `size_hint` agree they are correct.\n+        Ok(match iter.size_hint() {\n+            (1, Some(1)) => {\n+                f(&[iter.next().unwrap()?])\n+            }\n+            (2, Some(2)) => {\n+                let t0 = iter.next().unwrap()?;\n+                let t1 = iter.next().unwrap()?;\n+                f(&[t0, t1])\n+            }\n+            (0, Some(0)) => {\n+                f(&[])\n+            }\n+            _ => {\n+                f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?)\n+            }\n+        })\n     }\n }\n \n@@ -2930,7 +2941,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.extern_mod_stmt_cnum = |tcx, id| {\n         let id = tcx.hir().as_local_node_id(id).unwrap();\n-        tcx.cstore.extern_mod_stmt_cnum_untracked(id)\n+        tcx.extern_crate_map.get(&id).cloned()\n     };\n     providers.all_crate_nums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "d3a3f51cfa47b7a8abb7aa106cbec3556d0b91bd", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -94,7 +94,7 @@ impl FlagComputation {\n             &ty::Generator(_, ref substs, _) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                self.add_substs(&substs.substs);\n+                self.add_substs(substs);\n             }\n \n             &ty::GeneratorWitness(ref ts) => {\n@@ -250,7 +250,9 @@ impl FlagComputation {\n             ConstValue::Placeholder(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_REGIONS | TypeFlags::HAS_CT_PLACEHOLDER);\n             }\n-            _ => {},\n+            ConstValue::Scalar(_) => { }\n+            ConstValue::Slice { data: _, start: _, end: _ } => { }\n+            ConstValue::ByRef { alloc: _, offset: _ } => { }\n         }\n     }\n "}, {"sha": "5192075c26e9871068aedc5d7f17fda753228b73", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -911,13 +911,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     }\n \n     fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> bool {\n-        if let ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, _)),\n-            ..\n-        } = *ct {\n-            debruijn >= self.outer_index\n-        } else {\n-            false\n+        // we don't have a `visit_infer_const` callback, so we have to\n+        // hook in here to catch this case (annoying...), but\n+        // otherwise we do want to remember to visit the rest of the\n+        // const, as it has types/regions embedded in a lot of other\n+        // places.\n+        match ct.val {\n+            ConstValue::Infer(ty::InferConst::Canonical(debruijn, _))\n+                if debruijn >= self.outer_index => true,\n+            _ => ct.super_visit_with(self),\n         }\n     }\n }"}, {"sha": "5139c8085a583d7021a0b13fede6e04cdc590e34", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,3 +1,4 @@\n+use crate::hir::CodegenFnAttrFlags;\n use crate::hir::Unsafety;\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n@@ -25,6 +26,14 @@ pub enum InstanceDef<'tcx> {\n     /// `<T as Trait>::method` where `method` receives unsizeable `self: Self`.\n     VtableShim(DefId),\n \n+    /// `fn()` pointer where the function itself cannot be turned into a pointer.\n+    ///\n+    /// One example in the compiler today is functions annotated with `#[track_caller]`, which\n+    /// must have their implicit caller location argument populated for a call. Because this is a\n+    /// required part of the function's ABI but can't be tracked as a property of the function\n+    /// pointer, we create a single \"caller location\" at the site where the function is reified.\n+    ReifyShim(DefId),\n+\n     /// `<fn() as FnTrait>::call_*`\n     /// `DefId` is `FnTrait::call_*`\n     FnPtrShim(DefId, Ty<'tcx>),\n@@ -71,7 +80,7 @@ impl<'tcx> Instance<'tcx> {\n                 ))\n             }\n             ty::Generator(def_id, substs, _) => {\n-                let sig = substs.poly_sig(def_id, tcx);\n+                let sig = substs.as_generator().poly_sig(def_id, tcx);\n \n                 let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n@@ -123,6 +132,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         match *self {\n             InstanceDef::Item(def_id) |\n             InstanceDef::VtableShim(def_id) |\n+            InstanceDef::ReifyShim(def_id) |\n             InstanceDef::FnPtrShim(def_id, _) |\n             InstanceDef::Virtual(def_id, _) |\n             InstanceDef::Intrinsic(def_id, ) |\n@@ -178,6 +188,9 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::VtableShim(_) => {\n                 write!(f, \" - shim(vtable)\")\n             }\n+            InstanceDef::ReifyShim(_) => {\n+                write!(f, \" - shim(reify)\")\n+            }\n             InstanceDef::Intrinsic(_) => {\n                 write!(f, \" - intrinsic\")\n             }\n@@ -290,6 +303,30 @@ impl<'tcx> Instance<'tcx> {\n         result\n     }\n \n+    pub fn resolve_for_fn_ptr(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>> {\n+        debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n+        Instance::resolve(tcx, param_env, def_id, substs).map(|resolved| {\n+            let has_track_caller = |def| tcx.codegen_fn_attrs(def).flags\n+                .contains(CodegenFnAttrFlags::TRACK_CALLER);\n+\n+            match resolved.def {\n+                InstanceDef::Item(def_id) if has_track_caller(def_id) => {\n+                    debug!(\" => fn pointer created for function with #[track_caller]\");\n+                    Instance {\n+                        def: InstanceDef::ReifyShim(def_id),\n+                        substs,\n+                    }\n+                },\n+                _ => resolved,\n+            }\n+        })\n+    }\n+\n     pub fn resolve_for_vtable(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -395,7 +432,7 @@ fn resolve_associated_item<'tcx>(\n         traits::VtableGenerator(generator_data) => {\n             Some(Instance {\n                 def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-                substs: generator_data.substs.substs\n+                substs: generator_data.substs\n             })\n         }\n         traits::VtableClosure(closure_data) => {"}, {"sha": "aed9e87a168ce8cdd0dfc81dc192d06885b3d847", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,5 +1,5 @@\n use crate::session::{self, DataTypeKind};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, subst::SubstsRef};\n \n use syntax::ast::{self, Ident, IntTy, UintTy};\n use syntax::attr;\n@@ -15,7 +15,6 @@ use std::ops::Bound;\n use crate::hir;\n use crate::ich::StableHashingContext;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n-use crate::ty::GeneratorSubsts;\n use crate::ty::subst::Subst;\n use rustc_index::bit_set::BitSet;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -671,7 +670,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 tcx.intern_layout(unit)\n             }\n \n-            ty::Generator(def_id, substs, _) => self.generator_layout(ty, def_id, &substs)?,\n+            ty::Generator(def_id, substs, _) => self.generator_layout(ty, def_id, substs)?,\n \n             ty::Closure(def_id, ref substs) => {\n                 let tys = substs.as_closure().upvar_tys(def_id, tcx);\n@@ -825,10 +824,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     });\n                     (present_variants.next(), present_variants.next())\n                 };\n-                if present_first.is_none() {\n+                let present_first = match present_first {\n+                    present_first @ Some(_) => present_first,\n                     // Uninhabited because it has no variants, or only absent ones.\n-                    return tcx.layout_raw(param_env.and(tcx.types.never));\n-                }\n+                    None if def.is_enum() => return tcx.layout_raw(param_env.and(tcx.types.never)),\n+                    // if it's a struct, still compute a layout so that we can still compute the\n+                    // field offsets\n+                    None => Some(VariantIdx::new(0)),\n+                };\n \n                 let is_struct = !def.is_enum() ||\n                     // Only one variant is present.\n@@ -1406,22 +1409,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         &self,\n         ty: Ty<'tcx>,\n         def_id: hir::def_id::DefId,\n-        substs: &GeneratorSubsts<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n         use SavedLocalEligibility::*;\n         let tcx = self.tcx;\n \n-        let subst_field = |ty: Ty<'tcx>| { ty.subst(tcx, substs.substs) };\n+        let subst_field = |ty: Ty<'tcx>| { ty.subst(tcx, substs) };\n \n         let info = tcx.generator_layout(def_id);\n         let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&info);\n \n         // Build a prefix layout, including \"promoting\" all ineligible\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n-        let discr_index = substs.prefix_tys(def_id, tcx).count();\n+        let discr_index = substs.as_generator().prefix_tys(def_id, tcx).count();\n         // FIXME(eddyb) set the correct vaidity range for the discriminant.\n-        let discr_layout = self.layout_of(substs.discr_ty(tcx))?;\n+        let discr_layout = self.layout_of(substs.as_generator().discr_ty(tcx))?;\n         let discr = match &discr_layout.abi {\n             Abi::Scalar(s) => s.clone(),\n             _ => bug!(),\n@@ -1430,7 +1433,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             .map(|local| subst_field(info.field_tys[local]))\n             .map(|ty| tcx.mk_maybe_uninit(ty))\n             .map(|ty| self.layout_of(ty));\n-        let prefix_layouts = substs.prefix_tys(def_id, tcx)\n+        let prefix_layouts = substs.as_generator().prefix_tys(def_id, tcx)\n             .map(|ty| self.layout_of(ty))\n             .chain(iter::once(Ok(discr_layout)))\n             .chain(promoted_layouts)\n@@ -2153,15 +2156,15 @@ where\n             ty::Generator(def_id, ref substs, _) => {\n                 match this.variants {\n                     Variants::Single { index } => {\n-                        substs.state_tys(def_id, tcx)\n+                        substs.as_generator().state_tys(def_id, tcx)\n                             .nth(index.as_usize()).unwrap()\n                             .nth(i).unwrap()\n                     }\n                     Variants::Multiple { ref discr, discr_index, .. } => {\n                         if i == discr_index {\n                             return discr_layout(discr);\n                         }\n-                        substs.prefix_tys(def_id, tcx).nth(i).unwrap()\n+                        substs.as_generator().prefix_tys(def_id, tcx).nth(i).unwrap()\n                     }\n                 }\n             }"}, {"sha": "d46ab3769ad55063c88aff33da5e11af552de0e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -28,7 +28,7 @@ use crate::ty::subst::{Subst, InternalSubsts, SubstsRef};\n use crate::ty::util::{IntTypeExt, Discr};\n use crate::ty::walk::TypeWalker;\n use crate::util::captures::Captures;\n-use crate::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use crate::util::nodemap::{NodeMap, NodeSet, DefIdMap, FxHashMap};\n use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n@@ -45,7 +45,7 @@ use std::{mem, ptr};\n use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax_expand::hygiene::ExpnId;\n use syntax::symbol::{kw, sym, Symbol, InternedString};\n use syntax_pos::Span;\n \n@@ -121,6 +121,7 @@ mod sty;\n \n #[derive(Clone)]\n pub struct Resolutions {\n+    pub extern_crate_map: NodeMap<CrateNum>,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n@@ -700,6 +701,13 @@ impl<T> Deref for List<T> {\n     type Target = [T];\n     #[inline(always)]\n     fn deref(&self) -> &[T] {\n+        self.as_ref()\n+    }\n+}\n+\n+impl<T> AsRef<[T]> for List<T> {\n+    #[inline(always)]\n+    fn as_ref(&self) -> &[T] {\n         unsafe {\n             slice::from_raw_parts(self.data.as_ptr(), self.len)\n         }\n@@ -1010,15 +1018,12 @@ impl<'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Default, Debug, HashStable)]\n+#[derive(Copy, Clone, Default, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n-    pub predicates: Vec<(Predicate<'tcx>, Span)>,\n+    pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n-\n impl<'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate(\n         &self,\n@@ -2313,7 +2318,7 @@ impl<'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> &'tcx GenericPredicates<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n         tcx.predicates_of(self.did)\n     }\n \n@@ -2553,7 +2558,7 @@ impl<'tcx> AdtDef {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n-                let predicates = &tcx.predicates_of(self.did).predicates;\n+                let predicates = tcx.predicates_of(self.did).predicates;\n                 if predicates.iter().any(|(p, _)| *p == sized_predicate) {\n                     vec![]\n                 } else {\n@@ -3026,6 +3031,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 self.optimized_mir(did)\n             }\n             ty::InstanceDef::VtableShim(..) |\n+            ty::InstanceDef::ReifyShim(..) |\n             ty::InstanceDef::Intrinsic(..) |\n             ty::InstanceDef::FnPtrShim(..) |\n             ty::InstanceDef::Virtual(..) |\n@@ -3394,6 +3400,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     layout::provide(providers);\n     util::provide(providers);\n     constness::provide(providers);\n+    crate::traits::query::dropck_outlives::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,\n         associated_item,"}, {"sha": "80e77cdfad0b6ec97f5eaa990f2e3e88bb97eaf1", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -69,7 +69,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             ty::Generator(def_id, ref substs, _) => {\n                 // Same as the closure case\n-                for upvar_ty in substs.upvar_tys(def_id, *self) {\n+                for upvar_ty in substs.as_generator().upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n "}, {"sha": "df39d0ccc9eed08eab509f2504669679056ad7c0", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -8,7 +8,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::ConstValue;\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, Const, GeneratorSubsts, Instance, Ty, TyCtxt};\n+use rustc::ty::{self, Const, Instance, Ty, TyCtxt};\n use rustc::{bug, hir};\n use std::fmt::Write;\n use std::iter;\n@@ -154,7 +154,7 @@ impl DefPathBasedNames<'tcx> {\n                     self.push_type_name(sig.output(), output, debug);\n                 }\n             }\n-            ty::Generator(def_id, GeneratorSubsts { substs }, _)\n+            ty::Generator(def_id,  substs, _)\n             | ty::Closure(def_id, substs) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));"}, {"sha": "363109a0582df603c46fcea2c271505dabd1cfe6", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 118, "deletions": 115, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -605,8 +605,8 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Str => p!(write(\"str\")),\n             ty::Generator(did, substs, movability) => {\n-                let upvar_tys = substs.upvar_tys(did, self.tcx());\n-                let witness = substs.witness(did, self.tcx());\n+                let upvar_tys = substs.as_generator().upvar_tys(did, self.tcx());\n+                let witness = substs.as_generator().witness(did, self.tcx());\n                 if movability == hir::GeneratorMovability::Movable {\n                     p!(write(\"[generator\"));\n                 } else {\n@@ -689,7 +689,7 @@ pub trait PrettyPrinter<'tcx>:\n                 if self.tcx().sess.verbose() {\n                     p!(write(\n                         \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                        substs.as_closure().kind(did, self.tcx()),\n+                        substs.as_closure().kind_ty(did, self.tcx()),\n                         substs.as_closure().sig_ty(did, self.tcx())\n                     ));\n                 }\n@@ -698,7 +698,9 @@ pub trait PrettyPrinter<'tcx>:\n             },\n             ty::Array(ty, sz) => {\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n-                if let ConstValue::Unevaluated(..) = sz.val {\n+                if self.tcx().sess.verbose() {\n+                    p!(write(\"{:?}\", sz));\n+                } else if let ConstValue::Unevaluated(..) = sz.val {\n                     // do not try to evalute unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n@@ -855,126 +857,127 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        let u8 = self.tcx().types.u8;\n-        if let ty::FnDef(did, substs) = ct.ty.kind {\n-            p!(print_value_path(did, substs));\n+        if self.tcx().sess.verbose() {\n+            p!(write(\"Const({:?}: {:?})\", ct.val, ct.ty));\n             return Ok(self);\n         }\n-        if let ConstValue::Unevaluated(did, substs) = ct.val {\n-            match self.tcx().def_kind(did) {\n-                | Some(DefKind::Static)\n-                | Some(DefKind::Const)\n-                | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n-                _ => if did.is_local() {\n-                    let span = self.tcx().def_span(did);\n-                    if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n-                        p!(write(\"{}\", snip))\n+\n+        let u8 = self.tcx().types.u8;\n+\n+        match (ct.val, &ct.ty.kind) {\n+            (_,  ty::FnDef(did, substs)) => p!(print_value_path(*did, substs)),\n+            (ConstValue::Unevaluated(did, substs), _) => {\n+                match self.tcx().def_kind(did) {\n+                    | Some(DefKind::Static)\n+                    | Some(DefKind::Const)\n+                    | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n+                    _ => if did.is_local() {\n+                        let span = self.tcx().def_span(did);\n+                        if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n+                            p!(write(\"{}\", snip))\n+                        } else {\n+                            p!(write(\"_: \"), print(ct.ty))\n+                        }\n                     } else {\n                         p!(write(\"_: \"), print(ct.ty))\n-                    }\n+                    },\n+                }\n+            },\n+            (ConstValue::Infer(..), _) =>  p!(write(\"_: \"), print(ct.ty)),\n+            (ConstValue::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Bool) =>\n+                p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" })),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F32)) =>\n+                p!(write(\"{}f32\", Single::from_bits(data))),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F64)) =>\n+                p!(write(\"{}f64\", Double::from_bits(data))),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Uint(ui)) => {\n+                let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n+                let max = truncate(u128::max_value(), bit_size);\n+\n+                if data == max {\n+                    p!(write(\"std::{}::MAX\", ui))\n                 } else {\n-                    p!(write(\"_: \"), print(ct.ty))\n-                },\n-            }\n-            return Ok(self);\n-        }\n-        if let ConstValue::Infer(..) = ct.val {\n-            p!(write(\"_: \"), print(ct.ty));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Param(ParamConst { name, .. }) = ct.val {\n-            p!(write(\"{}\", name));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n-            match ct.ty.kind {\n-                ty::Bool => {\n-                    p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n-                    return Ok(self);\n-                },\n-                ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(data)));\n-                    return Ok(self);\n-                },\n-                ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(data)));\n-                    return Ok(self);\n-                },\n-                ty::Uint(ui) => {\n-                    let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(ui)).size();\n-                    let max = truncate(u128::max_value(), bit_size);\n+                    p!(write(\"{}{}\", data, ui))\n+                };\n+            },\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n+                let bit_size = Integer::from_attr(&self.tcx(), SignedInt(*i))\n+                    .size().bits() as u128;\n+                let min = 1u128 << (bit_size - 1);\n+                let max = min - 1;\n+\n+                let ty = self.tcx().lift(&ct.ty).unwrap();\n+                let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n+                    .unwrap()\n+                    .size;\n+                match data {\n+                    d if d == min => p!(write(\"std::{}::MIN\", i)),\n+                    d if d == max => p!(write(\"std::{}::MAX\", i)),\n+                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n+                }\n+            },\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) =>\n+                p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap())),\n+            (ConstValue::Scalar(_), ty::RawPtr(_)) => p!(write(\"{{pointer}}\")),\n+            (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::FnPtr(_)) => {\n+                let instance = {\n+                    let alloc_map = self.tcx().alloc_map.lock();\n+                    alloc_map.unwrap_fn(ptr.alloc_id)\n+                };\n+                p!(print_value_path(instance.def_id(), instance.substs));\n+            },\n+            _ => {\n+                let printed = if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n+                    let byte_str = match (ct.val, &ref_ty.kind) {\n+                        (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n+                            let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n+                            Some(self.tcx()\n+                                .alloc_map.lock()\n+                                .unwrap_memory(ptr.alloc_id)\n+                                .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n+                        },\n+                        (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                            // The `inspect` here is okay since we checked the bounds, and there are\n+                            // no relocations (we have an active slice reference here). We don't use\n+                            // this result to affect interpreter execution.\n+                            Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+                        },\n+                        _ => None,\n+                    };\n \n-                    if data == max {\n-                        p!(write(\"std::{}::MAX\", ui))\n+                    if let Some(byte_str) = byte_str {\n+                        p!(write(\"b\\\"\"));\n+                        for &c in byte_str {\n+                            for e in std::ascii::escape_default(c) {\n+                                self.write_char(e as char)?;\n+                            }\n+                        }\n+                        p!(write(\"\\\"\"));\n+                        true\n+                    } else if let (ConstValue::Slice { data, start, end }, ty::Str) =\n+                        (ct.val, &ref_ty.kind)\n+                    {\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                        let s = ::std::str::from_utf8(slice)\n+                            .expect(\"non utf8 str from miri\");\n+                        p!(write(\"{:?}\", s));\n+                        true\n                     } else {\n-                        p!(write(\"{}{}\", data, ui))\n-                    };\n-                    return Ok(self);\n-                },\n-                ty::Int(i) =>{\n-                    let bit_size = Integer::from_attr(&self.tcx(), SignedInt(i))\n-                        .size().bits() as u128;\n-                    let min = 1u128 << (bit_size - 1);\n-                    let max = min - 1;\n-\n-                    let ty = self.tcx().lift(&ct.ty).unwrap();\n-                    let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n-                        .unwrap()\n-                        .size;\n-                    match data {\n-                        d if d == min => p!(write(\"std::{}::MIN\", i)),\n-                        d if d == max => p!(write(\"std::{}::MAX\", i)),\n-                        _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n-                    }\n-                    return Ok(self);\n-                },\n-                ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()));\n-                    return Ok(self);\n-                }\n-                _ => {},\n-            }\n-        }\n-        if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n-            let byte_str = match (ct.val, &ref_ty.kind) {\n-                (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                    let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n-                    Some(self.tcx()\n-                        .alloc_map.lock()\n-                        .unwrap_memory(ptr.alloc_id)\n-                        .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    // The `inspect` here is okay since we checked the bounds, and there are no\n-                    // relocations (we have an active slice reference here). We don't use this\n-                    // result to affect interpreter execution.\n-                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    // The `inspect` here is okay since we checked the bounds, and there are no\n-                    // relocations (we have an active `str` reference here). We don't use this\n-                    // result to affect interpreter execution.\n-                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n-                    let s = ::std::str::from_utf8(slice)\n-                        .expect(\"non utf8 str from miri\");\n-                    p!(write(\"{:?}\", s));\n-                    return Ok(self);\n-                },\n-                _ => None,\n-            };\n-            if let Some(byte_str) = byte_str {\n-                p!(write(\"b\\\"\"));\n-                for &c in byte_str {\n-                    for e in std::ascii::escape_default(c) {\n-                        self.write_char(e as char)?;\n+                        false\n                     }\n+                } else {\n+                    false\n+                };\n+                if !printed {\n+                    // fallback\n+                    p!(write(\"{:?} : \", ct.val), print(ct.ty))\n                 }\n-                p!(write(\"\\\"\"));\n-                return Ok(self);\n             }\n-        }\n-        p!(write(\"{:?} : \", ct.val), print(ct.ty));\n-\n+        };\n         Ok(self)\n     }\n }\n@@ -1480,7 +1483,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         }\n \n         // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n+        // variants, using new unique identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give."}, {"sha": "c1c6a655d96a9132fe1e366f24b356a2582e1681", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -73,6 +73,17 @@ impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n             format!(\"processing {:?} with query `{}`\", def_id, name).into()\n         }\n     }\n+\n+    default fn cache_on_disk(_: TyCtxt<'tcx>, _: Self::Key, _: Option<&Self::Value>) -> bool {\n+        false\n+    }\n+\n+    default fn try_load_from_disk(\n+        _: TyCtxt<'tcx>,\n+        _: SerializedDepNodeIndex,\n+    ) -> Option<Self::Value> {\n+        bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n+    }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {"}, {"sha": "21a7cf00b283f54c43d5783e440697a090527d0f", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -882,15 +882,16 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> SpecializedEncoder<&'tcx [(ty::Predicate<'tcx>, Span)]>\n+    for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n-                          predicates: &ty::GenericPredicates<'tcx>)\n+                          predicates: &&'tcx [(ty::Predicate<'tcx>, Span)])\n                           -> Result<(), Self::Error> {\n-        ty_codec::encode_predicates(self, predicates,\n+        ty_codec::encode_spanned_predicates(self, predicates,\n             |encoder| &mut encoder.predicate_shorthands)\n     }\n }\n@@ -1075,7 +1076,7 @@ where\n     let desc = &format!(\"encode_query_results for {}\",\n         ::std::any::type_name::<Q>());\n \n-    time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n+    time_ext(tcx.sess.time_extended(), desc, || {\n         let shards = Q::query_cache(tcx).lock_shards();\n         assert!(shards.iter().all(|shard| shard.active.is_empty()));\n         for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {"}, {"sha": "7f05e553bc9765273d91dfd4f7157cad4873bf68", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 13, "deletions": 89, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -9,8 +9,6 @@ use crate::ty::query::Query;\n use crate::ty::query::config::{QueryConfig, QueryDescription};\n use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n \n-use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n-\n use errors::DiagnosticBuilder;\n use errors::Level;\n use errors::Diagnostic;\n@@ -62,33 +60,6 @@ impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n     }\n }\n \n-// If enabled, sends a message to the profile-queries thread.\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries() {\n-                profq_msg($tcx.sess, $msg)\n-            }\n-        }\n-    }\n-}\n-\n-// If enabled, formats a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_query_msg {\n-    ($query:expr, $tcx:expr, $key:expr) => {{\n-        let msg = if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None };\n-        QueryMsg {\n-            query: $query,\n-            msg,\n-        }\n-    }}\n-}\n-\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n@@ -111,7 +82,6 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         loop {\n             let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n-                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                 tcx.prof.query_cache_hit(Q::NAME);\n                 let result = (value.value.clone(), value.index);\n                 #[cfg(debug_assertions)]\n@@ -358,13 +328,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                key,\n                span);\n \n-        profq_msg!(self,\n-            ProfileQueriesMsg::QueryBegin(\n-                span.data(),\n-                profq_query_msg!(Q::NAME.as_str(), self, key),\n-            )\n-        );\n-\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n@@ -383,7 +346,6 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         if Q::ANON {\n \n-            profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n             let prof_timer = self.prof.query_provider(Q::NAME);\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -395,7 +357,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             });\n \n             drop(prof_timer);\n-            profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n \n@@ -468,7 +429,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let result = if let Some(result) = result {\n-            profq_msg!(self, ProfileQueriesMsg::CacheHit);\n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n@@ -489,10 +449,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.incremental_verify_ich::<Q>(&result, dep_node, dep_node_index);\n         }\n \n-        if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n-            self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n-        }\n-\n         result\n     }\n \n@@ -546,7 +502,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                  - dep-node: {:?}\",\n                 key, dep_node);\n \n-        profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n         let prof_timer = self.prof.query_provider(Q::NAME);\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -568,11 +523,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n \n         drop(prof_timer);\n-        profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n-\n-        if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n-            self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n-        }\n \n         if unlikely!(!diagnostics.is_empty()) {\n             if dep_node.kind != crate::dep_graph::DepKind::Null {\n@@ -614,19 +564,12 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n-            profq_msg!(self, ProfileQueriesMsg::CacheHit);\n             self.prof.query_cache_hit(Q::NAME);\n         }\n     }\n \n     #[allow(dead_code)]\n     fn force_query<Q: QueryDescription<'tcx>>(self, key: Q::Key, span: Span, dep_node: DepNode) {\n-        profq_msg!(\n-            self,\n-            ProfileQueriesMsg::QueryBegin(span.data(),\n-                                          profq_query_msg!(Q::NAME.as_str(), self, key))\n-        );\n-\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n         let job = match JobOwner::try_get(self, span, &key) {\n@@ -1191,37 +1134,6 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n         return false\n     }\n \n-    macro_rules! def_id {\n-        () => {\n-            if let Some(def_id) = dep_node.extract_def_id(tcx) {\n-                def_id\n-            } else {\n-                // Return from the whole function.\n-                return false\n-            }\n-        }\n-    };\n-\n-    macro_rules! krate {\n-        () => { (def_id!()).krate }\n-    };\n-\n-    macro_rules! force_ex {\n-        ($tcx:expr, $query:ident, $key:expr) => {\n-            {\n-                $tcx.force_query::<crate::ty::query::queries::$query<'_>>(\n-                    $key,\n-                    DUMMY_SP,\n-                    *dep_node\n-                );\n-            }\n-        }\n-    };\n-\n-    macro_rules! force {\n-        ($query:ident, $key:expr) => { force_ex!(tcx, $query, $key) }\n-    };\n-\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n@@ -1240,7 +1152,19 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n             bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n \n-        DepKind::Analysis => { force!(analysis, krate!()); }\n+        DepKind::Analysis => {\n+            let def_id = if let Some(def_id) = dep_node.extract_def_id(tcx) {\n+                def_id\n+            } else {\n+                // Return from the whole function.\n+                return false\n+            };\n+            tcx.force_query::<crate::ty::query::queries::analysis<'_>>(\n+                def_id.krate,\n+                DUMMY_SP,\n+                *dep_node\n+            );\n+        }\n     );\n \n     true"}, {"sha": "41f34703622e7f9606828a90947243840a97429d", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{ConstValue, get_slice_bytes, Scalar};\n+use crate::mir::interpret::{ConstValue, get_slice_bytes};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -561,37 +561,39 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     // implement both `PartialEq` and `Eq`, corresponding to\n     // `structural_match` types.\n     // FIXME(const_generics): check for `structural_match` synthetic attribute.\n-    match (eagerly_eval(a), eagerly_eval(b)) {\n+    let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n         (ConstValue::Param(a_p), ConstValue::Param(b_p)) if a_p.index == b_p.index => {\n-            Ok(a)\n+            return Ok(a);\n         }\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n-            Ok(a)\n+            return Ok(a);\n         }\n-        (a_val @ ConstValue::Scalar(Scalar::Raw { .. }), b_val @ _)\n-            if a.ty == b.ty && a_val == b_val =>\n-        {\n-            Ok(tcx.mk_const(ty::Const {\n-                val: a_val,\n-                ty: a.ty,\n-            }))\n+        (ConstValue::Scalar(a_val), ConstValue::Scalar(b_val)) if a.ty == b.ty => {\n+            if a_val == b_val {\n+                Ok(ConstValue::Scalar(a_val))\n+            } else if let ty::FnPtr(_) = a.ty.kind {\n+                let alloc_map = tcx.alloc_map.lock();\n+                let a_instance = alloc_map.unwrap_fn(a_val.to_ptr().unwrap().alloc_id);\n+                let b_instance = alloc_map.unwrap_fn(b_val.to_ptr().unwrap().alloc_id);\n+                if a_instance == b_instance {\n+                    Ok(ConstValue::Scalar(a_val))\n+                } else {\n+                    Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                }\n+            } else {\n+                Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+            }\n         }\n \n-        // FIXME(const_generics): we should either handle `Scalar::Ptr` or add a comment\n-        // saying that we're not handling it intentionally.\n-\n         (a_val @ ConstValue::Slice { .. }, b_val @ ConstValue::Slice { .. }) => {\n             let a_bytes = get_slice_bytes(&tcx, a_val);\n             let b_bytes = get_slice_bytes(&tcx, b_val);\n             if a_bytes == b_bytes {\n-                Ok(tcx.mk_const(ty::Const {\n-                    val: a_val,\n-                    ty: a.ty,\n-                }))\n+                Ok(a_val)\n             } else {\n                 Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n             }\n@@ -602,16 +604,16 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         // FIXME(const_generics): this is wrong, as it is a projection\n         (ConstValue::Unevaluated(a_def_id, a_substs),\n             ConstValue::Unevaluated(b_def_id, b_substs)) if a_def_id == b_def_id => {\n-                let substs =\n-                    relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-                Ok(tcx.mk_const(ty::Const {\n-                    val: ConstValue::Unevaluated(a_def_id, &substs),\n-                    ty: a.ty,\n-                }))\n-            }\n-\n-        _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n-    }\n+            let substs =\n+                relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n+            Ok(ConstValue::Unevaluated(a_def_id, &substs))\n+        }\n+        _ =>  Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n+    };\n+    new_const_val.map(|val| tcx.mk_const(ty::Const {\n+        val,\n+        ty: a.ty,\n+    }))\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {"}, {"sha": "83ec98f9ddd2f2dfbd87ab39978e22681bfd9ade", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -761,6 +761,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n                 Some(ty::InstanceDef::Item(def_id)),\n             ty::InstanceDef::VtableShim(def_id) =>\n                 Some(ty::InstanceDef::VtableShim(def_id)),\n+            ty::InstanceDef::ReifyShim(def_id) =>\n+                Some(ty::InstanceDef::ReifyShim(def_id)),\n             ty::InstanceDef::Intrinsic(def_id) =>\n                 Some(ty::InstanceDef::Intrinsic(def_id)),\n             ty::InstanceDef::FnPtrShim(def_id, ref ty) =>\n@@ -966,6 +968,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n             def: match self.def {\n                 Item(did) => Item(did.fold_with(folder)),\n                 VtableShim(did) => VtableShim(did.fold_with(folder)),\n+                ReifyShim(did) => ReifyShim(did.fold_with(folder)),\n                 Intrinsic(did) => Intrinsic(did.fold_with(folder)),\n                 FnPtrShim(did, ty) => FnPtrShim(\n                     did.fold_with(folder),\n@@ -994,7 +997,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n         use crate::ty::InstanceDef::*;\n         self.substs.visit_with(visitor) ||\n         match self.def {\n-            Item(did) | VtableShim(did) | Intrinsic(did) | Virtual(did, _) => {\n+            Item(did) | VtableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n                 did.visit_with(visitor)\n             },\n             FnPtrShim(did, ty) | CloneShim(did, ty) => {\n@@ -1215,16 +1218,23 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-        parent, predicates\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_predicates(&v)\n+        // This code is hot enough that it's worth specializing for a list of\n+        // length 0. (No other length is common enough to be worth singling\n+        // out).\n+        if self.len() == 0 {\n+            self\n+        } else {\n+            // Don't bother interning if nothing changed, which is the common\n+            // case.\n+            let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+            if v[..] == self[..] {\n+                self\n+            } else {\n+                folder.tcx().intern_predicates(&v)\n+            }\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {"}, {"sha": "4af73fa389a7db87f26b353981a38697cab8020f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -13,7 +13,7 @@ use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, GenericArg, GenericArgKind};\n use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n-use crate::ty::layout::{Size, Integer, IntegerExt, VariantIdx};\n+use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, GlobalId};\n \n@@ -24,7 +24,6 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n-use syntax::attr::{SignedInt, UnsignedInt};\n use syntax::symbol::{kw, InternedString};\n \n use self::InferTy::*;\n@@ -163,7 +162,7 @@ pub enum TyKind<'tcx> {\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n-    Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, SubstsRef<'tcx>, hir::GeneratorMovability),\n \n     /// A type representin the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n@@ -512,7 +511,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// variant indices.\n     #[inline]\n     pub fn discriminants(\n-        &'tcx self,\n+        self,\n         def_id: DefId,\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n@@ -524,7 +523,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// Calls `f` with a reference to the name of the enumerator for the given\n     /// variant `v`.\n     #[inline]\n-    pub fn variant_name(&self, v: VariantIdx) -> Cow<'static, str> {\n+    pub fn variant_name(self, v: VariantIdx) -> Cow<'static, str> {\n         match v.as_usize() {\n             Self::UNRESUMED => Cow::from(Self::UNRESUMED_NAME),\n             Self::RETURNED => Cow::from(Self::RETURNED_NAME),\n@@ -570,7 +569,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n #[derive(Debug, Copy, Clone)]\n pub enum UpvarSubsts<'tcx> {\n     Closure(SubstsRef<'tcx>),\n-    Generator(GeneratorSubsts<'tcx>),\n+    Generator(SubstsRef<'tcx>),\n }\n \n impl<'tcx> UpvarSubsts<'tcx> {\n@@ -582,7 +581,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let upvar_kinds = match self {\n             UpvarSubsts::Closure(substs) => substs.as_closure().split(def_id, tcx).upvar_kinds,\n-            UpvarSubsts::Generator(substs) => substs.split(def_id, tcx).upvar_kinds,\n+            UpvarSubsts::Generator(substs) => substs.as_generator().split(def_id, tcx).upvar_kinds,\n         };\n         upvar_kinds.iter().map(|t| {\n             if let GenericArgKind::Type(ty) = t.unpack() {\n@@ -1776,6 +1775,10 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_bool(&self) -> bool { self.kind == Bool }\n \n+    /// Returns `true` if this type is a `str`.\n+    #[inline]\n+    pub fn is_str(&self) -> bool { self.kind == Str }\n+\n     #[inline]\n     pub fn is_param(&self, index: u32) -> bool {\n         match self.kind {\n@@ -2109,7 +2112,8 @@ impl<'tcx> TyS<'tcx> {\n     pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n         match self.kind {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n-            TyKind::Generator(def_id, substs, _) => Some(substs.variant_range(def_id, tcx)),\n+            TyKind::Generator(def_id, substs, _) =>\n+                Some(substs.as_generator().variant_range(def_id, tcx)),\n             _ => None,\n         }\n     }\n@@ -2126,7 +2130,7 @@ impl<'tcx> TyS<'tcx> {\n         match self.kind {\n             TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n             TyKind::Generator(def_id, substs, _) =>\n-                Some(substs.discriminant_for_variant(def_id, tcx, variant_index)),\n+                Some(substs.as_generator().discriminant_for_variant(def_id, tcx, variant_index)),\n             _ => None,\n         }\n     }\n@@ -2149,7 +2153,7 @@ impl<'tcx> TyS<'tcx> {\n                 out.extend(substs.regions())\n             }\n             Closure(_, ref substs ) |\n-            Generator(_, GeneratorSubsts { ref substs }, _) => {\n+            Generator(_, ref substs, _) => {\n                 out.extend(substs.regions())\n             }\n             Projection(ref data) | UnnormalizedProjection(ref data) => {\n@@ -2199,7 +2203,9 @@ impl<'tcx> TyS<'tcx> {\n                 _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n             },\n \n-            Infer(_) => None,\n+            // \"Bound\" types appear in canonical queries when the\n+            // closure type is not yet known\n+            Bound(..) | Infer(_) => None,\n \n             Error => Some(ty::ClosureKind::Fn),\n \n@@ -2299,20 +2305,7 @@ impl<'tcx> Const<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Option<u128> {\n         assert_eq!(self.ty, ty);\n-        // This is purely an optimization -- layout_of is a pretty expensive operation,\n-        // but if we can determine the size without calling it, we don't need all that complexity\n-        // (hashing, caching, etc.). As such, try to skip it.\n-        let size = match ty.kind {\n-            ty::Bool => Size::from_bytes(1),\n-            ty::Char => Size::from_bytes(4),\n-            ty::Int(ity) => {\n-                Integer::from_attr(&tcx, SignedInt(ity)).size()\n-            }\n-            ty::Uint(uty) => {\n-                Integer::from_attr(&tcx, UnsignedInt(uty)).size()\n-            }\n-            _ => tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size,\n-        };\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         self.eval(tcx, param_env).val.try_to_bits(size)\n     }"}, {"sha": "4081c02a33ca41f87eecb7dc6fdcf69458b73579", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -5,7 +5,7 @@ use crate::infer::canonical::Canonical;\n use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::mir::interpret::ConstValue;\n-use crate::ty::sty::ClosureSubsts;\n+use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n \n use rustc_serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -194,6 +194,14 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         }\n     }\n \n+    /// Interpret these substitutions as the substitutions of a generator type.\n+    /// Closure substitutions have a particular structure controlled by the\n+    /// compiler that encodes information like the signature and generator kind;\n+    /// see `ty::GeneratorSubsts` struct for more comments.\n+    pub fn as_generator(&'tcx self) -> GeneratorSubsts<'tcx> {\n+        GeneratorSubsts { substs: self }\n+    }\n+\n     /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n@@ -394,14 +402,41 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n-\n-        // If folding doesn't change the substs, it's faster to avoid\n-        // calling `mk_substs` and instead reuse the existing substs.\n-        if params[..] == self[..] {\n-            self\n-        } else {\n-            folder.tcx().intern_substs(&params)\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // The match arms are in order of frequency. The 1, 2, and 0 cases are\n+        // typically hit in 90--99.99% of cases. When folding doesn't change\n+        // the substs, it's faster to reuse the existing substs rather than\n+        // calling `intern_substs`.\n+        match self.len() {\n+            1 => {\n+                let param0 = self[0].fold_with(folder);\n+                if param0 == self[0] {\n+                    self\n+                } else {\n+                    folder.tcx().intern_substs(&[param0])\n+                }\n+            }\n+            2 => {\n+                let param0 = self[0].fold_with(folder);\n+                let param1 = self[1].fold_with(folder);\n+                if param0 == self[0] && param1 == self[1] {\n+                    self\n+                } else {\n+                    folder.tcx().intern_substs(&[param0, param1])\n+                }\n+            }\n+            0 => {\n+                self\n+            }\n+            _ => {\n+                let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n+                if params[..] == self[..] {\n+                    self\n+                } else {\n+                    folder.tcx().intern_substs(&params)\n+                }\n+            }\n         }\n     }\n "}, {"sha": "e1eab2c6579e1892df943f0629e79e34541b7220", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -697,6 +697,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             // that type, and when we finish expanding that type we remove the\n             // its DefId.\n             seen_opaque_tys: FxHashSet<DefId>,\n+            // Cache of all expansions we've seen so far. This is a critical\n+            // optimization for some large types produced by async fn trees.\n+            expanded_cache: FxHashMap<(DefId, SubstsRef<'tcx>), Ty<'tcx>>,\n             primary_def_id: DefId,\n             found_recursion: bool,\n             tcx: TyCtxt<'tcx>,\n@@ -713,9 +716,16 @@ impl<'tcx> TyCtxt<'tcx> {\n                 }\n                 let substs = substs.fold_with(self);\n                 if self.seen_opaque_tys.insert(def_id) {\n-                    let generic_ty = self.tcx.type_of(def_id);\n-                    let concrete_ty = generic_ty.subst(self.tcx, substs);\n-                    let expanded_ty = self.fold_ty(concrete_ty);\n+                    let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n+                        Some(expanded_ty) => expanded_ty,\n+                        None => {\n+                            let generic_ty = self.tcx.type_of(def_id);\n+                            let concrete_ty = generic_ty.subst(self.tcx, substs);\n+                            let expanded_ty = self.fold_ty(concrete_ty);\n+                            self.expanded_cache.insert((def_id, substs), expanded_ty);\n+                            expanded_ty\n+                        }\n+                    };\n                     self.seen_opaque_tys.remove(&def_id);\n                     Some(expanded_ty)\n                 } else {\n@@ -735,14 +745,17 @@ impl<'tcx> TyCtxt<'tcx> {\n             fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Opaque(def_id, substs) = t.kind {\n                     self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-                } else {\n+                } else if t.has_projections() {\n                     t.super_fold_with(self)\n+                } else {\n+                    t\n                 }\n             }\n         }\n \n         let mut visitor = OpaqueTypeExpander {\n             seen_opaque_tys: FxHashSet::default(),\n+            expanded_cache: FxHashMap::default(),\n             primary_def_id: def_id,\n             found_recursion: false,\n             tcx: self,\n@@ -1017,34 +1030,25 @@ impl<'tcx> ty::TyS<'tcx> {\n }\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n-    tcx.infer_ctxt()\n-        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        ))\n+    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n }\n \n fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n-    tcx.infer_ctxt()\n-        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        ))\n+    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n+\n }\n \n fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n+}\n+\n+fn is_item_raw<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    item: lang_items::LangItem,\n+) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem, None);\n+    let trait_def_id = tcx.require_lang_item(item, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1105,6 +1109,9 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n \n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n \n+        // Zero-length arrays never contain anything to drop.\n+        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n+\n         // Structural recursion.\n         ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n "}, {"sha": "f5b1902e3cc8c5ab0085125d7c51f4c61351db96", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -110,12 +110,10 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::Adt(_, substs) | ty::Opaque(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::Closure(_, ref substs) => {\n+        ty::Closure(_, ref substs)\n+        | ty::Generator(_, ref substs, _) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::Generator(_, ref substs, _) => {\n-            stack.extend(substs.substs.types().rev());\n-        }\n         ty::GeneratorWitness(ts) => {\n             stack.extend(ts.skip_binder().iter().cloned().rev());\n         }"}, {"sha": "3e52a6aa50850c12901e0f9b8c5cac6e418a5374", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 73, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -6,11 +6,8 @@ use std::cell::Cell;\n use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n-use std::sync::mpsc::{Sender};\n-use syntax_pos::{SpanData};\n use syntax::symbol::{Symbol, sym};\n use rustc_macros::HashStable;\n-use crate::dep_graph::{DepNode};\n use crate::session::Session;\n \n #[cfg(test)]\n@@ -26,71 +23,13 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n-/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n-#[derive(Clone,Debug)]\n-pub struct ProfQDumpParams {\n-    /// A base path for the files we will dump.\n-    pub path:String,\n-    /// To ensure that the compiler waits for us to finish our dumps.\n-    pub ack:Sender<()>,\n-    /// Toggle dumping a log file with every `ProfileQueriesMsg`.\n-    pub dump_profq_msg_log:bool,\n-}\n-\n #[allow(nonstandard_style)]\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct QueryMsg {\n     pub query: &'static str,\n     pub msg: Option<String>,\n }\n \n-/// A sequence of these messages induce a trace of query-based incremental compilation.\n-// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n-#[derive(Clone,Debug)]\n-pub enum ProfileQueriesMsg {\n-    /// Begin a timed pass.\n-    TimeBegin(String),\n-    /// End a timed pass.\n-    TimeEnd,\n-    /// Begin a task (see `dep_graph::graph::with_task`).\n-    TaskBegin(DepNode),\n-    /// End a task.\n-    TaskEnd,\n-    /// Begin a new query.\n-    /// Cannot use `Span` because queries are sent to other thread.\n-    QueryBegin(SpanData, QueryMsg),\n-    /// Query is satisfied by using an already-known value for the given key.\n-    CacheHit,\n-    /// Query requires running a provider; providers may nest, permitting queries to nest.\n-    ProviderBegin,\n-    /// Query is satisfied by a provider terminating with a value.\n-    ProviderEnd,\n-    /// Dump a record of the queries to the given path.\n-    Dump(ProfQDumpParams),\n-    /// Halt the profiling/monitoring background thread.\n-    Halt\n-}\n-\n-/// If enabled, send a message to the profile-queries thread.\n-pub fn profq_msg(sess: &Session, msg: ProfileQueriesMsg) {\n-    if let Some(s) = sess.profile_channel.borrow().as_ref() {\n-        s.send(msg).unwrap()\n-    } else {\n-        // Do nothing.\n-    }\n-}\n-\n-/// Set channel for profile queries channel.\n-pub fn profq_set_chan(sess: &Session, s: Sender<ProfileQueriesMsg>) -> bool {\n-    let mut channel = sess.profile_channel.borrow_mut();\n-    if channel.is_none() {\n-        *channel = Some(s);\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {\n@@ -107,10 +46,10 @@ pub fn set_time_depth(depth: usize) {\n pub fn time<T, F>(sess: &Session, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n-    time_ext(sess.time_passes(), Some(sess), what, f)\n+    time_ext(sess.time_passes(), what, f)\n }\n \n-pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) -> T where\n+pub fn time_ext<T, F>(do_it: bool, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n     if !do_it { return f(); }\n@@ -121,19 +60,9 @@ pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) ->\n         r\n     });\n \n-    if let Some(sess) = sess {\n-        if cfg!(debug_assertions) {\n-            profq_msg(sess, ProfileQueriesMsg::TimeBegin(what.to_string()))\n-        }\n-    }\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n-    if let Some(sess) = sess {\n-        if cfg!(debug_assertions) {\n-            profq_msg(sess, ProfileQueriesMsg::TimeEnd)\n-        }\n-    }\n \n     print_time_passes_entry(true, what, dur);\n "}, {"sha": "8c60c030eacdb3a1e864e4995ef925cfaccb8a86", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -3,7 +3,7 @@ use std::ffi::CString;\n use crate::attributes;\n use libc::c_uint;\n use rustc::ty::TyCtxt;\n-use syntax::ext::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use syntax_expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n \n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};\n@@ -68,7 +68,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: Alloc\n \n         let llbb = llvm::LLVMAppendBasicBlockInContext(llcx,\n                                                        llfn,\n-                                                       \"entry\\0\".as_ptr() as *const _);\n+                                                       \"entry\\0\".as_ptr().cast());\n \n         let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n         llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n@@ -80,7 +80,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: Alloc\n                                           args.as_ptr(),\n                                           args.len() as c_uint,\n                                           None,\n-                                          \"\\0\".as_ptr() as *const _);\n+                                          \"\\0\".as_ptr().cast());\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {\n             llvm::LLVMBuildRet(llbuilder, ret);"}, {"sha": "6a36a4a50cbf3f2210b81c9dbfd244d8778a5dcb", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -96,10 +96,12 @@ pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n \n     // Currently stack probes seem somewhat incompatible with the address\n-    // sanitizer. With asan we're already protected from stack overflow anyway\n-    // so we don't really need stack probes regardless.\n-    if let Some(Sanitizer::Address) = cx.sess().opts.debugging_opts.sanitizer {\n-        return\n+    // sanitizer and thread sanitizer. With asan we're already protected from\n+    // stack overflow anyway so we don't really need stack probes regardless.\n+    match cx.sess().opts.debugging_opts.sanitizer {\n+        Some(Sanitizer::Address) |\n+        Some(Sanitizer::Thread) => return,\n+        _ => {},\n     }\n \n     // probestack doesn't play nice either with `-C profile-generate`.\n@@ -268,31 +270,37 @@ pub fn from_fn_attrs(\n         // optimize based on this!\n         false\n     } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n-        // If a specific #[unwind] attribute is present, use that\n+        // If a specific #[unwind] attribute is present, use that.\n         true\n     } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n-        // Special attribute for allocator functions, which can't unwind\n+        // Special attribute for allocator functions, which can't unwind.\n         false\n-    } else if let Some(id) = id {\n+    } else {\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        if cx.tcx.is_foreign_item(id) {\n-            // Foreign items like `extern \"C\" { fn foo(); }` are assumed not to\n-            // unwind\n-            false\n-        } else if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n-            // Any items defined in Rust that *don't* have the `extern` ABI are\n-            // defined to not unwind. We insert shims to abort if an unwind\n-            // happens to enforce this.\n-            false\n-        } else {\n-            // Anything else defined in Rust is assumed that it can possibly\n-            // unwind\n+        if sig.abi == Abi::Rust || sig.abi == Abi::RustCall {\n+            // Any Rust method (or `extern \"Rust\" fn` or `extern\n+            // \"rust-call\" fn`) is explicitly allowed to unwind\n+            // (unless it has no-unwind attribute, handled above).\n             true\n+        } else {\n+            // Anything else is either:\n+            //\n+            //  1. A foreign item using a non-Rust ABI (like `extern \"C\" { fn foo(); }`), or\n+            //\n+            //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n+            //\n+            // Foreign items (case 1) are assumed to not unwind; it is\n+            // UB otherwise. (At least for now; see also\n+            // rust-lang/rust#63909 and Rust RFC 2753.)\n+            //\n+            // Items defined in Rust with non-Rust ABIs (case 2) are also\n+            // not supposed to unwind. Whether this should be enforced\n+            // (versus stating it is UB) and *how* it would be enforced\n+            // is currently under discussion; see rust-lang/rust#58794.\n+            //\n+            // In either case, we mark item as explicitly nounwind.\n+            false\n         }\n-    } else {\n-        // assume this can possibly unwind, avoiding the application of a\n-        // `nounwind` attribute below.\n-        true\n     });\n \n     // Always annotate functions with the target-cpu they are compiled for."}, {"sha": "7437b1e3c8a32e2f7c31599d57a117fd86015de7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -116,7 +116,7 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = time_ext(cgcx.time_passes, None, &format!(\"decode {}\", name), || {\n+                let (bc, id) = time_ext(cgcx.time_passes, &format!(\"decode {}\", name), || {\n                     match DecodedBytecode::new(bc_encoded) {\n                         Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n                         Err(e) => Err(diag_handler.fatal(&e)),\n@@ -295,7 +295,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         for (bc_decoded, name) in serialized_modules {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n-            time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n+            time_ext(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n@@ -546,7 +546,7 @@ pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         llvm::LLVMRustAddAnalysisPasses(module.module_llvm.tm, pm, module.module_llvm.llmod());\n \n         if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n+            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n@@ -581,16 +581,16 @@ pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // We always generate bitcode through ThinLTOBuffers,\n         // which do not support anonymous globals\n         if config.bitcode_needed() {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"name-anon-globals\\0\".as_ptr() as *const _);\n+            let pass = llvm::LLVMRustFindAndCreatePass(\"name-anon-globals\\0\".as_ptr().cast());\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n         if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n+            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n+        time_ext(cgcx.time_passes, \"LTO passes\", ||\n              llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n \n         llvm::LLVMDisposePassManager(pm);"}, {"sha": "52f3a1cbb5c30b06959ddd66d120f79557fe2b4a", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -221,8 +221,8 @@ impl<'a> DiagnosticHandlers<'a> {\n                llcx: &'a llvm::Context) -> Self {\n         let data = Box::into_raw(Box::new((cgcx, handler)));\n         unsafe {\n-            llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data as *mut _);\n-            llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, data as *mut _);\n+            llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data.cast());\n+            llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, data.cast());\n         }\n         DiagnosticHandlers { data, llcx }\n     }\n@@ -427,7 +427,6 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n             time_ext(config.time_passes,\n-                        None,\n                         &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n                         || {\n                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n@@ -436,7 +435,6 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n             time_ext(config.time_passes,\n-                    None,\n                     &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n                     || {\n                 llvm::LLVMRunPassManager(mpm, llmod)\n@@ -538,7 +536,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n-        time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+        time_ext(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n                 let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n@@ -672,7 +670,7 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         common::val_ty(llconst),\n-        \"rustc.embedded.module\\0\".as_ptr() as *const _,\n+        \"rustc.embedded.module\\0\".as_ptr().cast(),\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n \n@@ -684,23 +682,23 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     } else {\n         \".llvmbc\\0\"\n     };\n-    llvm::LLVMSetSection(llglobal, section.as_ptr() as *const _);\n+    llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n     let llconst = common::bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         common::val_ty(llconst),\n-        \"rustc.embedded.cmdline\\0\".as_ptr() as *const _,\n+        \"rustc.embedded.cmdline\\0\".as_ptr().cast(),\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n     let section = if  is_apple {\n         \"__LLVM,__cmdline\\0\"\n     } else {\n         \".llvmcmd\\0\"\n     };\n-    llvm::LLVMSetSection(llglobal, section.as_ptr() as *const _);\n+    llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n }\n \n@@ -842,7 +840,7 @@ fn create_msvc_imps(\n         for (imp_name, val) in globals {\n             let imp = llvm::LLVMAddGlobal(llmod,\n                                           i8p_ty,\n-                                          imp_name.as_ptr() as *const _);\n+                                          imp_name.as_ptr().cast());\n             llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n             llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n         }"}, {"sha": "98be0ae44335f14723e212d60012aa8a25d5f54c", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -52,6 +52,7 @@ const UNNAMED: *const c_char = EMPTY_C_STR.as_ptr();\n \n impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n+    type Function = <CodegenCx<'ll, 'tcx> as BackendTypes>::Function;\n     type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;\n     type Type = <CodegenCx<'ll, 'tcx> as BackendTypes>::Type;\n     type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;"}, {"sha": "08fa23f2a7c9e31b09b539309692a655f9384926", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -33,7 +33,7 @@ pub fn get_fn(\n     assert!(!instance.substs.has_param_types());\n \n     let sig = instance.fn_sig(cx.tcx());\n-    if let Some(&llfn) = cx.instances().borrow().get(&instance) {\n+    if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n "}, {"sha": "a1a5232d588327c7fc8d3eb95bcadd8bd8181557", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,7 +2,7 @@\n \n //! Code that is useful in various codegen modules.\n \n-use crate::llvm::{self, True, False, Bool, BasicBlock, OperandBundleDef};\n+use crate::llvm::{self, True, False, Bool, BasicBlock, OperandBundleDef, ConstantInt};\n use crate::abi;\n use crate::consts;\n use crate::type_::Type;\n@@ -86,6 +86,8 @@ impl Funclet<'ll> {\n \n impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type Value = &'ll Value;\n+    type Function = &'ll Value;\n+\n     type BasicBlock = &'ll BasicBlock;\n     type Type = &'ll Type;\n     type Funclet = Funclet<'ll>;\n@@ -243,33 +245,23 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         struct_in_context(self.llcx, elts, packed)\n     }\n \n-    fn const_to_uint(&self, v: &'ll Value) -> u64 {\n-        unsafe {\n+    fn const_to_opt_uint(&self, v: &'ll Value) -> Option<u64> {\n+        try_as_const_integral(v).map(|v| unsafe {\n             llvm::LLVMConstIntGetZExtValue(v)\n-        }\n-    }\n-\n-    fn is_const_integral(&self, v: &'ll Value) -> bool {\n-        unsafe {\n-            llvm::LLVMIsAConstantInt(v).is_some()\n-        }\n+        })\n     }\n \n     fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n-        unsafe {\n-            if self.is_const_integral(v) {\n-                let (mut lo, mut hi) = (0u64, 0u64);\n-                let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n-                                                           &mut hi, &mut lo);\n-                if success {\n-                    Some(hi_lo_to_u128(lo, hi))\n-                } else {\n-                    None\n-                }\n+        try_as_const_integral(v).and_then(|v| unsafe {\n+            let (mut lo, mut hi) = (0u64, 0u64);\n+            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                        &mut hi, &mut lo);\n+            if success {\n+                Some(hi_lo_to_u128(lo, hi))\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n \n     fn scalar_to_backend(\n@@ -305,7 +297,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                     }\n                     Some(GlobalAlloc::Function(fn_instance)) => {\n-                        self.get_fn(fn_instance)\n+                        self.get_fn_addr(fn_instance)\n                     }\n                     Some(GlobalAlloc::Static(def_id)) => {\n                         assert!(self.tcx.is_static(def_id));\n@@ -386,3 +378,9 @@ pub fn struct_in_context(\n fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)\n }\n+\n+fn try_as_const_integral(v: &'ll Value) -> Option<&'ll ConstantInt> {\n+    unsafe {\n+        llvm::LLVMIsAConstantInt(v)\n+    }\n+}"}, {"sha": "d4df5b4a804ef8345e06ba20a87b1fcd496f1f8c", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -488,7 +488,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 if let Some(section) = attrs.link_section {\n                     let section = llvm::LLVMMDStringInContext(\n                         self.llcx,\n-                        section.as_str().as_ptr() as *const _,\n+                        section.as_str().as_ptr().cast(),\n                         section.as_str().len() as c_uint,\n                     );\n                     assert!(alloc.relocations().is_empty());\n@@ -500,14 +500,14 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                         0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n-                        bytes.as_ptr() as *const _,\n+                        bytes.as_ptr().cast(),\n                         bytes.len() as c_uint,\n                     );\n                     let data = [section, alloc];\n                     let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);\n                     llvm::LLVMAddNamedMetadataOperand(\n                         self.llmod,\n-                        \"wasm.custom_sections\\0\".as_ptr() as *const _,\n+                        \"wasm.custom_sections\\0\".as_ptr().cast(),\n                         meta,\n                     );\n                 }"}, {"sha": "2da93877172141890b20c3ba11cbc146e5c83733", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -20,7 +20,6 @@ use rustc::ty::layout::{\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};\n-use rustc_codegen_ssa::callee::resolve_and_get_fn;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use crate::callee::get_fn;\n \n@@ -211,7 +210,7 @@ pub unsafe fn create_module(\n     // If skipping the PLT is enabled, we need to add some module metadata\n     // to ensure intrinsic calls don't use it.\n     if !sess.needs_plt() {\n-        let avoid_plt = \"RtLibUseGOT\\0\".as_ptr() as *const _;\n+        let avoid_plt = \"RtLibUseGOT\\0\".as_ptr().cast();\n         llvm::LLVMRustAddModuleFlag(llmod, avoid_plt, 1);\n     }\n \n@@ -327,11 +326,11 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         &self.vtables\n     }\n \n-    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, &'ll Value>> {\n-        &self.instances\n+    fn get_fn(&self, instance: Instance<'tcx>) -> &'ll Value {\n+        get_fn(self, instance)\n     }\n \n-    fn get_fn(&self, instance: Instance<'tcx>) -> &'ll Value {\n+    fn get_fn_addr(&self, instance: Instance<'tcx>) -> &'ll Value {\n         get_fn(self, instance)\n     }\n \n@@ -362,7 +361,14 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !wants_msvc_seh(self.sess()) => {\n-                resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n+                self.get_fn_addr(\n+                    ty::Instance::resolve(\n+                        tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        tcx.intern_substs(&[]),\n+                    ).unwrap()\n+                )\n             }\n             _ => {\n                 let name = if wants_msvc_seh(self.sess()) {\n@@ -390,7 +396,14 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n-            let llfn = resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n+            let llfn = self.get_fn_addr(\n+                ty::Instance::resolve(\n+                    tcx,\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    tcx.intern_substs(&[]),\n+                ).unwrap()\n+            );\n             unwresume.set(Some(llfn));\n             return llfn;\n         }\n@@ -537,6 +550,7 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n+        ifn!(\"llvm.sideeffect\", fn() -> void);\n \n         ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n         ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);"}, {"sha": "9ed1c1730a697b1a44307c5d72be2454adb8a0b7", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -37,7 +37,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n \n     let section_var = unsafe {\n         llvm::LLVMGetNamedGlobal(cx.llmod,\n-                                 c_section_var_name.as_ptr() as *const _)\n+                                 c_section_var_name.as_ptr().cast())\n     };\n \n     section_var.unwrap_or_else(|| {\n@@ -52,7 +52,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n                                                      llvm_type).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n-            llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr().cast());\n             llvm::LLVMSetInitializer(section_var, cx.const_bytes(section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);"}, {"sha": "438a660b8a8673b5895737f732373da26868cbf3", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::Instance;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, Integer, IntegerExt, LayoutOf,\n                         PrimitiveExt, Size, TyLayout, VariantIdx};\n-use rustc::ty::subst::GenericArgKind;\n+use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::FxHashMap;\n use rustc_fs_util::path_to_c_string;\n@@ -692,9 +692,10 @@ pub fn type_metadata(\n                                    Some(containing_scope)).finalize(cx)\n         }\n         ty::Generator(def_id, substs,  _) => {\n-            let upvar_tys : Vec<_> = substs.prefix_tys(def_id, cx.tcx).map(|t| {\n-                cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n-            }).collect();\n+            let upvar_tys : Vec<_> = substs\n+                .as_generator().prefix_tys(def_id, cx.tcx).map(|t| {\n+                    cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n+                }).collect();\n             prepare_enum_metadata(cx,\n                                   t,\n                                   def_id,\n@@ -960,9 +961,9 @@ pub fn compile_unit_metadata(\n             file_metadata,\n             producer.as_ptr(),\n             tcx.sess.opts.optimize != config::OptLevel::No,\n-            flags.as_ptr() as *const _,\n+            flags.as_ptr().cast(),\n             0,\n-            split_name.as_ptr() as *const _,\n+            split_name.as_ptr().cast(),\n             kind);\n \n         if tcx.sess.opts.debugging_opts.profile {\n@@ -991,7 +992,7 @@ pub fn compile_unit_metadata(\n         if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n             let name_metadata = llvm::LLVMMDStringInContext(\n                 debug_context.llcontext,\n-                rustc_producer.as_ptr() as *const _,\n+                rustc_producer.as_ptr().cast(),\n                 rustc_producer.as_bytes().len() as c_uint,\n             );\n             llvm::LLVMAddNamedMetadataOperand(\n@@ -1338,7 +1339,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n                 ty::Generator(def_id, substs, _) => {\n                     let generator_layout = cx.tcx.generator_layout(*def_id);\n-                    VariantInfo::Generator(*substs, generator_layout, index)\n+                    VariantInfo::Generator(substs, generator_layout, index)\n                 }\n                 _ => bug!(),\n             }\n@@ -1611,15 +1612,15 @@ enum EnumDiscriminantInfo<'ll> {\n #[derive(Copy, Clone)]\n enum VariantInfo<'tcx> {\n     Adt(&'tcx ty::VariantDef),\n-    Generator(ty::GeneratorSubsts<'tcx>, &'tcx GeneratorLayout<'tcx>, VariantIdx),\n+    Generator(SubstsRef<'tcx>, &'tcx GeneratorLayout<'tcx>, VariantIdx),\n }\n \n impl<'tcx> VariantInfo<'tcx> {\n     fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n         match self {\n             VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n             VariantInfo::Generator(substs, _, variant_index) =>\n-                f(&substs.variant_name(*variant_index)),\n+                f(&substs.as_generator().variant_name(*variant_index)),\n         }\n     }\n \n@@ -1763,9 +1764,10 @@ fn prepare_enum_metadata(\n                 })\n                 .collect(),\n             ty::Generator(_, substs, _) => substs\n+                .as_generator()\n                 .variant_range(enum_def_id, cx.tcx)\n                 .map(|variant_index| {\n-                    let name = SmallCStr::new(&substs.variant_name(variant_index));\n+                    let name = SmallCStr::new(&substs.as_generator().variant_name(variant_index));\n                     unsafe {\n                         Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                             DIB(cx),"}, {"sha": "6e4ed42c45e9792ad2e019c8a0d50457310b34b2", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -127,20 +127,20 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n         if cx.sess().target.target.options.is_like_osx ||\n            cx.sess().target.target.options.is_like_android {\n             llvm::LLVMRustAddModuleFlag(cx.llmod,\n-                                        \"Dwarf Version\\0\".as_ptr() as *const _,\n+                                        \"Dwarf Version\\0\".as_ptr().cast(),\n                                         2)\n         }\n \n         // Indicate that we want CodeView debug information on MSVC\n         if cx.sess().target.target.options.is_like_msvc {\n             llvm::LLVMRustAddModuleFlag(cx.llmod,\n-                                        \"CodeView\\0\".as_ptr() as *const _,\n+                                        \"CodeView\\0\".as_ptr().cast(),\n                                         1)\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n         let ptr = \"Debug Info Version\\0\".as_ptr();\n-        llvm::LLVMRustAddModuleFlag(cx.llmod, ptr as *const _,\n+        llvm::LLVMRustAddModuleFlag(cx.llmod, ptr.cast(),\n                                     llvm::LLVMRustDebugMetadataVersion());\n     };\n }"}, {"sha": "042e51ed2ba7a4e95e0f4bacd7e16142947df71c", "filename": "src/librustc_codegen_llvm/error_codes.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,38 +0,0 @@\n-register_diagnostics! {\n-\n-E0511: r##\"\n-Invalid monomorphization of an intrinsic function was used. Erroneous code\n-example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(platform_intrinsics)]\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-fn main() {\n-    unsafe { simd_add(0, 1); }\n-    // error: invalid monomorphization of `simd_add` intrinsic\n-}\n-```\n-\n-The generic type has to be a SIMD type. Example:\n-\n-```\n-#![feature(repr_simd)]\n-#![feature(platform_intrinsics)]\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone)]\n-struct i32x2(i32, i32);\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n-```\n-\"##,\n-\n-}"}, {"sha": "3df8d4c26903bd43e859632e2c53a334b69689aa", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -20,9 +20,9 @@ use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n \n+use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::traits::*;\n \n-use rustc::session::Session;\n use syntax_pos::Span;\n \n use std::cmp::Ordering;\n@@ -724,6 +724,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n+    fn sideeffect(&mut self) {\n+        if self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n+            let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n+            self.call(fnname, &[], None);\n+        }\n+    }\n+\n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n         let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n         self.call(intrinsic, &[va_list], None)\n@@ -810,6 +817,7 @@ fn codegen_msvc_try(\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n+        bx.sideeffect();\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -933,6 +941,8 @@ fn codegen_gnu_try(\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n+        bx.sideeffect();\n+\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n@@ -1016,10 +1026,6 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     rust_try\n }\n \n-fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n-    span_err!(a, b, E0511, \"{}\", c);\n-}\n-\n fn generic_simd_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n     name: &str,"}, {"sha": "9b55bef0c514db7ae73520cdaa1b21fe247c5c6d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -19,7 +19,6 @@\n #![feature(link_args)]\n #![feature(static_nobundle)]\n #![feature(trusted_len)]\n-#![feature(mem_take)]\n \n use back::write::{create_target_machine, create_informational_target_machine};\n use syntax_pos::symbol::Symbol;\n@@ -39,7 +38,8 @@ extern crate rustc_fs_util;\n extern crate rustc_driver as _;\n \n #[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n+extern crate syntax_expand;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n@@ -49,7 +49,7 @@ use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModul\n use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n-use syntax::ext::allocator::AllocatorKind;\n+use syntax_expand::allocator::AllocatorKind;\n use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n@@ -65,8 +65,6 @@ use rustc::util::common::ErrorReported;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n-mod error_codes;\n-\n mod back {\n     pub mod archive;\n     pub mod bytecode;\n@@ -259,10 +257,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n         llvm_util::print_version();\n     }\n \n-    fn diagnostics(&self) -> &[(&'static str, &'static str)] {\n-        &error_codes::DIAGNOSTICS\n-    }\n-\n     fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n         target_features(sess)\n     }\n@@ -272,15 +266,10 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn provide(&self, providers: &mut ty::query::Providers<'_>) {\n-        rustc_codegen_utils::symbol_names::provide(providers);\n-        rustc_codegen_ssa::back::symbol_export::provide(providers);\n-        rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers<'_>) {\n-        rustc_codegen_ssa::back::symbol_export::provide_extern(providers);\n-        rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide_extern(providers);\n     }\n "}, {"sha": "a2313b933a6c970b56e63811f4a904bd40a7a81e", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -510,6 +510,7 @@ extern { pub type Module; }\n extern { pub type Context; }\n extern { pub type Type; }\n extern { pub type Value; }\n+extern { pub type ConstantInt; }\n extern { pub type Metadata; }\n extern { pub type BasicBlock; }\n #[repr(C)]\n@@ -719,8 +720,8 @@ extern \"C\" {\n     pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n     pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> &Value;\n     pub fn LLVMConstReal(RealTy: &Type, N: f64) -> &Value;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: &Value) -> c_ulonglong;\n-    pub fn LLVMRustConstInt128Get(ConstantVal: &Value, SExt: bool,\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: &ConstantInt) -> c_ulonglong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: &ConstantInt, SExt: bool,\n                                   high: &mut u64, low: &mut u64) -> bool;\n \n \n@@ -1666,7 +1667,7 @@ extern \"C\" {\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteValueToString(value_ref: &Value, s: &RustString);\n \n-    pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&Value>;\n+    pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;"}, {"sha": "d921bbc96adeebeedcab5dfbeab0530ede3ee620", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -65,7 +65,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             if let (&ty::Generator(_, substs, _), &layout::Variants::Single { index })\n                  = (&layout.ty.kind, &layout.variants)\n             {\n-                write!(&mut name, \"::{}\", substs.variant_name(index)).unwrap();\n+                write!(&mut name, \"::{}\", substs.as_generator().variant_name(index)).unwrap();\n             }\n             Some(name)\n         }"}, {"sha": "6992f93d9994950e425ac467e5c28d3066bf938e", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -21,6 +21,7 @@ tempfile = \"3.1\"\n \n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_expand = { path = \"../libsyntax_expand\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc = { path = \"../librustc\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }"}, {"sha": "a09a0c22c1ba5ec8dbd1918c809ee71fbde5fa99", "filename": "src/librustc_codegen_ssa/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FREADME.md?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -84,7 +84,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n {\n     fn new_block<'b>(\n         cx: &'a Self::CodegenCx,\n-        llfn: Self::Value,\n+        llfn: Self::Function,\n         name: &'b str\n     ) -> Self;\n     /* ... */"}, {"sha": "1c5d3b1a890ee76dfcfcd60966208b55aeed3bfe", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -323,6 +323,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             NativeLibraryKind::NativeStatic => {}\n             NativeLibraryKind::NativeStaticNobundle |\n             NativeLibraryKind::NativeFramework |\n+            NativeLibraryKind::NativeRawDylib |\n             NativeLibraryKind::NativeUnknown => continue,\n         }\n         if let Some(name) = lib.name {\n@@ -883,7 +884,8 @@ pub fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary\n                     Some(format!(\"-framework {}\", name))\n                 },\n                 // These are included, no need to print them\n-                NativeLibraryKind::NativeStatic => None,\n+                NativeLibraryKind::NativeStatic |\n+                NativeLibraryKind::NativeRawDylib => None,\n             }\n         })\n         .collect();\n@@ -1293,7 +1295,11 @@ pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n             NativeLibraryKind::NativeUnknown => cmd.link_dylib(name),\n             NativeLibraryKind::NativeFramework => cmd.link_framework(name),\n             NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(name),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(name, &search_path)\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(name, &search_path),\n+            NativeLibraryKind::NativeRawDylib => {\n+                // FIXME(#58713): Proper handling for raw dylibs.\n+                bug!(\"raw_dylib feature not yet implemented\");\n+            },\n         }\n     }\n }\n@@ -1385,7 +1391,9 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n                 add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n             }\n-            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n+            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) &&\n+                  crate_type == config::CrateType::Executable => {\n+                // Link the sanitizer runtimes only if we are actually producing an executable\n                 link_sanitizer_runtime::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n@@ -1527,7 +1535,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n+        time_ext(sess.time_extended(), &format!(\"altering {}.rlib\", name), || {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n \n@@ -1678,7 +1686,11 @@ pub fn add_upstream_native_libraries(\n                 // ignore statically included native libraries here as we've\n                 // already included them when we included the rust library\n                 // previously\n-                NativeLibraryKind::NativeStatic => {}\n+                NativeLibraryKind::NativeStatic => {},\n+                NativeLibraryKind::NativeRawDylib => {\n+                    // FIXME(#58713): Proper handling for raw dylibs.\n+                    bug!(\"raw_dylib feature not yet implemented\");\n+                },\n             }\n         }\n     }"}, {"sha": "d866a10f06935b55117f0a7b95469297add79afb", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::util::nodemap::{FxHashMap, DefIdMap};\n use rustc_index::vec::IndexVec;\n-use syntax::ext::allocator::ALLOCATOR_METHODS;\n+use syntax_expand::allocator::ALLOCATOR_METHODS;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,"}, {"sha": "8bc815f2c622ed61406cab1ac0ce2e596cf14388", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -22,11 +22,12 @@ use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n use rustc::util::profiling::SelfProfilerRef;\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n-use rustc_errors::{Handler, Level, FatalError, DiagnosticId};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::{Handler, Level, FatalError, DiagnosticId, SourceMapperDyn};\n use rustc_errors::emitter::{Emitter};\n use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax_expand::hygiene::ExpnId;\n use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n@@ -321,8 +322,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let (coordinator_send, coordinator_receive) = channel();\n     let sess = tcx.sess;\n \n-    sess.prof.generic_activity_start(\"codegen_and_optimize_crate\");\n-\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, sym::no_builtins);\n@@ -1665,13 +1664,13 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit_diagnostic(&mut self, db: &rustc_errors::Diagnostic) {\n+    fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: db.message(),\n-            code: db.code.clone(),\n-            lvl: db.level,\n+            msg: diag.message(),\n+            code: diag.code.clone(),\n+            lvl: diag.level,\n         })));\n-        for child in &db.children {\n+        for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n                 msg: child.message(),\n                 code: None,\n@@ -1680,6 +1679,9 @@ impl Emitter for SharedEmitter {\n         }\n         drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n     }\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        None\n+    }\n }\n \n impl SharedEmitterMain {\n@@ -1774,8 +1776,6 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n             self.backend.print_pass_timings()\n         }\n \n-        sess.prof.generic_activity_end(\"codegen_and_optimize_crate\");\n-\n         (CodegenResults {\n             crate_name: self.crate_name,\n             crate_hash: self.crate_hash,"}, {"sha": "f4f3dd4d2d295520629a458f2d320ed11a8071db", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -36,7 +36,6 @@ use crate::mir::place::PlaceRef;\n use crate::back::write::{OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n     submit_post_lto_module_to_llvm};\n use crate::{MemFlags, CrateInfo};\n-use crate::callee;\n use crate::common::{RealPredicate, TypeKind, IntPredicate};\n use crate::meth;\n use crate::mir;\n@@ -169,12 +168,6 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n-        }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n@@ -197,6 +190,8 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            // FIXME(eddyb) move these out of this `match` arm, so they're always\n+            // applied, uniformly, no matter the source/destination types.\n             (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n              bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n         }\n@@ -213,31 +208,27 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n-    let mut coerce_ptr = || {\n-        let (base, info) = match bx.load_operand(src).val {\n-            OperandValue::Pair(base, info) => {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                // So we need to pointercast the base to ensure\n-                // the types match up.\n-                let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n-                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n-            }\n-            OperandValue::Immediate(base) => {\n-                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n-            }\n-            OperandValue::Ref(..) => bug!()\n-        };\n-        OperandValue::Pair(base, info).store(bx, dst);\n-    };\n     match (&src_ty.kind, &dst_ty.kind) {\n         (&ty::Ref(..), &ty::Ref(..)) |\n         (&ty::Ref(..), &ty::RawPtr(..)) |\n         (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n-            coerce_ptr()\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            coerce_ptr()\n+            let (base, info) = match bx.load_operand(src).val {\n+                OperandValue::Pair(base, info) => {\n+                    // fat-ptr to fat-ptr unsize preserves the vtable\n+                    // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                    // So we need to pointercast the base to ensure\n+                    // the types match up.\n+                    // FIXME(eddyb) use `scalar_pair_element_backend_type` here,\n+                    // like `unsize_thin_ptr` does.\n+                    let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n+                    (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n+                }\n+                OperandValue::Immediate(base) => {\n+                    unsize_thin_ptr(bx, base, src_ty, dst_ty)\n+                }\n+                OperandValue::Ref(..) => bug!()\n+            };\n+            OperandValue::Pair(base, info).store(bx, dst);\n         }\n \n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n@@ -377,8 +368,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let sig = instance.fn_sig(cx.tcx());\n     let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n-    let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n-        bug!(\"Instance `{:?}` not already declared\", instance));\n+    let lldecl = cx.get_fn(instance);\n \n     let mir = cx.tcx().instance_mir(instance.def);\n     mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n@@ -400,7 +390,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         return;\n     }\n \n-    let main_llfn = cx.get_fn(instance);\n+    let main_llfn = cx.get_fn_addr(instance);\n \n     let et = cx.tcx().entry_fn(LOCAL_CRATE).map(|e| e.1);\n     match et {\n@@ -416,8 +406,11 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n     ) {\n-        let llfty =\n-            cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int());\n+        let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n+            cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int())\n+        } else {\n+            cx.type_func(&[], cx.type_int())\n+        };\n \n         let main_ret_ty = cx.tcx().fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -447,18 +440,29 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n-        // Params from native main() used as args for rust start function\n-        let param_argc = bx.get_param(0);\n-        let param_argv = bx.get_param(1);\n-        let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n-        let arg_argv = param_argv;\n+        let (arg_argc, arg_argv) = if cx.sess().target.target.options.main_needs_argc_argv {\n+            // Params from native main() used as args for rust start function\n+            let param_argc = bx.get_param(0);\n+            let param_argv = bx.get_param(1);\n+            let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n+            let arg_argv = param_argv;\n+            (arg_argc, arg_argv)\n+        } else {\n+            // The Rust start function doesn't need argc and argv, so just pass zeros.\n+            let arg_argc = bx.const_int(cx.type_int(), 0);\n+            let arg_argv = bx.const_null(cx.type_ptr_to(cx.type_i8p()));\n+            (arg_argc, arg_argv)\n+        };\n \n         let (start_fn, args) = if use_start_lang_item {\n             let start_def_id = cx.tcx().require_lang_item(StartFnLangItem, None);\n-            let start_fn = callee::resolve_and_get_fn(\n-                cx,\n-                start_def_id,\n-                cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+            let start_fn = cx.get_fn_addr(\n+                ty::Instance::resolve(\n+                    cx.tcx(),\n+                    ty::ParamEnv::reveal_all(),\n+                    start_def_id,\n+                    cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+                ).unwrap()\n             );\n             (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n                             arg_argc, arg_argv])"}, {"sha": "4744dd6302fb3200f1527371a04f35d19eaa598c", "filename": "src/librustc_codegen_ssa/callee.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcallee.rs?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,36 +0,0 @@\n-use crate::traits::*;\n-use rustc::ty;\n-use rustc::ty::subst::SubstsRef;\n-use rustc::hir::def_id::DefId;\n-\n-pub fn resolve_and_get_fn<'tcx, Cx: CodegenMethods<'tcx>>(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}\n-\n-pub fn resolve_and_get_fn_for_vtable<'tcx,\n-    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n->(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve_for_vtable(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}"}, {"sha": "ac39ca98476670ed2761ade3808667e35b4b2e51", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,7 @@\n #![allow(non_camel_case_types, non_snake_case)]\n \n use rustc::ty::{Ty, TyCtxt};\n+use rustc::session::Session;\n use syntax_pos::Span;\n \n use rustc::hir::def_id::DefId;\n@@ -200,3 +201,7 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n+\n+pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n+    span_err!(a, b, E0511, \"{}\", c);\n+}"}, {"sha": "02e26d8f6ecf0f9bebb552fc5dbb11b3717c7120", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,5 +1,40 @@\n syntax::register_diagnostics! {\n \n+E0511: r##\"\n+Invalid monomorphization of an intrinsic function was used. Erroneous code\n+example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+fn main() {\n+    unsafe { simd_add(0, 1); }\n+    // error: invalid monomorphization of `simd_add` intrinsic\n+}\n+```\n+\n+The generic type has to be a SIMD type. Example:\n+\n+```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x2(i32, i32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n+```\n+\"##,\n+\n E0668: r##\"\n Malformed inline assembly rejected by LLVM.\n "}, {"sha": "0221a04b045188840e07efef6cf66154fdfecb9c", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -10,7 +10,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(trusted_len)]\n-#![feature(mem_take)]\n #![feature(associated_type_bounds)]\n \n #![recursion_limit=\"256\"]\n@@ -28,6 +27,7 @@ use rustc::dep_graph::WorkProduct;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::middle::lang_items::LangItem;\n use rustc::hir::def_id::CrateNum;\n+use rustc::ty::query::Providers;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::svh::Svh;\n@@ -42,7 +42,6 @@ pub mod traits;\n pub mod mir;\n pub mod debuginfo;\n pub mod base;\n-pub mod callee;\n pub mod glue;\n pub mod meth;\n pub mod mono_item;\n@@ -157,3 +156,13 @@ pub struct CodegenResults {\n     pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    crate::back::symbol_export::provide(providers);\n+    crate::base::provide_both(providers);\n+}\n+\n+pub fn provide_extern(providers: &mut Providers<'_>) {\n+    crate::back::symbol_export::provide_extern(providers);\n+    crate::base::provide_both(providers);\n+}"}, {"sha": "266d2e5b18d22bbbfe2aa256b472cb495bb02c1e", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,5 @@\n use rustc_target::abi::call::FnType;\n \n-use crate::callee;\n use crate::traits::*;\n \n use rustc::ty::{self, Ty, Instance};\n@@ -92,7 +91,14 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n \n     let methods = methods.cloned().map(|opt_mth| {\n         opt_mth.map_or(nullptr, |(def_id, substs)| {\n-            callee::resolve_and_get_fn_for_vtable(cx, def_id, substs)\n+            cx.get_fn_addr(\n+                ty::Instance::resolve_for_vtable(\n+                    cx.tcx(),\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    substs,\n+                ).unwrap()\n+            )\n         })\n     });\n \n@@ -102,7 +108,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     // `get_vtable` in rust_mir/interpret/traits.rs\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n-        cx.get_fn(Instance::resolve_drop_in_place(cx.tcx(), ty)),\n+        cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty)),\n         cx.const_usize(layout.size.bytes()),\n         cx.const_usize(layout.align.abi.bytes())\n     ].iter().cloned().chain(methods).collect();"}, {"sha": "dc77d025c005fa4307d5dd77f187a95ffd31609f", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -149,6 +149,26 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    // Generate sideeffect intrinsic if jumping to any of the targets can form\n+    // a loop.\n+    fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n+        &self,\n+        mir: &'b mir::Body<'tcx>,\n+        bx: &mut Bx,\n+        targets: &[mir::BasicBlock],\n+    ) {\n+        if bx.tcx().sess.opts.debugging_opts.insert_sideeffect {\n+            if targets.iter().any(|target| {\n+                *target <= *self.bb\n+                    && target\n+                        .start_location()\n+                        .is_predecessor_of(self.bb.start_location(), mir)\n+            }) {\n+                bx.sideeffect();\n+            }\n+        }\n+    }\n }\n \n /// Codegen implementations for some terminator variants.\n@@ -197,6 +217,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let lltrue = helper.llblock(self, targets[0]);\n             let llfalse = helper.llblock(self, targets[1]);\n             if switch_ty == bx.tcx().types.bool {\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n                 if let [0] = values[..] {\n                     bx.cond_br(discr.immediate(), llfalse, lltrue);\n@@ -210,9 +231,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n                 let llval = bx.const_uint_big(switch_llty, values[0]);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n+            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n             let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n@@ -308,6 +331,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return\n         }\n@@ -334,10 +358,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n             }\n             _ => {\n-                (bx.get_fn(drop_fn),\n+                (bx.get_fn_addr(drop_fn),\n                  FnType::of_instance(&bx, drop_fn))\n             }\n         };\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n@@ -373,6 +398,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -383,6 +409,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -433,7 +460,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n         let fn_ty = FnType::of_instance(&bx, instance);\n-        let llfn = bx.get_fn(instance);\n+        let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n         helper.do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n@@ -486,6 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -513,6 +541,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n@@ -547,8 +576,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let fn_ty = FnType::of_instance(&bx, instance);\n-                let llfn = bx.get_fn(instance);\n+                let llfn = bx.get_fn_addr(instance);\n \n+                if let Some((_, target)) = destination.as_ref() {\n+                    helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+                }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n@@ -561,7 +593,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n             } else {\n                 // a NOP\n-                helper.funclet_br(self, &mut bx, destination.as_ref().unwrap().1)\n+                let target = destination.as_ref().unwrap().1;\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n             }\n             return;\n         }\n@@ -670,6 +704,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             if let Some((_, target)) = *destination {\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 bx.unreachable();\n@@ -758,10 +793,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let fn_ptr = match (llfn, instance) {\n             (Some(llfn), _) => llfn,\n-            (None, Some(instance)) => bx.get_fn(instance),\n+            (None, Some(instance)) => bx.get_fn_addr(instance),\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n+        if let Some((_, target)) = destination.as_ref() {\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+        }\n         helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                        cleanup);\n@@ -811,6 +849,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "1a2e796a5b7be6adc44b375316295c035d5ed2c9", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -30,7 +30,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     debug_context: FunctionDebugContext<Bx::DIScope>,\n \n-    llfn: Bx::Value,\n+    llfn: Bx::Function,\n \n     cx: &'a Bx::CodegenCx,\n \n@@ -183,7 +183,7 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n \n pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n-    llfn: Bx::Value,\n+    llfn: Bx::Function,\n     mir: &'a Body<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n@@ -200,6 +200,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n+    bx.sideeffect();\n+\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n@@ -636,7 +638,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                         ty::Generator(def_id, substs, _) => (def_id, substs),\n                         _ => bug!(\"generator layout without generator substs\"),\n                     };\n-                    let state_tys = gen_substs.state_tys(def_id, tcx);\n+                    let state_tys = gen_substs.as_generator().state_tys(def_id, tcx);\n \n                     generator_layout.variant_fields.iter()\n                         .zip(state_tys)"}, {"sha": "1d1bc2a81a2ca7459205a34391f665b92ec35a4e", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -394,8 +394,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         // Statically compute the offset if we can, otherwise just use the element size,\n         // as this will yield the lowest alignment.\n         let layout = self.layout.field(bx, 0);\n-        let offset = if bx.is_const_integral(llindex) {\n-            layout.size.checked_mul(bx.const_to_uint(llindex), bx).unwrap_or(layout.size)\n+        let offset = if let Some(llindex) = bx.const_to_opt_uint(llindex) {\n+            layout.size.checked_mul(llindex, bx).unwrap_or(layout.size)\n         } else {\n             layout.size\n         };"}, {"sha": "27442bb6bff887f54d866f6fe090267d1e89e427", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -10,7 +10,6 @@ use syntax::source_map::{DUMMY_SP, Span};\n \n use crate::base;\n use crate::MemFlags;\n-use crate::callee;\n use crate::common::{self, RealPredicate, IntPredicate};\n \n use crate::traits::*;\n@@ -95,7 +94,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let size = bx.const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n-                    if bx.cx().is_const_integral(v) && bx.cx().const_to_uint(v) == 0 {\n+                    if bx.cx().const_to_opt_uint(v) == Some(0) {\n                         let fill = bx.cx().const_u8(0);\n                         bx.memset(start, fill, size, dest.align, MemFlags::empty());\n                         return bx;\n@@ -190,7 +189,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     bug!(\"reifying a fn ptr that requires const arguments\");\n                                 }\n                                 OperandValue::Immediate(\n-                                    callee::resolve_and_get_fn(bx.cx(), def_id, substs))\n+                                    bx.get_fn_addr(\n+                                        ty::Instance::resolve_for_fn_ptr(\n+                                            bx.tcx(),\n+                                            ty::ParamEnv::reveal_all(),\n+                                            def_id,\n+                                            substs\n+                                        ).unwrap()\n+                                    )\n+                                )\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n@@ -205,7 +212,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     def_id,\n                                     substs,\n                                     ty::ClosureKind::FnOnce);\n-                                OperandValue::Immediate(bx.cx().get_fn(instance))\n+                                OperandValue::Immediate(bx.cx().get_fn_addr(instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n@@ -488,7 +495,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let r = bx.cx().get_fn(instance);\n+                let r = bx.cx().get_fn_addr(instance);\n                 let call = bx.call(r, &[llsize, llalign], None);\n                 let val = bx.pointercast(call, llty_ptr);\n "}, {"sha": "7cae3e9ade5903f3987434b3e6a2e59615568e3e", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -9,11 +9,13 @@ use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use std::sync::Arc;\n use std::sync::mpsc;\n-use syntax::ext::allocator::AllocatorKind;\n+use syntax_expand::allocator::AllocatorKind;\n use syntax_pos::symbol::InternedString;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n+    type Function: CodegenObject;\n+\n     type BasicBlock: Copy;\n     type Type: CodegenObject;\n     type Funclet;"}, {"sha": "62b5bcbb6c9dcff67c89e7899ae4d0a50c0e7951", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -34,7 +34,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     + HasTargetSpec\n \n {\n-    fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;\n+    fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Function, name: &'b str) -> Self;\n     fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n     fn build_sibling_block(&self, name: &str) -> Self;\n     fn cx(&self) -> &Self::CodegenCx;"}, {"sha": "95ada60fae08dd74ffc6f926967232489a27e50d", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -21,11 +21,9 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n \n     fn const_struct(&self, elts: &[Self::Value], packed: bool) -> Self::Value;\n \n-    fn const_to_uint(&self, v: Self::Value) -> u64;\n+    fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n-    fn is_const_integral(&self, v: Self::Value) -> bool;\n-\n     fn scalar_to_backend(\n         &self,\n         cv: Scalar,"}, {"sha": "989e6cf9dcaf1ea57aad2df096189b725a1adab8", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -20,7 +20,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         &self,\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n-        llfn: Self::Value,\n+        llfn: Self::Function,\n         mir: &mir::Body<'_>,\n     ) -> FunctionDebugContext<Self::DIScope>;\n "}, {"sha": "cd42044e48df8cf6d6c5cf0dfa458acc50c31b85", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -17,13 +17,13 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Value;\n+    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Function;\n \n     /// Declare a Rust function.\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+    fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Function;\n \n     /// Declare a global with an intention to define it.\n     ///"}, {"sha": "2c484084c4a20e063bc0c67d51423501b16eb787", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -20,6 +20,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n+    fn sideeffect(&mut self);\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "658ddd0028076970726f1d05b38a9b39400b7699", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -11,14 +11,14 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n         &self,\n     ) -> &RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Self::Value>>;\n     fn check_overflow(&self) -> bool;\n-    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, Self::Value>>;\n-    fn get_fn(&self, instance: Instance<'tcx>) -> Self::Value;\n+    fn get_fn(&self, instance: Instance<'tcx>) -> Self::Function;\n+    fn get_fn_addr(&self, instance: Instance<'tcx>) -> Self::Value;\n     fn eh_personality(&self) -> Self::Value;\n     fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n-    fn set_frame_pointer_elimination(&self, llfn: Self::Value);\n-    fn apply_target_cpu_attr(&self, llfn: Self::Value);\n+    fn set_frame_pointer_elimination(&self, llfn: Self::Function);\n+    fn apply_target_cpu_attr(&self, llfn: Self::Function);\n     fn create_used_variable(&self);\n }"}, {"sha": "4318ef16494a11194af39f0c434f3488106909ec", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -88,6 +88,7 @@ pub trait HasCodegen<'tcx>:\n     type CodegenCx: CodegenMethods<'tcx>\n         + BackendTypes<\n             Value = Self::Value,\n+            Function = Self::Function,\n             BasicBlock = Self::BasicBlock,\n             Type = Self::Type,\n             Funclet = Self::Funclet,"}, {"sha": "1077c1f42637ebf85a00c5d41a9b3c5b378a0eef", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -25,7 +25,6 @@ pub trait CodegenBackend {\n     fn target_features(&self, _sess: &Session) -> Vec<Symbol> { vec![] }\n     fn print_passes(&self) {}\n     fn print_version(&self) {}\n-    fn diagnostics(&self) -> &[(&'static str, &'static str)] { &[] }\n \n     fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n     fn provide(&self, _providers: &mut Providers<'_>);"}, {"sha": "66920342ff6ba3b894ec3135af73e45a0257fa90", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -18,6 +18,7 @@\n extern crate rustc;\n \n use rustc::ty::TyCtxt;\n+use rustc::ty::query::Providers;\n use rustc::hir::def_id::LOCAL_CRATE;\n use syntax::symbol::sym;\n \n@@ -37,3 +38,7 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n         }\n     }\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    crate::symbol_names::provide(providers);\n+}"}, {"sha": "cf575c54293c76ab690f86c98783088b5c42e189", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -225,7 +225,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n             ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::Closure(def_id, substs) |\n-            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+            ty::Generator(def_id, substs, _) => {\n                 self.print_def_path(def_id, substs)\n             }\n             _ => self.pretty_print_type(ty),"}, {"sha": "55b148fceb2177393101b9524258e9d8da68b64c", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -415,7 +415,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::Closure(def_id, substs) |\n-            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+            ty::Generator(def_id, substs, _) => {\n                 self = self.print_def_path(def_id, substs)?;\n             }\n             ty::Foreign(def_id) => {"}, {"sha": "065c8436ae06aa54fc5c19e9e727e94cf7873177", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -20,8 +20,8 @@ graphviz = { path = \"../libgraphviz\" }\n cfg-if = \"0.1.2\"\n crossbeam-utils = { version = \"0.6.5\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\"\n-rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n-rayon-core = { version = \"0.2.0\", package = \"rustc-rayon-core\" }\n+rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n+rayon-core = { version = \"0.3.0\", package = \"rustc-rayon-core\" }\n rustc-hash = \"1.0.1\"\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }"}, {"sha": "d0ff6108d6ea6183fc3d035198b588585ac206e2", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,6 +2,7 @@ use std::hash::{Hasher, Hash};\n use std::mem;\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n+use smallvec::SmallVec;\n use crate::fx::{FxHasher, FxHashMap};\n use crate::sync::{Lock, LockGuard};\n \n@@ -18,7 +19,7 @@ const SHARD_BITS: usize = 5;\n #[cfg(not(parallel_compiler))]\n const SHARD_BITS: usize = 0;\n \n-const SHARDS: usize = 1 << SHARD_BITS;\n+pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n #[derive(Clone)]\n@@ -29,21 +30,36 @@ pub struct Sharded<T> {\n impl<T: Default> Default for Sharded<T> {\n     #[inline]\n     fn default() -> Self {\n+        Self::new(|| T::default())\n+    }\n+}\n+\n+impl<T> Sharded<T> {\n+    #[inline]\n+    pub fn new(mut value: impl FnMut() -> T) -> Self {\n+        // Create a vector of the values we want\n+        let mut values: SmallVec<[_; SHARDS]> = (0..SHARDS).map(|_| {\n+            CacheAligned(Lock::new(value()))\n+        }).collect();\n+\n+        // Create an unintialized array\n         let mut shards: mem::MaybeUninit<[CacheAligned<Lock<T>>; SHARDS]> =\n             mem::MaybeUninit::uninit();\n-        let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+\n         unsafe {\n-            for i in 0..SHARDS {\n-                first.add(i).write(CacheAligned(Lock::new(T::default())));\n-            }\n+            // Copy the values into our array\n+            let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+            values.as_ptr().copy_to_nonoverlapping(first, SHARDS);\n+\n+            // Ignore the content of the vector\n+            values.set_len(0);\n+\n             Sharded {\n                 shards: shards.assume_init(),\n             }\n         }\n     }\n-}\n \n-impl<T> Sharded<T> {\n     #[inline]\n     pub fn get_shard_by_value<K: Hash + ?Sized>(&self, val: &K) -> &Lock<T> {\n         if SHARDS == 1 {"}, {"sha": "9622c290039d5ddac11616b97714f55a47d8abe4", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,6 @@\n //! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n //!\n-//! `Lrc` is an alias of either Rc or Arc.\n+//! `Lrc` is an alias of `Arc` if cfg!(parallel_compiler) is true, `Rc` otherwise.\n //!\n //! `Lock` is a mutex.\n //! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n@@ -12,7 +12,7 @@\n //!\n //! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n //!\n-//! `MTRef` is a immutable reference if cfg!(parallel_compiler), and an mutable reference otherwise.\n+//! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n //!\n //! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n //! depending on the value of cfg!(parallel_compiler).\n@@ -23,29 +23,6 @@ use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use crate::owning_ref::{Erased, OwningRef};\n \n-pub fn serial_join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)\n-    where A: FnOnce() -> RA,\n-          B: FnOnce() -> RB\n-{\n-    (oper_a(), oper_b())\n-}\n-\n-pub struct SerialScope;\n-\n-impl SerialScope {\n-    pub fn spawn<F>(&self, f: F)\n-        where F: FnOnce(&SerialScope)\n-    {\n-        f(self)\n-    }\n-}\n-\n-pub fn serial_scope<F, R>(f: F) -> R\n-    where F: FnOnce(&SerialScope) -> R\n-{\n-    f(&SerialScope)\n-}\n-\n pub use std::sync::atomic::Ordering::SeqCst;\n pub use std::sync::atomic::Ordering;\n \n@@ -176,8 +153,28 @@ cfg_if! {\n         pub type AtomicU32 = Atomic<u32>;\n         pub type AtomicU64 = Atomic<u64>;\n \n-        pub use self::serial_join as join;\n-        pub use self::serial_scope as scope;\n+        pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)\n+            where A: FnOnce() -> RA,\n+                  B: FnOnce() -> RB\n+        {\n+            (oper_a(), oper_b())\n+        }\n+\n+        pub struct SerialScope;\n+\n+        impl SerialScope {\n+            pub fn spawn<F>(&self, f: F)\n+                where F: FnOnce(&SerialScope)\n+            {\n+                f(self)\n+            }\n+        }\n+\n+        pub fn scope<F, R>(f: F) -> R\n+            where F: FnOnce(&SerialScope) -> R\n+        {\n+            f(&SerialScope)\n+        }\n \n         #[macro_export]\n         macro_rules! parallel {"}, {"sha": "f33cb4e215d332a4b7edef4bc953d2d170233196", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -166,7 +166,8 @@ pub fn run_compiler(\n         None => return Ok(()),\n     };\n \n-    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n+    let sopts = config::build_session_options(&matches);\n+    let cfg = config::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n \n     let mut dummy_config = |sopts, cfg, diagnostic_output| {\n         let mut config = interface::Config {\n@@ -615,7 +616,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                &*cstore.metadata_loader,\n+                                                cstore,\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "491bc2aa6a2eb7034669b33c4ae7cbba214164e5", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -31,24 +31,28 @@ pub struct AnnotateSnippetEmitterWriter {\n \n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n-    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        let mut children = db.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let mut children = diag.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n         self.fix_multispans_in_std_macros(&self.source_map,\n                                           &mut primary_span,\n                                           &mut children,\n-                                          &db.level,\n+                                          &diag.level,\n                                           self.external_macro_backtrace);\n \n-        self.emit_messages_default(&db.level,\n-                                   db.message(),\n-                                   &db.code,\n+        self.emit_messages_default(&diag.level,\n+                                   diag.message(),\n+                                   &diag.code,\n                                    &primary_span,\n                                    &children,\n                                    &suggestions);\n     }\n \n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        self.source_map.as_ref()\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         !self.short_message\n     }"}, {"sha": "fd74d8673da4dbc482430bd764caccf5d61a0dd6", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 68, "deletions": 37, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -298,9 +298,31 @@ impl Diagnostic {\n     /// * may contain a name of a function, variable, or type, but not whole expressions\n     ///\n     /// See `CodeSuggestion` for more information.\n-    pub fn span_suggestion(&mut self, sp: Span, msg: &str,\n-                                       suggestion: String,\n-                                       applicability: Applicability) -> &mut Self {\n+    pub fn span_suggestion(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        self.span_suggestion_with_style(\n+            sp,\n+            msg,\n+            suggestion,\n+            applicability,\n+            SuggestionStyle::ShowCode,\n+        );\n+        self\n+    }\n+\n+    pub fn span_suggestion_with_style(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+        style: SuggestionStyle,\n+    ) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart {\n@@ -309,16 +331,37 @@ impl Diagnostic {\n                 }],\n             }],\n             msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n         });\n         self\n     }\n \n+    pub fn span_suggestion_verbose(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        self.span_suggestion_with_style(\n+            sp,\n+            msg,\n+            suggestion,\n+            applicability,\n+            SuggestionStyle::ShowAlways,\n+        );\n+        self\n+    }\n+\n     /// Prints out a message with multiple suggested edits of the code.\n-    pub fn span_suggestions(&mut self, sp: Span, msg: &str,\n-        suggestions: impl Iterator<Item = String>, applicability: Applicability) -> &mut Self\n-    {\n+    pub fn span_suggestions(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestions: impl Iterator<Item = String>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n             substitutions: suggestions.map(|snippet| Substitution {\n                 parts: vec![SubstitutionPart {\n@@ -340,17 +383,13 @@ impl Diagnostic {\n     pub fn span_suggestion_short(\n         &mut self, sp: Span, msg: &str, suggestion: String, applicability: Applicability\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: vec![SubstitutionPart {\n-                    snippet: suggestion,\n-                    span: sp,\n-                }],\n-            }],\n-            msg: msg.to_owned(),\n-            style: SuggestionStyle::HideCodeInline,\n+        self.span_suggestion_with_style(\n+            sp,\n+            msg,\n+            suggestion,\n             applicability,\n-        });\n+            SuggestionStyle::HideCodeInline,\n+        );\n         self\n     }\n \n@@ -363,17 +402,13 @@ impl Diagnostic {\n     pub fn span_suggestion_hidden(\n         &mut self, sp: Span, msg: &str, suggestion: String, applicability: Applicability\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: vec![SubstitutionPart {\n-                    snippet: suggestion,\n-                    span: sp,\n-                }],\n-            }],\n-            msg: msg.to_owned(),\n-            style: SuggestionStyle::HideCodeAlways,\n+        self.span_suggestion_with_style(\n+            sp,\n+            msg,\n+            suggestion,\n             applicability,\n-        });\n+            SuggestionStyle::HideCodeAlways,\n+        );\n         self\n     }\n \n@@ -384,17 +419,13 @@ impl Diagnostic {\n     pub fn tool_only_span_suggestion(\n         &mut self, sp: Span, msg: &str, suggestion: String, applicability: Applicability\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: vec![SubstitutionPart {\n-                    snippet: suggestion,\n-                    span: sp,\n-                }],\n-            }],\n-            msg: msg.to_owned(),\n-            style: SuggestionStyle::CompletelyHidden,\n+        self.span_suggestion_with_style(\n+            sp,\n+            msg,\n+            suggestion,\n             applicability,\n-        });\n+            SuggestionStyle::CompletelyHidden,\n+        );\n         self\n     }\n "}, {"sha": "1e486786f6861a90dff68ed0b2b7e0a11dfb7e05", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -13,7 +13,7 @@ use syntax_pos::{SourceFile, Span, MultiSpan};\n \n use crate::{\n     Level, CodeSuggestion, Diagnostic, SubDiagnostic,\n-    SuggestionStyle, SourceMapperDyn, DiagnosticId,\n+    SuggestionStyle, SourceMapper, SourceMapperDyn, DiagnosticId,\n };\n use crate::Level::Error;\n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n@@ -180,7 +180,7 @@ const ANONYMIZED_LINE_NUM: &str = \"LL\";\n /// Emitter trait for emitting errors.\n pub trait Emitter {\n     /// Emit a structured diagnostic.\n-    fn emit_diagnostic(&mut self, db: &Diagnostic);\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic);\n \n     /// Emit a notification that an artifact has been output.\n     /// This is currently only supported for the JSON format,\n@@ -192,6 +192,8 @@ pub trait Emitter {\n         true\n     }\n \n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>>;\n+\n     /// Formats the substitutions of the primary_span\n     ///\n     /// The are a lot of conditions to this method, but in short:\n@@ -204,10 +206,10 @@ pub trait Emitter {\n     ///   we return the original `primary_span` and the original suggestions.\n     fn primary_span_formatted<'a>(\n         &mut self,\n-        db: &'a Diagnostic\n+        diag: &'a Diagnostic,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n-        let mut primary_span = db.span.clone();\n-        if let Some((sugg, rest)) = db.suggestions.split_first() {\n+        let mut primary_span = diag.span.clone();\n+        if let Some((sugg, rest)) = diag.suggestions.split_first() {\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n@@ -218,10 +220,14 @@ pub trait Emitter {\n                sugg.msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n                !sugg.substitutions[0].parts[0].snippet.contains('\\n') &&\n-               // when this style is set we want the suggestion to be a message, not inline\n-               sugg.style != SuggestionStyle::HideCodeAlways &&\n-               // trivial suggestion for tooling's sake, never shown\n-               sugg.style != SuggestionStyle::CompletelyHidden\n+               ![\n+                    // when this style is set we want the suggestion to be a message, not inline\n+                    SuggestionStyle::HideCodeAlways,\n+                    // trivial suggestion for tooling's sake, never shown\n+                    SuggestionStyle::CompletelyHidden,\n+                    // subtle suggestion, never shown inline\n+                    SuggestionStyle::ShowAlways,\n+               ].contains(&sugg.style)\n             {\n                 let substitution = &sugg.substitutions[0].parts[0].snippet.trim();\n                 let msg = if substitution.len() == 0 || sugg.style.hide_inline() {\n@@ -230,7 +236,20 @@ pub trait Emitter {\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n                     // Show the default suggestion text with the substitution\n-                    format!(\"help: {}: `{}`\", sugg.msg, substitution)\n+                    format!(\n+                        \"help: {}{}: `{}`\",\n+                        sugg.msg,\n+                        if self.source_map().map(|sm| is_case_difference(\n+                            &**sm,\n+                            substitution,\n+                            sugg.substitutions[0].parts[0].span,\n+                        )).unwrap_or(false) {\n+                            \" (notice the capitalization)\"\n+                        } else {\n+                            \"\"\n+                        },\n+                        substitution,\n+                    )\n                 };\n                 primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n \n@@ -241,10 +260,10 @@ pub trait Emitter {\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                (primary_span, &db.suggestions)\n+                (primary_span, &diag.suggestions)\n             }\n         } else {\n-            (primary_span, &db.suggestions)\n+            (primary_span, &diag.suggestions)\n         }\n     }\n \n@@ -378,19 +397,23 @@ pub trait Emitter {\n }\n \n impl Emitter for EmitterWriter {\n-    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        let mut children = db.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        self.sm.as_ref()\n+    }\n+\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let mut children = diag.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n         self.fix_multispans_in_std_macros(&self.sm,\n                                           &mut primary_span,\n                                           &mut children,\n-                                          &db.level,\n+                                          &diag.level,\n                                           self.external_macro_backtrace);\n \n-        self.emit_messages_default(&db.level,\n-                                   &db.styled_message(),\n-                                   &db.code,\n+        self.emit_messages_default(&diag.level,\n+                                   &diag.styled_message(),\n+                                   &diag.code,\n                                    &primary_span,\n                                    &children,\n                                    &suggestions);\n@@ -1457,7 +1480,9 @@ impl EmitterWriter {\n         let suggestions = suggestion.splice_lines(&**sm);\n \n         let mut row_num = 2;\n-        for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+        let mut notice_capitalization = false;\n+        for (complete, parts, only_capitalization) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+            notice_capitalization |= only_capitalization;\n             // Only show underline if the suggestion spans a single line and doesn't cover the\n             // entirety of the code output. If you have multiple replacements in the same line\n             // of code, show the underline.\n@@ -1548,7 +1573,10 @@ impl EmitterWriter {\n         }\n         if suggestions.len() > MAX_SUGGESTIONS {\n             let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n-            buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+            buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n+        } else if notice_capitalization {\n+            let msg = \"notice the capitalization difference\";\n+            buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n         }\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n@@ -2030,3 +2058,18 @@ impl<'a> Drop for WritableDst<'a> {\n         }\n     }\n }\n+\n+/// Whether the original and suggested code are visually similar enough to warrant extra wording.\n+pub fn is_case_difference(sm: &dyn SourceMapper, suggested: &str, sp: Span) -> bool {\n+    // FIXME: this should probably be extended to also account for `FO0` \u2192 `FOO` and unicode.\n+    let found = sm.span_to_snippet(sp).unwrap();\n+    let ascii_confusables = &['c', 'f', 'i', 'k', 'o', 's', 'u', 'v', 'w', 'x', 'y', 'z'];\n+    // All the chars that differ in capitalization are confusable (above):\n+    let confusable = found.chars().zip(suggested.chars()).filter(|(f, s)| f != s).all(|(f, s)| {\n+        (ascii_confusables.contains(&f) || ascii_confusables.contains(&s))\n+    });\n+    confusable && found.to_lowercase() == suggested.to_lowercase()\n+            // FIXME: We sometimes suggest the same thing we already have, which is a\n+            //        bug, but be defensive against that here.\n+            && found != suggested\n+}"}, {"sha": "63df052a225041095d263a75ae11e51d45dd33f9", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -13,7 +13,7 @@ pub use emitter::ColorConfig;\n \n use Level::*;\n \n-use emitter::{Emitter, EmitterWriter};\n+use emitter::{Emitter, EmitterWriter, is_case_difference};\n use registry::Registry;\n \n use rustc_data_structures::sync::{self, Lrc, Lock};\n@@ -37,13 +37,16 @@ pub mod registry;\n mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos,\n-                 Loc,\n-                 FileLinesResult,\n-                 SourceFile,\n-                 FileName,\n-                 MultiSpan,\n-                 Span};\n+use syntax_pos::{\n+    BytePos,\n+    FileLinesResult,\n+    FileName,\n+    Loc,\n+    MultiSpan,\n+    SourceFile,\n+    Span,\n+    SpanSnippetError,\n+};\n \n /// Indicates the confidence in the correctness of a suggestion.\n ///\n@@ -81,6 +84,8 @@ pub enum SuggestionStyle {\n     /// This will *not* show the code if the suggestion is inline *and* the suggested code is\n     /// empty.\n     ShowCode,\n+    /// Always show the suggested code independently.\n+    ShowAlways,\n }\n \n impl SuggestionStyle {\n@@ -145,6 +150,7 @@ pub trait SourceMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n     fn span_to_string(&self, sp: Span) -> String;\n+    fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError>;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n     fn call_span_if_macro(&self, sp: Span) -> Span;\n@@ -153,9 +159,12 @@ pub trait SourceMapper {\n }\n \n impl CodeSuggestion {\n-    /// Returns the assembled code suggestions and whether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &SourceMapperDyn)\n-                        -> Vec<(String, Vec<SubstitutionPart>)> {\n+    /// Returns the assembled code suggestions, whether they should be shown with an underline\n+    /// and whether the substitution only differs in capitalization.\n+    pub fn splice_lines(\n+        &self,\n+        cm: &SourceMapperDyn,\n+    ) -> Vec<(String, Vec<SubstitutionPart>, bool)> {\n         use syntax_pos::{CharPos, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -230,6 +239,7 @@ impl CodeSuggestion {\n                 prev_hi = cm.lookup_char_pos(part.span.hi());\n                 prev_line = fm.get_line(prev_hi.line - 1);\n             }\n+            let only_capitalization = is_case_difference(cm, &buf, bounding_span);\n             // if the replacement already ends with a newline, don't print the next line\n             if !buf.ends_with('\\n') {\n                 push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n@@ -238,7 +248,7 @@ impl CodeSuggestion {\n             while buf.ends_with('\\n') {\n                 buf.pop();\n             }\n-            (buf, substitution.parts)\n+            (buf, substitution.parts, only_capitalization)\n         }).collect()\n     }\n }"}, {"sha": "b12ab9e4576025c8efb7d17777df90fe7e94458b", "filename": "src/librustc_errors/styled_buffer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -111,7 +111,7 @@ impl StyledBuffer {\n \n     pub fn prepend(&mut self, line: usize, string: &str, style: Style) {\n         self.ensure_lines(line);\n-        let string_len = string.len();\n+        let string_len = string.chars().count();\n \n         // Push the old content over to make room for new content\n         for _ in 0..string_len {"}, {"sha": "673da52c3250e62f0f27552a00952688f43f68a3", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -101,6 +101,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     // before we fire the background thread.\n \n     let time_passes = sess.time_passes();\n+    let prof = sess.prof.clone();\n \n     if sess.opts.incremental.is_none() {\n         // No incremental compilation.\n@@ -160,7 +161,9 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     }\n \n     MaybeAsync::Async(std::thread::spawn(move || {\n-        time_ext(time_passes, None, \"background load prev dep-graph\", move || {\n+        time_ext(time_passes, \"background load prev dep-graph\", move || {\n+            let _prof_timer = prof.generic_activity(\"incr_comp_load_dep_graph\");\n+\n             match load_data(report_incremental_info, &path) {\n                 LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n                 LoadResult::Error { message } => LoadResult::Error { message },\n@@ -198,6 +201,8 @@ pub fn load_query_result_cache(sess: &Session) -> OnDiskCache<'_> {\n         return OnDiskCache::new_empty(sess.source_map());\n     }\n \n+    let _prof_timer = sess.prof.generic_activity(\"incr_comp_load_query_result_cache\");\n+\n     match load_data(sess.opts.debugging_opts.incremental_info, &query_cache_path(sess)) {\n         LoadResult::Ok{ data: (bytes, start_pos) } => OnDiskCache::new(sess, bytes, start_pos),\n         _ => OnDiskCache::new_empty(sess.source_map())"}, {"sha": "f5935c9969baa04b367cb654e4d1b2b524c5a63f", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -241,6 +241,8 @@ fn encode_work_product_index(work_products: &FxHashMap<WorkProductId, WorkProduc\n \n fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     time(tcx.sess, \"serialize query result cache\", || {\n+        let _timer = tcx.prof.generic_activity(\"incr_comp_serialize_result_cache\");\n+\n         tcx.serialize_query_result_cache(encoder).unwrap();\n     })\n }"}, {"sha": "9ed5ef5a539a1bc01fd771e7c04df41e868c6196", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -13,15 +13,18 @@ pub type Word = u64;\n pub const WORD_BYTES: usize = mem::size_of::<Word>();\n pub const WORD_BITS: usize = WORD_BYTES * 8;\n \n-/// A fixed-size bitset type with a dense representation. It does not support\n-/// resizing after creation; use `GrowableBitSet` for that.\n+/// A fixed-size bitset type with a dense representation.\n+///\n+/// NOTE: Use [`GrowableBitSet`] if you need support for resizing after creation.\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n ///\n /// All operations that involve an element will panic if the element is equal\n /// to or greater than the domain size. All operations that involve two bitsets\n /// will panic if the bitsets have differing domain sizes.\n+///\n+/// [`GrowableBitSet`]: struct.GrowableBitSet.html\n #[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct BitSet<T: Idx> {\n     domain_size: usize,\n@@ -168,11 +171,7 @@ impl<T: Idx> BitSet<T> {\n     /// Iterates over the indices of set bits in a sorted order.\n     #[inline]\n     pub fn iter(&self) -> BitIter<'_, T> {\n-        BitIter {\n-            cur: None,\n-            iter: self.words.iter().enumerate(),\n-            marker: PhantomData,\n-        }\n+        BitIter::new(&self.words)\n     }\n \n     /// Duplicates the set as a hybrid set.\n@@ -291,26 +290,55 @@ impl<T: Idx> ToString for BitSet<T> {\n }\n \n pub struct BitIter<'a, T: Idx> {\n-    cur: Option<(Word, usize)>,\n-    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n+    /// A copy of the current word, but with any already-visited bits cleared.\n+    /// (This lets us use `trailing_zeros()` to find the next set bit.) When it\n+    /// is reduced to 0, we move onto the next word.\n+    word: Word,\n+\n+    /// The offset (measured in bits) of the current word.\n+    offset: usize,\n+\n+    /// Underlying iterator over the words.\n+    iter: slice::Iter<'a, Word>,\n+\n     marker: PhantomData<T>\n }\n \n+impl<'a, T: Idx> BitIter<'a, T> {\n+    #[inline]\n+    fn new(words: &'a [Word]) -> BitIter<'a, T> {\n+        // We initialize `word` and `offset` to degenerate values. On the first\n+        // call to `next()` we will fall through to getting the first word from\n+        // `iter`, which sets `word` to the first word (if there is one) and\n+        // `offset` to 0. Doing it this way saves us from having to maintain\n+        // additional state about whether we have started.\n+        BitIter {\n+            word: 0,\n+            offset: std::usize::MAX - (WORD_BITS - 1),\n+            iter: words.iter(),\n+            marker: PhantomData,\n+        }\n+    }\n+}\n+\n impl<'a, T: Idx> Iterator for BitIter<'a, T> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n         loop {\n-            if let Some((ref mut word, offset)) = self.cur {\n-                let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != WORD_BITS {\n-                    let bit = 1 << bit_pos;\n-                    *word ^= bit;\n-                    return Some(T::new(bit_pos + offset))\n-                }\n+            if self.word != 0 {\n+                // Get the position of the next set bit in the current word,\n+                // then clear the bit.\n+                let bit_pos = self.word.trailing_zeros() as usize;\n+                let bit = 1 << bit_pos;\n+                self.word ^= bit;\n+                return Some(T::new(bit_pos + self.offset))\n             }\n \n-            let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, WORD_BITS * i));\n+            // Move onto the next word. `wrapping_add()` is needed to handle\n+            // the degenerate initial value given to `offset` in `new()`.\n+            let word = self.iter.next()?;\n+            self.word = *word;\n+            self.offset = self.offset.wrapping_add(WORD_BITS);\n         }\n     }\n }\n@@ -851,11 +879,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn iter(&self, row: R) -> BitIter<'_, C> {\n         assert!(row.index() < self.num_rows);\n         let (start, end) = self.range(row);\n-        BitIter {\n-            cur: None,\n-            iter: self.words[start..end].iter().enumerate(),\n-            marker: PhantomData,\n-        }\n+        BitIter::new(&self.words[start..end])\n     }\n \n     /// Returns the number of elements in `row`."}, {"sha": "7a0d931ca732ae159a0e721857934fd1df0c80d9", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -11,10 +11,11 @@ doctest = false\n \n [dependencies]\n log = \"0.4\"\n-rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n+rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n+syntax_expand = { path = \"../libsyntax_expand\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc = { path = \"../librustc\" }"}, {"sha": "b26bd75c974c6b67edae5cdc985ab475cf77d484", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,5 @@\n use crate::queries::Queries;\n use crate::util;\n-use crate::profile;\n pub use crate::passes::BoxedResolver;\n \n use rustc::lint;\n@@ -115,17 +114,7 @@ where\n         compiler.sess.diagnostic().print_error_count(&util::diagnostics_registry());\n     });\n \n-    if compiler.sess.profile_queries() {\n-        profile::begin(&compiler.sess);\n-    }\n-\n-    let r = f(&compiler);\n-\n-    if compiler.sess.profile_queries() {\n-        profile::dump(&compiler.sess, \"profile_queries\".to_string())\n-    }\n-\n-    r\n+    f(&compiler)\n }\n \n pub fn run_compiler<F, R>(mut config: Config, f: F) -> R"}, {"sha": "6be36e9b9001b80d608950547b3b07a7f7b865ad", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -16,6 +16,5 @@ mod passes;\n mod queries;\n pub mod util;\n mod proc_macro_decls;\n-mod profile;\n \n pub use interface::{run_compiler, Config};"}, {"sha": "89de5714695defea27ec132cf48446c9fc5d7259", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -35,7 +35,7 @@ use rustc_traits;\n use rustc_typeck as typeck;\n use syntax::{self, ast, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n-use syntax::ext::base::{NamedSyntaxExtension, ExtCtxt};\n+use syntax_expand::base::{NamedSyntaxExtension, ExtCtxt};\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n@@ -130,15 +130,15 @@ pub fn configure_and_expand(\n     let crate_name = crate_name.to_string();\n     let (result, resolver) = BoxedResolver::new(static move || {\n         let sess = &*sess;\n-        let mut crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n+        let crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n             sess,\n             &*cstore,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &mut crate_loader,\n+            &crate_loader,\n             plugin_info,\n         );\n         let mut resolver = match res {\n@@ -169,6 +169,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions),\n             resolutions: Steal::new(Resolutions {\n+                extern_crate_map: resolver.extern_crate_map,\n                 export_map: resolver.export_map,\n                 trait_map: resolver.trait_map,\n                 glob_map: resolver.glob_map,\n@@ -187,6 +188,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions.clone()),\n             resolutions: Steal::new(Resolutions {\n+                extern_crate_map: resolver.extern_crate_map.clone(),\n                 export_map: resolver.export_map.clone(),\n                 trait_map: resolver.trait_map.clone(),\n                 glob_map: resolver.glob_map.clone(),\n@@ -250,6 +252,8 @@ pub fn register_plugins<'a>(\n \n     if sess.opts.incremental.is_some() {\n         time(sess, \"garbage-collect incremental cache directory\", || {\n+            let _prof_timer =\n+                sess.prof.generic_activity(\"incr_comp_garbage_collect_session_directories\");\n             if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n                 warn!(\n                     \"Error while trying to garbage collect incremental \\\n@@ -317,7 +321,7 @@ fn configure_and_expand_inner<'a>(\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    crate_loader: &'a mut CrateLoader<'a>,\n+    crate_loader: &'a CrateLoader<'a>,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n@@ -393,12 +397,12 @@ fn configure_and_expand_inner<'a>(\n \n         // Create the config for macro expansion\n         let features = sess.features_untracked();\n-        let cfg = syntax::ext::expand::ExpansionConfig {\n+        let cfg = syntax_expand::expand::ExpansionConfig {\n             features: Some(&features),\n             recursion_limit: *sess.recursion_limit.get(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n-            ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n+            ..syntax_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n         let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n@@ -539,7 +543,8 @@ pub fn lower_to_hir(\n ) -> Result<hir::map::Forest> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n-        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver);\n+        let nt_to_tokenstream = syntax::parse::nt_to_tokenstream;\n+        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver, nt_to_tokenstream);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);\n@@ -554,7 +559,7 @@ pub fn lower_to_hir(\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !sess.opts.debugging_opts.keep_hygiene_data {\n-        syntax::ext::hygiene::clear_syntax_context_map();\n+        syntax_expand::hygiene::clear_syntax_context_map();\n     }\n \n     Ok(hir_forest)\n@@ -660,16 +665,15 @@ fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames:\n \n         if sess.binary_dep_depinfo() {\n             for cnum in compiler.cstore.crates_untracked() {\n-                let metadata = compiler.cstore.crate_data_as_rc_any(cnum);\n-                let metadata = metadata.downcast_ref::<cstore::CrateMetadata>().unwrap();\n-                if let Some((path, _)) = &metadata.source.dylib {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                let source = compiler.cstore.crate_source_untracked(cnum);\n+                if let Some((path, _)) = source.dylib {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n-                if let Some((path, _)) = &metadata.source.rlib {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                if let Some((path, _)) = source.rlib {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n-                if let Some((path, _)) = &metadata.source.rmeta {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                if let Some((path, _)) = source.rmeta {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n             }\n         }\n@@ -780,20 +784,20 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     ty::provide(providers);\n     traits::provide(providers);\n     stability::provide(providers);\n-    middle::intrinsicck::provide(providers);\n-    middle::liveness::provide(providers);\n     reachable::provide(providers);\n     rustc_passes::provide(providers);\n     rustc_traits::provide(providers);\n     middle::region::provide(providers);\n-    middle::entry::provide(providers);\n     cstore::provide(providers);\n     lint::provide(providers);\n     rustc_lint::provide(providers);\n+    rustc_codegen_utils::provide(providers);\n+    rustc_codegen_ssa::provide(providers);\n }\n \n pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n     cstore::provide_extern(providers);\n+    rustc_codegen_ssa::provide_extern(providers);\n }\n \n declare_box_region_type!(\n@@ -892,7 +896,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     time(sess, \"misc checking 1\", || {\n         parallel!({\n             entry_point = time(sess, \"looking for entry point\", || {\n-                middle::entry::find_entry_point(tcx)\n+                rustc_passes::entry::find_entry_point(tcx)\n             });\n \n             time(sess, \"looking for plugin registrar\", || {\n@@ -973,7 +977,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     tcx.ensure().check_private_in_public(LOCAL_CRATE);\n                 });\n             }, {\n-                time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n+                time(sess, \"death checking\", || rustc_passes::dead::check_crate(tcx));\n             },  {\n                 time(sess, \"unused lib feature checking\", || {\n                     stability::check_unused_or_stable_features(tcx)"}, {"sha": "2e71d46f4154c6384c5f1a0768df2761b0ba0be6", "filename": "src/librustc_interface/profile/mod.rs", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Fmod.rs?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,297 +0,0 @@\n-use log::debug;\n-use rustc::dep_graph::DepNode;\n-use rustc::session::Session;\n-use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n-use std::sync::mpsc::{Receiver};\n-use std::io::{Write};\n-use std::time::{Duration, Instant};\n-\n-pub mod trace;\n-\n-/// begin a profile thread, if not already running\n-pub fn begin(sess: &Session) {\n-    use std::thread;\n-    use std::sync::mpsc::{channel};\n-    let (tx, rx) = channel();\n-    if profq_set_chan(sess, tx) {\n-        thread::spawn(move || profile_queries_thread(rx));\n-    }\n-}\n-\n-/// dump files with profiling information to the given base path, and\n-/// wait for this dump to complete.\n-///\n-/// wraps the RPC (send/recv channel logic) of requesting a dump.\n-pub fn dump(sess: &Session, path: String) {\n-    use std::sync::mpsc::{channel};\n-    let (tx, rx) = channel();\n-    let params = ProfQDumpParams {\n-        path,\n-        ack: tx,\n-        // FIXME: Add another compiler flag to toggle whether this log\n-        // is written; false for now\n-        dump_profq_msg_log: true,\n-    };\n-    profq_msg(sess, ProfileQueriesMsg::Dump(params));\n-    let _ = rx.recv().unwrap();\n-}\n-\n-// State for parsing recursive trace structure in separate thread, via messages\n-#[derive(Clone, Eq, PartialEq)]\n-enum ParseState {\n-    // No (local) parse state; may be parsing a tree, focused on a\n-    // sub-tree that could be anything.\n-    Clear,\n-    // Have Query information from the last message\n-    HaveQuery(trace::Query, Instant),\n-    // Have \"time-begin\" information from the last message (doit flag, and message)\n-    HaveTimeBegin(String, Instant),\n-    // Have \"task-begin\" information from the last message\n-    HaveTaskBegin(DepNode, Instant),\n-}\n-struct StackFrame {\n-    pub parse_st: ParseState,\n-    pub traces:   Vec<trace::Rec>,\n-}\n-\n-fn total_duration(traces: &[trace::Rec]) -> Duration {\n-    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n-}\n-\n-// profiling thread; retains state (in local variables) and dump traces, upon request.\n-fn profile_queries_thread(r: Receiver<ProfileQueriesMsg>) {\n-    use self::trace::*;\n-    use std::fs::File;\n-\n-    let mut profq_msgs: Vec<ProfileQueriesMsg> = vec![];\n-    let mut frame: StackFrame = StackFrame { parse_st: ParseState::Clear, traces: vec![] };\n-    let mut stack: Vec<StackFrame> = vec![];\n-    loop {\n-        let msg = r.recv();\n-        if let Err(_recv_err) = msg {\n-            // FIXME: Perhaps do something smarter than simply quitting?\n-            break\n-        };\n-        let msg = msg.unwrap();\n-        debug!(\"profile_queries_thread: {:?}\", msg);\n-\n-        // Meta-level versus _actual_ queries messages\n-        match msg {\n-            ProfileQueriesMsg::Halt => return,\n-            ProfileQueriesMsg::Dump(params) => {\n-                assert!(stack.is_empty());\n-                assert!(frame.parse_st == ParseState::Clear);\n-\n-                // write log of all messages\n-                if params.dump_profq_msg_log {\n-                    let mut log_file =\n-                        File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n-                    for m in profq_msgs.iter() {\n-                        writeln!(&mut log_file, \"{:?}\", m).unwrap()\n-                    };\n-                }\n-\n-                // write HTML file, and counts file\n-                let html_path = format!(\"{}.html\", params.path);\n-                let mut html_file = File::create(&html_path).unwrap();\n-\n-                let counts_path = format!(\"{}.counts.txt\", params.path);\n-                let mut counts_file = File::create(&counts_path).unwrap();\n-\n-                writeln!(html_file,\n-                    \"<html>\\n<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\",\n-                    \"profile_queries.css\").unwrap();\n-                writeln!(html_file, \"<style>\").unwrap();\n-                trace::write_style(&mut html_file);\n-                writeln!(html_file, \"</style>\\n</head>\\n<body>\").unwrap();\n-                trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n-                writeln!(html_file, \"</body>\\n</html>\").unwrap();\n-\n-                let ack_path = format!(\"{}.ack\", params.path);\n-                let ack_file = File::create(&ack_path).unwrap();\n-                drop(ack_file);\n-\n-                // Tell main thread that we are done, e.g., so it can exit\n-                params.ack.send(()).unwrap();\n-            }\n-            // Actual query message:\n-            msg => {\n-                // Record msg in our log\n-                profq_msgs.push(msg.clone());\n-                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n-                match (frame.parse_st.clone(), msg) {\n-                    (_, ProfileQueriesMsg::Halt) | (_, ProfileQueriesMsg::Dump(_)) => {\n-                        unreachable!();\n-                    },\n-                    // Parse State: Clear\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::QueryBegin(span, querymsg)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveQuery\n-                            (Query { span, msg: querymsg }, start)\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::CacheHit) => {\n-                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::ProviderBegin) => {\n-                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::ProviderEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveQuery(q, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_self: duration - dur_extent,\n-                                            dur_total: duration,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TimeBegin(msg)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n-                        stack.push(frame);\n-                        frame = StackFrame{parse_st: ParseState::Clear, traces: vec![]};\n-                    },\n-                    (_, ProfileQueriesMsg::TimeBegin(_)) => {\n-                        panic!(\"parse error; did not expect time begin here\");\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TimeEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveTimeBegin(msg, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::TimeBegin(msg),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_total: duration,\n-                                            dur_self: duration - dur_extent,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (_, ProfileQueriesMsg::TimeEnd) => {\n-                        panic!(\"parse error\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TaskBegin(key)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveTaskBegin(key, start);\n-                        stack.push(frame);\n-                        frame = StackFrame{ parse_st: ParseState::Clear, traces: vec![] };\n-                    },\n-                    (_, ProfileQueriesMsg::TaskBegin(_)) => {\n-                        panic!(\"parse error; did not expect time begin here\");\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TaskEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveTaskBegin(key, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::TaskBegin(key),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_total: duration,\n-                                            dur_self: duration - dur_extent,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (_, ProfileQueriesMsg::TaskEnd) => {\n-                        panic!(\"parse error\")\n-                    },\n-                    // Parse State: HaveQuery\n-                    (ParseState::HaveQuery(q,start),\n-                     ProfileQueriesMsg::CacheHit) => {\n-                        let duration = start.elapsed();\n-                        let trace : Rec = Rec{\n-                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n-                            extent: Box::new(vec![]),\n-                            start: start,\n-                            dur_self: duration,\n-                            dur_total: duration,\n-                        };\n-                        frame.traces.push( trace );\n-                        frame.parse_st = ParseState::Clear;\n-                    },\n-                    (ParseState::HaveQuery(_, _),\n-                     ProfileQueriesMsg::ProviderBegin) => {\n-                        stack.push(frame);\n-                        frame = StackFrame{ parse_st: ParseState::Clear, traces: vec![] };\n-                    },\n-\n-                    // Parse errors:\n-\n-                    (ParseState::HaveQuery(q, _),\n-                     ProfileQueriesMsg::ProviderEnd) => {\n-                        panic!(\"parse error: unexpected ProviderEnd; \\\n-                                expected something else to follow BeginQuery for {:?}\", q)\n-                    },\n-                    (ParseState::HaveQuery(q1, _),\n-                     ProfileQueriesMsg::QueryBegin(span2, querymsg2)) => {\n-                        panic!(\"parse error: unexpected QueryBegin; \\\n-                                earlier query is unfinished: {:?} and now {:?}\",\n-                               q1, Query{span:span2, msg: querymsg2})\n-                    },\n-                    (ParseState::HaveTimeBegin(_, _), _) => {\n-                        unreachable!()\n-                    },\n-                    (ParseState::HaveTaskBegin(_, _), _) => {\n-                        unreachable!()\n-                    },\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "95c4ea6ff23478ffd6868c06238be7d7e94d5190", "filename": "src/librustc_interface/profile/trace.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,304 +0,0 @@\n-use super::*;\n-use syntax_pos::SpanData;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc::util::common::QueryMsg;\n-use std::fs::File;\n-use std::time::{Duration, Instant};\n-use rustc::dep_graph::{DepNode};\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct Query {\n-    pub span: SpanData,\n-    pub msg: QueryMsg,\n-}\n-pub enum Effect {\n-    QueryBegin(Query, CacheCase),\n-    TimeBegin(String),\n-    TaskBegin(DepNode),\n-}\n-pub enum CacheCase {\n-    Hit, Miss\n-}\n-/// Recursive trace structure\n-pub struct Rec {\n-    pub effect: Effect,\n-    pub start: Instant,\n-    pub dur_self: Duration,\n-    pub dur_total: Duration,\n-    pub extent: Box<Vec<Rec>>,\n-}\n-pub struct QueryMetric {\n-    pub count: usize,\n-    pub dur_self: Duration,\n-    pub dur_total: Duration,\n-}\n-\n-fn cons(s: &str) -> String {\n-    let first = s.split(|d| d == '(' || d == '{').next();\n-    assert!(first.is_some() && first != Some(\"\"));\n-    first.unwrap().to_owned()\n-}\n-\n-pub fn cons_of_query_msg(q: &trace::Query) -> String {\n-    cons(&format!(\"{:?}\", q.msg))\n-}\n-\n-pub fn cons_of_key(k: &DepNode) -> String {\n-    cons(&format!(\"{:?}\", k))\n-}\n-\n-// First return value is text; second return value is a CSS class\n-pub fn html_of_effect(eff: &Effect) -> (String, String) {\n-    match *eff {\n-        Effect::TimeBegin(ref msg) => {\n-            (msg.clone(),\n-             \"time-begin\".to_string())\n-        },\n-        Effect::TaskBegin(ref key) => {\n-            let cons = cons_of_key(key);\n-            (cons.clone(), format!(\"{} task-begin\", cons))\n-        },\n-        Effect::QueryBegin(ref qmsg, ref cc) => {\n-            let cons = cons_of_query_msg(qmsg);\n-            (cons.clone(),\n-             format!(\"{} {}\",\n-                     cons,\n-                     match *cc {\n-                         CacheCase::Hit => \"hit\",\n-                         CacheCase::Miss => \"miss\",\n-                     }))\n-        }\n-    }\n-}\n-\n-// First return value is text; second return value is a CSS class\n-fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n-    use rustc::util::common::duration_to_secs_str;\n-    (duration_to_secs_str(dur.clone()), String::new())\n-}\n-\n-fn html_of_fraction(frac: f64) -> (String, &'static str) {\n-    let css = {\n-        if       frac > 0.50  { \"frac-50\" }\n-        else if  frac > 0.40  { \"frac-40\" }\n-        else if  frac > 0.30  { \"frac-30\" }\n-        else if  frac > 0.20  { \"frac-20\" }\n-        else if  frac > 0.10  { \"frac-10\" }\n-        else if  frac > 0.05  { \"frac-05\" }\n-        else if  frac > 0.02  { \"frac-02\" }\n-        else if  frac > 0.01  { \"frac-01\" }\n-        else if  frac > 0.001 { \"frac-001\" }\n-        else                  { \"frac-0\" }\n-    };\n-    let percent = frac * 100.0;\n-\n-    if percent > 0.1 {\n-        (format!(\"{:.1}%\", percent), css)\n-    } else {\n-        (\"< 0.1%\".to_string(), css)\n-    }\n-}\n-\n-fn total_duration(traces: &[Rec]) -> Duration {\n-    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n-}\n-\n-fn duration_div(nom: Duration, den: Duration) -> f64 {\n-    fn to_nanos(d: Duration) -> u64 {\n-        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n-    }\n-\n-    to_nanos(nom) as f64 / to_nanos(den) as f64\n-}\n-\n-fn write_traces_rec(file: &mut File, traces: &[Rec], total: Duration, depth: usize) {\n-    for t in traces {\n-        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n-        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.dur_total);\n-        let fraction = duration_div(t.dur_total, total);\n-        let percent = fraction * 100.0;\n-        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n-        writeln!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\",\n-                 depth,\n-                 t.extent.len(),\n-                 /* Heuristic for 'important' CSS class: */\n-                 if t.extent.len() > 5 || percent >= 1.0 { \" important\" } else { \"\" },\n-                 eff_css_classes,\n-                 dur_css_classes,\n-                 frc_css_classes,\n-        ).unwrap();\n-        writeln!(file, \"<div class=\\\"eff\\\">{}</div>\", eff_text).unwrap();\n-        writeln!(file, \"<div class=\\\"dur\\\">{}</div>\", dur_text).unwrap();\n-        writeln!(file, \"<div class=\\\"frc\\\">{}</div>\", frc_text).unwrap();\n-        write_traces_rec(file, &t.extent, total, depth + 1);\n-        writeln!(file, \"</div>\").unwrap();\n-    }\n-}\n-\n-fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]) {\n-    counts.reserve(traces.len());\n-    for t in traces.iter() {\n-        match t.effect {\n-            Effect::TimeBegin(ref msg) => {\n-                let qm = match counts.get(msg) {\n-                    Some(_qm) => panic!(\"TimeBegin with non-unique, repeat message\"),\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_self: t.dur_self,\n-                        dur_total: t.dur_total,\n-                    }\n-                };\n-                counts.insert(msg.clone(), qm);\n-            },\n-            Effect::TaskBegin(ref key) => {\n-                let cons = cons_of_key(key);\n-                let qm = match counts.get(&cons) {\n-                    Some(qm) =>\n-                        QueryMetric {\n-                            count: qm.count + 1,\n-                            dur_self: qm.dur_self + t.dur_self,\n-                            dur_total: qm.dur_total + t.dur_total,\n-                        },\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_self: t.dur_self,\n-                        dur_total: t.dur_total,\n-                    }\n-                };\n-                counts.insert(cons, qm);\n-            },\n-            Effect::QueryBegin(ref qmsg, ref _cc) => {\n-                let qcons = cons_of_query_msg(qmsg);\n-                let qm = match counts.get(&qcons) {\n-                    Some(qm) =>\n-                        QueryMetric {\n-                            count: qm.count + 1,\n-                            dur_total: qm.dur_total + t.dur_total,\n-                            dur_self: qm.dur_self + t.dur_self\n-                        },\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_total: t.dur_total,\n-                        dur_self: t.dur_self,\n-                    }\n-                };\n-                counts.insert(qcons, qm);\n-            }\n-        }\n-        compute_counts_rec(counts, &t.extent)\n-    }\n-}\n-\n-pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String, QueryMetric>) {\n-    use rustc::util::common::duration_to_secs_str;\n-    use std::cmp::Reverse;\n-\n-    let mut data = counts.iter().map(|(ref cons, ref qm)|\n-        (cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone())\n-    ).collect::<Vec<_>>();\n-\n-    data.sort_by_key(|k| Reverse(k.3));\n-    for (cons, count, dur_total, dur_self) in data {\n-        writeln!(count_file, \"{}, {}, {}, {}\",\n-                 cons, count,\n-                 duration_to_secs_str(dur_total),\n-                 duration_to_secs_str(dur_self)\n-        ).unwrap();\n-    }\n-}\n-\n-pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &[Rec]) {\n-    let capacity = traces.iter().fold(0, |acc, t| acc + 1 + t.extent.len());\n-    let mut counts = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n-    compute_counts_rec(&mut counts, traces);\n-    write_counts(counts_file, &mut counts);\n-\n-    let total: Duration = total_duration(traces);\n-    write_traces_rec(html_file, traces, total, 0)\n-}\n-\n-pub fn write_style(html_file: &mut File) {\n-    write!(html_file, \"{}\", \"\n-body {\n-    font-family: sans-serif;\n-    background: black;\n-}\n-.trace {\n-    color: black;\n-    display: inline-block;\n-    border-style: solid;\n-    border-color: red;\n-    border-width: 1px;\n-    border-radius: 5px;\n-    padding: 0px;\n-    margin: 1px;\n-    font-size: 0px;\n-}\n-.task-begin {\n-    border-width: 1px;\n-    color: white;\n-    border-color: #ff8;\n-    font-size: 0px;\n-}\n-.miss {\n-    border-color: red;\n-    border-width: 1px;\n-}\n-.extent-0 {\n-    padding: 2px;\n-}\n-.time-begin {\n-    border-width: 4px;\n-    font-size: 12px;\n-    color: white;\n-    border-color: #afa;\n-}\n-.important {\n-    border-width: 3px;\n-    font-size: 12px;\n-    color: white;\n-    border-color: #f77;\n-}\n-.hit {\n-    padding: 0px;\n-    border-color: blue;\n-    border-width: 3px;\n-}\n-.eff {\n-  color: #fff;\n-  display: inline-block;\n-}\n-.frc {\n-  color: #7f7;\n-  display: inline-block;\n-}\n-.dur {\n-  display: none\n-}\n-.frac-50 {\n-  padding: 10px;\n-  border-width: 10px;\n-  font-size: 32px;\n-}\n-.frac-40 {\n-  padding: 8px;\n-  border-width: 8px;\n-  font-size: 24px;\n-}\n-.frac-30 {\n-  padding: 6px;\n-  border-width: 6px;\n-  font-size: 18px;\n-}\n-.frac-20 {\n-  padding: 4px;\n-  border-width: 6px;\n-  font-size: 16px;\n-}\n-.frac-10 {\n-  padding: 2px;\n-  border-width: 6px;\n-  font-size: 14px;\n-}\n-\").unwrap();\n-}"}, {"sha": "0c272f0c4563b01b5dbb01125bfdecf7c8c8556b", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -202,11 +202,12 @@ pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n ) -> R {\n-    use rayon::{ThreadPool, ThreadPoolBuilder};\n+    use rayon::{ThreadBuilder, ThreadPool, ThreadPoolBuilder};\n \n     let gcx_ptr = &Lock::new(0);\n \n     let mut config = ThreadPoolBuilder::new()\n+        .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n         .release_thread_handler(jobserver::release_thread)\n         .num_threads(threads)\n@@ -225,20 +226,20 @@ pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n                 // the thread local rustc uses. syntax_globals and syntax_pos_globals are\n                 // captured and set on the new threads. ty::tls::with_thread_locals sets up\n                 // thread local callbacks from libsyntax\n-                let main_handler = move |worker: &mut dyn FnMut()| {\n+                let main_handler = move |thread: ThreadBuilder| {\n                     syntax::GLOBALS.set(syntax_globals, || {\n                         syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n                             if let Some(stderr) = stderr {\n                                 io::set_panic(Some(box Sink(stderr.clone())));\n                             }\n                             ty::tls::with_thread_locals(|| {\n-                                ty::tls::GCX_PTR.set(gcx_ptr, || worker())\n+                                ty::tls::GCX_PTR.set(gcx_ptr, || thread.run())\n                             })\n                         })\n                     })\n                 };\n \n-                ThreadPool::scoped_pool(config, main_handler, with_pool).unwrap()\n+                config.build_scoped(main_handler, with_pool).unwrap()\n             })\n         })\n     })"}, {"sha": "08f6f43ab0cff4831c94c6b421c4e03d97928188", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -45,7 +45,7 @@ use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n-use syntax::print::pprust::expr_to_string;\n+use syntax::print::pprust::{self, expr_to_string};\n use syntax::visit::FnKind;\n \n use rustc::hir::{self, GenericParamKind, PatKind};\n@@ -701,7 +701,8 @@ impl EarlyLintPass for DeprecatedAttr {\n             }\n         }\n         if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n-            let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", attr.path);\n+            let path_str = pprust::path_to_string(&attr.path);\n+            let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n         }\n     }\n@@ -1240,7 +1241,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n-            for &(predicate, span) in &predicates.predicates {\n+            for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |"}, {"sha": "2edc8fadf45684dae76eb1bce80429c4b97e548a", "filename": "src/librustc_lint/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,4 +1,4 @@\n syntax::register_diagnostics! {\n ;\n-    E0721, // `await` keyword\n+//  E0721, // `await` keyword\n }"}, {"sha": "e3860e229d6b5d4b89960a3e0fc87160baf372e4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -255,6 +255,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_MUT,\n                     UNREACHABLE_CODE,\n                     UNREACHABLE_PATTERNS,\n+                    OVERLAPPING_PATTERNS,\n                     UNUSED_MUST_USE,\n                     UNUSED_UNSAFE,\n                     PATH_STATEMENTS,"}, {"sha": "aa6dfa50dddf3030267ec8325078545196ae0296", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -631,6 +631,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             };\n                         }\n \n+                        let is_non_exhaustive =\n+                            def.non_enum_variant().is_field_list_non_exhaustive();\n+                        if is_non_exhaustive && !def.did.is_local() {\n+                            return FfiUnsafe {\n+                                ty,\n+                                reason: \"this struct is non-exhaustive\",\n+                                help: None,\n+                            };\n+                        }\n+\n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n                                 ty,\n@@ -730,8 +740,25 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             }\n                         }\n \n+                        if def.is_variant_list_non_exhaustive() && !def.did.is_local() {\n+                            return FfiUnsafe {\n+                                ty,\n+                                reason: \"this enum is non-exhaustive\",\n+                                help: None,\n+                            };\n+                        }\n+\n                         // Check the contained variants.\n                         for variant in &def.variants {\n+                            let is_non_exhaustive = variant.is_field_list_non_exhaustive();\n+                            if is_non_exhaustive && !variant.def_id.is_local() {\n+                                return FfiUnsafe {\n+                                    ty,\n+                                    reason: \"this enum has non-exhaustive variants\",\n+                                    help: None,\n+                                };\n+                            }\n+\n                             for field in &variant.fields {\n                                 let field_ty = cx.normalize_erasing_regions(\n                                     ParamEnv::reveal_all(),"}, {"sha": "a93946df68f9235d484b50da6fae287bada285ab", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 }\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n-                    for (predicate, _) in &cx.tcx.predicates_of(def).predicates {\n+                    for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n                         if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;"}, {"sha": "c28fcb1a395ff999d2637908c08b8667ea3a164d", "filename": "src/librustc_macros/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -8,8 +8,8 @@ edition = \"2018\"\n proc-macro = true\n \n [dependencies]\n-synstructure = \"0.10.2\"\n-syn = { version = \"0.15.22\", features = [\"full\"] }\n-proc-macro2 = \"0.4.24\"\n-quote = \"0.6.10\"\n+synstructure = \"0.12.1\"\n+syn = { version = \"1\", features = [\"full\"] }\n+proc-macro2 = \"1\"\n+quote = \"1\"\n itertools = \"0.8\""}, {"sha": "735cfb11b365c4876c7d8720a98183a32ea5c734", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -15,22 +15,22 @@ fn parse_attributes(field: &syn::Field) -> Attributes {\n     };\n     for attr in &field.attrs {\n         if let Ok(meta) = attr.parse_meta() {\n-            if &meta.name().to_string() != \"stable_hasher\" {\n+            if !meta.path().is_ident(\"stable_hasher\") {\n                 continue;\n             }\n             let mut any_attr = false;\n             if let Meta::List(list) = meta {\n                 for nested in list.nested.iter() {\n                     if let NestedMeta::Meta(meta) = nested {\n-                        if &meta.name().to_string() == \"ignore\" {\n+                        if meta.path().is_ident(\"ignore\") {\n                             attrs.ignore = true;\n                             any_attr = true;\n                         }\n-                        if &meta.name().to_string() == \"project\" {\n+                        if meta.path().is_ident(\"project\") {\n                             if let Meta::List(list) = meta {\n                                 if let Some(nested) = list.nested.iter().next() {\n                                     if let NestedMeta::Meta(meta) = nested {\n-                                        attrs.project = Some(meta.name());\n+                                        attrs.project = meta.path().get_ident().cloned();\n                                         any_attr = true;\n                                     }\n                                 }"}, {"sha": "139e1b554cf90a2597a6ec606404b8034b3ceba0", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -495,7 +495,11 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 dep_node_force_stream.extend(quote! {\n                     DepKind::#name => {\n                         if let Some(key) = RecoverKey::recover($tcx, $dep_node) {\n-                            force_ex!($tcx, #name, key);\n+                            $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n+                                key,\n+                                DUMMY_SP,\n+                                *$dep_node\n+                            );\n                         } else {\n                             return false;\n                         }"}, {"sha": "18192e35f8a209fc240618799811199174936ef9", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -22,4 +22,5 @@ rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n stable_deref_trait = \"1.0.0\"\n syntax = { path = \"../libsyntax\" }\n+syntax_expand = { path = \"../libsyntax_expand\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "6a2da5d49887d3f8da42968f946ed73a3559f5af", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 38, "deletions": 57, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,19 +1,20 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n+use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n+use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n+use rustc::dep_graph::DepNodeIndex;\n use rustc::middle::cstore::DepKind;\n use rustc::mir::interpret::AllocDecodingState;\n use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{ExternCrate, ExternCrateSource};\n+use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n@@ -25,22 +26,20 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n+use syntax_expand::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n \n-pub struct Library {\n-    pub dylib: Option<(PathBuf, PathKind)>,\n-    pub rlib: Option<(PathBuf, PathKind)>,\n-    pub rmeta: Option<(PathBuf, PathKind)>,\n+crate struct Library {\n+    pub source: CrateSource,\n     pub metadata: MetadataBlob,\n }\n \n pub struct CrateLoader<'a> {\n-    pub sess: &'a Session,\n+    sess: &'a Session,\n     cstore: &'a CStore,\n     local_crate_name: Symbol,\n }\n@@ -188,15 +187,18 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn register_crate(\n-        &mut self,\n+        &self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol\n     ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n-        let crate_root = lib.metadata.get_root();\n+        let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n+\n+        let Library { source, metadata } = lib;\n+        let crate_root = metadata.get_root();\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n         let private_dep = self.sess.opts.externs.get(&name.as_str())\n@@ -214,28 +216,22 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths {\n-                ident: crate_root.name.to_string(),\n-                dylib: lib.dylib.clone().map(|p| p.0),\n-                rlib:  lib.rlib.clone().map(|p| p.0),\n-                rmeta: lib.rmeta.clone().map(|p| p.0),\n-            };\n+            crate_paths = CratePaths { name: crate_root.name, source: source.clone() };\n             &crate_paths\n         };\n \n-        let Library { dylib, rlib, rmeta, metadata } = lib;\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             let temp_root;\n-            let (dlsym_dylib, dlsym_root) = match &host_lib {\n+            let (dlsym_source, dlsym_root) = match &host_lib {\n                 Some(host_lib) =>\n-                    (&host_lib.dylib, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n-                None => (&dylib, &crate_root),\n+                    (&host_lib.source, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n+                None => (&source, &crate_root),\n             };\n-            let dlsym_dylib = dlsym_dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n+            let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n             self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n         });\n \n@@ -264,14 +260,10 @@ impl<'a> CrateLoader<'a> {\n             source_map_import_info: RwLock::new(vec![]),\n             alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n-            source: cstore::CrateSource {\n-                dylib,\n-                rlib,\n-                rmeta,\n-            },\n+            source,\n             private_dep,\n-            span,\n-            raw_proc_macros\n+            raw_proc_macros,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -280,7 +272,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn load_proc_macro<'b>(\n-        &mut self,\n+        &self,\n         locate_ctxt: &mut locator::Context<'b>,\n         path_kind: PathKind,\n     ) -> Option<(LoadResult, Option<Library>)>\n@@ -335,7 +327,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn resolve_crate<'b>(\n-        &'b mut self,\n+        &'b self,\n         name: Symbol,\n         span: Span,\n         dep_kind: DepKind,\n@@ -345,7 +337,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn maybe_resolve_crate<'b>(\n-        &'b mut self,\n+        &'b self,\n         name: Symbol,\n         span: Span,\n         mut dep_kind: DepKind,\n@@ -405,7 +397,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn load(&mut self, locate_ctxt: &mut locator::Context<'_>) -> Option<LoadResult> {\n+    fn load(&self, locate_ctxt: &mut locator::Context<'_>) -> Option<LoadResult> {\n         let library = locate_ctxt.maybe_load_library_crate()?;\n \n         // In the case that we're loading a crate, but not matching\n@@ -432,7 +424,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn update_extern_crate(&mut self,\n+    fn update_extern_crate(&self,\n                            cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n                            visited: &mut FxHashSet<(CrateNum, bool)>)\n@@ -474,7 +466,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     // Go through the crate metadata and load any crates that it references\n-    fn resolve_crate_deps(&mut self,\n+    fn resolve_crate_deps(&self,\n                           root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n@@ -504,7 +496,7 @@ impl<'a> CrateLoader<'a> {\n         })).collect()\n     }\n \n-    fn read_extension_crate(&mut self, name: Symbol, span: Span) -> ExtensionCrate {\n+    fn read_extension_crate(&self, name: Symbol, span: Span) -> ExtensionCrate {\n         info!(\"read extension crate `{}`\", name);\n         let target_triple = self.sess.opts.target_triple.clone();\n         let host_triple = TargetTriple::from_triple(config::host_triple());\n@@ -554,7 +546,7 @@ impl<'a> CrateLoader<'a> {\n                 (data.source.dylib.clone(), PMDSource::Registered(data))\n             }\n             LoadResult::Loaded(library) => {\n-                let dylib = library.dylib.clone();\n+                let dylib = library.source.dylib.clone();\n                 let metadata = PMDSource::Owned(library);\n                 (dylib, metadata)\n             }\n@@ -600,7 +592,7 @@ impl<'a> CrateLoader<'a> {\n \n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&mut self,\n+    pub fn find_plugin_registrar(&self,\n                                  span: Span,\n                                  name: Symbol)\n                                  -> Option<(PathBuf, CrateDisambiguator)> {\n@@ -633,7 +625,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n+    fn inject_panic_runtime(&self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n         let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| {\n@@ -714,7 +706,7 @@ impl<'a> CrateLoader<'a> {\n                                   &|data| data.root.needs_panic_runtime);\n     }\n \n-    fn inject_sanitizer_runtime(&mut self) {\n+    fn inject_sanitizer_runtime(&self) {\n         if let Some(ref sanitizer) = self.sess.opts.debugging_opts.sanitizer {\n             // Sanitizers can only be used on some tested platforms with\n             // executables linked to `std`\n@@ -812,7 +804,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_profiler_runtime(&mut self) {\n+    fn inject_profiler_runtime(&self) {\n         if self.sess.opts.debugging_opts.profile ||\n            self.sess.opts.cg.profile_generate.enabled()\n         {\n@@ -829,7 +821,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n+    fn inject_allocator_crate(&self, krate: &ast::Crate) {\n         let has_global_allocator = match &*global_allocator_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess.struct_span_err(*span2, \"cannot define multiple global allocators\")\n@@ -968,7 +960,7 @@ impl<'a> CrateLoader<'a> {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn postprocess(&mut self, krate: &ast::Crate) {\n+    pub fn postprocess(&self, krate: &ast::Crate) {\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);\n@@ -979,9 +971,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_extern_crate(\n-        &mut self, item: &ast::Item, definitions: &Definitions,\n-    ) -> CrateNum {\n+    pub fn process_extern_crate(&self, item: &ast::Item, definitions: &Definitions) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n@@ -1014,18 +1004,13 @@ impl<'a> CrateLoader<'a> {\n                     },\n                     &mut FxHashSet::default(),\n                 );\n-                self.cstore.add_extern_mod_stmt_cnum(item.id, cnum);\n                 cnum\n             }\n             _ => bug!(),\n         }\n     }\n \n-    pub fn process_path_extern(\n-        &mut self,\n-        name: Symbol,\n-        span: Span,\n-    ) -> CrateNum {\n+    pub fn process_path_extern(&self, name: Symbol, span: Span) -> CrateNum {\n         let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n \n         self.update_extern_crate(\n@@ -1043,11 +1028,7 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(\n-        &mut self,\n-        name: Symbol,\n-        span: Span,\n-    ) -> Option<CrateNum> {\n+    pub fn maybe_process_path_extern(&self, name: Symbol, span: Span) -> Option<CrateNum> {\n         let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n \n         self.update_extern_crate("}, {"sha": "9a0b98ffb73a9af45bf2a1231256ef0b6042630a", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 61, "deletions": 65, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -2,39 +2,32 @@\n // crates and libraries\n \n use crate::schema;\n+use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n+use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate, MetadataLoader};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n-use rustc::util::nodemap::{FxHashMap, NodeMap};\n-\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n use syntax::ast;\n-use syntax::ext::base::SyntaxExtension;\n+use syntax_expand::base::SyntaxExtension;\n use syntax_pos;\n-\n-pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n-pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LibSource, ForeignModule};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub use crate::cstore_impl::{provide, provide_extern};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n-\n-pub use rustc_data_structures::sync::MetadataRef;\n-use syntax_pos::Span;\n-use proc_macro::bridge::client::ProcMacro;\n+crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub struct MetadataBlob(pub MetadataRef);\n+crate struct MetadataBlob(pub MetadataRef);\n \n /// Holds information about a syntax_pos::SourceFile imported from another crate.\n /// See `imported_source_files()` for more information.\n-pub struct ImportedSourceFile {\n+crate struct ImportedSourceFile {\n     /// This SourceFile's byte-offset within the source_map of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n     /// The end of this SourceFile within the source_map of its original crate\n@@ -44,52 +37,66 @@ pub struct ImportedSourceFile {\n }\n \n pub struct CrateMetadata {\n-    /// Information about the extern crate that caused this crate to\n-    /// be loaded. If this is `None`, then the crate was injected\n-    /// (e.g., by the allocator)\n-    pub extern_crate: Lock<Option<ExternCrate>>,\n-\n-    pub blob: MetadataBlob,\n-    pub cnum_map: CrateNumMap,\n-    pub cnum: CrateNum,\n-    pub dependencies: Lock<Vec<CrateNum>>,\n-    pub source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n-\n-    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    pub alloc_decoding_state: AllocDecodingState,\n+    /// The primary crate data - binary metadata blob.\n+    crate blob: MetadataBlob,\n \n-    // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    // lifetime is only used behind `Lazy`, and therefore acts like an\n-    // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    // is being used to decode those values.\n-    pub root: schema::CrateRoot<'static>,\n+    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n \n+    /// Properties of the whole crate.\n+    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    /// is being used to decode those values.\n+    crate root: schema::CrateRoot<'static>,\n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub def_path_table: Lrc<DefPathTable>,\n-\n-    pub trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n-\n-    pub dep_kind: Lock<DepKind>,\n-    pub source: CrateSource,\n-\n+    crate def_path_table: Lrc<DefPathTable>,\n+    /// Trait impl data.\n+    /// FIXME: Used only from queries and can use query cache,\n+    /// so pre-decoding can probably be avoided.\n+    crate trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n+    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n+    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Source maps for code from the crate.\n+    crate source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    crate alloc_decoding_state: AllocDecodingState,\n+    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n+    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n+    /// Do not access the value directly, as it might not have been initialized yet.\n+    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n+    crate dep_node_index: AtomicCell<DepNodeIndex>,\n+\n+    // --- Other significant crate properties ---\n+\n+    /// ID of this crate, from the current compilation session's point of view.\n+    crate cnum: CrateNum,\n+    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n+    /// IDs as they are seen from the current compilation session.\n+    crate cnum_map: CrateNumMap,\n+    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    /// How to link (or not link) this crate to the currently compiled crate.\n+    crate dep_kind: Lock<DepKind>,\n+    /// Filesystem location of this crate.\n+    crate source: CrateSource,\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool,\n+    crate private_dep: bool,\n \n-    pub span: Span,\n+    // --- Data used only for improving diagnostics ---\n \n-    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n+    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n }\n \n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n-    /// Map from NodeId's of local extern crate statements to crate numbers\n-    extern_mod_crate_map: Lock<NodeMap<CrateNum>>,\n-    pub metadata_loader: Box<dyn MetadataLoader + Sync>,\n+    crate metadata_loader: Box<dyn MetadataLoader + Sync>,\n }\n \n pub enum LoadedMacro {\n@@ -105,30 +112,29 @@ impl CStore {\n             // corresponding `CrateNum`. This first entry will always remain\n             // `None`.\n             metas: RwLock::new(IndexVec::from_elem_n(None, 1)),\n-            extern_mod_crate_map: Default::default(),\n             metadata_loader,\n         }\n     }\n \n-    pub(super) fn alloc_new_crate_num(&self) -> CrateNum {\n+    crate fn alloc_new_crate_num(&self) -> CrateNum {\n         let mut metas = self.metas.borrow_mut();\n         let cnum = CrateNum::new(metas.len());\n         metas.push(None);\n         cnum\n     }\n \n-    pub(super) fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n         self.metas.borrow()[cnum].clone()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    pub(super) fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n+    crate fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n         let mut metas = self.metas.borrow_mut();\n         assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n         metas[cnum] = Some(data);\n     }\n \n-    pub(super) fn iter_crate_data<I>(&self, mut i: I)\n+    crate fn iter_crate_data<I>(&self, mut i: I)\n         where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n     {\n         for (k, v) in self.metas.borrow().iter_enumerated() {\n@@ -138,16 +144,14 @@ impl CStore {\n         }\n     }\n \n-    pub(super) fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n+    crate fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n         ordering.reverse();\n         ordering\n     }\n \n-    pub(super) fn push_dependencies_in_postorder(&self,\n-                                                 ordering: &mut Vec<CrateNum>,\n-                                                 krate: CrateNum) {\n+    crate fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n         if ordering.contains(&krate) {\n             return;\n         }\n@@ -162,7 +166,7 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    pub(super) fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+    crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (num, v) in self.metas.borrow().iter_enumerated() {\n             if let &Some(_) = v {\n@@ -171,12 +175,4 @@ impl CStore {\n         }\n         return ordering\n     }\n-\n-    pub(super) fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n-        self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n-    }\n-\n-    pub(super) fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n-        self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n-    }\n }"}, {"sha": "4cd1ff7b4a4ff8ed47ae02a8b3742a8df27f02a5", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -6,8 +6,7 @@ use crate::foreign_modules;\n use crate::schema;\n \n use rustc::ty::query::QueryConfig;\n-use rustc::middle::cstore::{CrateStore, DepKind,\n-                            EncodedMetadata, NativeLibraryKind};\n+use rustc::middle::cstore::{CrateSource, CrateStore, DepKind, EncodedMetadata, NativeLibraryKind};\n use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n use rustc::middle::dependency_format::Linkage;\n@@ -33,6 +32,7 @@ use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n+use syntax::source_map::Spanned;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n use rustc_index::bit_set::BitSet;\n@@ -47,23 +47,22 @@ macro_rules! provide {\n                 $tcx: TyCtxt<$lt>,\n                 def_id_arg: T,\n             ) -> <ty::queries::$name<$lt> as QueryConfig<$lt>>::Value {\n+                let _prof_timer =\n+                    $tcx.prof.generic_activity(\"metadata_decode_entry\");\n+\n                 #[allow(unused_variables)]\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let def_path_hash = $tcx.def_path_hash(DefId {\n-                    krate: $def_id.krate,\n-                    index: CRATE_DEF_INDEX\n-                });\n-                let dep_node = def_path_hash\n-                    .to_dep_node(rustc::dep_graph::DepKind::CrateMetadata);\n-                // The DepNodeIndex of the DepNode::CrateMetadata should be\n-                // cached somewhere, so that we can use read_index().\n-                $tcx.dep_graph.read(dep_node);\n-\n                 let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n+\n+                if $tcx.dep_graph.is_fully_enabled() {\n+                    let crate_dep_node_index = $cdata.get_crate_dep_node_index($tcx);\n+                    $tcx.dep_graph.read_index(crate_dep_node_index);\n+                }\n+\n                 $compute\n             })*\n \n@@ -98,11 +97,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generics_of => {\n         tcx.arena.alloc(cdata.get_generics(def_id.index, tcx.sess))\n     }\n-    predicates_of => { tcx.arena.alloc(cdata.get_predicates(def_id.index, tcx)) }\n-    predicates_defined_on => {\n-        tcx.arena.alloc(cdata.get_predicates_defined_on(def_id.index, tcx))\n-    }\n-    super_predicates_of => { tcx.arena.alloc(cdata.get_super_predicates(def_id.index, tcx)) }\n+    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n+    predicates_defined_on => { cdata.get_predicates_defined_on(def_id.index, tcx) }\n+    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n         tcx.arena.alloc(cdata.get_trait_def(def_id.index, tcx.sess))\n     }\n@@ -270,7 +267,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n     // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         is_dllimport_foreign_item: |tcx, id| {\n-            tcx.native_library_kind(id) == Some(NativeLibraryKind::NativeUnknown)\n+            match tcx.native_library_kind(id) {\n+                Some(NativeLibraryKind::NativeUnknown) |\n+                Some(NativeLibraryKind::NativeRawDylib) => true,\n+                _ => false,\n+            }\n         },\n         is_statically_included_foreign_item: |tcx, id| {\n             match tcx.native_library_kind(id) {\n@@ -410,26 +411,12 @@ impl cstore::CStore {\n         }\n     }\n \n-    pub fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind {\n-        let data = self.get_crate_data(cnum);\n-        let r = *data.dep_kind.lock();\n-        r\n-    }\n-\n     pub fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition {\n         self.get_crate_data(cnum).root.edition\n     }\n \n-    pub fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name> {\n-        self.get_crate_data(def.krate).get_struct_field_names(def.index)\n-    }\n-\n-    pub fn ctor_kind_untracked(&self, def: DefId) -> def::CtorKind {\n-        self.get_crate_data(def.krate).get_ctor_kind(def.index)\n-    }\n-\n-    pub fn item_attrs_untracked(&self, def: DefId, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        self.get_crate_data(def.krate).get_item_attrs(def.index, sess)\n+    pub fn struct_field_names_untracked(&self, def: DefId, sess: &Session) -> Vec<Spanned<Symbol>> {\n+        self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n \n     pub fn item_children_untracked(\n@@ -444,6 +431,8 @@ impl cstore::CStore {\n     }\n \n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n+        let _prof_timer = sess.prof.generic_activity(\"metadata_load_macro\");\n+\n         let data = self.get_crate_data(id.krate);\n         if data.is_proc_macro_crate() {\n             return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n@@ -487,6 +476,10 @@ impl cstore::CStore {\n     pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n+\n+    pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {\n+        self.get_crate_data(cnum).source.clone()\n+    }\n }\n \n impl CrateStore for cstore::CStore {\n@@ -521,20 +514,10 @@ impl CrateStore for cstore::CStore {\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n     fn def_key(&self, def: DefId) -> DefKey {\n-        // Note: loading the def-key (or def-path) for a def-id is not\n-        // a *read* of its metadata. This is because the def-id is\n-        // really just an interned shorthand for a def-path, which is the\n-        // canonical name for an item.\n-        //\n-        // self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n     fn def_path(&self, def: DefId) -> DefPath {\n-        // See `Note` above in `def_key()` for why this read is\n-        // commented out:\n-        //\n-        // self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n@@ -553,11 +536,6 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n-    {\n-        self.do_extern_mod_stmt_cnum(emod_id)\n-    }\n-\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         self.do_postorder_cnums_untracked()\n     }"}, {"sha": "b8b0030244028d25c343b8f9cd7aba7ffb93b058", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 226, "deletions": 184, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,18 +1,20 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::schema::*;\n+use crate::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n-use rustc::middle::cstore::LinkagePreference;\n+use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc::dep_graph::{DepNodeIndex, DepKind};\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n use rustc::mir::interpret::AllocDecodingSession;\n@@ -24,20 +26,21 @@ use rustc::util::captures::Captures;\n \n use std::io;\n use std::mem;\n+use std::num::NonZeroUsize;\n use std::u32;\n \n-use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n+use rustc_serialize::{Decodable, Decoder, Encodable, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n-use syntax::source_map;\n+use syntax::source_map::{self, respan, Spanned};\n use syntax::symbol::{Symbol, sym};\n-use syntax::ext::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n+use syntax_expand::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n-use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n+use syntax_expand::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n-pub struct DecodeContext<'a, 'tcx> {\n+crate struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'tcx Session>,\n@@ -53,7 +56,7 @@ pub struct DecodeContext<'a, 'tcx> {\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n-pub trait Metadata<'a, 'tcx>: Copy {\n+crate trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'tcx Session> { None }\n@@ -128,31 +131,31 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> Lazy<T> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n-        let mut dcx = meta.decoder(self.position);\n+impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n+    crate fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n+        let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Encodable + Decodable> Lazy<[T]> {\n+    crate fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n-        meta: M,\n+        metadata: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n-        let mut dcx = meta.decoder(self.position);\n+        let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n-    pub fn cdata(&self) -> &'a CrateMetadata {\n+    fn cdata(&self) -> &'a CrateMetadata {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n@@ -165,13 +168,14 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         let position = match self.lazy_state {\n             LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n+                let start = start.get();\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n-            LazyState::Previous(last_min_end) => last_min_end + distance,\n+            LazyState::Previous(last_min_end) => last_min_end.get() + distance,\n         };\n-        self.lazy_state = LazyState::Previous(position + min_size);\n-        Ok(Lazy::from_position_and_meta(position, meta))\n+        self.lazy_state = LazyState::Previous(NonZeroUsize::new(position + min_size).unwrap());\n+        Ok(Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta))\n     }\n }\n \n@@ -234,13 +238,13 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n         if len == 0 {\n@@ -251,6 +255,14 @@ impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<PerDefTable<T>>> for DecodeContext<'a, 'tcx>\n+    where Option<T>: FixedSizeEncoding,\n+{\n+    fn specialized_decode(&mut self) -> Result<Lazy<PerDefTable<T>>, Self::Error> {\n+        let len = self.read_usize()?;\n+        self.read_lazy_with_meta(len)\n+    }\n+}\n \n impl<'a, 'tcx> SpecializedDecoder<DefId> for DecodeContext<'a, 'tcx> {\n     #[inline]\n@@ -378,24 +390,28 @@ for DecodeContext<'a, 'tcx> {\n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n impl<'tcx> MetadataBlob {\n-    pub fn is_compatible(&self) -> bool {\n+    crate fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n \n-    pub fn get_rustc_version(&self) -> String {\n-        Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n+    crate fn get_rustc_version(&self) -> String {\n+        Lazy::<String>::from_position(\n+            NonZeroUsize::new(METADATA_HEADER.len() + 4).unwrap(),\n+        ).decode(self)\n     }\n \n-    pub fn get_root(&self) -> CrateRoot<'tcx> {\n+    crate fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n-        Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n+        Lazy::<CrateRoot<'tcx>>::from_position(\n+            NonZeroUsize::new(pos).unwrap(),\n+        ).decode(self)\n     }\n \n-    pub fn list_crate_metadata(&self,\n+    crate fn list_crate_metadata(&self,\n                                out: &mut dyn io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n@@ -448,7 +464,7 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n-    pub fn is_proc_macro_crate(&self) -> bool {\n+    crate fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n \n@@ -457,27 +473,20 @@ impl<'a, 'tcx> CrateMetadata {\n             self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n-    fn entry_unless_proc_macro(&self, id: DefIndex) -> Option<Entry<'tcx>> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => Some(self.entry(id)),\n-        }\n-    }\n-\n-    fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n+    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind<'tcx>> {\n+        self.root.per_def.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n-    fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n-        match self.maybe_entry(item_id) {\n-            None => {\n-                bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n-                     item_id,\n-                     self.root.name,\n-                     self.cnum)\n-            }\n-            Some(d) => d.decode(self),\n-        }\n+    fn kind(&self, item_id: DefIndex) -> EntryKind<'tcx> {\n+        assert!(!self.is_proc_macro(item_id));\n+        self.maybe_kind(item_id).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n     }\n \n     fn local_def_id(&self, index: DefIndex) -> DefId {\n@@ -498,7 +507,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    crate fn item_name(&self, item_index: DefIndex) -> Symbol {\n         if !self.is_proc_macro(item_index) {\n             self.def_key(item_index)\n                 .disambiguated_data\n@@ -511,18 +520,18 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n-            self.entry(index).kind.def_kind()\n+            self.kind(index).def_kind()\n         } else {\n             Some(DefKind::Macro(\n                 macro_kind(self.raw_proc_macro(index))\n             ))\n         }\n     }\n \n-    pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.entry(index).span.decode((self, sess))\n+    crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+        self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n     crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -551,12 +560,12 @@ impl<'a, 'tcx> CrateMetadata {\n             helper_attrs,\n             self.root.edition,\n             Symbol::intern(name),\n-            &self.get_attributes(&self.entry(id), sess),\n+            &self.get_item_attrs(id, sess),\n         )\n     }\n \n-    pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n-        match self.entry(item_id).kind {\n+    crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+        match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n                 ty::TraitDef::new(self.local_def_id(item_id),\n@@ -581,18 +590,24 @@ impl<'a, 'tcx> CrateMetadata {\n     fn get_variant(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        item: &Entry<'_>,\n+        kind: &EntryKind<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n-        adt_kind: ty::AdtKind,\n     ) -> ty::VariantDef {\n-        let data = match item.kind {\n+        let data = match kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n+        let adt_kind = match kind {\n+            EntryKind::Variant(_) => ty::AdtKind::Enum,\n+            EntryKind::Struct(..) => ty::AdtKind::Struct,\n+            EntryKind::Union(..) => ty::AdtKind::Union,\n+            _ => bug!(),\n+        };\n+\n         let variant_did = if adt_kind == ty::AdtKind::Enum {\n             Some(self.local_def_id(index))\n         } else {\n@@ -606,68 +621,66 @@ impl<'a, 'tcx> CrateMetadata {\n             variant_did,\n             ctor_did,\n             data.discr,\n-            item.children.decode(self).map(|index| {\n-                let f = self.entry(index);\n-                ty::FieldDef {\n+            self.root.per_def.children.get(self, index).unwrap_or(Lazy::empty())\n+                .decode(self).map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n                     ident: Ident::with_dummy_span(self.item_name(index)),\n-                    vis: f.visibility.decode(self)\n-                }\n-            }).collect(),\n+                    vis: self.get_visibility(index),\n+                }).collect(),\n             data.ctor_kind,\n             adt_kind,\n             parent_did,\n             false,\n         )\n     }\n \n-    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n-        let item = self.entry(item_id);\n+    crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+        let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n-        let (kind, repr) = match item.kind {\n+        let (adt_kind, repr) = match kind {\n             EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let variants = if let ty::AdtKind::Enum = kind {\n-            item.children\n+        let variants = if let ty::AdtKind::Enum = adt_kind {\n+            self.root.per_def.children.get(self, item_id).unwrap_or(Lazy::empty())\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(tcx, &self.entry(index), index, did, kind)\n+                    self.get_variant(tcx, &self.kind(index), index, did)\n                 })\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &item, item_id, did, kind)).collect()\n+            std::iter::once(self.get_variant(tcx, &kind, item_id, did)).collect()\n         };\n \n-        tcx.alloc_adt_def(did, kind, variants, repr)\n+        tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    pub fn get_predicates(\n+    crate fn get_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.entry(item_id).predicates.unwrap().decode((self, tcx))\n+        self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n }\n \n-    pub fn get_predicates_defined_on(\n+    crate fn get_predicates_defined_on(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n+        self.root.per_def.predicates_defined_on.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(\n+    crate fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        let super_predicates = match self.entry(item_id).kind {\n+        let super_predicates = match self.kind(item_id) {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n             EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n             _ => bug!(\"def-index does not refer to trait or trait alias\"),\n@@ -676,67 +689,66 @@ impl<'a, 'tcx> CrateMetadata {\n         super_predicates.decode((self, tcx))\n     }\n \n-    pub fn get_generics(&self,\n-                        item_id: DefIndex,\n-                        sess: &Session)\n-                        -> ty::Generics {\n-        self.entry(item_id).generics.unwrap().decode((self, sess))\n+    crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n+        self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.entry(id).ty.unwrap().decode((self, tcx))\n+    crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n-            false => self.entry(id).stability.map(|stab| stab.decode(self)),\n+            false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n-    pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n+    crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+        self.root.per_def.deprecation.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n+            .map(|depr| depr.decode(self))\n     }\n \n-    pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n-            false => self.entry(id).visibility.decode(self),\n+            false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n         }\n     }\n \n     fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n         }\n     }\n \n-    pub fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    crate fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    pub fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    crate fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    crate fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    pub fn get_coerce_unsized_info(&self,\n-                                   id: DefIndex)\n-                                   -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+    crate fn get_coerce_unsized_info(\n+        &self,\n+        id: DefIndex,\n+    ) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    pub fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    crate fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -745,7 +757,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    crate fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -758,7 +770,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    pub fn get_diagnostic_items(\n+    crate fn get_diagnostic_items(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n@@ -775,7 +787,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over each child of the given item.\n-    pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n+    crate fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n         if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n@@ -802,38 +814,42 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n \n         // Find the item.\n-        let item = match self.maybe_entry(id) {\n+        let kind = match self.maybe_kind(id) {\n             None => return,\n-            Some(item) => item.decode((self, sess)),\n+            Some(kind) => kind,\n         };\n \n         // Iterate over all children.\n         let macros_only = self.dep_kind.lock().macros_only();\n-        for child_index in item.children.decode((self, sess)) {\n+        let children = self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty());\n+        for child_index in children.decode((self, sess)) {\n             if macros_only {\n                 continue\n             }\n \n             // Get the item.\n-            if let Some(child) = self.maybe_entry(child_index) {\n-                let child = child.decode((self, sess));\n-                match child.kind {\n+            if let Some(child_kind) = self.maybe_kind(child_index) {\n+                match child_kind {\n                     EntryKind::MacroDef(..) => {}\n                     _ if macros_only => continue,\n                     _ => {}\n                 }\n \n                 // Hand off the item to the callback.\n-                match child.kind {\n+                match child_kind {\n                     // FIXME(eddyb) Don't encode these in children.\n                     EntryKind::ForeignMod => {\n-                        for child_index in child.children.decode((self, sess)) {\n+                        let child_children =\n+                            self.root.per_def.children.get(self, child_index)\n+                                .unwrap_or(Lazy::empty());\n+                        for child_index in child_children.decode((self, sess)) {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n                                     ident: Ident::with_dummy_span(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n-                                    span: self.entry(child_index).span.decode((self, sess)),\n+                                    span: self.root.per_def.span.get(self, child_index).unwrap()\n+                                        .decode((self, sess)),\n                                 });\n                             }\n                         }\n@@ -845,7 +861,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 }\n \n                 let def_key = self.def_key(child_index);\n-                let span = child.span.decode((self, sess));\n+                let span = self.get_span(child_index, sess);\n                 if let (Some(kind), Some(name)) =\n                     (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     let ident = Ident::from_interned_str(name);\n@@ -898,7 +914,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }\n         }\n \n-        if let EntryKind::Mod(data) = item.kind {\n+        if let EntryKind::Mod(data) = kind {\n             for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n                 match exp.res {\n                     Res::Def(DefKind::Macro(..), _) => {}\n@@ -910,33 +926,35 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n-        self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n+            self.root.per_def.mir.get(self, id).is_some()\n     }\n \n-    pub fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n+    crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+        self.root.per_def.mir.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n-                bug!(\"get_optimized_mir: missing MIR for `{:?}\", self.local_def_id(id))\n+                bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n+            .decode((self, tcx))\n     }\n \n-    pub fn get_promoted_mir(\n+    crate fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> IndexVec<Promoted, Body<'tcx>> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.promoted_mir.map(|promoted| promoted.decode((self, tcx))))\n+        self.root.per_def.promoted_mir.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n+            .decode((self, tcx))\n     }\n \n-    pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n-        match self.entry(id).kind {\n+    crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+        match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplFinal, qualif, _) => {\n@@ -946,13 +964,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n-        let item = self.entry(id);\n+    crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n-        let (kind, container, has_self) = match item.kind {\n+        let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => {\n                 (ty::AssocKind::Const, container, false)\n             }\n@@ -972,29 +989,30 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::AssocItem {\n             ident: Ident::from_interned_str(name),\n             kind,\n-            vis: item.visibility.decode(self),\n+            vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n             def_id: self.local_def_id(id),\n             container: container.with_def_id(parent),\n             method_has_self_argument: has_self\n         }\n     }\n \n-    pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        self.entry(id).variances.decode(self).collect()\n+    crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+        self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty())\n+            .decode(self).collect()\n     }\n \n-    pub fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n-        match self.entry(node_id).kind {\n+    crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n+        match self.kind(node_id) {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n             EntryKind::Variant(data) => data.decode(self).ctor_kind,\n             _ => CtorKind::Fictive,\n         }\n     }\n \n-    pub fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n-        match self.entry(node_id).kind {\n+    crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+        match self.kind(node_id) {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n             }\n@@ -1005,8 +1023,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-\n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n+    crate fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1017,22 +1034,22 @@ impl<'a, 'tcx> CrateMetadata {\n             node_id\n         };\n \n-        let item = self.entry(item_id);\n-        Lrc::from(self.get_attributes(&item, sess))\n+        Lrc::from(self.root.per_def.attributes.get(self, item_id).unwrap_or(Lazy::empty())\n+            .decode((self, sess))\n+            .collect::<Vec<_>>())\n     }\n \n-    pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        self.entry(id)\n-            .children\n+    crate fn get_struct_field_names(\n+        &self,\n+        id: DefIndex,\n+        sess: &Session,\n+    ) -> Vec<Spanned<ast::Name>> {\n+        self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty())\n             .decode(self)\n-            .map(|index| self.item_name(index))\n+            .map(|index| respan(self.get_span(index, sess), self.item_name(index)))\n             .collect()\n     }\n \n-    fn get_attributes(&self, item: &Entry<'tcx>, sess: &Session) -> Vec<ast::Attribute> {\n-        item.attributes.decode((self, sess)).collect()\n-    }\n-\n     // Translate a DefId from the current compilation environment to a DefId\n     // for an external crate.\n     fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n@@ -1048,18 +1065,19 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    pub fn get_inherent_implementations_for_type(\n+    crate fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> &'tcx [DefId] {\n-        tcx.arena.alloc_from_iter(self.entry(id)\n-                                      .inherent_impls\n-                                      .decode(self)\n-                                      .map(|index| self.local_def_id(index)))\n+        tcx.arena.alloc_from_iter(\n+            self.root.per_def.inherent_impls.get(self, id).unwrap_or(Lazy::empty())\n+                .decode(self)\n+                .map(|index| self.local_def_id(index))\n+        )\n     }\n \n-    pub fn get_implementations_for_trait(\n+    crate fn get_implementations_for_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n@@ -1090,15 +1108,15 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    crate fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n             // Not an associated item\n             _ => return None,\n         }\n         def_key.parent.and_then(|parent_index| {\n-            match self.entry(parent_index).kind {\n+            match self.kind(parent_index) {\n                 EntryKind::Trait(_) |\n                 EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1107,7 +1125,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    crate fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1116,7 +1134,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n+    crate fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1125,7 +1143,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_dylib_dependency_formats(\n+    crate fn get_dylib_dependency_formats(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n@@ -1139,7 +1157,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    crate fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1150,8 +1168,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        let param_names = match self.entry(id).kind {\n+    crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        let param_names = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n@@ -1160,7 +1178,7 @@ impl<'a, 'tcx> CrateMetadata {\n         param_names.decode(self).collect()\n     }\n \n-    pub fn exported_symbols(\n+    crate fn exported_symbols(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n@@ -1173,24 +1191,23 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_rendered_const(&self, id: DefIndex) -> String {\n-        match self.entry(id).kind {\n+    crate fn get_rendered_const(&self, id: DefIndex) -> String {\n+        match self.kind(id) {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n-    pub fn get_macro(&self, id: DefIndex) -> MacroDef {\n-        let entry = self.entry(id);\n-        match entry.kind {\n+    crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n+        match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }\n \n     crate fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n-        let constness = match self.entry(id).kind {\n+        let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n             EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n@@ -1199,17 +1216,17 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    pub fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n-         match self.entry(id).kind {\n+    crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+         match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n             EntryKind::ForeignFn(data) => data.decode(self).asyncness,\n-            _ => bug!(\"asyncness: expect functions entry.\"),\n+            _ => bug!(\"asyncness: expected function kind\"),\n         }\n     }\n \n-    pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n-        match self.entry(id).kind {\n+    crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n+        match self.kind(id) {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n             EntryKind::ForeignFn(_) => true,\n@@ -1218,7 +1235,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n             EntryKind::MutStatic |\n@@ -1227,8 +1244,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.entry(id).kind {\n+    crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        let sig = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,\n             EntryKind::Method(data) => data.decode(self).fn_data.sig,\n@@ -1241,7 +1258,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     #[inline]\n-    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+    crate fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n@@ -1251,13 +1268,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    pub fn def_path(&self, id: DefIndex) -> DefPath {\n+    crate fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    crate fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n \n@@ -1286,9 +1303,10 @@ impl<'a, 'tcx> CrateMetadata {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    pub fn imported_source_files(&'a self,\n-                                 local_source_map: &source_map::SourceMap)\n-                                 -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n+    fn imported_source_files(\n+        &'a self,\n+        local_source_map: &source_map::SourceMap,\n+    ) -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n         {\n             let source_files = self.source_map_import_info.borrow();\n             if !source_files.is_empty() {\n@@ -1365,6 +1383,30 @@ impl<'a, 'tcx> CrateMetadata {\n         // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n         self.source_map_import_info.borrow()\n     }\n+\n+    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n+    /// method is cached in the `dep_node_index` field.\n+    pub(super) fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+        let mut dep_node_index = self.dep_node_index.load();\n+\n+        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n+            // We have not cached the DepNodeIndex for this upstream crate yet,\n+            // so use the dep-graph to find it out and cache it.\n+            // Note that multiple threads can enter this block concurrently.\n+            // That is fine because the DepNodeIndex remains constant\n+            // throughout the whole compilation session, and multiple stores\n+            // would always write the same value.\n+\n+            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n+            let dep_node = def_path_hash.to_dep_node(DepKind::CrateMetadata);\n+\n+            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n+            assert!(dep_node_index != DepNodeIndex::INVALID);\n+            self.dep_node_index.store(dep_node_index);\n+        }\n+\n+        dep_node_index\n+    }\n }\n \n // Cannot be implemented on 'ProcMacro', as libproc_macro"}, {"sha": "7f76a9730e198392cde7ac039bef100cc77ad373", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -60,7 +60,7 @@ use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n-pub fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n         verify_ok(tcx, &linkage);"}, {"sha": "3871eb89f7b42c42e4c49dd5bc181d04659b00f2", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -32,30 +32,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Loads a dynamic library into the global namespace (RTLD_GLOBAL on Unix)\n-    /// and do it now (don't use RTLD_LAZY on Unix).\n-    pub fn open_global_now(filename: &Path) -> Result<DynamicLibrary, String> {\n-        let maybe_library = dl::open_global_now(filename.as_os_str());\n-        match maybe_library {\n-            Err(err) => Err(err),\n-            Ok(handle) => Ok(DynamicLibrary { handle })\n-        }\n-    }\n-\n-    /// Returns the environment variable for this process's dynamic library\n-    /// search path\n-    pub fn envvar() -> &'static str {\n-        if cfg!(windows) {\n-            \"PATH\"\n-        } else if cfg!(target_os = \"macos\") {\n-            \"DYLD_LIBRARY_PATH\"\n-        } else if cfg!(target_os = \"haiku\") {\n-            \"LIBRARY_PATH\"\n-        } else {\n-            \"LD_LIBRARY_PATH\"\n-        }\n-    }\n-\n     /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on\n@@ -83,7 +59,7 @@ mod dl {\n     use std::ptr;\n     use std::str;\n \n-    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             unsafe {\n                 match filename {\n@@ -94,13 +70,6 @@ mod dl {\n         })\n     }\n \n-    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| unsafe {\n-            let s = CString::new(filename.as_bytes()).unwrap();\n-            libc::dlopen(s.as_ptr(), libc::RTLD_GLOBAL | libc::RTLD_NOW) as *mut u8\n-        })\n-    }\n-\n     unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n         let s = CString::new(filename.as_bytes()).unwrap();\n         libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n@@ -110,8 +79,8 @@ mod dl {\n         libc::dlopen(ptr::null(), libc::RTLD_LAZY) as *mut u8\n     }\n \n-    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n-        F: FnOnce() -> T,\n+    fn check_for_errors_in<T, F>(f: F) -> Result<T, String>\n+        where F: FnOnce() -> T,\n     {\n         use std::sync::{Mutex, Once};\n         static INIT: Once = Once::new();\n@@ -139,14 +108,15 @@ mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const libc::c_char)\n-                         -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const libc::c_char,\n+    ) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n         })\n     }\n-    pub unsafe fn close(handle: *mut u8) {\n+    pub(super) unsafe fn close(handle: *mut u8) {\n         libc::dlclose(handle as *mut libc::c_void); ()\n     }\n }\n@@ -178,11 +148,7 @@ mod dl {\n         fn FreeLibrary(handle: HMODULE) -> BOOL;\n     }\n \n-    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n-        open(Some(filename))\n-    }\n-\n-    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let prev_error_mode = unsafe {\n             // SEM_FAILCRITICALERRORS 0x01\n@@ -225,14 +191,15 @@ mod dl {\n         result\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const c_char)\n-                         -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const c_char,\n+    ) -> Result<*mut u8, String> {\n         let ptr = GetProcAddress(handle as HMODULE, symbol) as *mut u8;\n         ptr_result(ptr)\n     }\n \n-    pub unsafe fn close(handle: *mut u8) {\n+    pub(super) unsafe fn close(handle: *mut u8) {\n         FreeLibrary(handle as HMODULE);\n     }\n "}, {"sha": "6ae8c2fc6c694b2b72d4cb0d943d5b60b3a5af12", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 443, "deletions": 606, "changes": 1049, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,11 +1,11 @@\n-use crate::index::Index;\n use crate::schema::*;\n+use crate::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc::hir::GenericParamKind;\n+use rustc::hir::{GenericParamKind, AnonConst};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n@@ -15,23 +15,24 @@ use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n+use rustc::ty::{self, Ty, TyCtxt, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::ty::layout::VariantIdx;\n \n use rustc::session::config::{self, CrateType};\n use rustc::util::nodemap::FxHashMap;\n \n use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::sync::Lrc;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n \n use std::hash::Hash;\n+use std::num::NonZeroUsize;\n use std::path::Path;\n-use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::proc_macro::is_proc_macro_attr;\n+use syntax_expand::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym, Ident, Symbol};\n use syntax_pos::{self, FileName, SourceFile, Span};\n@@ -42,11 +43,11 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-pub struct EncodeContext<'tcx> {\n+struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n-    pub tcx: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n-    entries_index: Index<'tcx>,\n+    per_def: PerDefTables<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -59,6 +60,27 @@ pub struct EncodeContext<'tcx> {\n     source_file_cache: Lrc<SourceFile>,\n }\n \n+#[derive(Default)]\n+struct PerDefTables<'tcx> {\n+    kind: PerDefTable<Lazy<EntryKind<'tcx>>>,\n+    visibility: PerDefTable<Lazy<ty::Visibility>>,\n+    span: PerDefTable<Lazy<Span>>,\n+    attributes: PerDefTable<Lazy<[ast::Attribute]>>,\n+    children: PerDefTable<Lazy<[DefIndex]>>,\n+    stability: PerDefTable<Lazy<attr::Stability>>,\n+    deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n+\n+    ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n+    variances: PerDefTable<Lazy<[ty::Variance]>>,\n+    generics: PerDefTable<Lazy<ty::Generics>>,\n+    predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+\n+    mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n+    promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+}\n+\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -97,13 +119,13 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         if lazy.meta == 0 {\n@@ -113,6 +135,15 @@ impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n+impl<'tcx, T> SpecializedEncoder<Lazy<PerDefTable<T>>> for EncodeContext<'tcx>\n+    where Option<T>: FixedSizeEncoding,\n+{\n+    fn specialized_encode(&mut self, lazy: &Lazy<PerDefTable<T>>) -> Result<(), Self::Error> {\n+        self.emit_usize(lazy.meta)?;\n+        self.emit_lazy_distance(*lazy)\n+    }\n+}\n+\n impl<'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n@@ -212,11 +243,11 @@ impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'tcx> {\n+impl<'tcx> SpecializedEncoder<&'tcx [(ty::Predicate<'tcx>, Span)]> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self,\n-                          predicates: &ty::GenericPredicates<'tcx>)\n+                          predicates: &&'tcx [(ty::Predicate<'tcx>, Span)])\n                           -> Result<(), Self::Error> {\n-        ty_codec::encode_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n+        ty_codec::encode_spanned_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n@@ -257,7 +288,7 @@ impl<T: Encodable> EncodeContentsForLazy<T> for T {\n     }\n }\n \n-impl<I, T> EncodeContentsForLazy<[T]> for I\n+impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n     where I: IntoIterator,\n           I::Item: EncodeContentsForLazy<T>,\n {\n@@ -266,15 +297,28 @@ impl<I, T> EncodeContentsForLazy<[T]> for I\n     }\n }\n \n+// Shorthand for `$self.$tables.$table.set($key, $self.lazy($value))`, which would\n+// normally need extra variables to avoid errors about multiple mutable borrows.\n+macro_rules! record {\n+    ($self:ident.$tables:ident.$table:ident[$key:expr] <- $value:expr) => {{\n+        {\n+            let value = $value;\n+            let lazy = $self.lazy(value);\n+            $self.$tables.$table.set($key, lazy);\n+        }\n+    }}\n+}\n+\n impl<'tcx> EncodeContext<'tcx> {\n     fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n         &mut self,\n         lazy: Lazy<T>,\n     ) -> Result<(), <Self as Encoder>::Error> {\n-        let min_end = lazy.position + T::min_size(lazy.meta);\n+        let min_end = lazy.position.get() + T::min_size(lazy.meta);\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n+                let start = start.get();\n                 assert!(min_end <= start);\n                 start - min_end\n             }\n@@ -284,53 +328,33 @@ impl<'tcx> EncodeContext<'tcx> {\n                     \"make sure that the calls to `lazy*` \\\n                     are in the same order as the metadata fields\",\n                 );\n-                lazy.position - last_min_end\n+                lazy.position.get() - last_min_end.get()\n             }\n         };\n-        self.lazy_state = LazyState::Previous(min_end);\n+        self.lazy_state = LazyState::Previous(NonZeroUsize::new(min_end).unwrap());\n         self.emit_usize(distance)\n     }\n \n     fn lazy<T: ?Sized + LazyMeta>(\n         &mut self,\n         value: impl EncodeContentsForLazy<T>,\n     ) -> Lazy<T> {\n-        let pos = self.position();\n+        let pos = NonZeroUsize::new(self.position()).unwrap();\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         self.lazy_state = LazyState::NodeStart(pos);\n         let meta = value.encode_contents_for_lazy(self);\n         self.lazy_state = LazyState::NoNode;\n \n-        assert!(pos + <T>::min_size(meta) <= self.position());\n+        assert!(pos.get() + <T>::min_size(meta) <= self.position());\n \n         Lazy::from_position_and_meta(pos, meta)\n     }\n \n-    /// Emit the data for a `DefId` to the metadata. The function to\n-    /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will call `op` to generate\n-    /// the `Entry` (which may point to other encoded information)\n-    /// and will then record the `Lazy<Entry>` for use in the index.\n-    // FIXME(eddyb) remove this.\n-    pub fn record<DATA>(&mut self,\n-                        id: DefId,\n-                        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n-                        data: DATA)\n-    {\n-        assert!(id.is_local());\n-\n-        let entry = op(self, data);\n-        let entry = self.lazy(entry);\n-        self.entries_index.record(id, entry);\n-    }\n-\n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        self.record(DefId::local(CRATE_DEF_INDEX),\n-                     EncodeContext::encode_info_for_mod,\n-                     (hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis));\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis);\n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n             self.visit_macro_def(macro_def);\n@@ -474,8 +498,26 @@ impl<'tcx> EncodeContext<'tcx> {\n \n \n         i = self.position();\n-        let entries_index = self.entries_index.write_index(&mut self.opaque);\n-        let entries_index_bytes = self.position() - i;\n+        let per_def = LazyPerDefTables {\n+            kind: self.per_def.kind.encode(&mut self.opaque),\n+            visibility: self.per_def.visibility.encode(&mut self.opaque),\n+            span: self.per_def.span.encode(&mut self.opaque),\n+            attributes: self.per_def.attributes.encode(&mut self.opaque),\n+            children: self.per_def.children.encode(&mut self.opaque),\n+            stability: self.per_def.stability.encode(&mut self.opaque),\n+            deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n+\n+            ty: self.per_def.ty.encode(&mut self.opaque),\n+            inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n+            variances: self.per_def.variances.encode(&mut self.opaque),\n+            generics: self.per_def.generics.encode(&mut self.opaque),\n+            predicates: self.per_def.predicates.encode(&mut self.opaque),\n+            predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+\n+            mir: self.per_def.mir.encode(&mut self.opaque),\n+            promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n+        };\n+        let per_def_bytes = self.position() - i;\n \n         // Encode the proc macro data\n         i = self.position();\n@@ -534,7 +576,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            entries_index,\n+            per_def,\n         });\n \n         let total_bytes = self.position();\n@@ -559,7 +601,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"   entries index bytes: {}\", entries_index_bytes);\n+            println!(\"   per-def table bytes: {}\", per_def_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -569,23 +611,21 @@ impl<'tcx> EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_variances_of(&mut self, def_id: DefId) -> Lazy<[ty::Variance]> {\n+    fn encode_variances_of(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&tcx.variances_of(def_id)[..])\n+        record!(self.per_def.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n     }\n \n-    fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n-        let tcx = self.tcx;\n-        let ty = tcx.type_of(def_id);\n-        debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n-        self.lazy(ty)\n+    fn encode_item_type(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n+        record!(self.per_def.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(\n         &mut self,\n-        (enum_did, index): (DefId, VariantIdx),\n-    ) -> Entry<'tcx> {\n+        enum_did: DefId,\n+        index: VariantIdx,\n+    ) {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -607,38 +647,32 @@ impl EncodeContext<'tcx> {\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n-        Entry {\n-            kind: EntryKind::Variant(self.lazy(data)),\n-            visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: self.lazy(variant.fields.iter().map(|f| {\n-                assert!(f.did.is_local());\n-                f.did.index\n-            })),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.per_def.children[def_id] <- variant.fields.iter().map(|f| {\n+            assert!(f.did.is_local());\n+            f.did.index\n+        }));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_enum_variant_ctor(\n         &mut self,\n-        (enum_did, index): (DefId, VariantIdx),\n-    ) -> Entry<'tcx> {\n+        enum_did: DefId,\n+        index: VariantIdx,\n+    ) {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -665,35 +699,28 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        Entry {\n-            kind: EntryKind::Variant(self.lazy(data)),\n-            visibility: self.lazy(ctor_vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <- ctor_vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_info_for_mod(\n         &mut self,\n-        (id, md, attrs, vis): (hir::HirId, &hir::Mod, &[ast::Attribute], &hir::Visibility),\n-    ) -> Entry<'tcx> {\n+        id: hir::HirId,\n+        md: &hir::Mod,\n+        attrs: &[ast::Attribute],\n+        vis: &hir::Visibility,\n+    ) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n@@ -705,33 +732,23 @@ impl EncodeContext<'tcx> {\n             },\n         };\n \n-        Entry {\n-            kind: EntryKind::Mod(self.lazy(data)),\n-            visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(attrs),\n-            children: self.lazy(md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).index\n-            })),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: None,\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        }\n+        record!(self.per_def.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- attrs);\n+        record!(self.per_def.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+            tcx.hir().local_def_id(item_id.id).index\n+        }));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n     }\n \n     fn encode_field(\n         &mut self,\n-        (adt_def_id, variant_index, field_index): (DefId, VariantIdx, usize),\n-    ) -> Entry<'tcx> {\n+        adt_def_id: DefId,\n+        variant_index: VariantIdx,\n+        field_index: usize,\n+    ) {\n         let tcx = self.tcx;\n         let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n@@ -742,28 +759,18 @@ impl EncodeContext<'tcx> {\n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n-        Entry {\n-            kind: EntryKind::Field,\n-            visibility: self.lazy(field.vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        }\n+        record!(self.per_def.kind[def_id] <- EntryKind::Field);\n+        record!(self.per_def.visibility[def_id] <- field.vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &variant_data.fields()[field_index].attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n     }\n \n-    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n+    fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let adt_def = tcx.adt_def(adt_def_id);\n@@ -797,52 +804,38 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        let repr_options = get_repr_options(tcx, adt_def_id);\n-\n-        Entry {\n-            kind: EntryKind::Struct(self.lazy(data), repr_options),\n-            visibility: self.lazy(ctor_vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+        record!(self.per_def.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n+        record!(self.per_def.visibility[def_id] <- ctor_vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n+    fn encode_generics(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(tcx.generics_of(def_id))\n+        record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n-    fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+    fn encode_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&*tcx.predicates_of(def_id))\n+        record!(self.per_def.predicates[def_id] <- self.tcx.predicates_of(def_id));\n     }\n \n-    fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+    fn encode_predicates_defined_on(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&*tcx.predicates_defined_on(def_id))\n+        record!(self.per_def.predicates_defined_on[def_id] <-\n+            self.tcx.predicates_defined_on(def_id))\n     }\n \n-    fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -859,7 +852,7 @@ impl EncodeContext<'tcx> {\n                 span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        let kind = match trait_item.kind {\n+        record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n@@ -868,7 +861,7 @@ impl EncodeContext<'tcx> {\n                 EntryKind::AssocConst(container, ConstQualif { mir: 0 }, rendered_const)\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.kind {\n+                let fn_data = if let hir::TraitItemKind::Method(m_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n                             self.encode_fn_param_names(names)\n@@ -878,10 +871,10 @@ impl EncodeContext<'tcx> {\n                         }\n                     };\n                     FnData {\n-                        asyncness: method_sig.header.asyncness,\n+                        asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -894,52 +887,39 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n             ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n-        };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(trait_item.vis),\n-            span: self.lazy(ast_item.span),\n-            attributes: self.encode_attributes(&ast_item.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: match trait_item.kind {\n-                ty::AssocKind::Const |\n-                ty::AssocKind::Method => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n-                ty::AssocKind::Type => {\n-                    if trait_item.defaultness.has_value() {\n-                        Some(self.encode_item_type(def_id))\n-                    } else {\n-                        None\n-                    }\n+        });\n+        record!(self.per_def.visibility[def_id] <- trait_item.vis);\n+        record!(self.per_def.span[def_id] <- ast_item.span);\n+        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        match trait_item.kind {\n+            ty::AssocKind::Const |\n+            ty::AssocKind::Method => {\n+                self.encode_item_type(def_id);\n+            }\n+            ty::AssocKind::Type => {\n+                if trait_item.defaultness.has_value() {\n+                    self.encode_item_type(def_id);\n                 }\n-                ty::AssocKind::OpaqueTy => unreachable!(),\n-            },\n-            inherent_impls: Lazy::empty(),\n-            variances: if trait_item.kind == ty::AssocKind::Method {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+            }\n+            ty::AssocKind::OpaqueTy => unreachable!(),\n+        }\n+        if trait_item.kind == ty::AssocKind::Method {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn metadata_output_only(&self) -> bool {\n         // MIR optimisation can be skipped when we're just interested in the metadata.\n         !self.tcx.sess.opts.output_types.should_codegen()\n     }\n \n-    fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -954,7 +934,7 @@ impl EncodeContext<'tcx> {\n                 span_bug!(ast_item.span, \"impl items always have values (currently)\"),\n         };\n \n-        let kind = match impl_item.kind {\n+        record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n@@ -972,7 +952,7 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -985,8 +965,18 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n-        };\n-\n+        });\n+        record!(self.per_def.visibility[def_id] <- impl_item.vis);\n+        record!(self.per_def.span[def_id] <- ast_item.span);\n+        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if impl_item.kind == ty::AssocKind::Method {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n             hir::ImplItemKind::Method(ref sig, _) => {\n@@ -1001,29 +991,9 @@ impl EncodeContext<'tcx> {\n             hir::ImplItemKind::OpaqueTy(..) |\n             hir::ImplItemKind::TyAlias(..) => false,\n         };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(impl_item.vis),\n-            span: self.lazy(ast_item.span),\n-            attributes: self.encode_attributes(&ast_item.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if impl_item.kind == ty::AssocKind::Method {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n-            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n+        if mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n         }\n     }\n \n@@ -1044,51 +1014,44 @@ impl EncodeContext<'tcx> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n-    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n+    fn encode_optimized_mir(&mut self, def_id: DefId) {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            let mir = self.tcx.optimized_mir(def_id);\n-            Some(self.lazy(mir))\n-        } else {\n-            None\n+            record!(self.per_def.mir[def_id] <- self.tcx.optimized_mir(def_id));\n         }\n     }\n \n-    fn encode_promoted_mir(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>> {\n+    fn encode_promoted_mir(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            let promoted = self.tcx.promoted_mir(def_id);\n-            Some(self.lazy(promoted))\n-        } else {\n-            None\n+            record!(self.per_def.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n         }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n-        if implementations.is_empty() {\n-            Lazy::empty()\n-        } else {\n-            self.lazy(implementations.iter().map(|&def_id| {\n+        if !implementations.is_empty() {\n+            record!(self.per_def.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n-            }))\n+            }));\n         }\n     }\n \n-    fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n+    fn encode_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n-        self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n+        if let Some(stab) = self.tcx.lookup_stability(def_id) {\n+            record!(self.per_def.stability[def_id] <- stab)\n+        }\n     }\n \n-    fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n+    fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n-        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(depr))\n+        if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n+            record!(self.per_def.deprecation[def_id] <- depr);\n+        }\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n@@ -1098,16 +1061,16 @@ impl EncodeContext<'tcx> {\n         self.lazy(rendered_const)\n     }\n \n-    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n+    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let kind = match item.kind {\n+        record!(self.per_def.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n+                let mir = self.tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n                     ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n@@ -1124,48 +1087,48 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n+                return self.encode_info_for_mod(item.hir_id, m, &item.attrs, &item.vis);\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n             hir::ItemKind::TyAlias(..) => EntryKind::Type,\n             hir::ItemKind::OpaqueTy(..) => EntryKind::OpaqueTy,\n-            hir::ItemKind::Enum(..) => EntryKind::Enum(get_repr_options(tcx, def_id)),\n+            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let variant = tcx.adt_def(def_id).non_enum_variant();\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let variant = adt_def.non_enum_variant();\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let ctor = struct_def.ctor_hir_id()\n-                    .map(|ctor_hir_id| tcx.hir().local_def_id(ctor_hir_id).index);\n-\n-                let repr_options = get_repr_options(tcx, def_id);\n+                let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n+                    self.tcx.hir().local_def_id(ctor_hir_id).index\n+                });\n \n                 EntryKind::Struct(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n                     ctor_sig: None,\n-                }), repr_options)\n+                }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n-                let variant = tcx.adt_def(def_id).non_enum_variant();\n-                let repr_options = get_repr_options(tcx, def_id);\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let variant = adt_def.non_enum_variant();\n \n                 EntryKind::Union(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n                     ctor_sig: None,\n-                }), repr_options)\n+                }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n-                let trait_ref = tcx.impl_trait_ref(def_id);\n-                let polarity = tcx.impl_polarity(def_id);\n+                let trait_ref = self.tcx.impl_trait_ref(def_id);\n+                let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n-                    let trait_def = tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(tcx, def_id).nth(1).and_then(|node| {\n+                    let trait_def = self.tcx.trait_def(trait_ref.def_id);\n+                    trait_def.ancestors(self.tcx, def_id).nth(1).and_then(|node| {\n                         match node {\n                             specialization_graph::Node::Impl(parent) => Some(parent),\n                             _ => None,\n@@ -1179,8 +1142,8 @@ impl EncodeContext<'tcx> {\n                 // \"unsized info\", else just store None\n                 let coerce_unsized_info =\n                     trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == tcx.lang_items().coerce_unsized_trait() {\n-                            Some(tcx.at(item.span).coerce_unsized_info(def_id))\n+                        if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n+                            Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n                         } else {\n                             None\n                         }\n@@ -1197,27 +1160,115 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Impl(self.lazy(data))\n             }\n             hir::ItemKind::Trait(..) => {\n-                let trait_def = tcx.trait_def(def_id);\n+                let trait_def = self.tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n-                    has_auto_impl: tcx.trait_is_auto(def_id),\n+                    has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(data))\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 let data = TraitAliasData {\n-                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n                 };\n \n                 EntryKind::TraitAlias(self.lazy(data))\n             }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n-        };\n+        });\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n+        record!(self.per_def.span[def_id] <- item.span);\n+        record!(self.per_def.attributes[def_id] <- &item.attrs);\n+        // FIXME(eddyb) there should be a nicer way to do this.\n+        match item.kind {\n+            hir::ItemKind::ForeignMod(ref fm) => record!(self.per_def.children[def_id] <-\n+                fm.items\n+                    .iter()\n+                    .map(|foreign_item| tcx.hir().local_def_id(\n+                        foreign_item.hir_id).index)\n+            ),\n+            hir::ItemKind::Enum(..) => record!(self.per_def.children[def_id] <-\n+                self.tcx.adt_def(def_id).variants.iter().map(|v| {\n+                    assert!(v.def_id.is_local());\n+                    v.def_id.index\n+                })\n+            ),\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => record!(self.per_def.children[def_id] <-\n+                self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n+                    assert!(f.did.is_local());\n+                    f.did.index\n+                })\n+            ),\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Trait(..) => {\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record!(self.per_def.children[def_id] <-\n+                    associated_item_def_ids.iter().map(|&def_id| {\n+                        assert!(def_id.is_local());\n+                        def_id.index\n+                    })\n+                );\n+            }\n+            _ => {}\n+        }\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        match item.kind {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n+            _ => {}\n+        }\n+        self.encode_inherent_implementations(def_id);\n+        match item.kind {\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n+            _ => {}\n+        }\n+        match item.kind {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_generics(def_id);\n+                self.encode_predicates(def_id);\n+            }\n+            _ => {}\n+        }\n+        // The only time that `predicates_defined_on` is used (on\n+        // an external item) is for traits, during chalk lowering,\n+        // so only encode it in that case as an efficiency\n+        // hack. (No reason not to expand it in the future if\n+        // necessary.)\n+        match item.kind {\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_predicates_defined_on(def_id);\n+            }\n+            _ => {} // not *wrong* for other kinds of items, but not needed\n+        }\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n@@ -1232,188 +1283,48 @@ impl EncodeContext<'tcx> {\n             }\n             _ => false,\n         };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n-            span: self.lazy(item.span),\n-            attributes: self.encode_attributes(&item.attrs),\n-            children: match item.kind {\n-                hir::ItemKind::ForeignMod(ref fm) => {\n-                    self.lazy(fm.items\n-                        .iter()\n-                        .map(|foreign_item| tcx.hir().local_def_id(\n-                            foreign_item.hir_id).index))\n-                }\n-                hir::ItemKind::Enum(..) => {\n-                    let def = self.tcx.adt_def(def_id);\n-                    self.lazy(def.variants.iter().map(|v| {\n-                        assert!(v.def_id.is_local());\n-                        v.def_id.index\n-                    }))\n-                }\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) => {\n-                    let def = self.tcx.adt_def(def_id);\n-                    self.lazy(def.non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    }))\n-                }\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::Trait(..) => {\n-                    self.lazy(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n-                        assert!(def_id.is_local());\n-                        def_id.index\n-                    }))\n-                }\n-                _ => Lazy::empty(),\n-            },\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) => Some(self.encode_item_type(def_id)),\n-                _ => None,\n-            },\n-            inherent_impls: self.encode_inherent_implementations(def_id),\n-            variances: match item.kind {\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => Lazy::empty(),\n-            },\n-            generics: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n-                _ => None,\n-            },\n-            predicates: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates(def_id)),\n-                _ => None,\n-            },\n-\n-            // The only time that `predicates_defined_on` is used (on\n-            // an external item) is for traits, during chalk lowering,\n-            // so only encode it in that case as an efficiency\n-            // hack. (No reason not to expand it in the future if\n-            // necessary.)\n-            predicates_defined_on: match item.kind {\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates_defined_on(def_id)),\n-                _ => None, // not *wrong* for other kinds of items, but not needed\n-            },\n-\n-            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n-            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n+        if mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n         }\n     }\n \n     /// Serialize the text of exported macros\n-    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        Entry {\n-            kind: EntryKind::MacroDef(self.lazy(MacroDef {\n-                body: pprust::tts_to_string(macro_def.body.clone()),\n-                legacy: macro_def.legacy,\n-            })),\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(macro_def.span),\n-            attributes: self.encode_attributes(&macro_def.attrs),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            children: Lazy::empty(),\n-            ty: None,\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-            mir: None,\n-            promoted_mir: None,\n-        }\n+        record!(self.per_def.kind[def_id] <- EntryKind::MacroDef(self.lazy(MacroDef {\n+            body: pprust::tts_to_string(macro_def.body.clone()),\n+            legacy: macro_def.legacy,\n+        })));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- macro_def.span);\n+        record!(self.per_def.attributes[def_id] <- &macro_def.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n     }\n \n     fn encode_info_for_generic_param(\n         &mut self,\n         def_id: DefId,\n-        entry_kind: EntryKind<'tcx>,\n+        kind: EntryKind<'tcx>,\n         encode_type: bool,\n-    ) -> Entry<'tcx> {\n-        let tcx = self.tcx;\n-        Entry {\n-            kind: entry_kind,\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-            ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n+    ) {\n+        record!(self.per_def.kind[def_id] <- kind);\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        if encode_type {\n+            self.encode_item_type(def_id);\n         }\n     }\n \n-    fn encode_info_for_ty_param(\n-        &mut self,\n-        (def_id, encode_type): (DefId, bool),\n-    ) -> Entry<'tcx> {\n-        debug!(\"EncodeContext::encode_info_for_ty_param({:?})\", def_id);\n-        self.encode_info_for_generic_param(def_id, EntryKind::TypeParam, encode_type)\n-    }\n-\n-    fn encode_info_for_const_param(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Entry<'tcx> {\n-        debug!(\"EncodeContext::encode_info_for_const_param({:?})\", def_id);\n-        self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true)\n-    }\n-\n-    fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n-        let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let kind = match tables.node_type(hir_id).kind {\n+\n+        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1428,61 +1339,32 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Closure(self.lazy(data))\n             }\n \n-            _ => bug!(\"closure that is neither generator nor closure\")\n-        };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+            _ => bug!(\"closure that is neither generator nor closure\"),\n+        });\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_anon_const(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let tcx = self.tcx;\n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let body_id = tcx.hir().body_owned_by(id);\n+        let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = tcx.mir_const_qualif(def_id).0;\n-\n-        Entry {\n-            kind: EntryKind::Const(ConstQualif { mir }, const_data),\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n-    }\n+        let mir = self.tcx.mir_const_qualif(def_id).0;\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n-        self.lazy(attrs)\n+        record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n@@ -1656,14 +1538,16 @@ impl EncodeContext<'tcx> {\n         Lazy::empty()\n     }\n \n-    fn encode_info_for_foreign_item(&mut self,\n-                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n-                                    -> Entry<'tcx> {\n+    fn encode_info_for_foreign_item(\n+        &mut self,\n+        def_id: DefId,\n+        nitem: &hir::ForeignItem,\n+    )  {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        let kind = match nitem.kind {\n+        record!(self.per_def.kind[def_id] <- match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1676,33 +1560,23 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n             hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n-        };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n-            span: self.lazy(nitem.span),\n-            attributes: self.encode_attributes(&nitem.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: match nitem.kind {\n-                hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => Lazy::empty(),\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n+        });\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n+        record!(self.per_def.span[def_id] <- nitem.span);\n+        record!(self.per_def.attributes[def_id] <- &nitem.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n     }\n }\n \n+// FIXME(eddyb) make metadata encoding walk over all definitions, instead of HIR.\n impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n@@ -1711,56 +1585,43 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         intravisit::walk_expr(self, ex);\n         self.encode_info_for_expr(ex);\n     }\n+    fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n+        intravisit::walk_anon_const(self, c);\n+        let def_id = self.tcx.hir().local_def_id(c.hir_id);\n+        self.encode_info_for_anon_const(def_id);\n+    }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n+            _ => self.encode_info_for_item(def_id, item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n-        self.record(def_id,\n-                          EncodeContext::encode_info_for_foreign_item,\n-                          (def_id, ni));\n-    }\n-    fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n-                     g: &'tcx hir::Generics,\n-                     id: hir::HirId) {\n-        intravisit::walk_variant(self, v, g, id);\n-\n-        if let Some(ref discr) = v.disr_expr {\n-            let def_id = self.tcx.hir().local_def_id(discr.hir_id);\n-            self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n-        }\n+        self.encode_info_for_foreign_item(def_id, ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        intravisit::walk_ty(self, ty);\n-        self.encode_info_for_ty(ty);\n-    }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+        self.encode_info_for_macro_def(macro_def);\n     }\n }\n \n impl EncodeContext<'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n-            for (field_index, field) in variant.fields.iter().enumerate() {\n-                self.record(field.did,\n-                            EncodeContext::encode_field,\n-                            (adt_def_id, variant_index, field_index));\n+            for (field_index, _field) in variant.fields.iter().enumerate() {\n+                // FIXME(eddyb) `adt_def_id` is leftover from incremental isolation,\n+                // pass `def`, `variant` or `field` instead.\n+                self.encode_field(adt_def_id, variant_index, field_index);\n             }\n         }\n     }\n@@ -1771,34 +1632,24 @@ impl EncodeContext<'tcx> {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => continue,\n                 GenericParamKind::Type { ref default, .. } => {\n-                    self.record(\n+                    self.encode_info_for_generic_param(\n                         def_id,\n-                        EncodeContext::encode_info_for_ty_param,\n-                        (def_id, default.is_some()),\n+                        EntryKind::TypeParam,\n+                        default.is_some(),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.record(def_id, EncodeContext::encode_info_for_const_param, def_id);\n+                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                 }\n             }\n         }\n     }\n \n-    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        match ty.kind {\n-            hir::TyKind::Array(_, ref length) => {\n-                let def_id = self.tcx.hir().local_def_id(length.hir_id);\n-                self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n+                self.encode_info_for_closure(def_id);\n             }\n             _ => {}\n         }\n@@ -1829,14 +1680,14 @@ impl EncodeContext<'tcx> {\n \n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    self.record(variant.def_id,\n-                                EncodeContext::encode_enum_variant_info,\n-                                (def_id, i));\n-\n-                    if let Some(ctor_def_id) = variant.ctor_def_id {\n-                        self.record(ctor_def_id,\n-                                    EncodeContext::encode_enum_variant_ctor,\n-                                    (def_id, i));\n+                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n+                    // pass `def` or `variant` instead.\n+                    self.encode_enum_variant_info(def_id, i);\n+\n+                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n+                    // pass `def`, `variant` or `ctor_def_id` instead.\n+                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n+                        self.encode_enum_variant_ctor(def_id, i);\n                     }\n                 }\n             }\n@@ -1846,26 +1697,20 @@ impl EncodeContext<'tcx> {\n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.record(ctor_def_id,\n-                                EncodeContext::encode_struct_ctor,\n-                                (def_id, ctor_def_id));\n+                    self.encode_struct_ctor(def_id, ctor_def_id);\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(trait_item_def_id,\n-                                EncodeContext::encode_info_for_impl_item,\n-                                trait_item_def_id);\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(item_def_id,\n-                                EncodeContext::encode_info_for_trait_item,\n-                                item_def_id);\n+                    self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n         }\n@@ -1920,7 +1765,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n@@ -1933,7 +1778,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n-            entries_index: Index::new(tcx.hir().definitions().def_index_count()),\n+            per_def: Default::default(),\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n@@ -1953,19 +1798,11 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n-    let pos = root.position;\n+    let pos = root.position.get();\n     result[header + 0] = (pos >> 24) as u8;\n     result[header + 1] = (pos >> 16) as u8;\n     result[header + 2] = (pos >> 8) as u8;\n     result[header + 3] = (pos >> 0) as u8;\n \n     EncodedMetadata { raw_data: result }\n }\n-\n-pub fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n-    let ty = tcx.type_of(did);\n-    match ty.kind {\n-        ty::Adt(ref def, _) => return def.repr,\n-        _ => bug!(\"{} is not an ADT\", ty),\n-    }\n-}"}, {"sha": "fa1402584eda50f7ba83eead17510d5b97e0b88e", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),"}, {"sha": "6f248f22cf2527502e3b60bbd39c9ea38788f810", "filename": "src/librustc_metadata/index.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43", "patch": "@@ -1,141 +0,0 @@\n-use crate::schema::*;\n-\n-use rustc::hir::def_id::{DefId, DefIndex};\n-use rustc_serialize::opaque::Encoder;\n-use std::marker::PhantomData;\n-use std::u32;\n-use log::debug;\n-\n-/// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n-pub trait FixedSizeEncoding {\n-    const BYTE_LEN: usize;\n-\n-    // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n-    // once that starts being allowed by the compiler (i.e. lazy normalization).\n-    fn from_bytes(b: &[u8]) -> Self;\n-    fn write_to_bytes(self, b: &mut [u8]);\n-\n-    // FIXME(eddyb) make these generic functions, or at least defaults here.\n-    // (same problem as above, needs `[u8; Self::BYTE_LEN]`)\n-    // For now, a macro (`fixed_size_encoding_byte_len_and_defaults`) is used.\n-    fn read_from_bytes_at(b: &[u8], i: usize) -> Self;\n-    fn write_to_bytes_at(self, b: &mut [u8], i: usize);\n-}\n-\n-// HACK(eddyb) this shouldn't be needed (see comments on the methods above).\n-macro_rules! fixed_size_encoding_byte_len_and_defaults {\n-    ($byte_len:expr) => {\n-        const BYTE_LEN: usize = $byte_len;\n-        fn read_from_bytes_at(b: &[u8], i: usize) -> Self {\n-            const BYTE_LEN: usize = $byte_len;\n-            // HACK(eddyb) ideally this would be done with fully safe code,\n-            // but slicing `[u8]` with `i * N..` is optimized worse, due to the\n-            // possibility of `i * N` overflowing, than indexing `[[u8; N]]`.\n-            let b = unsafe {\n-                std::slice::from_raw_parts(\n-                    b.as_ptr() as *const [u8; BYTE_LEN],\n-                    b.len() / BYTE_LEN,\n-                )\n-            };\n-            Self::from_bytes(&b[i])\n-        }\n-        fn write_to_bytes_at(self, b: &mut [u8], i: usize) {\n-            const BYTE_LEN: usize = $byte_len;\n-            // HACK(eddyb) ideally this would be done with fully safe code,\n-            // see similar comment in `read_from_bytes_at` for why it can't yet.\n-            let b = unsafe {\n-                std::slice::from_raw_parts_mut(\n-                    b.as_mut_ptr() as *mut [u8; BYTE_LEN],\n-                    b.len() / BYTE_LEN,\n-                )\n-            };\n-            self.write_to_bytes(&mut b[i]);\n-        }\n-    }\n-}\n-\n-impl FixedSizeEncoding for u32 {\n-    fixed_size_encoding_byte_len_and_defaults!(4);\n-\n-    fn from_bytes(b: &[u8]) -> Self {\n-        let mut bytes = [0; Self::BYTE_LEN];\n-        bytes.copy_from_slice(&b[..Self::BYTE_LEN]);\n-        Self::from_le_bytes(bytes)\n-    }\n-\n-    fn write_to_bytes(self, b: &mut [u8]) {\n-        b[..Self::BYTE_LEN].copy_from_slice(&self.to_le_bytes());\n-    }\n-}\n-\n-/// While we are generating the metadata, we also track the position\n-/// of each DefIndex. It is not required that all definitions appear\n-/// in the metadata, nor that they are serialized in order, and\n-/// therefore we first allocate the vector here and fill it with\n-/// `u32::MAX`. Whenever an index is visited, we fill in the\n-/// appropriate spot by calling `record_position`. We should never\n-/// visit the same index twice.\n-pub struct Index<'tcx> {\n-    positions: Vec<u8>,\n-    _marker: PhantomData<&'tcx ()>,\n-}\n-\n-impl Index<'tcx> {\n-    pub fn new(max_index: usize) -> Self {\n-        Index {\n-            positions: vec![0xff; max_index * 4],\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n-        assert!(def_id.is_local());\n-        self.record_index(def_id.index, entry);\n-    }\n-\n-    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n-        assert!(entry.position < (u32::MAX as usize));\n-        let position = entry.position as u32;\n-        let array_index = item.index();\n-\n-        let positions = &mut self.positions;\n-        assert!(u32::read_from_bytes_at(positions, array_index) == u32::MAX,\n-                \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n-                item,\n-                u32::read_from_bytes_at(positions, array_index),\n-                position);\n-\n-        position.write_to_bytes_at(positions, array_index)\n-    }\n-\n-    pub fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n-        let pos = buf.position();\n-\n-        // First we write the length of the lower range ...\n-        buf.emit_raw_bytes(&(self.positions.len() as u32 / 4).to_le_bytes());\n-        // ... then the values.\n-        buf.emit_raw_bytes(&self.positions);\n-        Lazy::from_position_and_meta(pos as usize, self.positions.len() / 4 + 1)\n-    }\n-}\n-\n-impl Lazy<[Index<'tcx>]> {\n-    /// Given the metadata, extract out the offset of a particular\n-    /// DefIndex (if any).\n-    #[inline(never)]\n-    pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        let bytes = &bytes[self.position..];\n-        debug!(\"Index::lookup: index={:?} len={:?}\",\n-               def_index,\n-               self.meta);\n-\n-        let position = u32::read_from_bytes_at(bytes, 1 + def_index.index());\n-        if position == u32::MAX {\n-            debug!(\"Index::lookup: position=u32::MAX\");\n-            None\n-        } else {\n-            debug!(\"Index::lookup: position={:?}\", position);\n-            Some(Lazy::from_position(position as usize))\n-        }\n-    }\n-}"}, {"sha": "291ee23ff7262d73917adb7dffcf3714888d8cec", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_patterns)]\n+#![feature(core_intrinsics)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n@@ -11,6 +12,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n+#![feature(stmt_expr_attributes)]\n \n #![recursion_limit=\"256\"]\n \n@@ -24,15 +26,15 @@ extern crate rustc_data_structures;\n \n pub mod error_codes;\n \n-mod index;\n mod encoder;\n mod decoder;\n+mod dependency_format;\n mod cstore_impl;\n-mod schema;\n-mod native_libs;\n-mod link_args;\n mod foreign_modules;\n-mod dependency_format;\n+mod link_args;\n+mod native_libs;\n+mod schema;\n+mod table;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "4291f3a4ae34e74358513fcd37f3cf9d931a9160", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };"}, {"sha": "05676dad3340c7553772ea73f362222ced55f033", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 36, "deletions": 53, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -212,13 +212,14 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::{MetadataRef, MetadataBlob};\n+use crate::cstore::{MetadataBlob, CStore};\n use crate::creader::Library;\n use crate::schema::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc_data_structures::sync::MetadataRef;\n+use rustc::middle::cstore::{CrateSource, MetadataLoader};\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n@@ -245,13 +246,13 @@ use rustc_data_structures::owning_ref::OwningRef;\n use log::{debug, info, warn};\n \n #[derive(Clone)]\n-pub struct CrateMismatch {\n+crate struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n #[derive(Clone)]\n-pub struct Context<'a> {\n+crate struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n     pub crate_name: Symbol,\n@@ -272,11 +273,9 @@ pub struct Context<'a> {\n     pub metadata_loader: &'a dyn MetadataLoader,\n }\n \n-pub struct CratePaths {\n-    pub ident: String,\n-    pub dylib: Option<PathBuf>,\n-    pub rlib: Option<PathBuf>,\n-    pub rmeta: Option<PathBuf>,\n+crate struct CratePaths {\n+    pub name: Symbol,\n+    pub source: CrateSource,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -296,22 +295,16 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n-impl CratePaths {\n-    fn paths(&self) -> Vec<PathBuf> {\n-        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).cloned().collect()\n-    }\n-}\n-\n impl<'a> Context<'a> {\n-    pub fn reset(&mut self) {\n+    crate fn reset(&mut self) {\n         self.rejected_via_hash.clear();\n         self.rejected_via_triple.clear();\n         self.rejected_via_kind.clear();\n         self.rejected_via_version.clear();\n         self.rejected_via_filename.clear();\n     }\n \n-    pub fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+    crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n             Some(s) => self.find_library_crate(s, &mut seen_paths)\n@@ -320,10 +313,10 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    pub fn report_errs(self) -> ! {\n+    crate fn report_errs(self) -> ! {\n         let add = match self.root {\n             None => String::new(),\n-            Some(r) => format!(\" which `{}` depends on\", r.ident),\n+            Some(r) => format!(\" which `{}` depends on\", r.name),\n         };\n         let mut msg = \"the following crate versions were found:\".to_string();\n         let mut err = if !self.rejected_via_hash.is_empty() {\n@@ -341,8 +334,8 @@ impl<'a> Context<'a> {\n             match self.root {\n                 None => {}\n                 Some(r) => {\n-                    for path in r.paths().iter() {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.ident, path.display()));\n+                    for path in r.source.paths() {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n                     }\n                 }\n             }\n@@ -534,18 +527,8 @@ impl<'a> Context<'a> {\n         // search is being performed for.\n         let mut libraries = FxHashMap::default();\n         for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n-            let mut slot = None;\n-            let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n-            let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n-            let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n-            if let Some((h, m)) = slot {\n-                libraries.insert(h,\n-                                 Library {\n-                                     dylib,\n-                                     rlib,\n-                                     rmeta,\n-                                     metadata: m,\n-                                 });\n+            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs) {\n+                libraries.insert(svh, lib);\n             }\n         }\n \n@@ -563,7 +546,7 @@ impl<'a> Context<'a> {\n                                                self.crate_name);\n                 let candidates = libraries.iter().filter_map(|(_, lib)| {\n                     let crate_name = &lib.metadata.get_root().name.as_str();\n-                    match &(&lib.dylib, &lib.rlib) {\n+                    match &(&lib.source.dylib, &lib.source.rlib) {\n                         &(&Some((ref pd, _)), &Some((ref pr, _))) => {\n                             Some(format!(\"\\ncrate `{}`: {}\\n{:>padding$}\",\n                                          crate_name,\n@@ -584,6 +567,21 @@ impl<'a> Context<'a> {\n         }\n     }\n \n+    fn extract_lib(\n+        &mut self,\n+        rlibs: FxHashMap<PathBuf, PathKind>,\n+        rmetas: FxHashMap<PathBuf, PathKind>,\n+        dylibs: FxHashMap<PathBuf, PathKind>,\n+    ) -> Option<(Svh, Library)> {\n+        let mut slot = None;\n+        let source = CrateSource {\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n+            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n+            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n+        };\n+        slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n+    }\n+\n     // Attempts to extract *one* library from the set `m`. If the set has no\n     // elements, `None` is returned. If the set has more than one element, then\n     // the errors and notes are emitted about the set of libraries.\n@@ -828,23 +826,8 @@ impl<'a> Context<'a> {\n             }\n         };\n \n-        // Extract the rlib/dylib pair.\n-        let mut slot = None;\n-        let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n-        let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n-        let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n-\n-        if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n-            return None;\n-        }\n-        slot.map(|(_, metadata)|\n-            Library {\n-                dylib,\n-                rlib,\n-                rmeta,\n-                metadata,\n-            }\n-        )\n+        // Extract the dylib/rlib/rmeta triple.\n+        self.extract_lib(rlibs, rmetas, dylibs).map(|(_, lib)| lib)\n     }\n }\n \n@@ -931,7 +914,7 @@ fn get_metadata_section_imp(target: &Target,\n /// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          loader: &dyn MetadataLoader,\n+                          cstore: &CStore,\n                           out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -942,7 +925,7 @@ pub fn list_file_metadata(target: &Target,\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path, loader) {\n+    match get_metadata_section(target, flavor, path, &*cstore.metadata_loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "9e4c2685f11626f6744cf8f0b197d9de2a530145", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),\n@@ -21,7 +21,7 @@ pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     return collector.libs;\n }\n \n-pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+crate fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,\n@@ -73,6 +73,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         \"static-nobundle\" => cstore::NativeStaticNobundle,\n                         \"dylib\" => cstore::NativeUnknown,\n                         \"framework\" => cstore::NativeFramework,\n+                        \"raw-dylib\" => cstore::NativeRawDylib,\n                         k => {\n                             struct_span_err!(self.tcx.sess, item.span(), E0458,\n                                       \"unknown kind: `{}`\", k)\n@@ -169,6 +170,14 @@ impl Collector<'tcx> {\n                                            GateIssue::Language,\n                                            \"kind=\\\"static-nobundle\\\" is unstable\");\n         }\n+        if lib.kind == cstore::NativeRawDylib &&\n+           !self.tcx.features().raw_dylib {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           sym::raw_dylib,\n+                                           span.unwrap_or_else(|| syntax_pos::DUMMY_SP),\n+                                           GateIssue::Language,\n+                                           \"kind=\\\"raw-dylib\\\" is unstable\");\n+        }\n         self.libs.push(lib);\n     }\n "}, {"sha": "96f35783278fa5784d21821ce3b949944cabb262", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 88, "deletions": 76, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,4 +1,4 @@\n-use crate::index;\n+use crate::table::PerDefTable;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -14,22 +14,24 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n \n+use rustc_serialize::Encodable;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n+use std::num::NonZeroUsize;\n \n-pub fn rustc_version() -> String {\n+crate fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n /// Metadata encoding version.\n /// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n-pub const METADATA_VERSION: u8 = 4;\n+const METADATA_VERSION: u8 = 4;\n \n /// Metadata header which includes `METADATA_VERSION`.\n /// To get older versions of rustc to ignore this metadata,\n@@ -39,20 +41,20 @@ pub const METADATA_VERSION: u8 = 4;\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-pub const METADATA_HEADER: &[u8; 12] =\n+crate const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n-pub trait LazyMeta {\n+crate trait LazyMeta {\n     type Meta: Copy + 'static;\n \n     /// Returns the minimum encoded size.\n     // FIXME(eddyb) Give better estimates for certain types.\n     fn min_size(meta: Self::Meta) -> usize;\n }\n \n-impl<T> LazyMeta for T {\n+impl<T: Encodable> LazyMeta for T {\n     type Meta = ();\n \n     fn min_size(_: ()) -> usize {\n@@ -61,7 +63,7 @@ impl<T> LazyMeta for T {\n     }\n }\n \n-impl<T> LazyMeta for [T] {\n+impl<T: Encodable> LazyMeta for [T] {\n     type Meta = usize;\n \n     fn min_size(len: usize) -> usize {\n@@ -98,17 +100,17 @@ impl<T> LazyMeta for [T] {\n #[must_use]\n // FIXME(#59875) the `Meta` parameter only exists to dodge\n // invariance wrt `T` (coming from the `meta: T::Meta` field).\n-pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n-    pub position: usize,\n+    pub position: NonZeroUsize,\n     pub meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-    pub fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+     crate fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -117,15 +119,15 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n     }\n }\n \n-impl<T> Lazy<T> {\n-    pub fn from_position(position: usize) -> Lazy<T> {\n+impl<T: Encodable> Lazy<T> {\n+    crate fn from_position(position: NonZeroUsize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n-impl<T> Lazy<[T]> {\n-    pub fn empty() -> Lazy<[T]> {\n-        Lazy::from_position_and_meta(0, 0)\n+impl<T: Encodable> Lazy<[T]> {\n+    crate fn empty() -> Lazy<[T]> {\n+        Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n     }\n }\n \n@@ -141,22 +143,32 @@ impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T>\n \n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum LazyState {\n+crate enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n     /// Inside a metadata node, and before any `Lazy`.\n     /// The position is that of the node itself.\n-    NodeStart(usize),\n+    NodeStart(NonZeroUsize),\n \n     /// Inside a metadata node, with a previous `Lazy`.\n     /// The position is a conservative estimate of where that\n     /// previous `Lazy` would end (see their comments).\n-    Previous(usize),\n+    Previous(NonZeroUsize),\n+}\n+\n+// FIXME(#59875) `Lazy!(T)` replaces `Lazy<T>`, passing the `Meta` parameter\n+// manually, instead of relying on the default, to get the correct variance.\n+// Only needed when `T` itself contains a parameter (e.g. `'tcx`).\n+macro_rules! Lazy {\n+    (Table<$T:ty>) => {Lazy<Table<$T>, usize>};\n+    (PerDefTable<$T:ty>) => {Lazy<PerDefTable<$T>, usize>};\n+    ([$T:ty]) => {Lazy<[$T], usize>};\n+    ($T:ty) => {Lazy<$T, ()>};\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateRoot<'tcx> {\n+crate struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n     pub extra_filename: String,\n@@ -182,10 +194,10 @@ pub struct CrateRoot<'tcx> {\n     pub source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: Lazy<[TraitImpls]>,\n-    pub exported_symbols: Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]>,\n+    pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub entries_index: Lazy<[index::Index<'tcx>]>,\n+    pub per_def: LazyPerDefTables<'tcx>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n@@ -202,42 +214,42 @@ pub struct CrateRoot<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateDep {\n+crate struct CrateDep {\n     pub name: ast::Name,\n     pub hash: Svh,\n     pub kind: DepKind,\n     pub extra_filename: String,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitImpls {\n+crate struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Entry<'tcx> {\n-    pub kind: EntryKind<'tcx>,\n-    pub visibility: Lazy<ty::Visibility>,\n-    pub span: Lazy<Span>,\n-    pub attributes: Lazy<[ast::Attribute]>,\n-    pub children: Lazy<[DefIndex]>,\n-    pub stability: Option<Lazy<attr::Stability>>,\n-    pub deprecation: Option<Lazy<attr::Deprecation>>,\n-\n-    pub ty: Option<Lazy<Ty<'tcx>>>,\n-    pub inherent_impls: Lazy<[DefIndex]>,\n-    pub variances: Lazy<[ty::Variance]>,\n-    pub generics: Option<Lazy<ty::Generics>>,\n-    pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n-    pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n-\n-    pub mir: Option<Lazy<mir::Body<'tcx>>>,\n-    pub promoted_mir: Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+crate struct LazyPerDefTables<'tcx> {\n+    pub kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n+    pub visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n+    pub span: Lazy!(PerDefTable<Lazy<Span>>),\n+    pub attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n+    pub children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    pub stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n+    pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n+\n+    pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n+    pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n+    pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+\n+    pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n+    pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum EntryKind<'tcx> {\n+crate enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n@@ -252,104 +264,104 @@ pub enum EntryKind<'tcx> {\n     OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData<'tcx>>),\n-    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n-    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n-    Fn(Lazy<FnData<'tcx>>),\n-    ForeignFn(Lazy<FnData<'tcx>>),\n+    Variant(Lazy!(VariantData<'tcx>)),\n+    Struct(Lazy!(VariantData<'tcx>), ReprOptions),\n+    Union(Lazy!(VariantData<'tcx>), ReprOptions),\n+    Fn(Lazy!(FnData<'tcx>)),\n+    ForeignFn(Lazy!(FnData<'tcx>)),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n-    Closure(Lazy<ClosureData<'tcx>>),\n-    Generator(Lazy<GeneratorData<'tcx>>),\n-    Trait(Lazy<TraitData<'tcx>>),\n-    Impl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData<'tcx>>),\n+    Closure(Lazy!(ClosureData<'tcx>)),\n+    Generator(Lazy!(GeneratorData<'tcx>)),\n+    Trait(Lazy!(TraitData<'tcx>)),\n+    Impl(Lazy!(ImplData<'tcx>)),\n+    Method(Lazy!(MethodData<'tcx>)),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n-    TraitAlias(Lazy<TraitAliasData<'tcx>>),\n+    TraitAlias(Lazy!(TraitAliasData<'tcx>)),\n }\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-pub struct ConstQualif {\n+crate struct ConstQualif {\n     pub mir: u8,\n }\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct RenderedConst(pub String);\n+crate struct RenderedConst(pub String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ModData {\n+crate struct ModData {\n     pub reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MacroDef {\n+crate struct MacroDef {\n     pub body: String,\n     pub legacy: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData<'tcx> {\n+crate struct FnData<'tcx> {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n-    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n+    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData<'tcx> {\n+crate struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n     pub ctor: Option<DefIndex>,\n     /// If this is a tuple struct or variant\n     /// ctor, this is its \"function\" signature.\n-    pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n+    pub ctor_sig: Option<Lazy!(ty::PolyFnSig<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitData<'tcx> {\n+crate struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n     pub is_marker: bool,\n-    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n+    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitAliasData<'tcx> {\n-    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n+crate struct TraitAliasData<'tcx> {\n+    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ImplData<'tcx> {\n+crate struct ImplData<'tcx> {\n     pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n     pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n-    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n+    pub trait_ref: Option<Lazy!(ty::TraitRef<'tcx>)>,\n }\n \n \n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AssocContainer {\n+crate enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n     ImplFinal,\n }\n \n impl AssocContainer {\n-    pub fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n+    crate fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n         match *self {\n             AssocContainer::TraitRequired |\n             AssocContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -359,7 +371,7 @@ impl AssocContainer {\n         }\n     }\n \n-    pub fn defaultness(&self) -> hir::Defaultness {\n+    crate fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n             AssocContainer::TraitRequired => hir::Defaultness::Default {\n                 has_value: false,\n@@ -376,22 +388,22 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData<'tcx> {\n+crate struct MethodData<'tcx> {\n     pub fn_data: FnData<'tcx>,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ClosureData<'tcx> {\n-    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n+crate struct ClosureData<'tcx> {\n+    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct GeneratorData<'tcx> {\n+crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n \n // Tags used for encoding Spans:\n-pub const TAG_VALID_SPAN: u8 = 0;\n-pub const TAG_INVALID_SPAN: u8 = 1;\n+crate const TAG_VALID_SPAN: u8 = 0;\n+crate const TAG_INVALID_SPAN: u8 = 1;"}, {"sha": "e164c28c953bc8b7d76f2fc46f44834a52404e65", "filename": "src/librustc_metadata/table.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_metadata%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftable.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -0,0 +1,239 @@\n+use crate::decoder::Metadata;\n+use crate::schema::*;\n+\n+use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc_serialize::{Encodable, opaque::Encoder};\n+use std::convert::TryInto;\n+use std::marker::PhantomData;\n+use std::num::NonZeroUsize;\n+use log::debug;\n+\n+/// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n+/// Used mainly for Lazy positions and lengths.\n+/// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n+/// but this has no impact on safety.\n+crate trait FixedSizeEncoding: Default {\n+    const BYTE_LEN: usize;\n+\n+    // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n+    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+    fn from_bytes(b: &[u8]) -> Self;\n+    fn write_to_bytes(self, b: &mut [u8]);\n+\n+    // FIXME(eddyb) make these generic functions, or at least defaults here.\n+    // (same problem as above, needs `[u8; Self::BYTE_LEN]`)\n+    // For now, a macro (`fixed_size_encoding_byte_len_and_defaults`) is used.\n+\n+    /// Read a `Self` value (encoded as `Self::BYTE_LEN` bytes),\n+    /// from `&b[i * Self::BYTE_LEN..]`, returning `None` if `i`\n+    /// is not in bounds, or `Some(Self::from_bytes(...))` otherwise.\n+    fn maybe_read_from_bytes_at(b: &[u8], i: usize) -> Option<Self>;\n+    /// Write a `Self` value (encoded as `Self::BYTE_LEN` bytes),\n+    /// at `&mut b[i * Self::BYTE_LEN..]`, using `Self::write_to_bytes`.\n+    fn write_to_bytes_at(self, b: &mut [u8], i: usize);\n+}\n+\n+// HACK(eddyb) this shouldn't be needed (see comments on the methods above).\n+macro_rules! fixed_size_encoding_byte_len_and_defaults {\n+    ($byte_len:expr) => {\n+        const BYTE_LEN: usize = $byte_len;\n+        fn maybe_read_from_bytes_at(b: &[u8], i: usize) -> Option<Self> {\n+            const BYTE_LEN: usize = $byte_len;\n+            // HACK(eddyb) ideally this would be done with fully safe code,\n+            // but slicing `[u8]` with `i * N..` is optimized worse, due to the\n+            // possibility of `i * N` overflowing, than indexing `[[u8; N]]`.\n+            let b = unsafe {\n+                std::slice::from_raw_parts(\n+                    b.as_ptr() as *const [u8; BYTE_LEN],\n+                    b.len() / BYTE_LEN,\n+                )\n+            };\n+            b.get(i).map(|b| FixedSizeEncoding::from_bytes(b))\n+        }\n+        fn write_to_bytes_at(self, b: &mut [u8], i: usize) {\n+            const BYTE_LEN: usize = $byte_len;\n+            // HACK(eddyb) ideally this would be done with fully safe code,\n+            // see similar comment in `read_from_bytes_at` for why it can't yet.\n+            let b = unsafe {\n+                std::slice::from_raw_parts_mut(\n+                    b.as_mut_ptr() as *mut [u8; BYTE_LEN],\n+                    b.len() / BYTE_LEN,\n+                )\n+            };\n+            self.write_to_bytes(&mut b[i]);\n+        }\n+    }\n+}\n+\n+impl FixedSizeEncoding for u32 {\n+    fixed_size_encoding_byte_len_and_defaults!(4);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        let mut bytes = [0; Self::BYTE_LEN];\n+        bytes.copy_from_slice(&b[..Self::BYTE_LEN]);\n+        Self::from_le_bytes(bytes)\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        b[..Self::BYTE_LEN].copy_from_slice(&self.to_le_bytes());\n+    }\n+}\n+\n+// NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n+// generic `Lazy<T>` impl, but in the general case we might not need / want to\n+// fit every `usize` in `u32`.\n+impl<T: Encodable> FixedSizeEncoding for Option<Lazy<T>> {\n+    fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        Some(Lazy::from_position(NonZeroUsize::new(u32::from_bytes(b) as usize)?))\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        let position = self.map_or(0, |lazy| lazy.position.get());\n+        let position: u32 = position.try_into().unwrap();\n+\n+        position.write_to_bytes(b)\n+    }\n+}\n+\n+impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n+    fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN * 2);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        Some(Lazy::from_position_and_meta(\n+            <Option<Lazy<T>>>::from_bytes(b)?.position,\n+            u32::from_bytes(&b[u32::BYTE_LEN..]) as usize,\n+        ))\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        self.map(|lazy| Lazy::<T>::from_position(lazy.position))\n+            .write_to_bytes(b);\n+\n+        let len = self.map_or(0, |lazy| lazy.meta);\n+        let len: u32 = len.try_into().unwrap();\n+\n+        len.write_to_bytes(&mut b[u32::BYTE_LEN..]);\n+    }\n+}\n+\n+/// Random-access table (i.e. offeringconstant-time `get`/`set`), similar to\n+/// `Vec<Option<T>>`, but without requiring encoding or decoding all the values\n+/// eagerly and in-order.\n+/// A total of `(max_idx + 1) * <Option<T> as FixedSizeEncoding>::BYTE_LEN` bytes\n+/// are used for a table, where `max_idx` is the largest index passed to `set`.\n+// FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n+// when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n+// (not sure if that is possible given that the `Vec` is being resized now)\n+crate struct Table<T> where Option<T>: FixedSizeEncoding {\n+    // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n+    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+    bytes: Vec<u8>,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n+    fn default() -> Self {\n+        Table {\n+            bytes: vec![],\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n+    crate fn set(&mut self, i: usize, value: T) {\n+        // FIXME(eddyb) investigate more compact encodings for sparse tables.\n+        // On the PR @michaelwoerister mentioned:\n+        // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n+        // > trick (i.e. divide things into buckets of 32 or 64 items and then\n+        // > store bit-masks of which item in each bucket is actually serialized).\n+        let needed = (i + 1) * <Option<T>>::BYTE_LEN;\n+        if self.bytes.len() < needed {\n+            self.bytes.resize(needed, 0);\n+        }\n+\n+        Some(value).write_to_bytes_at(&mut self.bytes, i);\n+    }\n+\n+    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+        let pos = buf.position();\n+        buf.emit_raw_bytes(&self.bytes);\n+        Lazy::from_position_and_meta(\n+            NonZeroUsize::new(pos as usize).unwrap(),\n+            self.bytes.len(),\n+        )\n+    }\n+}\n+\n+impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n+    type Meta = usize;\n+\n+    fn min_size(len: usize) -> usize {\n+        len\n+    }\n+}\n+\n+impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n+    /// Given the metadata, extract out the value at a particular index (if any).\n+    #[inline(never)]\n+    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+        &self,\n+        metadata: M,\n+        i: usize,\n+    ) -> Option<T> {\n+        debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n+\n+        let start = self.position.get();\n+        let bytes = &metadata.raw_bytes()[start..start + self.meta];\n+        <Option<T>>::maybe_read_from_bytes_at(bytes, i)?\n+    }\n+}\n+\n+/// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n+// FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n+// and by using `newtype_index!` to define `DefIndex`.\n+crate struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n+\n+impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n+    fn default() -> Self {\n+        PerDefTable(Table::default())\n+    }\n+}\n+\n+impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n+    crate fn set(&mut self, def_id: DefId, value: T) {\n+        assert!(def_id.is_local());\n+        self.0.set(def_id.index.index(), value);\n+    }\n+\n+    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+        let lazy = self.0.encode(buf);\n+        Lazy::from_position_and_meta(lazy.position, lazy.meta)\n+    }\n+}\n+\n+impl<T> LazyMeta for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n+    type Meta = <Table<T> as LazyMeta>::Meta;\n+\n+    fn min_size(meta: Self::Meta) -> usize {\n+        Table::<T>::min_size(meta)\n+    }\n+}\n+\n+impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n+    fn as_table(&self) -> Lazy<Table<T>> {\n+        Lazy::from_position_and_meta(self.position, self.meta)\n+    }\n+\n+    /// Given the metadata, extract out the value at a particular DefIndex (if any).\n+    #[inline(never)]\n+    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+        &self,\n+        metadata: M,\n+        def_index: DefIndex,\n+    ) -> Option<T> {\n+        self.as_table().get(metadata, def_index.index())\n+    }\n+}"}, {"sha": "098258994f4e2a8c31f0ba65163ceb47568ca934", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n     LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n@@ -750,6 +751,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n         let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n+        debug!(\n+            \"report_borrowed_value_does_not_live_long_enough(place_desc: {:?}, explanation: {:?})\",\n+            place_desc,\n+            explanation\n+        );\n         let err = match (place_desc, explanation) {\n             (Some(_), _) if self.is_place_thread_local(root_place) => {\n                 self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n@@ -783,7 +789,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     ..\n                 },\n             ) if borrow_spans.for_closure() => self.report_escaping_closure_capture(\n-                borrow_spans.args_or_use(),\n+                borrow_spans,\n+                borrow_span,\n+                region_name,\n+                category,\n+                span,\n+                &format!(\"`{}`\", name),\n+            ),\n+            (\n+                Some(ref name),\n+                BorrowExplanation::MustBeValidFor {\n+                    category: category @ ConstraintCategory::OpaqueType,\n+                    from_closure: false,\n+                    ref region_name,\n+                    span,\n+                    ..\n+                },\n+\n+            ) if borrow_spans.for_generator() => self.report_escaping_closure_capture(\n+                borrow_spans,\n                 borrow_span,\n                 region_name,\n                 category,\n@@ -1172,15 +1196,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn report_escaping_closure_capture(\n         &mut self,\n-        args_span: Span,\n+        use_span: UseSpans,\n         var_span: Span,\n         fr_name: &RegionName,\n         category: ConstraintCategory,\n         constraint_span: Span,\n         captured_var: &str,\n     ) -> DiagnosticBuilder<'cx> {\n         let tcx = self.infcx.tcx;\n-\n+        let args_span = use_span.args_or_use();\n         let mut err = self.cannot_capture_in_long_lived_closure(\n             args_span,\n             captured_var,\n@@ -1200,12 +1224,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             },\n             Err(_) => \"move |<args>| <body>\".to_string()\n         };\n-\n+        let kind = match use_span.generator_kind() {\n+            Some(generator_kind) => match generator_kind {\n+                GeneratorKind::Async(async_kind) => match async_kind {\n+                    AsyncGeneratorKind::Block => \"async block\",\n+                    AsyncGeneratorKind::Closure => \"async closure\",\n+                    _ => bug!(\"async block/closure expected, but async funtion found.\"),\n+                },\n+                GeneratorKind::Gen => \"generator\",\n+            }\n+            None => \"closure\",\n+        };\n         err.span_suggestion(\n             args_span,\n-            &format!(\"to force the closure to take ownership of {} (and any \\\n-                      other referenced variables), use the `move` keyword\",\n-                      captured_var),\n+            &format!(\n+                \"to force the {} to take ownership of {} (and any \\\n+                 other referenced variables), use the `move` keyword\",\n+                 kind,\n+                 captured_var\n+            ),\n             suggestion,\n             Applicability::MachineApplicable,\n         );\n@@ -1214,6 +1251,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             ConstraintCategory::Return => {\n                 err.span_note(constraint_span, \"closure is returned here\");\n             }\n+            ConstraintCategory::OpaqueType => {\n+                err.span_note(constraint_span, \"generator is returned here\");\n+            }\n             ConstraintCategory::CallArgument => {\n                 fr_name.highlight_region_name(&mut err);\n                 err.span_note("}, {"sha": "5e0727d51579fd70d518903f7d690816e0994d35", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::GeneratorKind;\n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind,\n@@ -14,7 +15,7 @@ use syntax_pos::Span;\n use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n-use super::{MirBorrowckCtxt};\n+use super::MirBorrowckCtxt;\n use crate::dataflow::move_paths::{InitLocation, LookupResult};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n@@ -604,7 +605,7 @@ pub(super) enum UseSpans {\n     // The access is caused by capturing a variable for a closure.\n     ClosureUse {\n         // This is true if the captured variable was from a generator.\n-        is_generator: bool,\n+        generator_kind: Option<GeneratorKind>,\n         // The span of the args of the closure, including the `move` keyword if\n         // it's present.\n         args_span: Span,\n@@ -631,6 +632,13 @@ impl UseSpans {\n         }\n     }\n \n+    pub(super) fn generator_kind(self) -> Option<GeneratorKind> {\n+        match self {\n+            UseSpans::ClosureUse { generator_kind, .. } => generator_kind,\n+            _ => None,\n+        }\n+    }\n+\n     // Add a span label to the arguments of the closure, if it exists.\n     pub(super) fn args_span_label(\n         self,\n@@ -656,23 +664,23 @@ impl UseSpans {\n     /// Returns `false` if this place is not used in a closure.\n     pub(super) fn for_closure(&self) -> bool {\n         match *self {\n-            UseSpans::ClosureUse { is_generator, .. } => !is_generator,\n+            UseSpans::ClosureUse { generator_kind, .. } => generator_kind.is_none(),\n             _ => false,\n         }\n     }\n \n     /// Returns `false` if this place is not used in a generator.\n     pub(super) fn for_generator(&self) -> bool {\n         match *self {\n-            UseSpans::ClosureUse { is_generator, .. } => is_generator,\n+            UseSpans::ClosureUse { generator_kind, .. } => generator_kind.is_some(),\n             _ => false,\n         }\n     }\n \n     /// Describe the span associated with a use of a place.\n     pub(super) fn describe(&self) -> String {\n         match *self {\n-            UseSpans::ClosureUse { is_generator, .. } => if is_generator {\n+            UseSpans::ClosureUse { generator_kind, .. } => if generator_kind.is_some() {\n                 \" in generator\".to_string()\n             } else {\n                 \" in closure\".to_string()\n@@ -794,19 +802,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let  StatementKind::Assign(\n             box(_, Rvalue::Aggregate(ref kind, ref places))\n         ) = stmt.kind {\n-            let (def_id, is_generator) = match kind {\n-                box AggregateKind::Closure(def_id, _) => (def_id, false),\n-                box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n+            let def_id = match kind {\n+                box AggregateKind::Closure(def_id, _)\n+                | box AggregateKind::Generator(def_id, _, _) => def_id,\n                 _ => return OtherUse(stmt.source_info.span),\n             };\n \n             debug!(\n-                \"move_spans: def_id={:?} is_generator={:?} places={:?}\",\n-                def_id, is_generator, places\n+                \"move_spans: def_id={:?} places={:?}\",\n+                def_id, places\n             );\n-            if let Some((args_span, var_span)) = self.closure_span(*def_id, moved_place, places) {\n+            if let Some((args_span, generator_kind, var_span))\n+                = self.closure_span(*def_id, moved_place, places) {\n                 return ClosureUse {\n-                    is_generator,\n+                    generator_kind,\n                     args_span,\n                     var_span,\n                 };\n@@ -857,11 +866,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"borrow_spans: def_id={:?} is_generator={:?} places={:?}\",\n                     def_id, is_generator, places\n                 );\n-                if let Some((args_span, var_span)) = self.closure_span(\n+                if let Some((args_span, generator_kind, var_span)) = self.closure_span(\n                     *def_id, Place::from(target).as_ref(), places\n                 ) {\n                     return ClosureUse {\n-                        is_generator,\n+                        generator_kind,\n                         args_span,\n                         var_span,\n                     };\n@@ -884,7 +893,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         def_id: DefId,\n         target_place: PlaceRef<'cx, 'tcx>,\n         places: &Vec<Operand<'tcx>>,\n-    ) -> Option<(Span, Span)> {\n+    ) -> Option<(Span, Option<GeneratorKind>, Span)> {\n         debug!(\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n@@ -893,14 +902,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(\n-            .., args_span, _\n+            .., body_id, args_span, _\n         ) = expr {\n             for (upvar, place) in self.infcx.tcx.upvars(def_id)?.values().zip(places) {\n                 match place {\n                     Operand::Copy(place) |\n                     Operand::Move(place) if target_place == place.as_ref() => {\n                         debug!(\"closure_span: found captured local {:?}\", place);\n-                        return Some((*args_span, upvar.span));\n+                        let body = self.infcx.tcx.hir().body(*body_id);\n+                        let generator_kind = body.generator_kind();\n+                        return Some((*args_span, generator_kind, upvar.span));\n                     },\n                     _ => {}\n                 }"}, {"sha": "75d4b56fdb7c20480890b3e62c44380ef7ac0651", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1944,14 +1944,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.is_mutable(place.as_ref(), is_local_mutation_allowed),\n                     self.errors_buffer.is_empty()\n                 ) {\n-                    // rust-lang/rust#46908: In pure NLL mode this code path should\n-                    // be unreachable (and thus we signal an ICE in the else branch here).\n-                    span_bug!(\n-                        span,\n+                    // rust-lang/rust#46908: In pure NLL mode this code path should be\n+                    // unreachable, but we use `delay_span_bug` because we can hit this when\n+                    // dereferencing a non-Copy raw pointer *and* have `-Ztreat-err-as-bug`\n+                    // enabled. We don't want to ICE for that case, as other errors will have\n+                    // been emitted (#52262).\n+                    self.infcx.tcx.sess.delay_span_bug(span, &format!(\n                         \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n                         place,\n                         kind,\n-                    );\n+                    ));\n                 }\n                 return false;\n             }"}, {"sha": "b105664399a5cbb6bd1ef6ea36adc1048f73388e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{\n     SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, GeneratorSubsts, RegionVid, Ty};\n+use rustc::ty::{self, RegionVid, Ty};\n use rustc::ty::subst::SubstsRef;\n \n pub(super) fn generate_constraints<'cx, 'tcx>(\n@@ -91,13 +91,6 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n         self.super_ty(ty);\n     }\n \n-    /// We sometimes have `generator_substs` within an rvalue, or within a\n-    /// call. Make them live at the location where they appear.\n-    fn visit_generator_substs(&mut self, substs: &GeneratorSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location);\n-        self.super_generator_substs(substs);\n-    }\n-\n     fn visit_statement(\n         &mut self,\n         statement: &Statement<'tcx>,"}, {"sha": "59b2796db7abe2c6f9fded0e539a41d97612720c", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -17,6 +17,7 @@ use syntax_pos::Span;\n \n mod find_use;\n \n+#[derive(Debug)]\n pub(in crate::borrow_check) enum BorrowExplanation {\n     UsedLater(LaterUseKind, Span),\n     UsedLaterInLoop(LaterUseKind, Span),\n@@ -35,7 +36,7 @@ pub(in crate::borrow_check) enum BorrowExplanation {\n     Unexplained,\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub(in crate::borrow_check) enum LaterUseKind {\n     TraitCapture,\n     ClosureCapture,\n@@ -457,7 +458,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// True if an edge `source -> target` is a backedge -- in other words, if the target\n     /// dominates the source.\n     fn is_back_edge(&self, source: Location, target: Location) -> bool {\n-        target.dominates(source, &self.body.dominators())\n+        target.dominates(source, &self.dominators)\n     }\n \n     /// Determine how the borrow was later used."}, {"sha": "9ecd6f837750e797365b467b434a4d818dcaf5ad", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Body, Promoted};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::mir::{Body, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_index::vec::IndexVec;\n@@ -62,6 +62,21 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n+    fn process_projection_elem(\n+        &mut self,\n+        elem: &PlaceElem<'tcx>,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        if let PlaceElem::Field(field, ty) = elem {\n+            let new_ty = self.renumber_regions(ty);\n+\n+            if new_ty != *ty {\n+                return Some(PlaceElem::Field(*field, new_ty));\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n         debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n \n@@ -82,18 +97,4 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n     fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _location: Location) {\n         *constant = self.renumber_regions(&*constant);\n     }\n-\n-    fn visit_generator_substs(&mut self,\n-                              substs: &mut GeneratorSubsts<'tcx>,\n-                              location: Location) {\n-        debug!(\n-            \"visit_generator_substs(substs={:?}, location={:?})\",\n-            substs,\n-            location,\n-        );\n-\n-        *substs = self.renumber_regions(substs);\n-\n-        debug!(\"visit_generator_substs: substs={:?}\", substs);\n-    }\n }"}, {"sha": "ed639e8eee7747efe171f506a731b0033d6d1b17", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -759,13 +759,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             PlaceTy { ty, variant_index: Some(variant_index) } => match ty.kind {\n                 ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n                 ty::Generator(def_id, substs, _) => {\n-                    let mut variants = substs.state_tys(def_id, tcx);\n+                    let mut variants = substs.as_generator().state_tys(def_id, tcx);\n                     let mut variant = match variants.nth(variant_index.into()) {\n                         Some(v) => v,\n                         None => {\n                             bug!(\"variant_index of generator out of range: {:?}/{:?}\",\n                                  variant_index,\n-                                 substs.state_tys(def_id, tcx).count())\n+                                 substs.as_generator().state_tys(def_id, tcx).count())\n                         }\n                     };\n                     return match variant.nth(field.index()) {\n@@ -791,10 +791,10 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 ty::Generator(def_id, substs, _) => {\n                     // Only prefix fields (upvars and current state) are\n                     // accessible without a variant index.\n-                    return match substs.prefix_tys(def_id, tcx).nth(field.index()) {\n+                    return match substs.as_generator().prefix_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.prefix_tys(def_id, tcx).count(),\n+                            field_count: substs.as_generator().prefix_tys(def_id, tcx).count(),\n                         }),\n                     }\n                 }\n@@ -1396,7 +1396,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n \n                 let place_ty = place.ty(body, tcx).ty;\n+                let place_ty = self.normalize(place_ty, location);\n                 let rv_ty = rv.ty(body, tcx);\n+                let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n                 {\n@@ -1672,6 +1674,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         match *destination {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(body, tcx).ty;\n+                let dest_ty = self.normalize(dest_ty, term_location);\n                 let category = match *dest {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n@@ -1963,10 +1966,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // It doesn't make sense to look at a field beyond the prefix;\n                 // these require a variant index, and are not initialized in\n                 // aggregate rvalues.\n-                match substs.prefix_tys(def_id, tcx).nth(field_index) {\n+                match substs.as_generator().prefix_tys(def_id, tcx).nth(field_index) {\n                     Some(ty) => Ok(ty),\n                     None => Err(FieldAccessError::OutOfRange {\n-                        field_count: substs.prefix_tys(def_id, tcx).count(),\n+                        field_count: substs.as_generator().prefix_tys(def_id, tcx).count(),\n                     }),\n                 }\n             }\n@@ -2541,7 +2544,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // these extra requirements are basically like where\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs)\n-            | AggregateKind::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+            | AggregateKind::Generator(def_id, substs, _) => {\n                 self.prove_closure_bounds(tcx, *def_id, substs, location)\n             }\n "}, {"sha": "5f6951856434e8021bbf7866ec51356fb452ea73", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::middle::lang_items;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{InternalSubsts, SubstsRef, Subst};\n-use rustc::ty::{self, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_errors::DiagnosticBuilder;\n@@ -90,7 +90,7 @@ pub enum DefiningTy<'tcx> {\n     /// The MIR is a generator. The signature is that generators take\n     /// no parameters and return the result of\n     /// `ClosureSubsts::generator_return_ty`.\n-    Generator(DefId, ty::GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, SubstsRef<'tcx>, hir::GeneratorMovability),\n \n     /// The MIR is a fn item with the given `DefId` and substs. The signature\n     /// of the function can be bound then with the `fn_sig` query.\n@@ -113,7 +113,7 @@ impl<'tcx> DefiningTy<'tcx> {\n                 substs.as_closure().upvar_tys(def_id, tcx)\n             ),\n             DefiningTy::Generator(def_id, substs, _) => {\n-                Either::Right(Either::Left(substs.upvar_tys(def_id, tcx)))\n+                Either::Right(Either::Left(substs.as_generator().upvar_tys(def_id, tcx)))\n             }\n             DefiningTy::FnDef(..) | DefiningTy::Const(..) => {\n                 Either::Right(Either::Right(iter::empty()))\n@@ -334,7 +334,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 err.note(&format!(\n                     \"defining type: {:?} with generator substs {:#?}\",\n                     def_id,\n-                    &substs.substs[..]\n+                    &substs[..]\n                 ));\n \n                 // FIXME: As above, we'd like to print out the region\n@@ -470,7 +470,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let yield_ty = match defining_ty {\n             DefiningTy::Generator(def_id, substs, _) => {\n-                Some(substs.yield_ty(def_id, self.infcx.tcx))\n+                Some(substs.as_generator().yield_ty(def_id, self.infcx.tcx))\n             }\n             _ => None,\n         };\n@@ -549,7 +549,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ref substs)\n-            | DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n+            | DefiningTy::Generator(_, ref substs, _) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `closure_base_def_id`.\n@@ -612,7 +612,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n                 assert_eq!(self.mir_def_id, def_id);\n-                let output = substs.return_ty(def_id, tcx);\n+                let output = substs.as_generator().return_ty(def_id, tcx);\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n                 let inputs_and_output = self.infcx.tcx.intern_type_list(&[generator_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)"}, {"sha": "87d95a751534d1d54750a6ec7ae3167fdd8bc239", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -128,7 +128,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         expr_span,\n                         scope,\n                         result,\n-                        expr.ty,\n                     );\n                 }\n \n@@ -569,7 +568,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 upvar_span,\n                 temp_lifetime,\n                 temp,\n-                upvar_ty,\n             );\n         }\n "}, {"sha": "18332ed68f8bd15ae65d7dba2c36fd7121bc5aef", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -103,7 +103,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         expr_span,\n                         temp_lifetime,\n                         temp,\n-                        expr_ty,\n                         DropKind::Storage,\n                     );\n                 }\n@@ -117,7 +116,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 expr_span,\n                 temp_lifetime,\n                 temp,\n-                expr_ty,\n                 DropKind::Value,\n             );\n         }"}, {"sha": "2e451fc88d95c37fa29153521d63c074689ca4c5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -535,21 +535,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 kind: StatementKind::StorageLive(local_id),\n             },\n         );\n-        let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, local_id, var_ty, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         Place::from(local_id)\n     }\n \n     pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n-        let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(\n             span,\n             region_scope,\n             local_id,\n-            var_ty,\n             DropKind::Value,\n         );\n     }"}, {"sha": "ffb70180bbb4b7676f1c88098e7fcf21071a756c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -146,7 +146,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_sig = match ty.kind {\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n-                        gen_substs.sig(gen_def_id, tcx),\n+                        gen_substs.as_generator().sig(gen_def_id, tcx),\n                     _ =>\n                         span_bug!(tcx.hir().span(id),\n                                   \"generator w/o generator type: {:?}\", ty),\n@@ -502,24 +502,21 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n-    // Not callable from C, so we can safely unwind through these\n-    if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n-\n-    // Validate `#[unwind]` syntax regardless of platform-specific panic strategy\n+fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n+    // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n     let attrs = &tcx.get_attrs(fn_def_id);\n     let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n \n-    // We never unwind, so it's not relevant to stop an unwind\n+    // We never unwind, so it's not relevant to stop an unwind.\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind { return false; }\n \n-    // We cannot add landing pads, so don't add one\n+    // We cannot add landing pads, so don't add one.\n     if tcx.sess.no_landing_pads() { return false; }\n \n     // This is a special case: some functions have a C abi but are meant to\n     // unwind anyway. Don't stop them.\n     match unwind_attr {\n-        None => false, // FIXME(#58794)\n+        None => false, // FIXME(#58794); should be `!(abi == Abi::Rust || abi == Abi::RustCall)`\n         Some(UnwindAttr::Allowed) => false,\n         Some(UnwindAttr::Aborts) => true,\n     }\n@@ -829,12 +826,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::from(local);\n-            let &ArgInfo(ty, opt_ty_info, arg_opt, ref self_binding) = arg_info;\n+            let &ArgInfo(_, opt_ty_info, arg_opt, ref self_binding) = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n                 arg_opt.as_ref().map_or(ast_body.span, |arg| arg.pat.span),\n-                argument_scope, local, ty, DropKind::Value,\n+                argument_scope, local, DropKind::Value,\n             );\n \n             if let Some(arg) = arg_opt {"}, {"sha": "a749b4263ea64abe73a5e4a5981519ec35995648", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -85,7 +85,6 @@ should go to.\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n use crate::hair::{Expr, ExprRef, LintLevel};\n use rustc::middle::region;\n-use rustc::ty::Ty;\n use rustc::hir;\n use rustc::mir::*;\n use syntax_pos::{DUMMY_SP, Span};\n@@ -173,11 +172,11 @@ struct BreakableScope<'tcx> {\n     region_scope: region::Scope,\n     /// Where the body of the loop begins. `None` if block\n     continue_block: Option<BasicBlock>,\n-    /// Block to branch into when the loop or block terminates (either by being `break`-en out\n-    /// from, or by having its condition to become false)\n+    /// Block to branch into when the loop or block terminates (either by being\n+    /// `break`-en out from, or by having its condition to become false)\n     break_block: BasicBlock,\n-    /// The destination of the loop/block expression itself (i.e., where to put the result of a\n-    /// `break` expression)\n+    /// The destination of the loop/block expression itself (i.e., where to put\n+    /// the result of a `break` expression)\n     break_destination: Place<'tcx>,\n }\n \n@@ -728,10 +727,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         region_scope: region::Scope,\n         local: Local,\n-        place_ty: Ty<'tcx>,\n     ) {\n-        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Storage);\n-        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Value);\n+        self.schedule_drop(span, region_scope, local, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, local, DropKind::Value);\n     }\n \n     /// Indicates that `place` should be dropped on exit from\n@@ -744,12 +742,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         region_scope: region::Scope,\n         local: Local,\n-        place_ty: Ty<'tcx>,\n         drop_kind: DropKind,\n     ) {\n-        let needs_drop = self.hir.needs_drop(place_ty);\n-        match drop_kind {\n-            DropKind::Value => if !needs_drop { return },\n+        let needs_drop = match drop_kind {\n+            DropKind::Value => {\n+                if !self.hir.needs_drop(self.local_decls[local].ty) { return }\n+                true\n+            },\n             DropKind::Storage => {\n                 if local.index() <= self.arg_count {\n                     span_bug!(\n@@ -758,8 +757,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         self.arg_count,\n                     )\n                 }\n+                false\n             }\n-        }\n+        };\n \n         for scope in self.scopes.iter_mut() {\n             let this_scope = scope.region_scope == region_scope;"}, {"sha": "bc09e327179268e12f351bae0c8030252497fee5", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -104,25 +104,16 @@ impl<'tcx> TransferFunction<'_, '_, 'tcx> {\n         kind: mir::BorrowKind,\n         borrowed_place: &mir::Place<'tcx>,\n     ) -> bool {\n-        let borrowed_ty = borrowed_place.ty(self.body, self.tcx).ty;\n-\n-        // Zero-sized types cannot be mutated, since there is nothing inside to mutate.\n-        //\n-        // FIXME: For now, we only exempt arrays of length zero. We need to carefully\n-        // consider the effects before extending this to all ZSTs.\n-        if let ty::Array(_, len) = borrowed_ty.kind {\n-            if len.try_eval_usize(self.tcx, self.param_env) == Some(0) {\n-                return false;\n-            }\n-        }\n-\n         match kind {\n             mir::BorrowKind::Mut { .. } => true,\n \n             | mir::BorrowKind::Shared\n             | mir::BorrowKind::Shallow\n             | mir::BorrowKind::Unique\n-            => !borrowed_ty.is_freeze(self.tcx, self.param_env, DUMMY_SP),\n+            => !borrowed_place\n+                .ty(self.body, self.tcx)\n+                .ty\n+                .is_freeze(self.tcx, self.param_env, DUMMY_SP),\n         }\n     }\n }"}, {"sha": "c1695ba66d0d536e54142f907043c66ddbe975e3", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -109,15 +109,13 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         assert_eq!(1, self.body.arg_count);\n     }\n \n-    fn statement_effect(&self,\n-                        sets: &mut GenKillSet<Local>,\n-                        loc: Location) {\n-        self.check_for_move(sets, loc);\n+    fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n+        // If we borrow or assign to a place then it needs storage for that\n+        // statement.\n         self.check_for_borrow(sets, loc);\n \n         let stmt = &self.body[loc.block].statements[loc.statement_index];\n         match stmt.kind {\n-            StatementKind::StorageLive(l) => sets.gen(l),\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box(ref place, _))\n             | StatementKind::SetDiscriminant { box ref place, .. } => {\n@@ -136,11 +134,35 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn terminator_effect(&self,\n-                         sets: &mut GenKillSet<Local>,\n-                         loc: Location) {\n+    fn statement_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        // If we move from a place then only stops needing storage *after*\n+        // that statement.\n         self.check_for_move(sets, loc);\n+    }\n+\n+    fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n         self.check_for_borrow(sets, loc);\n+\n+        if let TerminatorKind::Call {\n+            destination: Some((Place { base: PlaceBase::Local(local), .. }, _)),\n+            ..\n+        } = self.body[loc.block].terminator().kind {\n+            sets.gen(local);\n+        }\n+    }\n+\n+    fn terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        // For call terminators the destination requires storage for the call\n+        // and after the call returns successfully, but not after a panic.\n+        // Since `propagate_call_unwind` doesn't exist, we have to kill the\n+        // destination here, and then gen it again in `propagate_call_return`.\n+        if let TerminatorKind::Call {\n+            destination: Some((Place { base: PlaceBase::Local(local), projection: box [] }, _)),\n+            ..\n+        } = self.body[loc.block].terminator().kind {\n+            sets.kill(local);\n+        }\n+        self.check_for_move(sets, loc);\n     }\n \n     fn propagate_call_return("}, {"sha": "ad0f75d772548b7208bf942b21d03e1280e9461b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "patch": "@@ -1,4 +1,5 @@\n use syntax::ast::{self, MetaItem};\n+use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n \n use rustc_index::bit_set::{BitSet, HybridBitSet};\n@@ -159,9 +160,8 @@ where\n                 if let Some(s) = item.value_str() {\n                     return Some(s.to_string())\n                 } else {\n-                    sess.span_err(\n-                        item.span,\n-                        &format!(\"{} attribute requires a path\", item.path));\n+                    let path = pprust::path_to_string(&item.path);\n+                    sess.span_err(item.span, &format!(\"{} attribute requires a path\", path));\n                     return None;\n                 }\n             }"}, {"sha": "419c905cb5127a070530064f1b056b4630f7cb21", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "1d83b104177e23ead5bbcc9df2439ef66970f0aa", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 373, "deletions": 196, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "7bc4bf291ee488f5b61543b5b90ec71c197749f2", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "7e17162dfb3ef0df1d79afabee9e8d98707b5ec4", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "9ab347957f97ac8480ff5ac7f57f4ddbac941887", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "06fdd407951c1f76c6bb3c27ee3426ad52445943", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "646d1783c8ec96356a97120f3d379b424a0d6ea2", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "f9200f8c1c04239c87ba03610dee0027ff50f31f", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "4d9be55945e0279ef3acfb4ec0ced2efd156f9b3", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "0289c52fd37446bbd7578bbc3865786618170369", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "7f6baf0bb49c13e34c7af4ae2b77720c41ed3983", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "3444fb60f333b9d35fcf5c33cbe2f7bfbb265065", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "98d5487870a4de609eb01dfc2ce466d57415198e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "ee7452d3e8b460cae476dbb3fae5e9e227cbe4c1", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "e63426281bf21fea294ffd71ecac399254a366a5", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd4d9c27bf8fee4f7d664d76c41832745dff43/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=5ebd4d9c27bf8fee4f7d664d76c41832745dff43"}, {"sha": "b9d38028b72a81f21e8a3cdd4db3317fda5d2410", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "f532a18072fbda480bf227f709e635689f64441d", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "f0c0e57344388f8e09d410c118a099e5158a7e82", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 84, "deletions": 74, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "439cae2093ae5361ec82b136f369d862cd03f796", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "6533e3c5ba81fcc8180252c5bb8299eb09fadb82", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "0cbdcedff4780dea11618d9a609c18f2436ff196", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "ad1785417cd93409633603c784e9b8735143e92c", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "da1abb9747c1a7ef5cff597176234cc5c8905557", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "7b6255defd148cae58f4dcd0d5150bef7586188f", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "606c1a3a1cc09dd9deb761c42b0fe8f819340410", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "cdd07ad4b8ff4b88ba81689ddbf0aca0b71a7055", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "f7ba6f1ec6993994d8595ab43d4d44721db210f8", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "118deb560d62f1dff29252f4782fa640b6399716", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "74de31263d3944104009f40cf886fc3b67de4ef1", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "f2aef2c12c7df1b4d3cfffb223247ea3d83265b4", "filename": "src/librustc_passes/dead.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "previous_filename": "src/librustc/middle/dead.rs"}, {"sha": "bf68807a0c29b1ffd24069fad760e9163edb8b3f", "filename": "src/librustc_passes/entry.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "previous_filename": "src/librustc/middle/entry.rs"}, {"sha": "a2626617afec33f880c11b431a50a54d5d40e730", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 295, "deletions": 15, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "91a7e9f5d7fcadbaf8eea16c67cc91676fd3e8f0", "filename": "src/librustc_passes/intrinsicck.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "previous_filename": "src/librustc/middle/intrinsicck.rs"}, {"sha": "db59d8e101f77df07c0655f3e7bc5c761196cd7a", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "fb06808619f66f096719656fc0fc507a061a9d03", "filename": "src/librustc_passes/liveness.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83", "previous_filename": "src/librustc/middle/liveness.rs"}, {"sha": "e8bf4e7ea8ff67d94da7c47a02e7cc598c4d6759", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "38738e20630c912f895859479b7d84e098ed0920", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "b826dd911983862a78479a66045b95980fa2249d", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "03afb547d3a226a54faa166b91bf8673bb20b2ad", "filename": "src/librustc_privacy/error_codes.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_privacy%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_privacy%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "34cdec229af4318f329225cbecce252b842a8e76", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "06bf30859898a2af2fa1a4348ee06ed7b747b44b", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "e261d3af61ff8c8372b7b464e1a65fe10ee6a5a3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "5647d5b2794afb024aa14e3498c32f41f8092296", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "cd6189c681da14db13693d9eb178bb0dcd6da050", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 194, "deletions": 11, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "73a282b1a0ec1e9e159133b675d85d3f2bdbcb66", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 123, "deletions": 140, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "2721df4c687636d7b10924e0acae6e328a6664db", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "17d8f0f211a9288a061ad8f02056eac9869aaf2b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 112, "deletions": 80, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "94fe0cc57403e7a376a5d66384839e1a484b529e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "424bf31a785056e3a3f0c5a3c5d383b24e61d9a0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "e282936b5d9e7e762938fc483af2dabddc0f315b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "1cfb84bb511e4b4ca5c8c16d73235790f35b4db8", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "fde5c5bed4d91a02b35b42d8c2ed78ca3a241e38", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "c5277c4f90e7ae42e908715938c4b79afbcebbcf", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "d5ef230dcf7d23c5da16e34a71684249c6be4bc5", "filename": "src/librustc_target/spec/wasm32_wasi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "c1316f415a559182709fc15dd9b75e809046224f", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 53, "deletions": 60, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "dc7eeead30cbeb639657770cf614293a75913618", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "cc5348623fabda0dfdf0eda61c36b30fafc7e935", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "0df367fcca83c307fb4d5dc73c9d81311115c1c2", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "7e0a9bc4011c0fdc4240549b8940470d012d87e3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "4f4133954cf1d359e7b51f33bab81c980f77f0af", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "677e2ea3566281fa0800b1c9bacd6e9ef04d980f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "0c8df9bad448fdce38f9058397424495a11893e6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "ad46a443b8ffa9e886969f8409266a13d30b4d7a", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "e57cc809c347989488f7ba5e150ec4b05782141c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "f2d001eadedde1cf9c543479a9795b38185d8b6d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 144, "deletions": 64, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "152edf8dd0e5ad2989be33191a22e7cd5e67f704", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 23, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "18b103960c74595b5f684ea77eeb9434b58d9bf6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "1749fd1075e0524a86f0a904f8dbf3cfb8dd1f9b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "1fdf49fde55b53082907be472a3865d543e88fc9", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "ef08e8d4f0b7ab341d428a998b7061f653ebe29e", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 84, "deletions": 17, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "2d188007712ad376c4bb570e3cec41177fed30a1", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}, {"sha": "9374113e1c95042f61872001a8a4722e46af3755", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b6801b7dcd56a272dda2fbd88ecbc5b1476d8b83"}]}