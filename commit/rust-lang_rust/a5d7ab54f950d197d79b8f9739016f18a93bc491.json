{"sha": "a5d7ab54f950d197d79b8f9739016f18a93bc491", "node_id": "C_kwDOAAsO6NoAKGE1ZDdhYjU0Zjk1MGQxOTdkNzliOGY5NzM5MDE2ZjE4YTkzYmM0OTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-30T14:05:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-30T14:05:37Z"}, "message": "Auto merge of #12418 - Veykril:completions, r=Veykril\n\ninternal: More precise completion filtering with existing item qualifiers\n\nNow we are approaching the more complex cases for filtering completions", "tree": {"sha": "a21f0ee588318e99be47c565b567e3c2c682de60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21f0ee588318e99be47c565b567e3c2c682de60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5d7ab54f950d197d79b8f9739016f18a93bc491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5d7ab54f950d197d79b8f9739016f18a93bc491", "html_url": "https://github.com/rust-lang/rust/commit/a5d7ab54f950d197d79b8f9739016f18a93bc491", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5d7ab54f950d197d79b8f9739016f18a93bc491/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c551d1a6af58c80004b5f708c24f9d855a986493", "url": "https://api.github.com/repos/rust-lang/rust/commits/c551d1a6af58c80004b5f708c24f9d855a986493", "html_url": "https://github.com/rust-lang/rust/commit/c551d1a6af58c80004b5f708c24f9d855a986493"}, {"sha": "0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1", "html_url": "https://github.com/rust-lang/rust/commit/0327df224bf67ef2c3ceb5a69729cf36a6a96ba1"}], "stats": {"total": 182, "additions": 131, "deletions": 51}, "files": [{"sha": "edff146d8d772045a10c3aeee65fa24cec9cb6f4", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -8,21 +8,18 @@ use crate::{\n \n pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_item_list\");\n-    if ctx.is_path_disallowed() || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n-        return;\n-    }\n \n-    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n+    let (&is_absolute_path, path_qualifier, _kind) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n-            kind: PathKind::Item { .. },\n+            kind: PathKind::Item { kind },\n             is_absolute_path,\n             qualifier,\n             ..\n-        }) => (is_absolute_path, qualifier),\n+        }) => (is_absolute_path, qualifier, kind),\n         _ => return,\n     };\n \n-    match qualifier {\n+    match path_qualifier {\n         Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n             if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n                 for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n@@ -39,13 +36,14 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         None if is_absolute_path => {\n             acc.add_crate_roots(ctx);\n         }\n-        None => {\n+        None if ctx.qualifier_ctx.none() => {\n             ctx.process_all_names(&mut |name, def| {\n                 if let Some(def) = module_or_fn_macro(ctx.db, def) {\n                     acc.add_resolution(ctx, name, def);\n                 }\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n+        None => {}\n     }\n }"}, {"sha": "281e6e9783cf30164f90c0251240b9a4cb36600d", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -51,7 +51,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         return;\n     }\n \n-    if !ctx.has_visibility_prev_sibling()\n+    if ctx.qualifier_ctx.vis_node.is_none()\n         && (expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_field())\n     {\n         add_keyword(\"pub(crate)\", \"pub(crate)\");\n@@ -67,7 +67,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     if expects_item || has_block_expr_parent {\n-        if !ctx.has_visibility_prev_sibling() {\n+        if ctx.qualifier_ctx.vis_node.is_none() {\n             add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n             add_keyword(\"extern\", \"extern $0\");\n         }"}, {"sha": "ebc3bb5a6f9b921b4f055b24370a7f31e72a84a3", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -2,7 +2,6 @@\n \n use hir::Documentation;\n use ide_db::{imports::insert_use::ImportScope, SnippetCap};\n-use syntax::T;\n \n use crate::{\n     context::{ItemListKind, PathCompletionCtx, PathKind},\n@@ -52,10 +51,10 @@ pub(crate) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionConte\n         }) => kind,\n         _ => return,\n     };\n-    if ctx.previous_token_is(T![unsafe]) || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n+    if !ctx.qualifier_ctx.none() {\n         return;\n     }\n-    if ctx.has_visibility_prev_sibling() {\n+    if ctx.qualifier_ctx.vis_node.is_some() {\n         return; // technically we could do some of these snippet completions if we were to put the\n                 // attributes before the vis node.\n     }"}, {"sha": "b70d6f9e8dc233583a06ec51a465e5e70f6a0f22", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 105, "deletions": 7, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -75,6 +75,18 @@ pub(super) enum ItemListKind {\n     ExternBlock,\n }\n \n+#[derive(Debug, Default)]\n+pub(super) struct QualifierCtx {\n+    pub(super) unsafe_tok: Option<SyntaxToken>,\n+    pub(super) vis_node: Option<ast::Visibility>,\n+}\n+\n+impl QualifierCtx {\n+    pub(super) fn none(&self) -> bool {\n+        self.unsafe_tok.is_none() && self.vis_node.is_none()\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there (or {} in case of record patterns)\n@@ -253,6 +265,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) ident_ctx: IdentContext,\n \n     pub(super) pattern_ctx: Option<PatternContext>,\n+    pub(super) qualifier_ctx: QualifierCtx,\n \n     pub(super) existing_derives: FxHashSet<hir::Macro>,\n \n@@ -363,17 +376,13 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.prev_sibling, Some(ImmediatePrevSibling::ImplDefType))\n     }\n \n-    pub(crate) fn has_visibility_prev_sibling(&self) -> bool {\n-        matches!(self.prev_sibling, Some(ImmediatePrevSibling::Visibility))\n-    }\n-\n     pub(crate) fn after_if(&self) -> bool {\n         matches!(self.prev_sibling, Some(ImmediatePrevSibling::IfExpr))\n     }\n \n     // FIXME: This shouldn't exist\n     pub(crate) fn is_path_disallowed(&self) -> bool {\n-        self.previous_token_is(T![unsafe])\n+        !self.qualifier_ctx.none()\n             || matches!(self.prev_sibling, Some(ImmediatePrevSibling::Visibility))\n             || (matches!(self.name_ctx(), Some(NameContext { .. })) && self.pattern_ctx.is_none())\n             || matches!(self.pattern_ctx, Some(PatternContext { record_pat: Some(_), .. }))\n@@ -555,6 +564,7 @@ impl<'a> CompletionContext<'a> {\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n             pattern_ctx: None,\n+            qualifier_ctx: Default::default(),\n             existing_derives: Default::default(),\n             locals,\n         };\n@@ -865,7 +875,7 @@ impl<'a> CompletionContext<'a> {\n         offset: TextSize,\n         derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n     ) -> Option<()> {\n-        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n+        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         if is_in_token_of_for_loop(syntax_element.clone()) {\n             // for pat $0\n@@ -967,7 +977,49 @@ impl<'a> CompletionContext<'a> {\n             ast::NameLike::NameRef(name_ref) => {\n                 let parent = name_ref.syntax().parent()?;\n                 let (nameref_ctx, pat_ctx) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n+\n+                // Extract qualifiers\n+                if let Some(path_ctx) = &nameref_ctx.path_ctx {\n+                    if path_ctx.qualifier.is_none() {\n+                        let top = match path_ctx.kind {\n+                            PathKind::Expr { in_block_expr: true, .. } => parent\n+                                .ancestors()\n+                                .find(|it| ast::PathExpr::can_cast(it.kind()))\n+                                .and_then(|p| {\n+                                    let parent = p.parent()?;\n+                                    if ast::StmtList::can_cast(parent.kind()) {\n+                                        Some(p)\n+                                    } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                                        Some(parent)\n+                                    } else {\n+                                        None\n+                                    }\n+                                }),\n+                            PathKind::Item { .. } => {\n+                                parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                            }\n+                            _ => None,\n+                        };\n+                        if let Some(top) = top {\n+                            if let Some(NodeOrToken::Node(error_node)) =\n+                                syntax::algo::non_trivia_sibling(\n+                                    top.into(),\n+                                    syntax::Direction::Prev,\n+                                )\n+                            {\n+                                if error_node.kind() == SyntaxKind::ERROR {\n+                                    self.qualifier_ctx.unsafe_tok = error_node\n+                                        .children_with_tokens()\n+                                        .filter_map(NodeOrToken::into_token)\n+                                        .find(|it| it.kind() == T![unsafe]);\n+                                    self.qualifier_ctx.vis_node =\n+                                        error_node.children().find_map(ast::Visibility::cast);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n                 self.pattern_ctx = pat_ctx;\n             }\n@@ -1145,12 +1197,54 @@ impl<'a> CompletionContext<'a> {\n             }\n         };\n \n+        // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n+        // ex. trait Foo $0 {}\n+        // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n+        // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n+        // expression or an item list.\n+        // The following code checks if the body is missing, if it is we either cut off the body\n+        // from the item or it was missing in the first place\n+        let inbetween_body_and_decl_check = |node: SyntaxNode| {\n+            if let Some(NodeOrToken::Node(n)) =\n+                syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n+            {\n+                if let Some(item) = ast::Item::cast(n) {\n+                    match item {\n+                        ast::Item::Const(it) => it.body().is_none(),\n+                        ast::Item::Enum(it) => it.variant_list().is_none(),\n+                        ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n+                        ast::Item::Fn(it) => it.body().is_none(),\n+                        ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n+                        ast::Item::Module(it) => it.item_list().is_none(),\n+                        ast::Item::Static(it) => it.body().is_none(),\n+                        ast::Item::Struct(it) => it.field_list().is_none(),\n+                        ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n+                        ast::Item::TypeAlias(it) => it.ty().is_none(),\n+                        ast::Item::Union(it) => it.record_field_list().is_none(),\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+        };\n+\n         let kind = path.syntax().ancestors().find_map(|it| {\n             // using Option<Option<PathKind>> as extra controlflow\n             let kind = match_ast! {\n                 match it {\n                     ast::PathType(_) => Some(PathKind::Type),\n                     ast::PathExpr(it) => {\n+                        if let Some(p) = it.syntax().parent() {\n+                            if ast::ExprStmt::can_cast(p.kind()) {\n+                                if inbetween_body_and_decl_check(p) {\n+                                    return Some(None);\n+                                }\n+                            }\n+                        }\n+\n                         fill_record_expr(it.syntax());\n \n                         path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n@@ -1173,6 +1267,10 @@ impl<'a> CompletionContext<'a> {\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => {\n+                        if inbetween_body_and_decl_check(it.syntax().clone()) {\n+                            return Some(None);\n+                        }\n+\n                         path_ctx.has_macro_bang = it.excl_token().is_some();\n                         let parent = it.syntax().parent();\n                         match parent.as_ref().map(|it| it.kind()) {"}, {"sha": "9659efad619ddbf305263572b7d66803b929836b", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -143,15 +143,15 @@ pub fn completions(\n     db: &RootDatabase,\n     config: &CompletionConfig,\n     position: FilePosition,\n-    trigger_character: Option<&str>,\n+    trigger_character: Option<char>,\n ) -> Option<Completions> {\n     let ctx = &CompletionContext::new(db, position, config)?;\n     let mut acc = Completions::default();\n \n     {\n         let acc = &mut acc;\n         // prevent `(` from triggering unwanted completion noise\n-        if trigger_character != Some(\"(\") {\n+        if trigger_character != Some('(') {\n             completions::attribute::complete_attribute(acc, ctx);\n             completions::attribute::complete_derive(acc, ctx);\n             completions::attribute::complete_known_attribute_input(acc, ctx);"}, {"sha": "d30ff77bab622051a196fa998383ed883234ed7e", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -88,7 +88,7 @@ pub(crate) fn completion_list_no_kw(ra_fixture: &str) -> String {\n \n pub(crate) fn completion_list_with_trigger_character(\n     ra_fixture: &str,\n-    trigger_character: Option<&str>,\n+    trigger_character: Option<char>,\n ) -> String {\n     completion_list_with_config(TEST_CONFIG, ra_fixture, true, trigger_character)\n }\n@@ -97,7 +97,7 @@ fn completion_list_with_config(\n     config: CompletionConfig,\n     ra_fixture: &str,\n     include_keywords: bool,\n-    trigger_character: Option<&str>,\n+    trigger_character: Option<char>,\n ) -> String {\n     // filter out all but one builtintype completion for smaller test outputs\n     let items = get_all_items(config, ra_fixture, trigger_character);\n@@ -225,7 +225,7 @@ pub(crate) fn check_pattern_is_applicable(code: &str, check: impl FnOnce(SyntaxE\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,\n-    trigger_character: Option<&str>,\n+    trigger_character: Option<char>,\n ) -> Vec<CompletionItem> {\n     let (db, position) = position(code);\n     let res = crate::completions(&db, &config, position, trigger_character)"}, {"sha": "f5a5b5bae6ab37f229bd800750e3cdf9c0e8c741", "filename": "crates/ide-completion/src/tests/fn_param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Ffn_param.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -7,8 +7,8 @@ fn check(ra_fixture: &str, expect: Expect) {\n     expect.assert_eq(&actual);\n }\n \n-fn check_with_trigger_character(ra_fixture: &str, trigger_character: Option<&str>, expect: Expect) {\n-    let actual = completion_list_with_trigger_character(ra_fixture, trigger_character);\n+fn check_with_trigger_character(ra_fixture: &str, trigger_character: char, expect: Expect) {\n+    let actual = completion_list_with_trigger_character(ra_fixture, Some(trigger_character));\n     expect.assert_eq(&actual)\n }\n \n@@ -124,7 +124,7 @@ fn trigger_by_l_paren() {\n         r#\"\n fn foo($0)\n \"#,\n-        Some(\"(\"),\n+        '(',\n         expect![[]],\n     )\n }"}, {"sha": "537c9a7fa2415c1830c1254ac9a55901412d188a", "filename": "crates/ide-completion/src/tests/item.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -92,10 +92,7 @@ fn after_struct_name() {\n     check(\n         r\"struct Struct $0\",\n         expect![[r#\"\n-            ma makro!(\u2026)           macro_rules! makro\n-            md module\n             kw const\n-            kw crate::\n             kw enum\n             kw extern\n             kw fn\n@@ -104,18 +101,13 @@ fn after_struct_name() {\n             kw pub\n             kw pub(crate)\n             kw pub(super)\n-            kw self::\n             kw static\n             kw struct\n-            kw super::\n             kw trait\n             kw type\n             kw union\n             kw unsafe\n             kw use\n-            sn macro_rules\n-            sn tfn (Test function)\n-            sn tmod (Test module)\n         \"#]],\n     );\n }\n@@ -126,10 +118,7 @@ fn after_fn_name() {\n     check(\n         r\"fn func() $0\",\n         expect![[r#\"\n-            ma makro!(\u2026)           macro_rules! makro\n-            md module\n             kw const\n-            kw crate::\n             kw enum\n             kw extern\n             kw fn\n@@ -138,18 +127,13 @@ fn after_fn_name() {\n             kw pub\n             kw pub(crate)\n             kw pub(super)\n-            kw self::\n             kw static\n             kw struct\n-            kw super::\n             kw trait\n             kw type\n             kw union\n             kw unsafe\n             kw use\n-            sn macro_rules\n-            sn tfn (Test function)\n-            sn tmod (Test module)\n         \"#]],\n     );\n }"}, {"sha": "151dd6a7e85d4df27164ae8dfe681fc45dd5cf21", "filename": "crates/ide-completion/src/tests/visibility.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide-completion%2Fsrc%2Ftests%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fvisibility.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -8,8 +8,8 @@ fn check(ra_fixture: &str, expect: Expect) {\n     expect.assert_eq(&actual)\n }\n \n-fn check_with_trigger_character(ra_fixture: &str, trigger_character: Option<&str>, expect: Expect) {\n-    let actual = completion_list_with_trigger_character(ra_fixture, trigger_character);\n+fn check_with_trigger_character(ra_fixture: &str, trigger_character: char, expect: Expect) {\n+    let actual = completion_list_with_trigger_character(ra_fixture, Some(trigger_character));\n     expect.assert_eq(&actual)\n }\n \n@@ -20,7 +20,7 @@ fn empty_pub() {\n         r#\"\n pub($0)\n \"#,\n-        Some(\"(\"),\n+        '(',\n         expect![[r#\"\n             kw crate\n             kw in"}, {"sha": "aab5ceda366e1d3ae8716b372eb05b4485738f67", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -548,7 +548,7 @@ impl Analysis {\n         &self,\n         config: &CompletionConfig,\n         position: FilePosition,\n-        trigger_character: Option<&str>,\n+        trigger_character: Option<char>,\n     ) -> Cancellable<Option<Vec<CompletionItem>>> {\n         self.with_db(|db| {\n             ide_completion::completions(db, config, position, trigger_character).map(Into::into)"}, {"sha": "ff61081aa81f9e735fd5d0c78560c7c7c3115423", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5d7ab54f950d197d79b8f9739016f18a93bc491/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=a5d7ab54f950d197d79b8f9739016f18a93bc491", "patch": "@@ -796,9 +796,10 @@ pub(crate) fn handle_completion(\n     let _p = profile::span(\"handle_completion\");\n     let text_document_position = params.text_document_position.clone();\n     let position = from_proto::file_position(&snap, params.text_document_position)?;\n-    let completion_trigger_character = params.context.and_then(|ctx| ctx.trigger_character);\n+    let completion_trigger_character =\n+        params.context.and_then(|ctx| ctx.trigger_character).and_then(|s| s.chars().next());\n \n-    if Some(\":\") == completion_trigger_character.as_deref() {\n+    if Some(':') == completion_trigger_character {\n         let source_file = snap.analysis.parse(position.file_id)?;\n         let left_token = source_file.syntax().token_at_offset(position.offset).left_biased();\n         let completion_triggered_after_single_colon = match left_token {\n@@ -814,7 +815,7 @@ pub(crate) fn handle_completion(\n     let items = match snap.analysis.completions(\n         completion_config,\n         position,\n-        completion_trigger_character.as_deref(),\n+        completion_trigger_character,\n     )? {\n         None => return Ok(None),\n         Some(items) => items,"}]}