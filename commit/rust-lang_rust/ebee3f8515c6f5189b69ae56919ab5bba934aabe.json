{"sha": "ebee3f8515c6f5189b69ae56919ab5bba934aabe", "node_id": "C_kwDOAAsO6NoAKGViZWUzZjg1MTVjNmY1MTg5YjY5YWU1NjkxOWFiNWJiYTkzNGFhYmU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-01T08:51:05Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-02T02:02:32Z"}, "message": "Remove `MemEncoder`.\n\nIt's only used in tests. Which is bad, because it means that\n`FileEncoder` is used in the compiler but isn't used in tests!\n\n`tests/opaque.rs` now tests encoding/decoding round-trips via file.\nBecause this is slower than memory, this commit also adjusts the\n`u16`/`i16` tests so they are more like the `u32`/`i32` tests, i.e. they\ndon't test every possible value.", "tree": {"sha": "13190c8d685f0a0a0ec52f3b0321f5a32eded6f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13190c8d685f0a0a0ec52f3b0321f5a32eded6f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebee3f8515c6f5189b69ae56919ab5bba934aabe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebee3f8515c6f5189b69ae56919ab5bba934aabe", "html_url": "https://github.com/rust-lang/rust/commit/ebee3f8515c6f5189b69ae56919ab5bba934aabe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebee3f8515c6f5189b69ae56919ab5bba934aabe/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d359e4385052f012d8d0c2e57a0bcfe54462d44", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d359e4385052f012d8d0c2e57a0bcfe54462d44", "html_url": "https://github.com/rust-lang/rust/commit/8d359e4385052f012d8d0c2e57a0bcfe54462d44"}], "stats": {"total": 150, "additions": 17, "deletions": 133}, "files": [{"sha": "bff68df40142576a0eef68499dbfb276658aa064", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebee3f8515c6f5189b69ae56919ab5bba934aabe/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ebee3f8515c6f5189b69ae56919ab5bba934aabe/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ebee3f8515c6f5189b69ae56919ab5bba934aabe", "patch": "@@ -4059,6 +4059,7 @@ dependencies = [\n  \"indexmap\",\n  \"rustc_macros\",\n  \"smallvec\",\n+ \"tempfile\",\n  \"thin-vec\",\n ]\n "}, {"sha": "6046780685ad8eaeb40e1aa13d5352468f1934fc", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebee3f8515c6f5189b69ae56919ab5bba934aabe/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebee3f8515c6f5189b69ae56919ab5bba934aabe/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=ebee3f8515c6f5189b69ae56919ab5bba934aabe", "patch": "@@ -10,3 +10,4 @@ thin-vec = \"0.2.12\"\n \n [dev-dependencies]\n rustc_macros = { path = \"../rustc_macros\" }\n+tempfile = \"3.2\""}, {"sha": "a2ec318df6d83cab3c371dac7c055e94f63c8ba5", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 4, "deletions": 125, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ebee3f8515c6f5189b69ae56919ab5bba934aabe/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebee3f8515c6f5189b69ae56919ab5bba934aabe/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=ebee3f8515c6f5189b69ae56919ab5bba934aabe", "patch": "@@ -12,118 +12,14 @@ use std::ptr;\n // Encoder\n // -----------------------------------------------------------------------------\n \n-pub struct MemEncoder {\n-    pub data: Vec<u8>,\n-}\n-\n-impl MemEncoder {\n-    pub fn new() -> MemEncoder {\n-        MemEncoder { data: vec![] }\n-    }\n-\n-    #[inline]\n-    pub fn position(&self) -> usize {\n-        self.data.len()\n-    }\n-\n-    pub fn finish(self) -> Vec<u8> {\n-        self.data\n-    }\n-}\n-\n-macro_rules! write_leb128 {\n-    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n-        let old_len = $enc.data.len();\n-\n-        if MAX_ENCODED_LEN > $enc.data.capacity() - old_len {\n-            $enc.data.reserve(MAX_ENCODED_LEN);\n-        }\n-\n-        // SAFETY: The above check and `reserve` ensures that there is enough\n-        // room to write the encoded value to the vector's internal buffer.\n-        unsafe {\n-            let buf = &mut *($enc.data.as_mut_ptr().add(old_len)\n-                as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN]);\n-            let encoded = leb128::$fun(buf, $value);\n-            $enc.data.set_len(old_len + encoded.len());\n-        }\n-    }};\n-}\n-\n-impl Encoder for MemEncoder {\n-    #[inline]\n-    fn emit_usize(&mut self, v: usize) {\n-        write_leb128!(self, v, usize, write_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u128(&mut self, v: u128) {\n-        write_leb128!(self, v, u128, write_u128_leb128);\n-    }\n-\n-    #[inline]\n-    fn emit_u64(&mut self, v: u64) {\n-        write_leb128!(self, v, u64, write_u64_leb128);\n-    }\n-\n-    #[inline]\n-    fn emit_u32(&mut self, v: u32) {\n-        write_leb128!(self, v, u32, write_u32_leb128);\n-    }\n-\n-    #[inline]\n-    fn emit_u16(&mut self, v: u16) {\n-        self.data.extend_from_slice(&v.to_le_bytes());\n-    }\n-\n-    #[inline]\n-    fn emit_u8(&mut self, v: u8) {\n-        self.data.push(v);\n-    }\n-\n-    #[inline]\n-    fn emit_isize(&mut self, v: isize) {\n-        write_leb128!(self, v, isize, write_isize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i128(&mut self, v: i128) {\n-        write_leb128!(self, v, i128, write_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i64(&mut self, v: i64) {\n-        write_leb128!(self, v, i64, write_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i32(&mut self, v: i32) {\n-        write_leb128!(self, v, i32, write_i32_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i16(&mut self, v: i16) {\n-        self.data.extend_from_slice(&v.to_le_bytes());\n-    }\n-\n-    #[inline]\n-    fn emit_raw_bytes(&mut self, s: &[u8]) {\n-        self.data.extend_from_slice(s);\n-    }\n-}\n-\n pub type FileEncodeResult = Result<usize, io::Error>;\n \n /// `FileEncoder` encodes data to file via fixed-size buffer.\n ///\n-/// When encoding large amounts of data to a file, using `FileEncoder` may be\n-/// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n-/// `Vec` to file, as the latter uses as much memory as there is encoded data,\n-/// while the former uses the fixed amount of memory allocated to the buffer.\n-/// `FileEncoder` also has the advantage of not needing to reallocate as data\n-/// is appended to it, but the disadvantage of requiring more error handling,\n-/// which has some runtime overhead.\n+/// There used to be a `MemEncoder` type that encoded all the data into a\n+/// `Vec`. `FileEncoder` is better because its memory use is determined by the\n+/// size of the buffer, rather than the full length of the encoded data, and\n+/// because it doesn't need to reallocate memory along the way.\n pub struct FileEncoder {\n     /// The input buffer. For adequate performance, we need more control over\n     /// buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n@@ -645,13 +541,6 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n // Specialize encoding byte slices. This specialization also applies to encoding `Vec<u8>`s, etc.,\n // since the default implementations call `encode` on their slices internally.\n-impl Encodable<MemEncoder> for [u8] {\n-    fn encode(&self, e: &mut MemEncoder) {\n-        Encoder::emit_usize(e, self.len());\n-        e.emit_raw_bytes(self);\n-    }\n-}\n-\n impl Encodable<FileEncoder> for [u8] {\n     fn encode(&self, e: &mut FileEncoder) {\n         Encoder::emit_usize(e, self.len());\n@@ -675,16 +564,6 @@ impl IntEncodedWithFixedSize {\n     pub const ENCODED_SIZE: usize = 8;\n }\n \n-impl Encodable<MemEncoder> for IntEncodedWithFixedSize {\n-    #[inline]\n-    fn encode(&self, e: &mut MemEncoder) {\n-        let _start_pos = e.position();\n-        e.emit_raw_bytes(&self.0.to_le_bytes());\n-        let _end_pos = e.position();\n-        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-    }\n-}\n-\n impl Encodable<FileEncoder> for IntEncodedWithFixedSize {\n     #[inline]\n     fn encode(&self, e: &mut FileEncoder) {"}, {"sha": "861091688bb2dd6c14910260fd273934187b76f2", "filename": "compiler/rustc_serialize/tests/opaque.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ebee3f8515c6f5189b69ae56919ab5bba934aabe/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebee3f8515c6f5189b69ae56919ab5bba934aabe/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs?ref=ebee3f8515c6f5189b69ae56919ab5bba934aabe", "patch": "@@ -1,9 +1,10 @@\n #![allow(rustc::internal)]\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n+use rustc_serialize::opaque::{MemDecoder, FileEncoder};\n use rustc_serialize::{Decodable, Encodable};\n use std::fmt::Debug;\n+use std::fs;\n \n #[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n struct Struct {\n@@ -27,18 +28,21 @@ struct Struct {\n }\n \n fn check_round_trip<\n-    T: Encodable<MemEncoder> + for<'a> Decodable<MemDecoder<'a>> + PartialEq + Debug,\n+    T: Encodable<FileEncoder> + for<'a> Decodable<MemDecoder<'a>> + PartialEq + Debug,\n >(\n     values: Vec<T>,\n ) {\n-    let mut encoder = MemEncoder::new();\n+    let tmpfile = tempfile::NamedTempFile::new().unwrap();\n+    let tmpfile = tmpfile.path();\n+\n+    let mut encoder = FileEncoder::new(&tmpfile).unwrap();\n     for value in &values {\n         Encodable::encode(value, &mut encoder);\n     }\n+    encoder.finish().unwrap();\n \n-    let data = encoder.finish();\n+    let data = fs::read(&tmpfile).unwrap();\n     let mut decoder = MemDecoder::new(&data[..], 0);\n-\n     for value in values {\n         let decoded = Decodable::decode(&mut decoder);\n         assert_eq!(value, decoded);\n@@ -61,7 +65,7 @@ fn test_u8() {\n \n #[test]\n fn test_u16() {\n-    for i in u16::MIN..u16::MAX {\n+    for i in [u16::MIN, 111, 3333, 55555, u16::MAX] {\n         check_round_trip(vec![1, 2, 3, i, i, i]);\n     }\n }\n@@ -92,7 +96,7 @@ fn test_i8() {\n \n #[test]\n fn test_i16() {\n-    for i in i16::MIN..i16::MAX {\n+    for i in [i16::MIN, -100, 0, 101, i16::MAX] {\n         check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n     }\n }\n@@ -289,4 +293,3 @@ fn test_cell() {\n     let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n     check_round_trip(vec![obj]);\n }\n-"}]}