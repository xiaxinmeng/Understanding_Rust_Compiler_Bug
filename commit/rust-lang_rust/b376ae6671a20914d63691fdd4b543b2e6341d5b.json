{"sha": "b376ae6671a20914d63691fdd4b543b2e6341d5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNzZhZTY2NzFhMjA5MTRkNjM2OTFmZGQ0YjU0M2IyZTYzNDFkNWI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-08T13:00:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-13T09:14:56Z"}, "message": "make bin_op and unary_op APIs consistently work on ImmTy", "tree": {"sha": "da1699972ad56cb1acdcd123da33a9334d20004e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da1699972ad56cb1acdcd123da33a9334d20004e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b376ae6671a20914d63691fdd4b543b2e6341d5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b376ae6671a20914d63691fdd4b543b2e6341d5b", "html_url": "https://github.com/rust-lang/rust/commit/b376ae6671a20914d63691fdd4b543b2e6341d5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b376ae6671a20914d63691fdd4b543b2e6341d5b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e73f96abe7cc3a76223e5d0b50592c287c517750", "url": "https://api.github.com/repos/rust-lang/rust/commits/e73f96abe7cc3a76223e5d0b50592c287c517750", "html_url": "https://github.com/rust-lang/rust/commit/e73f96abe7cc3a76223e5d0b50592c287c517750"}], "stats": {"total": 131, "additions": 66, "deletions": 65}, "files": [{"sha": "7be7f4b439289bc0615fc703f2711f9947fd0bd6", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n@@ -21,7 +21,8 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, RawConst, ConstValue, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Operand, Immediate, Scalar, Pointer,\n+    RawConst, ConstValue,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -379,10 +380,8 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn ptr_op(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        _left: Scalar,\n-        _left_layout: TyLayout<'tcx>,\n-        _right: Scalar,\n-        _right_layout: TyLayout<'tcx>,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),"}, {"sha": "6466dd4098acd16e9a929402e44383fafcd86dc4", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     \"unchecked_shr\" => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n-                let (val, overflowed) = self.binary_op_imm(bin_op, l, r)?;\n+                let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;"}, {"sha": "7fb4c47d92acb4d4d12c64fd47a18a130f5a5149", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    EvalContext, PlaceTy, MPlaceTy, OpTy, Pointer, MemoryKind,\n+    EvalContext, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -158,10 +158,8 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn ptr_op(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: Scalar<Self::PointerTag>,\n-        left_layout: TyLayout<'tcx>,\n-        right: Scalar<Self::PointerTag>,\n-        right_layout: TyLayout<'tcx>,\n+        left: ImmTy<'tcx, Self::PointerTag>,\n+        right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword."}, {"sha": "7da907028eebfd542a5bd62032991f77294d7b07", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -44,6 +44,11 @@ impl Immediate {\n }\n \n impl<'tcx, Tag> Immediate<Tag> {\n+    #[inline]\n+    pub fn from_scalar(val: Scalar<Tag>) -> Self {\n+        Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n+    }\n+\n     #[inline]\n     pub fn erase_tag(self) -> Immediate\n     {\n@@ -115,7 +120,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    crate imm: Immediate<Tag>, // ideally we'd make this private, but const_prop needs this\n+    pub imm: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -215,6 +220,19 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n+impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n+{\n+    #[inline]\n+    pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n+        ImmTy { imm: Immediate::from_scalar(val), layout }\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(self) -> EvalResult<'tcx, u128> {\n+        self.to_scalar()?.to_bits(self.layout.size)\n+    }\n+}\n+\n impl<'tcx, Tag> OpTy<'tcx, Tag>\n {\n     #[inline]"}, {"sha": "b3b9c742d6c282bc020aaaa879d3a07d9029da3b", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -18,7 +18,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binary_op_imm(op, left, right)?;\n+        let (val, overflowed) = self.binary_op(op, left, right)?;\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n     }\n@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op_imm(op, left, right)?;\n+        let (val, _overflowed) = self.binary_op(op, left, right)?;\n         self.write_scalar(val, dest)\n     }\n }\n@@ -272,83 +272,70 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok((val, false))\n     }\n \n-    /// Convenience wrapper that's useful when keeping the layout together with the\n-    /// immediate value.\n+    /// Returns the result of the specified operation and whether it overflowed.\n     #[inline]\n-    pub fn binary_op_imm(\n+    pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n-        self.binary_op(\n-            bin_op,\n-            left.to_scalar()?, left.layout,\n-            right.to_scalar()?, right.layout,\n-        )\n-    }\n-\n-    /// Returns the result of the specified operation and whether it overflowed.\n-    pub fn binary_op(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Scalar<M::PointerTag>,\n-        left_layout: TyLayout<'tcx>,\n-        right: Scalar<M::PointerTag>,\n-        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n-            bin_op, left, left_layout.ty, right, right_layout.ty);\n+            bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n-        match left_layout.ty.sty {\n+        match left.layout.ty.sty {\n             ty::Char => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_char()?;\n-                let right = right.to_char()?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_scalar()?.to_char()?;\n+                let right = right.to_scalar()?.to_char()?;\n                 self.binary_char_op(bin_op, left, right)\n             }\n             ty::Bool => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_bool()?;\n-                let right = right.to_bool()?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_scalar()?.to_bool()?;\n+                let right = right.to_scalar()?.to_bool()?;\n                 self.binary_bool_op(bin_op, left, right)\n             }\n             ty::Float(fty) => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_bits(left_layout.size)?;\n-                let right = right.to_bits(right_layout.size)?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_bits()?;\n+                let right = right.to_bits()?;\n                 self.binary_float_op(bin_op, fty, left, right)\n             }\n             _ => {\n                 // Must be integer(-like) types.  Don't forget about == on fn pointers.\n-                assert!(left_layout.ty.is_integral() || left_layout.ty.is_unsafe_ptr() ||\n-                    left_layout.ty.is_fn());\n-                assert!(right_layout.ty.is_integral() || right_layout.ty.is_unsafe_ptr() ||\n-                    right_layout.ty.is_fn());\n+                assert!(left.layout.ty.is_integral() || left.layout.ty.is_unsafe_ptr() ||\n+                    left.layout.ty.is_fn());\n+                assert!(right.layout.ty.is_integral() || right.layout.ty.is_unsafe_ptr() ||\n+                    right.layout.ty.is_fn());\n \n                 // Handle operations that support pointer values\n-                if left.is_ptr() || right.is_ptr() || bin_op == mir::BinOp::Offset {\n-                    return M::ptr_op(self, bin_op, left, left_layout, right, right_layout);\n+                if left.to_scalar_ptr()?.is_ptr() ||\n+                    right.to_scalar_ptr()?.is_ptr() ||\n+                    bin_op == mir::BinOp::Offset\n+                {\n+                    return M::ptr_op(self, bin_op, left, right);\n                 }\n \n                 // Everything else only works with \"proper\" bits\n-                let left = left.to_bits(left_layout.size).expect(\"we checked is_ptr\");\n-                let right = right.to_bits(right_layout.size).expect(\"we checked is_ptr\");\n-                self.binary_int_op(bin_op, left, left_layout, right, right_layout)\n+                let l = left.to_bits().expect(\"we checked is_ptr\");\n+                let r = right.to_bits().expect(\"we checked is_ptr\");\n+                self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n         }\n     }\n \n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: Scalar<M::PointerTag>,\n-        layout: TyLayout<'tcx>,\n+        val: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n+        let layout = val.layout;\n+        let val = val.to_scalar()?;\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty.sty);\n \n         match layout.ty.sty {"}, {"sha": "97ef2b5fa3485342b1b58689ed74e204fb3b1721", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n+                let val = self.unary_op(un_op, val)?;\n                 self.write_scalar(val, dest)?;\n             }\n "}, {"sha": "c2ee3f5715bd370bafa580a2acbb1522affdaeb2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -51,8 +51,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // Compare using binary_op, to also support pointer values\n                     let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n-                        discr.to_scalar()?, discr.layout,\n-                        const_int, discr.layout,\n+                        discr,\n+                        ImmTy::from_scalar(const_int, discr.layout),\n                     )?;\n                     if res.to_bool()? {\n                         target_block = targets[index];"}, {"sha": "7da00c4ea0c36f0d7bb1a80ce9f9308e47cf12d0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b376ae6671a20914d63691fdd4b543b2e6341d5b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b376ae6671a20914d63691fdd4b543b2e6341d5b", "patch": "@@ -370,13 +370,12 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n                 let (arg, _) = self.eval_operand(arg, source_info)?;\n                 let val = self.use_ecx(source_info, |this| {\n-                    let prim = this.ecx.read_scalar(arg)?.not_undef()?;\n+                    let prim = this.ecx.read_immediate(arg)?;\n                     match op {\n                         UnOp::Neg => {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n-                            let size = arg.layout.size;\n-                            if prim.to_bits(size)? == (1 << (size.bits() - 1)) {\n+                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n                                 return err!(OverflowNeg);\n                             }\n                         }\n@@ -385,7 +384,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                         }\n                     }\n                     // Now run the actual operation.\n-                    this.ecx.unary_op(op, prim, arg.layout)\n+                    this.ecx.unary_op(op, prim)\n                 })?;\n                 let res = ImmTy {\n                     imm: Immediate::Scalar(val.into()),\n@@ -446,7 +445,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op_imm(op, l, r)\n+                    this.ecx.binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Immediate::ScalarPair("}]}