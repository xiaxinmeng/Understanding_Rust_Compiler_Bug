{"sha": "28f02fbf3e26738047135a577622a313a1c3bfb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZjAyZmJmM2UyNjczODA0NzEzNWE1Nzc2MjJhMzEzYTFjM2JmYjM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-10-23T17:54:34Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-10-26T15:11:43Z"}, "message": "Suggest calling await on method call and field access\n\nWhen encountering a failing method or field resolution on a `Future`,\nlook at the `Output` and try the same operation on it. If successful,\nsuggest calling `.await` on the `Future`.\n\nThis had already been introduced in #72784, but at some point they\nstopped working.", "tree": {"sha": "8dc7346c9d7e3c6ae5c9a098997b41570826c7f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dc7346c9d7e3c6ae5c9a098997b41570826c7f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28f02fbf3e26738047135a577622a313a1c3bfb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28f02fbf3e26738047135a577622a313a1c3bfb3", "html_url": "https://github.com/rust-lang/rust/commit/28f02fbf3e26738047135a577622a313a1c3bfb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28f02fbf3e26738047135a577622a313a1c3bfb3/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f6c670c4b4273b2c7c0af07a524d4240c926bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6c670c4b4273b2c7c0af07a524d4240c926bfc", "html_url": "https://github.com/rust-lang/rust/commit/9f6c670c4b4273b2c7c0af07a524d4240c926bfc"}], "stats": {"total": 185, "additions": 90, "deletions": 95}, "files": [{"sha": "1402f70c220dd30bfc9f4a414d13b4d21746835d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f02fbf3e26738047135a577622a313a1c3bfb3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f02fbf3e26738047135a577622a313a1c3bfb3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=28f02fbf3e26738047135a577622a313a1c3bfb3", "patch": "@@ -1669,7 +1669,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n-    fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         if let ty::Opaque(def_id, substs) = ty.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n             // Future::Output"}, {"sha": "3f1edeb5108cb1227c6e5ac5e15a3d0c1e6fa1bf", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/28f02fbf3e26738047135a577622a313a1c3bfb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f02fbf3e26738047135a577622a313a1c3bfb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=28f02fbf3e26738047135a577622a313a1c3bfb3", "patch": "@@ -42,7 +42,7 @@ use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::fmt::Display;\n \n@@ -1580,51 +1580,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         field_ident: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        def_id: DefId,\n+        ty: Ty<'tcx>,\n     ) {\n-        let param_env = self.tcx().param_env(def_id);\n-        let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-        // Future::Output\n-        let item_def_id =\n-            self.tcx.associated_items(future_trait).in_definition_order().next().unwrap().def_id;\n-\n-        let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-        debug!(\"suggest_await_on_field_access: projection_ty={:?}\", projection_ty);\n-\n-        let cause = self.misc(expr.span);\n-        let mut selcx = SelectionContext::new(&self.infcx);\n-\n-        let mut obligations = vec![];\n-        if let Some(projection_ty) = projection_ty {\n-            let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n-                &mut selcx,\n-                param_env,\n-                projection_ty,\n-                cause,\n-                0,\n-                &mut obligations,\n-            );\n-            debug!(\n-                \"suggest_await_on_field_access: normalized_ty={:?}, ty_kind={:?}\",\n-                self.resolve_vars_if_possible(&normalized_ty),\n-                normalized_ty.kind(),\n-            );\n-            if let ty::Adt(def, _) = normalized_ty.kind() {\n-                // no field access on enum type\n-                if !def.is_enum() {\n-                    if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident)\n-                    {\n-                        err.span_suggestion_verbose(\n-                            base.span.shrink_to_hi(),\n-                            \"consider awaiting before field access\",\n-                            \".await\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+            Some(output_ty) => self.resolve_vars_if_possible(&output_ty),\n+            _ => return,\n+        };\n+        let mut add_label = true;\n+        if let ty::Adt(def, _) = output_ty.kind() {\n+            // no field access on enum type\n+            if !def.is_enum() {\n+                if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident) {\n+                    add_label = false;\n+                    err.span_label(\n+                        field_ident.span,\n+                        \"field not available in `impl Future`, but it is available in its `Output`\",\n+                    );\n+                    err.span_suggestion_verbose(\n+                        base.span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future` and access the field of its `Output`\",\n+                        \".await\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }\n+        if add_label {\n+            err.span_label(field_ident.span, &format!(\"field not found in `{}`\", ty));\n+        }\n     }\n \n     fn ban_nonexisting_field(\n@@ -1653,8 +1636,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n-            ty::Opaque(def_id, _) => {\n-                self.suggest_await_on_field_access(&mut err, field, base, expr, def_id);\n+            ty::Opaque(_, _) => {\n+                self.suggest_await_on_field_access(&mut err, field, base, expr_t.peel_refs());\n             }\n             _ => {}\n         }"}, {"sha": "46afe4892dbd70866df0b0ab94a1623dd571bee0", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/28f02fbf3e26738047135a577622a313a1c3bfb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f02fbf3e26738047135a577622a313a1c3bfb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=28f02fbf3e26738047135a577622a313a1c3bfb3", "patch": "@@ -21,7 +21,6 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n-use rustc_trait_selection::traits::SelectionContext;\n \n use std::cmp::Ordering;\n \n@@ -870,46 +869,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call: &hir::Expr<'_>,\n         span: Span,\n     ) {\n-        if let ty::Opaque(def_id, _) = *ty.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self\n-                .tcx\n-                .associated_items(future_trait)\n-                .in_definition_order()\n-                .next()\n-                .unwrap()\n-                .def_id;\n-\n-            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-            let cause = self.misc(span);\n-            let mut selcx = SelectionContext::new(&self.infcx);\n-            let mut obligations = vec![];\n-            if let Some(projection_ty) = projection_ty {\n-                let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n-                    &mut selcx,\n-                    self.param_env,\n-                    projection_ty,\n-                    cause,\n-                    0,\n-                    &mut obligations,\n-                );\n-                debug!(\n-                    \"suggest_await_before_method: normalized_ty={:?}, ty_kind={:?}\",\n-                    self.resolve_vars_if_possible(&normalized_ty),\n-                    normalized_ty.kind(),\n-                );\n-                let method_exists = self.method_exists(item_name, normalized_ty, call.hir_id, true);\n-                debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n-                if method_exists {\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_lo(),\n-                        \"consider awaiting before this method call\",\n-                        \"await.\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n+        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+            Some(output_ty) => self.resolve_vars_if_possible(&output_ty),\n+            _ => return,\n+        };\n+        let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n+        debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n+        if method_exists {\n+            err.span_suggestion_verbose(\n+                span.shrink_to_lo(),\n+                \"consider `await`ing on the `Future` and calling the method on its `Output`\",\n+                \"await.\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n         }\n     }\n "}, {"sha": "8a7b166cb15bd4c0a9a087ce0fc1e8e3e2bb5de7", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/28f02fbf3e26738047135a577622a313a1c3bfb3/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f02fbf3e26738047135a577622a313a1c3bfb3/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=28f02fbf3e26738047135a577622a313a1c3bfb3", "patch": "@@ -40,6 +40,14 @@ async fn foo() -> Result<(), ()> {\n \n async fn bar() -> Result<(), ()> {\n     foo()?; //~ ERROR the `?` operator can only be applied to values that implement `Try`\n+    //~^ NOTE the `?` operator cannot be applied to type `impl Future`\n+    //~| HELP the trait `Try` is not implemented for `impl Future`\n+    //~| NOTE required by `into_result`\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n     Ok(())\n }\n \n@@ -48,25 +56,42 @@ async fn struct_() -> Struct {\n }\n \n async fn tuple() -> Tuple {\n+    //~^ NOTE the `Output` of this `async fn`'s expected opaque type\n     Tuple(1i32)\n }\n \n async fn baz() -> Result<(), ()> {\n     let t = T;\n     t?; //~ ERROR the `?` operator can only be applied to values that implement `Try`\n+    //~^ NOTE the `?` operator cannot be applied to type `T`\n+    //~| HELP the trait `Try` is not implemented for `T`\n+    //~| NOTE required by `into_result`\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+\n \n     let _: i32 = tuple().0; //~ ERROR no field `0`\n+    //~^ HELP consider `await`ing on the `Future`\n+    //~| NOTE field not available in `impl Future`\n \n     let _: i32 = struct_().a; //~ ERROR no field `a`\n+    //~^ HELP consider `await`ing on the `Future`\n+    //~| NOTE field not available in `impl Future`\n \n     struct_().method(); //~ ERROR no method named\n-\n+    //~^ NOTE method not found in `impl Future`\n+    //~| HELP consider `await`ing on the `Future`\n     Ok(())\n }\n \n async fn match_() {\n-    match tuple() {\n+    match tuple() { //~ HELP consider `await`ing on the `Future`\n         Tuple(_) => {} //~ ERROR mismatched types\n+        //~^ NOTE expected opaque type, found struct `Tuple`\n+        //~| NOTE expected opaque type `impl Future`\n     }\n }\n "}, {"sha": "db6dc3ea00a8d9077d9839700847312e97ca52af", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/28f02fbf3e26738047135a577622a313a1c3bfb3/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28f02fbf3e26738047135a577622a313a1c3bfb3/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=28f02fbf3e26738047135a577622a313a1c3bfb3", "patch": "@@ -12,7 +12,7 @@ LL |     foo().await?;\n    |          ^^^^^^\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/issue-61076.rs:56:5\n+  --> $DIR/issue-61076.rs:65:5\n    |\n LL |     t?;\n    |     ^^ the `?` operator cannot be applied to type `T`\n@@ -25,25 +25,40 @@ LL |     t.await?;\n    |      ^^^^^^\n \n error[E0609]: no field `0` on type `impl Future`\n-  --> $DIR/issue-61076.rs:58:26\n+  --> $DIR/issue-61076.rs:76:26\n    |\n LL |     let _: i32 = tuple().0;\n-   |                          ^\n+   |                          ^ field not available in `impl Future`, but it is available in its `Output`\n+   |\n+help: consider `await`ing on the `Future` and access the field of its `Output`\n+   |\n+LL |     let _: i32 = tuple().await.0;\n+   |                         ^^^^^^\n \n error[E0609]: no field `a` on type `impl Future`\n-  --> $DIR/issue-61076.rs:60:28\n+  --> $DIR/issue-61076.rs:80:28\n    |\n LL |     let _: i32 = struct_().a;\n-   |                            ^\n+   |                            ^ field not available in `impl Future`, but it is available in its `Output`\n+   |\n+help: consider `await`ing on the `Future` and access the field of its `Output`\n+   |\n+LL |     let _: i32 = struct_().await.a;\n+   |                           ^^^^^^\n \n error[E0599]: no method named `method` found for opaque type `impl Future` in the current scope\n-  --> $DIR/issue-61076.rs:62:15\n+  --> $DIR/issue-61076.rs:84:15\n    |\n LL |     struct_().method();\n    |               ^^^^^^ method not found in `impl Future`\n+   |\n+help: consider `await`ing on the `Future` and calling the method on its `Output`\n+   |\n+LL |     struct_().await.method();\n+   |               ^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-61076.rs:69:9\n+  --> $DIR/issue-61076.rs:92:9\n    |\n LL | async fn tuple() -> Tuple {\n    |                     ----- the `Output` of this `async fn`'s expected opaque type"}]}