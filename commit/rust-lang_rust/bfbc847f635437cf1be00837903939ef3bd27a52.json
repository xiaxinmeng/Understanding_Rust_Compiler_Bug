{"sha": "bfbc847f635437cf1be00837903939ef3bd27a52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYmM4NDdmNjM1NDM3Y2YxYmUwMDgzNzkwMzkzOWVmM2JkMjdhNTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-03T22:55:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-03T22:56:27Z"}, "message": "rustc: Add X-ray functionality to resolve3 so the test runner works", "tree": {"sha": "0b790a8abf7fac2070a74f45e43ceac6388c8dad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b790a8abf7fac2070a74f45e43ceac6388c8dad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfbc847f635437cf1be00837903939ef3bd27a52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc847f635437cf1be00837903939ef3bd27a52", "html_url": "https://github.com/rust-lang/rust/commit/bfbc847f635437cf1be00837903939ef3bd27a52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc847f635437cf1be00837903939ef3bd27a52/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1ee1982160d2b7846b97d790db6961c022bde3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ee1982160d2b7846b97d790db6961c022bde3b", "html_url": "https://github.com/rust-lang/rust/commit/e1ee1982160d2b7846b97d790db6961c022bde3b"}], "stats": {"total": 92, "additions": 58, "deletions": 34}, "files": [{"sha": "496ddf2572cbe4f6ff53acc5143a80fdfac362f3", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc847f635437cf1be00837903939ef3bd27a52/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc847f635437cf1be00837903939ef3bd27a52/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=bfbc847f635437cf1be00837903939ef3bd27a52", "patch": "@@ -24,6 +24,7 @@ import syntax::ast::{ty_u8, ty_uint, variant, view_item, view_item_export};\n import syntax::ast::{view_item_import, view_item_use, view_path_glob};\n import syntax::ast::{view_path_list, view_path_simple};\n import syntax::ast_util::{def_id_of_def, local_def, new_def_hash, walk_pat};\n+import syntax::attr::{attr_metas, contains_name};\n import syntax::codemap::span;\n import syntax::visit::{default_visitor, fk_method, mk_vt, visit_block};\n import syntax::visit::{visit_crate, visit_expr, visit_expr_opt, visit_fn};\n@@ -125,11 +126,6 @@ enum ResolveResult<T> {\n     Success(T)      // Successfully resolved the import.\n }\n \n-enum PrivacyFilter {\n-    PrivateOrPublic,    //< Will match both public and private items.\n-    PublicOnly          //< Will match only public items.\n-}\n-\n enum TypeParameters/& {\n     NoTypeParameters,               //< No type parameters.\n     HasTypeParameters(&~[ty_param], //< Type parameters.\n@@ -161,6 +157,18 @@ enum RibKind {\n     FunctionRibKind(node_id)\n }\n \n+// The X-ray flag indicates that a context has the X-ray privilege, which\n+// allows it to reference private names. Currently, this is used for the test\n+// runner.\n+//\n+// XXX: The X-ray flag is kind of questionable in the first place. It might\n+// be better to introduce an expr_xray_path instead.\n+\n+enum XrayFlag {\n+    NoXray,     //< Private items cannot be accessed.\n+    Xray        //< Private items can be accessed.\n+}\n+\n // FIXME (issue #2550): Should be a class but then it becomes not implicitly\n // copyable due to a kind bug.\n \n@@ -380,17 +388,6 @@ class Module {\n     }\n }\n \n-pure fn is_crate_root(module: @Module) -> bool {\n-    alt module.def_id {\n-        none => {\n-            ret false;\n-        }\n-        some(def_id) => {\n-            ret def_id.crate == 0 && def_id.node == 0;\n-        }\n-    }\n-}\n-\n // XXX: This is a workaround due to is_none in the standard library mistakenly\n // requiring a T:copy.\n \n@@ -566,6 +563,10 @@ class Resolver {\n     // The current set of local scopes, for types.\n     let type_ribs: @dvec<@Rib>;\n \n+    // Whether the current context is an X-ray context. An X-ray context is\n+    // allowed to access private names of any module.\n+    let mut xray_context: XrayFlag;\n+\n     // The atom for the keyword \"self\".\n     let self_atom: Atom;\n \n@@ -598,6 +599,7 @@ class Resolver {\n         self.current_module = (*self.graph_root).get_module();\n         self.value_ribs = @dvec();\n         self.type_ribs = @dvec();\n+        self.xray_context = NoXray;\n \n         self.self_atom = (*self.atom_table).intern(@\"self\");\n         self.primitive_type_table = @PrimitiveTypeTable(self.atom_table);\n@@ -1442,7 +1444,10 @@ class Resolver {\n                                                        import_directive);\n         } else {\n             // First, resolve the module path for the directive, if necessary.\n-            alt self.resolve_module_path_for_import(module, module_path) {\n+            alt self.resolve_module_path_for_import(module,\n+                                                    module_path,\n+                                                    NoXray) {\n+\n                 Failed {\n                     resolution_result = Failed;\n                 }\n@@ -1869,8 +1874,10 @@ class Resolver {\n \n     fn resolve_module_path_from_root(module: @Module,\n                                      module_path: @dvec<Atom>,\n-                                     index: uint)\n+                                     index: uint,\n+                                     xray: XrayFlag)\n                                   -> ResolveResult<@Module> {\n+\n         let mut search_module = module;\n         let mut index = index;\n         let module_path_len = (*module_path).len();\n@@ -1882,7 +1889,7 @@ class Resolver {\n         while index < module_path_len {\n             let name = (*module_path).get_elt(index);\n             alt self.resolve_name_in_module(search_module, name, ModuleNS,\n-                                            PublicOnly) {\n+                                            xray) {\n \n                 Failed {\n                     // XXX: span_err\n@@ -1925,7 +1932,8 @@ class Resolver {\n         the given module.\n     \"]\n     fn resolve_module_path_for_import(module: @Module,\n-                                      module_path: @dvec<Atom>)\n+                                      module_path: @dvec<Atom>,\n+                                      xray: XrayFlag)\n                                    -> ResolveResult<@Module> {\n \n         let module_path_len = (*module_path).len();\n@@ -1961,7 +1969,8 @@ class Resolver {\n \n         ret self.resolve_module_path_from_root(search_module,\n                                                module_path,\n-                                               1u);\n+                                               1u,\n+                                               xray);\n     }\n \n     fn resolve_item_in_lexical_scope(module: @Module,\n@@ -2030,7 +2039,7 @@ class Resolver {\n \n             // Resolve the name in the parent module.\n             alt self.resolve_name_in_module(search_module, name, namespace,\n-                                            PrivateOrPublic) {\n+                                            Xray) {\n                 Failed {\n                     // Continue up the search chain.\n                 }\n@@ -2092,16 +2101,14 @@ class Resolver {\n     fn resolve_name_in_module(module: @Module,\n                               name: Atom,\n                               namespace: Namespace,\n-                              privacy_filter: PrivacyFilter)\n+                              xray: XrayFlag)\n                            -> ResolveResult<Target> {\n \n         #debug(\"(resolving name in module) resolving '%s' in '%s'\",\n                *(*self.atom_table).atom_to_str(name),\n                self.module_to_str(module));\n \n-        if privacy_filter == PublicOnly &&\n-                !self.name_is_exported(module, name) {\n-\n+        if xray == NoXray && !self.name_is_exported(module, name) {\n             #debug(\"(resolving name in module) name '%s' is unexported\",\n                    *(*self.atom_table).atom_to_str(name));\n             ret Failed;\n@@ -2711,6 +2718,13 @@ class Resolver {\n     fn resolve_item(item: @item, visitor: ResolveVisitor) {\n         #debug(\"(resolving item) resolving %s\", *item.ident);\n \n+        // Items with the !resolve_unexported attribute are X-ray contexts.\n+        // This is used to allow the test runner to run unexported tests.\n+        let orig_xray_flag = self.xray_context;\n+        if contains_name(attr_metas(item.attrs), \"!resolve_unexported\") {\n+            self.xray_context = Xray;\n+        }\n+\n         alt item.node {\n             item_enum(_, type_parameters, _) |\n             item_ty(_, type_parameters, _) {\n@@ -2821,7 +2835,6 @@ class Resolver {\n \n                 if !self.session.building_library &&\n                         is_none(self.session.main_fn) &&\n-                        is_crate_root(self.current_module) &&\n                         str::eq(*item.ident, \"main\") {\n \n                     self.session.main_fn = some((item.id, item.span));\n@@ -2842,10 +2855,11 @@ class Resolver {\n                 visit_item(item, (), visitor);\n             }\n         }\n+\n+        self.xray_context = orig_xray_flag;\n     }\n \n     fn with_type_parameter_rib(type_parameters: TypeParameters, f: fn()) {\n-\n         alt type_parameters {\n             HasTypeParameters(type_parameters, node_id, initial_index)\n                     if (*type_parameters).len() >= 1u {\n@@ -3496,11 +3510,15 @@ class Resolver {\n         }\n \n         if path.global {\n-            ret self.resolve_crate_relative_path(path, namespace);\n+            ret self.resolve_crate_relative_path(path,\n+                                                 self.xray_context,\n+                                                 namespace);\n         }\n \n         if path.idents.len() > 1u {\n-            ret self.resolve_module_relative_path(path, namespace);\n+            ret self.resolve_module_relative_path(path,\n+                                                  self.xray_context,\n+                                                  namespace);\n         }\n \n         ret self.resolve_identifier(path.idents.last(),\n@@ -3593,14 +3611,17 @@ class Resolver {\n         ret module_path_atoms;\n     }\n \n-    fn resolve_module_relative_path(path: @path, namespace: Namespace)\n+    fn resolve_module_relative_path(path: @path,\n+                                    +xray: XrayFlag,\n+                                    namespace: Namespace)\n                                  -> option<def> {\n \n         let module_path_atoms = self.intern_module_part_of_path(path);\n \n         let mut containing_module;\n         alt self.resolve_module_path_for_import(self.current_module,\n-                                                module_path_atoms) {\n+                                                module_path_atoms,\n+                                                xray) {\n \n             Failed {\n                 self.session.span_err(path.span,\n@@ -3640,7 +3661,9 @@ class Resolver {\n         }\n     }\n \n-    fn resolve_crate_relative_path(path: @path, namespace: Namespace)\n+    fn resolve_crate_relative_path(path: @path,\n+                                   +xray: XrayFlag,\n+                                   namespace: Namespace)\n                                 -> option<def> {\n \n         let module_path_atoms = self.intern_module_part_of_path(path);\n@@ -3650,7 +3673,8 @@ class Resolver {\n         let mut containing_module;\n         alt self.resolve_module_path_from_root(root_module,\n                                                module_path_atoms,\n-                                               0u) {\n+                                               0u,\n+                                               xray) {\n \n             Failed {\n                 self.session.span_err(path.span,"}]}