{"sha": "3cb803460b109235cf83bbfc4173e5b038ce3396", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYjgwMzQ2MGIxMDkyMzVjZjgzYmJmYzQxNzNlNWIwMzhjZTMzOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-16T21:42:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-16T21:42:17Z"}, "message": "Auto merge of #42598 - cramertj:track-more-metadata, r=nikomatsakis\n\nTrack more crate metadata\n\nPart of https://github.com/rust-lang/rust/issues/41417\nr? @nikomatsakis", "tree": {"sha": "e8d310ae57b498529cc572e15b26d9bedfe53fee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8d310ae57b498529cc572e15b26d9bedfe53fee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cb803460b109235cf83bbfc4173e5b038ce3396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb803460b109235cf83bbfc4173e5b038ce3396", "html_url": "https://github.com/rust-lang/rust/commit/3cb803460b109235cf83bbfc4173e5b038ce3396", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cb803460b109235cf83bbfc4173e5b038ce3396/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe7227f6c8704f0186091085a14fd1027920e4bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7227f6c8704f0186091085a14fd1027920e4bb", "html_url": "https://github.com/rust-lang/rust/commit/fe7227f6c8704f0186091085a14fd1027920e4bb"}, {"sha": "e6dd8692606fc966dac7315c56e9a24932bb951c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6dd8692606fc966dac7315c56e9a24932bb951c", "html_url": "https://github.com/rust-lang/rust/commit/e6dd8692606fc966dac7315c56e9a24932bb951c"}], "stats": {"total": 215, "additions": 122, "deletions": 93}, "files": [{"sha": "b061663148d4ddb87f5d4f4882173e47380a126c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -81,7 +81,7 @@ macro_rules! define_dep_nodes {\n     ($(\n         $variant:ident $(( $($tuple_arg:tt),* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n-      ),*\n+      ,)*\n     ) => (\n         #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n                  RustcEncodable, RustcDecodable)]\n@@ -394,6 +394,7 @@ define_dep_nodes!(\n     ItemSignature(DefId),\n     ItemVarianceConstraints(DefId),\n     ItemVariances(DefId),\n+    IsConstFn(DefId),\n     IsForeignItem(DefId),\n     TypeParamPredicates { item_id: DefId, param_id: DefId },\n     SizedConstraint(DefId),\n@@ -475,7 +476,11 @@ define_dep_nodes!(\n     IsExportedSymbol(DefId),\n     IsMirAvailable(DefId),\n     ItemAttrs(DefId),\n-    FnArgNames(DefId)\n+    FnArgNames(DefId),\n+    DylibDepFormats(DefId),\n+    IsAllocator(DefId),\n+    IsPanicRuntime(DefId),\n+    ExternCrate(DefId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {"}, {"sha": "95a27f065999c21bf00def7fdcf1acacc2ef5f6d", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -58,6 +58,8 @@ impl CrateNum {\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    pub fn as_def_id(&self) -> DefId { DefId { krate: *self, index: CRATE_DEF_INDEX } }\n }\n \n impl fmt::Display for CrateNum {"}, {"sha": "960d616cd4ca232ae6c6178b816cba55d7972f0e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -243,24 +243,18 @@ pub trait CrateStore {\n     fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n \n     // flags\n-    fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: CrateNum)\n-                                    -> Vec<(CrateNum, LinkagePreference)>;\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n     fn export_macros(&self, cnum: CrateNum);\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_allocator(&self, cnum: CrateNum) -> bool;\n-    fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n     fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool;\n     fn is_profiler_runtime(&self, cnum: CrateNum) -> bool;\n     fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n-    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n     fn crate_name(&self, cnum: CrateNum) -> Symbol;\n@@ -365,29 +359,22 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"associated_item_cloned\") }\n \n     // flags\n-    fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: CrateNum)\n-                                    -> Vec<(CrateNum, LinkagePreference)>\n-        { bug!(\"dylib_dependency_formats\") }\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n         { bug!(\"lang_items\") }\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n     fn export_macros(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n-    fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n-    fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n     fn is_profiler_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_profiler_runtime\") }\n     fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_sanitizer_runtime\") }\n     fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         bug!(\"panic_strategy\")\n     }\n-    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n     fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n     fn original_crate_name(&self, cnum: CrateNum) -> Symbol {\n         bug!(\"original_crate_name\")"}, {"sha": "4e1f06cca06cc087b4b869db74ab7645c4d02c29", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -65,6 +65,7 @@ use hir::def_id::CrateNum;\n \n use session;\n use session::config;\n+use ty::TyCtxt;\n use middle::cstore::DepKind;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FxHashMap;\n@@ -91,18 +92,22 @@ pub enum Linkage {\n     Dynamic,\n }\n \n-pub fn calculate(sess: &session::Session) {\n+pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let sess = &tcx.sess;\n     let mut fmts = sess.dependency_formats.borrow_mut();\n     for &ty in sess.crate_types.borrow().iter() {\n-        let linkage = calculate_type(sess, ty);\n-        verify_ok(sess, &linkage);\n+        let linkage = calculate_type(tcx, ty);\n+        verify_ok(tcx, &linkage);\n         fmts.insert(ty, linkage);\n     }\n     sess.abort_if_errors();\n }\n \n-fn calculate_type(sess: &session::Session,\n-                  ty: config::CrateType) -> DependencyList {\n+fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            ty: config::CrateType) -> DependencyList {\n+\n+    let sess = &tcx.sess;\n+\n     if !sess.opts.output_types.should_trans() {\n         return Vec::new();\n     }\n@@ -111,7 +116,7 @@ fn calculate_type(sess: &session::Session,\n         // If the global prefer_dynamic switch is turned off, first attempt\n         // static linkage (this can fail).\n         config::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic => {\n-            if let Some(v) = attempt_static(sess) {\n+            if let Some(v) = attempt_static(tcx) {\n                 return v;\n             }\n         }\n@@ -124,7 +129,7 @@ fn calculate_type(sess: &session::Session,\n         // to be found, we generate some nice pretty errors.\n         config::CrateTypeStaticlib |\n         config::CrateTypeCdylib => {\n-            if let Some(v) = attempt_static(sess) {\n+            if let Some(v) = attempt_static(tcx) {\n                 return v;\n             }\n             for cnum in sess.cstore.crates() {\n@@ -141,7 +146,7 @@ fn calculate_type(sess: &session::Session,\n         // to try to eagerly statically link all dependencies. This is normally\n         // done for end-product dylibs, not intermediate products.\n         config::CrateTypeDylib if !sess.opts.cg.prefer_dynamic => {\n-            if let Some(v) = attempt_static(sess) {\n+            if let Some(v) = attempt_static(tcx) {\n                 return v;\n             }\n         }\n@@ -167,8 +172,8 @@ fn calculate_type(sess: &session::Session,\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", name);\n             add_library(sess, cnum, RequireDynamic, &mut formats);\n-            let deps = sess.cstore.dylib_dependency_formats(cnum);\n-            for &(depnum, style) in &deps {\n+            let deps = tcx.dylib_dependency_formats(cnum.as_def_id());\n+            for &(depnum, style) in deps.iter() {\n                 info!(\"adding {:?}: {}\", style,\n                       sess.cstore.crate_name(depnum));\n                 add_library(sess, depnum, style, &mut formats);\n@@ -210,9 +215,9 @@ fn calculate_type(sess: &session::Session,\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n     activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n-                          &|cnum| sess.cstore.is_allocator(cnum));\n+                          &|cnum| tcx.is_allocator(cnum.as_def_id()));\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| sess.cstore.is_panic_runtime(cnum));\n+                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n     // It could be the case, however, that the rlib for A is present (hence we\n@@ -269,7 +274,8 @@ fn add_library(sess: &session::Session,\n     }\n }\n \n-fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n+fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyList> {\n+    let sess = &tcx.sess;\n     let crates = sess.cstore.used_crates(RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n@@ -290,9 +296,9 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n     activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n-                          &|cnum| sess.cstore.is_allocator(cnum));\n+                          &|cnum| tcx.is_allocator(cnum.as_def_id()));\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| sess.cstore.is_panic_runtime(cnum));\n+                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n \n     Some(ret)\n }\n@@ -327,7 +333,8 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n \n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n-fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n+fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n+    let sess = &tcx.sess;\n     if list.len() == 0 {\n         return\n     }\n@@ -338,7 +345,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n             continue\n         }\n         let cnum = CrateNum::new(i + 1);\n-        if sess.cstore.is_allocator(cnum) {\n+        if tcx.is_allocator(cnum.as_def_id()) {\n             if let Some(prev) = allocator {\n                 let prev_name = sess.cstore.crate_name(prev);\n                 let cur_name = sess.cstore.crate_name(cnum);\n@@ -349,7 +356,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n             allocator = Some(cnum);\n         }\n \n-        if sess.cstore.is_panic_runtime(cnum) {\n+        if tcx.is_panic_runtime(cnum.as_def_id()) {\n             if let Some((prev, _)) = panic_runtime {\n                 let prev_name = sess.cstore.crate_name(prev);\n                 let cur_name = sess.cstore.crate_name(cnum);"}, {"sha": "09a3bcd06138056afaa89b6641d415a5b8ab4c56", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // Returns `None` for the local crate.\n                 if cnum != LOCAL_CRATE {\n-                    let opt_extern_crate = self.sess.cstore.extern_crate(cnum);\n+                    let opt_extern_crate = self.extern_crate(cnum.as_def_id());\n                     let opt_extern_crate = opt_extern_crate.and_then(|extern_crate| {\n                         if extern_crate.direct {\n                             Some(extern_crate.def_id)\n@@ -136,8 +136,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // If `cur_def` is a direct or injected extern crate, push the path to the crate\n             // followed by the path to the item within the crate and return.\n             if cur_def.index == CRATE_DEF_INDEX {\n-                match self.sess.cstore.extern_crate(cur_def.krate) {\n-                    Some(extern_crate) if extern_crate.direct => {\n+                match *self.extern_crate(cur_def) {\n+                    Some(ref extern_crate) if extern_crate.direct => {\n                         self.push_item_path(buffer, extern_crate.def_id);\n                         cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n                         return true;"}, {"sha": "524cf57472bc86dca71d4210e93381decd9df056", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -13,6 +13,7 @@ use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n use middle::const_val;\n+use middle::cstore::{ExternCrate, LinkagePreference};\n use middle::privacy::AccessLevels;\n use middle::region::RegionMaps;\n use mir;\n@@ -476,6 +477,36 @@ impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"dylib dependency formats of crate\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_allocator<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"checking if the crate is_allocator\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"checking if the crate is_panic_runtime\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"getting crate's ExternCrateData\".to_string()\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -791,6 +822,9 @@ define_maps! { <'tcx>\n     [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n     [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n+    /// True if this is a const fn\n+    [] is_const_fn: IsConstFn(DefId) -> bool,\n+\n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n@@ -929,6 +963,14 @@ define_maps! { <'tcx>\n     [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n+\n+    [] dylib_dependency_formats: DylibDepFormats(DefId)\n+                                    -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n+\n+    [] is_allocator: IsAllocator(DefId) -> bool,\n+    [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n+\n+    [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n }\n \n fn type_param_predicates((item_id, param_id): (DefId, DefId)) -> DepConstructor {"}, {"sha": "4ce985568ce23adaf9bcfcf4f1d04819566712d5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -351,7 +351,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 signal!(e, TypeckError)\n             }\n           } else {\n-            if tcx.sess.cstore.is_const_fn(def_id) {\n+            if tcx.is_const_fn(def_id) {\n                 tcx.sess.cstore.item_body(tcx, def_id)\n             } else {\n                 signal!(e, TypeckError)"}, {"sha": "792be8bc6dfa9827a0ac0b31ab65bb8e15e3c2bd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -900,6 +900,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n+    cstore::provide_local(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n@@ -1050,7 +1051,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     time(time_passes,\n          \"resolving dependency formats\",\n-         || dependency_format::calculate(&tcx.sess));\n+         || dependency_format::calculate(tcx));\n \n     let translation =\n         time(time_passes,"}, {"sha": "86146fe3947bcb06db134d6a5b747dd97012163a", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -34,7 +34,7 @@ pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePrefere\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n-pub use cstore_impl::provide;\n+pub use cstore_impl::{provide, provide_local};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external"}, {"sha": "c49712086d52c2aff46e5483d7629f275535cbce", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -14,7 +14,7 @@ use schema;\n \n use rustc::dep_graph::DepTrackingMapConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            ExternCrate, NativeLibrary, MetadataLoader, LinkMeta,\n+                            NativeLibrary, MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata};\n use rustc::hir::def;\n use rustc::middle::lang_items;\n@@ -23,6 +23,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData, DefPathHash};\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n@@ -39,7 +40,7 @@ use rustc::hir::svh::Svh;\n use rustc::hir;\n \n macro_rules! provide {\n-    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident $($name:ident => $compute:block)*) => {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident, $($name:ident => $compute:block)*) => {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n             $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n                                     -> <ty::queries::$name<$lt> as\n@@ -65,7 +66,7 @@ macro_rules! provide {\n     }\n }\n \n-provide! { <'tcx> tcx, def_id, cdata\n+provide! { <'tcx> tcx, def_id, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n     generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n     predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n@@ -81,7 +82,8 @@ provide! { <'tcx> tcx, def_id, cdata\n     variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n         let mut result = vec![];\n-        cdata.each_child_of_item(def_id.index, |child| result.push(child.def.def_id()), tcx.sess);\n+        cdata.each_child_of_item(def_id.index,\n+          |child| result.push(child.def.def_id()), tcx.sess);\n         Rc::new(result)\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n@@ -106,6 +108,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    is_const_fn => { cdata.is_const_fn(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     is_default_impl => { cdata.is_default_impl(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n@@ -129,6 +132,29 @@ provide! { <'tcx> tcx, def_id, cdata\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n     }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n+\n+    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n+    is_allocator => { cdata.is_allocator(&tcx.dep_graph) }\n+    is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n+    extern_crate => { Rc::new(cdata.extern_crate.get()) }\n+}\n+\n+pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n+    fn is_const_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+        let node_id = tcx.hir.as_local_node_id(def_id)\n+                             .expect(\"Non-local call to local provider is_const_fn\");\n+\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+            fn_like.constness() == hir::Constness::Const\n+        } else {\n+            false\n+        }\n+    }\n+\n+    *providers = Providers {\n+        is_const_fn,\n+        ..*providers\n+    };\n }\n \n impl CrateStore for cstore::CStore {\n@@ -172,12 +198,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n-    fn is_const_fn(&self, did: DefId) -> bool\n-    {\n-        self.read_dep_node(did);\n-        self.get_crate_data(did.krate).is_const_fn(did.index)\n-    }\n-\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool\n     {\n         self.do_is_statically_included_foreign_item(def_id)\n@@ -192,12 +212,6 @@ impl CrateStore for cstore::CStore {\n         }\n     }\n \n-    fn dylib_dependency_formats(&self, cnum: CrateNum)\n-                                -> Vec<(CrateNum, LinkagePreference)>\n-    {\n-        self.get_crate_data(cnum).get_dylib_dependency_formats(&self.dep_graph)\n-    }\n-\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind\n     {\n         let data = self.get_crate_data(cnum);\n@@ -227,16 +241,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).get_missing_lang_items(&self.dep_graph)\n     }\n \n-    fn is_allocator(&self, cnum: CrateNum) -> bool\n-    {\n-        self.get_crate_data(cnum).is_allocator(&self.dep_graph)\n-    }\n-\n-    fn is_panic_runtime(&self, cnum: CrateNum) -> bool\n-    {\n-        self.get_crate_data(cnum).is_panic_runtime(&self.dep_graph)\n-    }\n-\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n         self.get_crate_data(cnum).is_compiler_builtins(&self.dep_graph)\n     }\n@@ -263,11 +267,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).name()\n     }\n \n-    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n-    {\n-        self.get_crate_data(cnum).extern_crate.get()\n-    }\n-\n     fn crate_hash(&self, cnum: CrateNum) -> Svh\n     {\n         self.get_crate_hash(cnum)"}, {"sha": "dec0717e9e38355454b4f12311cd79cfdfd92ece", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -34,7 +34,6 @@ use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use util::def_use::DefUseAnalysis;\n-use transform::qualify_consts;\n \n pub struct CopyPropagation;\n \n@@ -55,7 +54,7 @@ impl MirPass for CopyPropagation {\n                 return\n             }\n             MirSource::Fn(function_node_id) => {\n-                if qualify_consts::is_const_fn(tcx, tcx.hir.local_def_id(function_node_id)) {\n+                if tcx.is_const_fn(tcx.hir.local_def_id(function_node_id)) {\n                     // Don't run on const functions, as, again, trans might not be able to evaluate\n                     // the optimized IR.\n                     return"}, {"sha": "8342d0ff491ec58bfc0b8d4e7c81227279df379d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n@@ -109,18 +108,6 @@ impl fmt::Display for Mode {\n     }\n }\n \n-pub fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n-            fn_like.constness() == hir::Constness::Const\n-        } else {\n-            false\n-        }\n-    } else {\n-        tcx.sess.cstore.is_const_fn(def_id)\n-    }\n-}\n-\n struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mode: Mode,\n     span: Span,\n@@ -766,7 +753,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 ty::TyFnDef(def_id, _, f) => {\n                     (f.abi() == Abi::PlatformIntrinsic &&\n                      self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n-                     is_const_fn(self.tcx, def_id))\n+                     self.tcx.is_const_fn(def_id))\n                 }\n                 _ => (false, false)\n             };\n@@ -957,7 +944,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         let def_id = tcx.hir.local_def_id(id);\n         let mode = match src {\n             MirSource::Fn(_) => {\n-                if is_const_fn(tcx, def_id) {\n+                if tcx.is_const_fn(def_id) {\n                     Mode::ConstFn\n                 } else {\n                     Mode::Fn"}, {"sha": "bec4c083905a9c0144431a1a21eeb93d3eb9b89f", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 fn_like.constness() == hir::Constness::Const\n             })\n         } else {\n-            self.tcx.sess.cstore.is_const_fn(def_id)\n+            self.tcx.is_const_fn(def_id)\n         };\n     }\n }"}, {"sha": "4ab2c1aa63c5c89d1664040bfc990cdf5b730eab", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -107,7 +107,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = Vec::new();\n \n         for n in self.tcx.sess.cstore.crates() {\n-            let span = match self.tcx.sess.cstore.extern_crate(n) {\n+            let span = match *self.tcx.extern_crate(n.as_def_id()) {\n                 Some(ref c) => c.span,\n                 None => {\n                     debug!(\"Skipping crate {}, no data\", n);"}, {"sha": "b38dc18838923196d527ee64900398c7a4f6c8bb", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -92,8 +92,8 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                scx.sess().cstore.is_allocator(cnum) ||\n-                scx.sess().cstore.is_panic_runtime(cnum) ||\n+                scx.tcx().is_allocator(cnum.as_def_id()) ||\n+                scx.tcx().is_panic_runtime(cnum.as_def_id()) ||\n                 scx.sess().cstore.is_compiler_builtins(cnum);\n \n             let crate_exports = scx"}, {"sha": "aeade47048223bef2b88e0c0a5781f789f50f646", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb803460b109235cf83bbfc4173e5b038ce3396/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3cb803460b109235cf83bbfc4173e5b038ce3396", "patch": "@@ -151,7 +151,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n     let sig = cx.tcx.type_of(did).fn_sig();\n \n-    let constness = if cx.tcx.sess.cstore.is_const_fn(did) {\n+    let constness = if cx.tcx.is_const_fn(did) {\n         hir::Constness::Const\n     } else {\n         hir::Constness::NotConst\n@@ -352,7 +352,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                     clean::TyMethodItem(clean::TyMethod {\n                         unsafety, decl, generics, abi\n                     }) => {\n-                        let constness = if tcx.sess.cstore.is_const_fn(item.def_id) {\n+                        let constness = if tcx.is_const_fn(item.def_id) {\n                             hir::Constness::Const\n                         } else {\n                             hir::Constness::NotConst"}]}