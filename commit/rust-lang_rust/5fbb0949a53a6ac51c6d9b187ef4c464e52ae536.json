{"sha": "5fbb0949a53a6ac51c6d9b187ef4c464e52ae536", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYmIwOTQ5YTUzYTZhYzUxYzZkOWIxODdlZjRjNDY0ZTUyYWU1MzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-22T21:52:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-22T22:08:47Z"}, "message": "core::rt: Add implementations of Reader, Writer, and Listener for Option\n\nThese will make it easier to write I/O code without worrying about errors", "tree": {"sha": "412f3a63b3278e97bc57105e28bc13e0cf5c53a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/412f3a63b3278e97bc57105e28bc13e0cf5c53a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536", "html_url": "https://github.com/rust-lang/rust/commit/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe13b865192028645b50c17d2cb1a6d44481f338", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe13b865192028645b50c17d2cb1a6d44481f338", "html_url": "https://github.com/rust-lang/rust/commit/fe13b865192028645b50c17d2cb1a6d44481f338"}], "stats": {"total": 177, "additions": 174, "deletions": 3}, "files": [{"sha": "d9d6622277f77f6e3310ee97b677ab89ae2863e9", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=5fbb0949a53a6ac51c6d9b187ef4c464e52ae536", "patch": "@@ -152,6 +152,9 @@ pub mod mem;\n /// Non-blocking access to stdin, stdout, stderr\n pub mod stdio;\n \n+/// Implementations for Option\n+mod option;\n+\n /// Basic stream compression. XXX: Belongs with other flate code\n #[cfg(not(stage0))] // XXX Using unsnapshotted features\n pub mod flate;\n@@ -194,12 +197,14 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n+#[deriving(Eq)]\n pub enum IoErrorKind {\n     FileNotFound,\n     FilePermission,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError\n+    OtherIoError,\n+    PreviousIoError\n }\n \n // XXX: Can't put doc comments on macros\n@@ -232,9 +237,9 @@ pub trait Reader {\n     ///         println(reader.read_line());\n     ///     }\n     ///\n-    /// # XXX\n+    /// # Failue\n     ///\n-    /// What does this return if the Reader is in an error state?\n+    /// Returns `true` on failure.\n     fn eof(&mut self) -> bool;\n }\n \n@@ -323,3 +328,16 @@ pub trait Decorator<T> {\n     /// Take a mutable reference to the decorated value\n     fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n }\n+\n+pub fn standard_error(kind: IoErrorKind) -> IoError {\n+    match kind {\n+        PreviousIoError => {\n+            IoError {\n+                kind: PreviousIoError,\n+                desc: \"Failing due to a previous I/O error\",\n+                detail: None\n+            }\n+        }\n+        _ => fail!()\n+    }\n+}"}, {"sha": "95f8711cb5bd555bd893a3ce7874054fb7b4e1bc", "filename": "src/libcore/rt/io/option.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbb0949a53a6ac51c6d9b187ef4c464e52ae536/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=5fbb0949a53a6ac51c6d9b187ef4c464e52ae536", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of I/O traits for the Option type\n+//!\n+//! I/O constructors return option types to allow errors to be handled.\n+//! These implementations allow e.g. `Option<FileStream>` to be used\n+//! as a `Reader` without unwrapping the option first.\n+//!\n+//! # XXX Seek and Close\n+\n+use option::*;\n+use super::{Reader, Writer, Listener};\n+use super::{standard_error, PreviousIoError, io_error, IoError};\n+\n+fn prev_io_error() -> IoError {\n+    standard_error(PreviousIoError)\n+}\n+\n+impl<W: Writer> Writer for Option<W> {\n+    fn write(&mut self, buf: &[u8]) {\n+        match *self {\n+            Some(ref mut writer) => writer.write(buf),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+\n+    fn flush(&mut self) {\n+        match *self {\n+            Some(ref mut writer) => writer.flush(),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Reader for Option<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match *self {\n+            Some(ref mut reader) => reader.read(buf),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        match *self {\n+            Some(ref mut reader) => reader.eof(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                true\n+            }\n+        }\n+    }\n+}\n+\n+impl<L: Listener<S>, S> Listener<S> for Option<L> {\n+    fn accept(&mut self) -> Option<S> {\n+        match *self {\n+            Some(ref mut listener) => listener.accept(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::*;\n+    use super::super::mem::*;\n+    use rt::test::*;\n+    use super::super::{PreviousIoError, io_error};\n+\n+    #[test]\n+    fn test_option_writer() {\n+        do run_in_newsched_task {\n+            let mut writer: Option<MemWriter> = Some(MemWriter::new());\n+            writer.write([0, 1, 2]);\n+            writer.flush();\n+            assert!(writer.unwrap().inner() == ~[0, 1, 2]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_writer_error() {\n+        do run_in_newsched_task {\n+            let mut writer: Option<MemWriter> = None;\n+\n+            let mut called = false;\n+            do io_error::cond.trap(|err| {\n+                assert!(err.kind == PreviousIoError);\n+                called = true;\n+            }).in {\n+                writer.write([0, 0, 0]);\n+            }\n+            assert!(called);\n+\n+            let mut called = false;\n+            do io_error::cond.trap(|err| {\n+                assert!(err.kind == PreviousIoError);\n+                called = true;\n+            }).in {\n+                writer.flush();\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader() {\n+        do run_in_newsched_task {\n+            let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n+            let mut buf = [0, 0];\n+            reader.read(buf);\n+            assert!(buf == [0, 1]);\n+            assert!(!reader.eof());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader_error() {\n+        let mut reader: Option<MemReader> = None;\n+        let mut buf = [];\n+\n+        let mut called = false;\n+        do io_error::cond.trap(|err| {\n+            assert!(err.kind == PreviousIoError);\n+            called = true;\n+        }).in {\n+            reader.read(buf);\n+        }\n+        assert!(called);\n+\n+        let mut called = false;\n+        do io_error::cond.trap(|err| {\n+            assert!(err.kind == PreviousIoError);\n+            called = true;\n+        }).in {\n+            assert!(reader.eof());\n+        }\n+        assert!(called);\n+    }\n+}"}]}