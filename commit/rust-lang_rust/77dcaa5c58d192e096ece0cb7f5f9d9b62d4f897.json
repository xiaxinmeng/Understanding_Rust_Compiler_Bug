{"sha": "77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZGNhYTVjNThkMTkyZTA5NmVjZTBjYjdmNWY5ZDliNjJkNGY4OTc=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-05-19T22:43:46Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-05-20T10:27:09Z"}, "message": "collections: Reorder slice methods to improve API docs\n\nWe have an evolutionary history whose traces are still visible in the\nslice docs today.\n\nSome heuristics:\n\n* Group method and method_mut together\n* Group method and method_by together\n* Group by use case, here we have roughly:\n\n  Basic interrogators (len)\n  Mutation (swap)\n  Iterators (iter)\n  Segmentation (split)\n  Searching (contains)\n  Permutations (permutations)\n  Misc (clone_from_slice)", "tree": {"sha": "6e3d729b88c52535cf5800c7ccebe092a1db3ca8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e3d729b88c52535cf5800c7ccebe092a1db3ca8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897", "html_url": "https://github.com/rust-lang/rust/commit/77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93701b399b2d3cbb056c1eaaf1fba421585bb2bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/93701b399b2d3cbb056c1eaaf1fba421585bb2bd", "html_url": "https://github.com/rust-lang/rust/commit/93701b399b2d3cbb056c1eaaf1fba421585bb2bd"}], "stats": {"total": 908, "additions": 454, "deletions": 454}, "files": [{"sha": "7ff28019de8446af89ab76e8d6f72bb4f59bb81b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 454, "deletions": 454, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=77dcaa5c58d192e096ece0cb7f5f9d9b62d4f897", "patch": "@@ -221,208 +221,110 @@ mod hack {\n #[cfg(not(test))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> [T] {\n-    /// Sorts the slice, in place, using `compare` to compare\n-    /// elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Examples\n+    /// Returns the number of elements in the slice.\n     ///\n-    /// ```rust\n-    /// let mut v = [5, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n+    /// # Example\n     ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n-        merge_sort(self, compare)\n+    pub fn len(&self) -> usize {\n+        core_slice::SliceExt::len(self)\n     }\n \n-    /// Consumes `src` and moves as many elements as it can into `self`\n-    /// from the range [start,end).\n-    ///\n-    /// Returns the number of elements copied (the shorter of `self.len()`\n-    /// and `end - start`).\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A mutable vector of `T`\n-    /// * start - The index into `src` to start copying from\n-    /// * end - The index into `src` to stop copying from\n+    /// Returns true if the slice has a length of 0\n     ///\n-    /// # Examples\n+    /// # Example\n     ///\n-    /// ```rust\n-    /// # #![feature(collections)]\n-    /// let mut a = [1, 2, 3, 4, 5];\n-    /// let b = vec![6, 7, 8];\n-    /// let num_moved = a.move_from(b, 0, 3);\n-    /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"uncertain about this API approach\")]\n+    /// let a = [1, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n-        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n-            mem::swap(a, b);\n-        }\n-        cmp::min(self.len(), end-start)\n+    pub fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n     }\n \n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n+    /// Returns the first element of a slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = [10, 40, 30, 20, 50];\n-    /// let (v1, v2) = v.split_at(2);\n-    /// assert_eq!([10, 40], v1);\n-    /// assert_eq!([30, 20, 50], v2);\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&10), v.first());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.first());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n+    pub fn first(&self) -> Option<&T> {\n+        core_slice::SliceExt::first(self)\n     }\n \n-    /// Returns an iterator over the slice.\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn iter(&self) -> Iter<T> {\n-        core_slice::SliceExt::iter(self)\n+    pub fn first_mut(&mut self) -> Option<&mut T> {\n+        core_slice::SliceExt::first_mut(self)\n     }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20]`, `[50]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.split(|num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Returns all but the first element of a slice.\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     #[inline]\n-    pub fn split<F>(&self, pred: F) -> Split<T, F> where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split(self, pred)\n+    pub fn tail(&self) -> &[T] {\n+        core_slice::SliceExt::tail(self)\n     }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items.  The matched element is\n-    /// not contained in the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20, 60, 50]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Returns all but the first element of a mutable slice\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n     #[inline]\n-    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F> where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn(self, n, pred)\n+    pub fn tail_mut(&mut self) -> &mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n     }\n \n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once, starting from the end, by numbers divisible\n-    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Returns all but the last element of a slice.\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     #[inline]\n-    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F> where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n+    pub fn init(&self) -> &[T] {\n+        core_slice::SliceExt::init(self)\n     }\n \n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n+    /// Returns all but the last element of a mutable slice\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n+    #[inline]\n+    pub fn init_mut(&mut self) -> &mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&30), v.last());\n     ///\n-    /// ```rust\n-    /// let v = &[1, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{:?}\", win);\n-    /// }\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.last());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn windows(&self, size: usize) -> Windows<T> {\n-        core_slice::SliceExt::windows(self, size)\n+    pub fn last(&self) -> Option<&T> {\n+        core_slice::SliceExt::last(self)\n     }\n \n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{:?}\", win);\n-    /// }\n-    /// ```\n+    /// Returns a mutable pointer to the last item in the slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn chunks(&self, size: usize) -> Chunks<T> {\n-        core_slice::SliceExt::chunks(self, size)\n+    pub fn last_mut(&mut self) -> Option<&mut T> {\n+        core_slice::SliceExt::last_mut(self)\n     }\n \n     /// Returns the element of a slice at the given index, or `None` if the\n@@ -441,63 +343,43 @@ impl<T> [T] {\n         core_slice::SliceExt::get(self, index)\n     }\n \n-    /// Returns the first element of a slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&10), v.first());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.first());\n-    /// ```\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn first(&self) -> Option<&T> {\n-        core_slice::SliceExt::first(self)\n+    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    /// Returns all but the first element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn tail(&self) -> &[T] {\n-        core_slice::SliceExt::tail(self)\n+    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n+        core_slice::SliceExt::get_unchecked(self, index)\n     }\n \n-    /// Returns all but the last element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn init(&self) -> &[T] {\n-        core_slice::SliceExt::init(self)\n+    pub unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n+        core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n-    /// Returns the last element of a slice, or `None` if it is empty.\n+    /// Returns an unsafe pointer to the slice's buffer\n     ///\n-    /// # Examples\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n     ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&30), v.last());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.last());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn last(&self) -> Option<&T> {\n-        core_slice::SliceExt::last(self)\n-    }\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n-        core_slice::SliceExt::get_unchecked(self, index)\n+    pub fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n     }\n \n-    /// Returns an unsafe pointer to the slice's buffer\n+    /// Returns an unsafe mutable pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage.\n@@ -506,118 +388,208 @@ impl<T> [T] {\n     /// would also make any pointers to it invalid.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n     }\n \n-    /// Binary search a sorted slice with a comparator function.\n+    /// Swaps two elements in a slice.\n     ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n+    /// # Arguments\n     ///\n-    /// If a matching value is found then returns `Ok`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n     ///\n-    /// # Example\n+    /// # Panics\n     ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// Panics if `a` or `b` are out of bounds.\n     ///\n-    /// ```rust\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// # Example\n     ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where F: FnMut(&T) -> Ordering {\n-        core_slice::SliceExt::binary_search_by(self, f)\n+    pub fn swap(&mut self, a: usize, b: usize) {\n+        core_slice::SliceExt::swap(self, a, b)\n     }\n \n-    /// Returns the number of elements in the slice.\n+    /// Reverse the order of elements in a slice, in place.\n     ///\n     /// # Example\n     ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n+    /// ```rust\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3, 2, 1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn len(&self) -> usize {\n-        core_slice::SliceExt::len(self)\n+    pub fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n     }\n \n-    /// Returns true if the slice has a length of 0\n+    /// Returns an iterator over the slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter(&self) -> Iter<T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n+\n+    /// Returns an iterator that allows modifying each value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n+\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n     ///\n     /// # Example\n     ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert!(!a.is_empty());\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{:?}\", win);\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n+    pub fn windows(&self, size: usize) -> Windows<T> {\n+        core_slice::SliceExt::windows(self, size)\n     }\n \n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{:?}\", win);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n-        core_slice::SliceExt::get_mut(self, index)\n+    pub fn chunks(&self, size: usize) -> Chunks<T> {\n+        core_slice::SliceExt::chunks(self, size)\n     }\n \n-    /// Returns an iterator that allows modifying each value\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn iter_mut(&mut self) -> IterMut<T> {\n-        core_slice::SliceExt::iter_mut(self)\n+    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n     }\n \n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 50];\n+    /// let (v1, v2) = v.split_at(2);\n+    /// assert_eq!([10, 40], v1);\n+    /// assert_eq!([30, 20, 50], v2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn first_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::first_mut(self)\n-    }\n-\n-    /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"collections\",\n-               reason = \"likely to be renamed or removed\")]\n-    #[inline]\n-    pub fn tail_mut(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::tail_mut(self)\n+    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n     }\n \n-    /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"collections\",\n-               reason = \"likely to be renamed or removed\")]\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn init_mut(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::init_mut(self)\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n     }\n \n-    /// Returns a mutable pointer to the last item in the slice.\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20]`, `[50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.split(|num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn last_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::last_mut(self)\n+    pub fn split<F>(&self, pred: F) -> Split<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -628,6 +600,30 @@ impl<T> [T] {\n         core_slice::SliceExt::split_mut(self, pred)\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to returning at most `n` items.  The matched element is\n+    /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20, 60, 50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to returning at most `n` items.  The matched element is\n     /// not contained in the subslices.\n@@ -641,6 +637,31 @@ impl<T> [T] {\n         core_slice::SliceExt::splitn_mut(self, n, pred)\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once, starting from the end, by numbers divisible\n+    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n@@ -655,125 +676,167 @@ impl<T> [T] {\n         core_slice::SliceExt::rsplitn_mut(self, n, pred)\n     }\n \n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n+    /// Returns true if the slice contains an element with the given value.\n     ///\n-    /// # Panics\n+    /// # Examples\n     ///\n-    /// Panics if `chunk_size` is 0.\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.contains(&30));\n+    /// assert!(!v.contains(&50));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    pub fn contains(&self, x: &T) -> bool where T: PartialEq {\n+        core_slice::SliceExt::contains(self, x)\n     }\n \n-    /// Swaps two elements in a slice.\n+    /// Returns true if `needle` is a prefix of the slice.\n     ///\n-    /// # Arguments\n+    /// # Examples\n     ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.starts_with(&[10]));\n+    /// assert!(v.starts_with(&[10, 40]));\n+    /// assert!(!v.starts_with(&[50]));\n+    /// assert!(!v.starts_with(&[10, 50]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::starts_with(self, needle)\n+    }\n+\n+    /// Returns true if `needle` is a suffix of the slice.\n     ///\n-    /// # Panics\n+    /// # Examples\n     ///\n-    /// Panics if `a` or `b` are out of bounds.\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.ends_with(&[30]));\n+    /// assert!(v.ends_with(&[40, 30]));\n+    /// assert!(!v.ends_with(&[50]));\n+    /// assert!(!v.ends_with(&[50, 30]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::ends_with(self, needle)\n+    }\n+\n+    /// Find the first index containing a matching value.\n+    #[unstable(feature = \"collections\")]\n+    pub fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n+        core_slice::SliceExt::position_elem(self, t)\n+    }\n+\n+    /// Find the last index containing a matching value.\n+    #[unstable(feature = \"collections\")]\n+    pub fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n+        core_slice::SliceExt::rposition_elem(self, t)\n+    }\n+\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n     /// # Example\n     ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n     /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn swap(&mut self, a: usize, b: usize) {\n-        core_slice::SliceExt::swap(self, a, b)\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n+        core_slice::SliceExt::binary_search(self, x)\n     }\n \n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    /// Binary search a sorted slice with a comparator function.\n     ///\n-    /// # Panics\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n     ///\n-    /// Panics if `mid > len`.\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// let mut v = [1, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n-    /// }\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n     ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n-    /// }\n+    /// ```rust\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n+    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n-    /// Reverse the order of elements in a slice, in place.\n+    /// Sorts the slice, in place.\n     ///\n-    /// # Example\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Examples\n     ///\n     /// ```rust\n-    /// let mut v = [1, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n-        core_slice::SliceExt::get_unchecked_mut(self, index)\n+    pub fn sort(&mut self) where T: Ord {\n+        self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    /// Returns an unsafe mutable pointer to the slice's buffer.\n+    /// Sorts the slice, in place, using `compare` to compare\n+    /// elements.\n     ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n     ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n-    }\n-\n-    /// Copies `self` into a new `Vec`.\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [5, 4, 1, 3, 2];\n+    /// v.sort_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn to_vec(&self) -> Vec<T> where T: Clone {\n-        // NB see hack module in this file\n-        hack::to_vec(self)\n+    pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+        merge_sort(self, compare)\n     }\n \n     /// Creates an iterator that yields every possible permutation of the\n@@ -809,74 +872,6 @@ impl<T> [T] {\n         hack::permutations(self)\n     }\n \n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(collections)]\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3, 4, 5]);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n-        core_slice::SliceExt::clone_from_slice(self, src)\n-    }\n-\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5, -3, 1, 2, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn sort(&mut self) where T: Ord {\n-        self.sort_by(|a, b| a.cmp(b))\n-    }\n-\n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n-        core_slice::SliceExt::binary_search(self, x)\n-    }\n-\n     /// Mutates the slice to the next lexicographic permutation.\n     ///\n     /// Returns `true` if successful and `false` if the slice is at the\n@@ -923,62 +918,67 @@ impl<T> [T] {\n         core_slice::SliceExt::prev_permutation(self)\n     }\n \n-    /// Find the first index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n-    pub fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n-        core_slice::SliceExt::position_elem(self, t)\n-    }\n-\n-    /// Find the last index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n-    pub fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n-        core_slice::SliceExt::rposition_elem(self, t)\n-    }\n-\n-    /// Returns true if the slice contains an element with the given value.\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n     ///\n-    /// # Examples\n+    /// # Example\n     ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.contains(&30));\n-    /// assert!(!v.contains(&50));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, x: &T) -> bool where T: PartialEq {\n-        core_slice::SliceExt::contains(self, x)\n-    }\n-\n-    /// Returns true if `needle` is a prefix of the slice.\n+    /// ```rust\n+    /// # #![feature(collections)]\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n     ///\n-    /// # Examples\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n     ///\n+    /// let src2 = [3, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3, 4, 5]);\n     /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.starts_with(&[10]));\n-    /// assert!(v.starts_with(&[10, 40]));\n-    /// assert!(!v.starts_with(&[50]));\n-    /// assert!(!v.starts_with(&[10, 50]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        core_slice::SliceExt::starts_with(self, needle)\n+    #[unstable(feature = \"collections\")]\n+    pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n+        core_slice::SliceExt::clone_from_slice(self, src)\n     }\n \n-    /// Returns true if `needle` is a suffix of the slice.\n+    /// Consumes `src` and moves as many elements as it can into `self`\n+    /// from the range [start,end).\n+    ///\n+    /// Returns the number of elements copied (the shorter of `self.len()`\n+    /// and `end - start`).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A mutable vector of `T`\n+    /// * start - The index into `src` to start copying from\n+    /// * end - The index into `src` to stop copying from\n     ///\n     /// # Examples\n     ///\n+    /// ```rust\n+    /// # #![feature(collections)]\n+    /// let mut a = [1, 2, 3, 4, 5];\n+    /// let b = vec![6, 7, 8];\n+    /// let num_moved = a.move_from(b, 0, 3);\n+    /// assert_eq!(num_moved, 3);\n+    /// assert!(a == [6, 7, 8, 4, 5]);\n     /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.ends_with(&[30]));\n-    /// assert!(v.ends_with(&[40, 30]));\n-    /// assert!(!v.ends_with(&[50]));\n-    /// assert!(!v.ends_with(&[50, 30]));\n-    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain about this API approach\")]\n+    #[inline]\n+    pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n+        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n+            mem::swap(a, b);\n+        }\n+        cmp::min(self.len(), end-start)\n+    }\n+\n+    /// Copies `self` into a new `Vec`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        core_slice::SliceExt::ends_with(self, needle)\n+    #[inline]\n+    pub fn to_vec(&self) -> Vec<T> where T: Clone {\n+        // NB see hack module in this file\n+        hack::to_vec(self)\n     }\n \n     /// Converts `self` into a vector without clones or allocation."}]}