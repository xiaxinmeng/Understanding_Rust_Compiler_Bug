{"sha": "806476c840a19ee2da4113ec3e68f9681018325e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNjQ3NmM4NDBhMTllZTJkYTQxMTNlYzNlNjhmOTY4MTAxODMyNWU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-13T23:41:43Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-13T23:41:43Z"}, "message": "Suggest giving return type to closures on E0282", "tree": {"sha": "3b0ba382b27f439c02e4da8936ff6805f29042f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b0ba382b27f439c02e4da8936ff6805f29042f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/806476c840a19ee2da4113ec3e68f9681018325e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/806476c840a19ee2da4113ec3e68f9681018325e", "html_url": "https://github.com/rust-lang/rust/commit/806476c840a19ee2da4113ec3e68f9681018325e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/806476c840a19ee2da4113ec3e68f9681018325e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939c1cb349f81a3ce488f5c17f195a5fcd84691c", "url": "https://api.github.com/repos/rust-lang/rust/commits/939c1cb349f81a3ce488f5c17f195a5fcd84691c", "html_url": "https://github.com/rust-lang/rust/commit/939c1cb349f81a3ce488f5c17f195a5fcd84691c"}], "stats": {"total": 289, "additions": 199, "deletions": 90}, "files": [{"sha": "e8d44ee1310e73b92e2adfa003c178393a42736e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -1541,7 +1541,7 @@ pub enum ExprKind {\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`.\n+    /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<GeneratorMovability>`."}, {"sha": "16fed3d42d6799b5c5ca166451c4f34ed5688e2a", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 141, "deletions": 70, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -1,13 +1,13 @@\n use crate::hir::def::Namespace;\n-use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n \n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -16,9 +16,26 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_local_pattern: Option<&'tcx Pat>,\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n+    found_closure: Option<&'tcx ExprKind>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        target_ty: Ty<'tcx>,\n+        hir_map: &'a hir::map::Map<'tcx>,\n+    ) -> FindLocalByTypeVisitor<'a, 'tcx> {\n+        FindLocalByTypeVisitor {\n+            infcx,\n+            target_ty,\n+            hir_map,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n+            found_ty: None,\n+            found_closure: None,\n+        }\n+    }\n+\n     fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_type_opt(hir_id)\n@@ -72,6 +89,16 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_body(self, body);\n     }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n+            &expr.node,\n+            self.node_matches_type(expr.hir_id),\n+        ) {\n+            self.found_closure = Some(&expr.node);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -106,16 +133,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n-        let mut err_span = span;\n-\n-        let mut local_visitor = FindLocalByTypeVisitor {\n-            infcx: &self,\n-            target_ty: ty,\n-            hir_map: &self.tcx.hir(),\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_ty: None,\n-        };\n+        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -136,6 +154,35 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n+        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n+            pattern.span\n+        } else {\n+            span\n+        };\n+\n+        let ty_msg = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let args = fn_sig.inputs()\n+                    .skip_binder()\n+                    .iter()\n+                    .next()\n+                    .map(|args| args.tuple_fields()\n+                        .map(|arg| arg.to_string())\n+                        .collect::<Vec<_>>().join(\", \"))\n+                    .unwrap_or_default();\n+                let ret = fn_sig.output().skip_binder().to_string();\n+                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n+            }\n+            Some(ty) if &ty.to_string() != \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) =>\n+            {\n+                let ty = ty_to_string(ty);\n+                format!(\" for `{}`\", ty)\n+            }\n+            _ => String::new(),\n+        };\n \n         // When `name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n@@ -150,34 +197,47 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let (ty_msg, suffix) = match &local_visitor.found_ty {\n-            Some(ty) if &ty.to_string() != \"_\" &&\n-                name == \"_\" &&\n-                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n-                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) &&\n-                !ty.is_closure() => // The suggestion doesn't make sense for closures.\n-            {\n-                let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\"the explicit type `{}`, with the type parameters specified\", ty))\n-            }\n-            Some(ty) if &ty.to_string() != \"_\" &&\n-                ty.to_string() != name &&\n-                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n-                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) &&\n-                !ty.is_closure() => // The suggestion doesn't make sense for closures.\n-            {\n-                let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\n-                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty,\n-                    name,\n-                 ))\n-            }\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            err_span,\n+            E0282,\n+            \"type annotations needed{}\",\n+            ty_msg,\n+        );\n+\n+        let suffix = match local_visitor.found_ty {\n             Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n-                let msg = \" for the closure\".to_string();\n                 let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+\n+                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n+                    let (arrow, post) = match decl.output {\n+                        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+                        _ => (\"\", \"\"),\n+                    };\n+                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n+                        let suggestion = match body.value.node {\n+                            ExprKind::Block(..) => {\n+                                vec![(decl.output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n+                            }\n+                            _ => {\n+                                vec![\n+                                    (decl.output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                                    (body.value.span.shrink_to_hi(), \" }\".to_string()),\n+                                ]\n+                            }\n+                        };\n+                        err.multipart_suggestion(\n+                            \"give this closure an explicit return type without `_` placeholders\",\n+                            suggestion,\n+                            Applicability::HasPlaceholders,\n+                        );\n+                        err.span_label(span, InferCtxt::missing_type_msg(&name));\n+                        return err;\n+                    }\n+                }\n+\n+                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n                 let args = fn_sig.inputs()\n                     .skip_binder()\n                     .iter()\n@@ -189,18 +249,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // This suggestion is incomplete, as the user will get further type inference\n                 // errors due to the `_` placeholders and the introduction of `Box`, but it does\n                 // nudge them in the right direction.\n-                (msg, format!(\n-                    \"a boxed closure type like `Box<dyn Fn({}) -> {}>`\",\n-                    args,\n-                    fn_sig.output().skip_binder().to_string(),\n-                ))\n+                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n+            }\n+            Some(ty) if &ty.to_string() != \"_\" &&\n+                name == \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) =>\n+            {\n+                let ty = ty_to_string(ty);\n+                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            _ => (String::new(), \"a type\".to_owned()),\n+            Some(ty) if &ty.to_string() != \"_\" &&\n+                ty.to_string() != name &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) =>\n+            {\n+                let ty = ty_to_string(ty);\n+                format!(\n+                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n+                    ty,\n+                    name,\n+                )\n+            }\n+            _ => \"a type\".to_string(),\n         };\n-        let mut labels = vec![(span, InferCtxt::missing_type_msg(&name))];\n \n         if let Some(pattern) = local_visitor.found_arg_pattern {\n-            err_span = pattern.span;\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:\n@@ -217,39 +291,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             //          ^ consider giving this closure parameter the type `[_; 0]`\n             //            with the type parameter `_` specified\n             // ```\n-            labels.clear();\n-            labels.push((\n+            err.span_label(\n                 pattern.span,\n                 format!(\"consider giving this closure parameter {}\", suffix),\n-            ));\n+            );\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n             if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n-                    None => labels.push((\n-                        pattern.span,\n-                        format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    )),\n-                    Some(DesugaringKind::ForLoop) => labels.push((\n-                        pattern.span,\n-                        \"the element type for this iterator is not specified\".to_owned(),\n-                    )),\n+                    None => {\n+                        err.span_label(\n+                            pattern.span,\n+                            format!(\"consider giving `{}` {}\", simple_ident, suffix),\n+                        );\n+                    }\n+                    Some(DesugaringKind::ForLoop) => {\n+                        err.span_label(\n+                            pattern.span,\n+                            \"the element type for this iterator is not specified\".to_string(),\n+                        );\n+                    }\n                     _ => {}\n                 }\n             } else {\n-                labels.push((pattern.span, format!(\"consider giving this pattern {}\", suffix)));\n+                err.span_label(pattern.span, format!(\"consider giving this pattern {}\", suffix));\n             }\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n-        );\n-\n-        for (target_span, label_message) in labels {\n-            err.span_label(target_span, label_message);\n+        }\n+        if !err.span.span_labels().iter().any(|span_label| {\n+                span_label.label.is_some() && span_label.span == span\n+            }) && local_visitor.found_arg_pattern.is_none()\n+        { // Avoid multiple labels pointing at `span`.\n+            err.span_label(span, InferCtxt::missing_type_msg(&name));\n         }\n \n         err"}, {"sha": "0f610a5e42f65060ad380ad2161ce35d80825e49", "filename": "src/test/ui/error-codes/E0282.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/E0282.rs:2:9\n    |\n LL |     let x = \"hello\".chars().rev().collect();\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "0672014a9292928ada4105fb3ca9c24b4a04e5d9", "filename": "src/test/ui/for/for-loop-unconstrained-element-type.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/for-loop-unconstrained-element-type.rs:8:14\n    |\n LL |     for i in Vec::new() { }\n-   |              ^^^^^^^^^^\n-   |              |\n-   |              cannot infer type\n-   |              the element type for this iterator is not specified\n+   |              ^^^^^^^^^^ the element type for this iterator is not specified\n \n error: aborting due to previous error\n "}, {"sha": "5f30b5d993c1ee84cbeee95fc3d55e3d845c913e", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -1,10 +1,12 @@\n-error[E0282]: type annotations needed for the closure\n+error[E0282]: type annotations needed for the closure `fn((), ()) -> std::result::Result<(), _>`\n   --> $DIR/cannot-infer-closure.rs:3:9\n    |\n-LL |     let x = |a: (), b: ()| {\n-   |         - consider giving `x` a boxed closure type like `Box<dyn Fn((), ()) -> std::result::Result<(), _>>`\n LL |         Err(a)?;\n    |         ^^^^^^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let x = |a: (), b: ()| -> std::result::Result<(), _> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "9b890be3c789b44d86c580d05725db5f0a2d6718", "filename": "src/test/ui/issues/issue-18159.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-18159.rs:2:9\n    |\n LL |     let x;\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "77df9921b754ac197d295029eac40558cc31e42b", "filename": "src/test/ui/match/match-unresolved-one-arm.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/match-unresolved-one-arm.rs:4:9\n    |\n LL |     let x = match () {\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "910f273b9722d01474cc7f8ec6e3b8c3cae7242c", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || -> _ { [] }; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "de2d29f1270c6c26af800ac12299338c6c19afd0", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-1.rs:2:24\n+   |\n+LL |     let _v = || -> _ { [] };\n+   |                        ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                    ^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "6955b37ad97e423526043712f4de6b3488b9006a", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || { [] }; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "9dbd822fbb5defc4fd6553e8d8993d7462cf56b2", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-2.rs:2:19\n+   |\n+LL |     let _v = || { [] };\n+   |                   ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                 ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "ec6c094027e1e48fdc32f8b2b733b730b187c27f", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || []; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "ad0d4e41f7874b66e43f6d0d6ffe3419bc2609c6", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/806476c840a19ee2da4113ec3e68f9681018325e/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr?ref=806476c840a19ee2da4113ec3e68f9681018325e", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-3.rs:2:17\n+   |\n+LL |     let _v = || [];\n+   |                 ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                 ^^^^^^^^^^^    ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}