{"sha": "515906a6694cd594a5bc12ce91c02d62bbb30e08", "node_id": "C_kwDOAAsO6NoAKDUxNTkwNmE2Njk0Y2Q1OTRhNWJjMTJjZTkxYzAyZDYyYmJiMzBlMDg", "commit": {"author": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2022-04-10T17:13:48Z"}, "committer": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2022-04-10T17:13:48Z"}, "message": "Use Add, Sub, Mul traits instead of unsafe", "tree": {"sha": "c8e3dfda0812edef3006c0dd31b056d8689134fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8e3dfda0812edef3006c0dd31b056d8689134fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/515906a6694cd594a5bc12ce91c02d62bbb30e08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0hoVRXRPubZAqGkYx9jUtSpSe8FAmJTEEwACgkQYx9jUtSp\nSe9ing//boIr1KrlHekHOhsymSED/JAxjGDlMUaOq9VqmOXSDPtELVFytSRDdGN4\nNHo8Zd6K4NNwFrKkzKW8K3K4UijKs21/obmpvkztCRwR8KM8NtQ6QZ6/t110u04Z\n9fZRByKHFdS9Ps4+hO9a56LaKKBY7uGvr/aUcptN/PXCluQfQLQ3E6b3pmLHMiCO\n8DqaXKj3EZU+sPkZ3TDExdDWDJQvP2uW5ICl8XPu/sxmy7yM8XgNZmTbbEY/BuEB\nQetVlqKbWYA4+O4IuLbkwdUjbzMJvTJOiG3ojBwKBn3KEiOfUT7aRDaEsQufDAVV\nuLa85045T+zC4kCozd7A4urQrVMEQIieOIVh6xVoedaVmd9TNy3tG50j5qAXYAR7\n10SkaFRb9qfT3mvTI3Mkv3VIazSNywq/YKEfvgEQksL/JA2GaTgn7MKzTiWr4rpN\nYqutmW6VcFENEM0Tg6Fi1Z4DXphpZzC6T+tXgJn+eFX5RyWzZaXWY4kSe/a3j9XV\nQJyt8G80vFxJ4KZ8klz8mVRn2jA+EzVuy+YFx5LYrzuUAhAGCZ2s8RrReIiLR9dX\ne641eGVo76TLqrUhc2HYPDAKcyVSrmuJ00rVBxpJnQpFtG9N5g331jtQYZhPWm/5\nsePZSB7YW8d3R5PMzBsuNEny5n3RcGUGsVSpn4ttHZucrux7fMA=\n=dWZG\n-----END PGP SIGNATURE-----", "payload": "tree c8e3dfda0812edef3006c0dd31b056d8689134fd\nparent 82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb\nauthor Giles Cope <gilescope@gmail.com> 1649610828 +0100\ncommitter Giles Cope <gilescope@gmail.com> 1649610828 +0100\n\nUse Add, Sub, Mul traits instead of unsafe\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/515906a6694cd594a5bc12ce91c02d62bbb30e08", "html_url": "https://github.com/rust-lang/rust/commit/515906a6694cd594a5bc12ce91c02d62bbb30e08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/515906a6694cd594a5bc12ce91c02d62bbb30e08/comments", "author": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb", "html_url": "https://github.com/rust-lang/rust/commit/82e9d9ebaca06b19f5c07afd9cf8f42a8045bdbb"}], "stats": {"total": 92, "additions": 51, "deletions": 41}, "files": [{"sha": "4768befcedd2b844b7a4eb54a837e3ea980eba0e", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/515906a6694cd594a5bc12ce91c02d62bbb30e08/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515906a6694cd594a5bc12ce91c02d62bbb30e08/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=515906a6694cd594a5bc12ce91c02d62bbb30e08", "patch": "@@ -5,6 +5,7 @@\n use crate::ascii;\n use crate::intrinsics;\n use crate::mem;\n+use crate::ops::{Add, Mul, Sub};\n use crate::str::FromStr;\n \n // Used because the `?` operator is not allowed in a const context.\n@@ -969,14 +970,14 @@ pub enum FpCategory {\n }\n \n #[doc(hidden)]\n-trait FromStrRadixHelper: PartialOrd + Copy + Default {\n+trait FromStrRadixHelper:\n+    PartialOrd + Copy + Default + Add<Output = Self> + Sub<Output = Self> + Mul<Output = Self>\n+{\n     const MIN: Self;\n+    fn from_u32(u: u32) -> Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_sub(&self, other: u32) -> Option<Self>;\n     fn checked_add(&self, other: u32) -> Option<Self>;\n-    unsafe fn unchecked_mul(self, other: u32) -> Self;\n-    unsafe fn unchecked_sub(self, other: u32) -> Self;\n-    unsafe fn unchecked_add(self, other: u32) -> Self;\n }\n \n macro_rules! from_str_radix_int_impl {\n@@ -996,6 +997,8 @@ macro_rules! impl_helper_for {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         const MIN: Self = Self::MIN;\n         #[inline]\n+        fn from_u32(u: u32) -> Self { u as Self }\n+        #[inline]\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n             Self::checked_mul(*self, other as Self)\n         }\n@@ -1007,27 +1010,6 @@ macro_rules! impl_helper_for {\n         fn checked_add(&self, other: u32) -> Option<Self> {\n             Self::checked_add(*self, other as Self)\n         }\n-        #[inline]\n-        unsafe fn unchecked_mul(self, other: u32) -> Self {\n-            // SAFETY:  Conditions of `Self::unchecked_mul` must be upheld by the caller.\n-            unsafe {\n-                Self::unchecked_mul(self, other as Self)\n-            }\n-        }\n-        #[inline]\n-        unsafe fn unchecked_sub(self, other: u32) -> Self {\n-            // SAFETY:  Conditions of `Self::unchecked_sub` must be upheld by the caller.\n-            unsafe {\n-                Self::unchecked_sub(self, other as Self)\n-            }\n-        }\n-        #[inline]\n-        unsafe fn unchecked_add(self, other: u32) -> Self {\n-            // SAFETY: Conditions of `Self::unchecked_add` must be upheld by the caller.\n-            unsafe {\n-                Self::unchecked_add(self, other as Self)\n-            }\n-        }\n     })*)\n }\n impl_helper_for! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n@@ -1077,30 +1059,28 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     let mut result = T::default();\n \n     if can_not_overflow::<T>(radix, is_signed_ty, digits) {\n-        // SAFETY: If the len of the str is short compared to the range of the type\n+        // If the len of the str is short compared to the range of the type\n         // we are parsing into, then we can be certain that an overflow will not occur.\n         // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition\n         // above is a faster (conservative) approximation of this.\n         //\n         // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:\n         // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.\n         // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.\n-        unsafe {\n-            macro_rules! run_unchecked_loop {\n-                ($unchecked_additive_op:ident) => {\n-                    for &c in digits {\n-                        result = result.unchecked_mul(radix);\n-                        let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;\n-                        result = T::$unchecked_additive_op(result, x);\n-                    }\n-                };\n-            }\n-            if is_positive {\n-                run_unchecked_loop!(unchecked_add)\n-            } else {\n-                run_unchecked_loop!(unchecked_sub)\n+        macro_rules! run_unchecked_loop {\n+            ($unchecked_additive_op:expr) => {\n+                for &c in digits {\n+                    result = result * T::from_u32(radix);\n+                    let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;\n+                    result = $unchecked_additive_op(result, T::from_u32(x));\n+                }\n             };\n         }\n+        if is_positive {\n+            run_unchecked_loop!(<T as core::ops::Add>::add)\n+        } else {\n+            run_unchecked_loop!(<T as core::ops::Sub>::sub)\n+        };\n     } else {\n         macro_rules! run_checked_loop {\n             ($checked_additive_op:ident, $overflow_err:expr) => {"}, {"sha": "10b8d975442137047ecde6b90fb69621ec651497", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/515906a6694cd594a5bc12ce91c02d62bbb30e08/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515906a6694cd594a5bc12ce91c02d62bbb30e08/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=515906a6694cd594a5bc12ce91c02d62bbb30e08", "patch": "@@ -122,6 +122,28 @@ fn test_int_from_str_overflow() {\n \n #[test]\n fn test_can_not_overflow() {\n+    fn can_overflow<T>(radix: u32, input: &str) -> bool\n+    where\n+        T: Default\n+            + core::ops::Sub<Output = T>\n+            + std::convert::From<bool>\n+            + std::cmp::PartialOrd\n+            + Copy,\n+    {\n+        let one = true.into();\n+        let zero = <T>::default();\n+        !can_not_overflow::<T>(radix, zero - one < zero, input.as_bytes())\n+    }\n+\n+    // Positive tests:\n+    assert!(!can_overflow::<i8>(16, \"F\"));\n+    assert!(!can_overflow::<u8>(16, \"FF\"));\n+\n+    assert!(!can_overflow::<i8>(10, \"9\"));\n+    assert!(!can_overflow::<u8>(10, \"99\"));\n+\n+    // Negative tests:\n+\n     // Not currently in std lib (issue: #27728)\n     fn format_radix<T>(mut x: T, radix: T) -> String\n     where\n@@ -157,12 +179,20 @@ fn test_can_not_overflow() {\n            // Calcutate the string length for the smallest overflowing number:\n            let max_len_string = format_radix(num, base as u128);\n            // Ensure that that string length is deemed to potentially overflow:\n-           assert_eq!(can_not_overflow::<$t>(base, <$t>::default() > <$t>::MIN, max_len_string.as_bytes()), false);\n+           assert!(can_overflow::<$t>(base, &max_len_string));\n         }\n         )*)\n     }\n \n     check! { i8 i16 i32 i64 i128 isize usize u8 u16 u32 u64 }\n+\n+    // Check u128 separately:\n+    for base in 2..=36 {\n+        let num = u128::MAX as u128;\n+        let max_len_string = format_radix(num, base as u128);\n+        // base 16 fits perfectly for u128 and won't overflow:\n+        assert_eq!(can_overflow::<u128>(base, &max_len_string), base != 16);\n+    }\n }\n \n #[test]"}]}