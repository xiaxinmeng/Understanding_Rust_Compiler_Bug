{"sha": "e94eaa6dce468928b4e1326b2f0054f3075681ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NGVhYTZkY2U0Njg5MjhiNGUxMzI2YjJmMDA1NGYzMDc1NjgxZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-01T01:38:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-01T01:38:05Z"}, "message": "Auto merge of #70674 - cjgillot:query-arena-all, r=matthewjasper\n\nHave the per-query caches store the results on arenas\n\nThis PR leverages the cache for each query to serve as storage area for the query results.\n\nIt introduces a new cache `ArenaCache`, which moves the result to an arena,\nand only stores the reference in the hash map.\nThis allows to remove a sizeable part of the usage of the global `TyCtxt` arena.\n\nI only migrated queries that already used arenas before.", "tree": {"sha": "833cc1402e3e700a5cda3385d79f08c7bc4b3591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/833cc1402e3e700a5cda3385d79f08c7bc4b3591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e94eaa6dce468928b4e1326b2f0054f3075681ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e94eaa6dce468928b4e1326b2f0054f3075681ff", "html_url": "https://github.com/rust-lang/rust/commit/e94eaa6dce468928b4e1326b2f0054f3075681ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e94eaa6dce468928b4e1326b2f0054f3075681ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "614f273e9388ddd7804d5cbc80b8865068a3744e", "url": "https://api.github.com/repos/rust-lang/rust/commits/614f273e9388ddd7804d5cbc80b8865068a3744e", "html_url": "https://github.com/rust-lang/rust/commit/614f273e9388ddd7804d5cbc80b8865068a3744e"}, {"sha": "d7d2185607280e143ea25b1cf688cb6f27f2db45", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d2185607280e143ea25b1cf688cb6f27f2db45", "html_url": "https://github.com/rust-lang/rust/commit/d7d2185607280e143ea25b1cf688cb6f27f2db45"}], "stats": {"total": 569, "additions": 313, "deletions": 256}, "files": [{"sha": "13a130a1b49c02f91fb378960df5fcbf7936717e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -4126,6 +4126,7 @@ dependencies = [\n name = \"rustc_query_system\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arena\",\n  \"log\",\n  \"parking_lot 0.10.2\",\n  \"rustc-rayon-core\","}, {"sha": "fc357ebb05d62784038cad0dbf608d8824e76b97", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -253,7 +253,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n         inline(cx, llfn, attributes::InlineAttr::Hint);\n     }\n \n-    inline(cx, llfn, codegen_fn_attrs.inline);\n+    inline(cx, llfn, codegen_fn_attrs.inline.clone());\n \n     // The `uwtable` attribute according to LLVM is:\n     //\n@@ -350,15 +350,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n         if tcx.sess.opts.actually_rustdoc {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // whitelist them all\n-            tcx.arena\n-                .alloc(llvm_util::all_known_features().map(|(a, b)| (a.to_string(), b)).collect())\n+            llvm_util::all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n         } else {\n-            tcx.arena.alloc(\n-                llvm_util::target_feature_whitelist(tcx.sess)\n-                    .iter()\n-                    .map(|&(a, b)| (a.to_string(), b))\n-                    .collect(),\n-            )\n+            llvm_util::target_feature_whitelist(tcx.sess)\n+                .iter()\n+                .map(|&(a, b)| (a.to_string(), b))\n+                .collect()\n         }\n     };\n \n@@ -390,7 +387,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n             }));\n         }\n \n-        tcx.arena.alloc(ret)\n+        ret\n     };\n }\n "}, {"sha": "338211ca11f3cd0bc6188a706c9436c1b1150158", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -42,14 +42,11 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n     }\n }\n \n-fn reachable_non_generics_provider(\n-    tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n-) -> &DefIdMap<SymbolExportLevel> {\n+fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<SymbolExportLevel> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n-        return tcx.arena.alloc(Default::default());\n+        return Default::default();\n     }\n \n     // Check to see if this crate is a \"special runtime crate\". These\n@@ -145,7 +142,7 @@ fn reachable_non_generics_provider(\n         reachable_non_generics.insert(id, SymbolExportLevel::C);\n     }\n \n-    tcx.arena.alloc(reachable_non_generics)\n+    reachable_non_generics\n }\n \n fn is_reachable_non_generic_provider_local(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n@@ -281,7 +278,7 @@ fn exported_symbols_provider_local(\n fn upstream_monomorphizations_provider(\n     tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n-) -> &DefIdMap<FxHashMap<SubstsRef<'_>, CrateNum>> {\n+) -> DefIdMap<FxHashMap<SubstsRef<'_>, CrateNum>> {\n     debug_assert!(cnum == LOCAL_CRATE);\n \n     let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n@@ -338,7 +335,7 @@ fn upstream_monomorphizations_provider(\n         }\n     }\n \n-    tcx.arena.alloc(instances)\n+    instances\n }\n \n fn upstream_monomorphizations_for_provider("}, {"sha": "fc6b547c5e70c79cd6bca2fcd68b439ce20a9ea7", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -908,7 +908,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n             .map(|id| &module_map[&id])\n             .flat_map(|module| module.foreign_items.iter().cloned())\n             .collect();\n-        tcx.arena.alloc(dllimports)\n+        dllimports\n     };\n \n     providers.is_dllimport_foreign_item ="}, {"sha": "7e8e4f59707c1bef3bdbd00649bc7cad1302432a", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -22,7 +22,7 @@ use rustc_span::symbol::{sym, Symbol};\n \n use std::cmp;\n \n-fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n+fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let store = unerased_lint_store(tcx);\n     let levels = LintLevelsBuilder::new(tcx.sess, false, &store);\n@@ -37,7 +37,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n \n-    tcx.arena.alloc(builder.levels.build_map())\n+    builder.levels.build_map()\n }\n \n pub struct LintLevelsBuilder<'s> {"}, {"sha": "229ccfe08f7afd78a68c359ac6ae30f25b149f98", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -107,7 +107,9 @@ impl Parse for QueryModifier {\n             let block = input.parse()?;\n             Ok(QueryModifier::LoadCached(tcx, id, block))\n         } else if modifier == \"storage\" {\n-            let ty = input.parse()?;\n+            let args;\n+            parenthesized!(args in input);\n+            let ty = args.parse()?;\n             Ok(QueryModifier::Storage(ty))\n         } else if modifier == \"fatal_cycle\" {\n             Ok(QueryModifier::FatalCycle)"}, {"sha": "6a4b35ed3d7facd69f6cc74f62cc50b4be211d52", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -939,8 +939,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    fn get_diagnostic_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n-        tcx.arena.alloc(if self.root.is_proc_macro_crate() {\n+    fn get_diagnostic_items(&self) -> FxHashMap<Symbol, DefId> {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any diagnostic-items to the target.\n             Default::default()\n         } else {\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .decode(self)\n                 .map(|(name, def_index)| (name, self.local_def_id(def_index)))\n                 .collect()\n-        })\n+        }\n     }\n \n     /// Iterates over each child of the given item."}, {"sha": "c6c06c98ee5c2f80f231a9721b45c8f89fe3feec", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -88,15 +88,11 @@ impl IntoArgs for (CrateNum, DefId) {\n \n provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n-    generics_of => {\n-        tcx.arena.alloc(cdata.get_generics(def_id.index, tcx.sess))\n-    }\n+    generics_of => { cdata.get_generics(def_id.index, tcx.sess) }\n     explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n     inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n-    trait_def => {\n-        tcx.arena.alloc(cdata.get_trait_def(def_id.index, tcx.sess))\n-    }\n+    trait_def => { cdata.get_trait_def(def_id.index, tcx.sess) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n         let _ = cdata;\n@@ -117,8 +113,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n-    promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n+    optimized_mir => { cdata.get_optimized_mir(tcx, def_id.index) }\n+    promoted_mir => { cdata.get_promoted_mir(tcx, def_id.index) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n@@ -178,7 +174,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             })\n             .collect();\n \n-        tcx.arena.alloc(reachable_non_generics)\n+        reachable_non_generics\n     }\n     native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n     foreign_modules => { cdata.get_foreign_modules(tcx) }\n@@ -220,7 +216,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     defined_lib_features => { cdata.get_lib_features(tcx) }\n     defined_lang_items => { cdata.get_lang_items(tcx) }\n-    diagnostic_items => { cdata.get_diagnostic_items(tcx) }\n+    diagnostic_items => { cdata.get_diagnostic_items() }\n     missing_lang_items => { cdata.get_missing_lang_items(tcx) }\n \n     missing_extern_crate_item => {\n@@ -363,7 +359,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n                 }\n             }\n \n-            tcx.arena.alloc(visible_parent_map)\n+            visible_parent_map\n         },\n \n         dependency_formats: |tcx, cnum| {"}, {"sha": "bbeacbfc5382e6005fbf3bf74b8a24782cf885b8", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 3, "deletions": 58, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -12,36 +12,13 @@ macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n             [] layouts: rustc_target::abi::Layout,\n-            [] generics: rustc_middle::ty::Generics,\n-            [] trait_def: rustc_middle::ty::TraitDef,\n+            // AdtDef are interned and compared by address\n             [] adt_def: rustc_middle::ty::AdtDef,\n-            [] steal_mir: rustc_middle::ty::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n-            [] mir: rustc_middle::mir::Body<$tcx>,\n-            [] steal_promoted: rustc_middle::ty::steal::Steal<\n-                rustc_index::vec::IndexVec<\n-                    rustc_middle::mir::Promoted,\n-                    rustc_middle::mir::Body<$tcx>\n-                >\n-            >,\n-            [] promoted: rustc_index::vec::IndexVec<\n-                rustc_middle::mir::Promoted,\n-                rustc_middle::mir::Body<$tcx>\n-            >,\n             [decode] tables: rustc_middle::ty::TypeckTables<$tcx>,\n-            [decode] borrowck_result: rustc_middle::mir::BorrowCheckResult<$tcx>,\n             [] const_allocs: rustc_middle::mir::interpret::Allocation,\n-            [] vtable_method: Option<(\n-                rustc_hir::def_id::DefId,\n-                rustc_middle::ty::subst::SubstsRef<$tcx>\n-            )>,\n-            [few, decode] collect_and_partition_mono_items: rustc_hir::def_id::DefIdSet,\n-            [few, decode] mir_keys: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n-            [decode] specialization_graph: rustc_middle::traits::specialization_graph::Graph,\n+            // Required for the incremental on-disk cache\n+            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet,\n             [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n-            [] item_local_set: rustc_hir::ItemLocalSet,\n-            [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc_middle::mir::Local>,\n-            [] trait_impls_of: rustc_middle::ty::trait_def::TraitImpls,\n-            [] associated_items: rustc_middle::ty::AssociatedItems,\n             [] dropck_outlives:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n@@ -80,42 +57,10 @@ macro_rules! arena_types {\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n                 >,\n-            [few] crate_inherent_impls: rustc_middle::ty::CrateInherentImpls,\n-            [few] upstream_monomorphizations:\n-                rustc_hir::def_id::DefIdMap<\n-                    rustc_data_structures::fx::FxHashMap<\n-                        rustc_middle::ty::subst::SubstsRef<'tcx>,\n-                        rustc_hir::def_id::CrateNum\n-                    >\n-                >,\n-            [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n-                rustc_span::symbol::Symbol,\n-                rustc_hir::def_id::DefId,\n-            >,\n-            [few] resolve_lifetimes: rustc_middle::middle::resolve_lifetime::ResolveLifetimes,\n-            [few] lint_levels: rustc_middle::lint::LintLevelMap,\n-            [few] stability_index: rustc_middle::middle::stability::Index<'tcx>,\n-            [few] features: rustc_feature::Features,\n             [few] all_traits: Vec<rustc_hir::def_id::DefId>,\n             [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n-            [few] target_features_whitelist: rustc_data_structures::fx::FxHashMap<\n-                String,\n-                Option<rustc_span::symbol::Symbol>\n-            >,\n-            [few] wasm_import_module_map: rustc_data_structures::fx::FxHashMap<\n-                rustc_hir::def_id::DefId,\n-                String\n-            >,\n-            [few] get_lib_features: rustc_middle::middle::lib_features::LibFeatures,\n-            [few] defined_lib_features: rustc_hir::lang_items::LanguageItems,\n-            [few] visible_parent_map: rustc_hir::def_id::DefIdMap<rustc_hir::def_id::DefId>,\n             [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n             [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n-            [few] reachable_non_generics: rustc_hir::def_id::DefIdMap<\n-                rustc_middle::middle::exported_symbols::SymbolExportLevel\n-            >,\n-            [few] crate_variances: rustc_middle::ty::CrateVariancesMap<'tcx>,\n-            [few] inferred_outlives_crate: rustc_middle::ty::CratePredicatesMap<'tcx>,\n             [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n             [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n             [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,"}, {"sha": "e57c51b9eefbed3ac48c3dbf78e6576d46d96b65", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 69, "deletions": 47, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -102,12 +102,13 @@ rustc_queries! {\n \n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n-        query generics_of(key: DefId) -> &'tcx ty::Generics {\n+        query generics_of(key: DefId) -> ty::Generics {\n+            storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let generics: Option<ty::Generics> = tcx.queries.on_disk_cache\n                                                         .try_load_query_result(tcx, id);\n-                generics.map(|x| &*tcx.arena.alloc(x))\n+                generics\n             }\n         }\n \n@@ -134,7 +135,8 @@ rustc_queries! {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }\n \n-        query lint_levels(_: CrateNum) -> &'tcx LintLevelMap {\n+        query lint_levels(_: CrateNum) -> LintLevelMap {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"computing the lint levels for items in this crate\" }\n         }\n@@ -156,7 +158,8 @@ rustc_queries! {\n         /// Set of all the `DefId`s in this crate that have MIR associated with\n         /// them. This includes all the body owners, but also things like struct\n         /// constructors.\n-        query mir_keys(_: CrateNum) -> &'tcx FxHashSet<LocalDefId> {\n+        query mir_keys(_: CrateNum) -> FxHashSet<LocalDefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"getting a list of all mir_keys\" }\n         }\n \n@@ -170,48 +173,40 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: LocalDefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_built(_: LocalDefId) -> Steal<mir::Body<'tcx>> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"building MIR for\" }\n         }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_const(_: DefId) -> Steal<mir::Body<'tcx>> {\n+            storage(ArenaCacheSelector<'tcx>)\n             no_hash\n         }\n \n         query mir_validated(key: LocalDefId) ->\n             (\n-                &'tcx Steal<mir::Body<'tcx>>,\n-                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+                Steal<mir::Body<'tcx>>,\n+                Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n             ) {\n+            storage(ArenaCacheSelector<'tcx>)\n             no_hash\n             desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n+        query optimized_mir(key: DefId) -> mir::Body<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n-            load_cached(tcx, id) {\n-                let mir: Option<crate::mir::Body<'tcx>>\n-                    = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n-                mir.map(|x| &*tcx.arena.alloc(x))\n-            }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+        query promoted_mir(key: DefId) -> IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n-            load_cached(tcx, id) {\n-                let promoted: Option<\n-                    rustc_index::vec::IndexVec<\n-                        crate::mir::Promoted,\n-                        crate::mir::Body<'tcx>\n-                    >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n-                promoted.map(|p| &*tcx.arena.alloc(p))\n-            }\n         }\n     }\n \n@@ -245,7 +240,8 @@ rustc_queries! {\n     }\n \n     Linking {\n-        query wasm_import_module_map(_: CrateNum) -> &'tcx FxHashMap<DefId, String> {\n+        query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"wasm import module map\" }\n         }\n     }\n@@ -283,8 +279,11 @@ rustc_queries! {\n             }}\n         }\n \n-        query trait_def(_: DefId) -> &'tcx ty::TraitDef {}\n-        query adt_def(_: DefId) -> &'tcx ty::AdtDef {}\n+        query trait_def(_: DefId) -> ty::TraitDef {\n+            storage(ArenaCacheSelector<'tcx>)\n+        }\n+        query adt_def(_: DefId) -> &'tcx ty::AdtDef {\n+        }\n         query adt_destructor(_: DefId) -> Option<ty::Destructor> {}\n \n         // The cycle error here should be reported as an error by `check_representable`.\n@@ -345,7 +344,8 @@ rustc_queries! {\n         query generator_kind(_: DefId) -> Option<hir::GeneratorKind> {}\n \n         /// Gets a map with the variance of every item; use `item_variance` instead.\n-        query crate_variances(_: CrateNum) -> &'tcx ty::CrateVariancesMap<'tcx> {\n+        query crate_variances(_: CrateNum) -> ty::CrateVariancesMap<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"computing the variances for items in this crate\" }\n         }\n \n@@ -356,7 +356,8 @@ rustc_queries! {\n     TypeChecking {\n         /// Maps from thee `DefId` of a type to its (inferred) outlives.\n         query inferred_outlives_crate(_: CrateNum)\n-            -> &'tcx ty::CratePredicatesMap<'tcx> {\n+            -> ty::CratePredicatesMap<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"computing the inferred outlives predicates for items in this crate\" }\n         }\n     }\n@@ -366,10 +367,13 @@ rustc_queries! {\n         query associated_item_def_ids(_: DefId) -> &'tcx [DefId] {}\n \n         /// Maps from a trait item to the trait item \"descriptor\".\n-        query associated_item(_: DefId) -> ty::AssocItem {}\n+        query associated_item(_: DefId) -> ty::AssocItem {\n+            storage(ArenaCacheSelector<'tcx>)\n+        }\n \n         /// Collects the associated items defined on a trait or impl.\n-        query associated_items(key: DefId) -> &'tcx ty::AssociatedItems {\n+        query associated_items(key: DefId) -> ty::AssociatedItems<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n \n@@ -393,6 +397,7 @@ rustc_queries! {\n         query unsafety_check_result(key: LocalDefId) -> mir::UnsafetyCheckResult {\n             desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if { true }\n+            storage(ArenaCacheSelector<'tcx>)\n         }\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n@@ -472,7 +477,7 @@ rustc_queries! {\n                     .queries.on_disk_cache\n                     .try_load_query_result(tcx, id);\n \n-                typeck_tables.map(|tables| &*tcx.arena.alloc(tables))\n+                typeck_tables.map(|x| &*tcx.arena.alloc(x))\n             }\n         }\n     }\n@@ -495,7 +500,8 @@ rustc_queries! {\n     BorrowChecking {\n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n-        query mir_borrowck(key: LocalDefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n+        query mir_borrowck(key: LocalDefId) -> mir::BorrowCheckResult<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if(tcx, opt_result) {\n                 tcx.is_closure(key.to_def_id())\n@@ -509,7 +515,8 @@ rustc_queries! {\n         /// Not meant to be used directly outside of coherence.\n         /// (Defined only for `LOCAL_CRATE`.)\n         query crate_inherent_impls(k: CrateNum)\n-            -> &'tcx CrateInherentImpls {\n+            -> CrateInherentImpls {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"all inherent impls defined in crate `{:?}`\", k }\n         }\n@@ -610,7 +617,8 @@ rustc_queries! {\n         /// in the case of closures, this will be redirected to the enclosing function.\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n-        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n \n@@ -639,6 +647,7 @@ rustc_queries! {\n \n     Codegen {\n         query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {\n+            storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { true }\n         }\n     }\n@@ -684,10 +693,12 @@ rustc_queries! {\n         query all_local_trait_impls(key: CrateNum) -> &'tcx BTreeMap<DefId, Vec<hir::HirId>> {\n             desc { \"local trait impls\" }\n         }\n-        query trait_impls_of(key: DefId) -> &'tcx ty::trait_def::TraitImpls {\n+        query trait_impls_of(key: DefId) -> ty::trait_def::TraitImpls {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n         }\n-        query specialization_graph_of(key: DefId) -> &'tcx specialization_graph::Graph {\n+        query specialization_graph_of(key: DefId) -> specialization_graph::Graph {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { true }\n         }\n@@ -829,7 +840,8 @@ rustc_queries! {\n         // Does not include external symbols that don't have a corresponding DefId,\n         // like the compiler-generated `main` function and so on.\n         query reachable_non_generics(_: CrateNum)\n-            -> &'tcx DefIdMap<SymbolExportLevel> {\n+            -> DefIdMap<SymbolExportLevel> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"looking up the exported symbols of a crate\" }\n         }\n         query is_reachable_non_generic(_: DefId) -> bool {}\n@@ -845,7 +857,8 @@ rustc_queries! {\n         /// better, `Instance::upstream_monomorphization()`.\n         query upstream_monomorphizations(\n             k: CrateNum\n-        ) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+        ) -> DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"collecting available upstream monomorphizations `{:?}`\", k }\n         }\n \n@@ -930,7 +943,8 @@ rustc_queries! {\n \n     Other {\n         query dllimport_foreign_items(_: CrateNum)\n-            -> &'tcx FxHashSet<DefId> {\n+            -> FxHashSet<DefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"dllimport_foreign_items\" }\n         }\n         query is_dllimport_foreign_item(_: DefId) -> bool {}\n@@ -948,7 +962,8 @@ rustc_queries! {\n \n     BorrowChecking {\n         /// Lifetime resolution. See `middle::resolve_lifetimes`.\n-        query resolve_lifetimes(_: CrateNum) -> &'tcx ResolveLifetimes {\n+        query resolve_lifetimes(_: CrateNum) -> ResolveLifetimes {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"resolving lifetimes\" }\n         }\n         query named_region_map(_: LocalDefId) ->\n@@ -981,7 +996,8 @@ rustc_queries! {\n         query item_children(_: DefId) -> &'tcx [Export<hir::HirId>] {}\n         query extern_mod_stmt_cnum(_: DefId) -> Option<CrateNum> {}\n \n-        query get_lib_features(_: CrateNum) -> &'tcx LibFeatures {\n+        query get_lib_features(_: CrateNum) -> LibFeatures {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"calculating the lib features map\" }\n         }\n@@ -992,13 +1008,15 @@ rustc_queries! {\n         /// Returns the lang items defined in another crate by loading it from metadata.\n         // FIXME: It is illegal to pass a `CrateNum` other than `LOCAL_CRATE` here, just get rid\n         // of that argument?\n-        query get_lang_items(_: CrateNum) -> &'tcx LanguageItems {\n+        query get_lang_items(_: CrateNum) -> LanguageItems {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"calculating the lang items map\" }\n         }\n \n         /// Returns all diagnostic items defined in all crates.\n-        query all_diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+        query all_diagnostic_items(_: CrateNum) -> FxHashMap<Symbol, DefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"calculating the diagnostic items map\" }\n         }\n@@ -1009,15 +1027,17 @@ rustc_queries! {\n         }\n \n         /// Returns the diagnostic items defined in a crate.\n-        query diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+        query diagnostic_items(_: CrateNum) -> FxHashMap<Symbol, DefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"calculating the diagnostic items map in a crate\" }\n         }\n \n         query missing_lang_items(_: CrateNum) -> &'tcx [LangItem] {\n             desc { \"calculating the missing lang items in a crate\" }\n         }\n         query visible_parent_map(_: CrateNum)\n-            -> &'tcx DefIdMap<DefId> {\n+            -> DefIdMap<DefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"calculating the visible parent map\" }\n         }\n         query missing_extern_crate_item(_: CrateNum) -> bool {\n@@ -1051,7 +1071,8 @@ rustc_queries! {\n             desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n         }\n \n-        query stability_index(_: CrateNum) -> &'tcx stability::Index<'tcx> {\n+        query stability_index(_: CrateNum) -> stability::Index<'tcx> {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"calculating the stability index for the local crate\" }\n         }\n@@ -1242,7 +1263,8 @@ rustc_queries! {\n     }\n \n     Other {\n-        query target_features_whitelist(_: CrateNum) -> &'tcx FxHashMap<String, Option<Symbol>> {\n+        query target_features_whitelist(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n+            storage(ArenaCacheSelector<'tcx>)\n             eval_always\n             desc { \"looking up the whitelist of target features\" }\n         }"}, {"sha": "ae06008d0f9f694c132f7bb3fa89b33dae060749", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -991,22 +991,15 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n-        self.arena.alloc(Steal::new(mir))\n+    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> Steal<Body<'tcx>> {\n+        Steal::new(mir)\n     }\n \n     pub fn alloc_steal_promoted(\n         self,\n         promoted: IndexVec<Promoted, Body<'tcx>>,\n-    ) -> &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n-        self.arena.alloc(Steal::new(promoted))\n-    }\n-\n-    pub fn intern_promoted(\n-        self,\n-        promoted: IndexVec<Promoted, Body<'tcx>>,\n-    ) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n-        self.arena.alloc(promoted)\n+    ) -> Steal<IndexVec<Promoted, Body<'tcx>>> {\n+        Steal::new(promoted)\n     }\n \n     pub fn alloc_adt_def(\n@@ -1016,8 +1009,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         variants: IndexVec<VariantIdx, ty::VariantDef>,\n         repr: ReprOptions,\n     ) -> &'tcx ty::AdtDef {\n-        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n-        self.arena.alloc(def)\n+        self.arena.alloc(ty::AdtDef::new(self, did, kind, variants, repr))\n     }\n \n     pub fn intern_const_alloc(self, alloc: Allocation) -> &'tcx Allocation {\n@@ -2745,7 +2737,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.features_query = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.arena.alloc(tcx.sess.features_untracked().clone())\n+        tcx.sess.features_untracked()\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "bef74289fd8508ac9156952dba8a33bdbb2fbf41", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -256,13 +256,13 @@ impl AssocItem {\n /// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n-pub struct AssociatedItems {\n-    items: SortedIndexMultiMap<u32, Symbol, ty::AssocItem>,\n+pub struct AssociatedItems<'tcx> {\n+    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n }\n \n-impl AssociatedItems {\n+impl<'tcx> AssociatedItems<'tcx> {\n     /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n-    pub fn new(items_in_def_order: impl IntoIterator<Item = ty::AssocItem>) -> Self {\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n         let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n         AssociatedItems { items }\n     }\n@@ -272,15 +272,15 @@ impl AssociatedItems {\n     /// New code should avoid relying on definition order. If you need a particular associated item\n     /// for a known trait, make that trait a lang item instead of indexing this array.\n     pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.iter().map(|(_, v)| v)\n+        self.items.iter().map(|(_, v)| *v)\n     }\n \n     /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n     pub fn filter_by_name_unhygienic(\n         &self,\n         name: Symbol,\n     ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.get_by_key(&name)\n+        self.items.get_by_key(&name).map(|v| *v)\n     }\n \n     /// Returns an iterator over all associated items with the given name.\n@@ -2671,7 +2671,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             .and_then(|def_id| self.hir().get(self.hir().as_local_hir_id(def_id)).ident())\n     }\n \n-    pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n+    pub fn opt_associated_item(self, def_id: DefId) -> Option<&'tcx AssocItem> {\n         let is_associated_item = if let Some(def_id) = def_id.as_local() {\n             match self.hir().get(self.hir().as_local_hir_id(def_id)) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,"}, {"sha": "e4237df592394f9dd5370250dcaa9f63527a967d", "filename": "src/librustc_middle/ty/query/plumbing.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -213,7 +213,7 @@ macro_rules! query_storage {\n         <<$K as Key>::CacheSelector as CacheSelector<$K, $V>>::Cache\n     };\n     ([storage($ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        $ty\n+        <$ty as CacheSelector<$K, $V>>::Cache\n     };\n     ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n         query_storage!([$($($modifiers)*)*][$($args)*])\n@@ -328,6 +328,10 @@ macro_rules! define_queries_inner {\n         $(impl<$tcx> QueryConfig<TyCtxt<$tcx>> for queries::$name<$tcx> {\n             type Key = $($K)*;\n             type Value = $V;\n+            type Stored = <\n+                query_storage!([$($modifiers)*][$($K)*, $V])\n+                as QueryStorage\n+            >::Stored;\n             const NAME: &'static str = stringify!($name);\n             const CATEGORY: ProfileCategory = $category;\n         }\n@@ -426,8 +430,10 @@ macro_rules! define_queries_inner {\n \n             $($(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V {\n-                self.at(DUMMY_SP).$name(key)\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*))\n+                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+            {\n+                self.at(DUMMY_SP).$name(key.into_query_param())\n             })*\n \n             /// All self-profiling events generated by the query engine use\n@@ -463,7 +469,9 @@ macro_rules! define_queries_inner {\n         impl TyCtxtAt<$tcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V {\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*))\n+                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+            {\n                 get_query::<queries::$name<'_>, _>(self.tcx, self.span, key.into_query_param())\n             })*\n         }"}, {"sha": "89bcb240d901332915f1265184f657822fd4d940", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -187,7 +187,7 @@ pub(super) fn all_local_trait_impls<'tcx>(\n }\n \n // Query provider for `trait_impls_of`.\n-pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> &TraitImpls {\n+pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> TraitImpls {\n     let mut impls = TraitImpls::default();\n \n     {\n@@ -219,7 +219,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> &Trai\n         }\n     }\n \n-    tcx.arena.alloc(impls)\n+    impls\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for TraitImpls {"}, {"sha": "b95a1043d92cb1e0ed05e62ba99df4f8525b2ecb", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -92,7 +92,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { mir_borrowck, ..*providers };\n }\n \n-fn mir_borrowck(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &BorrowCheckResult<'_> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def_id: LocalDefId) -> BorrowCheckResult<'_> {\n     let (input_body, promoted) = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id.to_def_id()));\n \n@@ -103,7 +103,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &BorrowCheckResult<'_> {\n     });\n     debug!(\"mir_borrowck done\");\n \n-    tcx.arena.alloc(opt_closure_req)\n+    opt_closure_req\n }\n \n fn do_mir_borrowck<'a, 'tcx>("}, {"sha": "dfa1bb764e47a8e4998adcd9fb7e1ffc022dd35f", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -26,7 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -128,7 +128,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n-    tcx.arena.alloc(result)\n+    result\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -828,7 +828,7 @@ fn build_call_shim<'tcx>(\n     body\n }\n \n-pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n+pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span =\n@@ -895,5 +895,5 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         |_, _| Ok(()),\n     );\n \n-    tcx.arena.alloc(body)\n+    body\n }"}, {"sha": "1d982d18eeb0d02de4e1450635936b905697ee65", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -60,7 +60,7 @@ fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &FxHashSet<LocalDefId> {\n+fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> FxHashSet<LocalDefId> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = FxHashSet::default();\n@@ -97,7 +97,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &FxHashSet<LocalDefId> {\n         .krate()\n         .visit_all_item_likes(&mut GatherCtors { tcx, set: &mut set }.as_deep_visitor());\n \n-    tcx.arena.alloc(set)\n+    set\n }\n \n /// Where a specific `mir::Body` comes from.\n@@ -211,7 +211,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     validator.qualifs_in_return_place()\n }\n \n-fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n+fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> Steal<Body<'_>> {\n     let def_id = def_id.expect_local();\n \n     // Unsafety check uses the raw mir, so make sure it is run\n@@ -241,7 +241,7 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n-) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n+) -> (Steal<Body<'tcx>>, Steal<IndexVec<Promoted, Body<'tcx>>>) {\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n     let _ = tcx.mir_const_qualif(def_id.to_def_id());\n@@ -360,7 +360,7 @@ fn run_optimization_passes<'tcx>(\n     );\n }\n \n-fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n+fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const\n@@ -381,12 +381,12 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n \n-    tcx.arena.alloc(body)\n+    body\n }\n \n-fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, Body<'_>> {\n+fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> IndexVec<Promoted, Body<'_>> {\n     if tcx.is_constructor(def_id) {\n-        return tcx.intern_promoted(IndexVec::new());\n+        return IndexVec::new();\n     }\n \n     let def_id = def_id.expect_local();\n@@ -401,5 +401,5 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, Body<'_>>\n \n     debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");\n \n-    tcx.intern_promoted(promoted)\n+    promoted\n }"}, {"sha": "2ce2627987a01df324edc0108d4205980a4b62c6", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -21,7 +21,7 @@ use rustc_target::spec::PanicStrategy;\n \n use super::lints;\n \n-crate fn mir_built(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &ty::steal::Steal<Body<'_>> {\n+crate fn mir_built(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::steal::Steal<Body<'_>> {\n     tcx.alloc_steal_mir(mir_build(tcx, def_id))\n }\n "}, {"sha": "69bfad6b139991ab00bb9d521bfbd80478f37224", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -24,7 +24,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: LocalDefId) {\n             Some(AssocItem {\n                 container: AssocItemContainer::TraitContainer(trait_def_id), ..\n             }) => {\n-                let trait_substs_count = tcx.generics_of(trait_def_id).count();\n+                let trait_substs_count = tcx.generics_of(*trait_def_id).count();\n                 &InternalSubsts::identity_for_item(tcx, def_id.to_def_id())[..trait_substs_count]\n             }\n             _ => &[],"}, {"sha": "d91f49554ff485b2d135013c23b60db2ebabed1d", "filename": "src/librustc_passes/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostic_items.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -93,18 +93,18 @@ fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n }\n \n /// Traverse and collect the diagnostic items in the current\n-fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> FxHashMap<Symbol, DefId> {\n     // Initialize the collector.\n     let mut collector = DiagnosticItemCollector::new(tcx);\n \n     // Collect diagnostic items in this crate.\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n-    tcx.arena.alloc(collector.items)\n+    collector.items\n }\n \n /// Traverse and collect all the diagnostic items in all crates.\n-fn collect_all<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+fn collect_all<'tcx>(tcx: TyCtxt<'tcx>) -> FxHashMap<Symbol, DefId> {\n     // Initialize the collector.\n     let mut collector = FxHashMap::default();\n \n@@ -115,7 +115,7 @@ fn collect_all<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n         }\n     }\n \n-    tcx.arena.alloc(collector)\n+    collector\n }\n \n pub fn provide(providers: &mut Providers<'_>) {"}, {"sha": "779fb8039d15713b08bc38b06f285c29500c7f5a", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -169,6 +169,6 @@ fn collect(tcx: TyCtxt<'_>) -> LanguageItems {\n pub fn provide(providers: &mut Providers<'_>) {\n     providers.get_lang_items = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n-        tcx.arena.alloc(collect(tcx))\n+        collect(tcx)\n     };\n }"}, {"sha": "31c7ba2a4b205385afa8e9885d968f3a5fabdaf0", "filename": "src/librustc_passes/lib_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib_features.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -138,6 +138,6 @@ fn collect(tcx: TyCtxt<'_>) -> LibFeatures {\n pub fn provide(providers: &mut Providers<'_>) {\n     providers.get_lib_features = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n-        tcx.arena.alloc(collect(tcx))\n+        collect(tcx)\n     };\n }"}, {"sha": "1a86babbc46cf723c808282e175d41dd71fc53a8", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -23,7 +23,7 @@ use rustc_target::spec::abi::Abi;\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: &CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true;\n     }"}, {"sha": "054748c09fc44b4a90853932568f5aeef4d24dc1", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -480,7 +480,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { check_mod_unstable_api_usage, ..*providers };\n     providers.stability_index = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.arena.alloc(new_index(tcx))\n+        new_index(tcx)\n     };\n }\n "}, {"sha": "392e19e1f44718a2d53f7eeb4cca0f48342732fe", "filename": "src/librustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -10,6 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n+arena = { path = \"../libarena\" }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon-core = \"0.3.0\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "6a47abc5b4612e0755567f8958f304156bb59b0f", "filename": "src/librustc_query_system/query/caches.rs", "status": "modified", "additions": 115, "deletions": 9, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -2,19 +2,29 @@ use crate::dep_graph::DepNodeIndex;\n use crate::query::plumbing::{QueryLookup, QueryState};\n use crate::query::QueryContext;\n \n+use arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n+use rustc_data_structures::sync::WorkerLocal;\n use std::default::Default;\n use std::hash::Hash;\n use std::marker::PhantomData;\n \n-pub trait CacheSelector<K: Hash, V> {\n-    type Cache: QueryCache<Key = K, Value = V>;\n+pub trait CacheSelector<K, V> {\n+    type Cache;\n }\n \n-pub trait QueryCache: Default {\n-    type Key: Hash;\n+pub trait QueryStorage: Default {\n     type Value;\n+    type Stored: Clone;\n+\n+    /// Store a value without putting it in the cache.\n+    /// This is meant to be used with cycle errors.\n+    fn store_nocache(&self, value: Self::Value) -> Self::Stored;\n+}\n+\n+pub trait QueryCache: QueryStorage {\n+    type Key: Hash;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n@@ -30,7 +40,7 @@ pub trait QueryCache: Default {\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        OnHit: FnOnce(&Self::Value, DepNodeIndex) -> R,\n+        OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R,\n         OnMiss: FnOnce(Self::Key, QueryLookup<'_, CTX, Self::Key, Self::Sharded>) -> R;\n \n     fn complete<CTX: QueryContext>(\n@@ -40,7 +50,7 @@ pub trait QueryCache: Default {\n         key: Self::Key,\n         value: Self::Value,\n         index: DepNodeIndex,\n-    );\n+    ) -> Self::Stored;\n \n     fn iter<R, L>(\n         &self,\n@@ -66,9 +76,19 @@ impl<K, V> Default for DefaultCache<K, V> {\n     }\n }\n \n+impl<K: Eq + Hash, V: Clone> QueryStorage for DefaultCache<K, V> {\n+    type Value = V;\n+    type Stored = V;\n+\n+    #[inline]\n+    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n+        // We have no dedicated storage\n+        value\n+    }\n+}\n+\n impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n     type Key = K;\n-    type Value = V;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n@@ -99,8 +119,94 @@ impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n         key: K,\n         value: V,\n         index: DepNodeIndex,\n-    ) {\n-        lock_sharded_storage.insert(key, (value, index));\n+    ) -> Self::Stored {\n+        lock_sharded_storage.insert(key, (value.clone(), index));\n+        value\n+    }\n+\n+    fn iter<R, L>(\n+        &self,\n+        shards: &Sharded<L>,\n+        get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n+        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+    ) -> R {\n+        let mut shards = shards.lock_shards();\n+        let mut shards: Vec<_> = shards.iter_mut().map(|shard| get_shard(shard)).collect();\n+        let results = shards.iter_mut().flat_map(|shard| shard.iter()).map(|(k, v)| (k, &v.0, v.1));\n+        f(Box::new(results))\n+    }\n+}\n+\n+pub struct ArenaCacheSelector<'tcx>(PhantomData<&'tcx ()>);\n+\n+impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<K, V> for ArenaCacheSelector<'tcx> {\n+    type Cache = ArenaCache<'tcx, K, V>;\n+}\n+\n+pub struct ArenaCache<'tcx, K, V> {\n+    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n+    phantom: PhantomData<(K, &'tcx V)>,\n+}\n+\n+impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n+    fn default() -> Self {\n+        ArenaCache { arena: WorkerLocal::new(|_| TypedArena::default()), phantom: PhantomData }\n+    }\n+}\n+\n+impl<'tcx, K: Eq + Hash, V: 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n+    type Value = V;\n+    type Stored = &'tcx V;\n+\n+    #[inline]\n+    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n+        let value = self.arena.alloc((value, DepNodeIndex::INVALID));\n+        let value = unsafe { &*(&value.0 as *const _) };\n+        &value\n+    }\n+}\n+\n+impl<'tcx, K: Eq + Hash, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V> {\n+    type Key = K;\n+    type Sharded = FxHashMap<K, &'tcx (V, DepNodeIndex)>;\n+\n+    #[inline(always)]\n+    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+        &self,\n+        state: &QueryState<CTX, Self>,\n+        key: K,\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'_, CTX, K, Self::Sharded>) -> R,\n+    {\n+        let mut lookup = state.get_lookup(&key);\n+        let lock = &mut *lookup.lock;\n+\n+        let result = lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, &key);\n+\n+        if let Some((_, value)) = result {\n+            on_hit(&&value.0, value.1)\n+        } else {\n+            on_miss(key, lookup)\n+        }\n+    }\n+\n+    #[inline]\n+    fn complete<CTX: QueryContext>(\n+        &self,\n+        _: CTX,\n+        lock_sharded_storage: &mut Self::Sharded,\n+        key: K,\n+        value: V,\n+        index: DepNodeIndex,\n+    ) -> Self::Stored {\n+        let value = self.arena.alloc((value, index));\n+        let value = unsafe { &*(value as *const _) };\n+        lock_sharded_storage.insert(key, value);\n+        &value.0\n     }\n \n     fn iter<R, L>("}, {"sha": "710ec3bfb0b3c80a0242b00be1c62c364d14ef27", "filename": "src/librustc_query_system/query/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -20,15 +20,16 @@ pub trait QueryConfig<CTX> {\n     const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n-    type Value: Clone;\n+    type Value;\n+    type Stored: Clone;\n }\n \n pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: CTX::DepKind;\n \n-    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n+    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX, Self::Cache>;"}, {"sha": "49097725bc9b9f0bc6a2bef775cd8e9462a9f2f6", "filename": "src/librustc_query_system/query/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -7,7 +7,9 @@ pub use self::job::deadlock;\n pub use self::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n \n mod caches;\n-pub use self::caches::{CacheSelector, DefaultCacheSelector, QueryCache};\n+pub use self::caches::{\n+    ArenaCacheSelector, CacheSelector, DefaultCacheSelector, QueryCache, QueryStorage,\n+};\n \n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};"}, {"sha": "0aeec269e617ac3c7de012d1e2ea5d8a3606da5d", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -148,7 +148,6 @@ struct JobOwner<'tcx, CTX: QueryContext, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     state: &'tcx QueryState<CTX, C>,\n     key: C::Key,\n@@ -159,7 +158,6 @@ impl<'tcx, CTX: QueryContext, C> JobOwner<'tcx, CTX, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n@@ -177,7 +175,7 @@ where\n         mut lookup: QueryLookup<'a, CTX, C::Key, C::Sharded>,\n     ) -> TryGetJob<'b, CTX, C>\n     where\n-        Q: QueryDescription<CTX, Key = C::Key, Value = C::Value, Cache = C>,\n+        Q: QueryDescription<CTX, Key = C::Key, Stored = C::Stored, Value = C::Value, Cache = C>,\n         CTX: QueryContext,\n     {\n         let lock = &mut *lookup.lock;\n@@ -229,7 +227,8 @@ where\n         // so we just return the error.\n         #[cfg(not(parallel_compiler))]\n         return TryGetJob::Cycle(cold_path(|| {\n-            Q::handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span))\n+            let value = Q::handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span));\n+            Q::query_state(tcx).cache.store_nocache(value)\n         }));\n \n         // With parallel queries we might just have to wait on some other\n@@ -239,7 +238,9 @@ where\n             let result = latch.wait_on(tcx, span);\n \n             if let Err(cycle) = result {\n-                return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n+                let value = Q::handle_cycle_error(tcx, cycle);\n+                let value = Q::query_state(tcx).cache.store_nocache(value);\n+                return TryGetJob::Cycle(value);\n             }\n \n             let cached = try_get_cached(\n@@ -261,26 +262,26 @@ where\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    fn complete(self, tcx: CTX, result: &C::Value, dep_node_index: DepNodeIndex) {\n+    fn complete(self, tcx: CTX, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n         let state = self.state;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let job = {\n-            let result = result.clone();\n+        let (job, result) = {\n             let mut lock = state.shards.get_shard_by_value(&key).lock();\n             let job = match lock.active.remove(&key).unwrap() {\n                 QueryResult::Started(job) => job,\n                 QueryResult::Poisoned => panic!(),\n             };\n-            state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n-            job\n+            let result = state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n+            (job, result)\n         };\n \n         job.signal_complete();\n+        result\n     }\n }\n \n@@ -297,7 +298,6 @@ where\n impl<'tcx, CTX: QueryContext, C: QueryCache> Drop for JobOwner<'tcx, CTX, C>\n where\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     #[inline(never)]\n     #[cold]\n@@ -331,7 +331,6 @@ pub struct CycleError<Q> {\n enum TryGetJob<'tcx, CTX: QueryContext, C: QueryCache>\n where\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n     NotYetStarted(JobOwner<'tcx, CTX, C>),\n@@ -340,10 +339,10 @@ where\n     /// Returns the result of the query and its dep-node index\n     /// if it succeeded or a cycle error if it failed.\n     #[cfg(parallel_compiler)]\n-    JobCompleted((C::Value, DepNodeIndex)),\n+    JobCompleted((C::Stored, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(C::Value),\n+    Cycle(C::Stored),\n }\n \n /// Checks if the query is already computed and in the cache.\n@@ -362,7 +361,7 @@ fn try_get_cached<CTX, C, R, OnHit, OnMiss>(\n where\n     C: QueryCache,\n     CTX: QueryContext,\n-    OnHit: FnOnce(&C::Value, DepNodeIndex) -> R,\n+    OnHit: FnOnce(&C::Stored, DepNodeIndex) -> R,\n     OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX, C::Key, C::Sharded>) -> R,\n {\n     state.cache.lookup(\n@@ -388,7 +387,7 @@ fn try_execute_query<Q, CTX>(\n     span: Span,\n     key: Q::Key,\n     lookup: QueryLookup<'_, CTX, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n-) -> Q::Value\n+) -> Q::Stored\n where\n     Q: QueryDescription<CTX>,\n     CTX: QueryContext,\n@@ -427,9 +426,7 @@ where\n             tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n         }\n \n-        job.complete(tcx, &result, dep_node_index);\n-\n-        return result;\n+        return job.complete(tcx, result, dep_node_index);\n     }\n \n     let dep_node = Q::to_dep_node(tcx, &key);\n@@ -454,8 +451,7 @@ where\n             })\n         });\n         if let Some((result, dep_node_index)) = loaded {\n-            job.complete(tcx, &result, dep_node_index);\n-            return result;\n+            return job.complete(tcx, result, dep_node_index);\n         }\n     }\n \n@@ -558,7 +554,7 @@ fn force_query_with_job<Q, CTX>(\n     key: Q::Key,\n     job: JobOwner<'_, CTX, Q::Cache>,\n     dep_node: DepNode<CTX::DepKind>,\n-) -> (Q::Value, DepNodeIndex)\n+) -> (Q::Stored, DepNodeIndex)\n where\n     Q: QueryDescription<CTX>,\n     CTX: QueryContext,\n@@ -603,13 +599,13 @@ where\n         }\n     }\n \n-    job.complete(tcx, &result, dep_node_index);\n+    let result = job.complete(tcx, result, dep_node_index);\n \n     (result, dep_node_index)\n }\n \n #[inline(never)]\n-pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Value\n+pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Stored\n where\n     Q: QueryDescription<CTX>,\n     CTX: QueryContext,"}, {"sha": "a062330ba4be6a5156941f28c86f094ad0db98e6", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -294,7 +294,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// entire crate. You should not read the result of this query\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> &ResolveLifetimes {\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -314,7 +314,7 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> &ResolveLifetimes\n         map.insert(hir_id.local_id, v);\n     }\n \n-    tcx.arena.alloc(rl)\n+    rl\n }\n \n fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {"}, {"sha": "f2b43754acaeaa9ad940ffef2d93fde09418db29", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -254,7 +254,7 @@ fn fulfill_implication<'a, 'tcx>(\n pub(super) fn specialization_graph_provider(\n     tcx: TyCtxt<'_>,\n     trait_id: DefId,\n-) -> &specialization_graph::Graph {\n+) -> specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n \n     let mut trait_impls: Vec<_> = tcx.all_impls(trait_id).collect();\n@@ -286,7 +286,7 @@ pub(super) fn specialization_graph_provider(\n         }\n     }\n \n-    tcx.arena.alloc(sg)\n+    sg\n }\n \n fn report_overlap_conflict("}, {"sha": "b65f1cd6fac4e4327a13ba002dd98db4b794ee4b", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -220,9 +220,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     }\n }\n \n-fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AssociatedItems {\n+fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssociatedItems<'_> {\n     let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n-    tcx.arena.alloc(ty::AssociatedItems::new(items))\n+    ty::AssociatedItems::new(items)\n }\n \n fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {"}, {"sha": "653b7b8f2a5ba1a4c3c9044ae8cfe694a577cfaf", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -17,13 +17,13 @@ use rustc_ast::ast;\n use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n-pub fn crate_inherent_impls(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CrateInherentImpls {\n+pub fn crate_inherent_impls(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n     let mut collect = InherentCollect { tcx, impls_map: Default::default() };\n     krate.visit_all_item_likes(&mut collect);\n-    tcx.arena.alloc(collect.impls_map)\n+    collect.impls_map\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type."}, {"sha": "e6aa53dd4f3b7695396b5caee31e4464f8e0dcef", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -1002,7 +1002,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     ty::GenericPredicates { parent: None, predicates: superbounds }\n }\n \n-fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n+fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n \n@@ -1033,16 +1033,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n         ty::trait_def::TraitSpecializationKind::None\n     };\n     let def_path_hash = tcx.def_path_hash(def_id);\n-    let def = ty::TraitDef::new(\n-        def_id,\n-        unsafety,\n-        paren_sugar,\n-        is_auto,\n-        is_marker,\n-        spec_kind,\n-        def_path_hash,\n-    );\n-    tcx.arena.alloc(def)\n+    ty::TraitDef::new(def_id, unsafety, paren_sugar, is_auto, is_marker, spec_kind, def_path_hash)\n }\n \n fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<Span> {\n@@ -1158,7 +1149,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     }\n }\n \n-fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n+fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n     use rustc_hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n@@ -1403,14 +1394,14 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n     let param_def_id_to_index = params.iter().map(|param| (param.def_id, param.index)).collect();\n \n-    tcx.arena.alloc(ty::Generics {\n+    ty::Generics {\n         parent: parent_def_id,\n         parent_count,\n         params,\n         param_def_id_to_index,\n         has_self: has_self || parent_has_self,\n         has_late_bound_regions: has_late_bound_regions(tcx, node),\n-    })\n+    }\n }\n \n fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {"}, {"sha": "a49d8e5ed0f0a105ff9cd2cc99881d16777b0234", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -58,7 +58,7 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n     }\n }\n \n-fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CratePredicatesMap<'_> {\n+fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredicatesMap<'_> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     // Compute a map from each struct/enum/union S to the **explicit**\n@@ -105,5 +105,5 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CratePredic\n         })\n         .collect();\n \n-    tcx.arena.alloc(ty::CratePredicatesMap { predicates })\n+    ty::CratePredicatesMap { predicates }\n }"}, {"sha": "631f551ade4feceb1c6cd87423147ee080be965c", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -29,12 +29,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { variances_of, crate_variances, ..*providers };\n }\n \n-fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CrateVariancesMap<'_> {\n+fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateVariancesMap<'_> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    tcx.arena.alloc(solve::solve_constraints(constraints_cx))\n+    solve::solve_constraints(constraints_cx)\n }\n \n fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {"}, {"sha": "efc62361694a5d89bd4a6e547aa8c27618d53c78", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94eaa6dce468928b4e1326b2f0054f3075681ff/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=e94eaa6dce468928b4e1326b2f0054f3075681ff", "patch": "@@ -53,7 +53,7 @@ impl CodegenBackend for TheBackend {\n         rustc_symbol_mangling::provide(providers);\n \n         providers.target_features_whitelist = |tcx, _cnum| {\n-            tcx.arena.alloc(Default::default()) // Just a dummy\n+            Default::default() // Just a dummy\n         };\n         providers.is_reachable_non_generic = |_tcx, _defid| true;\n         providers.exported_symbols = |_tcx, _crate| &[];"}]}