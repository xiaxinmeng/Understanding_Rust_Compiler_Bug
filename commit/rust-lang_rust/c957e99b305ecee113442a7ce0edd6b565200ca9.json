{"sha": "c957e99b305ecee113442a7ce0edd6b565200ca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NTdlOTliMzA1ZWNlZTExMzQ0MmE3Y2UwZWRkNmI1NjUyMDBjYTk=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-04T15:19:16Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:53:13Z"}, "message": "realloc with a new size only, not a full new layout.\n\nChanging the alignment with realloc is not supported.", "tree": {"sha": "02c7f8f7f8f35577d74dfb057625a2a4dae717a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02c7f8f7f8f35577d74dfb057625a2a4dae717a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c957e99b305ecee113442a7ce0edd6b565200ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c957e99b305ecee113442a7ce0edd6b565200ca9", "html_url": "https://github.com/rust-lang/rust/commit/c957e99b305ecee113442a7ce0edd6b565200ca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c957e99b305ecee113442a7ce0edd6b565200ca9/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b017742136a5d02b6ba0f2080e97d18a8bfeba4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b017742136a5d02b6ba0f2080e97d18a8bfeba4b", "html_url": "https://github.com/rust-lang/rust/commit/b017742136a5d02b6ba0f2080e97d18a8bfeba4b"}], "stats": {"total": 176, "additions": 74, "deletions": 102}, "files": [{"sha": "a6fc8d5004c29346697ac50dd2107fb0c64a6427", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=c957e99b305ecee113442a7ce0edd6b565200ca9", "patch": "@@ -91,21 +91,17 @@ unsafe impl Alloc for Global {\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       layout: Layout,\n-                      new_layout: Layout)\n+                      new_size: usize)\n                       -> Result<*mut u8, AllocErr>\n     {\n-        if layout.align() == new_layout.align() {\n-            #[cfg(not(stage0))]\n-            let ptr = __rust_realloc(ptr, layout.size(), layout.align(), new_layout.size());\n-            #[cfg(stage0)]\n-            let ptr = __rust_realloc(ptr, layout.size(), layout.align(),\n-                                     new_layout.size(), new_layout.align(), &mut 0);\n-\n-            if !ptr.is_null() {\n-                Ok(ptr)\n-            } else {\n-                Err(AllocErr)\n-            }\n+        #[cfg(not(stage0))]\n+        let ptr = __rust_realloc(ptr, layout.size(), layout.align(), new_size);\n+        #[cfg(stage0)]\n+        let ptr = __rust_realloc(ptr, layout.size(), layout.align(),\n+                                 new_size, layout.align(), &mut 0);\n+\n+        if !ptr.is_null() {\n+            Ok(ptr)\n         } else {\n             Err(AllocErr)\n         }"}, {"sha": "e79383331e180c0ddf6cfda7c136193199a1d37c", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=c957e99b305ecee113442a7ce0edd6b565200ca9", "patch": "@@ -64,7 +64,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                       ptr: *mut u8,\n                       layout: Layout,\n                       new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::realloc(self, ptr, layout, new_layout)\n+        CoreAlloc::realloc(self, ptr, layout, new_layout.size())\n     }\n \n     unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n@@ -79,20 +79,20 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<Excess, AllocErr> {\n-        CoreAlloc::realloc_excess(self, ptr, layout, new_layout)\n+        CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n     }\n \n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        CoreAlloc::grow_in_place(self, ptr, layout, new_layout)\n+        CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n     }\n \n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        CoreAlloc::shrink_in_place(self, ptr, layout, new_layout)\n+        CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n     }\n }"}, {"sha": "80b816878fb37fdd143782805912571018e63817", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=c957e99b305ecee113442a7ce0edd6b565200ca9", "patch": "@@ -309,11 +309,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n-                    let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n                     alloc_guard(new_size).expect(\"capacity overflow\");\n                     let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                                  cur,\n-                                                 new_layout);\n+                                                 new_size);\n                     match ptr_res {\n                         Ok(ptr) => (new_cap, Unique::new_unchecked(ptr as *mut T)),\n                         Err(_) => self.a.oom(),\n@@ -371,8 +370,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).expect(\"capacity overflow\");\n             let ptr = self.ptr() as *mut _;\n-            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n-            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n+            match self.a.grow_in_place(ptr, old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -428,8 +426,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             let res = match self.current_layout() {\n                 Some(layout) => {\n+                    debug_assert!(new_layout.align() == layout.align());\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n-                    self.a.realloc(old_ptr, layout, new_layout)\n+                    self.a.realloc(old_ptr, layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n@@ -537,8 +536,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             let res = match self.current_layout() {\n                 Some(layout) => {\n+                    debug_assert!(new_layout.align() == layout.align());\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n-                    self.a.realloc(old_ptr, layout, new_layout)\n+                    self.a.realloc(old_ptr, layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n@@ -604,7 +604,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n-            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n+            match self.a.grow_in_place(ptr, old_layout, new_layout.size()) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n                     true\n@@ -664,10 +664,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                let new_layout = Layout::from_size_align_unchecked(new_size, align);\n                 match self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                      old_layout,\n-                                     new_layout) {\n+                                     new_size) {\n                     Ok(p) => self.ptr = Unique::new_unchecked(p as *mut T),\n                     Err(_) => self.a.oom(),\n                 }"}, {"sha": "7b788a5f9898da1fc7df377b93117edfd4b8861c", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=c957e99b305ecee113442a7ce0edd6b565200ca9", "patch": "@@ -69,8 +69,8 @@ unsafe impl Alloc for System {\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       old_layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        Alloc::realloc(&mut &*self, ptr, old_layout, new_layout)\n+                      new_size: usize) -> Result<*mut u8, AllocErr> {\n+        Alloc::realloc(&mut &*self, ptr, old_layout, new_size)\n     }\n \n     fn oom(&mut self) -> ! {\n@@ -91,24 +91,24 @@ unsafe impl Alloc for System {\n     unsafe fn realloc_excess(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n-        Alloc::realloc_excess(&mut &*self, ptr, layout, new_layout)\n+                             new_size: usize) -> Result<Excess, AllocErr> {\n+        Alloc::realloc_excess(&mut &*self, ptr, layout, new_size)\n     }\n \n     #[inline]\n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        Alloc::grow_in_place(&mut &*self, ptr, layout, new_layout)\n+                            new_size: usize) -> Result<(), CannotReallocInPlace> {\n+        Alloc::grow_in_place(&mut &*self, ptr, layout, new_size)\n     }\n \n     #[inline]\n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        Alloc::shrink_in_place(&mut &*self, ptr, layout, new_layout)\n+                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n+        Alloc::shrink_in_place(&mut &*self, ptr, layout, new_size)\n     }\n }\n \n@@ -166,12 +166,8 @@ macro_rules! alloc_methods_based_on_global_alloc {\n         unsafe fn realloc(&mut self,\n                           ptr: *mut u8,\n                           old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(AllocErr)\n-            }\n-\n-            let ptr = GlobalAlloc::realloc(*self, ptr as *mut Void, old_layout, new_layout.size());\n+                          new_size: usize) -> Result<*mut u8, AllocErr> {\n+            let ptr = GlobalAlloc::realloc(*self, ptr as *mut Void, old_layout, new_size);\n             if !ptr.is_null() {\n                 Ok(ptr as *mut u8)\n             } else {\n@@ -428,30 +424,26 @@ mod platform {\n         unsafe fn grow_in_place(&mut self,\n                                 ptr: *mut u8,\n                                 layout: Layout,\n-                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-            self.shrink_in_place(ptr, layout, new_layout)\n+                                new_size: usize) -> Result<(), CannotReallocInPlace> {\n+            self.shrink_in_place(ptr, layout, new_size)\n         }\n \n         #[inline]\n         unsafe fn shrink_in_place(&mut self,\n                                   ptr: *mut u8,\n-                                  old_layout: Layout,\n-                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(CannotReallocInPlace)\n-            }\n-\n-            let new = if new_layout.align() <= MIN_ALIGN {\n+                                  layout: Layout,\n+                                  new_size: usize) -> Result<(), CannotReallocInPlace> {\n+            let new = if layout.align() <= MIN_ALIGN {\n                 HeapReAlloc(GetProcessHeap(),\n                             HEAP_REALLOC_IN_PLACE_ONLY,\n                             ptr as LPVOID,\n-                            new_layout.size())\n+                            new_size)\n             } else {\n                 let header = get_header(ptr);\n                 HeapReAlloc(GetProcessHeap(),\n                             HEAP_REALLOC_IN_PLACE_ONLY,\n                             header.0 as LPVOID,\n-                            new_layout.size() + new_layout.align())\n+                            new_size + layout.align())\n             };\n             if new.is_null() {\n                 Err(CannotReallocInPlace)"}, {"sha": "757f06e731ffca5027e2cac54c582dedb199a30c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c957e99b305ecee113442a7ce0edd6b565200ca9/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=c957e99b305ecee113442a7ce0edd6b565200ca9", "patch": "@@ -633,9 +633,10 @@ pub unsafe trait Alloc {\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n-    /// `new_layout`, meeting its size and alignment guarantees. To\n+    /// a new layout with `layout`\u2019s alginment and a size given\n+    /// by `new_size`. To\n     /// accomplish this, this may extend or shrink the allocation\n-    /// referenced by `ptr` to fit `new_layout`.\n+    /// referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block\n     /// referenced by `ptr` has been transferred to this\n@@ -648,44 +649,32 @@ pub unsafe trait Alloc {\n     /// block has not been transferred to this allocator, and the\n     /// contents of the memory block are unaltered.\n     ///\n-    /// For best results, `new_layout` should not impose a different\n-    /// alignment constraint than `layout`. (In other words,\n-    /// `new_layout.align()` should equal `layout.align()`.) However,\n-    /// behavior is well-defined (though underspecified) when this\n-    /// constraint is violated; further discussion below.\n-    ///\n     /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n     ///\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n-    /// * `layout` must *fit* the `ptr` (see above). (The `new_layout`\n+    /// * `layout` must *fit* the `ptr` (see above). (The `new_size`\n     ///   argument need not fit it.)\n     ///\n-    /// * `new_layout` must have size greater than zero.\n+    /// * `new_size` must be greater than zero.\n     ///\n-    /// * the alignment of `new_layout` is non-zero.\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n+    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n     /// behavior, e.g. guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors\n     ///\n-    /// Returns `Err` only if `new_layout` does not match the\n-    /// alignment of `layout`, or does not meet the allocator's size\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n     /// and alignment constraints of the allocator, or if reallocation\n     /// otherwise fails.\n     ///\n-    /// (Note the previous sentence did not say \"if and only if\" -- in\n-    /// particular, an implementation of this method *can* return `Ok`\n-    /// if `new_layout.align() != old_layout.align()`; or it can\n-    /// return `Err` in that scenario, depending on whether this\n-    /// allocator can dynamically adjust the alignment constraint for\n-    /// the block.)\n-    ///\n     /// Implementations are encouraged to return `Err` on memory\n     /// exhaustion rather than panicking or aborting, but this is not\n     /// a strict requirement. (Specifically: it is *legal* to\n@@ -698,22 +687,21 @@ pub unsafe trait Alloc {\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let new_size = new_layout.size();\n+                      new_size: usize) -> Result<*mut u8, AllocErr> {\n         let old_size = layout.size();\n-        let aligns_match = layout.align == new_layout.align;\n \n-        if new_size >= old_size && aligns_match {\n-            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_layout.clone()) {\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_size) {\n                 return Ok(ptr);\n             }\n-        } else if new_size < old_size && aligns_match {\n-            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_layout.clone()) {\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_size) {\n                 return Ok(ptr);\n             }\n         }\n \n         // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n         if let Ok(new_ptr) = result {\n             ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n@@ -789,17 +777,19 @@ pub unsafe trait Alloc {\n     unsafe fn realloc_excess(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n+                             new_size: usize) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let usable_size = self.usable_size(&new_layout);\n-        self.realloc(ptr, layout, new_layout)\n+        self.realloc(ptr, layout, new_size)\n             .map(|p| Excess(p, usable_size.1))\n     }\n \n-    /// Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.\n+    /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_layout`, and thus can\n-    /// be used to carry data of that layout. (The allocator is allowed to\n+    /// memory block referenced by `ptr` now fits `new_size`, and thus can\n+    /// be used to carry data of a layout of that size and same alignment as\n+    /// `layout`. (The allocator is allowed to\n     /// expend effort to accomplish this, such as extending the memory block to\n     /// include successor blocks, or virtual memory tricks.)\n     ///\n@@ -815,11 +805,9 @@ pub unsafe trait Alloc {\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n     /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_layout` argument need not fit it,\n+    ///   `new_size` argument need not fit it,\n     ///\n-    /// * `new_layout.size()` must not be less than `layout.size()`,\n-    ///\n-    /// * `new_layout.align()` must equal `layout.align()`.\n+    /// * `new_size` must not be less than `layout.size()`,\n     ///\n     /// # Errors\n     ///\n@@ -834,24 +822,23 @@ pub unsafe trait Alloc {\n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+                            new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_layout.size >= layout.size);\n-        debug_assert!(new_layout.align == layout.align);\n+        debug_assert!(new_size >= layout.size);\n         let (_l, u) = self.usable_size(&layout);\n         // _l <= layout.size()                       [guaranteed by usable_size()]\n         //       layout.size() <= new_layout.size()  [required by this method]\n-        if new_layout.size <= u {\n+        if new_size <= u {\n             return Ok(());\n         } else {\n             return Err(CannotReallocInPlace);\n         }\n     }\n \n-    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_layout`.\n+    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_layout`, and\n+    /// memory block referenced by `ptr` now fits `new_size`, and\n     /// thus can only be used to carry data of that smaller\n     /// layout. (The allocator is allowed to take advantage of this,\n     /// carving off portions of the block for reuse elsewhere.) The\n@@ -872,13 +859,11 @@ pub unsafe trait Alloc {\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n     /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_layout` argument need not fit it,\n+    ///   `new_size` argument need not fit it,\n     ///\n-    /// * `new_layout.size()` must not be greater than `layout.size()`\n+    /// * `new_size` must not be greater than `layout.size()`\n     ///   (and must be greater than zero),\n     ///\n-    /// * `new_layout.align()` must equal `layout.align()`.\n-    ///\n     /// # Errors\n     ///\n     /// Returns `Err(CannotReallocInPlace)` when the allocator is\n@@ -892,14 +877,13 @@ pub unsafe trait Alloc {\n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_layout.size <= layout.size);\n-        debug_assert!(new_layout.align == layout.align);\n+        debug_assert!(new_size <= layout.size);\n         let (l, _u) = self.usable_size(&layout);\n         //                      layout.size() <= _u  [guaranteed by usable_size()]\n         // new_layout.size() <= layout.size()        [required by this method]\n-        if l <= new_layout.size {\n+        if l <= new_size {\n             return Ok(());\n         } else {\n             return Err(CannotReallocInPlace);\n@@ -1061,7 +1045,8 @@ pub unsafe trait Alloc {\n     {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n             (Ok(ref k_old), Ok(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n-                self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n+                debug_assert!(k_old.align() == k_new.align());\n+                self.realloc(ptr as *mut u8, k_old.clone(), k_new.size())\n                     .map(|p| NonNull::new_unchecked(p as *mut T))\n             }\n             _ => {"}]}