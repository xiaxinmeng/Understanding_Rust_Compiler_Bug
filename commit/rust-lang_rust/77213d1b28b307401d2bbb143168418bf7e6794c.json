{"sha": "77213d1b28b307401d2bbb143168418bf7e6794c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MjEzZDFiMjhiMzA3NDAxZDJiYmIxNDMxNjg0MThiZjdlNjc5NGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-18T04:57:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-18T04:57:56Z"}, "message": "Auto merge of #24209 - nikomatsakis:refactor-unification, r=nrc\n\nI'm on a quest to slowly refactor a lot of the inference code. A first step for that is moving the \"pure data structures\" out so as to simplify what's left. This PR moves `snapshot_vec`, `graph`, and `unify` into their own crate (`librustc_data_structures`). They can then be unit-tested, benchmarked, etc more easily. As a benefit, I improved the performance of unification slightly on the benchmark I added vs the original code.\r\n\r\nr? @nrc", "tree": {"sha": "c191a85069e53bb24f06b335f17402215590a946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c191a85069e53bb24f06b335f17402215590a946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77213d1b28b307401d2bbb143168418bf7e6794c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77213d1b28b307401d2bbb143168418bf7e6794c", "html_url": "https://github.com/rust-lang/rust/commit/77213d1b28b307401d2bbb143168418bf7e6794c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77213d1b28b307401d2bbb143168418bf7e6794c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efa6a46a8eceb4ab792d5ec8e28cf3baaaa96491", "url": "https://api.github.com/repos/rust-lang/rust/commits/efa6a46a8eceb4ab792d5ec8e28cf3baaaa96491", "html_url": "https://github.com/rust-lang/rust/commit/efa6a46a8eceb4ab792d5ec8e28cf3baaaa96491"}, {"sha": "e47fb489c10f2d86216c3a75ad6cbde3742e9f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e47fb489c10f2d86216c3a75ad6cbde3742e9f0c", "html_url": "https://github.com/rust-lang/rust/commit/e47fb489c10f2d86216c3a75ad6cbde3742e9f0c"}], "stats": {"total": 1164, "additions": 782, "deletions": 382}, "files": [{"sha": "f7237c90efcb96aa9167d1af6cb650386965ceda", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -54,7 +54,8 @@ TARGET_CRATES := libc std flate arena term \\\n                  log graphviz core rbml alloc \\\n                  unicode rustc_bitflags\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n-                rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint\n+                rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n+                rustc_data_structures\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc rustbook\n@@ -80,9 +81,10 @@ DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc_privacy := rustc log syntax\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n-              log graphviz rustc_llvm rustc_back\n+              log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n+DEPS_rustc_data_structures := std log serialize\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint\n DEPS_rustc_bitflags := core"}, {"sha": "ab5c4e76966018210dd4c09020d23c7beca461dc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -54,6 +54,7 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc_llvm;\n extern crate rustc_back;\n+extern crate rustc_data_structures;\n extern crate serialize;\n extern crate rbml;\n extern crate collections;\n@@ -103,7 +104,6 @@ pub mod middle {\n     pub mod entry;\n     pub mod expr_use_visitor;\n     pub mod fast_reject;\n-    pub mod graph;\n     pub mod intrinsicck;\n     pub mod infer;\n     pub mod lang_items;\n@@ -141,7 +141,6 @@ pub mod util {\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;\n-    pub mod snapshot_vec;\n     pub mod lev_distance;\n }\n "}, {"sha": "359a1a486c9da7cabb5666f45cbc71de2ba607e5", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::graph;\n use middle::cfg::*;\n use middle::def;\n-use middle::graph;\n use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;"}, {"sha": "3ca221c9630be93c92aefaecad46fd3462da9ea8", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -11,7 +11,7 @@\n //! Module that constructs a control-flow graph representing an item.\n //! Uses `Graph` as the underlying representation.\n \n-use middle::graph;\n+use rustc_data_structures::graph;\n use middle::ty;\n use syntax::ast;\n \n@@ -24,7 +24,7 @@ pub struct CFG {\n     pub exit: CFGIndex,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum CFGNodeData {\n     AST(ast::NodeId),\n     Entry,\n@@ -43,6 +43,7 @@ impl CFGNodeData {\n     }\n }\n \n+#[derive(Debug)]\n pub struct CFGEdgeData {\n     pub exiting_scopes: Vec<ast::NodeId>\n }"}, {"sha": "1d5d4f72fc2da7693531a303e7e89a8927c2fe02", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -576,10 +576,9 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                                                pred_bits: &[usize],\n                                                cfg: &cfg::CFG,\n                                                cfgidx: CFGIndex) {\n-        cfg.graph.each_outgoing_edge(cfgidx, |_e_idx, edge| {\n+        for (_, edge) in cfg.graph.outgoing_edges(cfgidx) {\n             self.propagate_bits_into_entry_set_for(pred_bits, edge);\n-            true\n-        });\n+        }\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,"}, {"sha": "d93d13beec8fc47867e881886be8d85faba4ceab", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -37,7 +37,7 @@ use middle::ty_fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n-use super::unify::ToType;\n+use super::unify_key::ToType;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,"}, {"sha": "b0921a266f39f9c14a5eaa038b0162ae75d1cbf1", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -29,6 +29,7 @@ use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell};\n use std::fmt;\n use std::rc::Rc;\n@@ -41,8 +42,8 @@ use util::ppaux::{Repr, UserString};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::unify::{ToType, UnificationTable};\n use self::error_reporting::ErrorReporting;\n+use self::unify_key::ToType;\n \n pub mod bivariate;\n pub mod combine;\n@@ -57,7 +58,7 @@ pub mod resolve;\n mod freshen;\n pub mod sub;\n pub mod type_variable;\n-pub mod unify;\n+pub mod unify_key;\n \n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\""}, {"sha": "e76468131e04d973cf6e6935fd15313de298875a", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -20,14 +20,13 @@ use self::Classification::*;\n \n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n+use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty_relate::RelateResult;\n-use middle::graph;\n-use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::{Repr, UserString};\n@@ -1325,10 +1324,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let num_vars = self.num_vars();\n \n         let constraints = self.constraints.borrow();\n-        let num_edges = constraints.len();\n \n-        let mut graph = graph::Graph::with_capacity(num_vars as usize + 1,\n-                                                    num_edges);\n+        let mut graph = graph::Graph::new();\n \n         for _ in 0..num_vars {\n             graph.add_node(());\n@@ -1370,10 +1367,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // not contained by an upper-bound.\n         let (mut lower_bounds, lower_dup) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::Incoming, dup_vec);\n+                                          graph::INCOMING, dup_vec);\n         let (mut upper_bounds, upper_dup) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::Outgoing, dup_vec);\n+                                          graph::OUTGOING, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n@@ -1433,7 +1430,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::Outgoing, dup_vec);\n+                                          graph::OUTGOING, dup_vec);\n \n         if dup_found {\n             return;\n@@ -1508,8 +1505,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // figure out the direction from which this node takes its\n             // values, and search for concrete regions etc in that direction\n             let dir = match classification {\n-                Expanding => graph::Incoming,\n-                Contracting => graph::Outgoing,\n+                Expanding => graph::INCOMING,\n+                Contracting => graph::OUTGOING,\n             };\n \n             process_edges(self, &mut state, graph, node_idx, dir);\n@@ -1519,14 +1516,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         return (result, dup_found);\n \n         fn process_edges<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n-                         state: &mut WalkState<'tcx>,\n-                         graph: &RegionGraph,\n-                         source_vid: RegionVid,\n-                         dir: Direction) {\n+                                   state: &mut WalkState<'tcx>,\n+                                   graph: &RegionGraph,\n+                                   source_vid: RegionVid,\n+                                   dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index as usize);\n-            graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n+            for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n@@ -1544,8 +1541,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         });\n                     }\n                 }\n-                true\n-            });\n+            }\n         }\n     }\n "}, {"sha": "b3e3e016d85c2cbde4a6fa559ccd63b08c49a9a4", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -17,7 +17,7 @@ use std::cmp::min;\n use std::marker::PhantomData;\n use std::mem;\n use std::u32;\n-use util::snapshot_vec as sv;\n+use rustc_data_structures::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n     values: sv::SnapshotVec<Delegate<'tcx>>,\n@@ -65,7 +65,7 @@ impl RelationDir {\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n-        TypeVariableTable { values: sv::SnapshotVec::new(Delegate(PhantomData)) }\n+        TypeVariableTable { values: sv::SnapshotVec::new() }\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n@@ -201,9 +201,7 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n     type Value = TypeVariableData<'tcx>;\n     type Undo = UndoEntry;\n \n-    fn reverse(&mut self,\n-               values: &mut Vec<TypeVariableData<'tcx>>,\n-               action: UndoEntry) {\n+    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n                 values[vid.index as usize].value = Bounded(relations);"}, {"sha": "6b23e2c5029b8cddff34586de80e4e997272653f", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self, IntVarValue, Ty};\n+use rustc_data_structures::unify::UnifyKey;\n+use syntax::ast;\n+\n+pub trait ToType<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+}\n+\n+impl UnifyKey for ty::IntVid {\n+    type Value = Option<IntVarValue>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n+    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n+}\n+\n+impl<'tcx> ToType<'tcx> for IntVarValue {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n+            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n+        }\n+    }\n+}\n+\n+// Floating point type keys\n+\n+impl UnifyKey for ty::FloatVid {\n+    type Value = Option<ast::FloatTy>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n+    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n+}\n+\n+impl<'tcx> ToType<'tcx> for ast::FloatTy {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        ty::mk_mach_float(tcx, *self)\n+    }\n+}"}, {"sha": "983601771a02f6809e7b30df6f243047dcb15025", "filename": "src/librustc_data_structures/bitvec.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter;\n+\n+/// A very simple BitVector type.\n+pub struct BitVector {\n+    data: Vec<u64>\n+}\n+\n+impl BitVector {\n+    pub fn new(num_bits: usize) -> BitVector {\n+        let num_words = (num_bits + 63) / 64;\n+        BitVector { data: iter::repeat(0).take(num_words).collect() }\n+    }\n+\n+    fn word_mask(&self, bit: usize) -> (usize, u64) {\n+        let word = bit / 64;\n+        let mask = 1 << (bit % 64);\n+        (word, mask)\n+    }\n+\n+    pub fn contains(&self, bit: usize) -> bool {\n+        let (word, mask) = self.word_mask(bit);\n+        (self.data[word] & mask) != 0\n+    }\n+\n+    pub fn insert(&mut self, bit: usize) -> bool {\n+        let (word, mask) = self.word_mask(bit);\n+        let data = &mut self.data[word];\n+        let value = *data;\n+        *data = value | mask;\n+        (value | mask) != value\n+    }\n+}"}, {"sha": "5741544fe5419638d262839ab3c512d8e4ef4a28", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "renamed", "additions": 136, "deletions": 217, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -30,15 +30,17 @@\n //! the field `next_edge`). Each of those fields is an array that should\n //! be indexed by the direction (see the type `Direction`).\n \n-#![allow(dead_code)] // still WIP\n-\n+use bitvec::BitVector;\n use std::fmt::{Formatter, Error, Debug};\n use std::usize;\n-use std::collections::BitSet;\n+use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n+\n+#[cfg(test)]\n+mod test;\n \n pub struct Graph<N,E> {\n-    nodes: Vec<Node<N>> ,\n-    edges: Vec<Edge<E>> ,\n+    nodes: SnapshotVec<Node<N>> ,\n+    edges: SnapshotVec<Edge<E>> ,\n }\n \n pub struct Node<N> {\n@@ -53,6 +55,20 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n+impl<N> SnapshotVecDelegate for Node<N> {\n+    type Value = Node<N>;\n+    type Undo = ();\n+\n+    fn reverse(_: &mut Vec<Node<N>>, _: ()) {}\n+}\n+\n+impl<N> SnapshotVecDelegate for Edge<N> {\n+    type Value = Edge<N>;\n+    type Undo = ();\n+\n+    fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n+}\n+\n impl<E: Debug> Debug for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n         write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n@@ -61,49 +77,37 @@ impl<E: Debug> Debug for Edge<E> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub struct NodeIndex(pub usize);\n-#[allow(non_upper_case_globals)]\n-pub const InvalidNodeIndex: NodeIndex = NodeIndex(usize::MAX);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub struct EdgeIndex(pub usize);\n-#[allow(non_upper_case_globals)]\n-pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(usize::MAX);\n+\n+pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Clone, Debug)]\n pub struct Direction { repr: usize }\n-#[allow(non_upper_case_globals)]\n-pub const Outgoing: Direction = Direction { repr: 0 };\n-#[allow(non_upper_case_globals)]\n-pub const Incoming: Direction = Direction { repr: 1 };\n+\n+pub const OUTGOING: Direction = Direction { repr: 0 };\n+\n+pub const INCOMING: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n-    fn get(&self) -> usize { let NodeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated node).\n-    pub fn node_id(&self) -> usize { self.get() }\n+    pub fn node_id(&self) -> usize { self.0 }\n }\n \n impl EdgeIndex {\n-    fn get(&self) -> usize { let EdgeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> usize { self.get() }\n+    pub fn edge_id(&self) -> usize { self.0 }\n }\n \n-impl<N,E> Graph<N,E> {\n+impl<N:Debug,E:Debug> Graph<N,E> {\n     pub fn new() -> Graph<N,E> {\n         Graph {\n-            nodes: Vec::new(),\n-            edges: Vec::new(),\n-        }\n-    }\n-\n-    pub fn with_capacity(num_nodes: usize,\n-                         num_edges: usize) -> Graph<N,E> {\n-        Graph {\n-            nodes: Vec::with_capacity(num_nodes),\n-            edges: Vec::with_capacity(num_edges),\n+            nodes: SnapshotVec::new(),\n+            edges: SnapshotVec::new(),\n         }\n     }\n \n@@ -130,22 +134,22 @@ impl<N,E> Graph<N,E> {\n     pub fn add_node(&mut self, data: N) -> NodeIndex {\n         let idx = self.next_node_index();\n         self.nodes.push(Node {\n-            first_edge: [InvalidEdgeIndex, InvalidEdgeIndex],\n+            first_edge: [INVALID_EDGE_INDEX, INVALID_EDGE_INDEX],\n             data: data\n         });\n         idx\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes[idx.get()].data\n+        &mut self.nodes[idx.0].data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes[idx.get()].data\n+        &self.nodes[idx.0].data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        &self.nodes[idx.get()]\n+        &self.nodes[idx.0]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -159,13 +163,15 @@ impl<N,E> Graph<N,E> {\n                     source: NodeIndex,\n                     target: NodeIndex,\n                     data: E) -> EdgeIndex {\n+        debug!(\"graph: add_edge({:?}, {:?}, {:?})\", source, target, data);\n+\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes[source.get()]\n-                                     .first_edge[Outgoing.repr];\n-        let target_first = self.nodes[target.get()]\n-                                     .first_edge[Incoming.repr];\n+        let source_first = self.nodes[source.0]\n+                                     .first_edge[OUTGOING.repr];\n+        let target_first = self.nodes[target.0]\n+                                     .first_edge[INCOMING.repr];\n \n         // create the new edge, with the previous firsts from each node\n         // as the next pointers\n@@ -177,38 +183,38 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n-        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n+        self.nodes[source.0].first_edge[OUTGOING.repr] = idx;\n+        self.nodes[target.0].first_edge[INCOMING.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges[idx.get()].data\n+        &mut self.edges[idx.0].data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges[idx.get()].data\n+        &self.edges[idx.0].data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        &self.edges[idx.get()]\n+        &self.edges[idx.0]\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes[node.get()].first_edge[dir.repr]\n+        self.nodes[node.0].first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges[edge.get()].next_edge[dir.repr]\n+        self.edges[edge.0].next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -228,41 +234,25 @@ impl<N,E> Graph<N,E> {\n         self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n-    pub fn each_outgoing_edge<'a, F>(&'a self, source: NodeIndex, f: F) -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n-    {\n-        //! Iterates over all outgoing edges from the node `from`\n+    pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N,E> {\n+        self.adjacent_edges(source, OUTGOING)\n+    }\n \n-        self.each_adjacent_edge(source, Outgoing, f)\n+    pub fn incoming_edges(&self, source: NodeIndex) -> AdjacentEdges<N,E> {\n+        self.adjacent_edges(source, INCOMING)\n     }\n \n-    pub fn each_incoming_edge<'a, F>(&'a self, target: NodeIndex, f: F) -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n-    {\n-        //! Iterates over all incoming edges to the node `target`\n+    pub fn adjacent_edges(&self, source: NodeIndex, direction: Direction) -> AdjacentEdges<N,E> {\n+        let first_edge = self.node(source).first_edge[direction.repr];\n+        AdjacentEdges { graph: self, direction: direction, next: first_edge }\n+    }\n \n-        self.each_adjacent_edge(target, Incoming, f)\n+    pub fn successor_nodes<'a>(&'a self, source: NodeIndex) -> AdjacentTargets<N,E> {\n+        self.outgoing_edges(source).targets()\n     }\n \n-    pub fn each_adjacent_edge<'a, F>(&'a self,\n-                                     node: NodeIndex,\n-                                     dir: Direction,\n-                                     mut f: F)\n-                                     -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n-    {\n-        //! Iterates over all edges adjacent to the node `node`\n-        //! in the direction `dir` (either `Outgoing` or `Incoming)\n-\n-        let mut edge_idx = self.first_adjacent(node, dir);\n-        while edge_idx != InvalidEdgeIndex {\n-            let edge = &self.edges[edge_idx.get()];\n-            if !f(edge_idx, edge) {\n-                return false;\n-            }\n-            edge_idx = edge.next_edge[dir.repr];\n-        }\n-        return true;\n+    pub fn predecessor_nodes<'a>(&'a self, target: NodeIndex) -> AdjacentSources<N,E> {\n+        self.incoming_edges(target).sources()\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -292,31 +282,95 @@ impl<N,E> Graph<N,E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n-            visited: BitSet::new()\n+            visited: BitVector::new(self.nodes.len()),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Iterators\n+\n+pub struct AdjacentEdges<'g,N,E>\n+    where N:'g, E:'g\n+{\n+    graph: &'g Graph<N, E>,\n+    direction: Direction,\n+    next: EdgeIndex,\n+}\n+\n+impl<'g,N,E> AdjacentEdges<'g,N,E> {\n+    fn targets(self) -> AdjacentTargets<'g,N,E> {\n+        AdjacentTargets { edges: self }\n+    }\n+\n+    fn sources(self) -> AdjacentSources<'g,N,E> {\n+        AdjacentSources { edges: self }\n+    }\n+}\n+\n+impl<'g, N:Debug, E:Debug> Iterator for AdjacentEdges<'g, N, E> {\n+    type Item = (EdgeIndex, &'g Edge<E>);\n+\n+    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n+        let edge_index = self.next;\n+        if edge_index == INVALID_EDGE_INDEX {\n+            return None;\n         }\n+\n+        let edge = self.graph.edge(edge_index);\n+        self.next = edge.next_edge[self.direction.repr];\n+        Some((edge_index, edge))\n+    }\n+}\n+\n+pub struct AdjacentTargets<'g,N:'g,E:'g>\n+    where N:'g, E:'g\n+{\n+    edges: AdjacentEdges<'g,N,E>,\n+}\n+\n+impl<'g, N:Debug, E:Debug> Iterator for AdjacentTargets<'g, N, E> {\n+    type Item = NodeIndex;\n+\n+    fn next(&mut self) -> Option<NodeIndex> {\n+        self.edges.next().map(|(_, edge)| edge.target)\n+    }\n+}\n+\n+pub struct AdjacentSources<'g,N:'g,E:'g>\n+    where N:'g, E:'g\n+{\n+    edges: AdjacentEdges<'g,N,E>,\n+}\n+\n+impl<'g, N:Debug, E:Debug> Iterator for AdjacentSources<'g, N, E> {\n+    type Item = NodeIndex;\n+\n+    fn next(&mut self) -> Option<NodeIndex> {\n+        self.edges.next().map(|(_, edge)| edge.source)\n     }\n }\n \n pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitSet\n+    visited: BitVector\n }\n \n-impl<'g, N, E> Iterator for DepthFirstTraversal<'g, N, E> {\n+impl<'g, N:Debug, E:Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     type Item = &'g N;\n \n     fn next(&mut self) -> Option<&'g N> {\n         while let Some(idx) = self.stack.pop() {\n             if !self.visited.insert(idx.node_id()) {\n                 continue;\n             }\n-            self.graph.each_outgoing_edge(idx, |_, e| -> bool {\n-                if !self.visited.contains(&e.target().node_id()) {\n-                    self.stack.push(e.target());\n+\n+            for (_, edge) in self.graph.outgoing_edges(idx) {\n+                if !self.visited.contains(edge.target().node_id()) {\n+                    self.stack.push(edge.target());\n                 }\n-                true\n-            });\n+            }\n \n             return Some(self.graph.node_data(idx));\n         }\n@@ -329,7 +383,7 @@ pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where\n     F: FnMut(EdgeIndex) -> bool,\n {\n     let mut i = 0;\n-    let n = max_edge_index.get();\n+    let n = max_edge_index.0;\n     while i < n {\n         if !f(EdgeIndex(i)) {\n             return;\n@@ -347,138 +401,3 @@ impl<E> Edge<E> {\n         self.target\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use middle::graph::*;\n-    use std::fmt::Debug;\n-\n-    type TestNode = Node<&'static str>;\n-    type TestEdge = Edge<&'static str>;\n-    type TestGraph = Graph<&'static str, &'static str>;\n-\n-    fn create_graph() -> TestGraph {\n-        let mut graph = Graph::new();\n-\n-        // Create a simple graph\n-        //\n-        //    A -+> B --> C\n-        //       |  |     ^\n-        //       |  v     |\n-        //       F  D --> E\n-\n-        let a = graph.add_node(\"A\");\n-        let b = graph.add_node(\"B\");\n-        let c = graph.add_node(\"C\");\n-        let d = graph.add_node(\"D\");\n-        let e = graph.add_node(\"E\");\n-        let f = graph.add_node(\"F\");\n-\n-        graph.add_edge(a, b, \"AB\");\n-        graph.add_edge(b, c, \"BC\");\n-        graph.add_edge(b, d, \"BD\");\n-        graph.add_edge(d, e, \"DE\");\n-        graph.add_edge(e, c, \"EC\");\n-        graph.add_edge(f, b, \"FB\");\n-\n-        return graph;\n-    }\n-\n-    #[test]\n-    fn each_node() {\n-        let graph = create_graph();\n-        let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n-        graph.each_node(|idx, node| {\n-            assert_eq!(&expected[idx.get()], graph.node_data(idx));\n-            assert_eq!(expected[idx.get()], node.data);\n-            true\n-        });\n-    }\n-\n-    #[test]\n-    fn each_edge() {\n-        let graph = create_graph();\n-        let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n-        graph.each_edge(|idx, edge| {\n-            assert_eq!(&expected[idx.get()], graph.edge_data(idx));\n-            assert_eq!(expected[idx.get()], edge.data);\n-            true\n-        });\n-    }\n-\n-    fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n-                                      start_index: NodeIndex,\n-                                      start_data: N,\n-                                      expected_incoming: &[(E,N)],\n-                                      expected_outgoing: &[(E,N)]) {\n-        assert!(graph.node_data(start_index) == &start_data);\n-\n-        let mut counter = 0;\n-        graph.each_incoming_edge(start_index, |edge_index, edge| {\n-            assert!(graph.edge_data(edge_index) == &edge.data);\n-            assert!(counter < expected_incoming.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n-                   counter, expected_incoming[counter], edge_index, edge);\n-            match expected_incoming[counter] {\n-                (ref e, ref n) => {\n-                    assert!(e == &edge.data);\n-                    assert!(n == graph.node_data(edge.source));\n-                    assert!(start_index == edge.target);\n-                }\n-            }\n-            counter += 1;\n-            true\n-        });\n-        assert_eq!(counter, expected_incoming.len());\n-\n-        let mut counter = 0;\n-        graph.each_outgoing_edge(start_index, |edge_index, edge| {\n-            assert!(graph.edge_data(edge_index) == &edge.data);\n-            assert!(counter < expected_outgoing.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n-                   counter, expected_outgoing[counter], edge_index, edge);\n-            match expected_outgoing[counter] {\n-                (ref e, ref n) => {\n-                    assert!(e == &edge.data);\n-                    assert!(start_index == edge.source);\n-                    assert!(n == graph.node_data(edge.target));\n-                }\n-            }\n-            counter += 1;\n-            true\n-        });\n-        assert_eq!(counter, expected_outgoing.len());\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_a() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n-                            &[],\n-                            &[(\"AB\", \"B\")]);\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_b() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n-                            &[(\"FB\", \"F\"), (\"AB\", \"A\"),],\n-                            &[(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_c() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n-                            &[(\"EC\", \"E\"), (\"BC\", \"B\")],\n-                            &[]);\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_d() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n-                            &[(\"BD\", \"B\")],\n-                            &[(\"DE\", \"E\")]);\n-    }\n-}", "previous_filename": "src/librustc/middle/graph.rs"}, {"sha": "33b2edd2e106d22ec0dd98f4b17a7067dc38f43f", "filename": "src/librustc_data_structures/graph/test.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use graph::*;\n+use std::fmt::Debug;\n+\n+type TestNode = Node<&'static str>;\n+type TestEdge = Edge<&'static str>;\n+type TestGraph = Graph<&'static str, &'static str>;\n+\n+fn create_graph() -> TestGraph {\n+    let mut graph = Graph::new();\n+\n+    // Create a simple graph\n+    //\n+    //    A -+> B --> C\n+    //       |  |     ^\n+    //       |  v     |\n+    //       F  D --> E\n+\n+    let a = graph.add_node(\"A\");\n+    let b = graph.add_node(\"B\");\n+    let c = graph.add_node(\"C\");\n+    let d = graph.add_node(\"D\");\n+    let e = graph.add_node(\"E\");\n+    let f = graph.add_node(\"F\");\n+\n+    graph.add_edge(a, b, \"AB\");\n+    graph.add_edge(b, c, \"BC\");\n+    graph.add_edge(b, d, \"BD\");\n+    graph.add_edge(d, e, \"DE\");\n+    graph.add_edge(e, c, \"EC\");\n+    graph.add_edge(f, b, \"FB\");\n+\n+    return graph;\n+}\n+\n+#[test]\n+fn each_node() {\n+    let graph = create_graph();\n+    let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n+    graph.each_node(|idx, node| {\n+        assert_eq!(&expected[idx.0], graph.node_data(idx));\n+        assert_eq!(expected[idx.0], node.data);\n+        true\n+    });\n+}\n+\n+#[test]\n+fn each_edge() {\n+    let graph = create_graph();\n+    let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n+    graph.each_edge(|idx, edge| {\n+        assert_eq!(&expected[idx.0], graph.edge_data(idx));\n+        assert_eq!(expected[idx.0], edge.data);\n+        true\n+    });\n+}\n+\n+fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n+                                                            start_index: NodeIndex,\n+                                                            start_data: N,\n+                                                            expected_incoming: &[(E,N)],\n+                                                            expected_outgoing: &[(E,N)]) {\n+    assert!(graph.node_data(start_index) == &start_data);\n+\n+    let mut counter = 0;\n+    for (edge_index, edge) in graph.incoming_edges(start_index) {\n+        assert!(graph.edge_data(edge_index) == &edge.data);\n+        assert!(counter < expected_incoming.len());\n+        debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+               counter, expected_incoming[counter], edge_index, edge);\n+        match expected_incoming[counter] {\n+            (ref e, ref n) => {\n+                assert!(e == &edge.data);\n+                assert!(n == graph.node_data(edge.source()));\n+                assert!(start_index == edge.target);\n+            }\n+        }\n+        counter += 1;\n+    }\n+    assert_eq!(counter, expected_incoming.len());\n+\n+    let mut counter = 0;\n+    for (edge_index, edge) in graph.outgoing_edges(start_index) {\n+        assert!(graph.edge_data(edge_index) == &edge.data);\n+        assert!(counter < expected_outgoing.len());\n+        debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+               counter, expected_outgoing[counter], edge_index, edge);\n+        match expected_outgoing[counter] {\n+            (ref e, ref n) => {\n+                assert!(e == &edge.data);\n+                assert!(start_index == edge.source);\n+                assert!(n == graph.node_data(edge.target));\n+            }\n+        }\n+        counter += 1;\n+    }\n+    assert_eq!(counter, expected_outgoing.len());\n+}\n+\n+#[test]\n+fn each_adjacent_from_a() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n+                        &[],\n+                        &[(\"AB\", \"B\")]);\n+}\n+\n+#[test]\n+fn each_adjacent_from_b() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n+                        &[(\"FB\", \"F\"), (\"AB\", \"A\"),],\n+                        &[(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n+}\n+\n+#[test]\n+fn each_adjacent_from_c() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n+                        &[(\"EC\", \"E\"), (\"BC\", \"B\")],\n+                        &[]);\n+}\n+\n+#[test]\n+fn each_adjacent_from_d() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n+                        &[(\"BD\", \"B\")],\n+                        &[(\"DE\", \"E\")]);\n+}"}, {"sha": "dc376deebc113f941ff3cfd08a2cf76f05e1b04c", "filename": "src/librustc_data_structures/lib.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Various data structures used by the Rust compiler. The intention\n+//! is that code in here should be not be *specific* to rustc, so that\n+//! it can be easily unit tested and so forth.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+// Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"rustc_data_structures\"]\n+#![unstable(feature = \"rustc_private\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(rustc_private)]\n+#![cfg_attr(test, feature(test))]\n+\n+#[macro_use] extern crate log;\n+extern crate serialize as rustc_serialize; // used by deriving\n+\n+pub mod snapshot_vec;\n+pub mod graph;\n+pub mod bitvec;\n+pub mod unify;"}, {"sha": "5ab740f3629aa80238424aef0db1c173d3e23655", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "renamed", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -21,6 +21,7 @@\n use self::UndoLog::*;\n \n use std::mem;\n+use std::ops;\n \n pub enum UndoLog<D:SnapshotVecDelegate> {\n     /// Indicates where a snapshot started.\n@@ -42,7 +43,6 @@ pub enum UndoLog<D:SnapshotVecDelegate> {\n pub struct SnapshotVec<D:SnapshotVecDelegate> {\n     values: Vec<D::Value>,\n     undo_log: Vec<UndoLog<D>>,\n-    delegate: D\n }\n \n // Snapshots are tokens that should be created/consumed linearly.\n@@ -55,15 +55,14 @@ pub trait SnapshotVecDelegate {\n     type Value;\n     type Undo;\n \n-    fn reverse(&mut self, values: &mut Vec<Self::Value>, action: Self::Undo);\n+    fn reverse(values: &mut Vec<Self::Value>, action: Self::Undo);\n }\n \n impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n-    pub fn new(delegate: D) -> SnapshotVec<D> {\n+    pub fn new() -> SnapshotVec<D> {\n         SnapshotVec {\n             values: Vec::new(),\n             undo_log: Vec::new(),\n-            delegate: delegate\n         }\n     }\n \n@@ -77,6 +76,10 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         }\n     }\n \n+    pub fn len(&self) -> usize {\n+        self.values.len()\n+    }\n+\n     pub fn push(&mut self, elem: D::Value) -> usize {\n         let len = self.values.len();\n         self.values.push(elem);\n@@ -159,7 +162,7 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n                 }\n \n                 Other(u) => {\n-                    self.delegate.reverse(&mut self.values, u);\n+                    D::reverse(&mut self.values, u);\n                 }\n             }\n         }\n@@ -184,3 +187,21 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         }\n     }\n }\n+\n+impl<D:SnapshotVecDelegate> ops::Deref for SnapshotVec<D> {\n+    type Target = [D::Value];\n+    fn deref(&self) -> &[D::Value] { &*self.values }\n+}\n+\n+impl<D:SnapshotVecDelegate> ops::DerefMut for SnapshotVec<D> {\n+    fn deref_mut(&mut self) -> &mut [D::Value] { &mut *self.values }\n+}\n+\n+impl<D:SnapshotVecDelegate> ops::Index<usize> for SnapshotVec<D> {\n+    type Output = D::Value;\n+    fn index(&self, index: usize) -> &D::Value { self.get(index) }\n+}\n+\n+impl<D:SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n+    fn index_mut(&mut self, index: usize) -> &mut D::Value { self.get_mut(index) }\n+}", "previous_filename": "src/librustc/util/snapshot_vec.rs"}, {"sha": "7036c010c6580898d87c3973654f454034e54ece", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "renamed", "additions": 125, "deletions": 122, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::VarValue::*;\n-\n use std::marker;\n-\n-use middle::ty::{IntVarValue};\n-use middle::ty::{self, Ty};\n use std::fmt::Debug;\n use std::marker::PhantomData;\n-use syntax::ast;\n-use util::snapshot_vec as sv;\n+use snapshot_vec as sv;\n+\n+#[cfg(test)]\n+mod test;\n \n /// This trait is implemented by any type that can serve as a type\n /// variable. We call such variables *unification keys*. For example,\n@@ -28,9 +25,10 @@ use util::snapshot_vec as sv;\n /// `IntVid`, this is `Option<IntVarValue>`, representing some\n /// (possibly not yet known) sort of integer.\n ///\n-/// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey : Clone + Debug + PartialEq {\n-    type Value : UnifyValue;\n+/// Clients are expected to provide implementations of this trait; you\n+/// can see some examples in the `test` module.\n+pub trait UnifyKey : Copy + Clone + Debug + PartialEq {\n+    type Value: Clone + PartialEq + Debug;\n \n     fn index(&self) -> u32;\n \n@@ -39,15 +37,6 @@ pub trait UnifyKey : Clone + Debug + PartialEq {\n     fn tag(k: Option<Self>) -> &'static str;\n }\n \n-/// Trait for valid types that a type variable can be set to. Note that\n-/// this is typically not the end type that the value will take on, but\n-/// rather an `Option` wrapper (where `None` represents a variable\n-/// whose value is not yet set).\n-///\n-/// Implementations of this trait are at the end of this file.\n-pub trait UnifyValue : Clone + PartialEq + Debug {\n-}\n-\n /// Value of a unification key. We implement Tarjan's union-find\n /// algorithm: when two keys are unified, one of them is converted\n /// into a \"redirect\" pointing at the other. These redirects form a\n@@ -57,9 +46,10 @@ pub trait UnifyValue : Clone + PartialEq + Debug {\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n #[derive(PartialEq,Clone,Debug)]\n-pub enum VarValue<K:UnifyKey> {\n-    Redirect(K),\n-    Root(K::Value, usize),\n+pub struct VarValue<K:UnifyKey> {\n+    parent: K,       // if equal to self, this is a root\n+    value: K::Value, // value assigned (only relevant to root)\n+    rank: u32,       // max depth (only relevant to root)\n }\n \n /// Table of unification keys and their values.\n@@ -76,16 +66,46 @@ pub struct Snapshot<K:UnifyKey> {\n     snapshot: sv::Snapshot,\n }\n \n-/// Internal type used to represent the result of a `get()` operation.\n-/// Conveys the current root and value of the key.\n-pub struct Node<K:UnifyKey> {\n-    pub key: K,\n-    pub value: K::Value,\n-    pub rank: usize,\n-}\n-\n #[derive(Copy, Clone)]\n-pub struct Delegate<K>(PhantomData<K>);\n+struct Delegate<K>(PhantomData<K>);\n+\n+impl<K:UnifyKey> VarValue<K> {\n+    fn new_var(key: K, value: K::Value) -> VarValue<K> {\n+        VarValue::new(key, value, 0)\n+    }\n+\n+    fn new(parent: K, value: K::Value, rank: u32) -> VarValue<K> {\n+        VarValue { parent: parent, // this is a root\n+                   value: value,\n+                   rank: rank }\n+    }\n+\n+    fn redirect(self, to: K) -> VarValue<K> {\n+        VarValue { parent: to, ..self }\n+    }\n+\n+    fn root(self, rank: u32, value: K::Value) -> VarValue<K> {\n+        VarValue { rank: rank, value: value, ..self }\n+    }\n+\n+    /// Returns the key of this node. Only valid if this is a root\n+    /// node, which you yourself must ensure.\n+    fn key(&self) -> K {\n+        self.parent\n+    }\n+\n+    fn parent(&self, self_key: K) -> Option<K> {\n+        self.if_not_self(self.parent, self_key)\n+    }\n+\n+    fn if_not_self(&self, key: K, self_key: K) -> Option<K> {\n+        if key == self_key {\n+            None\n+        } else {\n+            Some(key)\n+        }\n+    }\n+}\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n@@ -95,7 +115,7 @@ pub struct Delegate<K>(PhantomData<K>);\n impl<K:UnifyKey> UnificationTable<K> {\n     pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n-            values: sv::SnapshotVec::new(Delegate(PhantomData)),\n+            values: sv::SnapshotVec::new()\n         }\n     }\n \n@@ -121,12 +141,13 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n \n     pub fn new_key(&mut self, value: K::Value) -> K {\n-        let index = self.values.push(Root(value, 0));\n-        let k = UnifyKey::from_index(index as u32);\n+        let len = self.values.len();\n+        let key: K = UnifyKey::from_index(len as u32);\n+        self.values.push(VarValue::new_var(key, value));\n         debug!(\"{}: created new key: {:?}\",\n                UnifyKey::tag(None::<K>),\n-               k);\n-        k\n+               key);\n+        key\n     }\n \n     /// Find the root node for `vid`. This uses the standard\n@@ -135,36 +156,34 @@ impl<K:UnifyKey> UnificationTable<K> {\n     ///\n     /// NB. This is a building-block operation and you would probably\n     /// prefer to call `probe` below.\n-    fn get(&mut self, vid: K) -> Node<K> {\n+    fn get(&mut self, vid: K) -> VarValue<K> {\n         let index = vid.index() as usize;\n-        let value = (*self.values.get(index)).clone();\n-        match value {\n-            Redirect(redirect) => {\n-                let node: Node<K> = self.get(redirect.clone());\n-                if node.key != redirect {\n+        let mut value: VarValue<K> = self.values.get(index).clone();\n+        match value.parent(vid) {\n+            Some(redirect) => {\n+                let root: VarValue<K> = self.get(redirect);\n+                if root.key() != redirect {\n                     // Path compression\n-                    self.values.set(index, Redirect(node.key.clone()));\n+                    value.parent = root.key();\n+                    self.values.set(index, value);\n                 }\n-                node\n+                root\n             }\n-            Root(value, rank) => {\n-                Node { key: vid, value: value, rank: rank }\n+            None => {\n+                value\n             }\n         }\n     }\n \n-    fn is_root(&self, key: &K) -> bool {\n+    fn is_root(&self, key: K) -> bool {\n         let index = key.index() as usize;\n-        match *self.values.get(index) {\n-            Redirect(..) => false,\n-            Root(..) => true,\n-        }\n+        self.values.get(index).parent(key).is_none()\n     }\n \n     /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n     /// node! This is an internal operation used to impl other things.\n     fn set(&mut self, key: K, new_value: VarValue<K>) {\n-        assert!(self.is_root(&key));\n+        assert!(self.is_root(key));\n \n         debug!(\"Updating variable {:?} to {:?}\",\n                key, new_value);\n@@ -181,40 +200,68 @@ impl<K:UnifyKey> UnificationTable<K> {\n     /// really more of a building block. If the values associated with\n     /// your key are non-trivial, you would probably prefer to call\n     /// `unify_var_var` below.\n-    fn unify(&mut self, node_a: &Node<K>, node_b: &Node<K>, new_value: K::Value) {\n-        debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n-               node_a.key,\n-               node_a.rank,\n-               node_b.key,\n-               node_b.rank);\n-\n-        let (new_root, new_rank) = if node_a.rank > node_b.rank {\n+    fn unify(&mut self, root_a: VarValue<K>, root_b: VarValue<K>, new_value: K::Value) {\n+        debug!(\"unify(root_a(id={:?}, rank={:?}), root_b(id={:?}, rank={:?}))\",\n+               root_a.key(),\n+               root_a.rank,\n+               root_b.key(),\n+               root_b.rank);\n+\n+        if root_a.rank > root_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n-            (node_a.key.clone(), node_a.rank)\n-        } else if node_a.rank < node_b.rank {\n+            self.redirect_root(root_a.rank, root_b, root_a, new_value);\n+        } else if root_a.rank < root_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(node_a.key.clone(), Redirect(node_b.key.clone()));\n-            (node_b.key.clone(), node_b.rank)\n+            self.redirect_root(root_b.rank, root_a, root_b, new_value);\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            assert_eq!(node_a.rank, node_b.rank);\n-            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n-            (node_a.key.clone(), node_a.rank + 1)\n-        };\n+            self.redirect_root(root_a.rank + 1, root_a, root_b, new_value);\n+        }\n+    }\n \n-        self.set(new_root, Root(new_value, new_rank));\n+    fn redirect_root(&mut self,\n+                     new_rank: u32,\n+                     old_root: VarValue<K>,\n+                     new_root: VarValue<K>,\n+                     new_value: K::Value) {\n+        let old_root_key = old_root.key();\n+        let new_root_key = new_root.key();\n+        self.set(old_root_key, old_root.redirect(new_root_key));\n+        self.set(new_root_key, new_root.root(new_rank, new_value));\n     }\n }\n \n impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n     type Value = VarValue<K>;\n     type Undo = ();\n \n-    fn reverse(&mut self, _: &mut Vec<VarValue<K>>, _: ()) {\n-        panic!(\"Nothing to reverse\");\n+    fn reverse(_: &mut Vec<VarValue<K>>, _: ()) {}\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Base union-find algorithm, where we are just making sets\n+\n+impl<'tcx,K> UnificationTable<K>\n+    where K : UnifyKey<Value=()>,\n+{\n+    pub fn union(&mut self, a_id: K, b_id: K) {\n+        let node_a = self.get(a_id);\n+        let node_b = self.get(b_id);\n+        let a_id = node_a.key();\n+        let b_id = node_b.key();\n+        if a_id != b_id {\n+            self.unify(node_a, node_b, ());\n+        }\n+    }\n+\n+    pub fn find(&mut self, id: K) -> K {\n+        self.get(id).key()\n+    }\n+\n+    pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n+        self.find(a_id) == self.find(b_id)\n     }\n }\n \n@@ -226,7 +273,6 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n impl<'tcx,K,V> UnificationTable<K>\n     where K: UnifyKey<Value=Option<V>>,\n           V: Clone+PartialEq,\n-          Option<V>: UnifyValue,\n {\n     pub fn unify_var_var(&mut self,\n                          a_id: K,\n@@ -235,8 +281,8 @@ impl<'tcx,K,V> UnificationTable<K>\n     {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n-        let a_id = node_a.key.clone();\n-        let b_id = node_b.key.clone();\n+        let a_id = node_a.key();\n+        let b_id = node_b.key();\n \n         if a_id == b_id { return Ok(()); }\n \n@@ -257,7 +303,7 @@ impl<'tcx,K,V> UnificationTable<K>\n             }\n         };\n \n-        Ok(self.unify(&node_a, &node_b, combined))\n+        Ok(self.unify(node_a, node_b, combined))\n     }\n \n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n@@ -267,12 +313,12 @@ impl<'tcx,K,V> UnificationTable<K>\n                            b: V)\n                            -> Result<(),(V,V)>\n     {\n-        let node_a = self.get(a_id);\n-        let a_id = node_a.key.clone();\n+        let mut node_a = self.get(a_id);\n \n         match node_a.value {\n             None => {\n-                self.set(a_id, Root(Some(b), node_a.rank));\n+                node_a.value = Some(b);\n+                self.set(node_a.key(), node_a);\n                 Ok(())\n             }\n \n@@ -295,46 +341,3 @@ impl<'tcx,K,V> UnificationTable<K>\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n-// Integral type keys\n-\n-pub trait ToType<'tcx> {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n-}\n-\n-impl UnifyKey for ty::IntVid {\n-    type Value = Option<IntVarValue>;\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n-    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n-}\n-\n-impl<'tcx> ToType<'tcx> for IntVarValue {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n-            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n-        }\n-    }\n-}\n-\n-impl UnifyValue for Option<IntVarValue> { }\n-\n-// Floating point type keys\n-\n-impl UnifyKey for ty::FloatVid {\n-    type Value = Option<ast::FloatTy>;\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n-}\n-\n-impl UnifyValue for Option<ast::FloatTy> {\n-}\n-\n-impl<'tcx> ToType<'tcx> for ast::FloatTy {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_mach_float(tcx, *self)\n-    }\n-}", "previous_filename": "src/librustc/middle/infer/unify.rs"}, {"sha": "dbe3cfc7a48a9b2e7c7f749a1f7c5f0f7d77adcb", "filename": "src/librustc_data_structures/unify/test.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Funify%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_data_structures%2Funify%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftest.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+extern crate test;\n+use self::test::Bencher;\n+use std::collections::HashSet;\n+use unify::{UnifyKey, UnificationTable};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+struct UnitKey(u32);\n+\n+impl UnifyKey for UnitKey {\n+    type Value = ();\n+    fn index(&self) -> u32 { self.0 }\n+    fn from_index(u: u32) -> UnitKey { UnitKey(u) }\n+    fn tag(_: Option<UnitKey>) -> &'static str { \"UnitKey\" }\n+}\n+\n+#[test]\n+fn basic() {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let k1 = ut.new_key(());\n+    let k2 = ut.new_key(());\n+    assert_eq!(ut.unioned(k1, k2), false);\n+    ut.union(k1, k2);\n+    assert_eq!(ut.unioned(k1, k2), true);\n+}\n+\n+#[test]\n+fn big_array() {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let mut keys = Vec::new();\n+    const MAX: usize = 1 << 15;\n+\n+    for _ in 0..MAX {\n+        keys.push(ut.new_key(()));\n+    }\n+\n+    for i in 1..MAX {\n+        let l = keys[i-1];\n+        let r = keys[i];\n+        ut.union(l, r);\n+    }\n+\n+    for i in 0..MAX {\n+        assert!(ut.unioned(keys[0], keys[i]));\n+    }\n+}\n+\n+#[bench]\n+fn big_array_bench(b: &mut Bencher) {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let mut keys = Vec::new();\n+    const MAX: usize = 1 << 15;\n+\n+    for _ in 0..MAX {\n+        keys.push(ut.new_key(()));\n+    }\n+\n+\n+    b.iter(|| {\n+        for i in 1..MAX {\n+            let l = keys[i-1];\n+            let r = keys[i];\n+            ut.union(l, r);\n+        }\n+\n+        for i in 0..MAX {\n+            assert!(ut.unioned(keys[0], keys[i]));\n+        }\n+    })\n+}\n+\n+#[test]\n+fn even_odd() {\n+    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n+    let mut keys = Vec::new();\n+    const MAX: usize = 1 << 10;\n+\n+    for i in 0..MAX {\n+        let key = ut.new_key(());\n+        keys.push(key);\n+\n+        if i >= 2 {\n+            ut.union(key, keys[i-2]);\n+        }\n+    }\n+\n+    for i in 1..MAX {\n+        assert!(!ut.unioned(keys[i-1], keys[i]));\n+    }\n+\n+    for i in 2..MAX {\n+        assert!(ut.unioned(keys[i-2], keys[i]));\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+struct IntKey(u32);\n+\n+impl UnifyKey for IntKey {\n+    type Value = Option<i32>;\n+    fn index(&self) -> u32 { self.0 }\n+    fn from_index(u: u32) -> IntKey { IntKey(u) }\n+    fn tag(_: Option<IntKey>) -> &'static str { \"IntKey\" }\n+}\n+\n+/// Test unifying a key whose value is `Some(_)`  with a key whose value is `None`.\n+/// Afterwards both should be `Some(_)`.\n+#[test]\n+fn unify_key_Some_key_None() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(None);\n+    assert!(ut.unify_var_var(k1, k2).is_ok());\n+    assert_eq!(ut.probe(k2), Some(22));\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `None`  with a key whose value is `Some(_)`.\n+/// Afterwards both should be `Some(_)`.\n+#[test]\n+fn unify_key_None_key_Some() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(None);\n+    assert!(ut.unify_var_var(k2, k1).is_ok());\n+    assert_eq!(ut.probe(k2), Some(22));\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(y)`.\n+/// This should yield an error.\n+#[test]\n+fn unify_key_Some_x_key_Some_y() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(Some(23));\n+    assert_eq!(ut.unify_var_var(k1, k2), Err((22, 23)));\n+    assert_eq!(ut.unify_var_var(k2, k1), Err((23, 22)));\n+    assert_eq!(ut.probe(k1), Some(22));\n+    assert_eq!(ut.probe(k2), Some(23));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(x)`.\n+/// This should be ok.\n+#[test]\n+fn unify_key_Some_x_key_Some_x() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    let k2 = ut.new_key(Some(22));\n+    assert!(ut.unify_var_var(k1, k2).is_ok());\n+    assert_eq!(ut.probe(k1), Some(22));\n+    assert_eq!(ut.probe(k2), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `None` with a value is `x`.\n+/// Afterwards key should be `x`.\n+#[test]\n+fn unify_key_None_val() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(None);\n+    assert!(ut.unify_var_value(k1, 22).is_ok());\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with the value `y`.\n+/// This should yield an error.\n+#[test]\n+fn unify_key_Some_x_val_y() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    assert_eq!(ut.unify_var_value(k1, 23), Err((22, 23)));\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+\n+/// Test unifying a key whose value is `Some(x)` with the value `x`.\n+/// This should be ok.\n+#[test]\n+fn unify_key_Some_x_val_x() {\n+    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n+    let k1 = ut.new_key(Some(22));\n+    assert!(ut.unify_var_value(k1, 22).is_ok());\n+    assert_eq!(ut.probe(k1), Some(22));\n+}\n+"}, {"sha": "33a817cfedbb2225f025a84f58b04c341c113b8f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77213d1b28b307401d2bbb143168418bf7e6794c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=77213d1b28b307401d2bbb143168418bf7e6794c", "patch": "@@ -1886,14 +1886,13 @@ impl LintPass for UnconditionalRecursion {\n                 continue;\n             }\n             // add the successors of this node to explore the graph further.\n-            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n+            for (_, edge) in cfg.graph.outgoing_edges(idx) {\n                 let target_idx = edge.target();\n                 let target_cfg_id = target_idx.node_id();\n                 if !visited.contains(&target_cfg_id) {\n                     work_queue.push(target_idx)\n                 }\n-                true\n-            });\n+            }\n         }\n \n         // Check the number of self calls because a function that"}]}