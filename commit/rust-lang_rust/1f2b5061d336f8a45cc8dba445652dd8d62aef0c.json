{"sha": "1f2b5061d336f8a45cc8dba445652dd8d62aef0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMmI1MDYxZDMzNmY4YTQ1Y2M4ZGJhNDQ1NjUyZGQ4ZDYyYWVmMGM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-19T20:15:43Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-22T21:54:09Z"}, "message": "modernize code blocks", "tree": {"sha": "b61251f0b211742043b566431f80017cbb3f09dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b61251f0b211742043b566431f80017cbb3f09dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f2b5061d336f8a45cc8dba445652dd8d62aef0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f2b5061d336f8a45cc8dba445652dd8d62aef0c", "html_url": "https://github.com/rust-lang/rust/commit/1f2b5061d336f8a45cc8dba445652dd8d62aef0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f2b5061d336f8a45cc8dba445652dd8d62aef0c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47682f96de1da3bb0986e44e529cc51f24549c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/47682f96de1da3bb0986e44e529cc51f24549c86", "html_url": "https://github.com/rust-lang/rust/commit/47682f96de1da3bb0986e44e529cc51f24549c86"}], "stats": {"total": 524, "additions": 262, "deletions": 262}, "files": [{"sha": "170ccb53bf61bee4bc5a02d22c6ec3bc6e39ae21", "filename": "src/doc/reference.md", "status": "modified", "additions": 262, "deletions": 262, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/1f2b5061d336f8a45cc8dba445652dd8d62aef0c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/1f2b5061d336f8a45cc8dba445652dd8d62aef0c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=1f2b5061d336f8a45cc8dba445652dd8d62aef0c", "patch": "@@ -57,15 +57,15 @@ supported by common automated LL(k) parsing tools such as `llgen`, rather than\n the dialect given in ISO 14977. The dialect can be defined self-referentially\n as follows:\n \n-~~~~ {.ebnf .notation}\n+```{.ebnf .notation}\n grammar : rule + ;\n rule    : nonterminal ':' productionrule ';' ;\n productionrule : production [ '|' production ] * ;\n production : term * ;\n term : element repeats ;\n element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n-~~~~\n+```\n \n Where:\n \n@@ -152,12 +152,12 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n ## Comments\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n comment : block_comment | line_comment ;\n block_comment : \"/*\" block_comment_body * '*' + '/' ;\n block_comment_body : [block_comment | character] * ;\n line_comment : \"//\" non_eol * ;\n-~~~~\n+```\n \n Comments in Rust code follow the general C++ style of line and block-comment\n forms.  Nested block comments are supported.\n@@ -177,10 +177,10 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n whitespace : [ whitespace_char | comment ] + ;\n-~~~~\n+```\n \n The `whitespace_char` production is any nonempty Unicode string consisting of\n any of the following Unicode characters: `U+0020` (space, `' '`), `U+0009`\n@@ -194,10 +194,10 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n simple_token : keyword | unop | binop ;\n token : simple_token | ident | literal | symbol | whitespace token ;\n-~~~~\n+```\n \n Tokens are primitive productions in the grammar defined by regular\n (non-recursive) languages. \"Simple\" tokens are given in [string table\n@@ -208,7 +208,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n The keywords are the following strings:\n \n-~~~~ {.text .keyword}\n+```{.text .keyword}\n as\n box break\n continue crate\n@@ -223,7 +223,7 @@ self static struct super\n true trait type\n unsafe use\n while\n-~~~~\n+```\n \n Each of these keywords has special meaning in its grammar, and all of them are\n excluded from the `ident` rule.\n@@ -235,13 +235,13 @@ of tokens, that immediately and directly denotes the value it evaluates to,\n rather than referring to it by name or some other evaluation rule. A literal is\n a form of constant expression, so is evaluated (primarily) at compile time.\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n literal : string_lit | char_lit | byte_string_lit | byte_lit | num_lit ;\n-~~~~\n+```\n \n #### Character and string literals\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n char_lit : '\\x27' char_body '\\x27' ;\n string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n \n@@ -265,7 +265,7 @@ oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n dec_digit : '0' | nonzero_dec ;\n nonzero_dec: '1' | '2' | '3' | '4'\n            | '5' | '6' | '7' | '8' | '9' ;\n-~~~~\n+```\n \n A _character literal_ is a single Unicode character enclosed within two\n `U+0027` (single-quote) characters, with the exception of `U+0027` itself,\n@@ -310,7 +310,7 @@ many `U+0023` (`#`) characters as were used to start the raw string literal) or\n \n Examples for string literals:\n \n-~~~~\n+```\n \"foo\"; r\"foo\";                     // foo\n \"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n \n@@ -319,11 +319,11 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n \"\\x52\"; \"R\"; r\"R\";                 // R\n \"\\\\x52\"; r\"\\x52\";                  // \\x52\n-~~~~\n+```\n \n #### Byte and byte string literals\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n byte_lit : 'b' '\\x27' byte_body '\\x27' ;\n byte_string_lit : 'b' '\"' string_body * '\"' | 'b' 'r' raw_byte_string ;\n \n@@ -334,7 +334,7 @@ byte_string_body : ascii_non_double_quote\n             | '\\x5c' [ '\\x22' | common_escape ] ;\n raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n \n-~~~~\n+```\n \n A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n range) enclosed within two `U+0027` (single-quote) characters, with the\n@@ -377,7 +377,7 @@ many `U+0023` (`#`) characters as were used to start the raw string literal) or\n \n Examples for byte string literals:\n \n-~~~~\n+```\n b\"foo\"; br\"foo\";                     // foo\n b\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n \n@@ -386,11 +386,11 @@ br##\"foo #\"# bar\"##;                 // foo #\"# bar\n \n b\"\\x52\"; b\"R\"; br\"R\";                // R\n b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n-~~~~\n+```\n \n #### Number literals\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n         | '0' [       [ dec_digit | '_' ] * num_suffix ?\n               | 'b'   [ '1' | '0' | '_' ] + int_suffix ?\n@@ -407,7 +407,7 @@ float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ;\n float_suffix_ty : 'f' [ '3' '2' | '6' '4' ] ;\n exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n dec_lit : [ dec_digit | '_' ] + ;\n-~~~~\n+```\n \n A _number literal_ is either an _integer literal_ or a _floating-point\n literal_. The grammar for recognizing the two kinds of literals is mixed, as\n@@ -444,14 +444,14 @@ context overconstrains the type, it is also considered a static type error.\n \n Examples of integer literals of various forms:\n \n-~~~~\n+```\n 123i;                              // type int\n 123u;                              // type uint\n 123_u;                             // type uint\n 0xff_u8;                           // type u8\n 0o70_i16;                          // type i16\n 0b1111_1111_1001_0000_i32;         // type i32\n-~~~~\n+```\n \n ##### Floating-point literals\n \n@@ -471,12 +471,12 @@ types).\n \n Examples of floating-point literals of various forms:\n \n-~~~~\n+```\n 123.0f64;                          // type f64\n 0.1f64;                            // type f64\n 0.1f32;                            // type f32\n 12E+99_f64;                        // type f64\n-~~~~\n+```\n \n ##### Unit and boolean literals\n \n@@ -485,11 +485,11 @@ as `()`.  The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n symbol : \"::\" \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n-~~~~\n+```\n \n Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n@@ -500,15 +500,15 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n                | expr_path ;\n \n type_path : ident [ type_path_tail ] + ;\n type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n                | \"::\" type_path ;\n-~~~~\n+```\n \n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n@@ -521,10 +521,10 @@ crates; an item's canonical path merely identifies it within the crate.\n \n Two examples of simple paths consisting of only identifier components:\n \n-~~~~ {.ignore}\n+```{.ignore}\n x;\n x::y::z;\n-~~~~\n+```\n \n Path components are usually [identifiers](#identifiers), but the trailing\n component of a path may be an angle-bracket-enclosed list of type arguments. In\n@@ -535,14 +535,14 @@ the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n-~~~~\n+```\n # struct HashMap<K, V>;\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n type T = HashMap<int,String>;  // Type arguments used in a type expression\n let x = id::<int>(10);       // Type arguments used in a call expression\n # }\n-~~~~\n+```\n \n Paths can be denoted with various leading qualifiers to change the meaning of\n how it is resolved:\n@@ -608,7 +608,7 @@ All of the above extensions are expressions with values.\n \n ## Macros\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ;\n macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n matcher : '(' matcher * ')' | '[' matcher * ']'\n@@ -619,7 +619,7 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n             | '{' transcriber * '}' | '$' ident\n             | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n             | non_special_token ;\n-~~~~\n+```\n \n User-defined syntax extensions are called \"macros\", and the `macro_rules`\n syntax extension defines them.  Currently, user-defined macros can expand to\n@@ -731,7 +731,7 @@ may optionally begin with any number of `attributes` that apply to the\n containing module.  Attributes on the anonymous crate module define important\n metadata that influences the behavior of the compiler.\n \n-~~~~ {.rust}\n+```{.rust}\n # #![allow(unused_attribute)]\n // Crate ID\n #![crate_id = \"projx#2.5\"]\n@@ -746,7 +746,7 @@ metadata that influences the behavior of the compiler.\n \n // Turn on a warning\n #![warn(non_camel_case_types)]\n-~~~~\n+```\n \n A crate that contains a `main` function can be compiled to an executable.  If a\n `main` function is present, its return type must be [`unit`](#primitive-types)\n@@ -759,10 +759,10 @@ Crates contain [items](#items), each of which may have some number of\n \n ## Items\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n item : mod_item | fn_item | type_item | struct_item | enum_item\n      | static_item | trait_item | impl_item | extern_block ;\n-~~~~\n+```\n \n An _item_ is a component of a crate; some module items can be defined in crate\n files, but most are defined in source files. Items are organized within a crate\n@@ -809,10 +809,10 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n mod : [ view_item | item ] * ;\n-~~~~\n+```\n \n A module is a container for zero or more [view items](#view-items) and zero or\n more [items](#items). The view items manage the visibility of the items defined\n@@ -825,7 +825,7 @@ modules making up a crate. Modules can nest arbitrarily.\n \n An example of a module:\n \n-~~~~\n+```\n mod math {\n     type Complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n@@ -841,7 +841,7 @@ mod math {\n # fail!();\n     }\n }\n-~~~~\n+```\n \n Modules and types share the same namespace.  Declaring a named type that has\n the same name as a module in scope is forbidden: that is, a type definition,\n@@ -853,33 +853,33 @@ same name as the module, plus the `.rs` extension.  When a nested submodule is\n loaded from an external file, it is loaded from a subdirectory path that\n mirrors the module hierarchy.\n \n-~~~~ {.ignore}\n+```{.ignore}\n // Load the `vec` module from `vec.rs`\n mod vec;\n \n mod task {\n     // Load the `local_data` module from `task/local_data.rs`\n     mod local_data;\n }\n-~~~~\n+```\n \n The directories and files used for loading external file modules can be\n influenced with the `path` attribute.\n \n-~~~~ {.ignore}\n+```{.ignore}\n #[path = \"task_files\"]\n mod task {\n     // Load the `local_data` module from `task_files/tls.rs`\n     #[path = \"tls.rs\"]\n     mod local_data;\n }\n-~~~~\n+```\n \n #### View items\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n view_item : extern_crate_decl | use_decl ;\n-~~~~\n+```\n \n A view item manages the namespace of a module.  View items do not define new\n items, but rather, simply change other items' visibility.  There are several\n@@ -890,10 +890,10 @@ kinds of view item:\n \n ##### Extern crate declarations\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n extern_crate_decl : \"extern\" \"crate\" crate_name\n crate_name: ident | ( string_lit as ident )\n-~~~~\n+```\n \n An _`extern crate` declaration_ specifies a dependency on an external crate.\n The external crate is then bound into the declaring scope as the `ident`\n@@ -910,17 +910,17 @@ external crate when it was compiled.  If no `crateid` is provided, a default\n \n Four examples of `extern crate` declarations:\n \n-~~~~ {.ignore}\n+```{.ignore}\n extern crate pcre;\n \n extern crate std; // equivalent to: extern crate std as std;\n \n extern crate \"std\" as ruststd; // linking to 'std' under another name\n-~~~~\n+```\n \n ##### Use declarations\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n use_decl : \"pub\" ? \"use\" [ path \"as\" ident\n                           | path_glob ] ;\n \n@@ -929,7 +929,7 @@ path_glob : ident [ \"::\" [ path_glob\n           | '{' path_item [ ',' path_item ] * '}' ;\n \n path_item : ident | \"mod\" ;\n-~~~~\n+```\n \n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths).  Usually a `use` declaration is used to shorten the\n@@ -953,7 +953,7 @@ Use declarations support a number of convenient shortcuts:\n \n An example of `use` declarations:\n \n-~~~~\n+```\n use std::iter::range_step;\n use std::option::{Some, None};\n use std::collections::hashmap::{mod, HashMap};\n@@ -974,7 +974,7 @@ fn main() {\n     let set = hashmap::HashSet::new();\n     bar(map, set);\n }\n-~~~~\n+```\n \n Like items, `use` declarations are private to the containing module, by\n default.  Also like items, a `use` declaration can be public, if qualified by\n@@ -986,7 +986,7 @@ cannot be resolved unambiguously, they represent a compile-time error.\n \n An example of re-exporting:\n \n-~~~~\n+```\n # fn main() { }\n mod quux {\n     pub use quux::foo::{bar, baz};\n@@ -996,7 +996,7 @@ mod quux {\n         pub fn baz() { }\n     }\n }\n-~~~~\n+```\n \n In this example, the module `quux` re-exports two public names defined in\n `foo`.\n@@ -1013,7 +1013,7 @@ declarations.\n \n An example of what will and will not work for `use` items:\n \n-~~~~\n+```\n # #![allow(unused_imports)]\n use foo::native::start;  // good: foo is at the root of the crate\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n@@ -1037,7 +1037,7 @@ mod foo {\n }\n \n fn main() {}\n-~~~~\n+```\n \n ### Functions\n \n@@ -1060,18 +1060,18 @@ interpreted as an implicit `return` expression applied to the final-expression.\n \n An example of a function:\n \n-~~~~\n+```\n fn add(x: int, y: int) -> int {\n     return x + y;\n }\n-~~~~\n+```\n \n As with `let` bindings, function arguments are irrefutable patterns, so any\n pattern that is valid in a let binding is also valid as an argument.\n \n-~~~~\n+```\n fn first((value, _): (int, int)) -> int { value }\n-~~~~\n+```\n \n \n #### Generic functions\n@@ -1080,7 +1080,7 @@ A _generic function_ allows one or more _parameterized types_ to appear in its\n signature. Each type parameter must be explicitly declared, in an\n angle-bracket-enclosed, comma-separated list following the function name.\n \n-~~~~ {.ignore}\n+```{.ignore}\n fn iter<T>(seq: &[T], f: |T|) {\n     for elt in seq.iter() { f(elt); }\n }\n@@ -1089,7 +1089,7 @@ fn map<T, U>(seq: &[T], f: |T| -> U) -> Vec<U> {\n     for elt in seq.iter() { acc.push(f(elt)); }\n     acc\n }\n-~~~~\n+```\n \n Inside the function signature and body, the name of the type parameter can be\n used as a type name.\n@@ -1108,9 +1108,9 @@ Since a parameter type is opaque to the generic function, the set of operations\n that can be performed on it is limited. Values of parameter type can only be\n moved, not copied.\n \n-~~~~\n+```\n fn id<T>(x: T) -> T { x }\n-~~~~\n+```\n \n Similarly, [trait](#traits) bounds can be specified for type parameters to\n allow methods with that trait to be called on values of that type.\n@@ -1204,12 +1204,12 @@ be undesired.\n A special kind of function can be declared with a `!` character where the\n output slot type would normally be. For example:\n \n-~~~~\n+```\n fn my_err(s: &str) -> ! {\n     println!(\"{}\", s);\n     fail!();\n }\n-~~~~\n+```\n \n We call such functions \"diverging\" because they never return a value to the\n caller. Every control path in a diverging function must end with a `fail!()` or\n@@ -1224,7 +1224,7 @@ with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n were declared without the `!` annotation, the following code would not\n typecheck:\n \n-~~~~\n+```\n # fn my_err(s: &str) -> ! { fail!() }\n \n fn f(i: int) -> int {\n@@ -1235,7 +1235,7 @@ fn f(i: int) -> int {\n      my_err(\"Bad number!\");\n    }\n }\n-~~~~\n+```\n \n This will not compile without the `!` annotation on `my_err`, since the `else`\n branch of the conditional in `f` does not return an `int`, as required by the\n@@ -1254,21 +1254,21 @@ bodies defined in Rust code _can be called by foreign code_. They are defined\n in the same way as any other Rust function, except that they have the `extern`\n modifier.\n \n-~~~~\n+```\n // Declares an extern fn, the ABI defaults to \"C\"\n extern fn new_int() -> int { 0 }\n \n // Declares an extern fn with \"stdcall\" ABI\n extern \"stdcall\" fn new_int_stdcall() -> int { 0 }\n-~~~~\n+```\n \n Unlike normal functions, extern fns have an `extern \"ABI\" fn()`.  This is the\n same type as the functions declared in an extern block.\n \n-~~~~\n+```\n # extern fn new_int() -> int { 0 }\n let fptr: extern \"C\" fn() -> int = new_int;\n-~~~~\n+```\n \n Extern functions may be called directly from Rust code as Rust uses large,\n contiguous stack segments like C.\n@@ -1297,30 +1297,30 @@ keyword `struct`.\n \n An example of a `struct` item and its use:\n \n-~~~~\n+```\n struct Point {x: int, y: int}\n let p = Point {x: 10, y: 11};\n let px: int = p.x;\n-~~~~\n+```\n \n A _tuple structure_ is a nominal [tuple type](#tuple-types), also defined with\n the keyword `struct`.  For example:\n \n-~~~~\n+```\n struct Point(int, int);\n let p = Point(10, 11);\n let px: int = match p { Point(x, _) => x };\n-~~~~\n+```\n \n A _unit-like struct_ is a structure without any fields, defined by leaving off\n the list of fields entirely.  Such types will have a single value, just like\n the [unit value `()`](#unit-and-boolean-literals) of the unit type.  For\n example:\n \n-~~~~\n+```\n struct Cookie;\n let c = [Cookie, Cookie, Cookie, Cookie];\n-~~~~\n+```\n \n The precise memory layout of a structure is not specified. One can specify a\n particular layout using the [`repr` attribute](#ffi-attributes).\n@@ -1335,12 +1335,12 @@ initializers. Inheritance between structures does not give subtyping or\n coercion. The super-struct and sub-struct must be defined in the same crate.\n The super-struct must be declared using the `virtual` keyword.  For example:\n \n-~~~~ {.ignore}\n+```{.ignore}\n virtual struct Sup { x: int }\n struct Sub : Sup { y: int }\n let s = Sub {x: 10, y: 11};\n let sx = s.x;\n-~~~~\n+```\n \n ### Enumerations\n \n@@ -1352,19 +1352,19 @@ Enumerations are declared with the keyword `enum`.\n \n An example of an `enum` item and its use:\n \n-~~~~\n+```\n enum Animal {\n   Dog,\n   Cat\n }\n \n let mut a: Animal = Dog;\n a = Cat;\n-~~~~\n+```\n \n Enumeration constructors can have either named or unnamed fields:\n \n-~~~~\n+```\n # #![feature(struct_variant)]\n # fn main() {\n enum Animal {\n@@ -1375,16 +1375,16 @@ enum Animal {\n let mut a: Animal = Dog(\"Cocoa\".to_string(), 37.2);\n a = Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n # }\n-~~~~\n+```\n \n In this example, `Cat` is a _struct-like enum variant_,\n whereas `Dog` is simply called an enum variant.\n \n ### Static items\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n static_item : \"static\" ident ':' type '=' expr ';' ;\n-~~~~\n+```\n \n A *static item* is a named _constant value_ stored in the global data section\n of a crate.  Immutable static items are stored in the read-only data section.\n@@ -1400,7 +1400,7 @@ Static items must be explicitly typed.  The type may be ```bool```, ```char```,\n a number, or a type derived from those primitive types.  The derived types are\n references with the `static` lifetime, fixed-size arrays, tuples, and structs.\n \n-~~~~\n+```\n static BIT1: uint = 1 << 0;\n static BIT2: uint = 1 << 1;\n \n@@ -1416,7 +1416,7 @@ static bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n     mybits: BITS,\n     mystring: STRING\n };\n-~~~~\n+```\n \n #### Mutable statics\n \n@@ -1431,7 +1431,7 @@ running in the same process.\n Mutable statics are still very useful, however. They can be used with C\n libraries and can also be bound from C libraries (in an ```extern``` block).\n \n-~~~~\n+```\n # fn atomic_add(_: &mut uint, _: uint) -> uint { 2 }\n \n static mut LEVELS: uint = 0;\n@@ -1450,7 +1450,7 @@ unsafe fn bump_levels_unsafe1() -> uint {\n unsafe fn bump_levels_unsafe2() -> uint {\n     return atomic_add(&mut LEVELS, 1);\n }\n-~~~~\n+```\n \n ### Traits\n \n@@ -1463,14 +1463,14 @@ unspecified, or constrained by some other trait.\n Traits are implemented for specific types through separate\n [implementations](#implementations).\n \n-~~~~\n+```\n # type Surface = int;\n # type BoundingBox = int;\n trait Shape {\n     fn draw(&self, Surface);\n     fn bounding_box(&self) -> BoundingBox;\n }\n-~~~~\n+```\n \n This defines a trait with two methods.  All values that have\n [implementations](#implementations) of this trait in scope can have their\n@@ -1481,39 +1481,39 @@ Type parameters can be specified for a trait to make it generic.  These appear\n after the trait name, using the same syntax used in [generic\n functions](#generic-functions).\n \n-~~~~\n+```\n trait Seq<T> {\n    fn len(&self) -> uint;\n    fn elt_at(&self, n: uint) -> T;\n    fn iter(&self, |T|);\n }\n-~~~~\n+```\n \n Generic functions may use traits as _bounds_ on their type parameters.  This\n will have two effects: only types that have the trait may instantiate the\n parameter, and within the generic function, the methods of the trait can be\n called on values that have the parameter's type.  For example:\n \n-~~~~\n+```\n # type Surface = int;\n # trait Shape { fn draw(&self, Surface); }\n fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n     sh.draw(surface);\n     sh.draw(surface);\n }\n-~~~~\n+```\n \n Traits also define an [object type](#object-types) with the same name as the\n trait.  Values of this type are created by [casting](#type-cast-expressions)\n pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n \n-~~~~\n+```\n # trait Shape { }\n # impl Shape for int { }\n # let mycircle = 0i;\n let myshape: Box<Shape> = box mycircle as Box<Shape>;\n-~~~~\n+```\n \n The resulting value is a box containing the value that was cast, along with\n information that identifies the methods of the implementation that was used.\n@@ -1527,22 +1527,22 @@ not method call syntax (`obj.f()`).  The way to refer to the name of a static\n method is to qualify it with the trait name, treating the trait name like a\n module. For example:\n \n-~~~~\n+```\n trait Num {\n     fn from_int(n: int) -> Self;\n }\n impl Num for f64 {\n     fn from_int(n: int) -> f64 { n as f64 }\n }\n let x: f64 = Num::from_int(42);\n-~~~~\n+```\n \n Traits may inherit from other traits. For example, in\n \n-~~~~\n+```\n trait Shape { fn area() -> f64; }\n trait Circle : Shape { fn radius() -> f64; }\n-~~~~\n+```\n \n the syntax `Circle : Shape` means that types that implement `Circle` must also\n have an implementation for `Shape`.  Multiple supertraits are separated by `+`,\n@@ -1555,26 +1555,26 @@ In type-parameterized functions, methods of the supertrait may be called on\n values of subtrait-bound type parameters.  Referring to the previous example of\n `trait Circle : Shape`:\n \n-~~~~\n+```\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n fn radius_times_area<T: Circle>(c: T) -> f64 {\n     // `c` is both a Circle and a Shape\n     c.radius() * c.area()\n }\n-~~~~\n+```\n \n Likewise, supertrait methods may also be called on trait objects.\n \n-~~~~ {.ignore}\n+```{.ignore}\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # impl Shape for int { fn area(&self) -> f64 { 0.0 } }\n # impl Circle for int { fn radius(&self) -> f64 { 0.0 } }\n # let mycircle = 0;\n let mycircle = box mycircle as Box<Circle>;\n let nonsense = mycircle.radius() * mycircle.area();\n-~~~~\n+```\n \n ### Implementations\n \n@@ -1583,7 +1583,7 @@ specific type.\n \n Implementations are defined with the keyword `impl`.\n \n-~~~~\n+```\n # struct Point {x: f64, y: f64};\n # type Surface = int;\n # struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n@@ -1602,7 +1602,7 @@ impl Shape for Circle {\n          width: 2.0 * r, height: 2.0 * r}\n     }\n }\n-~~~~\n+```\n \n It is possible to define an implementation without referring to a trait.  The\n methods in such an implementation can only be used as direct calls on the\n@@ -1618,22 +1618,22 @@ An implementation can take type parameters, which can be different from the\n type parameters taken by the trait it implements.  Implementation parameters\n are written after the `impl` keyword.\n \n-~~~~\n+```\n # trait Seq<T> { }\n impl<T> Seq<T> for Vec<T> {\n    /* ... */\n }\n impl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n }\n-~~~~\n+```\n \n ### External blocks\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n extern_block_item : \"extern\" '{' extern_block '}' ;\n extern_block : [ foreign_fn ] * ;\n-~~~~\n+```\n \n External blocks form the basis for Rust's foreign function interface.\n Declarations in an external block describe symbols in external, non-Rust\n@@ -1643,15 +1643,15 @@ Functions within external blocks are declared in the same way as other Rust\n functions, with the exception that they may not have a body and are instead\n terminated by a semicolon.\n \n-~~~~\n+```\n extern crate libc;\n use libc::{c_char, FILE};\n \n extern {\n     fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n }\n # fn main() {}\n-~~~~\n+```\n \n Functions within external blocks may be called by Rust code, just like\n functions defined in Rust.  The Rust compiler automatically translates between\n@@ -1663,19 +1663,19 @@ By default external blocks assume that the library they are calling uses the\n standard C \"cdecl\" ABI.  Other ABIs may be specified using an `abi` string, as\n shown here:\n \n-~~~~ {.ignore}\n+```{.ignore}\n // Interface to the Windows API\n extern \"stdcall\" { }\n-~~~~\n+```\n \n The `link` attribute allows the name of the library to be specified. When\n specified the compiler will attempt to link against the native library of the\n specified name.\n \n-~~~~ {.ignore}\n+```{.ignore}\n #[link(name = \"crypto\")]\n extern { }\n-~~~~\n+```\n \n The type of a function declared in an extern block is `extern \"abi\" fn(A1, ...,\n An) -> R`, where `A1...An` are the declared types of its arguments and `R` is\n@@ -1702,7 +1702,7 @@ in a `pub` enum are also public by default. You are allowed to alter this\n default visibility with the `priv` keyword. When an item is declared as `pub`,\n it can be thought of as being accessible to the outside world. For example:\n \n-~~~~\n+```\n # fn main() {}\n // Declare a private struct\n struct Foo;\n@@ -1717,7 +1717,7 @@ pub enum State {\n     PubliclyAccessibleState,\n     PubliclyAccessibleState2,\n }\n-~~~~\n+```\n \n With the notion of an item being either public or private, Rust allows item\n accesses in two cases:\n@@ -1762,7 +1762,7 @@ scope.\n Here's an example of a program which exemplifies the three cases outlined\n above.\n \n-~~~~\n+```\n // This module is private, meaning that no external crate can access this\n // module. Because it is private at the root of this current crate, however, any\n // module in the crate may access any publicly visible item in this module.\n@@ -1810,7 +1810,7 @@ pub mod submodule {\n }\n \n # fn main() {}\n-~~~~\n+```\n \n For a rust program to pass the privacy checking pass, all paths must be valid\n accesses given the two rules above. This includes all use statements,\n@@ -1823,15 +1823,15 @@ this is a public directive, this allows the item to be used in the current\n module through the rules above. It essentially allows public access into the\n re-exported item. For example, this program is valid:\n \n-~~~~\n+```\n pub use self::implementation as api;\n \n mod implementation {\n     pub fn f() {}\n }\n \n # fn main() {}\n-~~~~\n+```\n \n This means that any external crate referencing `implementation::f` would\n receive a privacy violation, while the path `api::f` would be allowed.\n@@ -1852,12 +1852,12 @@ import public items from their destination, not private items.\n \n ## Attributes\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n attribute : '#' '!' ? '[' meta_item ']' ;\n meta_item : ident [ '=' literal\n                   | '(' meta_seq ')' ] ? ;\n meta_seq : meta_item [ ',' meta_seq ] ? ;\n-~~~~\n+```\n \n Any item declaration may have an _attribute_ applied to it. Attributes in Rust\n are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334\n@@ -1876,7 +1876,7 @@ apply to the item that follows the attribute.\n \n An example of attributes:\n \n-~~~~ {.rust}\n+```{.rust}\n // General metadata applied to the enclosing module or crate.\n #![license = \"BSD\"]\n \n@@ -1895,7 +1895,7 @@ mod bar {\n // A lint attribute used to suppress a warning/error\n #[allow(non_camel_case_types)]\n type int8_t = i8;\n-~~~~\n+```\n \n > **Note:** At some point in the future, the compiler will distinguish between\n > language-reserved and user-available attributes. Until then, there is\n@@ -2017,7 +2017,7 @@ There are two kinds of configuration options, one that is either defined or not\n against (`#[cfg(bar = \"baz\")]` (currently only compiler-defined configuration\n options can have the latter form).\n \n-~~~~\n+```\n // The function is only included in the build when compiling for OSX\n #[cfg(target_os = \"macos\")]\n fn macos_only() {\n@@ -2037,7 +2037,7 @@ fn needs_foo_or_bar() {\n fn on_32bit_unix() {\n   // ...\n }\n-~~~~\n+```\n \n This illustrates some conditional compilation can be achieved using the\n `#[cfg(...)]` attribute. Note that `#[cfg(foo, bar)]` is a condition that needs\n@@ -2081,7 +2081,7 @@ For any lint check `C`:\n The lint checks supported by the compiler can be found via `rustc -W help`,\n along with their default settings.\n \n-~~~~ {.ignore}\n+```{.ignore}\n mod m1 {\n     // Missing documentation is ignored here\n     #[allow(missing_doc)]\n@@ -2095,12 +2095,12 @@ mod m1 {\n     #[deny(missing_doc)]\n     pub fn undocumented_end() -> int { 3 }\n }\n-~~~~\n+```\n \n This example shows how one can use `allow` and `warn` to toggle a particular\n check on and off.\n \n-~~~~ {.ignore}\n+```{.ignore}\n #[warn(missing_doc)]\n mod m2{\n     #[allow(missing_doc)]\n@@ -2117,20 +2117,20 @@ mod m2{\n     // Missing documentation signals a warning here\n     pub fn undocumented_too() -> int { 3 }\n }\n-~~~~\n+```\n \n This example shows how one can use `forbid` to disallow uses of `allow` for\n that lint check.\n \n-~~~~ {.ignore}\n+```{.ignore}\n #[forbid(missing_doc)]\n mod m3 {\n     // Attempting to toggle warning signals an error here\n     #[allow(missing_doc)]\n     /// Returns 2.\n     pub fn undocumented_too() -> int { 2 }\n }\n-~~~~\n+```\n \n ### Language items\n \n@@ -2140,12 +2140,12 @@ operations have to be easy for the compiler to find.  The `lang` attribute\n makes it possible to declare these operations.  For example, the `str` module\n in the Rust standard library defines the string equality function:\n \n-~~~~ {.ignore}\n+```{.ignore}\n #[lang=\"str_eq\"]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     // details elided\n }\n-~~~~\n+```\n \n The name `str_eq` has a special meaning to the Rust compiler, and the presence\n of this definition means that it will use this definition when generating calls\n@@ -2325,17 +2325,17 @@ for data structures. For example, the following will create an `impl` for the\n `PartialEq` and `Clone` traits for `Foo`, the type parameter `T` will be given\n the `PartialEq` or `Clone` constraints for the appropriate `impl`:\n \n-~~~~\n+```\n #[deriving(PartialEq, Clone)]\n struct Foo<T> {\n     a: int,\n     b: T\n }\n-~~~~\n+```\n \n The generated `impl` for `PartialEq` is equivalent to\n \n-~~~~\n+```\n # struct Foo<T> { a: int, b: T }\n impl<T: PartialEq> PartialEq for Foo<T> {\n     fn eq(&self, other: &Foo<T>) -> bool {\n@@ -2346,7 +2346,7 @@ impl<T: PartialEq> PartialEq for Foo<T> {\n         self.a != other.a || self.b != other.b\n     }\n }\n-~~~~\n+```\n \n Supported traits for `deriving` are:\n \n@@ -2395,7 +2395,7 @@ displayed when the lint flags the use of an item.\n \n For example, if we define one crate called `stability_levels`:\n \n-~~~~ {.ignore}\n+```{.ignore}\n #[deprecated=\"replaced by `best`\"]\n pub fn bad() {\n     // delete everything\n@@ -2409,11 +2409,11 @@ pub fn better() {\n pub fn best() {\n     // delete nothing\n }\n-~~~~\n+```\n \n then the lints will work as follows for a client crate:\n \n-~~~~ {.ignore}\n+```{.ignore}\n #![warn(unstable)]\n extern crate stability_levels;\n use stability_levels::{bad, better, best};\n@@ -2425,7 +2425,7 @@ fn main() {\n \n     best(); // no warning\n }\n-~~~~\n+```\n \n > **Note:** Currently these are only checked when applied to individual\n > functions, structs, methods and enum variants, *not* to entire modules,\n@@ -2440,9 +2440,9 @@ considered a full-fledged language feature.\n \n For this reason, Rust recognizes a special crate-level attribute of the form:\n \n-~~~~ {.ignore}\n+```{.ignore}\n #![feature(feature1, feature2, feature3)]\n-~~~~\n+```\n \n This directive informs the compiler that the feature list: `feature1`,\n `feature2`, and `feature3` should all be enabled. This is only recognized at a\n@@ -2626,10 +2626,10 @@ in meaning to declaring the item outside the statement block.\n \n #### Slot declarations\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n-~~~~\n+```\n \n A _slot declaration_ introduces a new set of slots, given by a pattern.  The\n pattern may be followed by a type annotation, and/or an initializer expression.\n@@ -2701,12 +2701,12 @@ A _literal expression_ consists of one of the [literal](#literals) forms\n described earlier. It directly describes a number, character, string, boolean\n value, or the unit value.\n \n-~~~~ {.literals}\n+```{.literals}\n ();        // unit type\n \"hello\";   // string type\n '5';       // character type\n 5;         // integer type\n-~~~~\n+```\n \n ### Path expressions\n \n@@ -2718,22 +2718,22 @@ or an item.  Path expressions are [lvalues](#lvalues,-rvalues-and-temporaries).\n Tuples are written by enclosing one or more comma-separated expressions in\n parentheses. They are used to create [tuple-typed](#tuple-types) values.\n \n-~~~~ {.tuple}\n+```{.tuple}\n (0,);\n (0.0, 4.5);\n (\"a\", 4u, true);\n-~~~~\n+```\n \n ### Structure expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n struct_expr : expr_path '{' ident ':' expr\n                       [ ',' ident ':' expr ] *\n                       [ \"..\" expr ] '}' |\n               expr_path '(' expr\n                       [ ',' expr ] * ')' |\n               expr_path ;\n-~~~~\n+```\n \n There are several forms of structure expressions.  A _structure expression_\n consists of the [path](#paths) of a [structure item](#structures), followed by\n@@ -2754,7 +2754,7 @@ A _unit-like structure expression_ consists only of the [path](#paths) of a\n \n The following are examples of structure expressions:\n \n-~~~~\n+```\n # struct Point { x: f64, y: f64 }\n # struct TuplePoint(f64, f64);\n # mod game { pub struct User<'a> { pub name: &'a str, pub age: uint, pub score: uint } }\n@@ -2763,7 +2763,7 @@ Point {x: 10.0, y: 20.0};\n TuplePoint(10.0, 20.0);\n let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);\n-~~~~\n+```\n \n A structure expression forms a new value of the named structure type.  Note\n that for a given *unit-like* structure type, this will always be the same\n@@ -2777,19 +2777,19 @@ the same type as the base expression) with the given values for the fields that\n were explicitly specified and the values in the base expression for all other\n fields.\n \n-~~~~\n+```\n # struct Point3d { x: int, y: int, z: int }\n let base = Point3d {x: 1, y: 2, z: 3};\n Point3d {y: 0, z: 10, .. base};\n-~~~~\n+```\n \n ### Block expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n block_expr : '{' [ view_item ] *\n                  [ stmt ';' | item ] *\n                  [ expr ] '}' ;\n-~~~~\n+```\n \n A _block expression_ is similar to a module in terms of the declarations that\n are possible. Each block conceptually introduces a new namespace scope. View\n@@ -2803,9 +2803,9 @@ of the block are that of the expression itself.\n \n ### Method-call expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n method_call_expr : expr '.' ident paren_expr_list ;\n-~~~~\n+```\n \n A _method call_ consists of an expression followed by a single dot, an\n identifier, and a parenthesized expression-list.  Method calls are resolved to\n@@ -2815,20 +2815,20 @@ the left-hand-side expression is an indirect [object type](#object-types).\n \n ### Field expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n field_expr : expr '.' ident ;\n-~~~~\n+```\n \n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n (the latter is a [method call expression](#method-call-expressions)).  A field\n expression denotes a field of a [structure](#structure-types).\n \n-~~~~ {.ignore .field}\n+```{.ignore .field}\n mystruct.myfield;\n foo().x;\n (Struct {a: 10, b: 20}).a;\n-~~~~\n+```\n \n A field access is an [lvalue](#lvalues,-rvalues-and-temporaries) referring to\n the value of that field.  When the type providing the field inherits mutabilty,\n@@ -2839,11 +2839,11 @@ automatically dereferenced to make the field access possible.\n \n ### Array expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n array_expr : '[' \"mut\" ? vec_elems? ']' ;\n \n array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n-~~~~\n+```\n \n An [array](#vector,-array,-and-slice-types) _expression_ is written by\n enclosing zero or more comma-separated expressions of uniform type in square\n@@ -2853,18 +2853,18 @@ In the `[expr ',' \"..\" expr]` form, the expression after the `\"..\"` must be a\n constant expression that can be evaluated at compile time, such as a\n [literal](#literals) or a [static item](#static-items).\n \n-~~~~\n+```\n [1i, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n [0i, ..128];             // array with 128 zeros\n [0u8, 0u8, 0u8, 0u8];\n-~~~~\n+```\n \n ### Index expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n idx_expr : expr '[' expr ']' ;\n-~~~~\n+```\n \n [Array](#vector,-array,-and-slice-types)-typed expressions can be indexed by\n writing a square-bracket-enclosed expression (the index) after them. When the\n@@ -2875,15 +2875,15 @@ Indices are zero-based, and may be of any integral type. Vector access is\n bounds-checked at run-time. When the check fails, it will put the task in a\n _failing state_.\n \n-~~~~ {.ignore}\n+```{.ignore}\n # use std::task;\n # task::spawn(proc() {\n \n ([1, 2, 3, 4])[0];\n ([\"a\", \"b\"])[10]; // fails\n \n # })\n-~~~~\n+```\n \n ### Unary operator expressions\n \n@@ -2916,9 +2916,9 @@ operators, before the expression they apply to.\n \n ### Binary operator expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n binop_expr : expr binop expr ;\n-~~~~\n+```\n \n Binary operators expressions are given in terms of [operator\n precedence](#operator-precedence).\n@@ -3019,7 +3019,7 @@ unsupported and will fail to compile.\n \n An example of an `as` expression:\n \n-~~~~\n+```\n # fn sum(v: &[f64]) -> f64 { 0.0 }\n # fn len(v: &[f64]) -> int { 0 }\n \n@@ -3028,7 +3028,7 @@ fn avg(v: &[f64]) -> f64 {\n   let sz: f64 = len(v) as f64;\n   return sum / sz;\n }\n-~~~~\n+```\n \n #### Assignment expressions\n \n@@ -3040,12 +3040,12 @@ Evaluating an assignment expression [either copies or\n moves](#moved-and-copied-types) its right-hand operand to its left-hand\n operand.\n \n-~~~~\n+```\n # let mut x = 0i;\n # let y = 0;\n \n x = y;\n-~~~~\n+```\n \n #### Compound assignment expressions\n \n@@ -3060,7 +3060,7 @@ Any such expression always has the [`unit`](#primitive-types) type.\n The precedence of Rust binary operators is ordered as follows, going from\n strong to weak:\n \n-~~~~ {.text .precedence}\n+```{.text .precedence}\n * / %\n as\n + -\n@@ -3073,7 +3073,7 @@ as\n &&\n ||\n =\n-~~~~\n+```\n \n Operators at the same precedence level are evaluated left-to-right. [Unary\n operators](#unary-operator-expressions) have the same precedence level and it\n@@ -3085,24 +3085,24 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression.  Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n paren_expr : '(' expr ')' ;\n-~~~~\n+```\n \n An example of a parenthesized expression:\n \n-~~~~\n+```\n let x: int = (2 + 3) * 4;\n-~~~~\n+```\n \n \n ### Call expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n expr_list : [ expr [ ',' expr ]* ] ? ;\n paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n-~~~~\n+```\n \n A _call expression_ invokes a function, providing zero or more input slots and\n an optional reference slot to serve as the function's output, bound to the\n@@ -3111,20 +3111,20 @@ then the expression completes.\n \n Some examples of call expressions:\n \n-~~~~\n+```\n # use std::from_str::FromStr;\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n let pi: Option<f32> = FromStr::from_str(\"3.14\");\n-~~~~\n+```\n \n ### Lambda expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n ident_list : [ ident [ ',' ident ]* ] ? ;\n lambda_expr : '|' ident_list '|' expr ;\n-~~~~\n+```\n \n A _lambda expression_ (sometimes called an \"anonymous function expression\")\n defines a function and denotes it as a value, in a single expression.  A lambda\n@@ -3153,7 +3153,7 @@ expression's captured environment.\n In this example, we define a function `ten_times` that takes a higher-order\n function argument, and call it with a lambda expression as an argument.\n \n-~~~~\n+```\n fn ten_times(f: |int|) {\n     let mut i = 0;\n     while i < 10 {\n@@ -3163,13 +3163,13 @@ fn ten_times(f: |int|) {\n }\n \n ten_times(|j| println!(\"hello, {}\", j));\n-~~~~\n+```\n \n ### While loops\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n while_expr : \"while\" no_struct_literal_expr '{' block '}' ;\n-~~~~\n+```\n \n A `while` loop begins by evaluating the boolean loop conditional expression.\n If the loop conditional expression evaluates to `true`, the loop body block\n@@ -3178,22 +3178,22 @@ conditional expression evaluates to `false`, the `while` expression completes.\n \n An example:\n \n-~~~~\n+```\n let mut i = 0u;\n \n while i < 10 {\n     println!(\"hello\");\n     i = i + 1;\n }\n-~~~~\n+```\n \n ### Infinite loops\n \n A `loop` expression denotes an infinite loop.\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n-~~~~\n+```\n \n A `loop` expression may optionally have a _label_.  If a label is present, then\n labeled `break` and `continue` expressions nested within this loop may exit out\n@@ -3203,9 +3203,9 @@ expressions](#continue-expressions).\n \n ### Break expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n break_expr : \"break\" [ lifetime ];\n-~~~~\n+```\n \n A `break` expression has an optional _label_.  If the label is absent, then\n executing a `break` expression immediately terminates the innermost loop\n@@ -3215,9 +3215,9 @@ be the innermost label enclosing the `break` expression, but must enclose it.\n \n ### Continue expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n continue_expr : \"continue\" [ lifetime ];\n-~~~~\n+```\n \n A `continue` expression has an optional _label_.  If the label is absent, then\n executing a `continue` expression immediately terminates the current iteration\n@@ -3232,16 +3232,16 @@ A `continue` expression is only permitted in the body of a loop.\n \n ### For expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n-~~~~\n+```\n \n A `for` expression is a syntactic construct for looping over elements provided\n by an implementation of `std::iter::Iterator`.\n \n An example of a for loop over the contents of an array:\n \n-~~~~\n+```\n # type Foo = int;\n # fn bar(f: Foo) { }\n # let a = 0;\n@@ -3253,26 +3253,26 @@ let v: &[Foo] = &[a, b, c];\n for e in v.iter() {\n     bar(*e);\n }\n-~~~~\n+```\n \n An example of a for loop over a series of integers:\n \n-~~~~\n+```\n # fn bar(b:uint) { }\n for i in range(0u, 256) {\n     bar(i);\n }\n-~~~~\n+```\n \n ### If expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n if_expr : \"if\" no_struct_literal_expr '{' block '}'\n           else_tail ? ;\n \n else_tail : \"else\" [ if_expr\n                    | '{' block '}' ] ;\n-~~~~\n+```\n \n An `if` expression is a conditional branch in program control. The form of an\n `if` expression is a condition expression, followed by a consequent block, any\n@@ -3286,13 +3286,13 @@ if` condition is evaluated. If all `if` and `else if` conditions evaluate to\n \n ### Match expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n \n match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n \n match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n-~~~~\n+```\n \n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n@@ -3306,7 +3306,7 @@ In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n fields of a particular variant. For example:\n \n-~~~~\n+```\n enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n let x: List<int> = Cons(10, box Cons(11, box Nil));\n@@ -3316,7 +3316,7 @@ match x {\n     Cons(..)         => return,\n     Nil              => fail!(\"empty list\")\n }\n-~~~~\n+```\n \n The first pattern matches lists constructed by applying `Cons` to any head\n value, and a tail value of `box Nil`. The second pattern matches _any_ list\n@@ -3332,7 +3332,7 @@ specifically match elements that are at an unknown distance from both ends of a\n array, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n corresponding slice to the variable. Example:\n \n-~~~~\n+```\n # #![feature(advanced_slice_patterns)]\n fn is_symmetric(list: &[uint]) -> bool {\n     match list {\n@@ -3348,7 +3348,7 @@ fn main() {\n     assert!(is_symmetric(sym));\n     assert!(!is_symmetric(not_sym));\n }\n-~~~~\n+```\n \n A `match` behaves differently depending on whether or not the head expression\n is an [lvalue or an rvalue](#lvalues,-rvalues-and-temporaries).  If the head\n@@ -3366,7 +3366,7 @@ the inside of the match.\n \n An example of a `match` expression:\n \n-~~~~\n+```\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n \n@@ -3388,7 +3388,7 @@ match x {\n         fail!();\n     }\n }\n-~~~~\n+```\n \n Patterns that bind variables default to binding to a copy or move of the\n matched value (depending on the matched value's type).  This can be changed to\n@@ -3398,7 +3398,7 @@ bind to a reference by using the `ref` keyword, or to a mutable reference using\n Subpatterns can also be bound to variables by the use of the syntax `variable @\n subpattern`. For example:\n \n-~~~~\n+```\n enum List { Nil, Cons(uint, Box<List>) }\n \n fn is_sorted(list: &List) -> bool {\n@@ -3418,18 +3418,18 @@ fn main() {\n     assert!(is_sorted(&a));\n }\n \n-~~~~\n+```\n \n Patterns can also dereference pointers by using the `&`, `box` or `@` symbols,\n as appropriate. For example, these two matches on `x: &int` are equivalent:\n \n-~~~~\n+```\n # let x = &3i;\n let y = match *x { 0 => \"zero\", _ => \"some\" };\n let z = match x { &0 => \"zero\", _ => \"some\" };\n \n assert_eq!(y, z);\n-~~~~\n+```\n \n A pattern that's just an identifier, like `Nil` in the previous example, could\n either refer to an enum variant that's in scope, or bind a new variable.  The\n@@ -3444,15 +3444,15 @@ local variables with lower-case letters.\n Multiple match patterns may be joined with the `|` operator.  A range of values\n may be specified with `..`.  For example:\n \n-~~~~\n+```\n # let x = 2i;\n \n let message = match x {\n   0 | 1  => \"not many\",\n   2 .. 9 => \"a few\",\n   _      => \"lots\"\n };\n-~~~~\n+```\n \n Range patterns only work on scalar types (like integers and characters; not\n like arrays and structs, which have sub-components).  A range pattern may not\n@@ -3463,7 +3463,7 @@ criteria for matching a case. Pattern guards appear after the pattern and\n consist of a bool-typed expression following the `if` keyword. A pattern guard\n may refer to the variables bound within the pattern they follow.\n \n-~~~~\n+```\n # let maybe_digit = Some(0);\n # fn process_digit(i: int) { }\n # fn process_other(i: int) { }\n@@ -3473,13 +3473,13 @@ let message = match maybe_digit {\n   Some(x) => process_other(x),\n   None => fail!()\n };\n-~~~~\n+```\n \n ### Return expressions\n \n-~~~~ {.ebnf .gram}\n+```{.ebnf .gram}\n return_expr : \"return\" expr ? ;\n-~~~~\n+```\n \n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n expression moves its argument into the output slot of the current function,\n@@ -3488,14 +3488,14 @@ caller frame.\n \n An example of a `return` expression:\n \n-~~~~\n+```\n fn max(a: int, b: int) -> int {\n    if a > b {\n       return a;\n    }\n    return b;\n }\n-~~~~\n+```\n \n # Type system\n \n@@ -3584,12 +3584,12 @@ by the tuple type.\n \n An example of a tuple type and its use:\n \n-~~~~\n+```\n type Pair<'a> = (int, &'a str);\n let p: Pair<'static> = (10, \"hello\");\n let (a, b) = p;\n assert!(b != \"world\");\n-~~~~\n+```\n \n ### Vector, Array, and Slice types\n \n@@ -3694,14 +3694,14 @@ enclosing `enum` or `struct` type itself.  Such recursion has restrictions:\n \n An example of a *recursive* type and its use:\n \n-~~~~\n+```\n enum List<T> {\n   Nil,\n   Cons(T, Box<List<T>>)\n }\n \n let a: List<int> = Cons(7, box Cons(13, box Nil));\n-~~~~\n+```\n \n ### Pointer types\n \n@@ -3741,7 +3741,7 @@ or `extern`), a sequence of input types and an output type.\n \n An example of a `fn` type:\n \n-~~~~\n+```\n fn add(x: int, y: int) -> int {\n   return x + y;\n }\n@@ -3751,11 +3751,11 @@ let mut x = add(5,7);\n type Binop<'a> = |int,int|: 'a -> int;\n let bo: Binop = add;\n x = bo(5,7);\n-~~~~\n+```\n \n ### Closure types\n \n-~~~~ {.ebnf .notation}\n+```{.ebnf .notation}\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n@@ -3764,7 +3764,7 @@ lifetime-list := lifetime | lifetime ',' lifetime-list\n arg-list := ident ':' type | ident ':' type ',' arg-list\n bound-list := bound | bound '+' bound-list\n bound := path | lifetime\n-~~~~\n+```\n \n The type of a closure mapping an input of type `A` to an output of type `B` is\n `|A| -> B`. A closure with no arguments or return values has type `||`.\n@@ -3834,7 +3834,7 @@ implementation of `R`, and the pointer value of `E`.\n \n An example of an object type:\n \n-~~~~\n+```\n trait Printable {\n   fn stringify(&self) -> String;\n }\n@@ -3850,7 +3850,7 @@ fn print(a: Box<Printable>) {\n fn main() {\n    print(box 10i as Box<Printable>);\n }\n-~~~~\n+```\n \n In this example, the trait `Printable` occurs as an object type in both the\n type signature of `print`, and the cast expression in `main`.\n@@ -3860,7 +3860,7 @@ type signature of `print`, and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of\n its type parameters are types:\n \n-~~~~\n+```\n fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n     if xs.len() == 0 {\n        return vec![];\n@@ -3870,7 +3870,7 @@ fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n     rest.insert(0, first);\n     return rest;\n }\n-~~~~\n+```\n \n Here, `first` has type `B`, referring to `map`'s `B` type parameter; and `rest`\n has type `Vec<B>`, a vector type with element type `B`.\n@@ -3880,7 +3880,7 @@ has type `Vec<B>`, a vector type with element type `B`.\n The special type `self` has a meaning within methods inside an impl item. It\n refers to the type of the implicit `self` argument. For example, in:\n \n-~~~~\n+```\n trait Printable {\n   fn make_string(&self) -> String;\n }\n@@ -3890,7 +3890,7 @@ impl Printable for String {\n         (*self).clone()\n     }\n }\n-~~~~\n+```\n \n `self` refers to the value of type `String` that is the receiver for a call to\n the method `make_string`.\n@@ -4029,12 +4029,12 @@ variable `y`).\n Methods that take either `self` or `Box<Self>` can optionally place them in a\n mutable slot by prefixing them with `mut` (similar to regular arguments):\n \n-~~~\n+```\n trait Changer {\n     fn change(mut self) -> Self;\n     fn modify(mut self: Box<Self>) -> Box<Self>;\n }\n-~~~\n+```\n \n Local variables are not initialized when allocated; the entire frame worth of\n local variables are allocated at once, on frame-entry, in an uninitialized\n@@ -4050,21 +4050,21 @@ in use, the type of an owned box is `std::owned::Box<T>`.\n \n An example of an owned box type and value:\n \n-~~~~\n+```\n let x: Box<int> = box 10;\n-~~~~\n+```\n \n Owned box values exist in 1:1 correspondence with their heap allocation,\n copying an owned box value makes a shallow copy of the pointer.  Rust will\n consider a shallow copy of an owned box to move ownership of the value. After a\n value has been moved, the source location cannot be used unless it is\n reinitialized.\n \n-~~~~\n+```\n let x: Box<int> = box 10;\n let y = x;\n // attempting to use `x` will result in an error here\n-~~~~\n+```\n \n ## Tasks\n \n@@ -4349,7 +4349,7 @@ removed. In that case, to turn on logging for a program compiled from, e.g.\n Rust provides several macros to log information. Here's a simple Rust program\n that demonstrates all four of them:\n \n-~~~~\n+```\n #![feature(phase)]\n #[phase(plugin, link)] extern crate log;\n \n@@ -4359,7 +4359,7 @@ fn main() {\n     info!(\"this is an info log\")\n     debug!(\"This is a debug log\")\n }\n-~~~~\n+```\n \n These four log levels correspond to levels 1-4, as controlled by `RUST_LOG`:\n "}]}