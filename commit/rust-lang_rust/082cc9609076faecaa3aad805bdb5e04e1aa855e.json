{"sha": "082cc9609076faecaa3aad805bdb5e04e1aa855e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmNjOTYwOTA3NmZhZWNhYTNhYWQ4MDViZGI1ZTA0ZTFhYTg1NWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-14T22:12:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-14T22:12:40Z"}, "message": "Refine privacy error messages to be more accurate\n\nThis stops labeling everything as \"is private\" when in fact the destination may\nbe public. Instead, the clause \"is inaccessible\" is used and the private part of\nthe flag is called out with a \"is private\" message.\n\nCloses #9793", "tree": {"sha": "708259c1f1b8a23a0a95de4f309a656b77a42fe0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708259c1f1b8a23a0a95de4f309a656b77a42fe0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082cc9609076faecaa3aad805bdb5e04e1aa855e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082cc9609076faecaa3aad805bdb5e04e1aa855e", "html_url": "https://github.com/rust-lang/rust/commit/082cc9609076faecaa3aad805bdb5e04e1aa855e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082cc9609076faecaa3aad805bdb5e04e1aa855e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e77d5586aed50821e0b9361b2e24c96ade816c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e77d5586aed50821e0b9361b2e24c96ade816c", "html_url": "https://github.com/rust-lang/rust/commit/c8e77d5586aed50821e0b9361b2e24c96ade816c"}], "stats": {"total": 140, "additions": 95, "deletions": 45}, "files": [{"sha": "b8c432c3f26abc78c3abbd40e8083b4bdfc1ba3b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 83, "deletions": 38, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/082cc9609076faecaa3aad805bdb5e04e1aa855e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082cc9609076faecaa3aad805bdb5e04e1aa855e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=082cc9609076faecaa3aad805bdb5e04e1aa855e", "patch": "@@ -21,7 +21,7 @@ use middle::typeck::{method_static, method_object};\n \n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::is_local;\n+use syntax::ast_util::{is_local, def_id_of_def};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -250,6 +250,12 @@ struct PrivacyVisitor<'self> {\n     last_private_map: resolve::LastPrivateMap,\n }\n \n+enum PrivacyResult {\n+    Allowable,\n+    ExternallyDenied,\n+    DisallowedBy(ast::NodeId),\n+}\n+\n impl<'self> PrivacyVisitor<'self> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> ~str {\n@@ -258,11 +264,11 @@ impl<'self> PrivacyVisitor<'self> {\n \n     // Determines whether the given definition is public from the point of view\n     // of the current item.\n-    fn def_public(&self, did: ast::DefId) -> bool {\n+    fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n         if !is_local(did) {\n             if self.external_exports.contains(&did) {\n                 debug2!(\"privacy - {:?} was externally exported\", did);\n-                return true;\n+                return Allowable;\n             }\n             debug2!(\"privacy - is {:?} a public method\", did);\n             return match self.tcx.methods.find(&did) {\n@@ -271,38 +277,42 @@ impl<'self> PrivacyVisitor<'self> {\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n                             debug2!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_public(id)\n+                            self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug2!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_public(t.def_id)\n+                                    self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n                                     debug2!(\"privacy - found a method {:?}\",\n                                             meth.vis);\n-                                    meth.vis == ast::public\n+                                    if meth.vis == ast::public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n                 }\n                 None => {\n                     debug2!(\"privacy - nope, not even a method\");\n-                    false\n+                    ExternallyDenied\n                 }\n             };\n         } else if self.exported_items.contains(&did.node) {\n             debug2!(\"privacy - exported item {}\", self.nodestr(did.node));\n-            return true;\n+            return Allowable;\n         }\n \n         debug2!(\"privacy - local {:?} not public all the way down\", did);\n         // return quickly for things in the same module\n         if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n             debug2!(\"privacy - same parent, we're done here\");\n-            return true;\n+            return Allowable;\n         }\n \n         // We now know that there is at least one private member between the\n@@ -330,7 +340,11 @@ impl<'self> PrivacyVisitor<'self> {\n             assert!(closest_private_id != ast::DUMMY_NODE_ID);\n         }\n         debug2!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n-        return self.private_accessible(closest_private_id);\n+        if self.private_accessible(closest_private_id) {\n+            Allowable\n+        } else {\n+            DisallowedBy(closest_private_id)\n+        }\n     }\n \n     /// For a local private node in the AST, this function will determine\n@@ -365,12 +379,51 @@ impl<'self> PrivacyVisitor<'self> {\n         }\n     }\n \n+    /// Guarantee that a particular definition is public, possibly emitting an\n+    /// error message if it's not.\n+    fn ensure_public(&self, span: Span, to_check: ast::DefId,\n+                     source_did: Option<ast::DefId>, msg: &str) -> bool {\n+        match self.def_privacy(to_check) {\n+            ExternallyDenied => {\n+                self.tcx.sess.span_err(span, format!(\"{} is private\", msg))\n+            }\n+            DisallowedBy(id) => {\n+                if id == source_did.unwrap_or(to_check).node {\n+                    self.tcx.sess.span_err(span, format!(\"{} is private\", msg));\n+                    return false;\n+                } else {\n+                    self.tcx.sess.span_err(span, format!(\"{} is inaccessible\",\n+                                                         msg));\n+                }\n+                match self.tcx.items.find(&id) {\n+                    Some(&ast_map::node_item(item, _)) => {\n+                        let desc = match item.node {\n+                            ast::item_mod(*) => \"module\",\n+                            ast::item_trait(*) => \"trait\",\n+                            _ => return false,\n+                        };\n+                        let msg = format!(\"{} `{}` is private\", desc,\n+                                          token::ident_to_str(&item.ident));\n+                        self.tcx.sess.span_note(span, msg);\n+                    }\n+                    Some(*) | None => {}\n+                }\n+            }\n+            Allowable => return true\n+        }\n+        return false;\n+    }\n+\n     // Checks that a dereference of a univariant enum can occur.\n     fn check_variant(&self, span: Span, enum_id: ast::DefId) {\n         let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n-        if !self.def_public(variant_info.id) {\n-            self.tcx.sess.span_err(span, \"can only dereference enums \\\n-                                          with a single, public variant\");\n+\n+        match self.def_privacy(variant_info.id) {\n+            Allowable => {}\n+            ExternallyDenied | DisallowedBy(*) => {\n+                self.tcx.sess.span_err(span, \"can only dereference enums \\\n+                                              with a single, public variant\");\n+            }\n         }\n     }\n \n@@ -399,29 +452,24 @@ impl<'self> PrivacyVisitor<'self> {\n         let method_id = ty::method(self.tcx, method_id).provided_source\n                                                        .unwrap_or(method_id);\n \n-        if !self.def_public(method_id) {\n-            debug2!(\"private: {:?}\", method_id);\n-            self.tcx.sess.span_err(span, format!(\"method `{}` is private\",\n-                                                 token::ident_to_str(name)));\n-        }\n+        self.ensure_public(span, method_id, None,\n+                           format!(\"method `{}`\", token::ident_to_str(name)));\n     }\n \n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug2!(\"privacy - path {}\", self.nodestr(path_id));\n+        let def = self.tcx.def_map.get_copy(&path_id);\n         let ck = |tyname: &str| {\n-            let last_private = *self.last_private_map.get(&path_id);\n-            debug2!(\"privacy - {:?}\", last_private);\n-            let public = match last_private {\n-                resolve::AllPublic => true,\n-                resolve::DependsOn(def) => self.def_public(def),\n-            };\n-            if !public {\n-                debug2!(\"denying {:?}\", path);\n-                let name = token::ident_to_str(&path.segments.last()\n-                                                    .identifier);\n-                self.tcx.sess.span_err(span,\n-                                  format!(\"{} `{}` is private\", tyname, name));\n+            let origdid = def_id_of_def(def);\n+            match *self.last_private_map.get(&path_id) {\n+                resolve::AllPublic => {},\n+                resolve::DependsOn(def) => {\n+                    let name = token::ident_to_str(&path.segments.last()\n+                                                        .identifier);\n+                    self.ensure_public(span, def, Some(origdid),\n+                                       format!(\"{} `{}`\", tyname, name));\n+                }\n             }\n         };\n         match self.tcx.def_map.get_copy(&path_id) {\n@@ -456,9 +504,8 @@ impl<'self> PrivacyVisitor<'self> {\n                 method_num: method_num,\n                  _\n             }) => {\n-                if !self.def_public(trait_id) {\n-                    self.tcx.sess.span_err(span, \"source trait is private\");\n-                    return;\n+                if !self.ensure_public(span, trait_id, None, \"source trait\") {\n+                    return\n                 }\n                 match self.tcx.items.find(&trait_id.node) {\n                     Some(&ast_map::node_item(item, _)) => {\n@@ -470,12 +517,10 @@ impl<'self> PrivacyVisitor<'self> {\n                                             node: method.id,\n                                             crate: trait_id.crate,\n                                         };\n-                                        if self.def_public(def) { return }\n-                                        let msg = format!(\"method `{}` is \\\n-                                                           private\",\n+                                        self.ensure_public(span, def, None,\n+                                                  format!(\"method `{}`\",\n                                                           token::ident_to_str(\n-                                                              &method.ident));\n-                                        self.tcx.sess.span_err(span, msg);\n+                                                              &method.ident)));\n                                     }\n                                     ast::required(_) => {\n                                         // Required methods can't be private."}, {"sha": "859cbd8e50bd86fc23412b165cb7090453c2053d", "filename": "src/test/compile-fail/export-tag-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082cc9609076faecaa3aad805bdb5e04e1aa855e/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082cc9609076faecaa3aad805bdb5e04e1aa855e/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs?ref=082cc9609076faecaa3aad805bdb5e04e1aa855e", "patch": "@@ -14,4 +14,4 @@ mod foo {\n     enum y { y1, }\n }\n \n-fn main() { let z = foo::y1; } //~ ERROR: is private\n+fn main() { let z = foo::y1; } //~ ERROR: is inaccessible"}, {"sha": "a17e689f444ff7f2d6a9db6884e7e0d51d2fcd95", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/082cc9609076faecaa3aad805bdb5e04e1aa855e/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082cc9609076faecaa3aad805bdb5e04e1aa855e/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=082cc9609076faecaa3aad805bdb5e04e1aa855e", "patch": "@@ -100,11 +100,14 @@ mod foo {\n         ::bar::A::bar();        //~ ERROR: method `bar` is private\n         ::bar::A.foo2();\n         ::bar::A.bar2();        //~ ERROR: method `bar2` is private\n-        ::bar::baz::A::foo();   //~ ERROR: method `foo` is private\n+        ::bar::baz::A::foo();   //~ ERROR: method `foo` is inaccessible\n+                                //~^ NOTE: module `baz` is private\n         ::bar::baz::A::bar();   //~ ERROR: method `bar` is private\n-        ::bar::baz::A.foo2();   //~ ERROR: struct `A` is private\n-        ::bar::baz::A.bar2();   //~ ERROR: struct `A` is private\n+        ::bar::baz::A.foo2();   //~ ERROR: struct `A` is inaccessible\n+                                //~^ NOTE: module `baz` is private\n+        ::bar::baz::A.bar2();   //~ ERROR: struct `A` is inaccessible\n                                 //~^ ERROR: method `bar2` is private\n+                                //~^^ NOTE: module `baz` is private\n         ::lol();\n \n         ::bar::Priv; //~ ERROR: variant `Priv` is private\n@@ -120,13 +123,14 @@ mod foo {\n \n         ::bar::gpub();\n \n-        ::bar::baz::foo(); //~ ERROR: function `foo` is private\n+        ::bar::baz::foo(); //~ ERROR: function `foo` is inaccessible\n+                           //~^ NOTE: module `baz` is private\n         ::bar::baz::bar(); //~ ERROR: function `bar` is private\n     }\n \n     fn test2() {\n         use bar::baz::{foo, bar};\n-        //~^ ERROR: function `foo` is private\n+        //~^ ERROR: function `foo` is inaccessible\n         //~^^ ERROR: function `bar` is private\n         foo();\n         bar();\n@@ -155,7 +159,8 @@ pub mod mytest {\n     // external crates through `foo::foo`, it should not be accessible through\n     // its definition path (which has the private `i` module).\n     use self::foo::foo;\n-    use self::foo::i::A; //~ ERROR: type `A` is private\n+    use self::foo::i::A; //~ ERROR: type `A` is inaccessible\n+                         //~^ NOTE: module `i` is private\n \n     pub mod foo {\n         pub use foo = self::i::A;"}]}