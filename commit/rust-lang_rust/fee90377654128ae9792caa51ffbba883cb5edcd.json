{"sha": "fee90377654128ae9792caa51ffbba883cb5edcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZTkwMzc3NjU0MTI4YWU5NzkyY2FhNTFmZmJiYTg4M2NiNWVkY2Q=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-01T02:32:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-01T03:32:27Z"}, "message": "rustdoc: Refactor tests", "tree": {"sha": "bb8be4cf4e69de2bfc4a8ee091c563c92ba49d8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb8be4cf4e69de2bfc4a8ee091c563c92ba49d8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fee90377654128ae9792caa51ffbba883cb5edcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fee90377654128ae9792caa51ffbba883cb5edcd", "html_url": "https://github.com/rust-lang/rust/commit/fee90377654128ae9792caa51ffbba883cb5edcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fee90377654128ae9792caa51ffbba883cb5edcd/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "496205c85f9e0450535514472cd6fc47d5462415", "url": "https://api.github.com/repos/rust-lang/rust/commits/496205c85f9e0450535514472cd6fc47d5462415", "html_url": "https://github.com/rust-lang/rust/commit/496205c85f9e0450535514472cd6fc47d5462415"}], "stats": {"total": 776, "additions": 246, "deletions": 530}, "files": [{"sha": "4e0c85c8ac389872ec58e03118ee1cf332db216d", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 61, "deletions": 105, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -56,11 +56,7 @@ fn fold_crate(\n \n #[test]\n fn should_replace_top_module_name_with_crate_name() {\n-    let source = \"#[link(name = \\\"bond\\\")];\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_crate(fold, doc);\n+    let doc = test::mk_doc(\"#[link(name = \\\"bond\\\")];\");\n     assert doc.topmod.name == \"bond\";\n }\n \n@@ -106,22 +102,14 @@ fn fold_mod(fold: fold::fold<astsrv::srv>, doc: doc::moddoc) -> doc::moddoc {\n \n #[test]\n fn fold_mod_should_extract_mod_attributes() {\n-    let source = \"#[doc = \\\"test\\\"] mod a { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_mod(fold, doc.topmod.mods()[0]);\n-    assert doc.desc == some(\"test\");\n+    let doc = test::mk_doc(\"#[doc = \\\"test\\\"] mod a { }\");\n+    assert doc.topmod.mods()[0].desc == some(\"test\");\n }\n \n #[test]\n fn fold_mod_should_extract_top_mod_attributes() {\n-    let source = \"#[doc = \\\"test\\\"];\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_mod(fold, doc.topmod);\n-    assert doc.desc == some(\"test\");\n+    let doc = test::mk_doc(\"#[doc = \\\"test\\\"];\");\n+    assert doc.topmod.desc == some(\"test\");\n }\n \n fn fold_fn(\n@@ -182,22 +170,14 @@ fn merge_ret_attrs(\n \n #[test]\n fn fold_fn_should_extract_fn_attributes() {\n-    let source = \"#[doc = \\\"test\\\"] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_fn(fold, doc.topmod.fns()[0]);\n-    assert doc.desc == some(\"test\");\n+    let doc = test::mk_doc(\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n+    assert doc.topmod.fns()[0].desc == some(\"test\");\n }\n \n #[test]\n fn fold_fn_should_extract_arg_attributes() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_fn(fold, doc.topmod.fns()[0]);\n-    assert doc.args[0].desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\");\n+    assert doc.topmod.fns()[0].args[0].desc == some(\"b\");\n }\n \n #[test]\n@@ -224,12 +204,8 @@ fn fold_fn_should_preserve_sig() {\n \n #[test]\n fn fold_fn_should_extract_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"what\\\")] fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_fn(fold, doc.topmod.fns()[0]);\n-    assert doc.failure == some(\"what\");\n+    let doc = test::mk_doc(\"#[doc(failure = \\\"what\\\")] fn a() { }\");\n+    assert doc.topmod.fns()[0].failure == some(\"what\");\n }\n \n fn fold_const(\n@@ -248,14 +224,10 @@ fn fold_const(\n \n #[test]\n fn fold_const_should_extract_docs() {\n-    let source = \"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n-                  const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_const(fold, doc.topmod.consts()[0]);\n-    assert doc.brief == some(\"foo\");\n-    assert doc.desc == some(\"bar\");\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n+                            const a: bool = true;\");\n+    assert doc.topmod.consts()[0].brief == some(\"foo\");\n+    assert doc.topmod.consts()[0].desc == some(\"bar\");\n }\n \n fn fold_enum(\n@@ -296,24 +268,16 @@ fn fold_enum(\n \n #[test]\n fn fold_enum_should_extract_docs() {\n-    let source = \"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n-                  enum a { v }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_enum(fold, doc.topmod.enums()[0]);\n-    assert doc.brief == some(\"a\");\n-    assert doc.desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n+                            enum a { v }\");\n+    assert doc.topmod.enums()[0].brief == some(\"a\");\n+    assert doc.topmod.enums()[0].desc == some(\"b\");\n }\n \n #[test]\n fn fold_enum_should_extract_variant_docs() {\n-    let source = \"enum a { #[doc = \\\"c\\\"] v }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_enum(fold, doc.topmod.enums()[0]);\n-    assert doc.variants[0].desc == some(\"c\");\n+    let doc = test::mk_doc(\"enum a { #[doc = \\\"c\\\"] v }\");\n+    assert doc.topmod.enums()[0].variants[0].desc == some(\"c\");\n }\n \n fn fold_res(\n@@ -346,26 +310,18 @@ fn fold_res(\n \n #[test]\n fn fold_res_should_extract_docs() {\n-    let source = \"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n-                  resource r(b: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_res(fold, doc.topmod.resources()[0]);\n-    assert doc.brief == some(\"a\");\n-    assert doc.desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n+                            resource r(b: bool) { }\");\n+    assert doc.topmod.resources()[0].brief == some(\"a\");\n+    assert doc.topmod.resources()[0].desc == some(\"b\");\n }\n \n #[test]\n fn fold_res_should_extract_arg_docs() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))]\\\n-                  resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_res(fold, doc.topmod.resources()[0]);\n-    assert doc.args[0].name == \"a\";\n-    assert doc.args[0].desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))]\\\n+                            resource r(a: bool) { }\");\n+    assert doc.topmod.resources()[0].args[0].name == \"a\";\n+    assert doc.topmod.resources()[0].args[0].desc == some(\"b\");\n }\n \n fn fold_iface(\n@@ -427,27 +383,22 @@ fn merge_method_attrs(\n \n #[test]\n fn should_extract_iface_docs() {\n-    let source = \"#[doc = \\\"whatever\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"whatever\\\"] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].desc == some(\"whatever\");\n }\n \n #[test]\n fn should_extract_iface_method_docs() {\n-    let source = \"iface i {\\\n-                  #[doc(\\\n-                  brief = \\\"brief\\\",\\\n-                  desc = \\\"desc\\\",\\\n-                  args(a = \\\"a\\\"),\\\n-                  return = \\\"return\\\",\\\n-                  failure = \\\"failure\\\")]\\\n-                  fn f(a: bool) -> bool;\\\n-                  }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i {\\\n+         #[doc(\\\n+         brief = \\\"brief\\\",\\\n+         desc = \\\"desc\\\",\\\n+         args(a = \\\"a\\\"),\\\n+         return = \\\"return\\\",\\\n+         failure = \\\"failure\\\")]\\\n+         fn f(a: bool) -> bool;\\\n+         }\");\n     assert doc.topmod.ifaces()[0].methods[0].brief == some(\"brief\");\n     assert doc.topmod.ifaces()[0].methods[0].desc == some(\"desc\");\n     assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n@@ -474,30 +425,35 @@ fn fold_impl(\n \n #[test]\n fn should_extract_impl_docs() {\n-    let source = \"#[doc = \\\"whatever\\\"] impl i for int { fn a() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"whatever\\\"] impl i for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].desc == some(\"whatever\");\n }\n \n #[test]\n fn should_extract_impl_method_docs() {\n-    let source = \"impl i for int {\\\n-                  #[doc(\\\n-                  brief = \\\"brief\\\",\\\n-                  desc = \\\"desc\\\",\\\n-                  args(a = \\\"a\\\"),\\\n-                  return = \\\"return\\\",\\\n-                  failure = \\\"failure\\\")]\\\n-                  fn f(a: bool) -> bool { }\\\n-                  }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"impl i for int {\\\n+         #[doc(\\\n+         brief = \\\"brief\\\",\\\n+         desc = \\\"desc\\\",\\\n+         args(a = \\\"a\\\"),\\\n+         return = \\\"return\\\",\\\n+         failure = \\\"failure\\\")]\\\n+         fn f(a: bool) -> bool { }\\\n+         }\");\n     assert doc.topmod.impls()[0].methods[0].brief == some(\"brief\");\n     assert doc.topmod.impls()[0].methods[0].desc == some(\"desc\");\n     assert doc.topmod.impls()[0].methods[0].args[0].desc == some(\"a\");\n     assert doc.topmod.impls()[0].methods[0].return.desc == some(\"return\");\n     assert doc.topmod.impls()[0].methods[0].failure == some(\"failure\");\n }\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        run(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "ff561cf0a90029fd972f37e7fd2d6db448400ca8", "filename": "src/rustdoc/desc_pass.rs", "status": "modified", "additions": 30, "deletions": 65, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fdesc_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fdesc_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -128,130 +128,95 @@ fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n \n #[test]\n fn should_execute_op_on_enum_brief() {\n-    let source = \"#[doc(brief = \\\" a \\\")] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] enum a { b }\");\n     assert doc.topmod.enums()[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n-    let source = \"#[doc(desc = \\\" a \\\")] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] enum a { b }\");\n     assert doc.topmod.enums()[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_variant_desc() {\n-    let source = \"enum a { #[doc = \\\" a \\\"] b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"enum a { #[doc = \\\" a \\\"] b }\");\n     assert doc.topmod.enums()[0].variants[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_brief() {\n-    let source = \"#[doc(brief = \\\" a \\\")] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_desc() {\n-    let source = \"#[doc(desc = \\\" a \\\")] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_args() {\n-    let source = \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_brief() {\n-    let source = \"#[doc(brief = \\\" a \\\")] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(brief = \\\" a \\\")] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_desc() {\n-    let source = \"#[doc(desc = \\\" a \\\")] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(desc = \\\" a \\\")] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_brief() {\n-    let source = \"iface i { #[doc(brief = \\\" a \\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(brief = \\\" a \\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_desc() {\n-    let source = \"iface i { #[doc(desc = \\\" a \\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(desc = \\\" a \\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_args() {\n-    let source = \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\");\n     assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_return() {\n-    let source = \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_failure_condition() {\n-    let source = \"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].failure == some(\"a\");\n }\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        mk_pass(str::trim)(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "00d1d6ba14ae6a56e389a15f6fb1403531ecc68b", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -106,81 +106,64 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n \n #[test]\n fn should_promote_mod_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] mod m { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] mod m { }\");\n     assert doc.topmod.mods()[0].brief == some(\"desc\");\n     assert doc.topmod.mods()[0].desc == none;\n }\n \n #[test]\n fn should_promote_const_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] const a: bool = true;\");\n     assert doc.topmod.consts()[0].brief == some(\"desc\");\n     assert doc.topmod.consts()[0].desc == none;\n }\n \n #[test]\n fn should_promote_fn_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] fn a() { }\");\n     assert doc.topmod.fns()[0].brief == some(\"desc\");\n     assert doc.topmod.fns()[0].desc == none;\n }\n \n #[test]\n fn should_promote_enum_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] enum a { b }\");\n     assert doc.topmod.enums()[0].brief == some(\"desc\");\n     assert doc.topmod.enums()[0].desc == none;\n }\n \n #[test]\n fn should_promote_resource_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(desc = \\\"desc\\\")] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].brief == some(\"desc\");\n     assert doc.topmod.resources()[0].desc == none;\n }\n \n #[test]\n fn should_promote_iface_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].brief == some(\"desc\");\n     assert doc.topmod.ifaces()[0].desc == none;\n }\n \n #[test]\n fn should_promote_iface_method_desc() {\n-    let source = \"iface i { #[doc(desc = \\\"desc\\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { #[doc(desc = \\\"desc\\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].brief == some(\"desc\");\n     assert doc.topmod.ifaces()[0].methods[0].desc == none;\n }\n \n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        run(srv, doc)\n+    }\n+}\n+\n fn modify(\n     brief: option<str>,\n     desc: option<str>"}, {"sha": "a36536fd3e8d65b381e903faa9e81a6e634f3d9e", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 25, "deletions": 56, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -145,9 +145,7 @@ fn constdoc_from_const(\n \n #[test]\n fn should_extract_const_name_and_id() {\n-    let source = \"const a: int = 0;\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"const a: int = 0;\");\n     assert doc.topmod.consts()[0].id != 0;\n     assert doc.topmod.consts()[0].name == \"a\";\n }\n@@ -182,18 +180,14 @@ fn variantdoc_from_variant(variant: ast::variant) -> doc::variantdoc {\n \n #[test]\n fn should_extract_enums() {\n-    let source = \"enum e { v }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"enum e { v }\");\n     assert doc.topmod.enums()[0].id != 0;\n     assert doc.topmod.enums()[0].name == \"e\";\n }\n \n #[test]\n fn should_extract_enum_variants() {\n-    let source = \"enum e { v }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"enum e { v }\");\n     assert doc.topmod.enums()[0].variants[0].name == \"v\";\n }\n \n@@ -214,18 +208,14 @@ fn resdoc_from_resource(\n \n #[test]\n fn should_extract_resources() {\n-    let source = \"resource r(b: bool) { }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n     assert doc.topmod.resources()[0].id != 0;\n     assert doc.topmod.resources()[0].name == \"r\";\n }\n \n #[test]\n fn should_extract_resource_args() {\n-    let source = \"resource r(b: bool) { }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n     assert doc.topmod.resources()[0].args[0].name == \"b\";\n }\n \n@@ -258,25 +248,19 @@ fn ifacedoc_from_iface(\n \n #[test]\n fn should_extract_ifaces() {\n-    let source = \"iface i { fn f(); }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"iface i { fn f(); }\");\n     assert doc.topmod.ifaces()[0].name == \"i\";\n }\n \n #[test]\n fn should_extract_iface_methods() {\n-    let source = \"iface i { fn f(); }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"iface i { fn f(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].name == \"f\";\n }\n \n #[test]\n fn should_extract_iface_method_args() {\n-    let source = \"iface i { fn f(a: bool); }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"iface i { fn f(a: bool); }\");\n     assert doc.topmod.ifaces()[0].methods[0].args[0].name == \"a\";\n }\n \n@@ -311,90 +295,75 @@ fn impldoc_from_impl(\n \n #[test]\n fn should_extract_impls_with_names() {\n-    let source = \"impl i for int { fn a() { } }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].name == \"i\";\n }\n \n #[test]\n fn should_extract_impls_without_names() {\n-    let source = \"impl of i for int { fn a() { } }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"impl of i for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].name == \"i\";\n }\n \n #[test]\n fn should_extract_impl_methods() {\n-    let source = \"impl i for int { fn f() { } }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"impl i for int { fn f() { } }\");\n     assert doc.topmod.impls()[0].methods[0].name == \"f\";\n }\n \n #[test]\n fn should_extract_impl_method_args() {\n-    let source = \"impl i for int { fn f(a: bool) { } }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"impl i for int { fn f(a: bool) { } }\");\n     assert doc.topmod.impls()[0].methods[0].args[0].name == \"a\";\n }\n \n #[cfg(test)]\n-mod tests {\n+mod test {\n+\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let ast = parse::from_str(source);\n+        extract(ast, \"\")\n+    }\n \n     #[test]\n     fn extract_empty_crate() {\n-        let source = \"\"; // empty crate\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"\");\n         assert vec::is_empty(doc.topmod.mods());\n         assert vec::is_empty(doc.topmod.fns());\n     }\n \n     #[test]\n     fn extract_mods() {\n-        let source = \"mod a { mod b { } mod c { } }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"mod a { mod b { } mod c { } }\");\n         assert doc.topmod.mods()[0].name == \"a\";\n         assert doc.topmod.mods()[0].mods()[0].name == \"b\";\n         assert doc.topmod.mods()[0].mods()[1].name == \"c\";\n     }\n \n     #[test]\n     fn extract_mods_deep() {\n-        let source = \"mod a { mod b { mod c { } } }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"mod a { mod b { mod c { } } }\");\n         assert doc.topmod.mods()[0].mods()[0].mods()[0].name == \"c\";\n     }\n \n     #[test]\n     fn extract_should_set_mod_ast_id() {\n-        let source = \"mod a { }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"mod a { }\");\n         assert doc.topmod.mods()[0].id != 0;\n     }\n \n     #[test]\n     fn extract_fns() {\n-        let source =\n+        let doc = mk_doc(\n             \"fn a() { } \\\n-             mod b { fn c() { } }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+             mod b { fn c() { } }\");\n         assert doc.topmod.fns()[0].name == \"a\";\n         assert doc.topmod.mods()[0].fns()[0].name == \"c\";\n     }\n \n     #[test]\n     fn extract_should_set_fn_ast_id() {\n-        let source = \"fn a() { }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"fn a() { }\");\n         assert doc.topmod.fns()[0].id != 0;\n     }\n "}, {"sha": "c14eb2773bdd6beb6dee44425d668edabea3d40b", "filename": "src/rustdoc/prune_undoc_pass.rs", "status": "modified", "additions": 33, "deletions": 99, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fprune_undoc_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fprune_undoc_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -138,21 +138,13 @@ fn prune_return(doc: doc::retdoc) -> doc::retdoc {\n \n #[test]\n fn should_elide_undocumented_arguments() {\n-    let source = \"#[doc = \\\"hey\\\"] fn a(b: int) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n     assert vec::is_empty(doc.topmod.fns()[0].args);\n }\n \n #[test]\n fn should_not_elide_fns_with_documented_arguments() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\");\n     assert vec::is_not_empty(doc.topmod.fns());\n }\n \n@@ -169,49 +161,31 @@ fn should_elide_undocumented_return_values() {\n \n #[test]\n fn should_not_elide_fns_with_documented_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"yup\\\")] fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(failure = \\\"yup\\\")] fn a() { }\");\n     assert vec::is_not_empty(doc.topmod.fns());\n }\n \n #[test]\n fn should_elide_undocumented_mods() {\n-    let source = \"mod a { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { }\");\n     assert vec::is_empty(doc.topmod.mods());\n }\n \n #[test]\n fn should_not_elide_undocument_mods_with_documented_mods() {\n-    let source = \"mod a { #[doc = \\\"b\\\"] mod b { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] mod b { } }\");\n     assert vec::is_not_empty(doc.topmod.mods());\n }\n \n #[test]\n fn should_not_elide_undocument_mods_with_documented_fns() {\n-    let source = \"mod a { #[doc = \\\"b\\\"] fn b() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] fn b() { } }\");\n     assert vec::is_not_empty(doc.topmod.mods());\n }\n \n #[test]\n fn should_elide_undocumented_fns() {\n-    let source = \"fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() { }\");\n     assert vec::is_empty(doc.topmod.fns());\n }\n \n@@ -228,10 +202,7 @@ fn fold_const(\n \n #[test]\n fn should_elide_undocumented_consts() {\n-    let source = \"const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"const a: bool = true;\");\n     assert vec::is_empty(doc.topmod.consts());\n }\n \n@@ -255,31 +226,19 @@ fn fold_enum(fold: fold::fold<ctxt>, doc: doc::enumdoc) -> doc::enumdoc {\n \n #[test]\n fn should_elide_undocumented_enums() {\n-    let source = \"enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"enum a { b }\");\n     assert vec::is_empty(doc.topmod.enums());\n }\n \n #[test]\n fn should_elide_undocumented_variants() {\n-    let source = \"#[doc = \\\"a\\\"] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"a\\\"] enum a { b }\");\n     assert vec::is_empty(doc.topmod.enums()[0].variants);\n }\n \n #[test]\n fn should_not_elide_enums_with_documented_variants() {\n-    let source = \"enum a { #[doc = \\\"a\\\"] b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"enum a { #[doc = \\\"a\\\"] b }\");\n     assert vec::is_not_empty(doc.topmod.enums());\n }\n \n@@ -303,32 +262,21 @@ fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n \n #[test]\n fn should_elide_undocumented_resources() {\n-    let source = \"resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"resource r(a: bool) { }\");\n     assert vec::is_empty(doc.topmod.resources());\n }\n \n #[test]\n fn should_elide_undocumented_resource_args() {\n-    let source = \"#[doc = \\\"drunk\\\"]\\\n-                  resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n+                            resource r(a: bool) { }\");\n     assert vec::is_empty(doc.topmod.resources()[0].args);\n }\n \n #[test]\n fn should_not_elide_resources_with_documented_args() {\n-    let source = \"#[doc(args(a = \\\"drunk\\\"))]\\\n-                  resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"drunk\\\"))]\\\n+                            resource r(a: bool) { }\");\n     assert vec::is_not_empty(doc.topmod.resources());\n }\n \n@@ -364,60 +312,46 @@ fn fold_iface(\n \n #[test]\n fn should_elide_undocumented_ifaces() {\n-    let source = \"iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a(); }\");\n     assert vec::is_empty(doc.topmod.ifaces());\n }\n \n #[test]\n fn should_not_elide_documented_ifaces() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n     assert vec::is_not_empty(doc.topmod.ifaces());\n }\n \n #[test]\n fn should_not_elide_ifaces_with_documented_methods() {\n-    let source = \"iface i { #[doc = \\\"hey\\\"] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { #[doc = \\\"hey\\\"] fn a(); }\");\n     assert vec::is_not_empty(doc.topmod.ifaces());\n }\n \n #[test]\n fn should_not_elide_undocumented_methods() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n     assert vec::is_not_empty(doc.topmod.ifaces()[0].methods);\n }\n \n #[test]\n fn should_elide_undocumented_method_args() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n     assert vec::is_empty(doc.topmod.ifaces()[0].methods[0].args);\n }\n \n #[test]\n fn should_elide_undocumented_method_return_values() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n-}\n\\ No newline at end of file\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        run(srv, doc)\n+    }\n+}"}, {"sha": "94e7332e2ccd0a6dff397095853923a7b8859616", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 29, "deletions": 58, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -132,128 +132,99 @@ fn is_exported_from_crate(\n \n #[test]\n fn should_prune_unexported_fns() {\n-    let source = \"mod b { export a; fn a() { } fn b() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod b { export a; fn a() { } fn b() { } }\");\n     assert vec::len(doc.topmod.mods()[0].fns()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_fns_from_top_mod() {\n-    let source = \"export a; fn a() { } fn b() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; fn a() { } fn b() { }\");\n     assert vec::len(doc.topmod.fns()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_modules() {\n-    let source = \"mod a { export a; mod a { } mod b { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { export a; mod a { } mod b { } }\");\n     assert vec::len(doc.topmod.mods()[0].mods()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_modules_from_top_mod() {\n-    let source = \"export a; mod a { } mod b { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } mod b { }\");\n     assert vec::len(doc.topmod.mods()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_consts() {\n-    let source = \"mod a { export a; \\\n-                  const a: bool = true; \\\n-                  const b: bool = true; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"mod a { export a; \\\n+         const a: bool = true; \\\n+         const b: bool = true; }\");\n     assert vec::len(doc.topmod.mods()[0].consts()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_consts_from_top_mod() {\n-    let source = \"export a; const a: bool = true; const b: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"export a; const a: bool = true; const b: bool = true;\");\n     assert vec::len(doc.topmod.consts()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_enums_from_top_mod() {\n-    let source = \"export a; mod a { } enum b { c }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } enum b { c }\");\n     assert vec::len(doc.topmod.enums()) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_enums() {\n-    let source = \"mod a { export a; mod a { } enum b { c } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { export a; mod a { } enum b { c } }\");\n     assert vec::len(doc.topmod.mods()[0].enums()) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_variants_from_top_mod() {\n-    let source = \"export b::{}; enum b { c }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export b::{}; enum b { c }\");\n     assert vec::len(doc.topmod.enums()[0].variants) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_variants() {\n-    let source = \"mod a { export b::{}; enum b { c } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { export b::{}; enum b { c } }\");\n     assert vec::len(doc.topmod.mods()[0].enums()[0].variants) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_resources_from_top_mod() {\n-    let source = \"export a; mod a { } resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } resource r(a: bool) { }\");\n     assert vec::is_empty(doc.topmod.resources());\n }\n \n #[test]\n fn should_prune_unexported_resources() {\n-    let source = \"mod a { export a; mod a { } resource r(a: bool) { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"mod a { export a; mod a { } resource r(a: bool) { } }\");\n     assert vec::is_empty(doc.topmod.mods()[0].resources());\n }\n \n #[test]\n fn should_prune_unexported_ifaces_from_top_mod() {\n-    let source = \"export a; mod a { } iface b { fn c(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } iface b { fn c(); }\");\n     assert vec::is_empty(doc.topmod.ifaces());\n }\n \n #[test]\n fn should_prune_unexported_impls_from_top_mod() {\n-    let source = \"export a; mod a { } impl b for int { fn c() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"export a; mod a { } impl b for int { fn c() { } }\");\n     assert vec::is_empty(doc.topmod.impls())\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        run(srv, doc)\n+    }\n }\n\\ No newline at end of file"}, {"sha": "bec08afdbd2bd58997aa58fbf5226f18655aae1c", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -15,69 +15,55 @@ fn mk_pass() -> pass {\n \n #[test]\n fn should_trim_mod() {\n-    let source = \"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                  desc = \\\"\\ndesc\\n\\\")] \\\n-                  mod m { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n+                            desc = \\\"\\ndesc\\n\\\")] \\\n+                            mod m { }\");\n     assert doc.topmod.mods()[0].brief == some(\"brief\");\n     assert doc.topmod.mods()[0].desc == some(\"desc\");\n }\n \n #[test]\n fn should_trim_const() {\n-    let source = \"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                  desc = \\\"\\ndesc\\n\\\")] \\\n-                  const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n+                            desc = \\\"\\ndesc\\n\\\")] \\\n+                            const a: bool = true;\");\n     assert doc.topmod.consts()[0].brief == some(\"brief\");\n     assert doc.topmod.consts()[0].desc == some(\"desc\");\n }\n \n #[test]\n fn should_trim_fn() {\n-    let source = \"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                  desc = \\\"\\ndesc\\n\\\")] \\\n-                  fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n+                            desc = \\\"\\ndesc\\n\\\")] \\\n+                            fn a() { }\");\n     assert doc.topmod.fns()[0].brief == some(\"brief\");\n     assert doc.topmod.fns()[0].desc == some(\"desc\");\n }\n \n #[test]\n fn should_trim_args() {\n-    let source = \"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\");\n     assert doc.topmod.fns()[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_trim_ret() {\n-    let source = \"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\");\n     assert doc.topmod.fns()[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_trim_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\");\n     assert doc.topmod.fns()[0].failure == some(\"a\");\n }\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        mk_pass()(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "604e411dde072bc4c02081ae1f05fd3c55f7589d", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 28, "deletions": 76, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fee90377654128ae9792caa51ffbba883cb5edcd/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=fee90377654128ae9792caa51ffbba883cb5edcd", "patch": "@@ -60,10 +60,7 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n \n #[test]\n fn should_add_fn_sig() {\n-    let source = \"fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() -> int { }\");\n     assert doc.topmod.fns()[0].sig == some(\"fn a() -> int\");\n }\n \n@@ -107,19 +104,13 @@ fn ret_ty_to_str(decl: ast::fn_decl) -> option<str> {\n \n #[test]\n fn should_add_fn_ret_types() {\n-    let source = \"fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() -> int { }\");\n     assert doc.topmod.fns()[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_nil_ret_type() {\n-    let source = \"fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() { }\");\n     assert doc.topmod.fns()[0].return.ty == none;\n }\n \n@@ -165,10 +156,7 @@ fn decl_arg_tys(decl: ast::fn_decl) -> [(str, str)] {\n \n #[test]\n fn should_add_arg_types() {\n-    let source = \"fn a(b: int, c: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a(b: int, c: bool) { }\");\n     let fn_ = doc.topmod.fns()[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n@@ -199,10 +187,7 @@ fn fold_const(\n \n #[test]\n fn should_add_const_types() {\n-    let source = \"const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"const a: bool = true;\");\n     assert doc.topmod.consts()[0].ty == some(\"bool\");\n }\n \n@@ -241,10 +226,7 @@ fn fold_enum(\n \n #[test]\n fn should_add_variant_sigs() {\n-    let source = \"enum a { b(int) }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"enum a { b(int) }\");\n     assert doc.topmod.enums()[0].variants[0].sig == some(\"b(int)\");\n }\n \n@@ -272,19 +254,13 @@ fn fold_res(\n \n #[test]\n fn should_add_resource_sigs() {\n-    let source = \"resource r(b: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n     assert doc.topmod.resources()[0].sig == some(\"resource r(b: bool)\");\n }\n \n #[test]\n fn should_add_resource_arg_tys() {\n-    let source = \"resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].args[0].ty == some(\"bool\");\n }\n \n@@ -464,37 +440,25 @@ fn get_method_arg_tys(\n \n #[test]\n fn should_add_iface_method_sigs() {\n-    let source = \"iface i { fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].sig == some(\"fn a() -> int\");\n }\n \n #[test]\n fn should_add_iface_method_ret_types() {\n-    let source = \"iface i { fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_iface_method_nil_ret_type() {\n-    let source = \"iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n }\n \n #[test]\n fn should_add_iface_method_arg_types() {\n-    let source = \"iface i { fn a(b: int, c: bool); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a(b: int, c: bool); }\");\n     let fn_ = doc.topmod.ifaces()[0].methods[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n@@ -531,65 +495,53 @@ fn fold_impl(\n \n #[test]\n fn should_add_impl_iface_ty() {\n-    let source = \"impl i of j for int { fn a() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i of j for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].iface_ty == some(\"j\");\n }\n \n #[test]\n fn should_not_add_impl_iface_ty_if_none() {\n-    let source = \"impl i for int { fn a() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].iface_ty == none;\n }\n \n #[test]\n fn should_add_impl_self_ty() {\n-    let source = \"impl i for int { fn a() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].self_ty == some(\"int\");\n }\n \n #[test]\n fn should_add_impl_method_sigs() {\n-    let source = \"impl i for int { fn a() -> int { fail } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i for int { fn a() -> int { fail } }\");\n     assert doc.topmod.impls()[0].methods[0].sig == some(\"fn a() -> int\");\n }\n \n #[test]\n fn should_add_impl_method_ret_types() {\n-    let source = \"impl i for int { fn a() -> int { fail } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i for int { fn a() -> int { fail } }\");\n     assert doc.topmod.impls()[0].methods[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_impl_method_nil_ret_type() {\n-    let source = \"impl i for int { fn a() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n     assert doc.topmod.impls()[0].methods[0].return.ty == none;\n }\n \n #[test]\n fn should_add_impl_method_arg_types() {\n-    let source = \"impl i for int { fn a(b: int, c: bool) { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"impl i for int { fn a(b: int, c: bool) { } }\");\n     let fn_ = doc.topmod.impls()[0].methods[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n }\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        run(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}]}