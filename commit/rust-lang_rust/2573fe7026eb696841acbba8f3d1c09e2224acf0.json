{"sha": "2573fe7026eb696841acbba8f3d1c09e2224acf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NzNmZTcwMjZlYjY5Njg0MWFjYmJhOGYzZDFjMDllMjIyNGFjZjA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-13T02:01:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-24T22:34:34Z"}, "message": "The Big Test Suite Overhaul\n\nThis replaces the make-based test runner with a set of Rust-based test\nrunners. I believe that all existing functionality has been\npreserved. The primary objective is to dogfood the Rust test\nframework.\n\nA few main things happen here:\n\n1) The run-pass/lib-* tests are all moved into src/test/stdtest. This\nis a standalone test crate intended for all standard library tests. It\ncompiles to build/test/stdtest.stageN.\n\n2) rustc now compiles into yet another build artifact, this one a test\nrunner that runs any tests contained directly in the rustc crate. This\nallows much more fine-grained unit testing of the compiler. It\ncompiles to build/test/rustctest.stageN.\n\n3) There is a new custom test runner crate at src/test/compiletest\nthat reproduces all the functionality for running the compile-fail,\nrun-fail, run-pass and bench tests while integrating with Rust's test\nframework. It compiles to build/test/compiletest.stageN.\n\n4) The build rules have been completely changed to use the new test\nrunners, while also being less redundant, following the example of the\nrecent stageN.mk rewrite.\n\nIt adds two new features to the cfail/rfail/rpass/bench tests:\n\n1) Tests can specify multiple 'error-pattern' directives which must be\nsatisfied in order.\n\n2) Tests can specify a 'compile-flags' directive which will make the\ntest runner provide additional command line arguments to rustc.\n\nThere are some downsides, the primary being that Rust has to be\nfunctioning pretty well just to run _any_ tests, which I imagine will\nbe the source of some frustration when the entire test suite\nbreaks. Will also cause some headaches during porting.\n\nNot having individual make rules, each rpass, etc test no longer\nremembers between runs whether it completed successfully. As a result,\nit's not possible to incrementally fix multiple tests by just running\n'make check', fixing a test, and repeating without re-running all the\ntests contained in the test runner. Instead you can filter just the\ntests you want to run by using the TESTNAME environment variable.\n\nThis also dispenses with the ability to run stage0 tests, but they\ntended to be broken more often than not anyway.", "tree": {"sha": "f5b48d70a3130ad32f2fe1260ea992a49fc5a75b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5b48d70a3130ad32f2fe1260ea992a49fc5a75b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2573fe7026eb696841acbba8f3d1c09e2224acf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2573fe7026eb696841acbba8f3d1c09e2224acf0", "html_url": "https://github.com/rust-lang/rust/commit/2573fe7026eb696841acbba8f3d1c09e2224acf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2573fe7026eb696841acbba8f3d1c09e2224acf0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6e53aff6398f9d2c6851c25acfdedd0bf47a321", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e53aff6398f9d2c6851c25acfdedd0bf47a321", "html_url": "https://github.com/rust-lang/rust/commit/e6e53aff6398f9d2c6851c25acfdedd0bf47a321"}], "stats": {"total": 1700, "additions": 958, "deletions": 742}, "files": [{"sha": "60b33f3bf5de6eec160719ace130a91f60a6e633", "filename": "configure", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -182,8 +182,7 @@ for i in \\\n     rustllvm \\\n     dl stage0 stage1 stage2 stage3 \\\n     stage0/lib stage1/lib stage2/lib stage3/lib \\\n-    test/run-pass test/run-fail test/compile-fail \\\n-    test/bench/99-bottles test/bench/shootout test/bench/task-perf\n+    test/run-pass test/run-fail test/compile-fail test/bench\n do\n     make_dir $i\n done"}, {"sha": "6c3645fe85eda25130fbb33a655b48271bec1d93", "filename": "mk/clean.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -38,6 +38,7 @@ clean:\n \t$(Q)rm -f rt/$(CFG_RUNTIME)\n \t$(Q)rm -f rt/main.o\n \t$(Q)rm -f rt/main.ll\n+\t$(Q)rm -f test/run_pass_stage2.rc test/run_pass_stage2_driver.rs\n \t$(Q)rm -Rf $(PKG_NAME)-*.tar.gz dist\n \t$(Q)rm -f $(foreach ext,o a d bc s exe,$(wildcard stage*/*.$(ext)))\n \t$(Q)rm -Rf $(foreach ext,out out.tmp                      \\"}, {"sha": "a66afc3251ffc2a667bc0f6faf2838abad4df6d8", "filename": "mk/platform.mk", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -63,24 +63,27 @@ ifneq ($(findstring MINGW,$(CFG_OSTYPE)),)\n   CFG_WINDOWSY := 1\n endif\n \n-CFG_TESTLIB=$(CFG_BUILD_DIR)/$(strip     \\\n- $(if $(findstring stage0,$(1)),         \\\n-       stage0/lib,                           \\\n-      $(if $(findstring stage1,$(1)),    \\\n-           stage1/lib,                       \\\n-          $(if $(findstring stage2,$(1)),\\\n-               stage2/lib,                   \\\n-               ))))\n+CFG_TESTLIB=$(CFG_BUILD_DIR)/$(strip \\\n+ $(if $(findstring stage0,$(1)), \\\n+       stage0/lib, \\\n+      $(if $(findstring stage1,$(1)), \\\n+           stage1/lib, \\\n+          $(if $(findstring stage2,$(1)), \\\n+               stage2/lib, \\\n+               $(if $(findstring stage3,$(1)), \\\n+                    stage3/lib, \\\n+               )))))\n \n ifdef CFG_UNIXY\n   CFG_INFO := $(info cfg: unix-y environment)\n \n   CFG_PATH_MUNGE := true\n   CFG_EXE_SUFFIX :=\n-  CFG_RUN_TARG=$(CFG_LDENV)=$(CFG_BUILD_DIR)/$(1) $(2)\n-  CFG_RUN_TEST=\\\n-      $(CFG_LDENV)=$(call CFG_TESTLIB,$(1)) \\\n-      $(CFG_VALGRIND) $(1)\n+  CFG_LDPATH :=\n+  CFG_RUN=$(CFG_LDENV)=$(1) $(2)\n+  CFG_RUN_TARG=$(call CFG_RUN,$(CFG_BUILD_DIR)/$(1),$(2))\n+  CFG_RUN_TEST=$(call CFG_RUN,$(call CFG_TESTLIB,$(1)),\\\n+      $(CFG_VALGRIND) $(1))\n \n   ifdef CFG_ENABLE_MINGW_CROSS\n     CFG_WINDOWSY := 1\n@@ -117,8 +120,9 @@ ifdef CFG_WINDOWSY\n   CFG_DEF_SUFFIX := .def\n   CFG_LDPATH :=$(CFG_LLVM_BINDIR)\n   CFG_LDPATH :=$(CFG_LDPATH):$$PATH\n-  CFG_RUN_TEST=PATH=\"$(CFG_LDPATH):$(call CFG_TESTLIB,$(1))\" $(1)\n-  CFG_RUN_TARG=PATH=\"$(CFG_LDPATH)\" $(2)\n+  CFG_RUN=PATH=\"$(CFG_LDPATH):$(1)\" $(2)\n+  CFG_RUN_TARG=$(call CFG_RUN,,$(2))\n+  CFG_RUN_TEST=$(call CFG_RUN,$(call CFG_TESTLIB,$(1)),$(1))\n \n   ifndef CFG_ENABLE_MINGW_CROSS\n     CFG_PATH_MUNGE := $(strip perl -i.bak -p             \\"}, {"sha": "309b7d494232a60f8dd9b7d36d193fabe1ebcbb1", "filename": "mk/tests.mk", "status": "modified", "additions": 166, "deletions": 325, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -6,386 +6,227 @@ ALL_TEST_INPUTS = $(wildcard $(S)src/test/*/*.rs   \\\n                               $(S)src/test/*/*/*.rs \\\n                               $(S)src/test/*/*.rc)\n \n-ifneq ($(findstring check,$(MAKECMDGOALS)),)\n-XFAIL_INPUTS := $(shell grep -l xfail $(ALL_TEST_INPUTS))\n-TEST_XFAILS_STAGE0 := $(shell grep -l xfail-stage0 $(XFAIL_INPUTS))\n-TEST_XFAILS_STAGE1 := $(shell grep -l xfail-stage1 $(XFAIL_INPUTS))\n-TEST_XFAILS_STAGE2 := $(shell grep -l xfail-stage2 $(XFAIL_INPUTS))\n-\n-ifdef MINGW_CROSS\n-TEST_XFAILS_STAGE0 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE1 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE2 += $(S)src/test/run-pass/native-mod.rc\n-endif\n-ifdef CFG_WINDOWSY\n-TEST_XFAILS_STAGE0 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE1 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE2 += $(S)src/test/run-pass/native-mod.rc\n-endif\n-endif\n-\n-\n-BENCH_RS := $(wildcard $(S)src/test/bench/shootout/*.rs) \\\n-            $(wildcard $(S)src/test/bench/99-bottles/*.rs)\n+BENCH_RS := $(wildcard $(S)src/test/bench/*.rs) \\\n RPASS_RC := $(wildcard $(S)src/test/run-pass/*.rc)\n-RPASS_RS := $(wildcard $(S)src/test/run-pass/*.rs) $(BENCH_RS)\n+RPASS_RS := $(wildcard $(S)src/test/run-pass/*.rs)\n RFAIL_RC := $(wildcard $(S)src/test/run-fail/*.rc)\n RFAIL_RS := $(wildcard $(S)src/test/run-fail/*.rs)\n CFAIL_RC := $(wildcard $(S)src/test/compile-fail/*.rc)\n CFAIL_RS := $(wildcard $(S)src/test/compile-fail/*.rs)\n \n-ifdef CHECK_XFAILS\n-TEST_RPASS_CRATES_STAGE0 := $(filter $(TEST_XFAILS_STAGE0), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE1 := $(filter $(TEST_XFAILS_STAGE1), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE2 := $(filter $(TEST_XFAILS_STAGE2), $(RPASS_RC))\n-TEST_RPASS_SOURCES_STAGE0 := $(filter $(TEST_XFAILS_STAGE0), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE1 := $(filter $(TEST_XFAILS_STAGE1), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE2 := $(filter $(TEST_XFAILS_STAGE2), $(RPASS_RS))\n-else\n-TEST_RPASS_CRATES_STAGE0 := $(filter-out $(TEST_XFAILS_STAGE0), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE1), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE2), $(RPASS_RC))\n-TEST_RPASS_SOURCES_STAGE0 := $(filter-out $(TEST_XFAILS_STAGE0), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE1), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE2 := $(filter-out $(TEST_XFAILS_STAGE2), $(RPASS_RS))\n-endif\n-\n-TEST_RPASS_EXES_STAGE0 := \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE0:.rc=.stage0$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE0:.rs=.stage0$(X)))\n-TEST_RPASS_EXES_STAGE1 := \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE1:.rc=.stage1$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE1:.rs=.stage1$(X)))\n-TEST_RPASS_EXES_STAGE2 := \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE2:.rc=.stage2$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE2:.rs=.stage2$(X)))\n-\n-TEST_RPASS_OUTS_STAGE0 := \\\n-  $(TEST_RPASS_EXES_STAGE0:.stage0$(X)=.stage0.out)\n-TEST_RPASS_OUTS_STAGE1 := \\\n-  $(TEST_RPASS_EXES_STAGE1:.stage1$(X)=.stage1.out)\n-TEST_RPASS_OUTS_STAGE2 := \\\n-  $(TEST_RPASS_EXES_STAGE2:.stage2$(X)=.stage2.out)\n-\n-TEST_RPASS_TMPS_STAGE0 := \\\n-  $(TEST_RPASS_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n-TEST_RPASS_TMPS_STAGE1 := \\\n-  $(TEST_RPASS_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n-TEST_RPASS_TMPS_STAGE2 := \\\n-  $(TEST_RPASS_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n-\n-\n-TEST_RFAIL_CRATES_STAGE0 := $(filter-out $(TEST_XFAILS_STAGE0), $(RFAIL_RC))\n-TEST_RFAIL_CRATES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE1), $(RFAIL_RC))\n-TEST_RFAIL_CRATES_STAGE2 := $(filter-out $(TEST_XFAILS_STAGE2), $(RFAIL_RC))\n-TEST_RFAIL_SOURCES_STAGE0 := $(filter-out $(TEST_XFAILS_STAGE0), $(RFAIL_RS))\n-TEST_RFAIL_SOURCES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE1), $(RFAIL_RS))\n-TEST_RFAIL_SOURCES_STAGE2 := $(filter-out $(TEST_XFAILS_STAGE2), $(RFAIL_RS))\n-\n-TEST_RFAIL_EXES_STAGE0 := \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE0:.rc=.stage0$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE0:.rs=.stage0$(X)))\n-TEST_RFAIL_EXES_STAGE1 := \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE1:.rc=.stage1$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE1:.rs=.stage1$(X)))\n-TEST_RFAIL_EXES_STAGE2 := \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE2:.rc=.stage2$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE2:.rs=.stage2$(X)))\n-\n-TEST_RFAIL_OUTS_STAGE0 := \\\n-  $(TEST_RFAIL_EXES_STAGE0:.stage0$(X)=.stage0.out)\n-TEST_RFAIL_OUTS_STAGE1 := \\\n-  $(TEST_RFAIL_EXES_STAGE1:.stage1$(X)=.stage1.out)\n-TEST_RFAIL_OUTS_STAGE2 := \\\n-  $(TEST_RFAIL_EXES_STAGE2:.stage2$(X)=.stage2.out)\n-\n-\n-TEST_CFAIL_CRATES_STAGE0 := $(filter-out $(TEST_XFAILS_STAGE0), $(CFAIL_RC))\n-TEST_CFAIL_CRATES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE1), $(CFAIL_RC))\n-TEST_CFAIL_CRATES_STAGE2 := $(filter-out $(TEST_XFAILS_STAGE2), $(CFAIL_RC))\n-TEST_CFAIL_SOURCES_STAGE0 := $(filter-out $(TEST_XFAILS_STAGE0), $(CFAIL_RS))\n-TEST_CFAIL_SOURCES_STAGE1 := $(filter-out $(TEST_XFAILS_STAGE1), $(CFAIL_RS))\n-TEST_CFAIL_SOURCES_STAGE2 := $(filter-out $(TEST_XFAILS_STAGE2), $(CFAIL_RS))\n-\n-TEST_CFAIL_OUTS_STAGE0 := \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE0:.rc=.stage0.out)) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE0:.rs=.stage0.out))\n-TEST_CFAIL_OUTS_STAGE1 := \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE1:.rc=.stage1.out)) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE1:.rs=.stage1.out))\n-TEST_CFAIL_OUTS_STAGE2 := \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE2:.rc=.stage2.out)) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE2:.rs=.stage2.out))\n-\n-\n-ALL_TEST_CRATES := $(TEST_CFAIL_CRATES_STAGE0) \\\n-                   $(TEST_RFAIL_CRATES_STAGE0) \\\n-                   $(TEST_RPASS_CRATES_STAGE0) \\\n-                   $(TEST_CFAIL_CRATES_STAGE1) \\\n-                   $(TEST_RFAIL_CRATES_STAGE1) \\\n-                   $(TEST_RPASS_CRATES_STAGE1) \\\n-                   $(TEST_CFAIL_CRATES_STAGE2) \\\n-                   $(TEST_RFAIL_CRATES_STAGE2) \\\n-                   $(TEST_RPASS_CRATES_STAGE2)\n-\n-ALL_TEST_SOURCES := $(TEST_CFAIL_SOURCES_STAGE0) \\\n-                    $(TEST_RFAIL_SOURCES_STAGE0) \\\n-                    $(TEST_RPASS_SOURCES_STAGE0) \\\n-                    $(TEST_CFAIL_SOURCES_STAGE1) \\\n-                    $(TEST_RFAIL_SOURCES_STAGE1) \\\n-                    $(TEST_RPASS_SOURCES_STAGE1) \\\n-                    $(TEST_CFAIL_SOURCES_STAGE2) \\\n-                    $(TEST_RFAIL_SOURCES_STAGE2) \\\n-                    $(TEST_RPASS_SOURCES_STAGE2)\n+RPASS_TESTS := $(RPASS_RC) $(RPASS_RS)\n+RFAIL_TESTS := $(RFAIL_RC) $(RFAIL_RS)\n+CFAIL_TESTS := $(CFAIL_RC) $(CFAIL_RS)\n \n FT := run_pass_stage2\n FT_LIB := $(call CFG_LIB_NAME,$(FT))\n FT_DRIVER := $(FT)_driver\n GENERATED += test/$(FT).rc test/$(FT_DRIVER).rs\n \n+# The arguments to all test runners\n+ifdef TESTNAME\n+  TESTARGS += $(TESTNAME)\n+endif\n+\n+ifdef CHECK_XFAILS\n+  TESTARGS += --ignored\n+endif\n+\n+# Arguments to the cfail/rfail/rpass/bench tests\n+ifdef CFG_VALGRIND\n+  CTEST_RUNTOOL = --runtool \"$(CFG_VALGRIND)\"\n+endif\n \n-check-nocompile: $(TEST_CFAIL_OUTS_STAGE0) \\\n-                 $(TEST_CFAIL_OUTS_STAGE1) \\\n-                 $(TEST_CFAIL_OUTS_STAGE2)\n+CTEST_TESTARGS := $(TESTARGS)\n \n-check-stage0: tidy \\\n-       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n-       $(TEST_RPASS_OUTS_STAGE0) $(TEST_RFAIL_OUTS_STAGE0) \\\n-       $(TEST_CFAIL_OUTS_STAGE0) \\\n+ifdef VERBOSE\n+  CTEST_TESTARGS += --verbose\n+endif\n \n+# The test runner that runs the cfail/rfail/rpass and bench tests\n+COMPILETEST_CRATE := $(S)src/test/compiletest/compiletest.rc\n+COMPILETEST_INPUTS := $(wildcard $(S)src/test/compiletest/*rs)\n \n-check-stage1: tidy \\\n-       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n-       $(TEST_RPASS_OUTS_STAGE1) $(TEST_RFAIL_OUTS_STAGE1) \\\n-       $(TEST_CFAIL_OUTS_STAGE1) \\\n+# The standard library test crate\n+STDTEST_CRATE := $(S)src/test/stdtest/stdtest.rc\n+STDTEST_INPUTS := $(wildcard $(S)src/test/stdtest/*rs)\n \n \n-check-stage2: tidy \\\n-       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2) \\\n-       $(TEST_RPASS_OUTS_STAGE2) $(TEST_RFAIL_OUTS_STAGE2) \\\n-       $(TEST_CFAIL_OUTS_STAGE2) \\\n+######################################################################\n+# Main test targets\n+######################################################################\n+\n+check: tidy check-stage2 \\\n \n-check: tidy \\\n-       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2) \\\n-       $(TEST_RPASS_OUTS_STAGE2) $(TEST_RFAIL_OUTS_STAGE2) \\\n-       $(TEST_CFAIL_OUTS_STAGE2)\n+check-full: tidy check-stage1 check-stage2 check-stage3 \\\n \n check-fast: tidy \\\n-       test/$(FT_DRIVER).out\n+\tcheck-stage2-rustc check-stage2-std \\\n+\ttest/$(FT_DRIVER).out \\\n \n-check-full: tidy \\\n-       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n-       $(TEST_RPASS_OUTS_STAGE0) $(TEST_RFAIL_OUTS_STAGE0) \\\n-       $(TEST_CFAIL_OUTS_STAGE0) \\\n-       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n-       $(TEST_RPASS_OUTS_STAGE1) $(TEST_RFAIL_OUTS_STAGE1) \\\n-       $(TEST_CFAIL_OUTS_STAGE1) \\\n-       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2) \\\n-       $(TEST_RPASS_OUTS_STAGE2) $(TEST_RFAIL_OUTS_STAGE2) \\\n-       $(TEST_CFAIL_OUTS_STAGE2)\n+tidy:\n+\t@$(call E, check: formatting)\n+\t$(Q)echo \\\n+\t  $(filter-out $(GENERATED) $(addprefix $(S)src/, $(GENERATED)) \\\n+\t    $(addprefix $(S)src/, $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS) \\\n+\t      $(RUSTLLVM_HDR) $(PKG_3RDPARTY)) \\\n+\t    $(S)src/etc/%, $(PKG_FILES)) \\\n+\t  | xargs -n 10 python $(S)src/etc/tidy.py\n \n-check-compile: tidy \\\n-       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n-       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n-       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2)\n+# Cancel the implicit .out rule in GNU make\n+%.out: %\n \n+%.out: %.out.tmp\n+\t$(Q)mv $< $@\n \n \n ######################################################################\n-# Fast-test rules\n+# Rules for the test runners\n ######################################################################\n \n-test/$(FT).rc test/$(FT_DRIVER).rs: $(TEST_RPASS_SOURCES_STAGE2) \\\n-    $(S)src/etc/combine-tests.py\n-\t@$(call E, check: building combined stage2 test runner)\n-\t$(Q)$(S)src/etc/combine-tests.py\n+# StageN template: to stay consistent with stageN.mk, arge 2 is the\n+# stage being tested, arg 1 is stage N-1\n \n-stage2/lib/$(FT_LIB): test/$(FT).rc $(SREQ2)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE2) --lib -o $@ $<\n+define TEST_STAGEN\n \n-test/$(FT_DRIVER)$(X): test/$(FT_DRIVER).rs stage2/lib/$(FT_LIB) $(SREQ2)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE2) -o $@ $<\n+check-stage$(2): tidy \\\n+\tcheck-stage$(2)-rustc \\\n+\tcheck-stage$(2)-std \\\n+\tcheck-stage$(2)-rpass \\\n+\tcheck-stage$(2)-rfail \\\n+\tcheck-stage$(2)-cfail \\\n+\tcheck-stage$(2)-bench \\\n \n-test/$(FT_DRIVER).out: test/$(FT_DRIVER)$(X) $(SREQ2)\n-\t$(Q)$(call CFG_RUN_TEST, $<) | tee $@\n \n+# Rules for the standard library test runner\n \n-######################################################################\n-# Testing rules\n-######################################################################\n+check-stage$(2)-std: test/stdtest.stage$(2).out \\\n \n-tidy:\n-\t@$(call E, check: formatting)\n-\t$(Q)echo \\\n-      $(filter-out $(GENERATED) $(addprefix $(S)src/, $(GENERATED)) \\\n-        $(addprefix $(S)src/, $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS) \\\n-          $(RUSTLLVM_HDR) $(PKG_3RDPARTY)) \\\n-        $(S)src/etc/%, $(PKG_FILES)) \\\n-    | xargs -n 10 python $(S)src/etc/tidy.py\n+test/stdtest.stage$(2)$$(X): $$(STDTEST_CRATE) $$(STDTEST_INPUTS) \\\n+                             $$(SREQ$(2))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE1) -o $$@ $$< --test\n \n-%.stage0$(X): %.rs $(SREQ0)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE0) -o $@ $<\n+test/stdtest.stage$(2).out.tmp: test/stdtest.stage$(2)$$(X)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN_TEST,$$<) $$(TESTARGS)\n+\t$$(Q)touch $$@\n \n-%.stage0$(X): %.rc $(SREQ0)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE0) -o $@ $<\n \n-%.stage1$(X): %.rs $(SREQ1)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE1) -o $@ $<\n+# Rules for the rustc test runner\n \n-%.stage1$(X): %.rc $(SREQ1)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE1) -o $@ $<\n+check-stage$(2)-rustc: test/rustctest.stage$(2).out \\\n \n-%.stage2$(X): %.rs $(SREQ2)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE2) -o $@ $<\n+test/rustctest.stage$(2)$$(X): $$(COMPILER_CRATE) $$(COMPILER_INPUTS) \\\n+                           stage$(2)/$$(CFG_RUNTIME) \\\n+                           $$(call CFG_STDLIB_DEFAULT,stage$(1),stage$(2)) \\\n+                           stage$(2)/$$(CFG_RUSTLLVM) \\\n+                           $$(SREQ$(1))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)) -o $$@ $$< --test\n \n-%.stage2$(X): %.rc $(SREQ2)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE2) -o $@ $<\n+test/rustctest.stage$(2).out.tmp: test/rustctest.stage$(2)$$(X)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN,stage$(2),$$(CFG_VALGRIND) $$<) \\\n+\t  $$(TESTARGS)\n+\t$$(Q)touch $$@\n \n-# Cancel the implicit .out rule in GNU make.\n-%.out: %\n \n-%.out: %.out.tmp\n-\t$(Q)mv $< $@\n+# Rules for the cfail/rfail/rpass/bench test runner\n \n-test/run-pass/%.out.tmp: test/run-pass/%$(X) rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n-\n-test/bench/shootout/%.out.tmp: test/bench/shootout/%$(X) \\\n-                               rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n-\n-test/bench/99-bottles/%.out.tmp: test/bench/99-bottles/%$(X) \\\n-                                 rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n-\n-test/run-fail/%.out.tmp: test/run-fail/%$(X) \\\n-                         rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run-fail: $@)\n-\t$(Q)grep -q error-pattern $(S)src/test/run-fail/$(basename $*).rs\n-\t$(Q)rm -f $@\n-\t$(Q)$(call CFG_RUN_TEST, $<) >$@ 2>&1 ; X=$$? ; \\\n-      if [ $$X -eq 0 ] ; then exit 1 ; else exit 0 ; fi\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $(S)src/test/run-fail/$(basename $*).rs \\\n-        | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage0.out.tmp: test/compile-fail/%.rs $(SREQ0)\n-\t@$(call E, compile-fail [stage0]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE0) -c -o $(@:.o=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage1.out.tmp: test/compile-fail/%.rs $(SREQ1)\n-\t@$(call E, compile-fail [stage1]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE1) -c -o $(@:.o=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage2.out.tmp: test/compile-fail/%.rs $(SREQ2)\n-\t@$(call E, compile-fail [stage2]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE2) -c -o $(@:.o=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage0.out.tmp: test/compile-fail/%.rc $(SREQ0)\n-\t@$(call E, compile-fail [stage0]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE0) -c -o $(@:.o=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage1.out.tmp: test/compile-fail/%.rc $(SREQ1)\n-\t@$(call E, compile-fail [stage1]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE1) -c -o $(@:.o=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage2.out.tmp: test/compile-fail/%.rc $(SREQ2)\n-\t@$(call E, compile-fail [stage2]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE2) -c -o $(@:.o=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-# Testing the stdtest crate\n+check-stage$(2)-cfail: test/compile-fail.stage$(2).out \\\n \n-STDTEST_CRATE := $(S)src/test/stdtest/stdtest.rc\n-STDTEST_INPUTS := $(wildcard $(S)src/test/stdtest/*rs)\n+check-stage$(2)-rfail: test/run-fail.stage$(2).out \\\n \n-test/stdtest.stage1$(X): $(STDTEST_CRATE) $(STDTEST_INPUTS) $(SREQ1)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE1) -o $@ $< --test\n+check-stage$(2)-rpass: test/run-pass.stage$(2).out \\\n \n-test/stdtest.stage2$(X): $(STDTEST_CRATE) $(STDTEST_INPUTS) $(SREQ2)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE2) -o $@ $< --test\n+check-stage$(2)-bench: test/bench.stage$(2).out \\\n \n-test/stdtest.stage3$(X): $(STDTEST_CRATE) $(STDTEST_INPUTS) $(SREQ3)\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE3) -o $@ $< --test\n+CTEST_COMMON_ARGS$(2) := --compile-lib-path stage$(2) \\\n+                         --run-lib-path stage$(2)/lib \\\n+                         --rustc-path stage$(2)/rustc$$(X) \\\n+                         --stage-id stage$(2) \\\n+                         --rustcflags \"$$(CFG_RUSTC_FLAGS)\" \\\n+                         $$(CTEST_TESTARGS) \\\n \n-check-stage1-std:test/stdtest.stage1$(X)\n-\t@$(call E, run: $<)\n-\t$(Q)$(call CFG_RUN_TARG,stage1, $<)\n+CFAIL_ARGS$(2) := $$(CTEST_COMMON_ARGS$(2)) \\\n+                  --src-base $$(S)src/test/compile-fail/ \\\n+                  --build-base test/compile-fail/ \\\n+                  --mode compile-fail \\\n \n-check-stage2-std:test/stdtest.stage2$(X)\n-\t@$(call E, run: $<)\n-\t$(Q)$(call CFG_RUN_TARG,stage2, $<)\n+# FIXME (236): run-fail should run under valgrind once unwinding works\n+RFAIL_ARGS$(2) := $$(CTEST_COMMON_ARGS$(2)) \\\n+                  --src-base $$(S)src/test/run-fail/ \\\n+                  --build-base test/run-fail/ \\\n+                  --mode run-fail \\\n \n-check-stage3-std:test/stdtest.stage3$(X)\n-\t@$(call E, run: $<)\n-\t$(Q)$(call CFG_RUN_TARG,stage3, $<)\n+RPASS_ARGS$(2) := $$(CTEST_COMMON_ARGS$(2)) \\\n+                  --src-base $(S)src/test/run-pass/ \\\n+                  --build-base test/run-pass/ \\\n+                  --mode run-pass \\\n+                  $$(CTEST_RUNTOOL) \\\n \n-# Testing the rustctest crate\n+BENCH_ARGS$(2) := $$(CTEST_COMMON_ARGS$(2)) \\\n+                  --src-base $(S)src/test/bench/ \\\n+                  --build-base test/bench/ \\\n+                  --mode run-pass \\\n+                  $$(CTEST_RUNTOOL) \\\n \n-test/rustctest.stage1$(X): $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ0) \\\n-\tstage0/intrinsics.bc\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE0) -o $@ $< --test\n+test/compiletest.stage$(2)$$(X): $$(COMPILETEST_CRATE) \\\n+                                 $$(COMPILETEST_INPUTS) \\\n+                                 $$(SREQ$(2))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(2)) -o $$@ $$<\n \n-test/rustctest.stage2$(X): $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ1) \\\n-\tstage1/intrinsics.bc\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE1) -o $@ $< --test\n+test/compile-fail.stage$(2).out.tmp: test/compiletest.stage$(2)$$(X) \\\n+                                   $$(CFAIL_TESTS)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN_TEST,$$<) $$(CFAIL_ARGS$(2))\n+\t$$(Q)touch $$@\n \n-test/rustctest.stage3$(X): $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ2) \\\n-\tstage2/intrinsics.bc\n-\t@$(call E, compile_and_link: $@)\n-\t$(STAGE2) -o $@ $< --test\n+test/run-fail.stage$(2).out.tmp: test/compiletest.stage$(2)$$(X) \\\n+                               $$(RFAIL_TESTS)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN_TEST,$$<) $$(RFAIL_ARGS$(2))\n+\t$$(Q)touch $$@\n+\n+test/run-pass.stage$(2).out.tmp: test/compiletest.stage$(2)$$(X) \\\n+                               $$(RPASS_TESTS)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN_TEST,$$<) $$(RPASS_ARGS$(2))\n+\t$$(Q)touch $$@\n+\n+test/bench.stage$(2).out.tmp: test/compiletest.stage$(2)$$(X) \\\n+                            $$(BENCH_TESTS)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN_TEST,$$<) $$(BENCH_ARGS$(2))\n+\t$$(Q)touch $$@\n \n-check-stage1-rustc: test/rustctest.stage1$(X)\n-\t@$(call E, run: $<)\n-\t$(Q)$(call CFG_RUN_TARG,stage1, $<)\n+endef\n \n-check-stage2-rustc: test/rustctest.stage2$(X)\n-\t@$(call E, run: $<)\n-\t$(Q)$(call CFG_RUN_TARG,stage2, $<)\n+# Instantiate the template for stage 1, 2, 3\n \n-check-stage3-rustc: test/rustctest.stage3$(X)\n-\t@$(call E, run: $<)\n-\t$(Q)$(call CFG_RUN_TARG,stage2, $<)\n+$(eval $(call TEST_STAGEN,0,1))\n+$(eval $(call TEST_STAGEN,1,2))\n+$(eval $(call TEST_STAGEN,2,3))\n+\n+\n+######################################################################\n+# Fast-test rules\n+######################################################################\n+\n+test/$(FT).rc test/$(FT_DRIVER).rs: $(TEST_RPASS_SOURCES_STAGE2) \\\n+    $(S)src/etc/combine-tests.py\n+\t@$(call E, check: building combined stage2 test runner)\n+\t$(Q)$(S)src/etc/combine-tests.py\n+\n+stage2/lib/$(FT_LIB): test/$(FT).rc $(SREQ2)\n+\t@$(call E, compile_and_link: $@)\n+\t$(STAGE2) --lib -o $@ $<\n+\n+test/$(FT_DRIVER)$(X): test/$(FT_DRIVER).rs stage2/lib/$(FT_LIB) $(SREQ2)\n+\t@$(call E, compile_and_link: $@)\n+\t$(STAGE2) -o $@ $<\n+\n+test/$(FT_DRIVER).out: test/$(FT_DRIVER)$(X) $(SREQ2)\n+\t$(Q)$(call CFG_RUN_TEST, $<) | tee $@"}, {"sha": "37a2a2cb3e29cc4ea6eebf7b15e1f567aee1fc0a", "filename": "src/lib/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -14,6 +14,7 @@ export test_opts;\n export tr_ok;\n export tr_failed;\n export tr_ignored;\n+export run_tests_console;\n export run_test;\n export filter_tests;\n export parse_opts;\n@@ -51,7 +52,7 @@ fn test_main(&vec[str] args, &test_desc[] tests) {\n         either::left(?o) { o }\n         either::right(?m) { fail m }\n     };\n-    if (!run_tests(opts, tests)) {\n+    if (!run_tests_console(opts, tests)) {\n         fail \"Some tests failed\";\n     }\n }\n@@ -94,7 +95,7 @@ tag test_result {\n }\n \n // A simple console test runner\n-fn run_tests(&test_opts opts, &test_desc[] tests) -> bool {\n+fn run_tests_console(&test_opts opts, &test_desc[] tests) -> bool {\n \n     auto filtered_tests = filter_tests(opts, tests);\n "}, {"sha": "b077aac7b1911e32735759da64657c54af10f9af", "filename": "src/test/bench/99bob-iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/99-bottles/99bob-iter.rs"}, {"sha": "d4790d36d6e3f611ee8a32e1d7be85abe2c793ee", "filename": "src/test/bench/99bob-pattern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/99-bottles/99bob-pattern.rs"}, {"sha": "3135030d4d07ef6b6f62882e8cb7baa640c571e1", "filename": "src/test/bench/99bob-simple.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/99-bottles/99bob-simple.rs"}, {"sha": "d1612e2143d27982df283d16b0bb1e1cb7b5a15b", "filename": "src/test/bench/99bob-tail.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-tail.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/99-bottles/99bob-tail.rs"}, {"sha": "868cee4327f51142200074515bc881b5481d995d", "filename": "src/test/bench/shootout-ackermann.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/shootout/ackermann.rs"}, {"sha": "ebbcc69c9cce08a1ad8dd3877b96cc45490eab49", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/shootout/binarytrees.rs"}, {"sha": "02208a4845c0237037bcc56f3563c2c8727da193", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/shootout/fannkuchredux.rs"}, {"sha": "b6e43c813ca25bd053e307929351526f7330e228", "filename": "src/test/bench/shootout-fasta.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/shootout/fasta.rs"}, {"sha": "123035813225a0d302d91fd4e694582ce05543f6", "filename": "src/test/bench/shootout-fibo.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/shootout/fibo.rs"}, {"sha": "540be7c6c73f28e2adf57625a69566515e763ab8", "filename": "src/test/bench/shootout-nbody.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "previous_filename": "src/test/bench/shootout/nbody.rs"}, {"sha": "09dcf6ec71347a39671958a3d6450921ff2ae65f", "filename": "src/test/bench/shootout-pfib.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -90,9 +90,7 @@ fn stress(int num_tasks) {\n fn main(vec[str] argv) {\n     if(vec::len(argv) == 1u) {\n         assert (fib(8) == 21);\n-        assert (fib(15) == 610);\n         log fib(8);\n-        log fib(15);\n     }\n     else {\n         // Interactive mode! Wooo!!!!", "previous_filename": "src/test/bench/task-perf/pfib.rs"}, {"sha": "44197a9acdbf782c2527aa9c8657b97e0d71d1f7", "filename": "src/test/bench/shootout/pfib.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fpfib.rs?ref=e6e53aff6398f9d2c6851c25acfdedd0bf47a321", "patch": "@@ -1,69 +0,0 @@\n-// -*- rust -*-\n-\n-/*\n-  A parallel version of fibonacci numbers.\n-*/\n-\n-use std;\n-\n-import std::vec;\n-import std::uint;\n-import std::time;\n-import std::str;\n-\n-fn recv[T](&port[T] p) -> T {\n-    let T x;\n-    p |> x;\n-    ret x;\n-}\n-\n-fn fib(int n) -> int {\n-    fn pfib(chan[int] c, int n) {\n-        if (n == 0) {\n-            c <| 0;\n-        }\n-        else if (n <= 2) {\n-            c <| 1;\n-        }\n-        else {\n-            let port[int] p = port();\n-\n-            auto t1 = spawn pfib(chan(p), n - 1);\n-            auto t2 = spawn pfib(chan(p), n - 2);\n-\n-            c <| recv(p) + recv(p);\n-        }\n-    }\n-\n-    let port[int] p = port();\n-    auto t = spawn pfib(chan(p), n);\n-    ret recv(p);\n-}\n-\n-fn main(vec[str] argv) {\n-    if(vec::len(argv) == 1u) {\n-        assert (fib(8) == 21);\n-        //assert (fib(15) == 610);\n-        log fib(8);\n-        //log fib(15);\n-    }\n-    else {\n-        // Interactive mode! Wooo!!!!\n-\n-        auto n = uint::parse_buf(str::bytes(argv.(1)), 10u) as int;\n-        auto start = time::precise_time_ns();\n-        auto fibn = fib(n);\n-        auto stop = time::precise_time_ns();\n-\n-        assert(stop >= start);\n-\n-        auto elapsed = stop - start;\n-        auto us_task = elapsed / (fibn as u64) / (1000 as u64);\n-\n-        log_err #fmt(\"Determined that fib(%d) = %d in %d%d ns (%d us / task)\",\n-                     n, fibn,\n-                     (elapsed / (1000000 as u64)) as int,\n-                     (elapsed % (1000000 as u64)) as int,\n-                     us_task as int);\n-    }\n-}"}, {"sha": "e3cc3a3c409790b32df4fa8d8fcc6d973facace8", "filename": "src/test/bench/task-perf-word-count.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,3 +1,6 @@\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n /**\n    A parallel word-frequency counting program.\n ", "previous_filename": "src/test/bench/task-perf/word-count.rs"}, {"sha": "85714affba6e630767cda54c0d244b71df27f8f2", "filename": "src/test/compile-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern:expecting \\]\n+// error-pattern:expecting ]\n \n // asterisk is bogus\n #[attr*]"}, {"sha": "b22b35cf28e20f3a6a99b84f27cae3add24af70e", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern:\\^ cannot be applied to type `str`\n+// error-pattern:^ cannot be applied to type `str`\n \n fn main() {\n   auto x = \"a\" ^ \"b\";"}, {"sha": "e4a6f31e896e42fbe402b8444be189ba7a452f37", "filename": "src/test/compile-fail/binop-shift-port.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern:>> cannot be applied to type `port\\[int\\]`\n+// error-pattern:>> cannot be applied to type `port[int]`\n \n fn main() {\n   let port[int] p1 = port();"}, {"sha": "3b68b0879b5af14451d8c9139c1909c2532a9e64", "filename": "src/test/compile-fail/binop-sub-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern:\\- cannot be applied to type `obj\n+// error-pattern:- cannot be applied to type `obj\n \n fn main() {\n   auto x = obj(){} - obj(){};"}, {"sha": "446fb836717c676627d582a9df42807d45002f8a", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern:expecting \\[, found fmt\n+// error-pattern:expecting [, found fmt\n \n // Don't know how to deal with a syntax extension appearing after an\n // item attribute. Probably could use a better error message."}, {"sha": "10f7fc0e2424bd6b6a3a3270943451fba1466b20", "filename": "src/test/compile-fail/type-mismatch-multiple.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -0,0 +1,8 @@\n+// Checking that the compiler reports multiple type errors at once\n+// error-pattern:mismatched types: expected bool\n+// error-pattern:mismatched types: expected int\n+\n+fn main() {\n+    let bool a = 1;\n+    let int b = true;\n+}\n\\ No newline at end of file"}, {"sha": "8c3f0c305155429a1fb051ff9078897ad80ed617", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern:attempted field access on type vec\\[int\\]\n+// error-pattern:attempted field access on type vec[int]\n // issue #367\n \n fn f() {"}, {"sha": "b2c1f4662c24814fba9ee44468a23831483a8fee", "filename": "src/test/compiletest/compiletest.rc", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rc?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -0,0 +1,11 @@\n+use std;\n+\n+mod compiletest;\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "ae6f229fc81c74dd7ed7ec6e5e256b14276578e1", "filename": "src/test/compiletest/compiletest.rs", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -0,0 +1,529 @@\n+import std::option;\n+import std::getopts;\n+import std::test;\n+import std::fs;\n+import std::str;\n+import std::vec;\n+import std::ivec;\n+import std::io;\n+import std::generic_os::setenv;\n+import std::generic_os::getenv;\n+import std::os;\n+import std::run;\n+\n+tag mode {\n+    mode_compile_fail;\n+    mode_run_fail;\n+    mode_run_pass;\n+}\n+\n+type config = rec(// The library paths required for running the compiler\n+                  str compile_lib_path,\n+                  // The library paths required for running compiled programs\n+                  str run_lib_path,\n+                  // The rustc executable\n+                  str rustc_path,\n+                  // The directory containing the tests to run\n+                  str src_base,\n+                  // The directory where programs should be built\n+                  str build_base,\n+                  // The name of the stage being built (stage1, etc)\n+                  str stage_id,\n+                  // The test mode, compile-fail, run-fail, run-pass\n+                  mode mode,\n+                  // Run ignored tests\n+                  bool run_ignored,\n+                  // Only run tests that match this filter\n+                  option::t[str] filter,\n+                  // A command line to prefix program execution with,\n+                  // for running under valgrind\n+                  option::t[str] runtool,\n+                  // Flags to pass to the compiler\n+                  option::t[str] rustcflags,\n+                  // Explain what's going on\n+                  bool verbose);\n+\n+fn main(vec[str] args) {\n+\n+    auto ivec_args = {\n+        auto ivec_args = ~[];\n+        for (str arg in args) {\n+            ivec_args += ~[arg];\n+        }\n+        ivec_args\n+    };\n+\n+    auto config = parse_config(ivec_args);\n+    log_config(config);\n+    run_tests(config);\n+}\n+\n+fn parse_config(&str[] args) -> config {\n+    auto opts = ~[getopts::reqopt(\"compile-lib-path\"),\n+                  getopts::reqopt(\"run-lib-path\"),\n+                  getopts::reqopt(\"rustc-path\"),\n+                  getopts::reqopt(\"src-base\"),\n+                  getopts::reqopt(\"build-base\"),\n+                  getopts::reqopt(\"stage-id\"),\n+                  getopts::reqopt(\"mode\"),\n+                  getopts::optflag(\"ignored\"),\n+                  getopts::optopt(\"runtool\"),\n+                  getopts::optopt(\"rustcflags\"),\n+                  getopts::optflag(\"verbose\")];\n+\n+    check ivec::is_not_empty(args);\n+    auto args_ = ivec::tail(args);\n+    auto match = alt (getopts::getopts_ivec(args_, opts)) {\n+        getopts::success(?m) { m }\n+        getopts::failure(?f) {\n+            fail getopts::fail_str(f)\n+        }\n+    };\n+\n+    ret rec(compile_lib_path = getopts::opt_str(match, \"compile-lib-path\"),\n+            run_lib_path = getopts::opt_str(match, \"run-lib-path\"),\n+            rustc_path = getopts::opt_str(match, \"rustc-path\"),\n+            src_base = getopts::opt_str(match, \"src-base\"),\n+            build_base = getopts::opt_str(match, \"build-base\"),\n+            stage_id = getopts::opt_str(match, \"stage-id\"),\n+            mode = alt getopts::opt_str(match, \"mode\") {\n+                \"compile-fail\" { mode_compile_fail }\n+                \"run-fail\" { mode_run_fail }\n+                \"run-pass\" { mode_run_pass }\n+                _ { fail \"invalid mode\" }\n+            },\n+            run_ignored = getopts::opt_present(match, \"ignored\"),\n+            filter = if vec::len(match.free) > 0u {\n+                option::some(match.free.(0))\n+            } else {\n+                option::none\n+            },\n+            runtool = getopts::opt_maybe_str(match, \"runtool\"),\n+            rustcflags = getopts::opt_maybe_str(match, \"rustcflags\"),\n+            verbose = getopts::opt_present(match, \"verbose\"));\n+}\n+\n+fn log_config(&config config) {\n+    auto c = config;\n+    logv(c, #fmt(\"configuration:\"));\n+    logv(c, #fmt(\"compile_lib_path: %s\", config.compile_lib_path));\n+    logv(c, #fmt(\"run_lib_path: %s\", config.run_lib_path));\n+    logv(c, #fmt(\"rustc_path: %s\", config.rustc_path));\n+    logv(c, #fmt(\"src_base: %s\", config.src_base));;\n+    logv(c, #fmt(\"build_base: %s\", config.build_base));\n+    logv(c, #fmt(\"stage_id: %s\", config.stage_id));\n+    logv(c, #fmt(\"mode: %s\", mode_str(config.mode)));\n+    logv(c, #fmt(\"run_ignored: %b\", config.run_ignored));\n+    logv(c, #fmt(\"filter: %s\", alt (config.filter) {\n+      option::some(?f) { f }\n+      option::none { \"(none)\" }\n+    }));\n+    logv(c, #fmt(\"runtool: %s\", alt (config.runtool) {\n+      option::some(?s) { s }\n+      option::none { \"(none)\" }\n+    }));\n+    logv(c, #fmt(\"rustcflags: %s\", alt (config.rustcflags) {\n+      option::some(?s) { s }\n+      option::none { \"(none)\" }\n+    }));\n+    logv(c, #fmt(\"verbose: %b\", config.verbose));\n+    logv(c, #fmt(\"\\n\"));\n+}\n+\n+fn mode_str(mode mode) -> str {\n+    alt (mode) {\n+        mode_compile_fail { \"compile-fail\" }\n+        mode_run_fail { \"run-fail\" }\n+        mode_run_pass { \"run-pass\" }\n+    }\n+}\n+\n+fn run_tests(&config config) {\n+    auto opts = test_opts(config);\n+    auto tests = make_tests(config);\n+    test::run_tests_console(opts, tests);\n+}\n+\n+fn test_opts(&config config) -> test::test_opts {\n+    rec(filter = config.filter,\n+        run_ignored = config.run_ignored)\n+}\n+\n+fn make_tests(&config config) -> test::test_desc[] {\n+    log #fmt(\"making tests from %s\", config.src_base);\n+    auto tests = ~[];\n+    for (str file in fs::list_dir(config.src_base)) {\n+        log #fmt(\"inspecting file %s\", file);\n+        if (is_test(file)) {\n+            tests += ~[make_test(config, file)];\n+        }\n+    }\n+    ret tests;\n+}\n+\n+fn is_test(&str testfile) -> bool {\n+    str::ends_with(testfile, \".rs\") || str::ends_with(testfile, \".rc\")\n+}\n+\n+fn make_test(&config config, &str testfile) -> test::test_desc {\n+    rec(name = testfile,\n+        fn = make_test_fn(config, testfile),\n+        ignore = is_test_ignored(config, testfile))\n+}\n+\n+fn is_test_ignored(&config config, &str testfile) -> bool {\n+    auto found = false;\n+    for each (str ln in iter_header(testfile)) {\n+        // FIXME: Can't return or break from iterator\n+        found = found || parse_name_directive(ln, \"xfail-\" + config.stage_id);\n+    }\n+    ret found;\n+}\n+\n+iter iter_header(&str testfile) -> str {\n+    auto rdr = io::file_reader(testfile);\n+    while !rdr.eof() {\n+        auto ln = rdr.read_line();\n+        // Assume that any directives will be found before the\n+        // first module or function. This doesn't seem to be an optimization\n+        // with a warm page cache. Maybe with a cold one.\n+        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+            break;\n+        } else {\n+            put ln;\n+        }\n+    }\n+}\n+\n+fn make_test_fn(&config config, &str testfile) -> test::test_fn {\n+    bind run_test(config, testfile)\n+}\n+\n+fn run_test(config config, str testfile) {\n+    log #fmt(\"running %s\", testfile);\n+    auto props = load_props(testfile);\n+    alt (config.mode) {\n+        mode_compile_fail {\n+            run_cfail_test(config, props, testfile);\n+        }\n+        mode_run_fail {\n+            run_rfail_test(config, props, testfile);\n+        }\n+        mode_run_pass {\n+            run_rpass_test(config, props, testfile);\n+        }\n+    }\n+}\n+\n+type test_props = rec(str[] error_patterns,\n+                      option::t[str] compile_flags);\n+\n+// Load any test directives embedded in the file\n+fn load_props(&str testfile) -> test_props {\n+    auto error_patterns = ~[];\n+    auto compile_flags = option::none;\n+    for each (str ln in iter_header(testfile)) {\n+        alt parse_error_pattern(ln) {\n+          option::some(?ep) { error_patterns += ~[ep]; }\n+          option::none { }\n+        }\n+\n+        if option::is_none(compile_flags) {\n+            compile_flags = parse_compile_flags(ln);\n+        }\n+    }\n+    ret rec(error_patterns = error_patterns,\n+            compile_flags = compile_flags);\n+}\n+\n+fn parse_error_pattern(&str line) -> option::t[str] {\n+    parse_name_value_directive(line, \"error-pattern\")\n+}\n+\n+fn parse_compile_flags(&str line) -> option::t[str] {\n+    parse_name_value_directive(line, \"compile-flags\")\n+}\n+\n+fn parse_name_directive(&str line, &str directive) -> bool {\n+    str::find(line, directive) >= 0\n+}\n+\n+fn parse_name_value_directive(&str line, &str directive) -> option::t[str] {\n+    auto keycolon = directive + \":\";\n+    if str::find(line, keycolon) >= 0 {\n+        auto colon = str::find(line, keycolon) as uint;\n+        auto value = str::slice(line,\n+                                colon + str::byte_len(keycolon),\n+                                str::byte_len(line));\n+        log #fmt(\"%s: %s\", directive, value);\n+        option::some(value)\n+    } else {\n+        option::none\n+    }\n+}\n+\n+fn run_cfail_test(&config config, &test_props props, &str testfile) {\n+    auto procres = compile_test(config, props, testfile);\n+\n+    if (procres.status == 0) {\n+        fatal_procres(\"compile-fail test compiled successfully!\", procres);\n+    }\n+\n+    check_error_patterns(props, testfile, procres);\n+}\n+\n+fn run_rfail_test(&config config, &test_props props, &str testfile) {\n+    auto procres = compile_test(config, props, testfile);\n+\n+    if (procres.status != 0) {\n+        fatal_procres(\"compilation failed!\", procres);\n+    }\n+\n+    procres = exec_compiled_test(config, testfile);\n+\n+    if (procres.status == 0) {\n+        fatal_procres(\"run-fail test didn't produce an error!\",\n+                      procres);\n+    }\n+\n+    check_error_patterns(props, testfile, procres);\n+}\n+\n+fn run_rpass_test(&config config, &test_props props, &str testfile) {\n+    auto procres = compile_test(config, props, testfile);\n+\n+    if (procres.status != 0) {\n+        fatal_procres(\"compilation failed!\", procres);\n+    }\n+\n+    procres = exec_compiled_test(config, testfile);\n+\n+    if (procres.status != 0) {\n+        fatal_procres(\"test run failed!\", procres);\n+    }\n+}\n+\n+fn check_error_patterns(&test_props props, &str testfile,\n+                       &procres procres) {\n+    if ivec::is_empty(props.error_patterns) {\n+        fatal(\"no error pattern specified in \" + testfile);\n+    }\n+\n+    auto next_err_idx = 0u;\n+    auto next_err_pat = props.error_patterns.(next_err_idx);\n+    for (str line in str::split(procres.out, '\\n' as u8)) {\n+        if (str::find(line, next_err_pat) > 0) {\n+            log #fmt(\"found error pattern %s\", next_err_pat);\n+            next_err_idx += 1u;\n+            if next_err_idx == ivec::len(props.error_patterns) {\n+                log \"found all error patterns\";\n+                ret;\n+            }\n+            next_err_pat = props.error_patterns.(next_err_idx);\n+        }\n+    }\n+\n+    auto missing_patterns = ivec::slice(props.error_patterns,\n+                                        next_err_idx,\n+                                        ivec::len(props.error_patterns));\n+    if (ivec::len(missing_patterns) == 1u) {\n+        fatal_procres(#fmt(\"error pattern '%s' not found!\",\n+                           missing_patterns.(0)),\n+                      procres);\n+    } else {\n+        for (str pattern in missing_patterns) {\n+            error(#fmt(\"error pattern '%s' not found!\", pattern));\n+        }\n+        fatal_procres(\"multiple error patterns not found\", procres);\n+    }\n+}\n+\n+type procargs = rec(str prog, vec[str] args);\n+\n+type procres = rec(int status, str out, str cmdline);\n+\n+fn compile_test(&config config, &test_props props,\n+                &str testfile) -> procres {\n+    compose_and_run(config,\n+                    testfile,\n+                    bind make_compile_args(_, props, _),\n+                    config.compile_lib_path)\n+}\n+\n+fn exec_compiled_test(&config config, &str testfile) -> procres {\n+    compose_and_run(config,\n+                    testfile,\n+                    make_run_args,\n+                    config.run_lib_path)\n+}\n+\n+fn compose_and_run(&config config, &str testfile,\n+                   fn(&config, &str) -> procargs make_args,\n+                   &str lib_path) -> procres {\n+    auto procargs = make_args(config, testfile);\n+    ret program_output(config, testfile, lib_path,\n+                       procargs.prog, procargs.args);\n+}\n+\n+fn make_compile_args(&config config, &test_props props,\n+                     &str testfile) -> procargs {\n+    auto prog = config.rustc_path;\n+    auto args = [testfile,\n+                 \"-o\", make_exe_name(config, testfile)];\n+    args += split_maybe_args(config.rustcflags);\n+    args += split_maybe_args(props.compile_flags);\n+    ret rec(prog = prog,\n+            args = args);\n+}\n+\n+fn make_run_args(&config config, &str testfile) -> procargs {\n+    // If we've got another tool to run under (valgrind),\n+    // then split apart its command\n+    auto args = split_maybe_args(config.runtool)\n+        + [make_exe_name(config, testfile)];\n+    ret rec(prog = args.(0),\n+            args = vec::slice(args, 1u, vec::len(args)));\n+}\n+\n+fn split_maybe_args(&option::t[str] argstr) -> vec[str] {\n+    alt (argstr) {\n+        option::some(?s) { str::split(s, ' ' as u8) }\n+        option::none { [] }\n+    }\n+}\n+\n+fn program_output(&config config, &str testfile,\n+                  &str lib_path, &str prog, &vec[str] args) -> procres {\n+    auto cmdline = {\n+        auto cmdline = make_cmdline(lib_path, prog, args);\n+        logv(config, #fmt(\"running %s\", cmdline));\n+        cmdline\n+    };\n+    auto res = with_lib_path(lib_path,\n+                             bind run::program_output(prog, args));\n+    dump_output(config, testfile, res.out);\n+    ret rec(status = res.status,\n+            out = res.out,\n+            cmdline = cmdline);\n+}\n+\n+fn make_cmdline(&str libpath, &str prog, &vec[str] args) -> str {\n+    #fmt(\"%s %s %s\",\n+         lib_path_cmd_prefix(libpath),\n+         prog,\n+         str::connect(args, \" \"))\n+}\n+\n+// Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n+// for diagnostic purposes\n+fn lib_path_cmd_prefix(&str path) -> str {\n+    #fmt(\"%s=\\\"%s\\\"\", lib_path_env_var(), make_new_path(path))\n+}\n+\n+fn with_lib_path[T](&str path, fn() -> T f) -> T {\n+    auto maybe_oldpath = getenv(lib_path_env_var());\n+    append_lib_path(path);\n+    auto res = f();\n+    if option::is_some(maybe_oldpath) {\n+        export_lib_path(option::get(maybe_oldpath));\n+    } else {\n+        // FIXME: This should really be unset but we don't have that yet\n+        export_lib_path(\"\");\n+    }\n+    ret res;\n+}\n+\n+fn append_lib_path(&str path) {\n+    export_lib_path(make_new_path(path));\n+}\n+\n+fn make_new_path(&str path) -> str {\n+    // Windows just uses PATH as the library search path, so we have to\n+    // maintain the current value while adding our own\n+    alt getenv(lib_path_env_var()) {\n+        option::some(?curr) { #fmt(\"%s:%s\", path, curr) }\n+        option::none { path }\n+    }\n+}\n+\n+fn export_lib_path(&str path) {\n+    setenv(lib_path_env_var(), path);\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n+\n+#[cfg(target_os = \"macos\")]\n+fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n+\n+#[cfg(target_os = \"win32\")]\n+fn lib_path_env_var() -> str { \"PATH\" }\n+\n+fn make_exe_name(&config config, &str testfile) -> str {\n+    output_base_name(config, testfile) + os::exec_suffix()\n+}\n+\n+fn output_base_name(&config config, &str testfile) -> str {\n+    auto base = config.build_base;\n+    auto filename = {\n+        auto parts = str::split(fs::basename(testfile), '.' as u8);\n+        parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n+        str::connect(parts, \".\")\n+    };\n+    #fmt(\"%s%s.%s\", base, filename, config.stage_id)\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+#[cfg(target_os = \"linux\")]\n+fn dump_output(&config config, &str testfile, &str out) {\n+    auto outfile = make_out_name(config, testfile);\n+    auto writer = io::file_writer(outfile, [io::create, io::truncate]);\n+    writer.write_str(out);\n+}\n+\n+// FIXME (726): Can't use file_writer on mac\n+#[cfg(target_os = \"macos\")]\n+fn dump_output(&config config, &str testfile, &str out) {\n+}\n+\n+fn make_out_name(&config config, &str testfile) -> str {\n+    output_base_name(config, testfile) + \".out\"\n+}\n+\n+fn error(&str err) {\n+    io::stdout().write_line(#fmt(\"\\nerror: %s\", err));\n+}\n+\n+fn fatal(&str err) -> ! {\n+    error(err);\n+    fail;\n+}\n+\n+fn fatal_procres(&str err, procres procres) -> ! {\n+    auto msg = #fmt(\"\\n\\\n+                     error: %s\\n\\\n+                     command: %s\\n\\\n+                     output:\\n\\\n+                     ------------------------------------------\\n\\\n+                     %s\\n\\\n+                     ------------------------------------------\\n\\\n+                     \\n\",\n+                    err, procres.cmdline, procres.out);\n+    io::stdout().write_str(msg);\n+    fail;\n+}\n+\n+fn logv(&config config, &str s) {\n+    log s;\n+    if (config.verbose) {\n+        io::stdout().write_line(s);\n+    }\n+}\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "f5f52e2092b6df1e30c8cd174e26215bae27417c", "filename": "src/test/run-pass/lib-int.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=e6e53aff6398f9d2c6851c25acfdedd0bf47a321", "patch": "@@ -1,28 +0,0 @@\n-\n-use std;\n-import std::int;\n-import std::str::eq;\n-\n-fn test_to_str() {\n-    assert (eq(int::to_str(0, 10u), \"0\"));\n-    assert (eq(int::to_str(1, 10u), \"1\"));\n-    assert (eq(int::to_str(-1, 10u), \"-1\"));\n-    assert (eq(int::to_str(255, 16u), \"ff\"));\n-    assert (eq(int::to_str(100, 10u), \"100\"));\n-}\n-\n-fn test_pow() {\n-    assert (int::pow(0, 0u) == 1);\n-    assert (int::pow(0, 1u) == 0);\n-    assert (int::pow(0, 2u) == 0);\n-    assert (int::pow(-1, 0u) == 1);\n-    assert (int::pow(1, 0u) == 1);\n-    assert (int::pow(-3, 2u) == 9);\n-    assert (int::pow(-3, 3u) == -27);\n-    assert (int::pow(4, 9u) == 262144);\n-}\n-\n-fn main() {\n-  test_to_str();\n-  test_pow();\n-}\n\\ No newline at end of file"}, {"sha": "9b706cc60f89eef5d9bce39b00aeee593d98c0e2", "filename": "src/test/run-pass/lib-option.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Frun-pass%2Flib-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Frun-pass%2Flib-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-option.rs?ref=e6e53aff6398f9d2c6851c25acfdedd0bf47a321", "patch": "@@ -1,4 +0,0 @@\n-\n-use std;\n-\n-fn main() { auto x = std::option::some[int](10); }\n\\ No newline at end of file"}, {"sha": "bfb59453eb1f2f50d22949558f5b572f0ba540d8", "filename": "src/test/run-pass/lib-sha1.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e53aff6398f9d2c6851c25acfdedd0bf47a321/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=e6e53aff6398f9d2c6851c25acfdedd0bf47a321", "patch": "@@ -1,90 +0,0 @@\n-\n-\n-// -*- rust -*-\n-\n-// xfail-stage0\n-use std;\n-import std::sha1;\n-import std::vec;\n-import std::str;\n-\n-fn main() {\n-    type test = rec(str input, vec[u8] output);\n-\n-    fn a_million_letter_a() -> str {\n-        auto i = 0;\n-        auto rs = \"\";\n-        while (i < 100000) { rs += \"aaaaaaaaaa\"; i += 1; }\n-        ret rs;\n-    }\n-    // Test messages from FIPS 180-1\n-\n-    let vec[test] fips_180_1_tests =\n-        [rec(input=\"abc\",\n-             output=[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8, 0x47u8, 0x06u8, 0x81u8,\n-                     0x6Au8, 0xBAu8, 0x3Eu8, 0x25u8, 0x71u8, 0x78u8, 0x50u8,\n-                     0xC2u8, 0x6Cu8, 0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]),\n-         rec(input=\"abcdbcdecdefdefgefghfghighij\" +\n-                       \"hijkijkljklmklmnlmnomnopnopq\",\n-             output=[0x84u8, 0x98u8, 0x3Eu8, 0x44u8, 0x1Cu8, 0x3Bu8, 0xD2u8,\n-                     0x6Eu8, 0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8, 0xF9u8, 0x51u8,\n-                     0x29u8, 0xE5u8, 0xE5u8, 0x46u8, 0x70u8, 0xF1u8]),\n-         rec(input=a_million_letter_a(),\n-             output=[0x34u8, 0xAAu8, 0x97u8, 0x3Cu8, 0xD4u8, 0xC4u8, 0xDAu8,\n-                     0xA4u8, 0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8, 0xDBu8, 0xADu8,\n-                     0x27u8, 0x31u8, 0x65u8, 0x34u8, 0x01u8, 0x6Fu8])];\n-    // Examples from wikipedia\n-\n-    let vec[test] wikipedia_tests =\n-        [rec(input=\"The quick brown fox jumps over the lazy dog\",\n-             output=[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8, 0x7au8, 0x2du8, 0x28u8,\n-                     0xfcu8, 0xedu8, 0x84u8, 0x9eu8, 0xe1u8, 0xbbu8, 0x76u8,\n-                     0xe7u8, 0x39u8, 0x1bu8, 0x93u8, 0xebu8, 0x12u8]),\n-         rec(input=\"The quick brown fox jumps over the lazy cog\",\n-             output=[0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8, 0xd2u8, 0x5eu8, 0x1bu8,\n-                     0x3au8, 0xfau8, 0xd3u8, 0xe8u8, 0x5au8, 0x0bu8, 0xd1u8,\n-                     0x7du8, 0x9bu8, 0x10u8, 0x0du8, 0xb4u8, 0xb3u8])];\n-    auto tests = fips_180_1_tests + wikipedia_tests;\n-    fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n-        assert (vec::len[u8](v0) == vec::len[u8](v1));\n-        auto len = vec::len[u8](v0);\n-        auto i = 0u;\n-        while (i < len) {\n-            auto a = v0.(i);\n-            auto b = v1.(i);\n-            assert (a == b);\n-            i += 1u;\n-        }\n-    }\n-    // Test that it works when accepting the message all at once\n-\n-    auto sh = sha1::mk_sha1();\n-    for (test t in tests) {\n-        sh.input_str(t.input);\n-        auto out = sh.result();\n-        check_vec_eq(t.output, out);\n-        sh.reset();\n-    }\n-\n-    // Test that it works when accepting the message in pieces\n-    for (test t in tests) {\n-        auto len = str::byte_len(t.input);\n-        auto left = len;\n-        while (left > 0u) {\n-            auto take = (left + 1u) / 2u;\n-            sh.input_str(str::substr(t.input, len - left, take));\n-            left = left - take;\n-        }\n-        auto out = sh.result();\n-        check_vec_eq(t.output, out);\n-        sh.reset();\n-    }\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "2b48e450befebcd6a4845641f156b9744beddb65", "filename": "src/test/run-pass/test-runner-hides-main.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags:--test\n+// xfail-fast\n+\n+use std;\n+\n+// Building as a test runner means that a synthetic main will be run,\n+// not ours\n+fn main() {\n+    fail;\n+}\n\\ No newline at end of file"}, {"sha": "a550136ec2cec032d7eb6a42f2e55f2d2c0934cb", "filename": "src/test/stdtest/bitv.rs", "status": "renamed", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbitv.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -3,6 +3,7 @@ use std;\n import std::vec;\n import std::bitv;\n \n+#[test]\n fn test_0_elements() {\n     auto act;\n     auto exp;\n@@ -13,6 +14,7 @@ fn test_0_elements() {\n     assert (bitv::eq_vec(act, exp));\n }\n \n+#[test]\n fn test_1_element() {\n     auto act;\n     act = bitv::create(1u, false);\n@@ -21,6 +23,7 @@ fn test_1_element() {\n     assert (bitv::eq_vec(act, [1u]));\n }\n \n+#[test]\n fn test_10_elements() {\n     auto act;\n     // all 0\n@@ -59,6 +62,7 @@ fn test_10_elements() {\n     assert (bitv::eq_vec(act, [1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n }\n \n+#[test]\n fn test_31_elements() {\n     auto act;\n     // all 0\n@@ -131,6 +135,7 @@ fn test_31_elements() {\n                           0u, 0u, 0u, 0u, 1u]));\n }\n \n+#[test]\n fn test_32_elements() {\n     auto act;\n     // all 0\n@@ -205,6 +210,7 @@ fn test_32_elements() {\n                           0u, 0u, 0u, 0u, 1u, 1u]));\n }\n \n+#[test]\n fn test_33_elements() {\n     auto act;\n     // all 0\n@@ -280,11 +286,3 @@ fn test_33_elements() {\n                           0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n }\n \n-fn main() {\n-    test_0_elements();\n-    test_1_element();\n-    test_10_elements();\n-    test_31_elements();\n-    test_32_elements();\n-    test_33_elements();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-bitv.rs"}, {"sha": "6b2d199ca6f9c72782fa4fd622c9eb6942183251", "filename": "src/test/stdtest/box.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbox.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -2,7 +2,8 @@\n use std;\n import std::box;\n \n-fn main() {\n+#[test]\n+fn test() {\n     auto x = @3;\n     auto y = @3;\n     assert (box::ptr_eq[int](x, x));", "previous_filename": "src/test/run-pass/lib-box.rs"}, {"sha": "0a66ab39daac4e49285f7943920d16a036b33f87", "filename": "src/test/stdtest/deque.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -4,6 +4,7 @@\n use std;\n import std::deque;\n \n+#[test]\n fn test_simple() {\n     let deque::t[int] d = deque::create[int]();\n     assert (d.size() == 0u);\n@@ -116,7 +117,8 @@ tag taggypar[T] { onepar(int); twopar(int, int); threepar(int, int, int); }\n \n type reccy = rec(int x, int y, taggy t);\n \n-fn main() {\n+#[test]\n+fn test() {\n     fn inteq(&int a, &int b) -> bool { ret a == b; }\n     fn intboxeq(&@int a, &@int b) -> bool { ret a == b; }\n     fn taggyeq(&taggy a, &taggy b) -> bool {\n@@ -170,10 +172,6 @@ fn main() {\n     fn reccyeq(&reccy a, &reccy b) -> bool {\n         ret a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n     }\n-    log \"*** starting\";\n-    log \"*** test simple\";\n-    test_simple();\n-    log \"*** end test simple\";\n     log \"*** test boxes\";\n     test_boxes(@5, @72, @64, @175);\n     log \"*** end test boxes\";", "previous_filename": "src/test/run-pass/lib-deque.rs"}, {"sha": "0d1fd4353ea34ea87743dcd0491b2f8956547c70", "filename": "src/test/stdtest/either.rs", "status": "renamed", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Feither.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,23 +1,24 @@\n-// xfail-stage0\n-\n use std;\n import std::either::*;\n import std::ivec::len;\n \n+#[test]\n fn test_either_left() {\n   auto val = left(10);\n   fn f_left(&int x) -> bool { x == 10 }\n   fn f_right(&uint x) -> bool { false }\n   assert (either(f_left, f_right, val));\n }\n \n+#[test]\n fn test_either_right() {\n   auto val = right(10u);\n   fn f_left(&int x) -> bool { false }\n   fn f_right(&uint x) -> bool { x == 10u }\n   assert (either(f_left, f_right, val));\n }\n \n+#[test]\n fn test_lefts() {\n   auto input = ~[left(10),\n                  right(11),\n@@ -28,19 +29,22 @@ fn test_lefts() {\n   assert (result == ~[10, 12, 14]);\n }\n \n+#[test]\n fn test_lefts_none() {\n   let (t[int, int])[] input = ~[right(10),\n                                 right(10)];\n   auto result = lefts(input);\n   assert (len(result) == 0u);\n }\n \n+#[test]\n fn test_lefts_empty() {\n   let (t[int, int])[] input = ~[];\n   auto result = lefts(input);\n   assert (len(result) == 0u);\n }\n \n+#[test]\n fn test_rights() {\n   auto input = ~[left(10),\n                  right(11),\n@@ -51,19 +55,22 @@ fn test_rights() {\n   assert (result == ~[11, 13]);\n }\n \n+#[test]\n fn test_rights_none() {\n   let (t[int, int])[] input = ~[left(10),\n                                 left(10)];\n   auto result = rights(input);\n   assert (len(result) == 0u);\n }\n \n+#[test]\n fn test_rights_empty() {\n     let (t[int, int])[] input = ~[];\n     auto result = rights(input);\n     assert (len(result) == 0u);\n }\n \n+#[test]\n fn test_partition() {\n   auto input = ~[left(10),\n                  right(11),\n@@ -78,6 +85,7 @@ fn test_partition() {\n   assert (result._1.(1) == 13);\n }\n \n+#[test]\n fn test_partition_no_lefts() {\n   let (t[int, int])[] input = ~[right(10),\n                                 right(11)];\n@@ -86,6 +94,7 @@ fn test_partition_no_lefts() {\n   assert (len(result._1) == 2u);\n }\n \n+#[test]\n fn test_partition_no_rights() {\n   let (t[int, int])[] input = ~[left(10),\n                                 left(11)];\n@@ -94,24 +103,10 @@ fn test_partition_no_rights() {\n   assert (len(result._1) == 0u);\n }\n \n+#[test]\n fn test_partition_empty() {\n   let (t[int, int])[] input = ~[];\n   auto result = partition(input);\n   assert (len(result._0) == 0u);\n   assert (len(result._1) == 0u);\n }\n-\n-fn main() {\n-  test_either_left();\n-  test_either_right();\n-  test_lefts();\n-  test_lefts_none();\n-  test_lefts_empty();\n-  test_rights();\n-  test_rights_none();\n-  test_rights_empty();\n-  test_partition();\n-  test_partition_no_lefts();\n-  test_partition_no_rights();\n-  test_partition_empty();\n-}", "previous_filename": "src/test/run-pass/lib-either.rs"}, {"sha": "76321fbb436ae6d5d86f5cdc2ccd7cfa5f45af9d", "filename": "src/test/stdtest/fs.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffs.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -2,6 +2,7 @@\n use std;\n import std::fs;\n \n+#[test]\n fn test_connect() {\n     auto slash = fs::path_sep();\n     log_err fs::connect(\"a\", \"b\");\n@@ -10,11 +11,8 @@ fn test_connect() {\n }\n \n // Issue #712\n+#[test]\n fn test_list_dir_no_invalid_memory_access() {\n   fs::list_dir(\".\");\n }\n \n-fn main() {\n-  test_connect();\n-  test_list_dir_no_invalid_memory_access();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-fs.rs"}, {"sha": "233e3a546fca6bd2abd33d00aeb6110fb8f7d59b", "filename": "src/test/stdtest/getopts.rs", "status": "renamed", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -29,6 +29,7 @@ fn check_fail_type(opt::fail_ f, fail_type ft) {\n \n \n // Tests for reqopt\n+#[test]\n fn test_reqopt_long() {\n     auto args = [\"--test=20\"];\n     auto opts = [opt::reqopt(\"test\")];\n@@ -42,6 +43,7 @@ fn test_reqopt_long() {\n     }\n }\n \n+#[test]\n fn test_reqopt_long_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::reqopt(\"test\")];\n@@ -52,6 +54,7 @@ fn test_reqopt_long_missing() {\n     }\n }\n \n+#[test]\n fn test_reqopt_long_no_arg() {\n     auto args = [\"--test\"];\n     auto opts = [opt::reqopt(\"test\")];\n@@ -62,6 +65,7 @@ fn test_reqopt_long_no_arg() {\n     }\n }\n \n+#[test]\n fn test_reqopt_long_multi() {\n     auto args = [\"--test=20\", \"--test=30\"];\n     auto opts = [opt::reqopt(\"test\")];\n@@ -72,6 +76,7 @@ fn test_reqopt_long_multi() {\n     }\n }\n \n+#[test]\n fn test_reqopt_short() {\n     auto args = [\"-t\", \"20\"];\n     auto opts = [opt::reqopt(\"t\")];\n@@ -85,6 +90,7 @@ fn test_reqopt_short() {\n     }\n }\n \n+#[test]\n fn test_reqopt_short_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::reqopt(\"t\")];\n@@ -95,6 +101,7 @@ fn test_reqopt_short_missing() {\n     }\n }\n \n+#[test]\n fn test_reqopt_short_no_arg() {\n     auto args = [\"-t\"];\n     auto opts = [opt::reqopt(\"t\")];\n@@ -105,6 +112,7 @@ fn test_reqopt_short_no_arg() {\n     }\n }\n \n+#[test]\n fn test_reqopt_short_multi() {\n     auto args = [\"-t\", \"20\", \"-t\", \"30\"];\n     auto opts = [opt::reqopt(\"t\")];\n@@ -117,6 +125,7 @@ fn test_reqopt_short_multi() {\n \n \n // Tests for optopt\n+#[test]\n fn test_optopt_long() {\n     auto args = [\"--test=20\"];\n     auto opts = [opt::optopt(\"test\")];\n@@ -130,6 +139,7 @@ fn test_optopt_long() {\n     }\n }\n \n+#[test]\n fn test_optopt_long_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::optopt(\"test\")];\n@@ -140,6 +150,7 @@ fn test_optopt_long_missing() {\n     }\n }\n \n+#[test]\n fn test_optopt_long_no_arg() {\n     auto args = [\"--test\"];\n     auto opts = [opt::optopt(\"test\")];\n@@ -150,6 +161,7 @@ fn test_optopt_long_no_arg() {\n     }\n }\n \n+#[test]\n fn test_optopt_long_multi() {\n     auto args = [\"--test=20\", \"--test=30\"];\n     auto opts = [opt::optopt(\"test\")];\n@@ -160,6 +172,7 @@ fn test_optopt_long_multi() {\n     }\n }\n \n+#[test]\n fn test_optopt_short() {\n     auto args = [\"-t\", \"20\"];\n     auto opts = [opt::optopt(\"t\")];\n@@ -173,6 +186,7 @@ fn test_optopt_short() {\n     }\n }\n \n+#[test]\n fn test_optopt_short_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::optopt(\"t\")];\n@@ -183,6 +197,7 @@ fn test_optopt_short_missing() {\n     }\n }\n \n+#[test]\n fn test_optopt_short_no_arg() {\n     auto args = [\"-t\"];\n     auto opts = [opt::optopt(\"t\")];\n@@ -193,6 +208,7 @@ fn test_optopt_short_no_arg() {\n     }\n }\n \n+#[test]\n fn test_optopt_short_multi() {\n     auto args = [\"-t\", \"20\", \"-t\", \"30\"];\n     auto opts = [opt::optopt(\"t\")];\n@@ -205,6 +221,7 @@ fn test_optopt_short_multi() {\n \n \n // Tests for optflag\n+#[test]\n fn test_optflag_long() {\n     auto args = [\"--test\"];\n     auto opts = [opt::optflag(\"test\")];\n@@ -215,6 +232,7 @@ fn test_optflag_long() {\n     }\n }\n \n+#[test]\n fn test_optflag_long_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::optflag(\"test\")];\n@@ -225,6 +243,7 @@ fn test_optflag_long_missing() {\n     }\n }\n \n+#[test]\n fn test_optflag_long_arg() {\n     auto args = [\"--test=20\"];\n     auto opts = [opt::optflag(\"test\")];\n@@ -238,6 +257,7 @@ fn test_optflag_long_arg() {\n     }\n }\n \n+#[test]\n fn test_optflag_long_multi() {\n     auto args = [\"--test\", \"--test\"];\n     auto opts = [opt::optflag(\"test\")];\n@@ -248,6 +268,7 @@ fn test_optflag_long_multi() {\n     }\n }\n \n+#[test]\n fn test_optflag_short() {\n     auto args = [\"-t\"];\n     auto opts = [opt::optflag(\"t\")];\n@@ -258,6 +279,7 @@ fn test_optflag_short() {\n     }\n }\n \n+#[test]\n fn test_optflag_short_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::optflag(\"t\")];\n@@ -268,6 +290,7 @@ fn test_optflag_short_missing() {\n     }\n }\n \n+#[test]\n fn test_optflag_short_arg() {\n     auto args = [\"-t\", \"20\"];\n     auto opts = [opt::optflag(\"t\")];\n@@ -282,6 +305,7 @@ fn test_optflag_short_arg() {\n     }\n }\n \n+#[test]\n fn test_optflag_short_multi() {\n     auto args = [\"-t\", \"-t\"];\n     auto opts = [opt::optflag(\"t\")];\n@@ -294,6 +318,7 @@ fn test_optflag_short_multi() {\n \n \n // Tests for optmulti\n+#[test]\n fn test_optmulti_long() {\n     auto args = [\"--test=20\"];\n     auto opts = [opt::optmulti(\"test\")];\n@@ -307,6 +332,7 @@ fn test_optmulti_long() {\n     }\n }\n \n+#[test]\n fn test_optmulti_long_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::optmulti(\"test\")];\n@@ -317,6 +343,7 @@ fn test_optmulti_long_missing() {\n     }\n }\n \n+#[test]\n fn test_optmulti_long_no_arg() {\n     auto args = [\"--test\"];\n     auto opts = [opt::optmulti(\"test\")];\n@@ -327,6 +354,7 @@ fn test_optmulti_long_no_arg() {\n     }\n }\n \n+#[test]\n fn test_optmulti_long_multi() {\n     auto args = [\"--test=20\", \"--test=30\"];\n     auto opts = [opt::optmulti(\"test\")];\n@@ -342,6 +370,7 @@ fn test_optmulti_long_multi() {\n     }\n }\n \n+#[test]\n fn test_optmulti_short() {\n     auto args = [\"-t\", \"20\"];\n     auto opts = [opt::optmulti(\"t\")];\n@@ -355,6 +384,7 @@ fn test_optmulti_short() {\n     }\n }\n \n+#[test]\n fn test_optmulti_short_missing() {\n     auto args = [\"blah\"];\n     auto opts = [opt::optmulti(\"t\")];\n@@ -365,6 +395,7 @@ fn test_optmulti_short_missing() {\n     }\n }\n \n+#[test]\n fn test_optmulti_short_no_arg() {\n     auto args = [\"-t\"];\n     auto opts = [opt::optmulti(\"t\")];\n@@ -375,6 +406,7 @@ fn test_optmulti_short_no_arg() {\n     }\n }\n \n+#[test]\n fn test_optmulti_short_multi() {\n     auto args = [\"-t\", \"20\", \"-t\", \"30\"];\n     auto opts = [opt::optmulti(\"t\")];\n@@ -390,6 +422,7 @@ fn test_optmulti_short_multi() {\n     }\n }\n \n+#[test]\n fn test_unrecognized_option_long() {\n     auto args = [\"--untest\"];\n     auto opts = [opt::optmulti(\"t\")];\n@@ -400,6 +433,7 @@ fn test_unrecognized_option_long() {\n     }\n }\n \n+#[test]\n fn test_unrecognized_option_short() {\n     auto args = [\"-t\"];\n     auto opts = [opt::optmulti(\"test\")];\n@@ -410,6 +444,7 @@ fn test_unrecognized_option_short() {\n     }\n }\n \n+#[test]\n fn test_combined() {\n     auto args =\n         [\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\", \"-f\",\n@@ -435,40 +470,3 @@ fn test_combined() {\n     }\n }\n \n-fn main() {\n-    test_reqopt_long();\n-    test_reqopt_long_missing();\n-    test_reqopt_long_no_arg();\n-    test_reqopt_long_multi();\n-    test_reqopt_short();\n-    test_reqopt_short_missing();\n-    test_reqopt_short_no_arg();\n-    test_reqopt_short_multi();\n-    test_optopt_long();\n-    test_optopt_long_missing();\n-    test_optopt_long_no_arg();\n-    test_optopt_long_multi();\n-    test_optopt_short();\n-    test_optopt_short_missing();\n-    test_optopt_short_no_arg();\n-    test_optopt_short_multi();\n-    test_optflag_long();\n-    test_optflag_long_missing();\n-    test_optflag_long_arg();\n-    test_optflag_long_multi();\n-    test_optflag_short();\n-    test_optflag_short_missing();\n-    test_optflag_short_arg();\n-    test_optflag_short_multi();\n-    test_optmulti_long();\n-    test_optmulti_long_missing();\n-    test_optmulti_long_no_arg();\n-    test_optmulti_long_multi();\n-    test_optmulti_short();\n-    test_optmulti_short_missing();\n-    test_optmulti_short_no_arg();\n-    test_optmulti_short_multi();\n-    test_unrecognized_option_long();\n-    test_unrecognized_option_short();\n-    test_combined();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-getopts.rs"}, {"sha": "61d3448a175e9827806f920c4117c61bc7d47a7a", "filename": "src/test/stdtest/int.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fint.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,3 +1,5 @@\n+\n+use std;\n import std::int;\n import std::str::eq;\n "}, {"sha": "460d68b75697393cf22446ca346759545258675f", "filename": "src/test/stdtest/io.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,11 +1,11 @@\n-// xfail-stage0\n // -*- rust -*-\n use std;\n import std::io;\n import std::str;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"win32\")]\n+#[test]\n fn test_simple() {\n     let str tmpfile = \"test/run-pass/lib-io-test-simple.tmp\";\n     log tmpfile;\n@@ -24,8 +24,7 @@ fn test_simple() {\n \n // FIXME (726)\n #[cfg(target_os = \"macos\")]\n+#[test]\n+#[ignore]\n fn test_simple() {}\n \n-fn main() {\n-    test_simple();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-io.rs"}, {"sha": "945a8310bff479abb1fed329606adc318f69f3f4", "filename": "src/test/stdtest/ivec.rs", "status": "renamed", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fivec.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,4 +1,3 @@\n-// xfail-stage0\n \n use std;\n import std::ivec;\n@@ -18,13 +17,15 @@ fn square_if_odd(&uint n) -> option::t[uint] {\n \n fn add(&uint x, &uint y) -> uint { ret x + y; }\n \n+#[test]\n fn test_reserve_and_on_heap() {\n     let int[] v = ~[ 1, 2 ];\n     assert (!ivec::on_heap(v));\n     ivec::reserve(v, 8u);\n     assert (ivec::on_heap(v));\n }\n \n+#[test]\n fn test_unsafe_ptrs() {\n     // Test on-stack copy-from-buf.\n     auto a = ~[ 1, 2, 3 ];\n@@ -49,6 +50,7 @@ fn test_unsafe_ptrs() {\n     assert (d.(4) == 5);\n }\n \n+#[test]\n fn test_init_fn() {\n     // Test on-stack init_fn.\n     auto v = ivec::init_fn(square, 3u);\n@@ -67,6 +69,7 @@ fn test_init_fn() {\n     assert (v.(4) == 16u);\n }\n \n+#[test]\n fn test_init_elt() {\n     // Test on-stack init_elt.\n     auto v = ivec::init_elt(10u, 2u);\n@@ -84,22 +87,26 @@ fn test_init_elt() {\n     assert (v.(5) == 20u);\n }\n \n+#[test]\n fn test_is_empty() {\n     assert ivec::is_empty[int](~[]);\n     assert !ivec::is_empty(~[0]);\n }\n \n+#[test]\n fn test_is_not_empty() {\n     assert ivec::is_not_empty(~[0]);\n     assert !ivec::is_not_empty[int](~[]);\n }\n \n+#[test]\n fn test_head() {\n     auto a = ~[11, 12];\n     check ivec::is_not_empty(a);\n     assert ivec::head(a) == 11;\n }\n \n+#[test]\n fn test_tail() {\n     auto a = ~[11];\n     check ivec::is_not_empty(a);\n@@ -110,6 +117,7 @@ fn test_tail() {\n     assert ivec::tail(a) == ~[12];\n }\n \n+#[test]\n fn test_last() {\n     auto n = ivec::last(~[]);\n     assert (n == none);\n@@ -119,6 +127,7 @@ fn test_last() {\n     assert (n == some(5));\n }\n \n+#[test]\n fn test_slice() {\n     // Test on-stack -> on-stack slice.\n     auto v = ivec::slice(~[ 1, 2, 3 ], 1u, 3u);\n@@ -143,6 +152,7 @@ fn test_slice() {\n     assert (v.(4) == 6);\n }\n \n+#[test]\n fn test_pop() {\n     // Test on-stack pop.\n     auto v = ~[ 1, 2, 3 ];\n@@ -163,6 +173,7 @@ fn test_pop() {\n     assert (e == 5);\n }\n \n+#[test]\n fn test_grow() {\n     // Test on-stack grow().\n     auto v = ~[];\n@@ -181,6 +192,7 @@ fn test_grow() {\n     assert (v.(4) == 2);\n }\n \n+#[test]\n fn test_grow_fn() {\n     auto v = ~[];\n     ivec::grow_fn(v, 3u, square);\n@@ -190,6 +202,7 @@ fn test_grow_fn() {\n     assert (v.(2) == 4u);\n }\n \n+#[test]\n fn test_grow_set() {\n     auto v = ~[ mutable 1, 2, 3 ];\n     ivec::grow_set(v, 4u, 4, 5);\n@@ -201,6 +214,7 @@ fn test_grow_set() {\n     assert (v.(4) == 5);\n }\n \n+#[test]\n fn test_map() {\n     // Test on-stack map.\n     auto v = ~[ 1u, 2u, 3u ];\n@@ -221,6 +235,7 @@ fn test_map() {\n     assert (w.(4) == 25u);\n }\n \n+#[test]\n fn test_filter_map() {\n     // Test on-stack filter-map.\n     auto v = ~[ 1u, 2u, 3u ];\n@@ -238,6 +253,7 @@ fn test_filter_map() {\n     assert (w.(2) == 25u);\n }\n \n+#[test]\n fn test_foldl() {\n     // Test on-stack fold.\n     auto v = ~[ 1u, 2u, 3u ];\n@@ -250,6 +266,7 @@ fn test_foldl() {\n     assert (sum == 15u);\n }\n \n+#[test]\n fn test_any_and_all() {\n     assert (ivec::any(is_three, ~[ 1u, 2u, 3u ]));\n     assert (!ivec::any(is_three, ~[ 0u, 1u, 2u ]));\n@@ -279,38 +296,6 @@ fn test_zip_unzip() {\n     assert tup(3, 6) == tup(u1._0.(2), u1._1.(2));\n }\n \n-fn main() {\n-    test_reserve_and_on_heap();\n-    test_unsafe_ptrs();\n-\n-    // Predicates\n-    test_is_empty();\n-    test_is_not_empty();\n-\n-    // Accessors\n-    test_init_fn();\n-    test_init_elt();\n-    test_head();\n-    test_tail();\n-    test_last();\n-    test_slice();\n-\n-    // Mutators\n-    test_pop();\n-\n-    // Appending\n-    test_grow();\n-    test_grow_fn();\n-    test_grow_set();\n-\n-    // Functional utilities\n-    test_map();\n-    test_filter_map();\n-    test_foldl();\n-    test_any_and_all();\n-    test_zip_unzip();\n-}\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;", "previous_filename": "src/test/run-pass/lib-ivec.rs"}, {"sha": "3d937016b1f221f5d697e14ed34dae54f97419a2", "filename": "src/test/stdtest/list.rs", "status": "renamed", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Flist.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -6,20 +6,23 @@ import std::list::cdr;\n import std::list::from_vec;\n import std::option;\n \n+#[test]\n fn test_from_vec() {\n     auto l = from_vec([0, 1, 2]);\n     assert (car(l) == 0);\n     assert (car(cdr(l)) == 1);\n     assert (car(cdr(cdr(l))) == 2);\n }\n \n+#[test]\n fn test_foldl() {\n     auto l = from_vec([0, 1, 2, 3, 4]);\n     fn add(&int a, &uint b) -> uint { ret (a as uint) + b; }\n     auto rs = list::foldl(l, 0u, add);\n     assert (rs == 10u);\n }\n \n+#[test]\n fn test_find_success() {\n     auto l = from_vec([0, 1, 2]);\n     fn match(&int i) -> option::t[int] {\n@@ -29,13 +32,15 @@ fn test_find_success() {\n     assert (rs == option::some(2));\n }\n \n+#[test]\n fn test_find_fail() {\n     auto l = from_vec([0, 1, 2]);\n     fn match(&int i) -> option::t[int] { ret option::none[int]; }\n     auto rs = list::find(l, match);\n     assert (rs == option::none[int]);\n }\n \n+#[test]\n fn test_has() {\n     auto l = from_vec([5, 8, 6]);\n     auto empty = list::nil[int];\n@@ -45,16 +50,9 @@ fn test_has() {\n     assert (!list::has(empty, 5));\n }\n \n+#[test]\n fn test_length() {\n     auto l = from_vec([0, 1, 2]);\n     assert (list::length(l) == 3u);\n }\n \n-fn main() {\n-    test_from_vec();\n-    test_foldl();\n-    test_find_success();\n-    test_find_fail();\n-    test_length();\n-    test_has();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-list.rs"}, {"sha": "da6d063011675cf3fb2d7d9b9d9b2270c152104c", "filename": "src/test/stdtest/map.rs", "status": "renamed", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -7,6 +7,7 @@ import std::str;\n import std::uint;\n import std::util;\n \n+#[test]\n fn test_simple() {\n     log \"*** starting test_simple\";\n     fn eq_uint(&uint x, &uint y) -> bool { ret x == y; }\n@@ -83,6 +84,7 @@ fn test_simple() {\n /**\n  * Force map growth and rehashing.\n  */\n+#[test]\n fn test_growth() {\n     log \"*** starting test_growth\";\n     let uint num_to_insert = 64u;\n@@ -162,6 +164,7 @@ fn test_growth() {\n     log \"*** finished test_growth\";\n }\n \n+#[test]\n fn test_removal() {\n     log \"*** starting test_removal\";\n     let uint num_to_insert = 64u;\n@@ -262,6 +265,7 @@ fn test_removal() {\n     log \"*** finished test_removal\";\n }\n \n+#[test]\n fn test_contains_key() {\n     auto key = \"k\";\n     auto map = map::mk_hashmap[str, str](str::hash, str::eq);\n@@ -270,18 +274,11 @@ fn test_contains_key() {\n     assert (map.contains_key(key));\n }\n \n+#[test]\n fn test_find() {\n     auto key = \"k\";\n     auto map = map::mk_hashmap[str, str](str::hash, str::eq);\n     assert (std::option::is_none(map.find(key)));\n     map.insert(key, \"val\");\n     assert (std::option::get(map.find(key)) == \"val\");\n }\n-\n-fn main() {\n-    test_simple();\n-    test_growth();\n-    test_removal();\n-    test_contains_key();\n-    test_find();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-map.rs"}, {"sha": "a22effc524afc7cea57d5f873fc8b46240747409", "filename": "src/test/stdtest/option.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Foption.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -0,0 +1,5 @@\n+\n+use std;\n+\n+#[test]\n+fn test() { auto x = std::option::some[int](10); }\n\\ No newline at end of file"}, {"sha": "a47777d7739593d047c1fd95bef524a0a2a5b477", "filename": "src/test/stdtest/os.rs", "status": "renamed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fos.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,7 +1,3 @@\n-// xfail-stage0\n-\n-use std;\n-\n import std::generic_os::setenv;\n import std::generic_os::getenv;\n import std::option;\n@@ -33,12 +29,6 @@ fn test_getenv_big() {\n     assert getenv(\"NAME\") == option::some(s);\n }\n \n-fn main() {\n-    test_setenv();\n-    test_setenv_overwrite();\n-    test_getenv_big();\n-}\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;", "previous_filename": "src/test/run-pass/lib-os.rs"}, {"sha": "81fd74208f87c544653011ecdc4ed1257a8e2717", "filename": "src/test/stdtest/path.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fpath.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,4 +1,3 @@\n-// xfail-stage0\n \n // Testing a few of the path manipuation functions\n \n@@ -7,7 +6,8 @@ use std;\n import std::fs;\n import std::os;\n \n-fn main() {\n+#[test]\n+fn test() {\n   assert(!fs::path_is_absolute(\"test-path\"));\n \n   log \"Current working directory: \" + os::getcwd();", "previous_filename": "src/test/run-pass/lib-path.rs"}, {"sha": "bf9633e0686da56018c26abdcdcb51c982399cf7", "filename": "src/test/stdtest/ptr.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fptr.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,12 +1,11 @@\n-// xfail-stage0\n-\n use std;\n import std::ptr;\n import std::unsafe;\n \n type pair = rec(mutable int fst, mutable int snd);\n \n-fn main() {\n+#[test]\n+fn test() {\n     auto p = rec(mutable fst=10, mutable snd=20);\n     let *mutable pair pptr = ptr::addr_of(p);\n     let *mutable int iptr = unsafe::reinterpret_cast(pptr);", "previous_filename": "src/test/run-pass/lib-ptr.rs"}, {"sha": "1581cd42403e700597b8a109054a1ba8894c9880", "filename": "src/test/stdtest/qsort.rs", "status": "renamed", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,6 +1,10 @@\n \n use std;\n \n+import std::sort;\n+import std::ivec;\n+import std::int;\n+\n fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n     auto len = std::vec::len[int](v1);\n     fn ltequal(&int a, &int b) -> bool { ret a <= b; }\n@@ -10,7 +14,8 @@ fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n     while (i < len) { log v2.(i); assert (v2.(i) == v1.(i)); i += 1u; }\n }\n \n-fn main() {\n+#[test]\n+fn test() {\n     {\n         auto v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n         auto v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n@@ -33,6 +38,24 @@ fn main() {\n         check_sort(v1, v2);\n     }\n }\n+\n+// Regression test for #705\n+#[test]\n+fn test_simple() {\n+    auto names = ~[mutable 2, 1, 3];\n+\n+    auto expected = ~[1, 2, 3];\n+\n+    fn lteq(&int a, &int b) -> bool { int::le(a, b) }\n+    sort::ivector::quick_sort(lteq, names);\n+\n+    auto pairs = ivec::zip(expected, ivec::from_mut(names));\n+    for (tup(int, int) p in pairs) {\n+        log #fmt(\"%d %d\", p._0, p._1);\n+        assert p._0 == p._1;\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;", "previous_filename": "src/test/run-pass/lib-qsort.rs"}, {"sha": "58abf1bc8fa974f43990d39bf1498964178cb85c", "filename": "src/test/stdtest/qsort3.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fqsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fqsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort3.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -12,7 +12,8 @@ fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n     while (i < len) { log v2.(i); assert (v2.(i) == v1.(i)); i += 1u; }\n }\n \n-fn main() {\n+#[test]\n+fn test() {\n     {\n         auto v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n         auto v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];", "previous_filename": "src/test/run-pass/lib-qsort3.rs"}, {"sha": "8d7b26df04b2f948b4f0d4dfc30643ec4cb55c5f", "filename": "src/test/stdtest/rand.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frand.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -4,7 +4,8 @@\n use std;\n import std::rand;\n \n-fn main() {\n+#[test]\n+fn test() {\n     let rand::rng r1 = rand::mk_rng();\n     log r1.next();\n     log r1.next();", "previous_filename": "src/test/run-pass/lib-rand.rs"}, {"sha": "c86182d36c95c952a47992482db2a166e7b41a80", "filename": "src/test/stdtest/run.rs", "status": "renamed", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,22 +1,18 @@\n-// xfail-stage0\n-\n use std;\n import std::run;\n \n // Regression test for memory leaks\n-// FIXME (714) Why does this fail on win32?\n-\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[test]\n fn test_leaks() {\n   run::run_program(\"echo\", []);\n   run::start_program(\"echo\", []);\n   run::program_output(\"echo\", []);\n }\n \n+// FIXME\n #[cfg(target_os = \"win32\")]\n+#[test]\n+#[ignore]\n fn test_leaks() {}\n-\n-fn main() {\n-  test_leaks();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-run.rs"}, {"sha": "038444552e078c3674256e2f01db9d9a03b384b2", "filename": "src/test/stdtest/sha1.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,3 +1,8 @@\n+\n+\n+// -*- rust -*-\n+\n+use std;\n import std::sha1;\n import std::vec;\n import std::str;"}, {"sha": "aae679217bb849d7f857ea79f8061892ef81a999", "filename": "src/test/stdtest/sort.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -10,7 +10,8 @@ fn check_sort(vec[int] v1, vec[int] v2) {\n     while (i < len) { log v3.(i); assert (v3.(i) == v2.(i)); i += 1u; }\n }\n \n-fn main() {\n+#[test]\n+fn test() {\n     {\n         auto v1 = [3, 7, 4, 5, 2, 9, 5, 8];\n         auto v2 = [2, 3, 4, 5, 5, 7, 8, 9];", "previous_filename": "src/test/run-pass/lib-sort.rs"}, {"sha": "dcc90a8edc9a64c860ad0fa26f09066af616b55c", "filename": "src/test/stdtest/sort_ivec.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fsort_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fsort_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort_ivec.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,4 +1,3 @@\n-// xfail-stage0\n \n use std;\n \n@@ -11,7 +10,8 @@ fn check_sort(&int[] v1, &int[] v2) {\n     while (i < len) { log v3.(i); assert (v3.(i) == v2.(i)); i += 1u; }\n }\n \n-fn main() {\n+#[test]\n+fn test() {\n     {\n         auto v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n         auto v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];", "previous_filename": "src/test/run-pass/lib-sort-ivec.rs"}, {"sha": "e313b77bd0c25ee8f10745b5e67e9bc90ce63c75", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,8 +1,35 @@\n use std;\n \n-mod sha1;\n+mod bitv;\n+mod box;\n+mod deque;\n+mod either;\n+mod fs;\n+mod getopts;\n mod int;\n+mod io;\n+mod ivec;\n+mod list;\n+mod map;\n+mod option;\n+mod os;\n+mod path;\n+mod ptr;\n+mod qsort3;\n+mod qsort;\n+mod rand;\n+mod run;\n+mod sha1;\n+mod sort_ivec;\n+mod sort;\n+mod str_buf;\n+mod str;\n+mod task;\n mod test;\n+mod uint;\n+mod vec;\n+mod vec_str_conversions;\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "063a0d9783c47015559ffa87844a482b6435b8c9", "filename": "src/test/stdtest/str.rs", "status": "renamed", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,9 +1,7 @@\n-\n-\n-// xfail-stage0\n use std;\n import std::str;\n \n+#[test]\n fn test_bytes_len() {\n     assert (str::byte_len(\"\") == 0u);\n     assert (str::byte_len(\"hello world\") == 11u);\n@@ -14,6 +12,7 @@ fn test_bytes_len() {\n     assert (str::byte_len(\"\\U0001d11e\") == 4u);\n }\n \n+#[test]\n fn test_index_and_rindex() {\n     assert (str::index(\"hello\", 'e' as u8) == 1);\n     assert (str::index(\"hello\", 'o' as u8) == 4);\n@@ -23,6 +22,7 @@ fn test_index_and_rindex() {\n     assert (str::rindex(\"hello\", 'z' as u8) == -1);\n }\n \n+#[test]\n fn test_split() {\n     fn t(&str s, char c, int i, &str k) {\n         log \"splitting: \" + s;\n@@ -42,6 +42,7 @@ fn test_split() {\n     t(\"...hello.there.\", '.', 5, \"\");\n }\n \n+#[test]\n fn test_find() {\n     fn t(&str haystack, &str needle, int i) {\n         let int j = str::find(haystack, needle);\n@@ -56,6 +57,7 @@ fn test_find() {\n     t(\"this\", \"simple\", -1);\n }\n \n+#[test]\n fn test_substr() {\n     fn t(&str a, &str b, int start) {\n         assert (str::eq(str::substr(a, start as uint, str::byte_len(b)), b));\n@@ -65,6 +67,7 @@ fn test_substr() {\n     t(\"substr should not be a challenge\", \"not\", 14);\n }\n \n+#[test]\n fn test_concat() {\n     fn t(&vec[str] v, &str s) { assert (str::eq(str::concat(v), s)); }\n     t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n@@ -73,6 +76,7 @@ fn test_concat() {\n     t([\"hi\"], \"hi\");\n }\n \n+#[test]\n fn test_connect() {\n     fn t(&vec[str] v, &str sep, &str s) {\n         assert (str::eq(str::connect(v, sep), s));\n@@ -83,6 +87,7 @@ fn test_connect() {\n     t([\"hi\"], \" \", \"hi\");\n }\n \n+#[test]\n fn test_to_upper() {\n     // to_upper doesn't understand unicode yet,\n     // but we need to at least preserve it\n@@ -94,6 +99,7 @@ fn test_to_upper() {\n     assert (str::eq(expected, actual));\n }\n \n+#[test]\n fn test_slice() {\n     assert (str::eq(\"ab\", str::slice(\"abc\", 0u, 2u)));\n     assert (str::eq(\"bc\", str::slice(\"abc\", 1u, 3u)));\n@@ -114,6 +120,7 @@ fn test_slice() {\n                     str::slice(a_million_letter_a(), 0u, 500000u)));\n }\n \n+#[test]\n fn test_ends_with() {\n     assert (str::ends_with(\"\", \"\"));\n     assert (str::ends_with(\"abc\", \"\"));\n@@ -122,16 +129,19 @@ fn test_ends_with() {\n     assert (!str::ends_with(\"\", \"abc\"));\n }\n \n+#[test]\n fn test_is_empty() {\n   assert str::is_empty(\"\");\n   assert !str::is_empty(\"a\");\n }\n \n+#[test]\n fn test_is_not_empty() {\n   assert str::is_not_empty(\"a\");\n   assert !str::is_not_empty(\"\");\n }\n \n+#[test]\n fn test_replace() {\n     auto a = \"a\";\n     check str::is_not_empty(a);\n@@ -145,22 +155,6 @@ fn test_replace() {\n     assert str::replace(\" test test \", test, \"\") == \"   \";\n }\n \n-fn main() {\n-    test_bytes_len();\n-    test_index_and_rindex();\n-    test_split();\n-    test_find();\n-    test_substr();\n-    test_concat();\n-    test_connect();\n-    test_to_upper();\n-    test_slice();\n-    test_ends_with();\n-    test_is_empty();\n-    test_is_not_empty();\n-    test_replace();\n-}\n-\n \n // Local Variables:\n // mode: rust;", "previous_filename": "src/test/run-pass/lib-str.rs"}, {"sha": "0bc005224c205976e2dd8784382260bc4b6e7ad7", "filename": "src/test/stdtest/str_buf.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fstr_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fstr_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr_buf.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -4,7 +4,8 @@\n use std;\n import std::str;\n \n-fn main() {\n+#[test]\n+fn test() {\n     auto s = \"hello\";\n     auto sb = str::buf(s);\n     auto s_cstr = str::str_from_cstr(sb);", "previous_filename": "src/test/run-pass/lib-str-buf.rs"}, {"sha": "b100fc2a9250d25b6349d9689529b4894e0dfbea", "filename": "src/test/stdtest/task.rs", "status": "renamed", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -1,12 +1,11 @@\n-\n-\n-// xfail-stage0\n-\n use std;\n import std::task;\n \n+#[test]\n+#[ignore]\n fn test_sleep() { task::sleep(1000000u); }\n \n+#[test]\n fn test_unsupervise() {\n   fn f() {\n     task::unsupervise();\n@@ -15,6 +14,7 @@ fn test_unsupervise() {\n   spawn f();\n }\n \n+#[test]\n fn test_join() {\n   fn winner() {\n   }\n@@ -32,10 +32,3 @@ fn test_join() {\n \n   assert task::join(failtask) == task::tr_failure;\n }\n-\n-fn main() {\n-  // FIXME: Why aren't we running this?\n-  //test_sleep();\n-  test_unsupervise();\n-  test_join();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-task.rs"}, {"sha": "8b450b8a5ffe527f982d8565cc6600ec552cab1b", "filename": "src/test/stdtest/uint.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fuint.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -4,7 +4,8 @@\n use std;\n import std::uint;\n \n-fn main() {\n+#[test]\n+fn test_next_power_of_two() {\n     assert (uint::next_power_of_two(0u) == 0u);\n     assert (uint::next_power_of_two(1u) == 1u);\n     assert (uint::next_power_of_two(2u) == 2u);", "previous_filename": "src/test/run-pass/lib-uint.rs"}, {"sha": "5e140a783cc13d8186353732415c5d55b133ead6", "filename": "src/test/stdtest/vec.rs", "status": "renamed", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -4,6 +4,7 @@ use std;\n import std::vec::*;\n import std::option;\n \n+#[test]\n fn test_init_elt() {\n     let vec[uint] v = init_elt[uint](5u, 3u);\n     assert (len[uint](v) == 3u);\n@@ -14,6 +15,7 @@ fn test_init_elt() {\n \n fn id(uint x) -> uint { ret x; }\n \n+#[test]\n fn test_init_fn() {\n     let fn(uint) -> uint  op = id;\n     let vec[uint] v = init_fn[uint](op, 5u);\n@@ -25,6 +27,7 @@ fn test_init_fn() {\n     assert (v.(4) == 4u);\n }\n \n+#[test]\n fn test_slice() {\n     let vec[int] v = [1, 2, 3, 4, 5];\n     auto v2 = slice[int](v, 2u, 4u);\n@@ -33,6 +36,7 @@ fn test_slice() {\n     assert (v2.(1) == 4);\n }\n \n+#[test]\n fn test_map() {\n     fn square(&int x) -> int { ret x * x; }\n     let option::operator[int, int] op = square;\n@@ -42,6 +46,7 @@ fn test_map() {\n     while (i < 5) { assert (v.(i) * v.(i) == s.(i)); i += 1; }\n }\n \n+#[test]\n fn test_map2() {\n     fn times(&int x, &int y) -> int { ret x * y; }\n     auto f = times;\n@@ -52,6 +57,7 @@ fn test_map2() {\n     while (i < 5) { assert (v0.(i) * v1.(i) == u.(i)); i += 1; }\n }\n \n+#[test]\n fn test_filter_map() {\n     fn halve(&int i) -> option::t[int] {\n         if (i % 2 == 0) {\n@@ -71,6 +77,7 @@ fn test_filter_map() {\n     assert (filter_map(halve, mix) == mix_dest);\n }\n \n+#[test]\n fn test_position() {\n   let vec[int] v1 = [1, 2, 3, 3, 2, 5];\n   assert (position(1, v1) == option::some[uint](0u));\n@@ -79,6 +86,7 @@ fn test_position() {\n   assert (position(4, v1) == option::none[uint]);\n }\n \n+#[test]\n fn test_position_pred() {\n   fn less_than_three(&int i) -> bool {\n     ret i <3;\n@@ -90,14 +98,3 @@ fn test_position_pred() {\n   assert (position_pred(less_than_three, v1) == option::some[uint](3u));\n   assert (position_pred(is_eighteen, v1) == option::none[uint]);\n }\n-\n-fn main() {\n-    test_init_elt();\n-    test_init_fn();\n-    test_slice();\n-    test_map();\n-    test_map2();\n-    test_filter_map();\n-    test_position();\n-    test_position_pred();\n-}\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-vec.rs"}, {"sha": "dddbb5b21be414adcd8cf90a8c769c853cd290db", "filename": "src/test/stdtest/vec_str_conversions.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2573fe7026eb696841acbba8f3d1c09e2224acf0/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs?ref=2573fe7026eb696841acbba8f3d1c09e2224acf0", "patch": "@@ -5,6 +5,7 @@ use std;\n import std::str;\n import std::vec;\n \n+#[test]\n fn test_simple() {\n     let str s1 = \"All mimsy were the borogoves\";\n     /*\n@@ -31,5 +32,3 @@ fn test_simple() {\n     log \"refcnt is\";\n     log str::refcount(s1);\n }\n-\n-fn main() { test_simple(); }\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/lib-vec-str-conversions.rs"}]}