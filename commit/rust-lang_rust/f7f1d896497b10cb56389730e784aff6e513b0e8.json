{"sha": "f7f1d896497b10cb56389730e784aff6e513b0e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZjFkODk2NDk3YjEwY2I1NjM4OTczMGU3ODRhZmY2ZTUxM2IwZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T01:11:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T01:11:19Z"}, "message": "auto merge of #8607 : sfackler/rust/extensions, r=brson\n\nThe method names in std::rt::io::extensions::WriterByteConversions are\r\nthe same as those in std::io::WriterUtils and a resolve error causes\r\nrustc to fail after trying to find an impl of io::Writer instead of\r\ntrying to look for rt::io::Writer as well.", "tree": {"sha": "67040b364ab6b6e927a0b412ac43b853fc0a88bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67040b364ab6b6e927a0b412ac43b853fc0a88bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7f1d896497b10cb56389730e784aff6e513b0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f1d896497b10cb56389730e784aff6e513b0e8", "html_url": "https://github.com/rust-lang/rust/commit/f7f1d896497b10cb56389730e784aff6e513b0e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7f1d896497b10cb56389730e784aff6e513b0e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "html_url": "https://github.com/rust-lang/rust/commit/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89"}, {"sha": "d6eee6a7d2706e5f027cc000ffbead3bc2cfe76b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6eee6a7d2706e5f027cc000ffbead3bc2cfe76b", "html_url": "https://github.com/rust-lang/rust/commit/d6eee6a7d2706e5f027cc000ffbead3bc2cfe76b"}], "stats": {"total": 245, "additions": 122, "deletions": 123}, "files": [{"sha": "e82662c6b0d2f69edfeb4a0adf13697e565d3894", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 122, "deletions": 123, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/f7f1d896497b10cb56389730e784aff6e513b0e8/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f1d896497b10cb56389730e784aff6e513b0e8/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=f7f1d896497b10cb56389730e784aff6e513b0e8", "patch": "@@ -68,174 +68,174 @@ pub trait ReaderByteConversions {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> u64;\n+    fn read_le_uint_n_(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: uint) -> i64;\n+    fn read_le_int_n_(&mut self, nbytes: uint) -> i64;\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: uint) -> u64;\n+    fn read_be_uint_n_(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: uint) -> i64;\n+    fn read_be_int_n_(&mut self, nbytes: uint) -> i64;\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_le_uint(&mut self) -> uint;\n+    fn read_le_uint_(&mut self) -> uint;\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_le_int(&mut self) -> int;\n+    fn read_le_int_(&mut self) -> int;\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_be_uint(&mut self) -> uint;\n+    fn read_be_uint_(&mut self) -> uint;\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_be_int(&mut self) -> int;\n+    fn read_be_int_(&mut self) -> int;\n \n     /// Reads a big-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    fn read_be_u64(&mut self) -> u64;\n+    fn read_be_u64_(&mut self) -> u64;\n \n     /// Reads a big-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    fn read_be_u32(&mut self) -> u32;\n+    fn read_be_u32_(&mut self) -> u32;\n \n     /// Reads a big-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    fn read_be_u16(&mut self) -> u16;\n+    fn read_be_u16_(&mut self) -> u16;\n \n     /// Reads a big-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    fn read_be_i64(&mut self) -> i64;\n+    fn read_be_i64_(&mut self) -> i64;\n \n     /// Reads a big-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    fn read_be_i32(&mut self) -> i32;\n+    fn read_be_i32_(&mut self) -> i32;\n \n     /// Reads a big-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    fn read_be_i16(&mut self) -> i16;\n+    fn read_be_i16_(&mut self) -> i16;\n \n     /// Reads a big-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64(&mut self) -> f64;\n+    fn read_be_f64_(&mut self) -> f64;\n \n     /// Reads a big-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32(&mut self) -> f32;\n+    fn read_be_f32_(&mut self) -> f32;\n \n     /// Reads a little-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    fn read_le_u64(&mut self) -> u64;\n+    fn read_le_u64_(&mut self) -> u64;\n \n     /// Reads a little-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    fn read_le_u32(&mut self) -> u32;\n+    fn read_le_u32_(&mut self) -> u32;\n \n     /// Reads a little-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    fn read_le_u16(&mut self) -> u16;\n+    fn read_le_u16_(&mut self) -> u16;\n \n     /// Reads a little-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    fn read_le_i64(&mut self) -> i64;\n+    fn read_le_i64_(&mut self) -> i64;\n \n     /// Reads a little-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    fn read_le_i32(&mut self) -> i32;\n+    fn read_le_i32_(&mut self) -> i32;\n \n     /// Reads a little-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    fn read_le_i16(&mut self) -> i16;\n+    fn read_le_i16_(&mut self) -> i16;\n \n     /// Reads a little-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64(&mut self) -> f64;\n+    fn read_le_f64_(&mut self) -> f64;\n \n     /// Reads a little-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32(&mut self) -> f32;\n+    fn read_le_f32_(&mut self) -> f32;\n \n     /// Read a u8.\n     ///\n     /// `u8`s are 1 byte.\n-    fn read_u8(&mut self) -> u8;\n+    fn read_u8_(&mut self) -> u8;\n \n     /// Read an i8.\n     ///\n     /// `i8`s are 1 byte.\n-    fn read_i8(&mut self) -> i8;\n+    fn read_i8_(&mut self) -> i8;\n \n }\n \n pub trait WriterByteConversions {\n     /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(&mut self, n: int);\n+    fn write_int_(&mut self, n: int);\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(&mut self, n: uint);\n+    fn write_uint_(&mut self, n: uint);\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(&mut self, n: uint);\n+    fn write_le_uint_(&mut self, n: uint);\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(&mut self, n: int);\n+    fn write_le_int_(&mut self, n: int);\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(&mut self, n: uint);\n+    fn write_be_uint_(&mut self, n: uint);\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(&mut self, n: int);\n+    fn write_be_int_(&mut self, n: int);\n \n     /// Write a big-endian u64 (8 bytes).\n     fn write_be_u64_(&mut self, n: u64);\n \n     /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(&mut self, n: u32);\n+    fn write_be_u32_(&mut self, n: u32);\n \n     /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(&mut self, n: u16);\n+    fn write_be_u16_(&mut self, n: u16);\n \n     /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(&mut self, n: i64);\n+    fn write_be_i64_(&mut self, n: i64);\n \n     /// Write a big-endian i32 (4 bytes).\n     fn write_be_i32_(&mut self, n: i32);\n \n     /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(&mut self, n: i16);\n+    fn write_be_i16_(&mut self, n: i16);\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64(&mut self, f: f64);\n+    fn write_be_f64_(&mut self, f: f64);\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n     fn write_be_f32_(&mut self, f: f32);\n@@ -244,33 +244,33 @@ pub trait WriterByteConversions {\n     fn write_le_u64_(&mut self, n: u64);\n \n     /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(&mut self, n: u32);\n+    fn write_le_u32_(&mut self, n: u32);\n \n     /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(&mut self, n: u16);\n+    fn write_le_u16_(&mut self, n: u16);\n \n     /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(&mut self, n: i64);\n+    fn write_le_i64_(&mut self, n: i64);\n \n     /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(&mut self, n: i32);\n+    fn write_le_i32_(&mut self, n: i32);\n \n     /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(&mut self, n: i16);\n+    fn write_le_i16_(&mut self, n: i16);\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n-    fn write_le_f64(&mut self, f: f64);\n+    fn write_le_f64_(&mut self, f: f64);\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n     fn write_le_f32_(&mut self, f: f32);\n \n     /// Write a u8 (1 byte).\n-    fn write_u8(&mut self, n: u8);\n+    fn write_u8_(&mut self, n: u8);\n \n     /// Write a i8 (1 byte).\n-    fn write_i8(&mut self, n: i8);\n+    fn write_i8_(&mut self, n: i8);\n }\n \n impl<T: Reader> ReaderUtil for T {\n@@ -340,136 +340,136 @@ impl<T: Reader> ReaderUtil for T {\n }\n \n impl<T: Reader> ReaderByteConversions for T {\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+    fn read_le_uint_n_(&mut self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64;\n         let mut pos = 0;\n         let mut i = nbytes;\n         while i > 0 {\n-            val += (self.read_u8() as u64) << pos;\n+            val += (self.read_u8_() as u64) << pos;\n             pos += 8;\n             i -= 1;\n         }\n         val\n     }\n \n-    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    fn read_le_int_n_(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n_(nbytes), nbytes)\n     }\n \n-    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+    fn read_be_uint_n_(&mut self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64;\n         let mut i = nbytes;\n         while i > 0 {\n             i -= 1;\n-            val += (self.read_u8() as u64) << i * 8;\n+            val += (self.read_u8_() as u64) << i * 8;\n         }\n         val\n     }\n \n-    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    fn read_be_int_n_(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n_(nbytes), nbytes)\n     }\n \n-    fn read_le_uint(&mut self) -> uint {\n-        self.read_le_uint_n(uint::bytes) as uint\n+    fn read_le_uint_(&mut self) -> uint {\n+        self.read_le_uint_n_(uint::bytes) as uint\n     }\n \n-    fn read_le_int(&mut self) -> int {\n-        self.read_le_int_n(int::bytes) as int\n+    fn read_le_int_(&mut self) -> int {\n+        self.read_le_int_n_(int::bytes) as int\n     }\n \n-    fn read_be_uint(&mut self) -> uint {\n-        self.read_be_uint_n(uint::bytes) as uint\n+    fn read_be_uint_(&mut self) -> uint {\n+        self.read_be_uint_n_(uint::bytes) as uint\n     }\n \n-    fn read_be_int(&mut self) -> int {\n-        self.read_be_int_n(int::bytes) as int\n+    fn read_be_int_(&mut self) -> int {\n+        self.read_be_int_n_(int::bytes) as int\n     }\n \n-    fn read_be_u64(&mut self) -> u64 {\n-        self.read_be_uint_n(8) as u64\n+    fn read_be_u64_(&mut self) -> u64 {\n+        self.read_be_uint_n_(8) as u64\n     }\n \n-    fn read_be_u32(&mut self) -> u32 {\n-        self.read_be_uint_n(4) as u32\n+    fn read_be_u32_(&mut self) -> u32 {\n+        self.read_be_uint_n_(4) as u32\n     }\n \n-    fn read_be_u16(&mut self) -> u16 {\n-        self.read_be_uint_n(2) as u16\n+    fn read_be_u16_(&mut self) -> u16 {\n+        self.read_be_uint_n_(2) as u16\n     }\n \n-    fn read_be_i64(&mut self) -> i64 {\n-        self.read_be_int_n(8) as i64\n+    fn read_be_i64_(&mut self) -> i64 {\n+        self.read_be_int_n_(8) as i64\n     }\n \n-    fn read_be_i32(&mut self) -> i32 {\n-        self.read_be_int_n(4) as i32\n+    fn read_be_i32_(&mut self) -> i32 {\n+        self.read_be_int_n_(4) as i32\n     }\n \n-    fn read_be_i16(&mut self) -> i16 {\n-        self.read_be_int_n(2) as i16\n+    fn read_be_i16_(&mut self) -> i16 {\n+        self.read_be_int_n_(2) as i16\n     }\n \n-    fn read_be_f64(&mut self) -> f64 {\n+    fn read_be_f64_(&mut self) -> f64 {\n         unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64())\n+            cast::transmute::<u64, f64>(self.read_be_u64_())\n         }\n     }\n \n-    fn read_be_f32(&mut self) -> f32 {\n+    fn read_be_f32_(&mut self) -> f32 {\n         unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32())\n+            cast::transmute::<u32, f32>(self.read_be_u32_())\n         }\n     }\n \n-    fn read_le_u64(&mut self) -> u64 {\n-        self.read_le_uint_n(8) as u64\n+    fn read_le_u64_(&mut self) -> u64 {\n+        self.read_le_uint_n_(8) as u64\n     }\n \n-    fn read_le_u32(&mut self) -> u32 {\n-        self.read_le_uint_n(4) as u32\n+    fn read_le_u32_(&mut self) -> u32 {\n+        self.read_le_uint_n_(4) as u32\n     }\n \n-    fn read_le_u16(&mut self) -> u16 {\n-        self.read_le_uint_n(2) as u16\n+    fn read_le_u16_(&mut self) -> u16 {\n+        self.read_le_uint_n_(2) as u16\n     }\n \n-    fn read_le_i64(&mut self) -> i64 {\n-        self.read_le_int_n(8) as i64\n+    fn read_le_i64_(&mut self) -> i64 {\n+        self.read_le_int_n_(8) as i64\n     }\n \n-    fn read_le_i32(&mut self) -> i32 {\n-        self.read_le_int_n(4) as i32\n+    fn read_le_i32_(&mut self) -> i32 {\n+        self.read_le_int_n_(4) as i32\n     }\n \n-    fn read_le_i16(&mut self) -> i16 {\n-        self.read_le_int_n(2) as i16\n+    fn read_le_i16_(&mut self) -> i16 {\n+        self.read_le_int_n_(2) as i16\n     }\n \n-    fn read_le_f64(&mut self) -> f64 {\n+    fn read_le_f64_(&mut self) -> f64 {\n         unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64())\n+            cast::transmute::<u64, f64>(self.read_le_u64_())\n         }\n     }\n \n-    fn read_le_f32(&mut self) -> f32 {\n+    fn read_le_f32_(&mut self) -> f32 {\n         unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32())\n+            cast::transmute::<u32, f32>(self.read_le_u32_())\n         }\n     }\n \n-    fn read_u8(&mut self) -> u8 {\n+    fn read_u8_(&mut self) -> u8 {\n         match self.read_byte() {\n             Some(b) => b as u8,\n             None => 0\n         }\n     }\n \n-    fn read_i8(&mut self) -> i8 {\n+    fn read_i8_(&mut self) -> i8 {\n         match self.read_byte() {\n             Some(b) => b as i8,\n             None => 0\n@@ -479,107 +479,107 @@ impl<T: Reader> ReaderByteConversions for T {\n }\n \n impl<T: Writer> WriterByteConversions for T {\n-    fn write_int(&mut self, n: int) {\n+    fn write_int_(&mut self, n: int) {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n \n-    fn write_uint(&mut self, n: uint) {\n+    fn write_uint_(&mut self, n: uint) {\n         uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n \n-    fn write_le_uint(&mut self, n: uint) {\n+    fn write_le_uint_(&mut self, n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n     }\n \n-    fn write_le_int(&mut self, n: int) {\n+    fn write_le_int_(&mut self, n: int) {\n         u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n     }\n \n-    fn write_be_uint(&mut self, n: uint) {\n+    fn write_be_uint_(&mut self, n: uint) {\n         u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n     }\n \n-    fn write_be_int(&mut self, n: int) {\n+    fn write_be_int_(&mut self, n: int) {\n         u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n     }\n \n     fn write_be_u64_(&mut self, n: u64) {\n         u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n \n-    fn write_be_u32(&mut self, n: u32) {\n+    fn write_be_u32_(&mut self, n: u32) {\n         u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n-    fn write_be_u16(&mut self, n: u16) {\n+    fn write_be_u16_(&mut self, n: u16) {\n         u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_be_i64(&mut self, n: i64) {\n+    fn write_be_i64_(&mut self, n: i64) {\n         u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     fn write_be_i32_(&mut self, n: i32) {\n         u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n-    fn write_be_i16(&mut self, n: i16) {\n+    fn write_be_i16_(&mut self, n: i16) {\n         u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_be_f64(&mut self, f: f64) {\n+    fn write_be_f64_(&mut self, f: f64) {\n         unsafe {\n             self.write_be_u64_(cast::transmute(f))\n         }\n     }\n \n     fn write_be_f32_(&mut self, f: f32) {\n         unsafe {\n-            self.write_be_u32(cast::transmute(f))\n+            self.write_be_u32_(cast::transmute(f))\n         }\n     }\n \n     fn write_le_u64_(&mut self, n: u64) {\n         u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n \n-    fn write_le_u32(&mut self, n: u32) {\n+    fn write_le_u32_(&mut self, n: u32) {\n         u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n-    fn write_le_u16(&mut self, n: u16) {\n+    fn write_le_u16_(&mut self, n: u16) {\n         u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_le_i64(&mut self, n: i64) {\n+    fn write_le_i64_(&mut self, n: i64) {\n         u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n-    fn write_le_i32(&mut self, n: i32) {\n+    fn write_le_i32_(&mut self, n: i32) {\n         u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n-    fn write_le_i16(&mut self, n: i16) {\n+    fn write_le_i16_(&mut self, n: i16) {\n         u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_le_f64(&mut self, f: f64) {\n+    fn write_le_f64_(&mut self, f: f64) {\n         unsafe {\n             self.write_le_u64_(cast::transmute(f))\n         }\n     }\n \n     fn write_le_f32_(&mut self, f: f32) {\n         unsafe {\n-            self.write_le_u32(cast::transmute(f))\n+            self.write_le_u32_(cast::transmute(f))\n         }\n     }\n \n-    fn write_u8(&mut self, n: u8) {\n+    fn write_u8_(&mut self, n: u8) {\n         self.write([n])\n     }\n \n-    fn write_i8(&mut self, n: i8) {\n+    fn write_i8_(&mut self, n: i8) {\n         self.write([n as u8])\n     }\n }\n@@ -825,7 +825,6 @@ mod test {\n         assert!(buf == ~[10, 11]);\n     }\n \n-\n     #[test]\n     fn test_read_write_le_mem() {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n@@ -837,7 +836,7 @@ mod test {\n \n         let mut reader = MemReader::new(writer.inner());\n         for i in uints.iter() {\n-            assert!(reader.read_le_u64() == *i);\n+            assert!(reader.read_le_u64_() == *i);\n         }\n     }\n \n@@ -853,7 +852,7 @@ mod test {\n \n         let mut reader = MemReader::new(writer.inner());\n         for i in uints.iter() {\n-            assert!(reader.read_be_u64() == *i);\n+            assert!(reader.read_be_u64_() == *i);\n         }\n     }\n \n@@ -870,7 +869,7 @@ mod test {\n         for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n(4) == *i as i64);\n+            assert!(reader.read_be_int_n_(4) == *i as i64);\n         }\n     }\n \n@@ -883,7 +882,7 @@ mod test {\n         writer.write(buf);\n \n         let mut reader = MemReader::new(writer.inner());\n-        let f = reader.read_be_f32();\n+        let f = reader.read_be_f32_();\n         assert!(f == 8.1250);\n     }\n \n@@ -896,8 +895,8 @@ mod test {\n         writer.write_le_f32_(f);\n \n         let mut reader = MemReader::new(writer.inner());\n-        assert!(reader.read_be_f32() == 8.1250);\n-        assert!(reader.read_le_f32() == 8.1250);\n+        assert!(reader.read_be_f32_() == 8.1250);\n+        assert!(reader.read_le_f32_() == 8.1250);\n     }\n \n }"}]}