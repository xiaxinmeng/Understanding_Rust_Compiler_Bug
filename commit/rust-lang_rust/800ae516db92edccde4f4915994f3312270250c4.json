{"sha": "800ae516db92edccde4f4915994f3312270250c4", "node_id": "C_kwDOAAsO6NoAKDgwMGFlNTE2ZGI5MmVkY2NkZTRmNDkxNTk5NGYzMzEyMjcwMjUwYzQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-22T15:17:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-22T15:17:50Z"}, "message": "Merge #11788\n\n11788: internal: Improve `find_path` and extern prelude handling r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "9a8d29fb9cc73c1905d01484e4f0c6a1f85fd11e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a8d29fb9cc73c1905d01484e4f0c6a1f85fd11e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/800ae516db92edccde4f4915994f3312270250c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiOeieCRBK7hj4Ov3rIwAA/JsIAB3lNL/XJ08IgSzlpaiZIFVk\nyZratTQOvjMjLwjlhsMsIwQ5GTF/wAsmKssyru2ilJLfsa3z8scAe18L71bEwvUf\n5tDBDi0Kow/5Iw0A0LKHWmA+LxdeA+gcEJaYeinJvwEwuJJZdZah/TxnsZ5hGK4o\nvkx0wq0YHJ/FLtnriEAoaUY6WUw/zgTeblNK+tdiHyYmQbGeLXL4IebIZhc3cPop\nuSSWsL+laPx3I4i2fJdLnY5elQopIDj3+uXskzgDIwsgcFFG+SE2PEyy32sro00t\n2GmR9qsCCv6Z1Ru/DwoX8WpCRzFArW4mehZb7t836MCHS6eqX6KBRp/MAprcyHM=\n=Ev8e\n-----END PGP SIGNATURE-----\n", "payload": "tree 9a8d29fb9cc73c1905d01484e4f0c6a1f85fd11e\nparent 98d1724cb0e4445c7b16a1fca909c83f539c8a72\nparent cb1b7e18fef9af18c12eed70cd63187f70b992a5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647962270 +0000\ncommitter GitHub <noreply@github.com> 1647962270 +0000\n\nMerge #11788\n\n11788: internal: Improve `find_path` and extern prelude handling r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/800ae516db92edccde4f4915994f3312270250c4", "html_url": "https://github.com/rust-lang/rust/commit/800ae516db92edccde4f4915994f3312270250c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/800ae516db92edccde4f4915994f3312270250c4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98d1724cb0e4445c7b16a1fca909c83f539c8a72", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d1724cb0e4445c7b16a1fca909c83f539c8a72", "html_url": "https://github.com/rust-lang/rust/commit/98d1724cb0e4445c7b16a1fca909c83f539c8a72"}, {"sha": "cb1b7e18fef9af18c12eed70cd63187f70b992a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1b7e18fef9af18c12eed70cd63187f70b992a5", "html_url": "https://github.com/rust-lang/rust/commit/cb1b7e18fef9af18c12eed70cd63187f70b992a5"}], "stats": {"total": 196, "additions": 103, "deletions": 93}, "files": [{"sha": "bb89b8cff4493b00b954ff67414771fc750ff797", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=800ae516db92edccde4f4915994f3312270250c4", "patch": "@@ -18,8 +18,7 @@ use crate::{\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     let _p = profile::span(\"find_path\");\n-    let mut visited_modules = FxHashSet::default();\n-    find_path_inner(db, item, from, MAX_PATH_LEN, None, &mut visited_modules)\n+    find_path_inner(db, item, from, None)\n }\n \n pub fn find_path_prefixed(\n@@ -29,8 +28,7 @@ pub fn find_path_prefixed(\n     prefix_kind: PrefixKind,\n ) -> Option<ModPath> {\n     let _p = profile::span(\"find_path_prefixed\");\n-    let mut visited_modules = FxHashSet::default();\n-    find_path_inner(db, item, from, MAX_PATH_LEN, Some(prefix_kind), &mut visited_modules)\n+    find_path_inner(db, item, from, Some(prefix_kind))\n }\n \n const MAX_PATH_LEN: usize = 15;\n@@ -56,12 +54,12 @@ impl ModPathExt for ModPath {\n fn check_self_super(def_map: &DefMap, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     if item == ItemInNs::Types(from.into()) {\n         // - if the item is the module we're in, use `self`\n-        Some(ModPath::from_segments(PathKind::Super(0), Vec::new()))\n+        Some(ModPath::from_segments(PathKind::Super(0), None))\n     } else if let Some(parent_id) = def_map[from.local_id].parent {\n         // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n         let parent_id = def_map.module_id(parent_id);\n         if item == ItemInNs::Types(ModuleDefId::ModuleId(parent_id)) {\n-            Some(ModPath::from_segments(PathKind::Super(1), Vec::new()))\n+            Some(ModPath::from_segments(PathKind::Super(1), None))\n         } else {\n             None\n         }\n@@ -97,12 +95,25 @@ impl PrefixKind {\n         self == &PrefixKind::ByCrate\n     }\n }\n-\n /// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId\n fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n+    prefixed: Option<PrefixKind>,\n+) -> Option<ModPath> {\n+    // FIXME: Do fast path for std/core libs?\n+\n+    let mut visited_modules = FxHashSet::default();\n+    let def_map = from.def_map(db);\n+    find_path_inner_(db, &def_map, from, item, MAX_PATH_LEN, prefixed, &mut visited_modules)\n+}\n+\n+fn find_path_inner_(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    from: ModuleId,\n+    item: ItemInNs,\n     max_len: usize,\n     mut prefixed: Option<PrefixKind>,\n     visited_modules: &mut FxHashSet<ModuleId>,\n@@ -114,19 +125,24 @@ fn find_path_inner(\n     // Base cases:\n \n     // - if the item is already in scope, return the name under which it is\n-    let def_map = from.def_map(db);\n     let scope_name = def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n         def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n     });\n-    if prefixed.is_none() && scope_name.is_some() {\n-        return scope_name\n-            .map(|scope_name| ModPath::from_segments(PathKind::Plain, vec![scope_name]));\n+    if prefixed.is_none() {\n+        if let Some(scope_name) = scope_name {\n+            return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n+        }\n+    }\n+\n+    // - if the item is a builtin, it's in scope\n+    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n+        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n     }\n \n     // - if the item is the crate root, return `crate`\n-    let root = def_map.crate_root(db);\n-    if item == ItemInNs::Types(ModuleDefId::ModuleId(root)) {\n-        return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n+    let crate_root = def_map.crate_root(db);\n+    if item == ItemInNs::Types(ModuleDefId::ModuleId(crate_root)) {\n+        return Some(ModPath::from_segments(PathKind::Crate, None));\n     }\n \n     if prefixed.filter(PrefixKind::is_absolute).is_none() {\n@@ -136,46 +152,43 @@ fn find_path_inner(\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n-    let root_def_map = root.def_map(db);\n-    for (name, def_id) in root_def_map.extern_prelude() {\n-        if item == ItemInNs::Types(*def_id) {\n-            let name = scope_name.unwrap_or_else(|| name.clone());\n-\n-            let name_already_occupied_in_type_ns = def_map\n-                .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-                    def_map[local_id].scope.get(&name).take_types().filter(|&id| id != *def_id)\n-                })\n-                .is_some();\n-            return Some(ModPath::from_segments(\n-                if name_already_occupied_in_type_ns {\n+    let root_def_map = crate_root.def_map(db);\n+    if let ItemInNs::Types(ModuleDefId::ModuleId(item)) = item {\n+        for (name, &def_id) in root_def_map.extern_prelude() {\n+            if item == def_id {\n+                let name = scope_name.unwrap_or_else(|| name.clone());\n+\n+                let name_already_occupied_in_type_ns = def_map\n+                    .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+                        def_map[local_id]\n+                            .scope\n+                            .type_(&name)\n+                            .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n+                    })\n+                    .is_some();\n+                let kind = if name_already_occupied_in_type_ns {\n                     cov_mark::hit!(ambiguous_crate_start);\n                     PathKind::Abs\n                 } else {\n                     PathKind::Plain\n-                },\n-                vec![name],\n-            ));\n+                };\n+                return Some(ModPath::from_segments(kind, Some(name)));\n+            }\n         }\n     }\n \n     // - if the item is in the prelude, return the name from there\n     if let Some(prelude_module) = root_def_map.prelude() {\n         // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n         let prelude_def_map = prelude_module.def_map(db);\n-        let prelude_scope: &crate::item_scope::ItemScope =\n-            &prelude_def_map[prelude_module.local_id].scope;\n+        let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n             if vis.is_visible_from(db, from) {\n-                return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n+                return Some(ModPath::from_segments(PathKind::Plain, Some(name.clone())));\n             }\n         }\n     }\n \n-    // - if the item is a builtin, it's in scope\n-    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n-        return Some(ModPath::from_segments(PathKind::Plain, vec![builtin.as_name()]));\n-    }\n-\n     // Recursive case:\n     // - if the item is an enum variant, refer to it via the enum\n     if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n@@ -190,25 +203,24 @@ fn find_path_inner(\n     }\n \n     // - otherwise, look for modules containing (reexporting) it and import it from one of those\n-\n-    let crate_root = def_map.crate_root(db);\n-    let crate_attrs = db.attrs(crate_root.into());\n-    let prefer_no_std = crate_attrs.by_key(\"no_std\").exists();\n+    let prefer_no_std = db.attrs(crate_root.into()).by_key(\"no_std\").exists();\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n \n     if item.krate(db) == Some(from.krate) {\n         // Item was defined in the same crate that wants to import it. It cannot be found in any\n         // dependency in this case.\n+        // FIXME: this should have a fast path that doesn't look through the prelude again?\n         for (module_id, name) in find_local_import_locations(db, item, from) {\n             if !visited_modules.insert(module_id) {\n                 cov_mark::hit!(recursive_imports);\n                 continue;\n             }\n-            if let Some(mut path) = find_path_inner(\n+            if let Some(mut path) = find_path_inner_(\n                 db,\n-                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                def_map,\n                 from,\n+                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n                 best_path_len - 1,\n                 prefixed,\n                 visited_modules,\n@@ -233,16 +245,18 @@ fn find_path_inner(\n             let import_map = db.import_map(dep.crate_id);\n             import_map.import_info_for(item).and_then(|info| {\n                 // Determine best path for containing module and append last segment from `info`.\n-                let mut path = find_path_inner(\n+                // FIXME: we should guide this to look up the path locally, or from the same crate again?\n+                let mut path = find_path_inner_(\n                     db,\n-                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n+                    def_map,\n                     from,\n+                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n                     best_path_len - 1,\n                     prefixed,\n                     visited_modules,\n                 )?;\n                 cov_mark::hit!(partially_imported);\n-                path.push_segment(info.path.segments.last().unwrap().clone());\n+                path.push_segment(info.path.segments.last()?.clone());\n                 Some(path)\n             })\n         });\n@@ -267,7 +281,7 @@ fn find_path_inner(\n \n     match prefixed.map(PrefixKind::prefix) {\n         Some(prefix) => best_path.or_else(|| {\n-            scope_name.map(|scope_name| ModPath::from_segments(prefix, vec![scope_name]))\n+            scope_name.map(|scope_name| ModPath::from_segments(prefix, Some(scope_name)))\n         }),\n         None => best_path,\n     }\n@@ -370,8 +384,8 @@ fn find_local_import_locations(\n         }\n \n         // Descend into all modules visible from `from`.\n-        for (_, per_ns) in data.scope.entries() {\n-            if let Some((ModuleDefId::ModuleId(module), vis)) = per_ns.take_types_vis() {\n+        for (ty, vis) in data.scope.types() {\n+            if let ModuleDefId::ModuleId(module) = ty {\n                 if vis.is_visible_from(db, from) {\n                     worklist.push(module);\n                 }\n@@ -415,15 +429,7 @@ mod tests {\n             .take_types()\n             .unwrap();\n \n-        let mut visited_modules = FxHashSet::default();\n-        let found_path = find_path_inner(\n-            &db,\n-            ItemInNs::Types(resolved),\n-            module,\n-            MAX_PATH_LEN,\n-            prefix_kind,\n-            &mut visited_modules,\n-        );\n+        let found_path = find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind);\n         assert_eq!(found_path, Some(mod_path), \"{:?}\", prefix_kind);\n     }\n "}, {"sha": "0096df2288d42b43312aeda210820ea75d3b23e7", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=800ae516db92edccde4f4915994f3312270250c4", "patch": "@@ -119,6 +119,12 @@ impl ItemScope {\n         self.values.values().copied()\n     }\n \n+    pub fn types(\n+        &self,\n+    ) -> impl Iterator<Item = (ModuleDefId, Visibility)> + ExactSizeIterator + '_ {\n+        self.types.values().copied()\n+    }\n+\n     pub fn unnamed_consts(&self) -> impl Iterator<Item = ConstId> + '_ {\n         self.unnamed_consts.iter().copied()\n     }\n@@ -142,6 +148,10 @@ impl ItemScope {\n         }\n     }\n \n+    pub(crate) fn type_(&self, name: &Name) -> Option<(ModuleDefId, Visibility)> {\n+        self.types.get(name).copied()\n+    }\n+\n     /// XXX: this is O(N) rather than O(1), try to not introduce new usages.\n     pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n         let (def, mut iter) = match item {"}, {"sha": "e923d883ecf4c2147f8fe1dcb049d2eda98c11ef", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=800ae516db92edccde4f4915994f3312270250c4", "patch": "@@ -75,7 +75,7 @@ use crate::{\n     path::ModPath,\n     per_ns::PerNs,\n     visibility::Visibility,\n-    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, ModuleDefId, ModuleId, ProcMacroId,\n+    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, ModuleId, ProcMacroId,\n };\n \n /// Contains the results of (early) name resolution.\n@@ -98,7 +98,7 @@ pub struct DefMap {\n     /// marked with the `prelude_import` attribute, or (in the normal case) from\n     /// a dependency (`std` or `core`).\n     prelude: Option<ModuleId>,\n-    extern_prelude: FxHashMap<Name, ModuleDefId>,\n+    extern_prelude: FxHashMap<Name, ModuleId>,\n \n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n@@ -318,7 +318,7 @@ impl DefMap {\n         self.prelude\n     }\n \n-    pub(crate) fn extern_prelude(&self) -> impl Iterator<Item = (&Name, &ModuleDefId)> + '_ {\n+    pub(crate) fn extern_prelude(&self) -> impl Iterator<Item = (&Name, &ModuleId)> + '_ {\n         self.extern_prelude.iter()\n     }\n "}, {"sha": "ea29f8043734499bb2bf44c76f6ac34752213f35", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=800ae516db92edccde4f4915994f3312270250c4", "patch": "@@ -70,7 +70,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         deps.insert(dep.as_name(), dep_root.into());\n \n         if dep.is_prelude() && !tree_id.is_block() {\n-            def_map.extern_prelude.insert(dep.as_name(), dep_root.into());\n+            def_map.extern_prelude.insert(dep.as_name(), dep_root);\n         }\n     }\n \n@@ -234,7 +234,7 @@ enum MacroDirectiveKind {\n struct DefCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def_map: DefMap,\n-    deps: FxHashMap<Name, ModuleDefId>,\n+    deps: FxHashMap<Name, ModuleId>,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n@@ -687,9 +687,7 @@ impl DefCollector<'_> {\n             self.def_map.edition,\n         );\n \n-        let res = self.resolve_extern_crate(&extern_crate.name);\n-\n-        if let Some(ModuleDefId::ModuleId(m)) = res.take_types() {\n+        if let Some(m) = self.resolve_extern_crate(&extern_crate.name) {\n             if m == self.def_map.module_id(current_module_id) {\n                 cov_mark::hit!(ignore_macro_use_extern_crate_self);\n                 return;\n@@ -757,10 +755,11 @@ impl DefCollector<'_> {\n \n             let res = self.resolve_extern_crate(name);\n \n-            if res.is_none() {\n-                PartialResolvedImport::Unresolved\n-            } else {\n-                PartialResolvedImport::Resolved(res)\n+            match res {\n+                Some(res) => {\n+                    PartialResolvedImport::Resolved(PerNs::types(res.into(), Visibility::Public))\n+                }\n+                None => PartialResolvedImport::Unresolved,\n             }\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n@@ -796,7 +795,7 @@ impl DefCollector<'_> {\n         }\n     }\n \n-    fn resolve_extern_crate(&self, name: &Name) -> PerNs {\n+    fn resolve_extern_crate(&self, name: &Name) -> Option<ModuleId> {\n         if *name == name!(self) {\n             cov_mark::hit!(extern_crate_self_as);\n             let root = match self.def_map.block {\n@@ -806,9 +805,9 @@ impl DefCollector<'_> {\n                 }\n                 None => self.def_map.module_id(self.def_map.root()),\n             };\n-            PerNs::types(root.into(), Visibility::Public)\n+            Some(root)\n         } else {\n-            self.deps.get(name).map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public))\n+            self.deps.get(name).copied()\n         }\n     }\n \n@@ -846,7 +845,8 @@ impl DefCollector<'_> {\n \n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                 if import.is_extern_crate && module_id == self.def_map.root {\n-                    if let (Some(def), Some(name)) = (def.take_types(), name) {\n+                    if let (Some(ModuleDefId::ModuleId(def)), Some(name)) = (def.take_types(), name)\n+                    {\n                         self.def_map.extern_prelude.insert(name.clone(), def);\n                     }\n                 }"}, {"sha": "cc5fc0a52a1f4c38915bd14084c84209f8917d80", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=800ae516db92edccde4f4915994f3312270250c4", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n-    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId,\n+    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -63,19 +63,11 @@ impl DefMap {\n         &self,\n         db: &dyn DefDatabase,\n         name: &Name,\n-    ) -> PerNs {\n-        let arc;\n-        let root = match self.block {\n-            Some(_) => {\n-                arc = self.crate_root(db).def_map(db);\n-                &*arc\n-            }\n-            None => self,\n-        };\n-\n-        root.extern_prelude\n-            .get(name)\n-            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public))\n+    ) -> Option<ModuleId> {\n+        match self.block {\n+            Some(_) => self.crate_root(db).def_map(db).extern_prelude.get(name).copied(),\n+            None => self.extern_prelude.get(name).copied(),\n+        }\n     }\n \n     pub(crate) fn resolve_visibility(\n@@ -273,9 +265,9 @@ impl DefMap {\n                     Some((_, segment)) => segment,\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n-                if let Some(def) = self.extern_prelude.get(segment) {\n+                if let Some(&def) = self.extern_prelude.get(segment) {\n                     tracing::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def, Visibility::Public)\n+                    PerNs::types(def.into(), Visibility::Public)\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n@@ -408,7 +400,7 @@ impl DefMap {\n         let from_extern_prelude = self\n             .extern_prelude\n             .get(name)\n-            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public));\n+            .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public));\n \n         let from_prelude = self.resolve_in_prelude(db, name);\n \n@@ -429,7 +421,9 @@ impl DefMap {\n             None => self,\n         };\n         let from_crate_root = crate_def_map[crate_def_map.root].scope.get(name);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(db, name);\n+        let from_extern_prelude = self\n+            .resolve_name_in_extern_prelude(db, name)\n+            .map_or(PerNs::none(), |it| PerNs::types(it.into(), Visibility::Public));\n \n         from_crate_root.or(from_extern_prelude)\n     }"}, {"sha": "ab99627d182b9d9899ecea7cc946040e0729fd05", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ae516db92edccde4f4915994f3312270250c4/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=800ae516db92edccde4f4915994f3312270250c4", "patch": "@@ -498,7 +498,7 @@ impl Scope {\n                     acc.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n                 });\n                 m.def_map.extern_prelude().for_each(|(name, &def)| {\n-                    acc.add(name, ScopeDef::ModuleDef(def));\n+                    acc.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n                 });\n                 BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n                     acc.add_per_ns(name, def);"}]}