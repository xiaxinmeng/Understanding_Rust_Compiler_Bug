{"sha": "a0643ee9ae5726edaa382a1a125319688477ec98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNjQzZWU5YWU1NzI2ZWRhYTM4MmExYTEyNTMxOTY4ODQ3N2VjOTg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-06T13:14:37Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-07T13:31:23Z"}, "message": "std::trie: add an mutable-values iterator.", "tree": {"sha": "e92f45273f71ae639652e6cfb06c9e90eb25121b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e92f45273f71ae639652e6cfb06c9e90eb25121b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0643ee9ae5726edaa382a1a125319688477ec98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0643ee9ae5726edaa382a1a125319688477ec98", "html_url": "https://github.com/rust-lang/rust/commit/a0643ee9ae5726edaa382a1a125319688477ec98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0643ee9ae5726edaa382a1a125319688477ec98/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f1838ea3e6795487521d4541bbd877d8e0797b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f1838ea3e6795487521d4541bbd877d8e0797b8", "html_url": "https://github.com/rust-lang/rust/commit/1f1838ea3e6795487521d4541bbd877d8e0797b8"}], "stats": {"total": 168, "additions": 168, "deletions": 0}, "files": [{"sha": "b66472c72cb7d6338ff6b96a112841b3057f5449", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/a0643ee9ae5726edaa382a1a125319688477ec98/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0643ee9ae5726edaa382a1a125319688477ec98/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=a0643ee9ae5726edaa382a1a125319688477ec98", "patch": "@@ -156,6 +156,16 @@ impl<T> TrieMap<T> {\n         }\n     }\n \n+    /// Get an iterator over the key-value pairs in the map, with the\n+    /// ability to mutate the values.\n+    pub fn mut_iter<'a>(&'a mut self) -> TrieMapMutIterator<'a, T> {\n+        TrieMapMutIterator {\n+            stack: ~[self.root.children.mut_iter()],\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n+\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n@@ -202,6 +212,63 @@ impl<T> TrieMap<T> {\n     pub fn upper_bound<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n         self.bound(key, true)\n     }\n+    // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[inline]\n+    fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> TrieMapMutIterator<'a, T> {\n+        // we need an unsafe pointer here because we are borrowing\n+        // references to the internals of each of these\n+        // nodes.\n+        //\n+        // However, we're allowed to flaunt rustc like this because we\n+        // never actually modify the \"shape\" of the nodes. The only\n+        // place that mutation is can actually occur is of the actual\n+        // values of the TrieMap (as the return value of the\n+        // iterator), i.e. we can never cause a deallocation of any\n+        // TrieNodes so this pointer is always valid.\n+        let mut node = &mut self.root as *mut TrieNode<T>;\n+\n+        let mut idx = 0;\n+        let mut it = TrieMapMutIterator {\n+            stack: ~[],\n+            remaining_min: 0,\n+            remaining_max: self.length\n+        };\n+        loop {\n+            let children = unsafe {&mut (*node).children};\n+            let child_id = chunk(key, idx);\n+            match children[child_id] {\n+                Internal(ref mut n) => {\n+                    node = &mut **n as *mut TrieNode<T>;\n+                }\n+                External(stored, _) => {\n+                    if stored < key || (upper && stored == key) {\n+                        it.stack.push(children.mut_slice_from(child_id + 1).mut_iter());\n+                    } else {\n+                        it.stack.push(children.mut_slice_from(child_id).mut_iter());\n+                    }\n+                    return it;\n+                }\n+                Nothing => {\n+                    it.stack.push(children.mut_slice_from(child_id + 1).mut_iter());\n+                    return it\n+                }\n+            }\n+            it.stack.push(children.mut_slice_from(child_id + 1).mut_iter());\n+            idx += 1;\n+        }\n+    }\n+\n+    /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n+    /// If all keys in the map are less than `key` an empty iterator is returned.\n+    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> TrieMapMutIterator<'a, T> {\n+        self.mut_bound(key, false)\n+    }\n+\n+    /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n+    /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> TrieMapMutIterator<'a, T> {\n+        self.mut_bound(key, true)\n+    }\n }\n \n impl<T> FromIterator<(uint, T)> for TrieMap<T> {\n@@ -482,6 +549,47 @@ impl<'a, T> Iterator<(uint, &'a T)> for TrieMapIterator<'a, T> {\n     }\n }\n \n+/// Forward iterator over the key-value pairs of a map, with the\n+/// values being mutable.\n+pub struct TrieMapMutIterator<'a, T> {\n+    priv stack: ~[vec::VecMutIterator<'a, Child<T>>],\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n+}\n+\n+impl<'a, T> Iterator<(uint, &'a mut T)> for TrieMapMutIterator<'a, T> {\n+    fn next(&mut self) -> Option<(uint, &'a mut T)> {\n+        while !self.stack.is_empty() {\n+            match self.stack[self.stack.len() - 1].next() {\n+                None => {\n+                    self.stack.pop();\n+                }\n+                Some(child) => {\n+                    match *child {\n+                        Internal(ref mut node) => {\n+                            self.stack.push(node.children.mut_iter());\n+                        }\n+                        External(key, ref mut value) => {\n+                            self.remaining_max -= 1;\n+                            if self.remaining_min > 0 {\n+                                self.remaining_min -= 1;\n+                            }\n+                            return Some((key, value));\n+                        }\n+                        Nothing => {}\n+                    }\n+                }\n+            }\n+        }\n+        return None;\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.remaining_min, Some(self.remaining_max))\n+    }\n+}\n+\n /// Forward iterator over a set\n pub struct TrieSetIterator<'a> {\n     priv iter: TrieMapIterator<'a, ()>\n@@ -712,6 +820,30 @@ mod test_map {\n         assert_eq!(i, last - first);\n     }\n \n+    #[test]\n+    fn test_mut_iter() {\n+        let mut empty_map : TrieMap<uint> = TrieMap::new();\n+        assert!(empty_map.mut_iter().next().is_none());\n+\n+        let first = uint::max_value - 10000;\n+        let last = uint::max_value;\n+\n+        let mut map = TrieMap::new();\n+        for x in range(first, last).invert() {\n+            map.insert(x, x / 2);\n+        }\n+\n+        let mut i = 0;\n+        for (k, v) in map.mut_iter() {\n+            assert_eq!(k, first + i);\n+            *v -= k / 2;\n+            i += 1;\n+        }\n+        assert_eq!(i, last - first);\n+\n+        assert!(map.iter().all(|(_, &v)| v == 0));\n+    }\n+\n     #[test]\n     fn test_bound() {\n         let empty_map : TrieMap<uint> = TrieMap::new();\n@@ -753,6 +885,42 @@ mod test_map {\n             assert_eq!(ub.next(), None);\n         }\n     }\n+\n+    #[test]\n+    fn test_mut_bound() {\n+        let empty_map : TrieMap<uint> = TrieMap::new();\n+        assert_eq!(empty_map.lower_bound(0).next(), None);\n+        assert_eq!(empty_map.upper_bound(0).next(), None);\n+\n+        let mut m_lower = TrieMap::new();\n+        let mut m_upper = TrieMap::new();\n+        for i in range(0u, 100) {\n+            m_lower.insert(2 * i, 4 * i);\n+            m_upper.insert(2 * i, 4 * i);\n+        }\n+\n+        for i in range(0u, 199) {\n+            let mut lb_it = m_lower.mut_lower_bound(i);\n+            let (k, v) = lb_it.next().unwrap();\n+            let lb = i + i % 2;\n+            assert_eq!(lb, k);\n+            *v -= k;\n+        }\n+\n+        for i in range(0u, 198) {\n+            let mut ub_it = m_upper.mut_upper_bound(i);\n+            let (k, v) = ub_it.next().unwrap();\n+            let ub = i + 2 - i % 2;\n+            assert_eq!(ub, k);\n+            *v -= k;\n+        }\n+\n+        assert!(m_lower.mut_lower_bound(199).next().is_none());\n+        assert!(m_upper.mut_upper_bound(198).next().is_none());\n+\n+        assert!(m_lower.iter().all(|(_, &x)| x == 0));\n+        assert!(m_upper.iter().all(|(_, &x)| x == 0));\n+    }\n }\n \n #[cfg(test)]"}]}