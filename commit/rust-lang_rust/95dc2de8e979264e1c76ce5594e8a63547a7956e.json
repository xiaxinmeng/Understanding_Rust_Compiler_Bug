{"sha": "95dc2de8e979264e1c76ce5594e8a63547a7956e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZGMyZGU4ZTk3OTI2NGUxYzc2Y2U1NTk0ZThhNjM1NDdhNzk1NmU=", "commit": {"author": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2019-12-13T11:44:07Z"}, "committer": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2019-12-13T11:45:37Z"}, "message": "Add helper for resolving associated type of trait in infer", "tree": {"sha": "1394f8a25960fd676301bde2273acd5753c96d45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1394f8a25960fd676301bde2273acd5753c96d45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95dc2de8e979264e1c76ce5594e8a63547a7956e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95dc2de8e979264e1c76ce5594e8a63547a7956e", "html_url": "https://github.com/rust-lang/rust/commit/95dc2de8e979264e1c76ce5594e8a63547a7956e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95dc2de8e979264e1c76ce5594e8a63547a7956e/comments", "author": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16cf6bcf4b614a7a1a3a3f3659f7bb3df7cff086", "url": "https://api.github.com/repos/rust-lang/rust/commits/16cf6bcf4b614a7a1a3a3f3659f7bb3df7cff086", "html_url": "https://github.com/rust-lang/rust/commit/16cf6bcf4b614a7a1a3a3f3659f7bb3df7cff086"}], "stats": {"total": 72, "additions": 25, "deletions": 47}, "files": [{"sha": "62d5c8803cc63d66e32c539dcecf6a56fe7849ee", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95dc2de8e979264e1c76ce5594e8a63547a7956e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc2de8e979264e1c76ce5594e8a63547a7956e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=95dc2de8e979264e1c76ce5594e8a63547a7956e", "patch": "@@ -338,6 +338,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.table.resolve_ty_shallow(ty)\n     }\n \n+    fn resolve_associated_type(&mut self, inner_ty: Ty, assoc_ty: Option<TypeAliasId>) -> Ty {\n+        match assoc_ty {\n+            Some(res_assoc_ty) => {\n+                let ty = self.table.new_type_var();\n+                let projection = ProjectionPredicate {\n+                    ty: ty.clone(),\n+                    projection_ty: ProjectionTy {\n+                        associated_ty: res_assoc_ty,\n+                        parameters: Substs::single(inner_ty),\n+                    },\n+                };\n+                self.obligations.push(Obligation::Projection(projection));\n+                self.resolve_ty_as_possible(ty)\n+            }\n+            None => Ty::Unknown,\n+        }\n+    }\n+\n     /// Recurses through the given type, normalizing associated types mentioned\n     /// in it by replacing them by type variables and registering obligations to\n     /// resolve later. This should be done once for every type we get from some"}, {"sha": "6110f5abd3372afa13c3c1d10cff5439b658c876", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 47, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/95dc2de8e979264e1c76ce5594e8a63547a7956e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc2de8e979264e1c76ce5594e8a63547a7956e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=95dc2de8e979264e1c76ce5594e8a63547a7956e", "patch": "@@ -19,8 +19,8 @@ use crate::{\n     method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n-    CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n-    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef, Ty,\n+    TypeCtor, TypeWalk, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -95,21 +95,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                let pat_ty = match self.resolve_into_iter_item() {\n-                    Some(into_iter_item_alias) => {\n-                        let pat_ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: pat_ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias,\n-                                parameters: Substs::single(iterable_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(pat_ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let pat_ty =\n+                    self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -284,40 +271,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let ty = match self.resolve_future_future_output() {\n-                    Some(future_future_output_alias) => {\n-                        let ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let ty =\n+                    self.resolve_associated_type(inner_ty, self.resolve_future_future_output());\n                 ty\n             }\n             Expr::Try { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let ty = match self.resolve_ops_try_ok() {\n-                    Some(ops_try_ok_alias) => {\n-                        let ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let ty = self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok());\n                 ty\n             }\n             Expr::Cast { expr, type_ref } => {"}]}