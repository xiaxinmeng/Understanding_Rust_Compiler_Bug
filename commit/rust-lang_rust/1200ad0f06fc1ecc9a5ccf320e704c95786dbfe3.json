{"sha": "1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMDBhZDBmMDZmYzFlY2M5YTVjY2YzMjBlNzA0Yzk1Nzg2ZGJmZTM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-07-28T01:05:07Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-07-29T22:51:03Z"}, "message": "Fix a bug pretty printing `match { 5i } { _ => { } }`\n\nThis also always puts a trailing comma on the last non-block expr.", "tree": {"sha": "7e1a908806f9c817c915265e882f13cf736a7c52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e1a908806f9c817c915265e882f13cf736a7c52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "html_url": "https://github.com/rust-lang/rust/commit/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a46463d17920b99411337f20fc0e7edc72230c0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a46463d17920b99411337f20fc0e7edc72230c0b", "html_url": "https://github.com/rust-lang/rust/commit/a46463d17920b99411337f20fc0e7edc72230c0b"}], "stats": {"total": 121, "additions": 71, "deletions": 50}, "files": [{"sha": "8f236cebcf471af6d78a65e7eab9574f84f0d6b7", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "patch": "@@ -147,6 +147,7 @@ pub mod rt {\n     impl_to_source!(Gc<ast::Stmt>, stmt_to_string)\n     impl_to_source!(Gc<ast::Expr>, expr_to_string)\n     impl_to_source!(Gc<ast::Pat>, pat_to_string)\n+    impl_to_source!(ast::Arm, arm_to_string)\n     impl_to_source_slice!(ast::Ty, \", \")\n     impl_to_source_slice!(Gc<ast::Item>, \"\\n\\n\")\n \n@@ -240,6 +241,7 @@ pub mod rt {\n     impl_to_tokens!(ast::Ident)\n     impl_to_tokens!(Gc<ast::Item>)\n     impl_to_tokens!(Gc<ast::Pat>)\n+    impl_to_tokens!(ast::Arm)\n     impl_to_tokens!(Gc<ast::Method>)\n     impl_to_tokens_lifetime!(&'a [Gc<ast::Item>])\n     impl_to_tokens!(ast::Ty)"}, {"sha": "4ab9d1b486a34170ba9683c044b6207c7b2d190a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "patch": "@@ -18,7 +18,6 @@ use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n-use parse::classify::expr_is_simple_block;\n use parse::token;\n use parse::lexer::comments;\n use parse;\n@@ -151,6 +150,10 @@ pub fn pat_to_string(pat: &ast::Pat) -> String {\n     to_string(|s| s.print_pat(pat))\n }\n \n+pub fn arm_to_string(arm: &ast::Arm) -> String {\n+    to_string(|s| s.print_arm(arm))\n+}\n+\n pub fn expr_to_string(e: &ast::Expr) -> String {\n     to_string(|s| s.print_expr(e))\n }\n@@ -1402,53 +1405,8 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                let len = arms.len();\n-                for (i, arm) in arms.iter().enumerate() {\n-                    // I have no idea why this check is necessary, but here it\n-                    // is :(\n-                    if arm.attrs.is_empty() {\n-                        try!(space(&mut self.s));\n-                    }\n-                    try!(self.cbox(indent_unit));\n-                    try!(self.ibox(0u));\n-                    try!(self.print_outer_attributes(arm.attrs.as_slice()));\n-                    let mut first = true;\n-                    for p in arm.pats.iter() {\n-                        if first {\n-                            first = false;\n-                        } else {\n-                            try!(space(&mut self.s));\n-                            try!(self.word_space(\"|\"));\n-                        }\n-                        try!(self.print_pat(&**p));\n-                    }\n-                    try!(space(&mut self.s));\n-                    match arm.guard {\n-                        Some(ref e) => {\n-                            try!(self.word_space(\"if\"));\n-                            try!(self.print_expr(&**e));\n-                            try!(space(&mut self.s));\n-                        }\n-                        None => ()\n-                    }\n-                    try!(self.word_space(\"=>\"));\n-\n-                    match arm.body.node {\n-                        ast::ExprBlock(ref blk) => {\n-                            // the block will close the pattern's ibox\n-                            try!(self.print_block_unclosed_indent(&**blk,\n-                                                                  indent_unit));\n-                        }\n-                        _ => {\n-                            try!(self.end()); // close the ibox for the pattern\n-                            try!(self.print_expr(&*arm.body));\n-                        }\n-                    }\n-                    if !expr_is_simple_block(expr.clone())\n-                        && i < len - 1 {\n-                        try!(word(&mut self.s, \",\"));\n-                    }\n-                    try!(self.end()); // close enclosing cbox\n+                for arm in arms.iter() {\n+                    try!(self.print_arm(arm));\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n@@ -1882,6 +1840,51 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodePat(pat))\n     }\n \n+    fn print_arm(&mut self, arm: &ast::Arm) -> IoResult<()> {\n+        // I have no idea why this check is necessary, but here it\n+        // is :(\n+        if arm.attrs.is_empty() {\n+            try!(space(&mut self.s));\n+        }\n+        try!(self.cbox(indent_unit));\n+        try!(self.ibox(0u));\n+        try!(self.print_outer_attributes(arm.attrs.as_slice()));\n+        let mut first = true;\n+        for p in arm.pats.iter() {\n+            if first {\n+                first = false;\n+            } else {\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"|\"));\n+            }\n+            try!(self.print_pat(&**p));\n+        }\n+        try!(space(&mut self.s));\n+        match arm.guard {\n+            Some(ref e) => {\n+                try!(self.word_space(\"if\"));\n+                try!(self.print_expr(&**e));\n+                try!(space(&mut self.s));\n+            }\n+            None => ()\n+        }\n+        try!(self.word_space(\"=>\"));\n+\n+        match arm.body.node {\n+            ast::ExprBlock(ref blk) => {\n+                // the block will close the pattern's ibox\n+                try!(self.print_block_unclosed_indent(&**blk,\n+                                                      indent_unit));\n+            }\n+            _ => {\n+                try!(self.end()); // close the ibox for the pattern\n+                try!(self.print_expr(&*arm.body));\n+                try!(word(&mut self.s, \",\"));\n+            }\n+        }\n+        self.end() // close enclosing cbox\n+    }\n+\n     // Returns whether it printed anything\n     fn print_explicit_self(&mut self,\n                            explicit_self: ast::ExplicitSelf_,"}, {"sha": "44771a29bb4fde1dc3716196821de4105755db3a", "filename": "src/test/pretty/match-block-expr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs?ref=1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+\n+fn main() {\n+    let x = match { 5i } { 1 => 5i, 2 => 6, _ => 7, };\n+    assert_eq!(x , 7);\n+}"}, {"sha": "d2f8157ef62131e9f9efd82c1e47b1c841833fad", "filename": "src/test/pretty/match-naked-expr-medium.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs?ref=1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "patch": "@@ -19,6 +19,6 @@ fn main() {\n              \"long\".to_string(), \"string\".to_string()],\n             None =>\n             [\"none\".to_string(), \"a\".to_string(), \"a\".to_string(),\n-             \"a\".to_string(), \"a\".to_string()]\n+             \"a\".to_string(), \"a\".to_string()],\n         };\n }"}, {"sha": "6b4f579f9c51c61c966874fe4049f771ce01f003", "filename": "src/test/pretty/match-naked-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs?ref=1200ad0f06fc1ecc9a5ccf320e704c95786dbfe3", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     let _y =\n         match x {\n             Some(_) => \"some(_)\".to_string(),\n-            None => \"none\".to_string()\n+            None => \"none\".to_string(),\n         };\n }"}]}