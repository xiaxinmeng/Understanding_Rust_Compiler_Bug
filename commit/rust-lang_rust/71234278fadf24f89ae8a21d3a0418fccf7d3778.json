{"sha": "71234278fadf24f89ae8a21d3a0418fccf7d3778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMjM0Mjc4ZmFkZjI0Zjg5YWU4YTIxZDNhMDQxOGZjY2Y3ZDM3Nzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-07T22:23:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:31:49Z"}, "message": "align the `type-op` outputs with what canonicalized queries give", "tree": {"sha": "cbfbb9474f29052bde9df1f16427776687eff3ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbfbb9474f29052bde9df1f16427776687eff3ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71234278fadf24f89ae8a21d3a0418fccf7d3778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71234278fadf24f89ae8a21d3a0418fccf7d3778", "html_url": "https://github.com/rust-lang/rust/commit/71234278fadf24f89ae8a21d3a0418fccf7d3778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71234278fadf24f89ae8a21d3a0418fccf7d3778/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ac89174b8b1f75ff867588e82a51e7134aaba31", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac89174b8b1f75ff867588e82a51e7134aaba31", "html_url": "https://github.com/rust-lang/rust/commit/6ac89174b8b1f75ff867588e82a51e7134aaba31"}], "stats": {"total": 276, "additions": 175, "deletions": 101}, "files": [{"sha": "93079b046690c509aa5028d11a462a40f1102722", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=71234278fadf24f89ae8a21d3a0418fccf7d3778", "patch": "@@ -13,4 +13,4 @@\n pub mod env;\n pub mod free_region_map;\n pub mod bounds;\n-mod obligations;\n+pub mod obligations;"}, {"sha": "07286f1250cd38f4063dce51754e7b205a96aee9", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=71234278fadf24f89ae8a21d3a0418fccf7d3778", "patch": "@@ -250,7 +250,7 @@ impl<'cx, 'gcx, 'tcx, D> TypeOutlives<'cx, 'gcx, 'tcx, D>\n where\n     D: TypeOutlivesDelegate<'tcx>,\n {\n-    fn new(\n+    pub fn new(\n         delegate: D,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -274,7 +274,7 @@ where\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n-    fn type_must_outlive(\n+    pub fn type_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,"}, {"sha": "44f8420ca7ed0282d8e372abc0d217bf1a655e9f", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 94, "deletions": 46, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=71234278fadf24f89ae8a21d3a0418fccf7d3778", "patch": "@@ -11,64 +11,66 @@\n use borrow_check::location::LocationTable;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n-use borrow_check::nll::type_check::Locations;\n+use borrow_check::nll::type_check::{Locations, LexicalRegionConstraintData};\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use rustc::infer::region_constraints::Constraint;\n-use rustc::infer::region_constraints::RegionConstraintData;\n-use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::infer::{self, RegionObligation, SubregionOrigin};\n+use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n+use rustc::infer::region_constraints::{Constraint, GenericKind, VerifyBound};\n use rustc::mir::{Location, Mir};\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use syntax::codemap::Span;\n \n-crate struct ConstraintConversion<'a, 'tcx: 'a> {\n+crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n+    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    locations: Locations,\n     outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n     all_facts: &'a mut Option<AllFacts>,\n-\n }\n \n-impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         location_table: &'a LocationTable,\n+        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        locations: Locations,\n         outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n         all_facts: &'a mut Option<AllFacts>,\n     ) -> Self {\n         Self {\n+            tcx,\n             mir,\n             universal_regions,\n             location_table,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            locations,\n             outlives_constraints,\n             type_tests,\n             all_facts,\n         }\n     }\n \n-    crate fn convert(\n-        &mut self,\n-        locations: Locations,\n-        data: &RegionConstraintData<'tcx>,\n-    ) {\n-        debug!(\"generate: constraints at: {:#?}\", locations);\n-        let RegionConstraintData {\n+    pub(super) fn convert(&mut self, data: &LexicalRegionConstraintData<'tcx>) {\n+        debug!(\"generate: constraints at: {:#?}\", self.locations);\n+        let LexicalRegionConstraintData {\n             constraints,\n-            verifys,\n-            givens,\n+            region_obligations,\n         } = data;\n \n-        let span = self\n-            .mir\n-            .source_info(locations.from_location().unwrap_or(Location::START))\n-            .span;\n-\n-        let at_location = locations.at_location().unwrap_or(Location::START);\n-\n-        for constraint in constraints.keys() {\n+        for constraint in constraints {\n             debug!(\"generate: constraint: {:?}\", constraint);\n             let (a_vid, b_vid) = match constraint {\n                 Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n@@ -84,13 +86,13 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             // reverse direction, because `regioncx` talks about\n             // \"outlives\" (`>=`) whereas the region constraints\n             // talk about `<=`.\n-            self.add_outlives(span, b_vid, a_vid, at_location);\n+            self.add_outlives(b_vid, a_vid);\n \n             // In the new analysis, all outlives relations etc\n             // \"take effect\" at the mid point of the statement\n             // that requires them, so ignore the `at_location`.\n             if let Some(all_facts) = &mut self.all_facts {\n-                if let Some(from_location) = locations.from_location() {\n+                if let Some(from_location) = self.locations.from_location() {\n                     all_facts.outlives.push((\n                         b_vid,\n                         a_vid,\n@@ -104,36 +106,50 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             }\n         }\n \n-        for verify in verifys {\n-            let type_test = self.verify_to_type_test(verify, span, locations);\n-            self.add_type_test(type_test);\n+        let ConstraintConversion {\n+            tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            ..\n+        } = *self;\n+        for r_o in region_obligations {\n+            let RegionObligation {\n+                sup_type,\n+                sub_region,\n+                cause,\n+            } = r_o;\n+\n+            // we don't actually use this for anything.\n+            let origin = infer::RelateParamBound(cause.span, sup_type);\n+\n+            TypeOutlives::new(\n+                &mut *self,\n+                tcx,\n+                region_bound_pairs,\n+                implicit_region_bound,\n+                param_env,\n+            ).type_must_outlive(origin, sup_type, sub_region);\n         }\n-\n-        assert!(\n-            givens.is_empty(),\n-            \"MIR type-checker does not use givens (thank goodness)\"\n-        );\n     }\n \n     fn verify_to_type_test(\n         &self,\n-        verify: &Verify<'tcx>,\n-        span: Span,\n-        locations: Locations,\n+        generic_kind: GenericKind<'tcx>,\n+        region: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n-        let generic_kind = verify.kind;\n+        let lower_bound = self.to_region_vid(region);\n \n-        let lower_bound = self.to_region_vid(verify.region);\n+        let point = self.locations.at_location().unwrap_or(Location::START);\n \n-        let point = locations.at_location().unwrap_or(Location::START);\n-\n-        let test = self.verify_bound_to_region_test(&verify.bound);\n+        let test = self.verify_bound_to_region_test(&bound);\n \n         TypeTest {\n             generic_kind,\n             lower_bound,\n             point,\n-            span,\n+            span: self.span(),\n             test,\n         }\n     }\n@@ -168,13 +184,21 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n+    fn span(&self) -> Span {\n+        self\n+            .mir\n+            .source_info(self.locations.from_location().unwrap_or(Location::START))\n+            .span\n+    }\n+\n     fn add_outlives(\n         &mut self,\n-        span: Span,\n         sup: ty::RegionVid,\n         sub: ty::RegionVid,\n-        point: Location,\n     ) {\n+        let span = self.span();\n+        let point = self.locations.at_location().unwrap_or(Location::START);\n+\n         self.outlives_constraints.push(OutlivesConstraint {\n             span,\n             sub,\n@@ -188,3 +212,27 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         self.type_tests.push(type_test);\n     }\n }\n+\n+impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'b, 'gcx, 'tcx> {\n+    fn push_sub_region_constraint(\n+        &mut self,\n+        _origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n+        let b = self.universal_regions.to_region_vid(b);\n+        let a = self.universal_regions.to_region_vid(a);\n+        self.add_outlives(b, a);\n+    }\n+\n+    fn push_verify(\n+        &mut self,\n+        _origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        let type_test = self.verify_to_type_test(kind, a, bound);\n+        self.add_type_test(type_test);\n+    }\n+}"}, {"sha": "92a60602b796a56f0adbfed07984ba81b82d3c70", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=71234278fadf24f89ae8a21d3a0418fccf7d3778", "patch": "@@ -10,11 +10,10 @@\n \n use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::type_check::type_op::{DropckOutlives, TypeOp};\n-use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::type_check::{AtLocation, LexicalRegionConstraintData};\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n-use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::mir::Local;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::subst::Kind;\n@@ -71,7 +70,7 @@ where\n \n struct DropData<'tcx> {\n     dropped_kinds: Vec<Kind<'tcx>>,\n-    region_constraint_data: Option<Rc<RegionConstraintData<'tcx>>>,\n+    region_constraint_data: Option<Rc<LexicalRegionConstraintData<'tcx>>>,\n }\n \n impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n@@ -198,8 +197,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         });\n \n         if let Some(data) = &drop_data.region_constraint_data {\n-            self.cx\n-                .push_region_constraints(location.at_self(), data.clone());\n+            self.cx.push_region_constraints(location.at_self(), data);\n         }\n \n         // All things in the `outlives` array may be touched by\n@@ -217,16 +215,9 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n         let param_env = cx.param_env;\n-        let (dropped_kinds, region_constraint_data) =\n-            DropckOutlives::new(\n-                param_env,\n-                dropped_ty,\n-            ).fully_perform(\n-                cx.infcx,\n-                cx.region_bound_pairs,\n-                cx.implicit_region_bound,\n-                cx.param_env,\n-            ).unwrap();\n+        let (dropped_kinds, region_constraint_data) = DropckOutlives::new(param_env, dropped_ty)\n+            .fully_perform(cx.infcx)\n+            .unwrap();\n \n         DropData {\n             dropped_kinds,"}, {"sha": "cb16461de4914338ac382546b95a751bee99a35c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=71234278fadf24f89ae8a21d3a0418fccf7d3778", "patch": "@@ -20,8 +20,8 @@ use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n-use rustc::infer::{InferCtxt, LateBoundRegionConversionTime, UnitResult};\n+use rustc::infer::region_constraints::{Constraint, GenericKind};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime, RegionObligation, UnitResult};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n@@ -31,7 +31,6 @@ use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use std::fmt;\n-use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n@@ -626,6 +625,21 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n+/// The type checker layers on top of the \"old\" inference engine.  The\n+/// idea is that we run some operations, like trait selection, and\n+/// then we \"scrape out\" the region constraints that have accumulated\n+/// from the old lexical solver. This struct just collects the bits of\n+/// that data that we care about into one place.\n+#[derive(Debug)]\n+struct LexicalRegionConstraintData<'tcx> {\n+    /// The `'a <= 'b` constraints extracted from `RegionConstraintData`.\n+    constraints: Vec<Constraint<'tcx>>,\n+\n+    /// The `T: 'a` (and `'a: 'b`, in some cases) constraints\n+    /// extracted from the pending \"region obligations\".\n+    region_obligations: Vec<RegionObligation<'tcx>>,\n+}\n+\n /// The `Locations` type summarizes *where* region constraints are\n /// required to hold. Normally, this is at a particular point which\n /// created the obligation, but for constraints that the user gave, we\n@@ -733,14 +747,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n         op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Result<R, TypeError<'tcx>> {\n-        let (r, opt_data) = op.fully_perform(\n-            self.infcx,\n-            self.region_bound_pairs,\n-            self.implicit_region_bound,\n-            self.param_env,\n-        )?;\n-\n-        if let Some(data) = opt_data {\n+        let (r, opt_data) = op.fully_perform(self.infcx)?;\n+\n+        if let Some(data) = &opt_data {\n             self.push_region_constraints(locations, data);\n         }\n \n@@ -750,7 +759,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        data: Rc<RegionConstraintData<'tcx>>,\n+        data: &LexicalRegionConstraintData<'tcx>,\n     ) {\n         debug!(\n             \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n@@ -759,13 +768,18 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n+                self.infcx.tcx,\n                 self.mir,\n                 borrowck_context.universal_regions,\n                 borrowck_context.location_table,\n+                self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n+                locations,\n                 &mut self.constraints.outlives_constraints,\n                 &mut self.constraints.type_tests,\n                 &mut borrowck_context.all_facts,\n-            ).convert(locations, &data);\n+            ).convert(&data);\n         }\n     }\n \n@@ -1689,3 +1703,10 @@ impl ToLocations for Location {\n         self.at_self()\n     }\n }\n+\n+impl<'tcx> LexicalRegionConstraintData<'tcx> {\n+    fn is_empty(&self) -> bool {\n+        let LexicalRegionConstraintData { constraints, region_obligations } = self;\n+        constraints.is_empty() && region_obligations.is_empty()\n+    }\n+}"}, {"sha": "263bce8067f2d2b98c9e8f8094d8f89d50fb6e48", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/mod.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71234278fadf24f89ae8a21d3a0418fccf7d3778/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs?ref=71234278fadf24f89ae8a21d3a0418fccf7d3778", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::type_check::LexicalRegionConstraintData;\n+use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::infer::{InferCtxt, InferOk, InferResult};\n-use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n use rustc::traits::query::NoSolution;\n use rustc::traits::{Normalized, Obligation, ObligationCause, PredicateObligation, TraitEngine};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Kind;\n-use rustc::ty::{self, ParamEnv, Predicate, Ty};\n-use std::rc::Rc;\n+use rustc::ty::{ParamEnv, Predicate, Ty};\n use std::fmt;\n+use std::rc::Rc;\n use syntax::codemap::DUMMY_SP;\n \n pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n@@ -43,10 +44,7 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n-        implicit_region_bound: Option<ty::Region<'tcx>>,\n-        param_env: ParamEnv<'tcx>,\n-    ) -> Result<(Self::Output, Option<Rc<RegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n+    ) -> Result<(Self::Output, Option<Rc<LexicalRegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n         let op = match self.trivial_noop() {\n             Ok(r) => return Ok((r, None)),\n             Err(op) => op,\n@@ -68,14 +66,29 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n             );\n         }\n \n-        infcx.process_registered_region_obligations(\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-            dummy_body_id,\n-        );\n+        let region_obligations: Vec<_> = infcx\n+            .take_registered_region_obligations()\n+            .into_iter()\n+            .map(|(_node_id, region_obligation)| region_obligation)\n+            .collect();\n+\n+        let RegionConstraintData {\n+            constraints,\n+            verifys,\n+            givens,\n+        } = infcx.take_and_reset_region_constraints();\n \n-        let data = infcx.take_and_reset_region_constraints();\n+        // These are created when we \"process\" the registered region\n+        // obliations, and that hasn't happened yet.\n+        assert!(verifys.is_empty());\n+\n+        // NLL doesn't use givens (and thank goodness!).\n+        assert!(givens.is_empty());\n+\n+        let data = LexicalRegionConstraintData {\n+            constraints: constraints.keys().cloned().collect(),\n+            region_obligations,\n+        };\n         if data.is_empty() {\n             Ok((value, None))\n         } else {\n@@ -84,8 +97,6 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     }\n }\n \n-\n-\n pub(super) struct CustomTypeOp<F, G> {\n     closure: F,\n     description: G,\n@@ -97,7 +108,10 @@ impl<F, G> CustomTypeOp<F, G> {\n         F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n         G: Fn() -> String,\n     {\n-        CustomTypeOp { closure, description }\n+        CustomTypeOp {\n+            closure,\n+            description,\n+        }\n     }\n }\n \n@@ -277,11 +291,11 @@ pub(super) struct DropckOutlives<'tcx> {\n }\n \n impl<'tcx> DropckOutlives<'tcx> {\n-    pub(super) fn new(\n-        param_env: ParamEnv<'tcx>,\n-        dropped_ty: Ty<'tcx>,\n-    ) -> Self {\n-        DropckOutlives { param_env, dropped_ty }\n+    pub(super) fn new(param_env: ParamEnv<'tcx>, dropped_ty: Ty<'tcx>) -> Self {\n+        DropckOutlives {\n+            param_env,\n+            dropped_ty,\n+        }\n     }\n }\n \n@@ -294,7 +308,7 @@ impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for DropckOutlives<'tcx> {\n \n     fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n         Ok(infcx\n-           .at(&ObligationCause::dummy(), self.param_env)\n-           .dropck_outlives(self.dropped_ty))\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .dropck_outlives(self.dropped_ty))\n     }\n }"}]}