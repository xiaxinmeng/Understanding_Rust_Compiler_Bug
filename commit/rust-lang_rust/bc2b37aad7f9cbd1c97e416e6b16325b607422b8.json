{"sha": "bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMmIzN2FhZDdmOWNiZDFjOTdlNDE2ZTZiMTYzMjViNjA3NDIyYjg=", "commit": {"author": {"name": "Pankaj Chaudhary", "email": "pankajchaudhary172@gmail.com", "date": "2020-07-13T08:44:37Z"}, "committer": {"name": "PankajChaudhary5", "email": "pankajchaudhary172@gmail.com", "date": "2020-07-13T09:27:22Z"}, "message": "Merge branch 'master' into E0688", "tree": {"sha": "867a6176bcf763bba6e5de12bc08f034a320ac56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/867a6176bcf763bba6e5de12bc08f034a320ac56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "html_url": "https://github.com/rust-lang/rust/commit/bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/comments", "author": {"login": "Polkaverse", "id": 25547063, "node_id": "MDQ6VXNlcjI1NTQ3MDYz", "avatar_url": "https://avatars.githubusercontent.com/u/25547063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Polkaverse", "html_url": "https://github.com/Polkaverse", "followers_url": "https://api.github.com/users/Polkaverse/followers", "following_url": "https://api.github.com/users/Polkaverse/following{/other_user}", "gists_url": "https://api.github.com/users/Polkaverse/gists{/gist_id}", "starred_url": "https://api.github.com/users/Polkaverse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Polkaverse/subscriptions", "organizations_url": "https://api.github.com/users/Polkaverse/orgs", "repos_url": "https://api.github.com/users/Polkaverse/repos", "events_url": "https://api.github.com/users/Polkaverse/events{/privacy}", "received_events_url": "https://api.github.com/users/Polkaverse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Polkaverse", "id": 25547063, "node_id": "MDQ6VXNlcjI1NTQ3MDYz", "avatar_url": "https://avatars.githubusercontent.com/u/25547063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Polkaverse", "html_url": "https://github.com/Polkaverse", "followers_url": "https://api.github.com/users/Polkaverse/followers", "following_url": "https://api.github.com/users/Polkaverse/following{/other_user}", "gists_url": "https://api.github.com/users/Polkaverse/gists{/gist_id}", "starred_url": "https://api.github.com/users/Polkaverse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Polkaverse/subscriptions", "organizations_url": "https://api.github.com/users/Polkaverse/orgs", "repos_url": "https://api.github.com/users/Polkaverse/repos", "events_url": "https://api.github.com/users/Polkaverse/events{/privacy}", "received_events_url": "https://api.github.com/users/Polkaverse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3ae4c7345cfd06b06c6996536d7c158ce6970db", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ae4c7345cfd06b06c6996536d7c158ce6970db", "html_url": "https://github.com/rust-lang/rust/commit/e3ae4c7345cfd06b06c6996536d7c158ce6970db"}, {"sha": "9d09331e00b02f81c714b0c41ce3a38380dd36a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d09331e00b02f81c714b0c41ce3a38380dd36a2", "html_url": "https://github.com/rust-lang/rust/commit/9d09331e00b02f81c714b0c41ce3a38380dd36a2"}], "stats": {"total": 319233, "additions": 252064, "deletions": 67169}, "files": [{"sha": "a38761d166567119be2d78247446cbaa875adf22", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 138, "deletions": 186, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -24,20 +24,20 @@ name: CI\n   pull_request:\n     branches:\n       - \"**\"\n+defaults:\n+  run:\n+    shell: \"python src/ci/exec-with-shell.py {0}\"\n jobs:\n   pr:\n     name: PR\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n       SCCACHE_BUCKET: rust-lang-gha-caches\n       TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'pull_request'\"\n     strategy:\n       matrix:\n-        name:\n-          - mingw-check\n-          - x86_64-gnu-llvm-8\n-          - x86_64-gnu-tools\n         include:\n           - name: mingw-check\n             os: ubuntu-latest-xl\n@@ -68,95 +68,68 @@ jobs:\n         run: src/ci/scripts/setup-environment.sh\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n   try:\n     name: try\n     env:\n@@ -168,20 +141,14 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n       matrix:\n-        name:\n-          - dist-x86_64-linux\n-          - dist-x86_64-linux-alt\n         include:\n           - name: dist-x86_64-linux\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: dist-x86_64-linux-alt\n-            env:\n-              IMAGE: dist-x86_64-linux\n-            os: ubuntu-latest-xl\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:\n@@ -201,95 +168,68 @@ jobs:\n         run: src/ci/scripts/setup-environment.sh\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n   auto:\n     name: auto\n     env:\n@@ -301,67 +241,10 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n       matrix:\n-        name:\n-          - arm-android\n-          - armhf-gnu\n-          - dist-aarch64-linux\n-          - dist-android\n-          - dist-arm-linux\n-          - dist-armhf-linux\n-          - dist-armv7-linux\n-          - dist-i586-gnu-i586-i686-musl\n-          - dist-i686-freebsd\n-          - dist-i686-linux\n-          - dist-i686-mingw\n-          - dist-i686-msvc\n-          - dist-mips-linux\n-          - dist-mips64-linux\n-          - dist-mips64el-linux\n-          - dist-mipsel-linux\n-          - dist-powerpc-linux\n-          - dist-powerpc64-linux\n-          - dist-powerpc64le-linux\n-          - dist-s390x-linux\n-          - dist-various-1\n-          - dist-various-2\n-          - dist-x86_64-apple\n-          - dist-x86_64-apple-alt\n-          - dist-x86_64-freebsd\n-          - dist-x86_64-linux\n-          - dist-x86_64-linux-alt\n-          - dist-x86_64-mingw\n-          - dist-x86_64-msvc\n-          - dist-x86_64-msvc-alt\n-          - dist-x86_64-musl\n-          - dist-x86_64-netbsd\n-          - i686-gnu\n-          - i686-gnu-nopt\n-          - i686-mingw-1\n-          - i686-mingw-2\n-          - i686-msvc-1\n-          - i686-msvc-2\n-          - mingw-check\n-          - test-various\n-          - wasm32\n-          - x86_64-apple\n-          - x86_64-gnu\n-          - x86_64-gnu-aux\n-          - x86_64-gnu-debug\n-          - x86_64-gnu-distcheck\n-          - x86_64-gnu-full-bootstrap\n-          - x86_64-gnu-llvm-8\n-          - x86_64-gnu-nopt\n-          - x86_64-gnu-tools\n-          - x86_64-mingw-1\n-          - x86_64-mingw-2\n-          - x86_64-msvc-1\n-          - x86_64-msvc-2\n-          - x86_64-msvc-aux\n-          - x86_64-msvc-cargo\n-          - x86_64-msvc-tools\n         include:\n           - name: arm-android\n             os: ubuntu-latest-xl\n@@ -480,35 +363,6 @@ jobs:\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n             os: ubuntu-latest-xl\n-          - name: dist-x86_64-apple\n-            env:\n-              SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-latest\n-          - name: dist-x86_64-apple-alt\n-            env:\n-              SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            os: macos-latest\n-          - name: x86_64-apple\n-            env:\n-              SCRIPT: \"./x.py test\"\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.8\n-              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            os: macos-latest\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n@@ -535,22 +389,17 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_LLVM_ASSERTIONS: 1\n             os: windows-latest-xl\n-          - name: x86_64-msvc-aux\n-            env:\n-              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n-            os: windows-latest-xl\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n               VCVARS_BAT: vcvars64.bat\n               NO_DEBUG_ASSERTIONS: 1\n               NO_LLVM_ASSERTIONS: 1\n             os: windows-latest-xl\n           - name: x86_64-msvc-tools\n             env:\n-              SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+              SCRIPT: src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\"\n             os: windows-latest-xl\n           - name: i686-mingw-1\n@@ -631,95 +480,194 @@ jobs:\n         run: src/ci/scripts/setup-environment.sh\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n-        if: success() && !env.SKIP_JOB\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  auto-fallible:\n+    name: auto-fallible\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: macos-latest\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py test\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n   master:\n     name: master\n     runs-on: ubuntu-latest\n@@ -731,6 +679,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n     steps:\n       - name: checkout the source code\n@@ -741,7 +690,6 @@ jobs:\n         run: src/ci/publish_toolstate.sh\n         env:\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n-        shell: \"python src/ci/exec-with-shell.py {0}\"\n         if: success() && !env.SKIP_JOB\n   try-success:\n     needs:\n@@ -750,6 +698,7 @@ jobs:\n     steps:\n       - name: mark the job as a success\n         run: exit 0\n+        shell: bash\n     name: bors build finished\n     runs-on: ubuntu-latest\n   try-failure:\n@@ -759,6 +708,7 @@ jobs:\n     steps:\n       - name: mark the job as a failure\n         run: exit 1\n+        shell: bash\n     name: bors build finished\n     runs-on: ubuntu-latest\n   auto-success:\n@@ -768,6 +718,7 @@ jobs:\n     steps:\n       - name: mark the job as a success\n         run: exit 0\n+        shell: bash\n     name: bors build finished\n     runs-on: ubuntu-latest\n   auto-failure:\n@@ -777,5 +728,6 @@ jobs:\n     steps:\n       - name: mark the job as a failure\n         run: exit 1\n+        shell: bash\n     name: bors build finished\n     runs-on: ubuntu-latest"}, {"sha": "5c0ab737f63dbd7da7c41695f382a9a2a275f1b6", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -16,9 +16,6 @@\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n \turl = https://github.com/rust-lang/rls.git\n-[submodule \"src/tools/clippy\"]\n-\tpath = src/tools/clippy\n-\turl = https://github.com/rust-lang/rust-clippy.git\n [submodule \"src/tools/rustfmt\"]\n \tpath = src/tools/rustfmt\n \turl = https://github.com/rust-lang/rustfmt.git\n@@ -40,7 +37,10 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/9.0-2019-12-19\n+\tbranch = rustc/10.0-2020-05-05\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git\n+[submodule \"src/tools/rust-analyzer\"]\n+\tpath = src/tools/rust-analyzer\n+\turl = https://github.com/rust-analyzer/rust-analyzer.git"}, {"sha": "15ca403456a4ede8efd866b41fc16f2a1b104ad3", "filename": ".mailmap", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -44,11 +44,13 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n+Camelid <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n Carol Willing <carolcode@willingconsulting.com>\n+Charles Lew <crlf0710@gmail.com> CrLF0710 <crlf0710@gmail.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n@@ -69,6 +71,8 @@ David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n+Donough Liu <ldm2993593805@163.com> <donoughliu@gmail.com>\n+Donough Liu <ldm2993593805@163.com> DingMing Liu <liudingming@bupt.edu.cn>\n Dustin Bensing <dustin.bensing@googlemail.com>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n@@ -149,6 +153,10 @@ Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n Keegan McAllister <mcallister.keegan@gmail.com> <kmcallister@mozilla.com>\n Kevin Butler <haqkrs@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Kyle J Strand <batmanaod@gmail.com> <BatmanAoD@users.noreply.github.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.j.strand@gmail.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.strand@pieinsurance.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.strand@rms.com>\n Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n@@ -258,6 +266,7 @@ Tim Chevalier <chevalier@alum.wellesley.edu> <catamorphism@gmail.com>\n Tim JIANG <p90eri@gmail.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n+Trevor Spiteri <tspiteri@ieee.org> <trevor.spiteri@um.edu.mt>\n Ty Overby <ty@pre-alpha.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>"}, {"sha": "aad495fa3fae6e4b04d95230bee6655795d99792", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 517, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,522 +1,8 @@\n # Contributing to Rust\n-[contributing-to-rust]: #contributing-to-rust\n \n-Thank you for your interest in contributing to Rust! There are many ways to\n-contribute, and we appreciate all of them. This document is a bit long, so here's\n-links to the major sections:\n+Thank you for your interest in contributing to Rust!\n \n-* [Feature Requests](#feature-requests)\n-* [Bug Reports](#bug-reports)\n-* [The Build System](#the-build-system)\n-* [Pull Requests](#pull-requests)\n-* [Writing Documentation](#writing-documentation)\n-* [Issue Triage](#issue-triage)\n-* [Out-of-tree Contributions](#out-of-tree-contributions)\n-* [Helpful Links and Information](#helpful-links-and-information)\n+To get started, read the [Getting Started] guide in the [rustc-dev-guide].\n \n-If you have questions, please make a post on [internals.rust-lang.org][internals] or\n-hop on the [Rust Discord server][rust-discord] or [Rust Zulip server][rust-zulip].\n-\n-As a reminder, all contributors are expected to follow our [Code of Conduct][coc].\n-\n-The [rustc-dev-guide] is your friend! It describes how the compiler works and how\n-to contribute to it in more detail than this document.\n-\n-If this is your first time contributing, the [walkthrough] chapter of the guide\n-can give you a good example of how a typical contribution would go.\n-\n-[internals]: https://internals.rust-lang.org\n-[rust-discord]: http://discord.gg/rust-lang\n-[rust-zulip]: https://rust-lang.zulipchat.com\n-[coc]: https://www.rust-lang.org/conduct.html\n+[Getting Started]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n-[walkthrough]: https://rustc-dev-guide.rust-lang.org/walkthrough.html\n-\n-## Feature Requests\n-[feature-requests]: #feature-requests\n-\n-To request a change to the way the Rust language works, please head over\n-to the [RFCs repository](https://github.com/rust-lang/rfcs) and view the\n-[README](https://github.com/rust-lang/rfcs/blob/master/README.md)\n-for instructions.\n-\n-## Bug Reports\n-[bug-reports]: #bug-reports\n-\n-While bugs are unfortunate, they're a reality in software. We can't fix what we\n-don't know about, so please report liberally. If you're not sure if something\n-is a bug or not, feel free to file a bug anyway.\n-\n-**If you believe reporting your bug publicly represents a security risk to Rust users,\n-please follow our [instructions for reporting security vulnerabilities](https://www.rust-lang.org/policies/security)**.\n-\n-If you're using the nightly channel, please check if the bug exists in the\n-latest toolchain before filing your bug. It might be fixed already.\n-\n-If you have the chance, before reporting a bug, please [search existing\n-issues](https://github.com/rust-lang/rust/search?q=&type=Issues&utf8=%E2%9C%93),\n-as it's possible that someone else has already reported your error. This doesn't\n-always work, and sometimes it's hard to know what to search for, so consider this\n-extra credit. We won't mind if you accidentally file a duplicate report.\n-\n-Similarly, to help others who encountered the bug find your issue,\n-consider filing an issue with a descriptive title, which contains information that might be unique to it.\n-This can be the language or compiler feature used, the conditions that trigger the bug,\n-or part of the error message if there is any.\n-An example could be: **\"impossible case reached\" on lifetime inference for impl Trait in return position**.\n-\n-Opening an issue is as easy as following [this\n-link](https://github.com/rust-lang/rust/issues/new) and filling out the fields.\n-Here's a template that you can use to file a bug, though it's not necessary to\n-use it exactly:\n-\n-    <short summary of the bug>\n-\n-    I tried this code:\n-\n-    <code sample that causes the bug>\n-\n-    I expected to see this happen: <explanation>\n-\n-    Instead, this happened: <explanation>\n-\n-    ## Meta\n-\n-    `rustc --version --verbose`:\n-\n-    Backtrace:\n-\n-All three components are important: what you did, what you expected, what\n-happened instead. Please include the output of `rustc --version --verbose`,\n-which includes important information about what platform you're on, what\n-version of Rust you're using, etc.\n-\n-Sometimes, a backtrace is helpful, and so including that is nice. To get\n-a backtrace, set the `RUST_BACKTRACE` environment variable to a value\n-other than `0`. The easiest way\n-to do this is to invoke `rustc` like this:\n-\n-```bash\n-$ RUST_BACKTRACE=1 rustc ...\n-```\n-\n-## The Build System\n-\n-For info on how to configure and build the compiler, please see [this\n-chapter][rustcguidebuild] of the rustc-dev-guide. This chapter contains info for\n-contributions to the compiler and the standard library. It also lists some\n-really useful commands to the build system (`./x.py`), which could save you a\n-lot of time.\n-\n-[rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n-\n-## Pull Requests\n-[pull-requests]: #pull-requests\n-\n-Pull requests are the primary mechanism we use to change Rust. GitHub itself\n-has some [great documentation][about-pull-requests] on using the Pull Request feature.\n-We use the \"fork and pull\" model [described here][development-models], where\n-contributors push changes to their personal fork and create pull requests to\n-bring those changes into the source repository.\n-\n-[about-pull-requests]: https://help.github.com/articles/about-pull-requests/\n-[development-models]: https://help.github.com/articles/about-collaborative-development-models/\n-\n-Please make pull requests against the `master` branch.\n-\n-Rust follows a no merge policy, meaning, when you encounter merge\n-conflicts you are expected to always rebase instead of merge.\n-E.g. always use rebase when bringing the latest changes from\n-the master branch to your feature branch.\n-Also, please make sure that fixup commits are squashed into other related\n-commits with meaningful commit messages.\n-\n-GitHub allows [closing issues using keywords][closing-keywords]. This feature\n-should be used to keep the issue tracker tidy. However, it is generally preferred\n-to put the \"closes #123\" text in the PR description rather than the issue commit;\n-particularly during rebasing, citing the issue number in the commit can \"spam\"\n-the issue in question.\n-\n-[closing-keywords]: https://help.github.com/en/articles/closing-issues-using-keywords\n-\n-Please make sure your pull request is in compliance with Rust's style\n-guidelines by running\n-\n-    $ python x.py test tidy\n-\n-Make this check before every pull request (and every new commit in a pull\n-request); you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)\n-before every push to make sure you never forget to make this check.\n-\n-All pull requests are reviewed by another person. We have a bot,\n-[@rust-highfive][rust-highfive], that will automatically assign a random person to review your\n-request.\n-\n-If you want to request that a specific person reviews your pull request,\n-you can add an `r?` to the pull request description. For example, [Steve][steveklabnik] usually reviews\n-documentation changes. So if you were to make a documentation change, add\n-\n-    r? @steveklabnik\n-\n-to the end of the pull request description, and [@rust-highfive][rust-highfive] will assign\n-[@steveklabnik][steveklabnik] instead of a random person. This is entirely optional.\n-\n-After someone has reviewed your pull request, they will leave an annotation\n-on the pull request with an `r+`. It will look something like this:\n-\n-    @bors r+\n-\n-This tells [@bors][bors], our lovable integration bot, that your pull request has\n-been approved. The PR then enters the [merge queue][merge-queue], where [@bors][bors]\n-will run all the tests on every platform we support. If it all works out,\n-[@bors][bors] will merge your code into `master` and close the pull request.\n-\n-Depending on the scale of the change, you may see a slightly different form of `r+`:\n-\n-    @bors r+ rollup\n-\n-The additional `rollup` tells [@bors][bors] that this change is eligible for to be\n-\"rolled up\". Changes that are rolled up are tested and merged at the same time, to\n-speed the process up. Typically only small changes that are expected not to conflict\n-with one another are rolled up.\n-\n-[rust-highfive]: https://github.com/rust-highfive\n-[steveklabnik]: https://github.com/steveklabnik\n-[bors]: https://github.com/bors\n-[merge-queue]: https://buildbot2.rust-lang.org/homu/queue/rust\n-\n-Speaking of tests, Rust has a comprehensive test suite. More information about\n-it can be found [here][rctd].\n-\n-### External Dependencies (subtree)\n-\n-As a developer to this repository, you don't have to treat the following external projects\n-differently from other crates that are directly in this repo:\n-\n-* none so far, see https://github.com/rust-lang/rust/issues/70651 for more info\n-\n-They are just regular files and directories. This is in contrast to `submodule` dependencies\n-(see below for those). Only tool authors will actually use any operations here.\n-\n-#### Synchronizing a subtree\n-\n-There are two synchronization directions: `subtree push` and `subtree pull`.\n-\n-```\n-git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n-```\n-\n-takes all the changes that\n-happened to the copy in this repo and creates commits on the remote repo that match the local\n-changes. Every local commit that touched the subtree causes a commit on the remote repo, but is\n-modified to move the files from the specified directory to the tool repo root.\n-\n-Make sure to not pick the `master` branch on the tool repo, so you can open a normal PR to the tool\n-to merge that subrepo push.\n-\n-```\n-git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n-```\n-\n-takes all changes since the last `subtree pull` from the tool repo\n-repo and adds these commits to the rustc repo + a merge commit that moves the tool changes into\n-the specified directory in the rust repository.\n-\n-It is recommended that you always do a push first and get that merged to the tool master branch.\n-Then, when you do a pull, the merge works without conflicts.\n-While it's definitely possible to resolve conflicts during a pull, you may have to redo the conflict\n-resolution if your PR doesn't get merged fast enough and there are new conflicts. Do not try to\n-rebase the result of a `git subtree pull`, rebasing merge commits is a bad idea in general.\n-\n-You always need to specify the `-P` prefix to the subtree directory and the corresponding remote\n-repository. If you specify the wrong directory or repository\n-you'll get very fun merges that try to push the wrong directory to the wrong remote repository.\n-Luckily you can just abort this without any consequences by throwing away either the pulled commits\n-in rustc or the pushed branch on the remote and try again. It is usually fairly obvious\n-that this is happening because you suddenly get thousands of commits that want to be synchronized.\n-\n-#### Creating a new subtree dependency\n-\n-If you want to create a new subtree dependency from an existing repository, call (from this\n-repository's root directory!)\n-\n-```\n-git subtree add -P src/tools/clippy https://github.com/rust-lang/rust-clippy.git master\n-```\n-\n-This will create a new commit, which you may not rebase under any circumstances! Delete the commit\n-and redo the operation if you need to rebase.\n-\n-Now you're done, the `src/tools/clippy` directory behaves as if clippy were part of the rustc\n-monorepo, so no one but you (or others that synchronize subtrees) actually needs to use `git subtree`.\n-\n-\n-### External Dependencies (submodules)\n-\n-Currently building Rust will also build the following external projects:\n-\n-* [clippy](https://github.com/rust-lang/rust-clippy)\n-* [miri](https://github.com/rust-lang/miri)\n-* [rustfmt](https://github.com/rust-lang/rustfmt)\n-* [rls](https://github.com/rust-lang/rls/)\n-\n-We allow breakage of these tools in the nightly channel. Maintainers of these\n-projects will be notified of the breakages and should fix them as soon as\n-possible.\n-\n-After the external is fixed, one could add the changes with\n-\n-```sh\n-git add path/to/submodule\n-```\n-\n-outside the submodule.\n-\n-In order to prepare your tool-fixing PR, you can run the build locally by doing\n-`./x.py build src/tools/TOOL`. If you will be editing the sources\n-there, you may wish to set `submodules = false` in the `config.toml`\n-to prevent `x.py` from resetting to the original branch.\n-\n-Breakage is not allowed in the beta and stable channels, and must be addressed\n-before the PR is merged.\n-\n-#### Breaking Tools Built With The Compiler\n-\n-Rust's build system builds a number of tools that make use of the\n-internals of the compiler. This includes\n-[RLS](https://github.com/rust-lang/rls) and\n-[rustfmt](https://github.com/rust-lang/rustfmt). If these tools\n-break because of your changes, you may run into a sort of \"chicken and egg\"\n-problem. These tools rely on the latest compiler to be built so you can't update\n-them to reflect your changes to the compiler until those changes are merged into\n-the compiler. At the same time, you can't get your changes merged into the compiler\n-because the rust-lang/rust build won't pass until those tools build and pass their\n-tests.\n-\n-That means that, in the default state, you can't update the compiler without first\n-fixing rustfmt, rls and the other tools that the compiler builds.\n-\n-Luckily, a feature was [added to Rust's build](https://github.com/rust-lang/rust/issues/45861)\n-to make all of this easy to handle. The idea is that we allow these tools to be \"broken\",\n-so that the rust-lang/rust build passes without trying to build them, then land the change\n-in the compiler, wait for a nightly, and go update the tools that you broke. Once you're done\n-and the tools are working again, you go back in the compiler and update the tools\n-so they can be distributed again.\n-\n-This should avoid a bunch of synchronization dances and is also much easier on contributors as\n-there's no need to block on rls/rustfmt/other tools changes going upstream.\n-\n-Here are those same steps in detail:\n-\n-1. (optional) First, if it doesn't exist already, create a `config.toml` by copying\n-   `config.toml.example` in the root directory of the Rust repository.\n-   Set `submodules = false` in the `[build]` section. This will prevent `x.py`\n-   from resetting to the original branch after you make your changes. If you\n-   need to [update any submodules to their latest versions](#updating-submodules),\n-   see the section of this file about that for more information.\n-2. (optional) Run `./x.py test src/tools/rustfmt` (substituting the submodule\n-   that broke for `rustfmt`). Fix any errors in the submodule (and possibly others).\n-3. (optional) Make commits for your changes and send them to upstream repositories as a PR.\n-4. (optional) Maintainers of these submodules will **not** merge the PR. The PR can't be\n-   merged because CI will be broken. You'll want to write a message on the PR referencing\n-   your change, and how the PR should be merged once your change makes it into a nightly.\n-5. Wait for your PR to merge.\n-6. Wait for a nightly\n-7. (optional) Help land your PR on the upstream repository now that your changes are in nightly.\n-8. (optional) Send a PR to rust-lang/rust updating the submodule.\n-\n-#### Updating submodules\n-\n-These instructions are specific to updating `rustfmt`, however they may apply\n-to the other submodules as well. Please help by improving these instructions\n-if you find any discrepancies or special cases that need to be addressed.\n-\n-To update the `rustfmt` submodule, start by running the appropriate\n-[`git submodule` command](https://git-scm.com/book/en/v2/Git-Tools-Submodules).\n-For example, to update to the latest commit on the remote master branch,\n-you may want to run:\n-```\n-git submodule update --remote src/tools/rustfmt\n-```\n-If you run `./x.py build` now, and you are lucky, it may just work. If you see\n-an error message about patches that did not resolve to any crates, you will need\n-to complete a few more steps which are outlined with their rationale below.\n-\n-*(This error may change in the future to include more information.)*\n-```\n-error: failed to resolve patches for `https://github.com/rust-lang/rustfmt`\n-\n-Caused by:\n-  patch for `rustfmt-nightly` in `https://github.com/rust-lang/rustfmt` did not resolve to any crates\n-failed to run: ~/rust/build/x86_64-unknown-linux-gnu/stage0/bin/cargo build --manifest-path ~/rust/src/bootstrap/Cargo.toml\n-```\n-\n-If you haven't used the `[patch]`\n-section of `Cargo.toml` before, there is [some relevant documentation about it\n-in the cargo docs](http://doc.crates.io/manifest.html#the-patch-section). In\n-addition to that, you should read the\n-[Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#overriding-dependencies)\n-section of the documentation as well.\n-\n-Specifically, the following [section in Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#testing-a-bugfix) reveals what the problem is:\n-\n-> Next up we need to ensure that our lock file is updated to use this new version of uuid so our project uses the locally checked out copy instead of one from crates.io. The way [patch] works is that it'll load the dependency at ../path/to/uuid and then whenever crates.io is queried for versions of uuid it'll also return the local version.\n->\n-> This means that the version number of the local checkout is significant and will affect whether the patch is used. Our manifest declared uuid = \"1.0\" which means we'll only resolve to >= 1.0.0, < 2.0.0, and Cargo's greedy resolution algorithm also means that we'll resolve to the maximum version within that range. Typically this doesn't matter as the version of the git repository will already be greater or match the maximum version published on crates.io, but it's important to keep this in mind!\n-\n-This says that when we updated the submodule, the version number in our\n-`src/tools/rustfmt/Cargo.toml` changed. The new version is different from\n-the version in `Cargo.lock`, so the build can no longer continue.\n-\n-To resolve this, we need to update `Cargo.lock`. Luckily, cargo provides a\n-command to do this easily.\n-\n-```\n-$ cargo update -p rustfmt-nightly\n-```\n-\n-This should change the version listed in `Cargo.lock` to the new version you updated\n-the submodule to. Running `./x.py build` should work now.\n-\n-## Writing Documentation\n-\n-Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n-is located in `src/doc` in the tree, and standard API documentation is generated\n-from the source code itself. Documentation pull requests function in the same way\n-as other pull requests.\n-\n-To find documentation-related issues, sort by the [T-doc label][tdoc].\n-\n-[tdoc]: https://github.com/rust-lang/rust/issues?q=is%3Aopen%20is%3Aissue%20label%3AT-doc\n-\n-You can find documentation style guidelines in [RFC 1574][rfc1574].\n-\n-[rfc1574]: https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#appendix-a-full-conventions-text\n-\n-In many cases, you don't need a full `./x.py doc`. You can use `rustdoc` directly\n-to check small fixes. For example, `rustdoc src/doc/reference.md` will render\n-reference to `doc/reference.html`. The CSS might be messed up, but you can\n-verify that the HTML is right.\n-\n-Additionally, contributions to the [rustc-dev-guide] are always welcome. Contributions\n-can be made directly at [the\n-rust-lang/rustc-dev-guide](https://github.com/rust-lang/rustc-dev-guide) repo. The issue\n-tracker in that repo is also a great way to find things that need doing. There\n-are issues for beginners and advanced compiler devs alike!\n-\n-## Issue Triage\n-\n-Sometimes, an issue will stay open, even though the bug has been fixed. And\n-sometimes, the original bug may go stale because something has changed in the\n-meantime.\n-\n-It can be helpful to go through older bug reports and make sure that they are\n-still valid. Load up an older issue, double check that it's still true, and\n-leave a comment letting us know if it is or is not. The [least recently\n-updated sort][lru] is good for finding issues like this.\n-\n-Contributors with sufficient permissions on the Rust repo can help by adding\n-labels to triage issues:\n-\n-* Yellow, **A**-prefixed labels state which **area** of the project an issue\n-  relates to.\n-\n-* Magenta, **B**-prefixed labels identify bugs which are **blockers**.\n-\n-* Dark blue, **beta-** labels track changes which need to be backported into\n-  the beta branches.\n-\n-* Light purple, **C**-prefixed labels represent the **category** of an issue.\n-\n-* Green, **E**-prefixed labels explain the level of **experience** necessary\n-  to fix the issue.\n-\n-* The dark blue **final-comment-period** label marks bugs that are using the\n-  RFC signoff functionality of [rfcbot] and are currently in the final\n-  comment period.\n-\n-* Red, **I**-prefixed labels indicate the **importance** of the issue. The\n-  [I-nominated][inom] label indicates that an issue has been nominated for\n-  prioritizing at the next triage meeting.\n-\n-* The purple **metabug** label marks lists of bugs collected by other\n-  categories.\n-\n-* Purple gray, **O**-prefixed labels are the **operating system** or platform\n-  that this issue is specific to.\n-\n-* Orange, **P**-prefixed labels indicate a bug's **priority**. These labels\n-  are only assigned during triage meetings, and replace the [I-nominated][inom]\n-  label.\n-\n-* The gray **proposed-final-comment-period** label marks bugs that are using\n-  the RFC signoff functionality of [rfcbot] and are currently awaiting\n-  signoff of all team members in order to enter the final comment period.\n-\n-* Pink, **regression**-prefixed labels track regressions from stable to the\n-  release channels.\n-\n-* The light orange **relnotes** label marks issues that should be documented in\n-  the release notes of the next release.\n-\n-* Gray, **S**-prefixed labels are used for tracking the **status** of pull\n-  requests.\n-\n-* Blue, **T**-prefixed bugs denote which **team** the issue belongs to.\n-\n-If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n-\n-[inom]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-nominated\n-[eeasy]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy\n-[lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n-[rfcbot]: https://github.com/anp/rfcbot-rs/\n-\n-## Out-of-tree Contributions\n-\n-There are a number of other ways to contribute to Rust that don't deal with\n-this repository.\n-\n-Answer questions in the _Get Help!_ channels from the [Rust Discord server][rust-discord], on [users.rust-lang.org][users],\n-or on [StackOverflow][so].\n-\n-Participate in the [RFC process](https://github.com/rust-lang/rfcs).\n-\n-Find a [requested community library][community-library], build it, and publish\n-it to [Crates.io](http://crates.io). Easier said than done, but very, very\n-valuable!\n-\n-[rust-discord]: https://discord.gg/rust-lang\n-[users]: https://users.rust-lang.org/\n-[so]: http://stackoverflow.com/questions/tagged/rust\n-[community-library]: https://github.com/rust-lang/rfcs/labels/A-community-library\n-\n-## Helpful Links and Information\n-\n-For people new to Rust, and just starting to contribute, or even for\n-more seasoned developers, some useful places to look for information\n-are:\n-\n-* The [rustc dev guide] contains information about how various parts of the compiler work and how to contribute to the compiler\n-* [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n-* The [Rust Internals forum][rif], a place to ask questions and\n-  discuss Rust's internals\n-* The [generated documentation for rust's compiler][gdfrustc]\n-* The [rust reference][rr], even though it doesn't specifically talk about Rust's internals, it's a great resource nonetheless\n-* Although out of date, [Tom Lee's great blog article][tlgba] is very helpful\n-* [rustaceans.org][ro] is helpful, but mostly dedicated to IRC\n-* The [Rust Compiler Testing Docs][rctd]\n-* For [@bors][bors], [this cheat sheet][cheatsheet] is helpful\n-(though you'll need to replace `@homu` with `@bors` in any commands)\n-* **Google!** ([search only in Rust Documentation][gsearchdocs] to find types, traits, etc. quickly)\n-* Don't be afraid to ask! The Rust community is friendly and helpful.\n-\n-[rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[gdfrustc]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n-[gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n-[rif]: http://internals.rust-lang.org\n-[rr]: https://doc.rust-lang.org/book/README.html\n-[rustforge]: https://forge.rust-lang.org/\n-[tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n-[ro]: http://www.rustaceans.org/\n-[rctd]: https://rustc-dev-guide.rust-lang.org/tests/intro.html\n-[cheatsheet]: https://buildbot2.rust-lang.org/homu/"}, {"sha": "905f523aa53d666f67571b835d419e68ba8991bb", "filename": "Cargo.lock", "status": "modified", "additions": 474, "deletions": 927, "changes": 1401, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "be15e50e2bcca07d92d6615542914b4c0ba112f7", "filename": "Cargo.toml", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -22,6 +22,7 @@ members = [\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\",\n   \"src/tools/miri\",\n+  \"src/tools/miri/cargo-miri\",\n   \"src/tools/rustdoc-themes\",\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\",\n@@ -32,14 +33,27 @@ exclude = [\n   \"obj\",\n ]\n \n-# These options are controlled from our rustc wrapper script, so turn them off\n-# here and have them controlled elsewhere.\n-[profile.dev]\n-debug = false\n-debug-assertions = false\n-[profile.test]\n-debug = false\n+[profile.release.package.compiler_builtins]\n+# The compiler-builtins crate cannot reference libcore, and it's own CI will\n+# verify that this is the case. This requires, however, that the crate is built\n+# without overflow checks and debug assertions. Forcefully disable debug\n+# assertions and overflow checks here which should ensure that even if these\n+# assertions are enabled for libstd we won't enable then for compiler_builtins\n+# which should ensure we still link everything correctly.\n debug-assertions = false\n+overflow-checks = false\n+\n+# For compiler-builtins we always use a high number of codegen units.\n+# The goal here is to place every single intrinsic into its own object\n+# file to avoid symbol clashes with the system libgcc if possible. Note\n+# that this number doesn't actually produce this many object files, we\n+# just don't create more than this number of object files.\n+#\n+# It's a bit of a bummer that we have to pass this here, unfortunately.\n+# Ideally this would be specified through an env var to Cargo so Cargo\n+# knows how many CGUs are for this specific crate, but for now\n+# per-crate configuration isn't specifiable in the environment.\n+codegen-units = 10000\n \n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the"}, {"sha": "639789123d8321ebedda2356f910934393bc97e3", "filename": "README.md", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,10 +1,14 @@\n-# The Rust Programming Language\n+<a href = \"https://www.rust-lang.org/\"> \n+<img width = \"90%\" height = \"auto\" src = \"https://img.shields.io/badge/Rust-Programming%20Language-black?style=flat&logo=rust\" alt = \"The Rust Programming Language\">\n+</a>\n \n This is the main source code repository for [Rust]. It contains the compiler,\n-standard library, and documentation.\n+standard library, and documentation. \n \n [Rust]: https://www.rust-lang.org\n \n+**Note: this README is for _users_ rather than _contributors_.**\n+\n ## Quick Start\n \n Read [\"Installation\"] from [The Book].\n@@ -14,16 +18,18 @@ Read [\"Installation\"] from [The Book].\n \n ## Installing from Source\n \n-_Note: If you wish to contribute to the compiler, you should read [this\n-chapter][rustcguidebuild] of the rustc-dev-guide instead of this section._\n+**Note: If you wish to _contribute_ to the compiler, you should read the\n+[Getting Started][gettingstarted] of the rustc-dev-guide instead of this\n+section.**\n \n-The Rust build system has a Python script called `x.py` to bootstrap building\n-the compiler. More information about it may be found by running `./x.py --help`\n-or reading the [rustc dev guide][rustcguidebuild].\n+The Rust build system uses a Python script called `x.py` to build the compiler,\n+which manages the bootstrapping process. More information about it can be found \n+by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n \n+[gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n \n-### Building on *nix\n+### Building on a Unix-like system\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 5.1 or later or `clang++` 3.5 or later\n@@ -54,9 +60,8 @@ or reading the [rustc dev guide][rustcguidebuild].\n     $ cp config.toml.example config.toml\n     ```\n \n-    It is recommended that if you plan to use the Rust build system to create\n-    an installation (using `./x.py install`) that you set the `prefix` value\n-    in the `[install]` section to a directory that you have write permissions.\n+    If you plan to use `x.py install` to create an installation, it is recommended\n+    that you set the `prefix` value in the `[install]` section to a directory.\n \n     Create install directory if you are not installing in default directory\n \n@@ -143,8 +148,8 @@ shell with:\n ```\n \n Currently, building Rust only works with some known versions of Visual Studio. If\n-you have a more recent version installed the build system doesn't understand\n-then you may need to force rustbuild to use an older version. This can be done\n+you have a more recent version installed and the build system doesn't understand,\n+you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch\n@@ -224,10 +229,6 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n-There is more advice about hacking on Rust in [CONTRIBUTING.md].\n-\n-[CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md\n-\n ## Getting Help\n \n The Rust community congregates in a few places:\n@@ -242,21 +243,8 @@ The Rust community congregates in a few places:\n \n ## Contributing\n \n-To contribute to Rust, please see [CONTRIBUTING](CONTRIBUTING.md).\n-\n-Most real-time collaboration happens in a variety of channels on the\n-[Rust Discord server][rust-discord], with channels dedicated for getting help,\n-community, documentation, and all major contribution areas in the Rust ecosystem.\n-A good place to ask for help would be the #help channel.\n-\n-The [rustc dev guide] might be a good place to start if you want to find out how\n-various parts of the compiler work.\n-\n-Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n-\n-[rust-discord]: https://discord.gg/rust-lang\n-[rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n+If you are interested in contributing to the Rust project, please take a look\n+at the [Getting Started][gettingstarted] guide in the [rustc-dev-guide].\n \n ## License\n "}, {"sha": "006682f50593662b5cef199b4ec7f4beece47062", "filename": "RELEASES.md", "status": "modified", "additions": 179, "deletions": 5, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,3 +1,177 @@\n+Version 1.44.0 (2020-06-04)\n+==========================\n+\n+Language\n+--------\n+- [You can now use `async/.await` with `#[no_std]` enabled.][69033]\n+- [Added the `unused_braces` lint.][70081]\n+\n+**Syntax-only changes**\n+\n+- [Expansion-driven outline module parsing][69838]\n+```rust\n+#[cfg(FALSE)]\n+mod foo {\n+    mod bar {\n+        mod baz; // `foo/bar/baz.rs` doesn't exist, but no error!\n+    }\n+}\n+```\n+\n+These are still rejected semantically, so you will likely receive an error but\n+these changes can be seen and parsed by macros and conditional compilation.\n+\n+Compiler\n+--------\n+- [Rustc now respects the `-C codegen-units` flag in incremental mode.][70156]\n+  Additionally when in incremental mode rustc defaults to 256 codegen units.\n+- [Refactored `catch_unwind` to have zero-cost, unless unwinding is enabled and\n+  a panic is thrown.][67502]\n+- [Added tier 3\\* support for the `aarch64-unknown-none` and\n+  `aarch64-unknown-none-softfloat` targets.][68334]\n+- [Added tier 3 support for `arm64-apple-tvos` and\n+  `x86_64-apple-tvos` targets.][68191]\n+\n+\n+Libraries\n+---------\n+- [Special cased `vec![]` to map directly to `Vec::new()`.][70632] This allows\n+  `vec![]` to be able to be used in `const` contexts.\n+- [`convert::Infallible` now implements `Hash`.][70281]\n+- [`OsString` now implements `DerefMut` and `IndexMut` returning\n+  a `&mut OsStr`.][70048]\n+- [Unicode 13 is now supported.][69929]\n+- [`String` now implements `From<&mut str>`.][69661]\n+- [`IoSlice` now implements `Copy`.][69403]\n+- [`Vec<T>` now implements `From<[T; N]>`.][68692] Where `N` is at most 32.\n+- [`proc_macro::LexError` now implements `fmt::Display` and `Error`.][68899]\n+- [`from_le_bytes`, `to_le_bytes`, `from_be_bytes`, `to_be_bytes`,\n+  `from_ne_bytes`, and `to_ne_bytes` methods are now `const` for all\n+  integer types.][69373]\n+\n+Stabilized APIs\n+---------------\n+- [`PathBuf::with_capacity`]\n+- [`PathBuf::capacity`]\n+- [`PathBuf::clear`]\n+- [`PathBuf::reserve`]\n+- [`PathBuf::reserve_exact`]\n+- [`PathBuf::shrink_to_fit`]\n+- [`f32::to_int_unchecked`]\n+- [`f64::to_int_unchecked`]\n+- [`Layout::align_to`]\n+- [`Layout::pad_to_align`]\n+- [`Layout::array`]\n+- [`Layout::extend`]\n+\n+Cargo\n+-----\n+- [Added the `cargo tree` command which will print a tree graph of\n+  your dependencies.][cargo/8062] E.g.\n+  ```\n+    mdbook v0.3.2 (/Users/src/rust/mdbook)\n+  \u251c\u2500\u2500 ammonia v3.0.0\n+  \u2502   \u251c\u2500\u2500 html5ever v0.24.0\n+  \u2502   \u2502   \u251c\u2500\u2500 log v0.4.8\n+  \u2502   \u2502   \u2502   \u2514\u2500\u2500 cfg-if v0.1.9\n+  \u2502   \u2502   \u251c\u2500\u2500 mac v0.1.1\n+  \u2502   \u2502   \u2514\u2500\u2500 markup5ever v0.9.0\n+  \u2502   \u2502       \u251c\u2500\u2500 log v0.4.8 (*)\n+  \u2502   \u2502       \u251c\u2500\u2500 phf v0.7.24\n+  \u2502   \u2502       \u2502   \u2514\u2500\u2500 phf_shared v0.7.24\n+  \u2502   \u2502       \u2502       \u251c\u2500\u2500 siphasher v0.2.3\n+  \u2502   \u2502       \u2502       \u2514\u2500\u2500 unicase v1.4.2\n+  \u2502   \u2502       \u2502           [build-dependencies]\n+  \u2502   \u2502       \u2502           \u2514\u2500\u2500 version_check v0.1.5\n+  ...\n+  ```\n+  You can also display dependencies on multiple versions of the same crate with\n+  `cargo tree -d` (short for `cargo tree --duplicates`).\n+\n+Misc\n+----\n+- [Rustdoc now allows you to specify `--crate-version` to have rustdoc include\n+  the version in the sidebar.][69494]\n+\n+Compatibility Notes\n+-------------------\n+- [Rustc now correctly generates static libraries on Windows GNU targets with\n+  the `.a` extension, rather than the previous `.lib`.][70937]\n+- [Removed the `-C no_integrated_as` flag from rustc.][70345]\n+- [The `file_name` property in JSON output of macro errors now points the actual\n+  source file rather than the previous format of `<NAME macros>`.][70969]\n+  **Note:** this may not point to a file that actually exists on the user's system.\n+- [The minimum required external LLVM version has been bumped to LLVM 8.][71147]\n+- [`mem::{zeroed, uninitialised}` will now panic when used with types that do\n+  not allow zero initialization such as `NonZeroU8`.][66059] This was\n+  previously a warning.\n+- [In 1.45.0 (the next release) converting a `f64` to `u32` using the `as`\n+  operator has been defined as a saturating operation.][71269] This was previously\n+  undefined behaviour, but you can use the `{f64, f32}::to_int_unchecked` methods to\n+  continue using the current behaviour, which may be desirable in rare performance\n+  sensitive situations.\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [dep_graph Avoid allocating a set on when the number reads are small.][69778]\n+- [Replace big JS dict with JSON parsing.][71250]\n+\n+[69373]: https://github.com/rust-lang/rust/pull/69373/\n+[66059]: https://github.com/rust-lang/rust/pull/66059/\n+[68191]: https://github.com/rust-lang/rust/pull/68191/\n+[68899]: https://github.com/rust-lang/rust/pull/68899/\n+[71147]: https://github.com/rust-lang/rust/pull/71147/\n+[71250]: https://github.com/rust-lang/rust/pull/71250/\n+[70937]: https://github.com/rust-lang/rust/pull/70937/\n+[70969]: https://github.com/rust-lang/rust/pull/70969/\n+[70632]: https://github.com/rust-lang/rust/pull/70632/\n+[70281]: https://github.com/rust-lang/rust/pull/70281/\n+[70345]: https://github.com/rust-lang/rust/pull/70345/\n+[70048]: https://github.com/rust-lang/rust/pull/70048/\n+[70081]: https://github.com/rust-lang/rust/pull/70081/\n+[70156]: https://github.com/rust-lang/rust/pull/70156/\n+[71269]: https://github.com/rust-lang/rust/pull/71269/\n+[69838]: https://github.com/rust-lang/rust/pull/69838/\n+[69929]: https://github.com/rust-lang/rust/pull/69929/\n+[69661]: https://github.com/rust-lang/rust/pull/69661/\n+[69778]: https://github.com/rust-lang/rust/pull/69778/\n+[69494]: https://github.com/rust-lang/rust/pull/69494/\n+[69403]: https://github.com/rust-lang/rust/pull/69403/\n+[69033]: https://github.com/rust-lang/rust/pull/69033/\n+[68692]: https://github.com/rust-lang/rust/pull/68692/\n+[68334]: https://github.com/rust-lang/rust/pull/68334/\n+[67502]: https://github.com/rust-lang/rust/pull/67502/\n+[cargo/8062]: https://github.com/rust-lang/cargo/pull/8062/\n+[`PathBuf::with_capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.with_capacity\n+[`PathBuf::capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.capacity\n+[`PathBuf::clear`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.clear\n+[`PathBuf::reserve`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve\n+[`PathBuf::reserve_exact`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve_exact\n+[`PathBuf::shrink_to_fit`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.shrink_to_fit\n+[`f32::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_int_unchecked\n+[`f64::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_int_unchecked\n+[`Layout::align_to`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.align_to\n+[`Layout::pad_to_align`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.pad_to_align\n+[`Layout::array`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.array\n+[`Layout::extend`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.extend\n+\n+\n+Version 1.43.1 (2020-05-07)\n+===========================\n+\n+* [Updated openssl-src to 1.1.1g for CVE-2020-1967.][71430]\n+* [Fixed the stabilization of AVX-512 features.][71473]\n+* [Fixed `cargo package --list` not working with unpublished dependencies.][cargo/8151]\n+\n+[71430]: https://github.com/rust-lang/rust/pull/71430\n+[71473]: https://github.com/rust-lang/rust/issues/71473\n+[cargo/8151]: https://github.com/rust-lang/cargo/issues/8151\n+\n+\n Version 1.43.0 (2020-04-23)\n ==========================\n \n@@ -14,7 +188,7 @@ Language\n - [Merge `fn` syntax + cleanup item parsing.][68728]\n - [`item` macro fragments can be interpolated into `trait`s, `impl`s, and `extern` blocks.][69366]\n   For example, you may now write:\n-  ```rust \n+  ```rust\n   macro_rules! mac_trait {\n       ($i:item) => {\n           trait T { $i }\n@@ -82,7 +256,7 @@ Misc\n - [Certain checks in the `const_err` lint were deemed unrelated to const\n   evaluation][69185], and have been moved to the `unconditional_panic` and\n   `arithmetic_overflow` lints.\n-  \n+\n Compatibility Notes\n -------------------\n \n@@ -173,7 +347,7 @@ Language\n      (e.g. `type Foo: Ord;`).\n    - `...` (the C-variadic type) may occur syntactically directly as the type of\n       any function parameter.\n-  \n+\n   These are still rejected *semantically*, so you will likely receive an error\n   but these changes can be seen and parsed by procedural macros and\n   conditional compilation.\n@@ -465,7 +639,7 @@ Compatibility Notes\n - [Using `#[inline]` on function prototypes and consts now emits a warning under\n   `unused_attribute` lint.][65294] Using `#[inline]` anywhere else inside traits\n   or `extern` blocks now correctly emits a hard error.\n-  \n+\n [65294]: https://github.com/rust-lang/rust/pull/65294/\n [66103]: https://github.com/rust-lang/rust/pull/66103/\n [65843]: https://github.com/rust-lang/rust/pull/65843/\n@@ -738,7 +912,7 @@ Compatibility Notes\n [`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n [`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n [`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n-[forge-platform-support]: https://forge.rust-lang.org/platform-support.html\n+[forge-platform-support]: https://forge.rust-lang.org/release/platform-support.html\n [pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n \n Version 1.37.0 (2019-08-15)"}, {"sha": "79e4e46d85ba344ea441ea279ae17923903610e2", "filename": "config.toml.example", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -69,7 +69,7 @@\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n # on them will not work unless the user opts in to building them.\n-#experimental-targets = \"\"\n+#experimental-targets = \"AVR\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly\n@@ -118,18 +118,28 @@\n # nightlies are already produced for. The current platform must be able to run\n # binaries of this build triple and the nightly will be used to bootstrap the\n # first compiler.\n-#build = \"x86_64-unknown-linux-gnu\"    # defaults to your host platform\n+#\n+# Defaults to host platform\n+#build = \"x86_64-unknown-linux-gnu\"\n \n # In addition to the build triple, other triples to produce full compiler\n # toolchains for. Each of these triples will be bootstrapped from the build\n # triple and then will continue to bootstrap themselves. This platform must\n # currently be able to run all of the triples provided here.\n-#host = [\"x86_64-unknown-linux-gnu\"]   # defaults to just the build triple\n+#\n+# Defaults to just the build triple\n+#host = [\"x86_64-unknown-linux-gnu\"]\n \n # In addition to all host triples, other triples to produce the standard library\n # for. Each host triple will be used to produce a copy of the standard library\n # for each target triple.\n-#target = [\"x86_64-unknown-linux-gnu\"] # defaults to just the build triple\n+#\n+# Defaults to just the build triple\n+#target = [\"x86_64-unknown-linux-gnu\"]\n+\n+# Use this directory to store build artifacts.\n+# You can use \"$ROOT\" to indicate the root of the git repository.\n+#build-dir = \"build\"\n \n # Instead of downloading the src/stage0.txt version of Cargo specified, use\n # this Cargo binary instead to build all Rust code\n@@ -170,7 +180,7 @@\n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n #\n-# Defaults to the Python interpreter used to execute x.py.\n+# Defaults to the Python interpreter used to execute x.py\n #python = \"python\"\n \n # Force Cargo to check that Cargo.lock describes the precise dependency\n@@ -205,7 +215,8 @@\n # Build the sanitizer runtimes\n #sanitizers = false\n \n-# Build the profiler runtime\n+# Build the profiler runtime (required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n #profiler = false\n \n # Indicates whether the native libraries linked into Cargo will be statically\n@@ -307,26 +318,46 @@\n #codegen-units-std = 1\n \n # Whether or not debug assertions are enabled for the compiler and standard\n-# library.\n+# library. Debug assertions control the maximum log level used by rustc. When\n+# enabled calls to `trace!` and `debug!` macros are preserved in the compiled\n+# binary, otherwise they are omitted.\n+#\n+# Defaults to rust.debug value\n #debug-assertions = false\n \n+# Whether or not debug assertions are enabled for the standard library.\n+# Overrides the `debug-assertions` option, if defined.\n+#\n+# Defaults to rust.debug-assertions value\n+#debug-assertions-std = false\n+\n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info\n-# `1` - line tables only\n+# `1` - line tables only - sufficient to generate backtraces that include line\n+#       information and inlined functions, set breakpoints at source code\n+#       locations, and step through execution in a debugger.\n # `2` - full debug info with variable and type information\n # Can be overridden for specific subsets of Rust code (rustc, std or tools).\n # Debuginfo for tests run with compiletest is not controlled by this option\n # and needs to be enabled separately with `debuginfo-level-tests`.\n-#debuginfo-level = if debug { 2 } else { 0 }\n+#\n+# Defaults to 2 if debug is true\n+#debuginfo-level = 0\n \n # Debuginfo level for the compiler.\n-#debuginfo-level-rustc = debuginfo-level\n+#\n+# Defaults to rust.debuginfo-level value\n+#debuginfo-level-rustc = 0\n \n # Debuginfo level for the standard library.\n-#debuginfo-level-std = debuginfo-level\n+#\n+# Defaults to rust.debuginfo-level value\n+#debuginfo-level-std = 0\n \n # Debuginfo level for the tools.\n-#debuginfo-level-tools = debuginfo-level\n+#\n+# Defaults to rust.debuginfo-level value\n+#debuginfo-level-tools = 0\n \n # Debuginfo level for the test suites run with compiletest.\n # FIXME(#61117): Some tests fail when this option is enabled.\n@@ -351,7 +382,7 @@\n # nightly features\n #channel = \"dev\"\n \n-# The root location of the MUSL installation directory.\n+# The root location of the musl installation directory.\n #musl-root = \"...\"\n \n # By default the `rustc` executable is built with `-Wl,-rpath` flags on Unix\n@@ -407,10 +438,6 @@\n # sysroot.\n #llvm-tools = false\n \n-# Indicates whether LLDB will be made available in the sysroot.\n-# This is only built if LLVM is also being built.\n-#lldb = false\n-\n # Whether to deny warnings in crates\n #deny-warnings = true\n \n@@ -498,12 +525,15 @@\n # only use static libraries. If unset, the target's default linkage is used.\n #crt-static = false\n \n-# The root location of the MUSL installation directory. The library directory\n+# The root location of the musl installation directory. The library directory\n # will also need to contain libunwind.a for an unwinding implementation. Note\n-# that this option only makes sense for MUSL targets that produce statically\n+# that this option only makes sense for musl targets that produce statically\n # linked binaries\n #musl-root = \"...\"\n \n+# The full path to the musl libdir.\n+#musl-libdir = musl-root/lib\n+\n # The root location of the `wasm32-wasi` sysroot.\n #wasi-root = \"...\"\n "}, {"sha": "c76a75fa07bb0361eee0acda48734f8c58c797a2", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -27,6 +27,7 @@ ignore = [\n     \"src/tools/clippy\",\n     \"src/tools/miri\",\n     \"src/tools/rls\",\n+    \"src/tools/rust-analyzer\",\n     \"src/tools/rust-installer\",\n     \"src/tools/rustfmt\",\n "}, {"sha": "c4918d7f2e7146795f0d5fdf5ea485dc2d6386bc", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -48,6 +48,7 @@ toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n+opener = \"0.4\"\n \n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\""}, {"sha": "89984bb55dfd82380ade435c25e362176592a593", "filename": "src/bootstrap/bin/llvm-config-wrapper.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -10,7 +10,14 @@ fn main() {\n     let mut cmd = Command::new(real_llvm_config);\n     cmd.args(env::args().skip(1)).stderr(Stdio::piped());\n     let output = cmd.output().expect(\"failed to spawn llvm-config\");\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let mut stdout = String::from_utf8_lossy(&output.stdout);\n+\n+    if let Ok(to_replace) = env::var(\"LLVM_CONFIG_SHIM_REPLACE\") {\n+        if let Ok(replace_with) = env::var(\"LLVM_CONFIG_SHIM_REPLACE_WITH\") {\n+            stdout = stdout.replace(&to_replace, &replace_with).into();\n+        }\n+    }\n+\n     print!(\"{}\", stdout.replace(\"\\\\\", \"/\"));\n     io::stdout().flush().unwrap();\n     process::exit(output.status.code().unwrap_or(1));"}, {"sha": "3072a4a1ae7c035c987c06332b63dc32e91bbe51", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -101,30 +101,6 @@ fn main() {\n         {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n-\n-        // Set various options from config.toml to configure how we're building\n-        // code.\n-        let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n-            Ok(s) => {\n-                if s == \"true\" {\n-                    \"y\"\n-                } else {\n-                    \"n\"\n-                }\n-            }\n-            Err(..) => \"n\",\n-        };\n-\n-        // The compiler builtins are pretty sensitive to symbols referenced in\n-        // libcore and such, so we never compile them with debug assertions.\n-        //\n-        // FIXME(rust-lang/cargo#7253) we should be doing this in `builder.rs`\n-        // with env vars instead of doing it here in this script.\n-        if crate_name == Some(\"compiler_builtins\") {\n-            cmd.arg(\"-C\").arg(\"debug-assertions=no\");\n-        } else {\n-            cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n-        }\n     } else {\n         // FIXME(rust-lang/cargo#5754) we shouldn't be using special env vars\n         // here, but rather Cargo should know what flags to pass rustc itself."}, {"sha": "8c56cf1cb3414bb1508114f63ce389b9a4fddc20", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -13,7 +13,6 @@ fn main() {\n     let libdir = env::var_os(\"RUSTDOC_LIBDIR\").expect(\"RUSTDOC_LIBDIR was not set\");\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n-    let mut has_unstable = false;\n \n     use std::str::FromStr;\n \n@@ -55,22 +54,10 @@ fn main() {\n         cmd.arg(\"--crate-version\").arg(version);\n     }\n \n-    // Needed to be able to run all rustdoc tests.\n-    if env::var_os(\"RUSTDOC_GENERATE_REDIRECT_PAGES\").is_some() {\n-        // This \"unstable-options\" can be removed when `--generate-redirect-pages` is stabilized\n-        if !has_unstable {\n-            cmd.arg(\"-Z\").arg(\"unstable-options\");\n-        }\n-        cmd.arg(\"--generate-redirect-pages\");\n-        has_unstable = true;\n-    }\n-\n     // Needed to be able to run all rustdoc tests.\n     if let Some(ref x) = env::var_os(\"RUSTDOC_RESOURCE_SUFFIX\") {\n         // This \"unstable-options\" can be removed when `--resource-suffix` is stabilized\n-        if !has_unstable {\n-            cmd.arg(\"-Z\").arg(\"unstable-options\");\n-        }\n+        cmd.arg(\"-Z\").arg(\"unstable-options\");\n         cmd.arg(\"--resource-suffix\").arg(x);\n     }\n "}, {"sha": "1dfa635c694acdc06bcb3f256e8fe267014d06d6", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -2,6 +2,7 @@\n import argparse\n import contextlib\n import datetime\n+import distutils.version\n import hashlib\n import os\n import re\n@@ -78,6 +79,7 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-#\"\n         else:\n             option = \"-s\"\n+        require([\"curl\", \"--version\"])\n         run([\"curl\", option,\n              \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n              \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n@@ -142,6 +144,21 @@ def run(args, verbose=False, exception=False, **kwargs):\n         sys.exit(err)\n \n \n+def require(cmd, exit=True):\n+    '''Run a command, returning its output.\n+    On error,\n+        If `exit` is `True`, exit the process.\n+        Otherwise, return None.'''\n+    try:\n+        return subprocess.check_output(cmd).strip()\n+    except (subprocess.CalledProcessError, OSError) as exc:\n+        if not exit:\n+            return None\n+        print(\"error: unable to run `{}`: {}\".format(' '.join(cmd), exc))\n+        print(\"Please make sure it's installed and in the path.\")\n+        sys.exit(1)\n+\n+\n def stage0_data(rust_root):\n     \"\"\"Build a dictionary from stage0.txt\"\"\"\n     nightlies = os.path.join(rust_root, \"src/stage0.txt\")\n@@ -163,16 +180,16 @@ def format_build_time(duration):\n def default_build_triple():\n     \"\"\"Build triple as in LLVM\"\"\"\n     default_encoding = sys.getdefaultencoding()\n-    try:\n-        ostype = subprocess.check_output(\n-            ['uname', '-s']).strip().decode(default_encoding)\n-        cputype = subprocess.check_output(\n-            ['uname', '-m']).strip().decode(default_encoding)\n-    except (subprocess.CalledProcessError, OSError):\n-        if sys.platform == 'win32':\n-            return 'x86_64-pc-windows-msvc'\n-        err = \"uname not found\"\n-        sys.exit(err)\n+    required = sys.platform != 'win32'\n+    ostype = require([\"uname\", \"-s\"], exit=required)\n+    cputype = require(['uname', '-m'], exit=required)\n+\n+    # If we do not have `uname`, assume Windows.\n+    if ostype is None or cputype is None:\n+        return 'x86_64-pc-windows-msvc'\n+\n+    ostype = ostype.decode(default_encoding)\n+    cputype = cputype.decode(default_encoding)\n \n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n@@ -202,12 +219,7 @@ def default_build_triple():\n         # output from that option is too generic for our purposes (it will\n         # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n         # must be used instead.\n-        try:\n-            cputype = subprocess.check_output(\n-                ['isainfo', '-k']).strip().decode(default_encoding)\n-        except (subprocess.CalledProcessError, OSError):\n-            err = \"isainfo not found\"\n-            sys.exit(err)\n+        cputype = require(['isainfo', '-k']).decode(default_encoding)\n     elif ostype.startswith('MINGW'):\n         # msys' `uname` does not print gcc configuration, but prints msys\n         # configuration. so we cannot believe `uname -m`:\n@@ -225,6 +237,11 @@ def default_build_triple():\n         if ostype.endswith('WOW64'):\n             cputype = 'x86_64'\n         ostype = 'pc-windows-gnu'\n+    elif sys.platform == 'win32':\n+        # Some Windows platforms might have a `uname` command that returns a\n+        # non-standard string (e.g. gnuwin32 tools returns `windows32`). In\n+        # these cases, fall back to using sys.platform.\n+        return 'x86_64-pc-windows-msvc'\n     else:\n         err = \"unknown OS type: {}\".format(ostype)\n         sys.exit(err)\n@@ -324,13 +341,14 @@ def __init__(self):\n         self.rustc_channel = ''\n         self.rustfmt_channel = ''\n         self.build = ''\n-        self.build_dir = os.path.join(os.getcwd(), \"build\")\n+        self.build_dir = ''\n         self.clean = False\n         self.config_toml = ''\n         self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n+        self.git_version = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -743,15 +761,13 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n         run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n-        try:\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", \"--progress\", module],\n-                cwd=self.rust_root, verbose=self.verbose, exception=True)\n-        except RuntimeError:\n-            # Some versions of git don't support --progress.\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", module],\n-                cwd=self.rust_root, verbose=self.verbose)\n+\n+        update_args = [\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"]\n+        if self.git_version >= distutils.version.LooseVersion(\"2.11.0\"):\n+            update_args.append(\"--progress\")\n+        update_args.append(module)\n+        run(update_args, cwd=self.rust_root, verbose=self.verbose, exception=True)\n+\n         run([\"git\", \"reset\", \"-q\", \"--hard\"],\n             cwd=module_path, verbose=self.verbose)\n         run([\"git\", \"clean\", \"-qdfx\"],\n@@ -763,12 +779,11 @@ def update_submodules(self):\n                 self.get_toml('submodules') == \"false\":\n             return\n \n-        # check the existence of 'git' command\n-        try:\n-            subprocess.check_output(['git', '--version'])\n-        except (subprocess.CalledProcessError, OSError):\n-            print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n-            sys.exit(1)\n+        default_encoding = sys.getdefaultencoding()\n+\n+        # check the existence and version of 'git' command\n+        git_version_str = require(['git', '--version']).split()[2].decode(default_encoding)\n+        self.git_version = distutils.version.LooseVersion(git_version_str)\n \n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n@@ -854,7 +869,7 @@ def ensure_vendored(self):\n         # the rust git repository is updated. Normal development usually does\n         # not use vendoring, so hopefully this isn't too much of a problem.\n         if self.use_vendored_sources and not os.path.exists(vendor_dir):\n-            run([self.cargo(), \"vendor\"],\n+            run([self.cargo(), \"vendor\", \"--sync=./src/tools/rust-analyzer/Cargo.toml\"],\n                 verbose=self.verbose, cwd=self.rust_root)\n \n \n@@ -884,11 +899,18 @@ def bootstrap(help_triggered):\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n-    try:\n-        with open(args.config or 'config.toml') as config:\n+    # Read from `RUST_BOOTSTRAP_CONFIG`, then `--config`, then fallback to `config.toml` (if it\n+    # exists).\n+    toml_path = os.getenv('RUST_BOOTSTRAP_CONFIG') or args.config\n+    if not toml_path and os.path.exists('config.toml'):\n+        toml_path = 'config.toml'\n+\n+    if toml_path:\n+        if not os.path.exists(toml_path):\n+            toml_path = os.path.join(build.rust_root, toml_path)\n+\n+        with open(toml_path) as config:\n             build.config_toml = config.read()\n-    except (OSError, IOError):\n-        pass\n \n     config_verbose = build.get_toml('verbose', 'build')\n     if config_verbose is not None:\n@@ -900,6 +922,9 @@ def bootstrap(help_triggered):\n \n     build.check_vendored_status()\n \n+    build_dir = build.get_toml('build-dir', 'build') or 'build'\n+    build.build_dir = os.path.abspath(build_dir.replace(\"$ROOT\", build.rust_root))\n+\n     data = stage0_data(build.rust_root)\n     build.date = data['date']\n     build.rustc_channel = data['rustc']\n@@ -935,6 +960,8 @@ def bootstrap(help_triggered):\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n     env[\"CARGO\"] = build.cargo()\n     env[\"RUSTC\"] = build.rustc()\n+    if toml_path:\n+        env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     if build.rustfmt():\n         env[\"RUSTFMT\"] = build.rustfmt()\n     run(args, env=env, verbose=build.verbose)"}, {"sha": "3cbecbbaa06cb89c7677884f8aa3fe1ed677fa03", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 99, "deletions": 34, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -23,7 +23,7 @@ use crate::install;\n use crate::native;\n use crate::run;\n use crate::test;\n-use crate::tool;\n+use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir};\n use crate::{Build, DocTests, GitRepo, Mode};\n \n@@ -52,6 +52,8 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// it's been assembled.\n     type Output: Clone;\n \n+    /// Whether this step is run by default as part of its respective phase.\n+    /// `true` here can still be overwritten by `should_run` calling `default_condition`.\n     const DEFAULT: bool = false;\n \n     /// If true, then this rule should be skipped if --target was specified, but --host was not\n@@ -97,9 +99,21 @@ struct StepDescription {\n     name: &'static str,\n }\n \n+/// Collection of paths used to match a task rule.\n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub enum PathSet {\n+    /// A collection of individual paths.\n+    ///\n+    /// These are generally matched as a path suffix. For example, a\n+    /// command-line value of `libstd` will match if `src/libstd` is in the\n+    /// set.\n     Set(BTreeSet<PathBuf>),\n+    /// A \"suite\" of paths.\n+    ///\n+    /// These can match as a path suffix (like `Set`), or as a prefix. For\n+    /// example, a command-line value of `src/test/ui/abi/variadic-ffi.rs`\n+    /// will match `src/test/ui`. A command-line value of `ui` would also\n+    /// match `src/test/ui`.\n     Suite(PathBuf),\n }\n \n@@ -249,21 +263,33 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n-    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n-    // actually doing something different for every crate passed.\n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// Compared to `krate`, this treats the dependencies as aliases for the\n+    /// same job. Generally it is preferred to use `krate`, and treat each\n+    /// individual path separately. For example `./x.py test src/liballoc`\n+    /// (which uses `krate`) will test just `liballoc`. However, `./x.py check\n+    /// src/liballoc` (which uses `all_krates`) will check all of `libtest`.\n+    /// `all_krates` should probably be removed at some point.\n     pub fn all_krates(mut self, name: &str) -> Self {\n         let mut set = BTreeSet::new();\n         for krate in self.builder.in_tree_crates(name) {\n-            set.insert(PathBuf::from(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            set.insert(path);\n         }\n         self.paths.insert(PathSet::Set(set));\n         self\n     }\n \n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// `make_run` will be called separately for each matching command-line path.\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name) {\n-            self.paths.insert(PathSet::one(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            self.paths.insert(PathSet::one(path));\n         }\n         self\n     }\n@@ -342,24 +368,26 @@ impl<'a> Builder<'a> {\n                 tool::RustInstaller,\n                 tool::Cargo,\n                 tool::Rls,\n+                tool::RustAnalyzer,\n                 tool::Rustdoc,\n                 tool::Clippy,\n+                tool::CargoClippy,\n                 native::Llvm,\n                 native::Sanitizers,\n                 tool::Rustfmt,\n                 tool::Miri,\n+                tool::CargoMiri,\n                 native::Lld\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n-                describe!(check::Std, check::Rustc, check::Rustdoc)\n+                describe!(check::Std, check::Rustc, check::Rustdoc, check::Clippy)\n             }\n             Kind::Test => describe!(\n                 crate::toolstate::ToolStateCheck,\n                 test::ExpandYamlAnchors,\n                 test::Tidy,\n                 test::Ui,\n                 test::CompileFail,\n-                test::RunFail,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n                 test::Codegen,\n@@ -370,8 +398,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunFailPretty,\n-                test::RunPassValgrindPretty,\n                 test::Crate,\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,\n@@ -437,11 +463,11 @@ impl<'a> Builder<'a> {\n                 dist::PlainSourceTarball,\n                 dist::Cargo,\n                 dist::Rls,\n+                dist::RustAnalyzer,\n                 dist::Rustfmt,\n                 dist::Clippy,\n                 dist::Miri,\n                 dist::LlvmTools,\n-                dist::Lldb,\n                 dist::Extended,\n                 dist::HashSign\n             ),\n@@ -450,6 +476,7 @@ impl<'a> Builder<'a> {\n                 install::Std,\n                 install::Cargo,\n                 install::Rls,\n+                install::RustAnalyzer,\n                 install::Rustfmt,\n                 install::Clippy,\n                 install::Miri,\n@@ -488,13 +515,19 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n+        let mut add_path = |path: &Path| {\n+            help.push_str(&format!(\"    ./x.py {} {}\\n\", subcommand, path.display()));\n+        };\n         for pathset in should_run.paths {\n-            if let PathSet::Set(set) = pathset {\n-                set.iter().for_each(|path| {\n-                    help.push_str(\n-                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n-                    )\n-                })\n+            match pathset {\n+                PathSet::Set(set) => {\n+                    for path in set {\n+                        add_path(&path);\n+                    }\n+                }\n+                PathSet::Suite(path) => {\n+                    add_path(&path.join(\"...\"));\n+                }\n             }\n         }\n         Some(help)\n@@ -506,7 +539,7 @@ impl<'a> Builder<'a> {\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Clippy { ref paths } => (Kind::Clippy, &paths[..]),\n             Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n-            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n+            Subcommand::Doc { ref paths, .. } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n@@ -651,6 +684,7 @@ impl<'a> Builder<'a> {\n     pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n         match self.config.libdir_relative() {\n             Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n+            _ if compiler.stage == 0 => &self.build.initial_libdir,\n             _ => Path::new(\"lib\"),\n         }\n     }\n@@ -728,6 +762,7 @@ impl<'a> Builder<'a> {\n         &self,\n         compiler: Compiler,\n         mode: Mode,\n+        source_type: SourceType,\n         target: Interned<String>,\n         cmd: &str,\n     ) -> Cargo {\n@@ -765,9 +800,17 @@ impl<'a> Builder<'a> {\n         }\n \n         // Set a flag for `check`/`clippy`/`fix`, so that certain build\n-        // scripts can do less work (e.g. not building/requiring LLVM).\n+        // scripts can do less work (i.e. not building/requiring LLVM).\n         if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n-            cargo.env(\"RUST_CHECK\", \"1\");\n+            // If we've not yet built LLVM, or it's stale, then bust\n+            // the librustc_llvm cache. That will always work, even though it\n+            // may mean that on the next non-check build we'll need to rebuild\n+            // librustc_llvm. But if LLVM is stale, that'll be a tiny amount\n+            // of work comparitively, and we'd likely need to rebuild it anyway,\n+            // so that's okay.\n+            if crate::native::prebuilt_llvm_config(self, target).is_err() {\n+                cargo.env(\"RUST_CHECK\", \"1\");\n+            }\n         }\n \n         let stage = if compiler.stage == 0 && self.local_rebuild {\n@@ -791,6 +834,11 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"--cfg=bootstrap\");\n         }\n \n+        // FIXME: It might be better to use the same value for both `RUSTFLAGS` and `RUSTDOCFLAGS`,\n+        // but this breaks CI. At the very least, stage0 `rustdoc` needs `--cfg bootstrap`. See\n+        // #71458.\n+        let rustdocflags = rustflags.clone();\n+\n         if let Ok(s) = env::var(\"CARGOFLAGS\") {\n             cargo.args(s.split_whitespace());\n         }\n@@ -905,7 +953,6 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n             .env(\"RUSTC_REAL\", self.rustc(compiler))\n             .env(\"RUSTC_STAGE\", stage.to_string())\n-            .env(\"RUSTC_DEBUG_ASSERTIONS\", self.config.rust_debug_assertions.to_string())\n             .env(\"RUSTC_SYSROOT\", &sysroot)\n             .env(\"RUSTC_LIBDIR\", &libdir)\n             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n@@ -929,7 +976,7 @@ impl<'a> Builder<'a> {\n         // we're gated on RUSTC_RPATH here.\n         //\n         // Ok, so the astute might be wondering \"why isn't `-C rpath` used\n-        // here?\" and that is indeed a good question to task. This codegen\n+        // here?\" and that is indeed a good question to ask. This codegen\n         // option is the compiler's current interface to generating an rpath.\n         // Unfortunately it doesn't quite suffice for us. The flag currently\n         // takes no value as an argument, so the compiler calculates what it\n@@ -989,6 +1036,14 @@ impl<'a> Builder<'a> {\n             }\n         };\n         cargo.env(profile_var(\"DEBUG\"), debuginfo_level.to_string());\n+        cargo.env(\n+            profile_var(\"DEBUG_ASSERTIONS\"),\n+            if mode == Mode::Std {\n+                self.config.rust_debug_assertions_std.to_string()\n+            } else {\n+                self.config.rust_debug_assertions.to_string()\n+            },\n+        );\n \n         if !mode.is_tool() {\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n@@ -1074,7 +1129,7 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n \n-        if !mode.is_tool() {\n+        if source_type == SourceType::InTree {\n             // When extending this list, add the new lints to the RUSTFLAGS of the\n             // build_bootstrap function of src/bootstrap/bootstrap.py as well as\n             // some code doesn't go through this `rustc` wrapper.\n@@ -1083,13 +1138,13 @@ impl<'a> Builder<'a> {\n \n             if self.config.deny_warnings {\n                 rustflags.arg(\"-Dwarnings\");\n+            }\n \n-                // FIXME(#58633) hide \"unused attribute\" errors in incremental\n-                // builds of the standard library, as the underlying checks are\n-                // not yet properly integrated with incremental recompilation.\n-                if mode == Mode::Std && compiler.stage == 0 && self.config.incremental {\n-                    rustflags.arg(\"-Aunused-attributes\");\n-                }\n+            // FIXME(#58633) hide \"unused attribute\" errors in incremental\n+            // builds of the standard library, as the underlying checks are\n+            // not yet properly integrated with incremental recompilation.\n+            if mode == Mode::Std && compiler.stage == 0 && self.config.incremental {\n+                rustflags.arg(\"-Aunused-attributes\");\n             }\n         }\n \n@@ -1155,7 +1210,7 @@ impl<'a> Builder<'a> {\n             );\n         }\n \n-        // If Control Flow Guard is enabled, pass the `control_flow_guard=checks` flag to rustc\n+        // If Control Flow Guard is enabled, pass the `control-flow-guard` flag to rustc\n         // when compiling the standard library, since this might be linked into the final outputs\n         // produced by rustc. Since this mitigation is only available on Windows, only enable it\n         // for the standard library in case the compiler is run on a non-Windows platform.\n@@ -1166,7 +1221,7 @@ impl<'a> Builder<'a> {\n             && self.config.control_flow_guard\n             && compiler.stage >= 1\n         {\n-            rustflags.arg(\"-Zcontrol_flow_guard=checks\");\n+            rustflags.arg(\"-Zcontrol-flow-guard\");\n         }\n \n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n@@ -1269,7 +1324,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        Cargo { command: cargo, rustflags }\n+        Cargo { command: cargo, rustflags, rustdocflags }\n     }\n \n     /// Ensure that a given step is built, returning its output. This will\n@@ -1327,7 +1382,7 @@ impl<'a> Builder<'a> {\n #[cfg(test)]\n mod tests;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n struct Rustflags(String);\n \n impl Rustflags {\n@@ -1367,6 +1422,7 @@ impl Rustflags {\n pub struct Cargo {\n     command: Command,\n     rustflags: Rustflags,\n+    rustdocflags: Rustflags,\n }\n \n impl Cargo {\n@@ -1399,7 +1455,16 @@ impl Cargo {\n \n impl From<Cargo> for Command {\n     fn from(mut cargo: Cargo) -> Command {\n-        cargo.command.env(\"RUSTFLAGS\", &cargo.rustflags.0);\n+        let rustflags = &cargo.rustflags.0;\n+        if !rustflags.is_empty() {\n+            cargo.command.env(\"RUSTFLAGS\", rustflags);\n+        }\n+\n+        let rustdocflags = &cargo.rustdocflags.0;\n+        if !rustdocflags.is_empty() {\n+            cargo.command.env(\"RUSTDOCFLAGS\", rustdocflags);\n+        }\n+\n         cargo.command\n     }\n }"}, {"sha": "1e75e67af0c9e17f847e5e63255ad1d41e2d8feb", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -54,6 +54,11 @@ fn dist_baseline() {\n         &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    // Make sure rustdoc is only built once.\n+    assert_eq!(\n+        first(builder.cache.all::<tool::Rustdoc>()),\n+        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+    );\n }\n \n #[test]\n@@ -414,3 +419,77 @@ fn test_exclude() {\n     // Ensure other tests are not affected.\n     assert!(builder.cache.contains::<test::RustdocUi>());\n }\n+\n+#[test]\n+fn doc_default() {\n+    let mut config = configure(&[], &[]);\n+    config.compiler_docs = true;\n+    config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+    // rustdoc tool.\n+    assert_eq!(\n+        first(builder.cache.all::<doc::ErrorIndex>()),\n+        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<tool::ErrorIndex>()),\n+        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+    );\n+    // This is actually stage 1, but Rustdoc::run swaps out the compiler with\n+    // stage minus 1 if --stage is not 0. Very confusing!\n+    assert_eq!(\n+        first(builder.cache.all::<tool::Rustdoc>()),\n+        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+    );\n+}\n+\n+#[test]\n+fn test_docs() {\n+    // Behavior of `x.py test` doing various documentation tests.\n+    let mut config = configure(&[], &[]);\n+    config.cmd = Subcommand::Test {\n+        paths: vec![],\n+        test_args: vec![],\n+        rustc_args: vec![],\n+        fail_fast: true,\n+        doc_tests: DocTests::Yes,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+        pass: None,\n+    };\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+    // rustdoc tool.\n+    assert_eq!(\n+        first(builder.cache.all::<doc::ErrorIndex>()),\n+        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<tool::ErrorIndex>()),\n+        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+    );\n+    // Unfortunately rustdoc is built twice. Once from stage1 for compiletest\n+    // (and other things), and once from stage0 for std crates. Ideally it\n+    // would only be built once. If someone wants to fix this, it might be\n+    // worth investigating if it would be possible to test std from stage1.\n+    // Note that the stages here are +1 than what they actually are because\n+    // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n+    // not 0.\n+    assert_eq!(\n+        first(builder.cache.all::<tool::Rustdoc>()),\n+        &[\n+            tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n+            tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n+        ]\n+    );\n+}"}, {"sha": "ab16ca3732c1fc93a81d4ed8ac20855052155c5f", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -37,7 +37,9 @@ use crate::{Build, GitRepo};\n // try to infer the archiver path from the C compiler path.\n // In the future this logic should be replaced by calling into the `cc` crate.\n fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if let Some(ar) = env::var_os(\"AR\") {\n+    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.replace(\"-\", \"_\"))) {\n+        Some(PathBuf::from(ar))\n+    } else if let Some(ar) = env::var_os(\"AR\") {\n         Some(PathBuf::from(ar))\n     } else if target.contains(\"msvc\") {\n         None"}, {"sha": "a4115904ac76f16500d5c6fd6eb834a683041ec9", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.44.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.46.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "0d38d2eebe79390fefb2eae22ca674574f0f136f", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 93, "deletions": 72, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -44,8 +44,14 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, builder.config.build);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Std, target, cargo_subcommand(builder.kind));\n-        std_cargo(builder, target, &mut cargo);\n+        let mut cargo = builder.cargo(\n+            compiler,\n+            Mode::Std,\n+            SourceType::InTree,\n+            target,\n+            cargo_subcommand(builder.kind),\n+        );\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n \n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(\n@@ -92,8 +98,13 @@ impl Step for Rustc {\n \n         builder.ensure(Std { target });\n \n-        let mut cargo =\n-            builder.cargo(compiler, Mode::Rustc, target, cargo_subcommand(builder.kind));\n+        let mut cargo = builder.cargo(\n+            compiler,\n+            Mode::Rustc,\n+            SourceType::InTree,\n+            target,\n+            cargo_subcommand(builder.kind),\n+        );\n         rustc_cargo(builder, &mut cargo, target);\n \n         builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n@@ -112,83 +123,93 @@ impl Step for Rustc {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n-    pub target: Interned<String>,\n+macro_rules! tool_check_step {\n+    ($name:ident, $path:expr, $source_type:expr) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub target: Interned<String>,\n+        }\n+\n+        impl Step for $name {\n+            type Output = ();\n+            const ONLY_HOSTS: bool = true;\n+            const DEFAULT: bool = true;\n+\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+                run.path($path)\n+            }\n+\n+            fn make_run(run: RunConfig<'_>) {\n+                run.builder.ensure($name { target: run.target });\n+            }\n+\n+            fn run(self, builder: &Builder<'_>) {\n+                let compiler = builder.compiler(0, builder.config.build);\n+                let target = self.target;\n+\n+                builder.ensure(Rustc { target });\n+\n+                let cargo = prepare_tool_cargo(\n+                    builder,\n+                    compiler,\n+                    Mode::ToolRustc,\n+                    target,\n+                    cargo_subcommand(builder.kind),\n+                    $path,\n+                    $source_type,\n+                    &[],\n+                );\n+\n+                println!(\n+                    \"Checking {} artifacts ({} -> {})\",\n+                    stringify!($name).to_lowercase(),\n+                    &compiler.host,\n+                    target\n+                );\n+                run_cargo(\n+                    builder,\n+                    cargo,\n+                    args(builder.kind),\n+                    &stamp(builder, compiler, target),\n+                    vec![],\n+                    true,\n+                );\n+\n+                let libdir = builder.sysroot_libdir(compiler, target);\n+                let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+                add_to_sysroot(&builder, &libdir, &hostdir, &stamp(builder, compiler, target));\n+\n+                /// Cargo's output path in a given stage, compiled by a particular\n+                /// compiler for the specified target.\n+                fn stamp(\n+                    builder: &Builder<'_>,\n+                    compiler: Compiler,\n+                    target: Interned<String>,\n+                ) -> PathBuf {\n+                    builder\n+                        .cargo_out(compiler, Mode::ToolRustc, target)\n+                        .join(format!(\".{}-check.stamp\", stringify!($name).to_lowercase()))\n+                }\n+            }\n+        }\n+    };\n }\n \n-impl Step for Rustdoc {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/rustdoc\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Rustc { target });\n-\n-        let cargo = prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolRustc,\n-            target,\n-            cargo_subcommand(builder.kind),\n-            \"src/tools/rustdoc\",\n-            SourceType::InTree,\n-            &[],\n-        );\n-\n-        println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder.kind),\n-            &rustdoc_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-    }\n-}\n+tool_check_step!(Rustdoc, \"src/tools/rustdoc\", SourceType::InTree);\n+// Clippy is a hybrid. It is an external tool, but uses a git subtree instead\n+// of a submodule. Since the SourceType only drives the deny-warnings\n+// behavior, treat it as in-tree so that any new warnings in clippy will be\n+// rejected.\n+tool_check_step!(Clippy, \"src/tools/clippy\", SourceType::InTree);\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n-\n-/// Cargo's output path for rustdoc in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn rustdoc_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::ToolRustc, target).join(\".rustdoc-check.stamp\")\n-}"}, {"sha": "9b4926f28d4edb320d50b6efc3a1069215113f32", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 163, "deletions": 78, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -20,13 +20,13 @@ use filetime::FileTime;\n use serde::Deserialize;\n \n use crate::builder::Cargo;\n+use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n+use crate::cache::{Interned, INTERNER};\n use crate::dist;\n use crate::native;\n+use crate::tool::SourceType;\n use crate::util::{exe, is_dylib, symlink_dir};\n-use crate::{Compiler, GitRepo, Mode};\n-\n-use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n-use crate::cache::{Interned, INTERNER};\n+use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n@@ -74,6 +74,7 @@ impl Step for Std {\n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n+            copy_self_contained_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n                 compiler: compiler_to_use,\n@@ -83,10 +84,11 @@ impl Step for Std {\n             return;\n         }\n \n-        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target));\n+        target_deps.extend(copy_self_contained_objects(builder, &compiler, target));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n-        std_cargo(builder, target, &mut cargo);\n+        let mut cargo = builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"build\");\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n \n         builder.info(&format!(\n             \"Building stage{} std artifacts ({} -> {})\",\n@@ -109,62 +111,108 @@ impl Step for Std {\n     }\n }\n \n+fn copy_and_stamp(\n+    builder: &Builder<'_>,\n+    libdir: &Path,\n+    sourcedir: &Path,\n+    name: &str,\n+    target_deps: &mut Vec<(PathBuf, DependencyType)>,\n+    dependency_type: DependencyType,\n+) {\n+    let target = libdir.join(name);\n+    builder.copy(&sourcedir.join(name), &target);\n+\n+    target_deps.push((target, dependency_type));\n+}\n+\n /// Copies third party objects needed by various targets.\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n     target: Interned<String>,\n-) -> Vec<PathBuf> {\n-    let libdir = builder.sysroot_libdir(*compiler, target);\n-\n+) -> Vec<(PathBuf, DependencyType)> {\n     let mut target_deps = vec![];\n \n-    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n-        let target = libdir.join(name);\n-        builder.copy(&sourcedir.join(name), &target);\n-        target_deps.push(target);\n+    // FIXME: remove this in 2021\n+    if target == \"x86_64-fortanix-unknown-sgx\" {\n+        if env::var_os(\"X86_FORTANIX_SGX_LIBS\").is_some() {\n+            builder.info(\"Warning: X86_FORTANIX_SGX_LIBS environment variable is ignored, libunwind is now compiled as part of rustbuild\");\n+        }\n+    }\n+\n+    if builder.config.sanitizers && compiler.stage != 0 {\n+        // The sanitizers are only copied in stage1 or above,\n+        // to avoid creating dependency on LLVM.\n+        target_deps.extend(\n+            copy_sanitizers(builder, &compiler, target)\n+                .into_iter()\n+                .map(|d| (d, DependencyType::Target)),\n+        );\n+    }\n+\n+    target_deps\n+}\n+\n+/// Copies third party objects needed by various targets for self-contained linkage.\n+fn copy_self_contained_objects(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<(PathBuf, DependencyType)> {\n+    // cfg(bootstrap)\n+    // Remove when upgrading bootstrap compiler.\n+    let libdir_self_contained = if compiler.stage == 0 {\n+        builder.sysroot_libdir(*compiler, target).to_path_buf()\n+    } else {\n+        builder.sysroot_libdir(*compiler, target).join(\"self-contained\")\n     };\n+    t!(fs::create_dir_all(&libdir_self_contained));\n+    let mut target_deps = vec![];\n \n-    // Copies the crt(1,i,n).o startup objects\n+    // Copies the CRT objects.\n     //\n-    // Since musl supports fully static linking, we can cross link for it even\n-    // with a glibc-targeting toolchain, given we have the appropriate startup\n-    // files. As those shipped with glibc won't work, copy the ones provided by\n-    // musl so we have them on linux-gnu hosts.\n+    // rustc historically provides a more self-contained installation for musl targets\n+    // not requiring the presence of a native musl toolchain. For example, it can fall back\n+    // to using gcc from a glibc-targeting toolchain for linking.\n+    // To do that we have to distribute musl startup objects as a part of Rust toolchain\n+    // and link with them manually in the self-contained mode.\n     if target.contains(\"musl\") {\n-        let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n-        for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-            copy_and_stamp(&srcdir, obj);\n+        let srcdir = builder.musl_libdir(target).unwrap();\n+        for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n+            copy_and_stamp(\n+                builder,\n+                &libdir_self_contained,\n+                &srcdir,\n+                obj,\n+                &mut target_deps,\n+                DependencyType::TargetSelfContained,\n+            );\n         }\n     } else if target.ends_with(\"-wasi\") {\n         let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n-        copy_and_stamp(&srcdir, \"crt1.o\");\n-    }\n-\n-    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n-    //\n-    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n-    // libunwind requires support for rwlock and printing to stderr,\n-    // which is provided by std for this target.\n-    if target == \"x86_64-fortanix-unknown-sgx\" {\n-        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let src =\n-            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n-        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n-    }\n-\n-    if builder.config.sanitizers && compiler.stage != 0 {\n-        // The sanitizers are only copied in stage1 or above,\n-        // to avoid creating dependency on LLVM.\n-        target_deps.extend(copy_sanitizers(builder, &compiler, target));\n+        copy_and_stamp(\n+            builder,\n+            &libdir_self_contained,\n+            &srcdir,\n+            \"crt1.o\",\n+            &mut target_deps,\n+            DependencyType::TargetSelfContained,\n+        );\n+    } else if target.contains(\"windows-gnu\") {\n+        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+            let src = compiler_file(builder, builder.cc(target), target, obj);\n+            let target = libdir_self_contained.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push((target, DependencyType::TargetSelfContained));\n+        }\n     }\n \n     target_deps\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Cargo) {\n+pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, cargo: &mut Cargo) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -218,8 +266,8 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Ca\n         // Help the libc crate compile by assisting it in finding various\n         // sysroot native libraries.\n         if target.contains(\"musl\") {\n-            if let Some(p) = builder.musl_root(target) {\n-                let root = format!(\"native={}/lib\", p.to_str().unwrap());\n+            if let Some(p) = builder.musl_libdir(target) {\n+                let root = format!(\"native={}\", p.to_str().unwrap());\n                 cargo.rustflag(\"-L\").rustflag(&root);\n             }\n         }\n@@ -231,6 +279,28 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Ca\n             }\n         }\n     }\n+\n+    // By default, rustc uses `-Cembed-bitcode=yes`, and Cargo overrides that\n+    // with `-Cembed-bitcode=no` for non-LTO builds. However, libstd must be\n+    // built with bitcode so that the produced rlibs can be used for both LTO\n+    // builds (which use bitcode) and non-LTO builds (which use object code).\n+    // So we override the override here!\n+    //\n+    // But we don't bother for the stage 0 compiler because it's never used\n+    // with LTO.\n+    if stage >= 1 {\n+        cargo.rustflag(\"-Cembed-bitcode=yes\");\n+    }\n+\n+    // By default, rustc does not include unwind tables unless they are required\n+    // for a particular target. They are not required by RISC-V targets, but\n+    // compiling the standard library with them means that users can get\n+    // backtraces without having to recompile the standard library themselves.\n+    //\n+    // This choice was discussed in https://github.com/rust-lang/rust/pull/69890\n+    if target.contains(\"riscv\") {\n+        cargo.rustflag(\"-Cforce-unwind-tables=yes\");\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -312,7 +382,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = Vec<PathBuf>;\n+    type Output = Vec<(PathBuf, DependencyType)>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -331,7 +401,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Vec<(PathBuf, DependencyType)> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n@@ -365,14 +435,7 @@ impl Step for StartupObjects {\n \n             let target = sysroot_dir.join((*file).to_string() + \".o\");\n             builder.copy(dst_file, &target);\n-            target_deps.push(target);\n-        }\n-\n-        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder, builder.cc(target), target, obj);\n-            let target = sysroot_dir.join(obj);\n-            builder.copy(&src, &target);\n-            target_deps.push(target);\n+            target_deps.push((target, DependencyType::Target));\n         }\n \n         target_deps\n@@ -437,7 +500,7 @@ impl Step for Rustc {\n             target: builder.config.build,\n         });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"build\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, SourceType::InTree, target, \"build\");\n         rustc_cargo(builder, &mut cargo, target);\n \n         builder.info(&format!(\n@@ -505,9 +568,13 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n     // librustc_llvm and librustc_codegen_llvm.\n     //\n     // Note that this is disabled if LLVM itself is disabled or we're in a check\n-    // build, where if we're in a check build there's no need to build all of\n-    // LLVM and such.\n-    if builder.config.llvm_enabled() && builder.kind != Kind::Check {\n+    // build. If we are in a check build we still go ahead here presuming we've\n+    // detected that LLVM is alreay built and good to go which helps prevent\n+    // busting caches (e.g. like #71152).\n+    if builder.config.llvm_enabled()\n+        && (builder.kind != Kind::Check\n+            || crate::native::prebuilt_llvm_config(builder, target).is_ok())\n+    {\n         if builder.is_rust_llvm(target) {\n             cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n         }\n@@ -756,7 +823,8 @@ impl Step for Assemble {\n \n         // Ensure that `libLLVM.so` ends up in the newly build compiler directory,\n         // so that it can be found when the newly built `rustc` is run.\n-        dist::maybe_install_llvm_dylib(builder, target_compiler.host, &sysroot);\n+        dist::maybe_install_llvm_runtime(builder, target_compiler.host, &sysroot);\n+        dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);\n \n         // Link the compiler binary itself into place\n         let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n@@ -780,14 +848,17 @@ pub fn add_to_sysroot(\n     sysroot_host_dst: &Path,\n     stamp: &Path,\n ) {\n+    let self_contained_dst = &sysroot_dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&sysroot_dst));\n     t!(fs::create_dir_all(&sysroot_host_dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if host {\n-            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n-        } else {\n-            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n-        }\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        let dst = match dependency_type {\n+            DependencyType::Host => sysroot_host_dst,\n+            DependencyType::Target => sysroot_dst,\n+            DependencyType::TargetSelfContained => self_contained_dst,\n+        };\n+        builder.copy(&path, &dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -796,7 +867,7 @@ pub fn run_cargo(\n     cargo: Cargo,\n     tail_args: Vec<String>,\n     stamp: &Path,\n-    additional_target_deps: Vec<PathBuf>,\n+    additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n ) -> Vec<PathBuf> {\n     if builder.config.dry_run {\n@@ -847,15 +918,15 @@ pub fn run_cargo(\n             if filename.starts_with(&host_root_dir) {\n                 // Unless it's a proc macro used in the compiler\n                 if crate_types.iter().any(|t| t == \"proc-macro\") {\n-                    deps.push((filename.to_path_buf(), true));\n+                    deps.push((filename.to_path_buf(), DependencyType::Host));\n                 }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push((filename.to_path_buf(), false));\n+                deps.push((filename.to_path_buf(), DependencyType::Target));\n                 continue;\n             }\n \n@@ -892,10 +963,11 @@ pub fn run_cargo(\n         .collect::<Vec<_>>();\n     for (prefix, extension, expected_len) in toplevel {\n         let candidates = contents.iter().filter(|&&(_, ref filename, ref meta)| {\n-            filename.starts_with(&prefix[..])\n-                && filename[prefix.len()..].starts_with('-')\n-                && filename.ends_with(&extension[..])\n-                && meta.len() == expected_len\n+            meta.len() == expected_len\n+                && filename\n+                    .strip_prefix(&prefix[..])\n+                    .map(|s| s.starts_with('-') && s.ends_with(&extension[..]))\n+                    .unwrap_or(false)\n         });\n         let max = candidates\n             .max_by_key(|&&(_, _, ref metadata)| FileTime::from_last_modification_time(metadata));\n@@ -907,17 +979,21 @@ pub fn run_cargo(\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push((candidate, false));\n+                deps.push((candidate, DependencyType::Target));\n             }\n         }\n-        deps.push((path_to_add.into(), false));\n+        deps.push((path_to_add.into(), DependencyType::Target));\n     }\n \n-    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n+    deps.extend(additional_target_deps);\n     deps.sort();\n     let mut new_contents = Vec::new();\n-    for (dep, proc_macro) in deps.iter() {\n-        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n+    for (dep, dependency_type) in deps.iter() {\n+        new_contents.extend(match *dependency_type {\n+            DependencyType::Host => b\"h\",\n+            DependencyType::Target => b\"t\",\n+            DependencyType::TargetSelfContained => b\"s\",\n+        });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n@@ -965,7 +1041,13 @@ pub fn stream_cargo(\n     for line in stdout.lines() {\n         let line = t!(line);\n         match serde_json::from_str::<CargoMessage<'_>>(&line) {\n-            Ok(msg) => cb(msg),\n+            Ok(msg) => {\n+                if builder.config.json_output {\n+                    // Forward JSON to stdout.\n+                    println!(\"{}\", line);\n+                }\n+                cb(msg)\n+            }\n             // If this was informational, just print it out and continue\n             Err(_) => println!(\"{}\", line),\n         }\n@@ -1000,4 +1082,7 @@ pub enum CargoMessage<'a> {\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n     },\n+    BuildFinished {\n+        success: bool,\n+    },\n }"}, {"sha": "ff545a6ddcf47902ef580d2622107eceba396f3b", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -85,7 +85,6 @@ pub struct Config {\n \n     pub use_lld: bool,\n     pub lld_enabled: bool,\n-    pub lldb_enabled: bool,\n     pub llvm_tools_enabled: bool,\n \n     pub llvm_cflags: Option<String>,\n@@ -98,6 +97,7 @@ pub struct Config {\n     pub rust_codegen_units: Option<u32>,\n     pub rust_codegen_units_std: Option<u32>,\n     pub rust_debug_assertions: bool,\n+    pub rust_debug_assertions_std: bool,\n     pub rust_debuginfo_level_rustc: u32,\n     pub rust_debuginfo_level_std: u32,\n     pub rust_debuginfo_level_tools: u32,\n@@ -173,6 +173,7 @@ pub struct Target {\n     pub ndk: Option<PathBuf>,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n+    pub musl_libdir: Option<PathBuf>,\n     pub wasi_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n     pub no_std: bool,\n@@ -212,6 +213,8 @@ struct Build {\n     host: Vec<String>,\n     #[serde(default)]\n     target: Vec<String>,\n+    // This is ignored, the rust code always gets the build directory from the `BUILD_DIR` env variable\n+    build_dir: Option<String>,\n     cargo: Option<String>,\n     rustc: Option<String>,\n     rustfmt: Option<String>, /* allow bootstrap.py to use rustfmt key */\n@@ -313,6 +316,7 @@ struct Rust {\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n+    debug_assertions_std: Option<bool>,\n     debuginfo_level: Option<u32>,\n     debuginfo_level_rustc: Option<u32>,\n     debuginfo_level_std: Option<u32>,\n@@ -335,7 +339,6 @@ struct Rust {\n     lld: Option<bool>,\n     use_lld: Option<bool>,\n     llvm_tools: Option<bool>,\n-    lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n@@ -361,6 +364,7 @@ struct TomlTarget {\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n+    musl_libdir: Option<String>,\n     wasi_root: Option<String>,\n     qemu_rootfs: Option<String>,\n     no_std: Option<bool>,\n@@ -518,6 +522,7 @@ impl Config {\n         let mut llvm_assertions = None;\n         let mut debug = None;\n         let mut debug_assertions = None;\n+        let mut debug_assertions_std = None;\n         let mut debuginfo_level = None;\n         let mut debuginfo_level_rustc = None;\n         let mut debuginfo_level_std = None;\n@@ -560,6 +565,7 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             debug = rust.debug;\n             debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n             debuginfo_level = rust.debuginfo_level;\n             debuginfo_level_rustc = rust.debuginfo_level_rustc;\n             debuginfo_level_std = rust.debuginfo_level_std;\n@@ -583,7 +589,6 @@ impl Config {\n             }\n             set(&mut config.use_lld, rust.use_lld);\n             set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n             config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n@@ -628,6 +633,7 @@ impl Config {\n                 target.linker = cfg.linker.clone().map(PathBuf::from);\n                 target.crt_static = cfg.crt_static;\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n+                target.musl_libdir = cfg.musl_libdir.clone().map(PathBuf::from);\n                 target.wasi_root = cfg.wasi_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n \n@@ -659,6 +665,8 @@ impl Config {\n \n         let default = debug == Some(true);\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n+        config.rust_debug_assertions_std =\n+            debug_assertions_std.unwrap_or(config.rust_debug_assertions);\n \n         let with_defaults = |debuginfo_level_specific: Option<u32>| {\n             debuginfo_level_specific.or(debuginfo_level).unwrap_or(if debug == Some(true) {"}, {"sha": "47673ce1e870304894f260e5d33925db20cf2f45", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -57,7 +57,6 @@ def v(*args):\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n o(\"full-tools\", None, \"enable all tools\")\n o(\"lld\", \"rust.lld\", \"build lld\")\n-o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n o(\"control-flow-guard\", \"rust.control-flow-guard\", \"Enable Control Flow Guard\")\n@@ -142,6 +141,8 @@ def v(*args):\n   \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\",\n   \"rootfs in qemu testing, you probably don't want to use this\")\n+v(\"qemu-riscv64-rootfs\", \"target.riscv64gc-unknown-linux-gnu.qemu-rootfs\",\n+  \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"experimental-targets\", \"llvm.experimental-targets\",\n   \"experimental LLVM targets to build\")\n v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")"}, {"sha": "5d2fcba7feabaaf16662bf7154ffcb13907bf2b5", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 201, "deletions": 219, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -22,14 +22,16 @@ use crate::channel;\n use crate::compile;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n-use crate::{Compiler, Mode, LLVM_TOOLS};\n+use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n     if component == \"cargo\" {\n         format!(\"{}-{}\", component, builder.cargo_package_vers())\n     } else if component == \"rls\" {\n         format!(\"{}-{}\", component, builder.rls_package_vers())\n+    } else if component == \"rust-analyzer\" {\n+        format!(\"{}-{}\", component, builder.rust_analyzer_package_vers())\n     } else if component == \"clippy\" {\n         format!(\"{}-{}\", component, builder.clippy_package_vers())\n     } else if component == \"miri\" {\n@@ -38,8 +40,6 @@ pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n         format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n     } else if component == \"llvm-tools\" {\n         format!(\"{}-{}\", component, builder.llvm_tools_package_vers())\n-    } else if component == \"lldb\" {\n-        format!(\"{}-{}\", component, builder.lldb_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n         format!(\"{}-{}\", component, builder.rust_package_vers())\n@@ -308,7 +308,12 @@ fn make_win_dist(\n     }\n \n     //Copy platform tools to platform-specific bin directory\n-    let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n+    let target_bin_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"bin\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n         builder.copy_to_folder(&src, &target_bin_dir);\n@@ -323,7 +328,12 @@ fn make_win_dist(\n     );\n \n     //Copy platform libs to platform-specific lib directory\n-    let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n+    let target_lib_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"lib\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n         builder.copy_to_folder(&src, &target_lib_dir);\n@@ -516,7 +526,7 @@ impl Step for Rustc {\n             // components like the llvm tools and LLD. LLD is included below and\n             // tools/LLDB come later, so let's just throw it in the rustc\n             // component for now.\n-            maybe_install_llvm_dylib(builder, host, image);\n+            maybe_install_llvm_runtime(builder, host, image);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -621,19 +631,21 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"natvis/libcore.natvis\");\n             cp_debugger_script(\"natvis/libstd.natvis\");\n         } else {\n-            cp_debugger_script(\"debugger_pretty_printers_common.py\");\n+            cp_debugger_script(\"rust_types.py\");\n \n             // gdb debugger scripts\n             builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"), 0o755);\n             builder.install(&builder.src.join(\"src/etc/rust-gdbgui\"), &sysroot.join(\"bin\"), 0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n-            cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n+            cp_debugger_script(\"gdb_lookup.py\");\n+            cp_debugger_script(\"gdb_providers.py\");\n \n             // lldb debugger scripts\n             builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"), 0o755);\n \n-            cp_debugger_script(\"lldb_rust_formatters.py\");\n+            cp_debugger_script(\"lldb_lookup.py\");\n+            cp_debugger_script(\"lldb_providers.py\");\n         }\n     }\n }\n@@ -652,9 +664,13 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n /// Copy stamped files into an image's `target/lib` directory.\n fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n     let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if !host || builder.config.build == target {\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        if dependency_type == DependencyType::TargetSelfContained {\n+            builder.copy(&path, &self_contained_dst.join(path.file_name().unwrap()));\n+        } else if dependency_type == DependencyType::Target || builder.config.build == target {\n             builder.copy(&path, &dst.join(path.file_name().unwrap()));\n         }\n     }\n@@ -1093,7 +1109,10 @@ impl Step for PlainSourceTarball {\n         if builder.rust_info.is_git() {\n             // Vendor all Cargo dependencies\n             let mut cmd = Command::new(&builder.initial_cargo);\n-            cmd.arg(\"vendor\").current_dir(&plain_dst_src);\n+            cmd.arg(\"vendor\")\n+                .arg(\"--sync\")\n+                .arg(builder.src.join(\"./src/tools/rust-analyzer/Cargo.toml\"))\n+                .current_dir(&plain_dst_src);\n             builder.run(&mut cmd);\n         }\n \n@@ -1323,14 +1342,101 @@ impl Step for Rls {\n     }\n }\n \n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustAnalyzer {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustAnalyzer {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"rust-analyzer\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(RustAnalyzer {\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        assert!(builder.config.extended);\n+\n+        let src = builder.src.join(\"src/tools/rust-analyzer\");\n+        let release_num = builder.release_num(\"rust-analyzer/crates/rust-analyzer\");\n+        let name = pkgname(builder, \"rust-analyzer\");\n+        let version = builder.rust_analyzer_info.version(builder, &release_num);\n+\n+        let tmp = tmpdir(builder);\n+        let image = tmp.join(\"rust-analyzer-image\");\n+        drop(fs::remove_dir_all(&image));\n+        builder.create_dir(&image);\n+\n+        // Prepare the image directory\n+        // We expect rust-analyer to always build, as it doesn't depend on rustc internals\n+        // and doesn't have associated toolstate.\n+        let rust_analyzer = builder\n+            .ensure(tool::RustAnalyzer { compiler, target, extra_features: Vec::new() })\n+            .expect(\"rust-analyzer always builds\");\n+\n+        builder.install(&rust_analyzer, &image.join(\"bin\"), 0o755);\n+        let doc = image.join(\"share/doc/rust-analyzer\");\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"rust-analyzer-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        t!(fs::create_dir_all(&overlay));\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=rust-analyzer-ready-to-serve.\")\n+            .arg(\"--image-dir\")\n+            .arg(&image)\n+            .arg(\"--work-dir\")\n+            .arg(&tmpdir(builder))\n+            .arg(\"--output-dir\")\n+            .arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=rust-analyzer-preview\");\n+\n+        builder.info(&format!(\"Dist rust-analyzer stage{} ({})\", compiler.stage, target));\n+        let _time = timeit(builder);\n+        builder.run(&mut cmd);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n+    }\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n impl Step for Clippy {\n-    type Output = Option<PathBuf>;\n+    type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1348,7 +1454,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1368,16 +1474,10 @@ impl Step for Clippy {\n         // state for clippy isn't testing.\n         let clippy = builder\n             .ensure(tool::Clippy { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"clippy\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"clippy expected to build - essential tool\");\n         let cargoclippy = builder\n             .ensure(tool::CargoClippy { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"cargo clippy\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"clippy expected to build - essential tool\");\n \n         builder.install(&clippy, &image.join(\"bin\"), 0o755);\n         builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n@@ -1416,7 +1516,7 @@ impl Step for Clippy {\n         builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -1648,10 +1748,10 @@ impl Step for Extended {\n         let cargo_installer = builder.ensure(Cargo { compiler, target });\n         let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n         let rls_installer = builder.ensure(Rls { compiler, target });\n+        let rust_analyzer_installer = builder.ensure(RustAnalyzer { compiler, target });\n         let llvm_tools_installer = builder.ensure(LlvmTools { target });\n         let clippy_installer = builder.ensure(Clippy { compiler, target });\n         let miri_installer = builder.ensure(Miri { compiler, target });\n-        let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n@@ -1683,11 +1783,11 @@ impl Step for Extended {\n         tarballs.push(rustc_installer);\n         tarballs.push(cargo_installer);\n         tarballs.extend(rls_installer.clone());\n-        tarballs.extend(clippy_installer.clone());\n+        tarballs.push(rust_analyzer_installer.clone());\n+        tarballs.push(clippy_installer);\n         tarballs.extend(miri_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n         tarballs.extend(llvm_tools_installer);\n-        tarballs.extend(lldb_installer);\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n         if builder.config.docs {\n@@ -1761,9 +1861,7 @@ impl Step for Extended {\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n-            if clippy_installer.is_none() {\n-                contents = filter(&contents, \"clippy\");\n-            }\n+            contents = filter(&contents, \"rust-analyzer\");\n             if miri_installer.is_none() {\n                 contents = filter(&contents, \"miri\");\n             }\n@@ -1805,13 +1903,12 @@ impl Step for Extended {\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n             prepare(\"rust-analysis\");\n+            prepare(\"clippy\");\n \n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            if clippy_installer.is_some() {\n-                prepare(\"clippy\");\n-            }\n+            prepare(\"rust-analyzer\");\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -1845,6 +1942,8 @@ impl Step for Extended {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n+                } else if name == \"rust-analyzer\" {\n+                    \"rust-analyzer-preview\".to_string()\n                 } else if name == \"clippy\" {\n                     \"clippy-preview\".to_string()\n                 } else if name == \"miri\" {\n@@ -1863,41 +1962,19 @@ impl Step for Extended {\n             prepare(\"rust-analysis\");\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n+            prepare(\"clippy\");\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            if clippy_installer.is_some() {\n-                prepare(\"clippy\");\n-            }\n+            prepare(\"rust-analyzer\");\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n             if target.contains(\"windows-gnu\") {\n                 prepare(\"rust-mingw\");\n             }\n \n-            builder.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            builder.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            builder.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n             builder.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            builder.create(&exe.join(\"LICENSE.txt\"), &license);\n-\n-            // Generate exe installer\n-            builder.info(\"building `exe` installer with `iscc`\");\n-            let mut cmd = Command::new(\"iscc\");\n-            cmd.arg(\"rust.iss\").arg(\"/Q\").current_dir(&exe);\n-            if target.contains(\"windows-gnu\") {\n-                cmd.arg(\"/dMINGW\");\n-            }\n-            add_env(builder, &mut cmd, target);\n-            let time = timeit(builder);\n-            builder.run(&mut cmd);\n-            drop(time);\n-            builder.install(\n-                &exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n-                &distdir(builder),\n-                0o755,\n-            );\n \n             // Generate msi installer\n             let wix = PathBuf::from(env::var_os(\"WIX\").unwrap());\n@@ -1989,25 +2066,40 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            if clippy_installer.is_some() {\n-                builder.run(\n-                    Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"clippy\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\")\n-                        .arg(\"ClippyGroup\")\n-                        .arg(\"-dr\")\n-                        .arg(\"Clippy\")\n-                        .arg(\"-var\")\n-                        .arg(\"var.ClippyDir\")\n-                        .arg(\"-out\")\n-                        .arg(exe.join(\"ClippyGroup.wxs\"))\n-                        .arg(\"-t\")\n-                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n-                );\n-            }\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"rust-analyzer\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"RustAnalyzerGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"RustAnalyzer\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.RustAnalyzerDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"RustAnalyzerGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+            );\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"clippy\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"ClippyGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Clippy\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.ClippyDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"ClippyGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+            );\n             if miri_installer.is_some() {\n                 builder.run(\n                     Command::new(&heat)\n@@ -2073,6 +2165,7 @@ impl Step for Extended {\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n+                    .arg(\"-dClippyDir=clippy\")\n                     .arg(\"-arch\")\n                     .arg(&arch)\n                     .arg(\"-out\")\n@@ -2083,9 +2176,7 @@ impl Step for Extended {\n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n-                if clippy_installer.is_some() {\n-                    cmd.arg(\"-dClippyDir=clippy\");\n-                }\n+                cmd.arg(\"-dRustAnalyzerDir=rust-analyzer\");\n                 if miri_installer.is_some() {\n                     cmd.arg(\"-dMiriDir=miri\");\n                 }\n@@ -2101,12 +2192,11 @@ impl Step for Extended {\n             candle(\"DocsGroup.wxs\".as_ref());\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n+            candle(\"ClippyGroup.wxs\".as_ref());\n             if rls_installer.is_some() {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n-            if clippy_installer.is_some() {\n-                candle(\"ClippyGroup.wxs\".as_ref());\n-            }\n+            candle(\"RustAnalyzerGroup.wxs\".as_ref());\n             if miri_installer.is_some() {\n                 candle(\"MiriGroup.wxs\".as_ref());\n             }\n@@ -2138,14 +2228,13 @@ impl Step for Extended {\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n+                .arg(\"ClippyGroup.wixobj\")\n                 .current_dir(&exe);\n \n             if rls_installer.is_some() {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n-            if clippy_installer.is_some() {\n-                cmd.arg(\"ClippyGroup.wixobj\");\n-            }\n+            cmd.arg(\"RustAnalyzerGroup.wixobj\");\n             if miri_installer.is_some() {\n                 cmd.arg(\"MiriGroup.wixobj\");\n             }\n@@ -2239,11 +2328,11 @@ impl Step for HashSign {\n         cmd.arg(addr);\n         cmd.arg(builder.package_vers(&builder.release_num(\"cargo\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rls\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"rust-analyzer/crates/rust-analyzer\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"clippy\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"miri\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n         cmd.arg(builder.llvm_tools_package_vers());\n-        cmd.arg(builder.lldb_package_vers());\n \n         builder.create_dir(&distdir(builder));\n \n@@ -2254,27 +2343,18 @@ impl Step for HashSign {\n     }\n }\n \n-// Maybe add libLLVM.so to the lib-dir. It will only have been built if\n-// LLVM tools are linked dynamically.\n-//\n-// We add this to both the libdir of the rustc binary itself (for it to load at\n-// runtime) and also to the target directory so it can find it at link-time.\n-//\n-// Note: This function does no yet support Windows but we also don't support\n-//       linking LLVM tools dynamically on Windows yet.\n-pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+/// Maybe add libLLVM.so to the given destination lib-dir. It will only have\n+/// been built if LLVM tools are linked dynamically.\n+///\n+/// Note: This function does not yet support Windows, but we also don't support\n+///       linking LLVM tools dynamically on Windows yet.\n+fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdir: &Path) {\n     let src_libdir = builder.llvm_out(target).join(\"lib\");\n-    let dst_libdir1 = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n-    let dst_libdir2 =\n-        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n-    t!(fs::create_dir_all(&dst_libdir1));\n-    t!(fs::create_dir_all(&dst_libdir2));\n \n     if target.contains(\"apple-darwin\") {\n         let llvm_dylib_path = src_libdir.join(\"libLLVM.dylib\");\n         if llvm_dylib_path.exists() {\n-            builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n-            builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n+            builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n         }\n         return;\n     }\n@@ -2288,11 +2368,23 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>,\n             panic!(\"dist: Error calling canonicalize path `{}`: {}\", llvm_dylib_path.display(), e);\n         });\n \n-        builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n-        builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n+        builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n     }\n }\n \n+/// Maybe add libLLVM.so to the target lib-dir for linking.\n+pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n+    maybe_install_llvm(builder, target, &dst_libdir);\n+}\n+\n+/// Maybe add libLLVM.so to the runtime lib-dir for rustc itself.\n+pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let dst_libdir =\n+        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n+    maybe_install_llvm(builder, target, &dst_libdir);\n+}\n+\n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n     pub target: Interned<String>,\n@@ -2340,6 +2432,12 @@ impl Step for LlvmTools {\n             builder.install(&exe, &dst_bindir, 0o755);\n         }\n \n+        // Copy libLLVM.so to the target lib dir as well, so the RPATH like\n+        // `$ORIGIN/../lib` can find it. It may also be used as a dependency\n+        // of `rustc-dev` to support the inherited `-lLLVM` when using the\n+        // compiler libraries.\n+        maybe_install_llvm_target(builder, target, &image);\n+\n         // Prepare the overlay\n         let overlay = tmp.join(\"llvm-tools-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n@@ -2370,119 +2468,3 @@ impl Step for LlvmTools {\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n-\n-#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n-pub struct Lldb {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Lldb {\n-    type Output = Option<PathBuf>;\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/llvm-project/lldb\").path(\"src/tools/lldb\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Lldb { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let target = self.target;\n-\n-        if builder.config.dry_run {\n-            return None;\n-        }\n-\n-        let bindir = builder.llvm_out(target).join(\"bin\");\n-        let lldb_exe = bindir.join(exe(\"lldb\", &target));\n-        if !lldb_exe.exists() {\n-            return None;\n-        }\n-\n-        builder.info(&format!(\"Dist Lldb ({})\", target));\n-        let src = builder.src.join(\"src/llvm-project/lldb\");\n-        let name = pkgname(builder, \"lldb\");\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"lldb-image\");\n-        drop(fs::remove_dir_all(&image));\n-\n-        // Prepare the image directory\n-        let root = image.join(\"lib/rustlib\").join(&*target);\n-        let dst = root.join(\"bin\");\n-        t!(fs::create_dir_all(&dst));\n-        for program in &[\"lldb\", \"lldb-argdumper\", \"lldb-mi\", \"lldb-server\"] {\n-            let exe = bindir.join(exe(program, &target));\n-            builder.install(&exe, &dst, 0o755);\n-        }\n-\n-        // The libraries.\n-        let libdir = builder.llvm_out(target).join(\"lib\");\n-        let dst = root.join(\"lib\");\n-        t!(fs::create_dir_all(&dst));\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = entry.unwrap();\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"liblldb.\") && !name.ends_with(\".a\") {\n-                    if t!(entry.file_type()).is_symlink() {\n-                        builder.copy_to_folder(&entry.path(), &dst);\n-                    } else {\n-                        builder.install(&entry.path(), &dst, 0o755);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // The lldb scripts might be installed in lib/python$version\n-        // or in lib64/python$version.  If lib64 exists, use it;\n-        // otherwise lib.\n-        let libdir = builder.llvm_out(target).join(\"lib64\");\n-        let (libdir, libdir_name) = if libdir.exists() {\n-            (libdir, \"lib64\")\n-        } else {\n-            (builder.llvm_out(target).join(\"lib\"), \"lib\")\n-        };\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = t!(entry);\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"python\") {\n-                    let dst = root.join(libdir_name).join(entry.file_name());\n-                    t!(fs::create_dir_all(&dst));\n-                    builder.cp_r(&entry.path(), &dst);\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"lldb-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &builder.lldb_vers());\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=lldb-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=lldb-preview\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n-    }\n-}"}, {"sha": "582bc9da0e804d4838da8b343b9f21de04957f9a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 89, "deletions": 43, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -70,6 +70,35 @@ book!(\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n+fn open(builder: &Builder<'_>, path: impl AsRef<Path>) {\n+    if builder.config.dry_run || !builder.config.cmd.open() {\n+        return;\n+    }\n+\n+    let path = path.as_ref();\n+    builder.info(&format!(\"Opening doc {}\", path.display()));\n+    if let Err(err) = opener::open(path) {\n+        builder.info(&format!(\"{}\\n\", err));\n+    }\n+}\n+\n+// \"src/libstd\" -> [\"src\", \"libstd\"]\n+//\n+// Used for deciding whether a particular step is one requested by the user on\n+// the `x.py doc` command line, which determines whether `--open` will open that\n+// page.\n+fn components_simplified(path: &PathBuf) -> Vec<&str> {\n+    path.iter().map(|component| component.to_str().unwrap_or(\"???\")).collect()\n+}\n+\n+fn is_explicit_request(builder: &Builder<'_>, path: &str) -> bool {\n+    builder\n+        .paths\n+        .iter()\n+        .map(components_simplified)\n+        .any(|requested| requested.iter().copied().eq(path.split(\"/\")))\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n     target: Interned<String>,\n@@ -127,7 +156,7 @@ impl Step for RustbookSrc {\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n-        if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n+        if builder.config.dry_run || up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return;\n         }\n         builder.info(&format!(\"Rustbook ({}) - {}\", target, name));\n@@ -200,6 +229,12 @@ impl Step for TheBook {\n \n             invoke_rustdoc(builder, compiler, target, path);\n         }\n+\n+        if is_explicit_request(builder, \"src/doc/book\") {\n+            let out = builder.doc_out(target);\n+            let index = out.join(\"book\").join(\"index.html\");\n+            open(builder, &index);\n+        }\n     }\n }\n \n@@ -338,6 +373,13 @@ impl Step for Standalone {\n             }\n             builder.run(&mut cmd);\n         }\n+\n+        // We open doc/index.html as the default if invoked as `x.py doc --open`\n+        // with no particular explicit doc requested (e.g. src/libcore).\n+        if builder.paths.is_empty() || is_explicit_request(builder, \"src/doc\") {\n+            let index = out.join(\"index.html\");\n+            open(builder, &index);\n+        }\n     }\n }\n \n@@ -393,11 +435,10 @@ impl Step for Std {\n         t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n \n         let run_cargo_rustdoc_for = |package: &str| {\n-            let mut cargo = builder.cargo(compiler, Mode::Std, target, \"rustdoc\");\n-            compile::std_cargo(builder, target, &mut cargo);\n+            let mut cargo =\n+                builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"rustdoc\");\n+            compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n \n-            // Keep a whitelist so we do not build internal stdlib crates, these will be\n-            // build by the rustc step later if enabled.\n             cargo.arg(\"-p\").arg(package);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links.\n@@ -408,7 +449,6 @@ impl Step for Std {\n                 .arg(\"--markdown-css\")\n                 .arg(\"rust.css\")\n                 .arg(\"--markdown-no-toc\")\n-                .arg(\"--generate-redirect-pages\")\n                 .arg(\"-Z\")\n                 .arg(\"unstable-options\")\n                 .arg(\"--resource-suffix\")\n@@ -418,10 +458,29 @@ impl Step for Std {\n \n             builder.run(&mut cargo.into());\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n+        // Only build the following crates. While we could just iterate over the\n+        // folder structure, that would also build internal crates that we do\n+        // not want to show in documentation. These crates will later be visited\n+        // by the rustc step, so internal documentation will show them.\n+        let krates = [\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"];\n+        for krate in &krates {\n             run_cargo_rustdoc_for(krate);\n         }\n         builder.cp_r(&my_out, &out);\n+\n+        // Look for src/libstd, src/libcore etc in the `x.py doc` arguments and\n+        // open the corresponding rendered docs.\n+        for path in builder.paths.iter().map(components_simplified) {\n+            if path.get(0) == Some(&\"src\")\n+                && path.get(1).map_or(false, |dir| dir.starts_with(\"lib\"))\n+            {\n+                let requested_crate = &path[1][3..];\n+                if krates.contains(&requested_crate) {\n+                    let index = out.join(requested_crate).join(\"index.html\");\n+                    open(builder, &index);\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -460,8 +519,7 @@ impl Step for Rustc {\n         let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        // Get the correct compiler for this stage.\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n+        let compiler = builder.compiler(stage, builder.config.build);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -477,8 +535,12 @@ impl Step for Rustc {\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         // Build cargo command.\n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, SourceType::InTree, target, \"doc\");\n+        cargo.env(\n+            \"RUSTDOCFLAGS\",\n+            \"--document-private-items \\\n+            --enable-index-page -Zunstable-options\",\n+        );\n         compile::rustc_cargo(builder, &mut cargo, target);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -487,8 +549,8 @@ impl Step for Rustc {\n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n         for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n-            let interned_root_crate = INTERNER.intern_str(root_crate);\n-            find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n+            compiler_crates\n+                .extend(builder.in_tree_crates(root_crate).into_iter().map(|krate| krate.name));\n         }\n \n         for krate in &compiler_crates {\n@@ -503,22 +565,6 @@ impl Step for Rustc {\n     }\n }\n \n-fn find_compiler_crates(\n-    builder: &Builder<'_>,\n-    name: &Interned<String>,\n-    crates: &mut HashSet<Interned<String>>,\n-) {\n-    // Add current crate.\n-    crates.insert(*name);\n-\n-    // Look for dependencies.\n-    for dep in builder.crates.get(name).unwrap().deps.iter() {\n-        if builder.crates.get(dep).unwrap().is_local(builder) {\n-            find_compiler_crates(builder, dep, crates);\n-        }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n     stage: u32,\n@@ -553,8 +599,7 @@ impl Step for Rustdoc {\n         let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        // Get the correct compiler for this stage.\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n+        let compiler = builder.compiler(stage, builder.config.build);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -593,9 +638,10 @@ impl Step for Rustdoc {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n-    target: Interned<String>,\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n impl Step for ErrorIndex {\n@@ -609,26 +655,26 @@ impl Step for ErrorIndex {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(ErrorIndex { target: run.target });\n+        let target = run.target;\n+        // error_index_generator depends on librustdoc. Use the compiler that\n+        // is normally used to build rustdoc for other documentation so that\n+        // it shares the same artifacts.\n+        let compiler =\n+            run.builder.compiler_for(run.builder.top_stage, run.builder.config.build, target);\n+        run.builder.ensure(ErrorIndex { compiler, target });\n     }\n \n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n     fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-\n-        builder.info(&format!(\"Documenting error index ({})\", target));\n-        let out = builder.doc_out(target);\n+        builder.info(&format!(\"Documenting error index ({})\", self.target));\n+        let out = builder.doc_out(self.target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(2, builder.config.build);\n-        let mut index = tool::ErrorIndex::command(builder, compiler);\n+        let mut index = tool::ErrorIndex::command(builder, self.compiler);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n \n-        // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &builder.config.build);\n-\n         builder.run(&mut index);\n     }\n }"}, {"sha": "f477c752933856e0ffd07747f963dcf20fff026c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -3,19 +3,17 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::fs;\n+use std::env;\n use std::path::PathBuf;\n use std::process;\n \n use getopts::Options;\n \n use crate::builder::Builder;\n+use crate::cache::{Interned, INTERNER};\n use crate::config::Config;\n-use crate::metadata;\n use crate::{Build, DocTests};\n \n-use crate::cache::{Interned, INTERNER};\n-\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n@@ -61,6 +59,7 @@ pub enum Subcommand {\n     },\n     Doc {\n         paths: Vec<PathBuf>,\n+        open: bool,\n     },\n     Test {\n         paths: Vec<PathBuf>,\n@@ -106,18 +105,18 @@ impl Flags {\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n-    build       Compile either the compiler or libraries\n-    check       Compile either the compiler or libraries, using cargo check\n+    build, b    Compile either the compiler or libraries\n+    check, c    Compile either the compiler or libraries, using cargo check\n     clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n     fix         Run cargo fix\n     fmt         Run rustfmt\n-    test        Build and run some test suites\n+    test, t     Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n     clean       Clean out build directories\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n-    run         Run tools contained in this repository\n+    run, r      Run tools contained in this repository\n \n To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n@@ -148,7 +147,12 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"N\",\n         );\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n-        opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n+        let j_msg = format!(\n+            \"number of jobs to run in parallel; \\\n+             defaults to {} (this host's logical CPU count)\",\n+            num_cpus::get()\n+        );\n+        opts.optopt(\"j\", \"jobs\", &j_msg, \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n         opts.optopt(\n             \"\",\n@@ -184,17 +188,21 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         // there on out.\n         let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n+                || (s == \"b\")\n                 || (s == \"check\")\n+                || (s == \"c\")\n                 || (s == \"clippy\")\n                 || (s == \"fix\")\n                 || (s == \"fmt\")\n                 || (s == \"test\")\n+                || (s == \"t\")\n                 || (s == \"bench\")\n                 || (s == \"doc\")\n                 || (s == \"clean\")\n                 || (s == \"dist\")\n                 || (s == \"install\")\n                 || (s == \"run\")\n+                || (s == \"r\")\n         });\n         let subcommand = match subcommand {\n             Some(s) => s,\n@@ -210,7 +218,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 opts.optmulti(\n@@ -244,6 +252,9 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"bench\" => {\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n             }\n+            \"doc\" => {\n+                opts.optflag(\"\", \"open\", \"open the docs in a browser\");\n+            }\n             \"clean\" => {\n                 opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n             }\n@@ -285,7 +296,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n-            \"build\" => {\n+            \"build\" | \"b\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -312,7 +323,7 @@ Arguments:\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n                 );\n             }\n-            \"check\" => {\n+            \"check\" | \"c\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -362,7 +373,7 @@ Arguments:\n         ./x.py fmt --check\",\n                 );\n             }\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -400,14 +411,15 @@ Arguments:\n         ./x.py doc src/doc/book\n         ./x.py doc src/doc/nomicon\n         ./x.py doc src/doc/book src/libstd\n+        ./x.py doc src/libstd --open\n \n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n         ./x.py doc --stage 1\",\n                 );\n             }\n-            \"run\" => {\n+            \"run\" | \"r\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -424,19 +436,12 @@ Arguments:\n         // Get any optional paths which occur after the subcommand\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n-        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n-            if fs::metadata(\"config.toml\").is_ok() {\n-                Some(PathBuf::from(\"config.toml\"))\n-            } else {\n-                None\n-            }\n-        });\n+        let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n \n         // All subcommands except `clean` can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let config = Config::parse(&[\"build\".to_string()]);\n-            let mut build = Build::new(config);\n-            metadata::build(&mut build);\n+            let build = Build::new(config);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n@@ -453,11 +458,11 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => Subcommand::Build { paths },\n-            \"check\" => Subcommand::Check { paths },\n+            \"build\" | \"b\" => Subcommand::Build { paths },\n+            \"check\" | \"c\" => Subcommand::Check { paths },\n             \"clippy\" => Subcommand::Clippy { paths },\n             \"fix\" => Subcommand::Fix { paths },\n-            \"test\" => Subcommand::Test {\n+            \"test\" | \"t\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n@@ -475,7 +480,7 @@ Arguments:\n                 },\n             },\n             \"bench\" => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n-            \"doc\" => Subcommand::Doc { paths },\n+            \"doc\" => Subcommand::Doc { paths, open: matches.opt_present(\"open\") },\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n@@ -487,7 +492,7 @@ Arguments:\n             \"fmt\" => Subcommand::Format { check: matches.opt_present(\"check\") },\n             \"dist\" => Subcommand::Dist { paths },\n             \"install\" => Subcommand::Install { paths },\n-            \"run\" => {\n+            \"run\" | \"r\" => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n                     usage(1, &opts, &subcommand_help, &extra_help);\n@@ -499,6 +504,20 @@ Arguments:\n             }\n         };\n \n+        if let Subcommand::Check { .. } = &cmd {\n+            if matches.opt_str(\"stage\").is_some() {\n+                println!(\"{}\", \"--stage not supported for x.py check, always treated as stage 0\");\n+                process::exit(1);\n+            }\n+            if matches.opt_str(\"keep-stage\").is_some() {\n+                println!(\n+                    \"{}\",\n+                    \"--keep-stage not supported for x.py check, only one stage available\"\n+                );\n+                process::exit(1);\n+            }\n+        }\n+\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n@@ -595,6 +614,13 @@ impl Subcommand {\n             _ => None,\n         }\n     }\n+\n+    pub fn open(&self) -> bool {\n+        match *self {\n+            Subcommand::Doc { open, .. } => open,\n+            _ => false,\n+        }\n+    }\n }\n \n fn split(s: &[String]) -> Vec<String> {"}, {"sha": "390b7e96b9a543cecdd806fe2369b10469bd9f50", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -23,7 +23,7 @@ fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     if !status.success() {\n         eprintln!(\n             \"Running `{}` failed.\\nIf you're running `tidy`, \\\n-            try again with `--bless` flag. Or, you just want to format \\\n+            try again with `--bless`. Or, if you just want to format \\\n             code, run `./x.py fmt` instead.\",\n             cmd_debug,\n         );"}, {"sha": "7026b25d1b98467d821f5fd2981c263bcddb8de3", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -32,6 +32,9 @@ pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: Interned<String>)\n pub fn install_rls(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n+pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+    install_sh(builder, \"rust-analyzer\", \"rust-analyzer\", stage, Some(host));\n+}\n pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n }\n@@ -70,7 +73,10 @@ fn install_sh(\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n-        fs::canonicalize(p).unwrap_or_else(|_| panic!(\"could not canonicalize {}\", p.display()))\n+        fs::create_dir_all(p)\n+            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n+        fs::canonicalize(p)\n+            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n     });\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n@@ -213,11 +219,19 @@ install!((self, builder, _config),\n             );\n         }\n     };\n+    RustAnalyzer, \"rust-analyzer\", Self::should_build(_config), only_hosts: true, {\n+        builder.ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target });\n+        if Self::should_install(builder) {\n+            install_rust_analyzer(builder, self.compiler.stage, self.target);\n+        } else {\n+            builder.info(\n+                &format!(\"skipping Install rust-analyzer stage{} ({})\", self.compiler.stage, self.target),\n+            );\n+        }\n+    };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy {\n-            compiler: self.compiler,\n-            target: self.target,\n-        }).is_some() || Self::should_install(builder) {\n+        builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n+        if Self::should_install(builder) {\n             install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info("}, {"sha": "783a64c3581f96a43b6b106bcebff0bdce9ec3ec", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 103, "deletions": 58, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -225,6 +225,7 @@ pub struct Build {\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n+    rust_analyzer_info: channel::GitInfo,\n     clippy_info: channel::GitInfo,\n     miri_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n@@ -243,6 +244,7 @@ pub struct Build {\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n     initial_lld: PathBuf,\n+    initial_libdir: PathBuf,\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n@@ -269,16 +271,22 @@ struct Crate {\n }\n \n impl Crate {\n-    fn is_local(&self, build: &Build) -> bool {\n-        self.path.starts_with(&build.config.src) && !self.path.to_string_lossy().ends_with(\"_shim\")\n-    }\n-\n     fn local_path(&self, build: &Build) -> PathBuf {\n-        assert!(self.is_local(build));\n         self.path.strip_prefix(&build.config.src).unwrap().into()\n     }\n }\n \n+/// When building Rust various objects are handled differently.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum DependencyType {\n+    /// Libraries originating from proc-macros.\n+    Host,\n+    /// Typical Rust libraries.\n+    Target,\n+    /// Non Rust libraries and objects shipped to ease usage of certain targets.\n+    TargetSelfContained,\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -294,16 +302,21 @@ pub enum Mode {\n     /// Build codegen libraries, placing output in the \"stageN-codegen\" directory\n     Codegen,\n \n-    /// Build some tools, placing output in the \"stageN-tools\" directory. The\n-    /// \"other\" here is for miscellaneous sets of tools that are built using the\n-    /// bootstrap compiler in its entirety (target libraries and all).\n-    /// Typically these tools compile with stable Rust.\n+    /// Build a tool, placing output in the \"stage0-bootstrap-tools\"\n+    /// directory. This is for miscellaneous sets of tools that are built\n+    /// using the bootstrap stage0 compiler in its entirety (target libraries\n+    /// and all). Typically these tools compile with stable Rust.\n     ToolBootstrap,\n \n-    /// Compile a tool which uses all libraries we compile (up to rustc).\n-    /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n-    /// tools like rustdoc, cargo, rls, etc.\n+    /// Build a tool which uses the locally built std, placing output in the\n+    /// \"stageN-tools\" directory. Its usage is quite rare, mainly used by\n+    /// compiletest which needs libtest.\n     ToolStd,\n+\n+    /// Build a tool which uses the locally built rustc and the target std,\n+    /// placing the output in the \"stageN-tools\" directory. This is used for\n+    /// anything that needs a fully functional rustc, such as rustdoc, clippy,\n+    /// cargo, rls, rustfmt, miri, etc.\n     ToolRustc,\n }\n \n@@ -337,25 +350,48 @@ impl Build {\n         let rust_info = channel::GitInfo::new(ignore_git, &src);\n         let cargo_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/cargo\"));\n         let rls_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/rls\"));\n+        let rust_analyzer_info =\n+            channel::GitInfo::new(ignore_git, &src.join(\"src/tools/rust-analyzer\"));\n         let clippy_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/clippy\"));\n         let miri_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/miri\"));\n         let rustfmt_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/rustfmt\"));\n \n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n \n-        let initial_sysroot = config.initial_rustc.parent().unwrap().parent().unwrap();\n-        let initial_lld = initial_sysroot\n-            .join(\"lib\")\n-            .join(\"rustlib\")\n-            .join(config.build)\n-            .join(\"bin\")\n-            .join(\"rust-lld\");\n+        let initial_target_libdir_str = if config.dry_run {\n+            \"/dummy/lib/path/to/lib/\".to_string()\n+        } else {\n+            output(\n+                Command::new(&config.initial_rustc)\n+                    .arg(\"--target\")\n+                    .arg(config.build)\n+                    .arg(\"--print\")\n+                    .arg(\"target-libdir\"),\n+            )\n+        };\n+        let initial_target_dir = Path::new(&initial_target_libdir_str).parent().unwrap();\n+        let initial_lld = initial_target_dir.join(\"bin\").join(\"rust-lld\");\n+\n+        let initial_sysroot = if config.dry_run {\n+            \"/dummy\".to_string()\n+        } else {\n+            output(Command::new(&config.initial_rustc).arg(\"--print\").arg(\"sysroot\"))\n+        };\n+        let initial_libdir = initial_target_dir\n+            .parent()\n+            .unwrap()\n+            .parent()\n+            .unwrap()\n+            .strip_prefix(initial_sysroot.trim())\n+            .unwrap()\n+            .to_path_buf();\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             initial_lld,\n+            initial_libdir,\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n             doc_tests: config.cmd.doc_tests(),\n@@ -372,6 +408,7 @@ impl Build {\n             rust_info,\n             cargo_info,\n             rls_info,\n+            rust_analyzer_info,\n             clippy_info,\n             miri_info,\n             rustfmt_info,\n@@ -399,10 +436,9 @@ impl Build {\n             output(Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n         let local_release = local_version_verbose\n             .lines()\n-            .filter(|x| x.starts_with(\"release:\"))\n+            .filter_map(|x| x.strip_prefix(\"release:\"))\n             .next()\n             .unwrap()\n-            .trim_start_matches(\"release:\")\n             .trim();\n         let my_version = channel::CFG_RELEASE_NUM;\n         if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n@@ -855,6 +891,15 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns the \"musl libdir\" for this `target`.\n+    fn musl_libdir(&self, target: Interned<String>) -> Option<PathBuf> {\n+        let t = self.config.target_config.get(&target)?;\n+        if let libdir @ Some(_) = &t.musl_libdir {\n+            return libdir.clone();\n+        }\n+        self.musl_root(target).map(|root| root.join(\"lib\"))\n+    }\n+\n     /// Returns the sysroot for the wasi target, if defined\n     fn wasi_root(&self, target: Interned<String>) -> Option<&Path> {\n         self.config.target_config.get(&target).and_then(|t| t.wasi_root.as_ref()).map(|p| &**p)\n@@ -941,29 +986,15 @@ impl Build {\n             return s;\n         }\n \n-        let beta = output(\n-            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"beta\").current_dir(&self.src),\n-        );\n-        let beta = beta.trim().split_whitespace().next().unwrap();\n-        let master = output(\n-            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"master\").current_dir(&self.src),\n-        );\n-        let master = master.trim().split_whitespace().next().unwrap();\n-\n-        // Figure out where the current beta branch started.\n-        let base = output(\n-            Command::new(\"git\").arg(\"merge-base\").arg(beta).arg(master).current_dir(&self.src),\n-        );\n-        let base = base.trim();\n-\n-        // Next figure out how many merge commits happened since we branched off\n-        // beta. That's our beta number!\n+        // Figure out how many merge commits happened since we branched off master.\n+        // That's our beta number!\n+        // (Note that we use a `..` range, not the `...` symmetric difference.)\n         let count = output(\n             Command::new(\"git\")\n                 .arg(\"rev-list\")\n                 .arg(\"--count\")\n                 .arg(\"--merges\")\n-                .arg(format!(\"{}...HEAD\", base))\n+                .arg(\"refs/remotes/origin/master..HEAD\")\n                 .current_dir(&self.src),\n         );\n         let n = count.trim().parse().unwrap();\n@@ -1006,6 +1037,11 @@ impl Build {\n         self.package_vers(&self.release_num(\"rls\"))\n     }\n \n+    /// Returns the value of `package_vers` above for rust-analyzer\n+    fn rust_analyzer_package_vers(&self) -> String {\n+        self.package_vers(&self.release_num(\"rust-analyzer/crates/rust-analyzer\"))\n+    }\n+\n     /// Returns the value of `package_vers` above for clippy\n     fn clippy_package_vers(&self) -> String {\n         self.package_vers(&self.release_num(\"clippy\"))\n@@ -1029,14 +1065,6 @@ impl Build {\n         self.rust_version()\n     }\n \n-    fn lldb_package_vers(&self) -> String {\n-        self.package_vers(channel::CFG_RELEASE_NUM)\n-    }\n-\n-    fn lldb_vers(&self) -> String {\n-        self.rust_version()\n-    }\n-\n     fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }\n@@ -1060,10 +1088,10 @@ impl Build {\n         let toml_file_name = self.src.join(&format!(\"src/tools/{}/Cargo.toml\", package));\n         let toml = t!(fs::read_to_string(&toml_file_name));\n         for line in toml.lines() {\n-            let prefix = \"version = \\\"\";\n-            let suffix = \"\\\"\";\n-            if line.starts_with(prefix) && line.ends_with(suffix) {\n-                return line[prefix.len()..line.len() - suffix.len()].to_string();\n+            if let Some(stripped) =\n+                line.strip_prefix(\"version = \\\"\").and_then(|s| s.strip_suffix(\"\\\"\"))\n+            {\n+                return stripped.to_owned();\n             }\n         }\n \n@@ -1079,25 +1107,37 @@ impl Build {\n         }\n     }\n \n+    /// Returns a Vec of all the dependencies of the given root crate,\n+    /// including transitive dependencies and the root itself. Only includes\n+    /// \"local\" crates (those in the local source tree, not from a registry).\n     fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n         let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            if krate.is_local(self) {\n-                ret.push(krate);\n-            }\n+            ret.push(krate);\n             for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n+                // Don't include optional deps if their features are not\n+                // enabled. Ideally this would be computed from `cargo\n+                // metadata --features \u2026`, but that is somewhat slow. Just\n+                // skip `build_helper` since there aren't any operations we\n+                // want to perform on it. In the future, we may want to\n+                // consider just filtering all build and dev dependencies in\n+                // metadata::build.\n+                if visited.insert(dep)\n+                    && dep != \"build_helper\"\n+                    && (dep != \"profiler_builtins\" || self.config.profiler)\n+                    && (dep != \"rustc_codegen_llvm\" || self.config.llvm_enabled())\n+                {\n                     list.push(*dep);\n                 }\n             }\n         }\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, DependencyType)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1110,9 +1150,14 @@ impl Build {\n             if part.is_empty() {\n                 continue;\n             }\n-            let host = part[0] as char == 'h';\n+            let dependency_type = match part[0] as char {\n+                'h' => DependencyType::Host,\n+                's' => DependencyType::TargetSelfContained,\n+                't' => DependencyType::Target,\n+                _ => unreachable!(),\n+            };\n             let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n-            paths.push((path, host));\n+            paths.push((path, dependency_type));\n         }\n         paths\n     }"}, {"sha": "a38391c7b88f28f31125681682e41bc4441e1d76", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,5 +1,3 @@\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n use std::path::PathBuf;\n use std::process::Command;\n \n@@ -12,7 +10,6 @@ use crate::{Build, Crate};\n #[derive(Deserialize)]\n struct Output {\n     packages: Vec<Package>,\n-    resolve: Resolve,\n }\n \n #[derive(Deserialize)]\n@@ -21,72 +18,39 @@ struct Package {\n     name: String,\n     source: Option<String>,\n     manifest_path: String,\n+    dependencies: Vec<Dependency>,\n }\n \n #[derive(Deserialize)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(Deserialize)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n+struct Dependency {\n+    name: String,\n+    source: Option<String>,\n }\n \n pub fn build(build: &mut Build) {\n-    let mut resolves = Vec::new();\n-    build_krate(&build.std_features(), build, &mut resolves, \"src/libstd\");\n-    build_krate(\"\", build, &mut resolves, \"src/libtest\");\n-    build_krate(&build.rustc_features(), build, &mut resolves, \"src/rustc\");\n-\n-    let mut id2name = HashMap::with_capacity(build.crates.len());\n-    for (name, krate) in build.crates.iter() {\n-        id2name.insert(krate.id.clone(), name.clone());\n-    }\n-\n-    for node in resolves {\n-        let name = match id2name.get(&node.id) {\n-            Some(name) => name,\n-            None => continue,\n-        };\n-\n-        let krate = build.crates.get_mut(name).unwrap();\n-        for dep in node.dependencies.iter() {\n-            let dep = match id2name.get(dep) {\n-                Some(dep) => dep,\n-                None => continue,\n-            };\n-            krate.deps.insert(*dep);\n-        }\n-    }\n-}\n-\n-fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode>, krate: &str) {\n     // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n     let mut cargo = Command::new(&build.initial_cargo);\n     cargo\n         .arg(\"metadata\")\n         .arg(\"--format-version\")\n         .arg(\"1\")\n-        .arg(\"--features\")\n-        .arg(features)\n+        .arg(\"--no-deps\")\n         .arg(\"--manifest-path\")\n-        .arg(build.src.join(krate).join(\"Cargo.toml\"));\n+        .arg(build.src.join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n-            build.crates.insert(name, Crate { name, id: package.id, deps: HashSet::new(), path });\n+            let deps = package\n+                .dependencies\n+                .into_iter()\n+                .filter(|dep| dep.source.is_none())\n+                .map(|dep| INTERNER.intern_string(dep.name))\n+                .collect();\n+            build.crates.insert(name, Crate { name, id: package.id, deps, path });\n         }\n     }\n-    resolves.extend(output.resolve.nodes);\n }"}, {"sha": "12a1734e21c7e165eea70f8ff3742cac2fe55889", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -6,12 +6,6 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n-ifdef EXCLUDE_CARGO\n-AUX_ARGS :=\n-else\n-AUX_ARGS := src/tools/cargo src/tools/cargotest\n-endif\n-\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -48,9 +42,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-fail/pretty \\\n-\t\tsrc/test/run-pass-valgrind/pretty \\\n-\t\t$(AUX_ARGS) \\\n+\t\tsrc/tools/cargo \\\n+\t\tsrc/tools/cargotest \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py"}, {"sha": "e8ec575ea37466379f6ab1e75ccc3134f5c22ddd", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 179, "deletions": 104, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -9,6 +9,7 @@\n //! ensure that they're always in place if needed.\n \n use std::env;\n+use std::env::consts::EXE_EXTENSION;\n use std::ffi::OsString;\n use std::fs::{self, File};\n use std::io;\n@@ -24,6 +25,72 @@ use crate::util::{self, exe};\n use crate::GitRepo;\n use build_helper::up_to_date;\n \n+pub struct Meta {\n+    stamp: HashStamp,\n+    build_llvm_config: PathBuf,\n+    out_dir: PathBuf,\n+    root: String,\n+}\n+\n+// This returns whether we've already previously built LLVM.\n+//\n+// It's used to avoid busting caches during x.py check -- if we've already built\n+// LLVM, it's fine for us to not try to avoid doing so.\n+//\n+// This will return the llvm-config if it can get it (but it will not build it\n+// if not).\n+pub fn prebuilt_llvm_config(\n+    builder: &Builder<'_>,\n+    target: Interned<String>,\n+) -> Result<PathBuf, Meta> {\n+    // If we're using a custom LLVM bail out here, but we can only use a\n+    // custom LLVM for the build triple.\n+    if let Some(config) = builder.config.target_config.get(&target) {\n+        if let Some(ref s) = config.llvm_config {\n+            check_llvm_version(builder, s);\n+            return Ok(s.to_path_buf());\n+        }\n+    }\n+\n+    let root = \"src/llvm-project/llvm\";\n+    let out_dir = builder.llvm_out(target);\n+    let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n+    if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n+        llvm_config_ret_dir.push(\"build\");\n+    }\n+    llvm_config_ret_dir.push(\"bin\");\n+\n+    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n+\n+    let stamp = out_dir.join(\"llvm-finished-building\");\n+    let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n+\n+    if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n+        builder.info(\n+            \"Warning: \\\n+                Using a potentially stale build of LLVM; \\\n+                This may not behave well.\",\n+        );\n+        return Ok(build_llvm_config);\n+    }\n+\n+    if stamp.is_done() {\n+        if stamp.hash.is_none() {\n+            builder.info(\n+                \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+            );\n+            builder.info(&format!(\n+                \"To force LLVM to rebuild, remove the file `{}`\",\n+                stamp.path.display()\n+            ));\n+        }\n+        return Ok(build_llvm_config);\n+    }\n+\n+    Err(Meta { stamp, build_llvm_config, out_dir, root: root.into() })\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: Interned<String>,\n@@ -46,51 +113,11 @@ impl Step for Llvm {\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n \n-        // If we're using a custom LLVM bail out here, but we can only use a\n-        // custom LLVM for the build triple.\n-        if let Some(config) = builder.config.target_config.get(&target) {\n-            if let Some(ref s) = config.llvm_config {\n-                check_llvm_version(builder, s);\n-                return s.to_path_buf();\n-            }\n-        }\n-\n-        let root = \"src/llvm-project/llvm\";\n-        let out_dir = builder.llvm_out(target);\n-        let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n-        if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n-            llvm_config_ret_dir.push(\"build\");\n-        }\n-        llvm_config_ret_dir.push(\"bin\");\n-\n-        let build_llvm_config =\n-            llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n-\n-        let stamp = out_dir.join(\"llvm-finished-building\");\n-        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n-\n-        if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n-            builder.info(\n-                \"Warning: \\\n-                Using a potentially stale build of LLVM; \\\n-                This may not behave well.\",\n-            );\n-            return build_llvm_config;\n-        }\n-\n-        if stamp.is_done() {\n-            if stamp.hash.is_none() {\n-                builder.info(\n-                    \"Could not determine the LLVM submodule commit hash. \\\n-                     Assuming that an LLVM rebuild is not necessary.\",\n-                );\n-                builder.info(&format!(\n-                    \"To force LLVM to rebuild, remove the file `{}`\",\n-                    stamp.path.display()\n-                ));\n-            }\n-            return build_llvm_config;\n-        }\n+        let Meta { stamp, build_llvm_config, out_dir, root } =\n+            match prebuilt_llvm_config(builder, target) {\n+                Ok(p) => return p,\n+                Err(m) => m,\n+            };\n \n         builder.info(&format!(\"Building LLVM for {}\", target));\n         t!(stamp.remove());\n@@ -118,7 +145,7 @@ impl Step for Llvm {\n \n         let llvm_exp_targets = match builder.config.llvm_experimental_targets {\n             Some(ref s) => s,\n-            None => \"\",\n+            None => \"AVR\",\n         };\n \n         let assertions = if builder.config.llvm_assertions { \"ON\" } else { \"OFF\" };\n@@ -132,7 +159,6 @@ impl Step for Llvm {\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n-            .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n             .define(\"WITH_POLLY\", \"OFF\")\n             .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n             .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n@@ -142,6 +168,25 @@ impl Step for Llvm {\n             .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n             .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+        if !target.contains(\"netbsd\") {\n+            cfg.define(\"LLVM_ENABLE_ZLIB\", \"ON\");\n+        } else {\n+            // FIXME: Enable zlib on NetBSD too\n+            // https://github.com/rust-lang/rust/pull/72696#issuecomment-641517185\n+            cfg.define(\"LLVM_ENABLE_ZLIB\", \"OFF\");\n+        }\n+\n+        // Are we compiling for iOS/tvOS?\n+        if target.contains(\"apple-ios\") || target.contains(\"apple-tvos\") {\n+            // These two defines prevent CMake from automatically trying to add a MacOSX sysroot, which leads to a compiler error.\n+            cfg.define(\"CMAKE_OSX_SYSROOT\", \"/\");\n+            cfg.define(\"CMAKE_OSX_DEPLOYMENT_TARGET\", \"\");\n+            // Prevent cmake from adding -bundle to CFLAGS automatically, which leads to a compiler error because \"-bitcode_bundle\" also gets added.\n+            cfg.define(\"LLVM_ENABLE_PLUGINS\", \"OFF\");\n+            // Zlib fails to link properly, leading to a compiler error.\n+            cfg.define(\"LLVM_ENABLE_ZLIB\", \"OFF\");\n+        }\n+\n         if builder.config.llvm_thin_lto {\n             cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n             if !target.contains(\"apple\") {\n@@ -158,7 +203,7 @@ impl Step for Llvm {\n         }\n \n         // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n-        if builder.config.llvm_tools_enabled || builder.config.lldb_enabled {\n+        if builder.config.llvm_tools_enabled {\n             if !target.contains(\"msvc\") {\n                 if target.contains(\"apple\") {\n                     cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n@@ -186,17 +231,9 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n-        if builder.config.lldb_enabled {\n-            enabled_llvm_projects.push(\"clang\");\n-            enabled_llvm_projects.push(\"lldb\");\n-            // For the time being, disable code signing.\n-            cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n-            cfg.define(\"LLDB_NO_DEBUGSERVER\", \"ON\");\n-        } else {\n-            // LLDB requires libxml2; but otherwise we want it to be disabled.\n-            // See https://github.com/rust-lang/rust/pull/50104\n-            cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n-        }\n+        // We want libxml to be disabled.\n+        // See https://github.com/rust-lang/rust/pull/50104\n+        cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n \n         if !enabled_llvm_projects.is_empty() {\n             enabled_llvm_projects.sort();\n@@ -216,8 +253,14 @@ impl Step for Llvm {\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n             //        actually exists most of the time in normal installs of LLVM.\n-            let host = builder.llvm_out(builder.config.build).join(\"bin/llvm-tblgen\");\n-            cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\").define(\"LLVM_TABLEGEN\", &host);\n+            let host_bin = builder.llvm_out(builder.config.build).join(\"bin\");\n+            cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\");\n+            cfg.define(\"LLVM_TABLEGEN\", host_bin.join(\"llvm-tblgen\").with_extension(EXE_EXTENSION));\n+            cfg.define(\"LLVM_NM\", host_bin.join(\"llvm-nm\").with_extension(EXE_EXTENSION));\n+            cfg.define(\n+                \"LLVM_CONFIG_PATH\",\n+                host_bin.join(\"llvm-config\").with_extension(EXE_EXTENSION),\n+            );\n \n             if target.contains(\"netbsd\") {\n                 cfg.define(\"CMAKE_SYSTEM_NAME\", \"NetBSD\");\n@@ -226,8 +269,6 @@ impl Step for Llvm {\n             } else if target.contains(\"windows\") {\n                 cfg.define(\"CMAKE_SYSTEM_NAME\", \"Windows\");\n             }\n-\n-            cfg.define(\"LLVM_NATIVE_BUILD\", builder.llvm_out(builder.config.build).join(\"build\"));\n         }\n \n         if let Some(ref suffix) = builder.config.llvm_version_suffix {\n@@ -387,6 +428,17 @@ fn configure_cmake(\n     if let Some(ref s) = builder.config.llvm_cflags {\n         cflags.push_str(&format!(\" {}\", s));\n     }\n+    // Some compiler features used by LLVM (such as thread locals) will not work on a min version below iOS 10.\n+    if target.contains(\"apple-ios\") {\n+        if target.contains(\"86-\") {\n+            cflags.push_str(\" -miphonesimulator-version-min=10.0\");\n+        } else {\n+            cflags.push_str(\" -miphoneos-version-min=10.0\");\n+        }\n+    }\n+    if builder.config.llvm_clang_cl.is_some() {\n+        cflags.push_str(&format!(\" --target={}\", target))\n+    }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n     let mut cxxflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n     if builder.config.llvm_static_stdcpp && !target.contains(\"msvc\") && !target.contains(\"netbsd\") {\n@@ -395,6 +447,9 @@ fn configure_cmake(\n     if let Some(ref s) = builder.config.llvm_cxxflags {\n         cxxflags.push_str(&format!(\" {}\", s));\n     }\n+    if builder.config.llvm_clang_cl.is_some() {\n+        cxxflags.push_str(&format!(\" --target={}\", target))\n+    }\n     cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n     if let Some(ar) = builder.ar(target) {\n         if ar.is_absolute() {\n@@ -440,7 +495,7 @@ impl Step for Lld {\n         run.builder.ensure(Lld { target: run.target });\n     }\n \n-    /// Compile LLVM for `target`.\n+    /// Compile LLD for `target`.\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         if builder.config.dry_run {\n             return PathBuf::from(\"lld-out-dir-test-gen\");\n@@ -477,12 +532,39 @@ impl Step for Lld {\n         // can't build on a system where your paths require `\\` on Windows, but\n         // there's probably a lot of reasons you can't do that other than this.\n         let llvm_config_shim = env::current_exe().unwrap().with_file_name(\"llvm-config-wrapper\");\n+\n         cfg.out_dir(&out_dir)\n             .profile(\"Release\")\n-            .env(\"LLVM_CONFIG_REAL\", llvm_config)\n+            .env(\"LLVM_CONFIG_REAL\", &llvm_config)\n             .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n+        // While we're using this horrible workaround to shim the execution of\n+        // llvm-config, let's just pile on more. I can't seem to figure out how\n+        // to build LLD as a standalone project and also cross-compile it at the\n+        // same time. It wants a natively executable `llvm-config` to learn\n+        // about LLVM, but then it learns about all the host configuration of\n+        // LLVM and tries to link to host LLVM libraries.\n+        //\n+        // To work around that we tell our shim to replace anything with the\n+        // build target with the actual target instead. This'll break parts of\n+        // LLD though which try to execute host tools, such as llvm-tblgen, so\n+        // we specifically tell it where to find those. This is likely super\n+        // brittle and will break over time. If anyone knows better how to\n+        // cross-compile LLD it would be much appreciated to fix this!\n+        if target != builder.config.build {\n+            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build)\n+                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target)\n+                .define(\n+                    \"LLVM_TABLEGEN_EXE\",\n+                    llvm_config.with_file_name(\"llvm-tblgen\").with_extension(EXE_EXTENSION),\n+                );\n+        }\n+\n+        // Explicitly set C++ standard, because upstream doesn't do so\n+        // for standalone builds.\n+        cfg.define(\"CMAKE_CXX_STANDARD\", \"14\");\n+\n         cfg.build();\n \n         t!(File::create(&done_stamp));\n@@ -528,8 +610,8 @@ impl Step for TestHelpers {\n         }\n \n         // We may have found various cross-compilers a little differently due to our\n-        // extra configuration, so inform gcc of these compilers. Note, though, that\n-        // on MSVC we still need gcc's detection of env vars (ugh).\n+        // extra configuration, so inform cc of these compilers. Note, though, that\n+        // on MSVC we still need cc's detection of env vars (ugh).\n         if !target.contains(\"msvc\") {\n             if let Some(ar) = builder.ar(target) {\n                 cfg.archiver(ar);\n@@ -648,48 +730,41 @@ fn supported_sanitizers(\n     target: Interned<String>,\n     channel: &str,\n ) -> Vec<SanitizerRuntime> {\n-    let mut result = Vec::new();\n+    let darwin_libs = |os: &str, components: &[&str]| -> Vec<SanitizerRuntime> {\n+        components\n+            .into_iter()\n+            .map(move |c| SanitizerRuntime {\n+                cmake_target: format!(\"clang_rt.{}_{}_dynamic\", c, os),\n+                path: out_dir\n+                    .join(&format!(\"build/lib/darwin/libclang_rt.{}_{}_dynamic.dylib\", c, os)),\n+                name: format!(\"librustc-{}_rt.{}.dylib\", channel, c),\n+            })\n+            .collect()\n+    };\n+\n+    let common_libs = |os: &str, arch: &str, components: &[&str]| -> Vec<SanitizerRuntime> {\n+        components\n+            .into_iter()\n+            .map(move |c| SanitizerRuntime {\n+                cmake_target: format!(\"clang_rt.{}-{}\", c, arch),\n+                path: out_dir.join(&format!(\"build/lib/{}/libclang_rt.{}-{}.a\", os, c, arch)),\n+                name: format!(\"librustc-{}_rt.{}.a\", channel, c),\n+            })\n+            .collect()\n+    };\n+\n     match &*target {\n-        \"x86_64-apple-darwin\" => {\n-            for s in &[\"asan\", \"lsan\", \"tsan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}_osx_dynamic\", s),\n-                    path: out_dir\n-                        .join(&format!(\"build/lib/darwin/libclang_rt.{}_osx_dynamic.dylib\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.dylib\", channel, s),\n-                });\n-            }\n+        \"aarch64-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n+        \"aarch64-unknown-linux-gnu\" => {\n+            common_libs(\"linux\", \"aarch64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n         }\n+        \"x86_64-apple-darwin\" => darwin_libs(\"osx\", &[\"asan\", \"lsan\", \"tsan\"]),\n+        \"x86_64-fuchsia\" => common_libs(\"fuchsia\", \"x86_64\", &[\"asan\"]),\n         \"x86_64-unknown-linux-gnu\" => {\n-            for s in &[\"asan\", \"lsan\", \"msan\", \"tsan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n-                    path: out_dir.join(&format!(\"build/lib/linux/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n-                });\n-            }\n-        }\n-        \"x86_64-fuchsia\" => {\n-            for s in &[\"asan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n-                    path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n-                });\n-            }\n-        }\n-        \"aarch64-fuchsia\" => {\n-            for s in &[\"asan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}-aarch64\", s),\n-                    path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-aarch64.a\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n-                });\n-            }\n+            common_libs(\"linux\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n         }\n-        _ => {}\n+        _ => Vec::new(),\n     }\n-    result\n }\n \n struct HashStamp {"}, {"sha": "3301d41cfeefa9f5c3571eaeae8914c7c7c500ab", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -117,14 +117,6 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n-\n-        if build.config.lldb_enabled {\n-            cmd_finder.must_have(\"swig\");\n-            let out = output(Command::new(\"swig\").arg(\"-version\"));\n-            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n-                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n-            }\n-        }\n     }\n \n     build.config.python = build\n@@ -207,10 +199,10 @@ pub fn check(build: &mut Build) {\n                 let target = build.config.target_config.entry(target.clone()).or_default();\n                 target.musl_root = Some(\"/usr\".into());\n             }\n-            match build.musl_root(*target) {\n-                Some(root) => {\n-                    if fs::metadata(root.join(\"lib/libc.a\")).is_err() {\n-                        panic!(\"couldn't find libc.a in musl dir: {}\", root.join(\"lib\").display());\n+            match build.musl_libdir(*target) {\n+                Some(libdir) => {\n+                    if fs::metadata(libdir.join(\"libc.a\")).is_err() {\n+                        panic!(\"couldn't find libc.a in musl libdir: {}\", libdir.display());\n                     }\n                 }\n                 None => panic!("}, {"sha": "1916d96bed71dba0632b9881504bebd2c8a59725", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 102, "deletions": 94, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -154,6 +154,7 @@ impl Step for Cargotest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -165,7 +166,7 @@ impl Step for Cargotest {\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(\n             builder,\n-            cmd.arg(&builder.initial_cargo)\n+            cmd.arg(&cargo)\n                 .arg(&out_dir)\n                 .env(\"RUSTC\", builder.rustc(compiler))\n                 .env(\"RUSTDOC\", builder.rustdoc(compiler)),\n@@ -360,8 +361,14 @@ impl Step for Miri {\n \n         let miri =\n             builder.ensure(tool::Miri { compiler, target: self.host, extra_features: Vec::new() });\n-        if let Some(miri) = miri {\n-            let mut cargo = builder.cargo(compiler, Mode::ToolRustc, host, \"install\");\n+        let cargo_miri = builder.ensure(tool::CargoMiri {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let (Some(miri), Some(_cargo_miri)) = (miri, cargo_miri) {\n+            let mut cargo =\n+                builder.cargo(compiler, Mode::ToolRustc, SourceType::Submodule, host, \"install\");\n             cargo.arg(\"xargo\");\n             // Configure `cargo install` path. cargo adds a `bin/`.\n             cargo.env(\"CARGO_INSTALL_ROOT\", &builder.out);\n@@ -378,18 +385,18 @@ impl Step for Miri {\n                 Mode::ToolRustc,\n                 host,\n                 \"run\",\n-                \"src/tools/miri\",\n+                \"src/tools/miri/cargo-miri\",\n                 SourceType::Submodule,\n                 &[],\n             );\n-            cargo.arg(\"--bin\").arg(\"cargo-miri\").arg(\"--\").arg(\"miri\").arg(\"setup\");\n+            cargo.arg(\"--\").arg(\"miri\").arg(\"setup\");\n \n             // Tell `cargo miri setup` where to find the sources.\n             cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n+            // Tell it where to find Miri.\n+            cargo.env(\"MIRI\", &miri);\n             // Debug things.\n             cargo.env(\"RUST_BACKTRACE\", \"1\");\n-            // Overwrite bootstrap's `rustc` wrapper overwriting our flags.\n-            cargo.env(\"RUSTC_DEBUG_ASSERTIONS\", \"true\");\n             // Let cargo-miri know where xargo ended up.\n             cargo.env(\"XARGO_CHECK\", builder.out.join(\"bin\").join(\"xargo-check\"));\n \n@@ -436,9 +443,10 @@ impl Step for Miri {\n \n             // miri tests need to know about the stage sysroot\n             cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            cargo.env(\"MIRI_PATH\", miri);\n+            cargo.env(\"MIRI\", miri);\n+\n+            cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n@@ -515,45 +523,37 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let clippy = builder.ensure(tool::Clippy {\n+        let clippy = builder\n+            .ensure(tool::Clippy { compiler, target: self.host, extra_features: Vec::new() })\n+            .expect(\"in-tree tool\");\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n             compiler,\n-            target: self.host,\n-            extra_features: Vec::new(),\n-        });\n-        if let Some(clippy) = clippy {\n-            let mut cargo = tool::prepare_tool_cargo(\n-                builder,\n-                compiler,\n-                Mode::ToolRustc,\n-                host,\n-                \"test\",\n-                \"src/tools/clippy\",\n-                SourceType::Submodule,\n-                &[],\n-            );\n+            Mode::ToolRustc,\n+            host,\n+            \"test\",\n+            \"src/tools/clippy\",\n+            SourceType::InTree,\n+            &[],\n+        );\n \n-            // clippy tests need to know about the stage sysroot\n-            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n-            let target_libs = builder\n-                .stage_out(compiler, Mode::ToolRustc)\n-                .join(&self.host)\n-                .join(builder.cargo_dir());\n-            cargo.env(\"HOST_LIBS\", host_libs);\n-            cargo.env(\"TARGET_LIBS\", target_libs);\n-            // clippy tests need to find the driver\n-            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+        // clippy tests need to know about the stage sysroot\n+        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+        let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n+        let target_libs =\n+            builder.stage_out(compiler, Mode::ToolRustc).join(&self.host).join(builder.cargo_dir());\n+        cargo.env(\"HOST_LIBS\", host_libs);\n+        cargo.env(\"TARGET_LIBS\", target_libs);\n+        // clippy tests need to find the driver\n+        cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-            if try_run(builder, &mut cargo.into()) {\n-                builder.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test clippy: could not build\");\n-        }\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        builder.run(&mut cargo.into());\n     }\n }\n \n@@ -900,8 +900,6 @@ default_test!(CompileFail {\n     suite: \"compile-fail\"\n });\n \n-default_test!(RunFail { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" });\n-\n default_test!(RunPassValgrind {\n     path: \"src/test/run-pass-valgrind\",\n     mode: \"run-pass-valgrind\",\n@@ -931,20 +929,6 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n-test!(RunFailPretty {\n-    path: \"src/test/run-fail/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-fail\",\n-    default: false,\n-    host: true\n-});\n-test!(RunPassValgrindPretty {\n-    path: \"src/test/run-pass-valgrind/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass-valgrind\",\n-    default: false,\n-    host: true\n-});\n \n default_test!(RunMake { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" });\n \n@@ -1108,20 +1092,15 @@ impl Step for Compiletest {\n                     .to_string()\n             })\n         };\n-        let lldb_exe = if builder.config.lldb_enabled {\n-            // Test against the lldb that was just built.\n-            builder.llvm_out(target).join(\"bin\").join(\"lldb\")\n-        } else {\n-            PathBuf::from(\"lldb\")\n-        };\n-        let lldb_version = Command::new(&lldb_exe)\n+        let lldb_exe = \"lldb\";\n+        let lldb_version = Command::new(lldb_exe)\n             .arg(\"--version\")\n             .output()\n             .map(|output| String::from_utf8_lossy(&output.stdout).to_string())\n             .ok();\n         if let Some(ref vers) = lldb_version {\n             cmd.arg(\"--lldb-version\").arg(vers);\n-            let lldb_python_dir = run(Command::new(&lldb_exe).arg(\"-P\")).ok();\n+            let lldb_python_dir = run(Command::new(lldb_exe).arg(\"-P\")).ok();\n             if let Some(ref dir) = lldb_python_dir {\n                 cmd.arg(\"--lldb-python-dir\").arg(dir);\n             }\n@@ -1473,8 +1452,11 @@ impl Step for ErrorIndex {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder\n-            .ensure(ErrorIndex { compiler: run.builder.compiler(run.builder.top_stage, run.host) });\n+        // error_index_generator depends on librustdoc. Use the compiler that\n+        // is normally used to build rustdoc for other tests (like compiletest\n+        // tests in src/test/rustdoc) so that it shares the same artifacts.\n+        let compiler = run.builder.compiler_for(run.builder.top_stage, run.host, run.host);\n+        run.builder.ensure(ErrorIndex { compiler });\n     }\n \n     /// Runs the error index generator tool to execute the tests located in the error\n@@ -1486,22 +1468,23 @@ impl Step for ErrorIndex {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n-\n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n-        let mut tool = tool::ErrorIndex::command(\n-            builder,\n-            builder.compiler(compiler.stage, builder.config.build),\n-        );\n-        tool.arg(\"markdown\").arg(&output).env(\"CFG_BUILD\", &builder.config.build);\n+        let mut tool = tool::ErrorIndex::command(builder, compiler);\n+        tool.arg(\"markdown\").arg(&output);\n \n-        builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        // Use the rustdoc that was built by self.compiler. This copy of\n+        // rustdoc is shared with other tests (like compiletest tests in\n+        // src/test/rustdoc). This helps avoid building rustdoc multiple\n+        // times.\n+        let rustdoc_compiler = builder.compiler(builder.top_stage, builder.config.build);\n+        builder.info(&format!(\"Testing error-index stage{}\", rustdoc_compiler.stage));\n         let _time = util::timeit(&builder);\n         builder.run_quiet(&mut tool);\n-        markdown_test(builder, compiler, &output);\n+        builder.ensure(compile::Std { compiler: rustdoc_compiler, target: rustdoc_compiler.host });\n+        markdown_test(builder, rustdoc_compiler, &output);\n     }\n }\n \n@@ -1579,7 +1562,7 @@ impl Step for CrateLibrustc {\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n         for krate in builder.in_tree_crates(\"rustc-main\") {\n-            if run.path.ends_with(&krate.path) {\n+            if krate.path.ends_with(&run.path) {\n                 let test_kind = builder.kind.into();\n \n                 builder.ensure(CrateLibrustc {\n@@ -1665,14 +1648,8 @@ impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        for krate in run.builder.in_tree_crates(\"test\") {\n-            if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n-                run = run.path(krate.local_path(&builder).to_str().unwrap());\n-            }\n-        }\n-        run\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.krate(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1692,7 +1669,7 @@ impl Step for Crate {\n         };\n \n         for krate in builder.in_tree_crates(\"test\") {\n-            if run.path.ends_with(&krate.local_path(&builder)) {\n+            if krate.path.ends_with(&run.path) {\n                 make(Mode::Std, krate);\n             }\n         }\n@@ -1722,10 +1699,11 @@ impl Step for Crate {\n         // we're working with automatically.\n         let compiler = builder.compiler_for(compiler.stage, compiler.host, target);\n \n-        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n+        let mut cargo =\n+            builder.cargo(compiler, mode, SourceType::InTree, target, test_kind.subcommand());\n         match mode {\n             Mode::Std => {\n-                compile::std_cargo(builder, target, &mut cargo);\n+                compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n             }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n@@ -1783,7 +1761,7 @@ impl Step for Crate {\n         } else if builder.remote_tested(target) {\n             cargo.env(\n                 format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                format!(\"{} run\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+                format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n             );\n         }\n \n@@ -1821,9 +1799,13 @@ impl Step for CrateRustdoc {\n \n     fn run(self, builder: &Builder<'_>) {\n         let test_kind = self.test_kind;\n+        let target = self.host;\n \n-        let compiler = builder.compiler(builder.top_stage, self.host);\n-        let target = compiler.host;\n+        // Use the previous stage compiler to reuse the artifacts that are\n+        // created when running compiletest for src/test/rustdoc. If this used\n+        // `compiler`, then it would cause rustdoc to be built *again*, which\n+        // isn't really necessary.\n+        let compiler = builder.compiler_for(builder.top_stage, target, target);\n         builder.ensure(compile::Rustc { compiler, target });\n \n         let mut cargo = tool::prepare_tool_cargo(\n@@ -1849,6 +1831,32 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n         }\n \n+        // This is needed for running doctests on librustdoc. This is a bit of\n+        // an unfortunate interaction with how bootstrap works and how cargo\n+        // sets up the dylib path, and the fact that the doctest (in\n+        // html/markdown.rs) links to rustc-private libs. For stage1, the\n+        // compiler host dylibs (in stage1/lib) are not the same as the target\n+        // dylibs (in stage1/lib/rustlib/...). This is different from a normal\n+        // rust distribution where they are the same.\n+        //\n+        // On the cargo side, normal tests use `target_process` which handles\n+        // setting up the dylib for a *target* (stage1/lib/rustlib/... in this\n+        // case). However, for doctests it uses `rustdoc_process` which only\n+        // sets up the dylib path for the *host* (stage1/lib), which is the\n+        // wrong directory.\n+        //\n+        // It should be considered to just stop running doctests on\n+        // librustdoc. There is only one test, and it doesn't look too\n+        // important. There might be other ways to avoid this, but it seems\n+        // pretty convoluted.\n+        //\n+        // See also https://github.com/rust-lang/rust/issues/13983 where the\n+        // host vs target dylibs for rustdoc are consistently tricky to deal\n+        // with.\n+        let mut dylib_path = dylib_path();\n+        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n         if !builder.config.verbose_tests {\n             cargo.arg(\"--quiet\");\n         }"}, {"sha": "450b534d5dfdbe378ab8d2b26ab975b14fb36193", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -12,11 +12,11 @@ use crate::channel;\n use crate::channel::GitInfo;\n use crate::compile;\n use crate::toolstate::ToolState;\n-use crate::util::{add_dylib_path, exe, CiEnv};\n+use crate::util::{add_dylib_path, exe};\n use crate::Compiler;\n use crate::Mode;\n \n-#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub enum SourceType {\n     InTree,\n     Submodule,\n@@ -226,21 +226,16 @@ pub fn prepare_tool_cargo(\n     source_type: SourceType,\n     extra_features: &[String],\n ) -> CargoCommand {\n-    let mut cargo = builder.cargo(compiler, mode, target, command);\n+    let mut cargo = builder.cargo(compiler, mode, source_type, target, command);\n     let dir = builder.src.join(path);\n     cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n \n-    if source_type == SourceType::Submodule {\n-        cargo.env(\"RUSTC_EXTERNAL_TOOL\", \"1\");\n-    }\n-\n     let mut features = extra_features.to_vec();\n     if builder.build.config.cargo_native_static {\n         if path.ends_with(\"cargo\")\n             || path.ends_with(\"rls\")\n             || path.ends_with(\"clippy\")\n             || path.ends_with(\"miri\")\n-            || path.ends_with(\"rustbook\")\n             || path.ends_with(\"rustfmt\")\n         {\n             cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n@@ -252,6 +247,10 @@ pub fn prepare_tool_cargo(\n     // own copy\n     cargo.env(\"LZMA_API_STATIC\", \"1\");\n \n+    // CFG_RELEASE is needed by rustfmt (and possibly other tools) which\n+    // import rustc-ap-rustc_attr which requires this to be set for the\n+    // `#[cfg(version(...))]` attribute.\n+    cargo.env(\"CFG_RELEASE\", builder.rust_release());\n     cargo.env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel);\n     cargo.env(\"CFG_VERSION\", builder.rust_version());\n     cargo.env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM);\n@@ -272,20 +271,6 @@ pub fn prepare_tool_cargo(\n     cargo\n }\n \n-fn rustbook_features() -> Vec<String> {\n-    let mut features = Vec::new();\n-\n-    // Due to CI budged and risk of spurious failures we want to limit jobs running this check.\n-    // At same time local builds should run it regardless of the platform.\n-    // `CiEnv::None` means it's local build and `CHECK_LINKS` is defined in x86_64-gnu-tools to\n-    // explicitly enable it on single job\n-    if CiEnv::current() == CiEnv::None || env::var(\"CHECK_LINKS\").is_ok() {\n-        features.push(\"linkcheck\".to_string());\n-    }\n-\n-    features\n-}\n-\n macro_rules! bootstrap_tool {\n     ($(\n         $name:ident, $path:expr, $tool_name:expr\n@@ -368,7 +353,7 @@ macro_rules! bootstrap_tool {\n }\n \n bootstrap_tool!(\n-    Rustbook, \"src/tools/rustbook\", \"rustbook\", features = rustbook_features();\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\";\n     UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\";\n     Tidy, \"src/tools/tidy\", \"tidy\";\n     Linkchecker, \"src/tools/linkchecker\", \"linkchecker\";\n@@ -381,7 +366,7 @@ bootstrap_tool!(\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n );\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct ErrorIndex {\n     pub compiler: Compiler,\n }\n@@ -407,9 +392,9 @@ impl Step for ErrorIndex {\n     fn make_run(run: RunConfig<'_>) {\n         // Compile the error-index in the same stage as rustdoc to avoid\n         // recompiling rustdoc twice if we can.\n-        let stage = if run.builder.top_stage >= 2 { run.builder.top_stage } else { 0 };\n-        run.builder\n-            .ensure(ErrorIndex { compiler: run.builder.compiler(stage, run.builder.config.build) });\n+        let host = run.builder.config.build;\n+        let compiler = run.builder.compiler_for(run.builder.top_stage, host, host);\n+        run.builder.ensure(ErrorIndex { compiler });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n@@ -464,7 +449,7 @@ impl Step for RemoteTestServer {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct Rustdoc {\n     /// This should only ever be 0 or 2.\n     /// We sometimes want to reference the \"bootstrap\" rustdoc, which is why this option is here.\n@@ -477,7 +462,7 @@ impl Step for Rustdoc {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/rustdoc\")\n+        run.path(\"src/tools/rustdoc\").path(\"src/librustdoc\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -591,6 +576,8 @@ macro_rules! tool_extended {\n        $toolstate:ident,\n        $path:expr,\n        $tool_name:expr,\n+       stable = $stable:expr,\n+       $(in_tree = $in_tree:expr,)*\n        $extra_deps:block;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n@@ -602,12 +589,25 @@ macro_rules! tool_extended {\n \n         impl Step for $name {\n             type Output = Option<PathBuf>;\n-            const DEFAULT: bool = true;\n+            const DEFAULT: bool = true; // Overwritten below\n             const ONLY_HOSTS: bool = true;\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.config.extended)\n+                run.path($path).default_condition(\n+                    builder.config.extended\n+                        && builder.config.tools.as_ref().map_or(\n+                            // By default, on nightly/dev enable all tools, else only\n+                            // build stable tools.\n+                            $stable || builder.build.unstable_features(),\n+                            // If `tools` is set, search list for this tool.\n+                            |tools| {\n+                                tools.iter().any(|tool| match tool.as_ref() {\n+                                    \"clippy\" => $tool_name == \"clippy-driver\",\n+                                    x => $tool_name == x,\n+                            })\n+                        }),\n+                )\n             }\n \n             fn make_run(run: RunConfig<'_>) {\n@@ -629,31 +629,36 @@ macro_rules! tool_extended {\n                     path: $path,\n                     extra_features: $sel.extra_features,\n                     is_optional_tool: true,\n-                    source_type: SourceType::Submodule,\n+                    source_type: if false $(|| $in_tree)* {\n+                        SourceType::InTree\n+                    } else {\n+                        SourceType::Submodule\n+                    },\n                 })\n             }\n         }\n         )+\n     }\n }\n \n+// Note: tools need to be also added to `Builder::get_step_descriptions` in `builder.rs`\n+// to make `./x.py build <tool>` work.\n tool_extended!((self, builder),\n-    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n-    Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n-    Rls, rls, \"src/tools/rls\", \"rls\", {\n-        let clippy = builder.ensure(Clippy {\n+    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, {};\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, in_tree=true, {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true, in_tree=true, {};\n+    Miri, miri, \"src/tools/miri\", \"miri\", stable=false, {};\n+    CargoMiri, miri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=false, {};\n+    Rls, rls, \"src/tools/rls\", \"rls\", stable=true, {\n+        builder.ensure(Clippy {\n             compiler: self.compiler,\n             target: self.target,\n             extra_features: Vec::new(),\n         });\n-        if clippy.is_some() {\n-            self.extra_features.push(\"clippy\".to_owned());\n-        }\n+        self.extra_features.push(\"clippy\".to_owned());\n     };\n-    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n+    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, {};\n+    RustAnalyzer, rust_analyzer, \"src/tools/rust-analyzer/crates/rust-analyzer\", \"rust-analyzer\", stable=false, {};\n );\n \n impl<'a> Builder<'a> {"}, {"sha": "8740393288c48021800631de542eec2b15064587", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -78,7 +78,6 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n     (\"edition-guide\", \"src/doc/edition-guide\"),\n     (\"rls\", \"src/tools/rls\"),\n     (\"rustfmt\", \"src/tools/rustfmt\"),\n-    (\"clippy-driver\", \"src/tools/clippy\"),\n ];\n \n // These tools are permitted to not build on the beta/stable channels.\n@@ -89,16 +88,16 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n static NIGHTLY_TOOLS: &[(&str, &str)] = &[\n     (\"miri\", \"src/tools/miri\"),\n     (\"embedded-book\", \"src/doc/embedded-book\"),\n-    (\"rustc-dev-guide\", \"src/doc/rustc-dev-guide\"),\n+    // (\"rustc-dev-guide\", \"src/doc/rustc-dev-guide\"),\n ];\n \n fn print_error(tool: &str, submodule: &str) {\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"We detected that this PR updated '{}', but its tests failed.\", tool);\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do intend to update '{}', please check the error messages above and\", tool);\n     eprintln!(\"commit another update.\");\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n     eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n     eprintln!(\"proper steps.\");\n@@ -273,6 +272,18 @@ impl Builder<'_> {\n     /// `rust.save-toolstates` in `config.toml`. If unspecified, nothing will be\n     /// done. The file is updated immediately after this function completes.\n     pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n+        // If we're in a dry run setting we don't want to save toolstates as\n+        // that means if we e.g. panic down the line it'll look like we tested\n+        // everything (but we actually haven't).\n+        if self.config.dry_run {\n+            return;\n+        }\n+        // Toolstate isn't tracked for clippy, but since most tools do, we avoid\n+        // checking in all the places we could save toolstate and just do so\n+        // here.\n+        if tool == \"clippy-driver\" {\n+            return;\n+        }\n         if let Some(ref path) = self.config.save_toolstates {\n             if let Some(parent) = path.parent() {\n                 // Ensure the parent directory always exists"}, {"sha": "3de5a19f851645e2c2e1468c9296cf38f3b26b46", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -142,20 +142,16 @@ jobs:\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n-      # MSVC aux tests\n-      x86_64-msvc-aux:\n-        RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n       x86_64-msvc-cargo:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n         VCVARS_BAT: vcvars64.bat\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       # MSVC tools tests\n       x86_64-msvc-tools:\n-        SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py\n+        SCRIPT: src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh x.py\n         INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n \n       # 32/64-bit MinGW builds."}, {"sha": "34fc4d76fa207d7cc572ef02c24ffcda40001993", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -66,10 +66,6 @@ steps:\n   displayName: Install wix\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/install-innosetup.sh\n-  displayName: Install InnoSetup\n-  condition: and(succeeded(), not(variables.SKIP_JOB))\n-\n - bash: src/ci/scripts/symlink-build-dir.sh\n   displayName: Ensure the build happens on a partition with enough space\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n@@ -82,10 +78,6 @@ steps:\n   displayName: Install msys2\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/install-msys2-packages.sh\n-  displayName: Install msys2 packages\n-  condition: and(succeeded(), not(variables.SKIP_JOB))\n-\n - bash: src/ci/scripts/install-mingw.sh\n   displayName: Install MinGW\n   condition: and(succeeded(), not(variables.SKIP_JOB))"}, {"sha": "818306a00922986ab4fe3c3f8ceb079b574a3acd", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -26,8 +26,6 @@ jobs:\n   strategy:\n     matrix:\n       dist-x86_64-linux: {}\n-      dist-x86_64-linux-alt:\n-        IMAGE: dist-x86_64-linux\n \n # The macOS and Windows builds here are currently disabled due to them not being\n # overly necessary on `try` builds. We also don't actually have anything that"}, {"sha": "7e79cc88513695f137a4936e9d6390fc15e17360", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -25,9 +25,11 @@ before running your command.\n \n ## Filesystem layout\n \n-- Each directory, excluding `scripts` and `disabled`, corresponds to a docker image\n-- `scripts` contains files shared by docker images\n-- `disabled` contains images that are not built on CI\n+- Each host architecture has its own `host-{arch}` directory, and those\n+  directories contain a subdirectory for each Docker image (plus the `disabled`\n+  subdirectory).\n+- `host-{arch}/disabled` contains images that are not built on CI.\n+- `scripts` contains files shared by multiple Docker images.\n \n ## Docker Toolbox on Windows\n "}, {"sha": "77514848167067b2187f680130f2584d9278b13a", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,40 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/android-base-apt-get.sh /scripts/\n-RUN sh /scripts/android-base-apt-get.sh\n-\n-COPY scripts/android-ndk.sh /scripts/\n-RUN . /scripts/android-ndk.sh && \\\n-    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm 14\n-\n-RUN dpkg --add-architecture i386 && \\\n-    apt-get update && \\\n-    apt-get install -y --no-install-recommends \\\n-  libgl1-mesa-glx \\\n-  libpulse0 \\\n-  libstdc++6:i386 \\\n-  openjdk-9-jre-headless \\\n-  tzdata \\\n-  wget \\\n-  python3\n-\n-COPY scripts/android-sdk.sh /scripts/\n-COPY scripts/android-sdk-manager.py /scripts/\n-COPY arm-android/android-sdk.lock /android/sdk/android-sdk.lock\n-RUN /scripts/android-sdk.sh\n-\n-ENV PATH=$PATH:/android/sdk/emulator\n-ENV PATH=$PATH:/android/sdk/tools\n-ENV PATH=$PATH:/android/sdk/platform-tools\n-\n-ENV TARGETS=arm-linux-androideabi\n-\n-ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n-\n-ENV SCRIPT python3 ../x.py test --target $TARGETS\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-COPY scripts/android-start-emulator.sh /scripts/\n-ENTRYPOINT [\"/scripts/android-start-emulator.sh\"]"}, {"sha": "d1bc70689e1e7bb97ce2c99f531d37f4f11f8985", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,83 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n-      bc \\\n-      bzip2 \\\n-      ca-certificates \\\n-      cmake \\\n-      cpio \\\n-      curl \\\n-      file \\\n-      g++ \\\n-      gcc-arm-linux-gnueabihf \\\n-      git \\\n-      libc6-dev \\\n-      libc6-dev-armhf-cross \\\n-      make \\\n-      python3 \\\n-      qemu-system-arm \\\n-      xz-utils\n-\n-ENV ARCH=arm \\\n-    CROSS_COMPILE=arm-linux-gnueabihf-\n-\n-WORKDIR /build\n-\n-# Compile the kernel that we're going to run and be emulating with. This is\n-# basically just done to be compatible with the QEMU target that we're going\n-# to be using when running tests. If any other kernel works or if any\n-# other QEMU target works with some other stock kernel, we can use that too!\n-#\n-# The `vexpress_config` config file was a previously generated config file for\n-# the kernel. This file was generated by running `make vexpress_defconfig`\n-# followed by `make menuconfig` and then enabling the IPv6 protocol page.\n-COPY armhf-gnu/vexpress_config /build/.config\n-RUN curl https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.42.tar.xz | \\\n-      tar xJf - && \\\n-      cd /build/linux-4.4.42 && \\\n-      cp /build/.config . && \\\n-      make -j$(nproc) all && \\\n-      cp arch/arm/boot/zImage /tmp && \\\n-      cd /build &&  \\\n-      rm -rf linux-4.4.42\n-\n-# Compile an instance of busybox as this provides a lightweight system and init\n-# binary which we will boot into. Only trick here is configuring busybox to\n-# build static binaries.\n-RUN curl https://www.busybox.net/downloads/busybox-1.21.1.tar.bz2 | tar xjf - && \\\n-      cd busybox-1.21.1 && \\\n-      make defconfig && \\\n-      sed -i 's/.*CONFIG_STATIC.*/CONFIG_STATIC=y/' .config && \\\n-      make -j$(nproc) && \\\n-      make install && \\\n-      mv _install /tmp/rootfs && \\\n-      cd /build && \\\n-      rm -rf busybox-1.12.1\n-\n-# Download the ubuntu rootfs, which we'll use as a chroot for all our tests.\n-WORKDIR /tmp\n-RUN mkdir rootfs/ubuntu\n-RUN curl http://cdimage.ubuntu.com/ubuntu-base/releases/16.04/release/ubuntu-base-16.04-core-armhf.tar.gz | \\\n-      tar xzf - -C rootfs/ubuntu && \\\n-      cd rootfs && mkdir proc sys dev etc etc/init.d\n-\n-# Copy over our init script, which starts up our test server and also a few\n-# other misc tasks.\n-COPY scripts/qemu-bare-bones-rcS rootfs/etc/init.d/rcS\n-RUN chmod +x rootfs/etc/init.d/rcS\n-\n-# Helper to quickly fill the entropy pool in the kernel.\n-COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n-RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n-\n-# TODO: What is this?!\n-# Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n-RUN curl -O https://ci-mirrors.rust-lang.org/rustc/vexpress-v2p-ca15-tc1.dtb\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n-ENV SCRIPT python3 ../x.py test --target arm-unknown-linux-gnueabihf\n-\n-ENV NO_CHANGE_USER=1"}, {"sha": "9dd0435ac4f0c9727988c71d401d9303ac2ae456", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,79 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n-      bc \\\n-      bzip2 \\\n-      ca-certificates \\\n-      cmake \\\n-      cpio \\\n-      curl \\\n-      file \\\n-      g++ \\\n-      gcc-aarch64-linux-gnu \\\n-      git \\\n-      libc6-dev \\\n-      libc6-dev-arm64-cross \\\n-      make \\\n-      python3 \\\n-      qemu-system-aarch64 \\\n-      xz-utils\n-\n-ENV ARCH=arm64 \\\n-    CROSS_COMPILE=aarch64-linux-gnu-\n-\n-WORKDIR /build\n-\n-# Compile the kernel that we're going to run and be emulating with. This is\n-# basically just done to be compatible with the QEMU target that we're going\n-# to be using when running tests. If any other kernel works or if any\n-# other QEMU target works with some other stock kernel, we can use that too!\n-#\n-# The `config` config file was a previously generated config file for\n-# the kernel. This file was generated by running `make defconfig`\n-# followed by `make menuconfig` and then enabling the IPv6 protocol page.\n-COPY aarch64-gnu/config /build/.config\n-RUN curl https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.42.tar.xz | \\\n-      tar xJf - && \\\n-      cd /build/linux-4.4.42 && \\\n-      cp /build/.config . && \\\n-      make -j$(nproc) all && \\\n-      cp arch/arm64/boot/Image /tmp && \\\n-      cd /build &&  \\\n-      rm -rf linux-4.4.42\n-\n-# Compile an instance of busybox as this provides a lightweight system and init\n-# binary which we will boot into. Only trick here is configuring busybox to\n-# build static binaries.\n-RUN curl https://www.busybox.net/downloads/busybox-1.21.1.tar.bz2 | tar xjf - && \\\n-      cd busybox-1.21.1 && \\\n-      make defconfig && \\\n-      sed -i 's/.*CONFIG_STATIC.*/CONFIG_STATIC=y/' .config && \\\n-      make -j$(nproc) && \\\n-      make install && \\\n-      mv _install /tmp/rootfs && \\\n-      cd /build && \\\n-      rm -rf busybox-1.12.1\n-\n-# Download the ubuntu rootfs, which we'll use as a chroot for all our tests.\n-WORKDIR /tmp\n-RUN mkdir rootfs/ubuntu\n-RUN curl http://cdimage.ubuntu.com/ubuntu-base/releases/16.04/release/ubuntu-base-16.04-core-arm64.tar.gz | \\\n-      tar xzf - -C rootfs/ubuntu && \\\n-      cd rootfs && mkdir proc sys dev etc etc/init.d\n-\n-# Copy over our init script, which starts up our test server and also a few\n-# other misc tasks.\n-COPY scripts/qemu-bare-bones-rcS rootfs/etc/init.d/rcS\n-RUN chmod +x rootfs/etc/init.d/rcS\n-\n-# Helper to quickly fill the entropy pool in the kernel.\n-COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n-RUN aarch64-linux-gnu-gcc addentropy.c -o rootfs/addentropy -static\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-      --qemu-aarch64-rootfs=/tmp/rootfs\n-ENV SCRIPT python3 ../x.py test --target aarch64-unknown-linux-gnu\n-ENV NO_CHANGE_USER=1"}, {"sha": "a1792532392f43e7012d0d45dfb66750ddb08741", "filename": "src/ci/docker/disabled/aarch64-gnu/config", "status": "removed", "additions": 0, "deletions": 3100, "changes": 3100, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2Fconfig?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db"}, {"sha": "5b7196c573c8b278cb58c9284c548d64b4fb25bb", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,36 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  bzip2 \\\n-  xz-utils \\\n-  wget \\\n-  libssl-dev \\\n-  bsdtar \\\n-  pkg-config\n-\n-\n-COPY dist-x86_64-dragonfly/build-toolchain.sh /tmp/\n-COPY dist-x86_64-dragonfly/patch-toolchain /tmp/\n-RUN /tmp/build-toolchain.sh /tmp/patch-toolchain\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-ar \\\n-    CC_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-gcc \\\n-    CXX_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-g++\n-\n-ENV HOSTS=x86_64-unknown-dragonfly\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5b65335bfe4e4f635ba58febbe0d6274a1c9ed27", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/Dockerfile", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,49 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  autoconf \\\n-  automake \\\n-  bison \\\n-  bzip2 \\\n-  ca-certificates \\\n-  cmake \\\n-  curl \\\n-  file \\\n-  flex \\\n-  g++ \\\n-  gawk \\\n-  git \\\n-  libcurl4-openssl-dev \\\n-  libssl-dev \\\n-  make \\\n-  nasm \\\n-  pkg-config \\\n-  python3 \\\n-  sudo \\\n-  texinfo \\\n-  wget \\\n-  xz-utils \\\n-  zlib1g-dev\n-\n-COPY dist-x86_64-haiku/llvm-config.sh /bin/llvm-config-haiku\n-\n-ENV ARCH=x86_64\n-\n-WORKDIR /tmp\n-COPY dist-x86_64-haiku/build-toolchain.sh /tmp/\n-RUN /tmp/build-toolchain.sh $ARCH\n-\n-COPY dist-x86_64-haiku/fetch-packages.sh /tmp/\n-RUN /tmp/fetch-packages.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV HOST=x86_64-unknown-haiku\n-ENV TARGET=target.$HOST\n-\n-ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n-  --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n-  --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n-  --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n-ENV SCRIPT python3 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "7b53e73d700ba4cc418efb6b0356a59e70042c6f", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,22 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-WORKDIR /tmp\n-COPY dist-various-1/install-x86_64-redox.sh /scripts/\n-RUN sh /scripts/install-x86_64-redox.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_x86_64_unknown_redox=x86_64-unknown-redox-ar \\\n-    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n-    CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended\n-ENV SCRIPT python3 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "37e81dffc0697c5e6e32e7073c3b2bfb170fb5aa", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,39 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-aarch64-linux/aarch64-linux-gnu.config dist-aarch64-linux/build-toolchains.sh /tmp/\n-RUN ./build-toolchains.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/aarch64-unknown-linux-gnueabi/bin\n-\n-ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n-    AR_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-ar \\\n-    CXX_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-g++\n-\n-ENV HOSTS=aarch64-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-      --enable-extended \\\n-      --enable-profiler \\\n-      --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "78f2734ed40ee0585a1024d460308a97ae523490", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,31 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-COPY scripts/crosstool-ng-1.24.sh /scripts/\n-RUN sh /scripts/crosstool-ng-1.24.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-arm-linux/arm-linux-gnueabi.config dist-arm-linux/build-toolchains.sh /tmp/\n-RUN ./build-toolchains.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabi/bin\n-\n-ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n-    AR_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-ar \\\n-    CXX_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-g++\n-\n-ENV HOSTS=arm-unknown-linux-gnueabi\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "175dadfd303d751c6b87f08fe4ea499bffefbee3", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,31 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-COPY scripts/crosstool-ng-1.24.sh /scripts/\n-RUN sh /scripts/crosstool-ng-1.24.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-armhf-linux/arm-linux-gnueabihf.config dist-armhf-linux/build-toolchains.sh /tmp/\n-RUN ./build-toolchains.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabihf/bin\n-\n-ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n-    AR_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-ar \\\n-    CXX_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-g++\n-\n-ENV HOSTS=arm-unknown-linux-gnueabihf\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "faa2ce106068bfcd6dc57c2ce1d1352899542117", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,31 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-COPY scripts/crosstool-ng-1.24.sh /scripts/\n-RUN sh /scripts/crosstool-ng-1.24.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-armv7-linux/build-toolchains.sh dist-armv7-linux/armv7-linux-gnueabihf.config /tmp/\n-RUN ./build-toolchains.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/armv7-unknown-linux-gnueabihf/bin\n-\n-ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n-    AR_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-ar \\\n-    CXX_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-g++\n-\n-ENV HOSTS=armv7-unknown-linux-gnueabihf\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ad675830b7799ce8b27fe8115fe28f0dbeca5dd4", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,120 +0,0 @@\n-FROM centos:5\n-\n-WORKDIR /build\n-\n-# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n-# to http://vault.centos.org/\n-RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n-RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n-RUN sed -i 's|#\\(baseurl.*\\)mirror.centos.org/centos/$releasever|\\1vault.centos.org/5.11|' /etc/yum.repos.d/*.repo\n-\n-RUN yum upgrade -y && yum install -y \\\n-      curl \\\n-      bzip2 \\\n-      gcc \\\n-      gcc-c++ \\\n-      make \\\n-      glibc-devel \\\n-      perl \\\n-      zlib-devel \\\n-      file \\\n-      xz \\\n-      which \\\n-      pkgconfig \\\n-      wget \\\n-      autoconf \\\n-      gettext\n-\n-ENV PATH=/rustroot/bin:$PATH\n-ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n-ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n-WORKDIR /tmp\n-COPY dist-x86_64-linux/shared.sh /tmp/\n-\n-# We need a build of openssl which supports SNI to download artifacts from\n-# static.rust-lang.org. This'll be used to link into libcurl below (and used\n-# later as well), so build a copy of OpenSSL with dynamic libraries into our\n-# generic root.\n-COPY dist-x86_64-linux/build-openssl.sh /tmp/\n-RUN ./build-openssl.sh\n-\n-# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n-# some https urls we have, so install a new version of libcurl + curl which is\n-# using the openssl we just built previously.\n-#\n-# Note that we also disable a bunch of optional features of curl that we don't\n-# really need.\n-COPY dist-x86_64-linux/build-curl.sh /tmp/\n-RUN ./build-curl.sh\n-\n-# binutils < 2.22 has a bug where the 32-bit executables it generates\n-# immediately segfault in Rust, so we need to install our own binutils.\n-#\n-# See https://github.com/rust-lang/rust/issues/20440 for more info\n-COPY dist-x86_64-linux/build-binutils.sh /tmp/\n-RUN ./build-binutils.sh\n-\n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY dist-x86_64-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n-# Need a newer version of gcc than centos has to compile LLVM nowadays\n-COPY dist-x86_64-linux/build-gcc.sh /tmp/\n-RUN ./build-gcc.sh\n-\n-# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n-COPY dist-x86_64-linux/build-python.sh /tmp/\n-RUN ./build-python.sh\n-\n-# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n-# clang/clang++ compilers.\n-COPY dist-x86_64-linux/build-clang.sh dist-x86_64-linux/llvm-project-centos.patch /tmp/\n-RUN ./build-clang.sh\n-ENV CC=clang CXX=clang++\n-\n-# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n-# cloning, so download and build it here.\n-COPY dist-x86_64-linux/build-git.sh /tmp/\n-RUN ./build-git.sh\n-\n-# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n-# with so we install newer ones here\n-COPY dist-x86_64-linux/build-headers.sh /tmp/\n-RUN ./build-headers.sh\n-\n-# OpenSSL requires a more recent version of perl\n-# with so we install newer ones here\n-COPY dist-x86_64-linux/build-perl.sh /tmp/\n-RUN ./build-perl.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV HOSTS=i686-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-      --enable-full-tools \\\n-      --enable-sanitizers \\\n-      --enable-profiler \\\n-      --set target.i686-unknown-linux-gnu.linker=clang \\\n-      --build=i686-unknown-linux-gnu \\\n-      --set rust.jemalloc\n-ENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\n-ENV CARGO_TARGET_I686_UNKNOWN_LINUX_GNU_LINKER=clang\n-\n-# This was added when we switched from gcc to clang. It's not clear why this is\n-# needed unfortunately, but without this the stage1 bootstrap segfaults\n-# somewhere inside of a build script. The build ends up just hanging instead of\n-# actually killing the process that segfaulted, but if the process is run\n-# manually in a debugger the segfault is immediately seen as well as the\n-# misaligned stack access.\n-#\n-# Added in #50200 there's some more logs there\n-ENV CFLAGS -mstackrealign\n-\n-# When we build cargo in this container, we don't want it to use the system\n-# libcurl, instead it should compile its own.\n-ENV LIBCURL_NO_PKG_CONFIG 1\n-\n-ENV DIST_REQUIRE_ALL_TOOLS 1"}, {"sha": "b8792b0c7fa92711f9fe339b0293dda51751860c", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,38 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-powerpc-linux/patches/ /tmp/patches/\n-COPY dist-powerpc-linux/powerpc-linux-gnu.config dist-powerpc-linux/build-powerpc-toolchain.sh /tmp/\n-RUN ./build-powerpc-toolchain.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/powerpc-unknown-linux-gnu/bin\n-\n-ENV \\\n-    CC_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-gcc \\\n-    AR_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-ar \\\n-    CXX_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-g++\n-\n-ENV HOSTS=powerpc-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a790a143ac5e73918269a35c5e147a7aee13d765", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,39 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-\n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-powerpc64-linux/patches/ /tmp/patches/\n-COPY dist-powerpc64-linux/shared.sh dist-powerpc64-linux/powerpc64-linux-gnu.config dist-powerpc64-linux/build-powerpc64-toolchain.sh /tmp/\n-RUN ./build-powerpc64-toolchain.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/powerpc64-unknown-linux-gnu/bin\n-\n-ENV \\\n-    AR_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-ar \\\n-    CC_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-gcc \\\n-    CXX_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-g++\n-\n-ENV HOSTS=powerpc64-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5c17bc321c1712d8eb4b5cc7baedb3dd4503c851", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,36 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-USER root\n-\n-RUN apt-get install -y --no-install-recommends rpm2cpio cpio\n-COPY dist-powerpc64le-linux/shared.sh dist-powerpc64le-linux/build-powerpc64le-toolchain.sh /tmp/\n-RUN ./build-powerpc64le-toolchain.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-ar \\\n-    CC_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-gcc \\\n-    CXX_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-g++\n-\n-ENV HOSTS=powerpc64le-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "76d29a471c3967e14451c71495299bb3857ff65f", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,38 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n-COPY dist-s390x-linux/patches/ /tmp/patches/\n-COPY dist-s390x-linux/s390x-linux-gnu.config dist-s390x-linux/build-s390x-toolchain.sh /tmp/\n-RUN ./build-s390x-toolchain.sh\n-\n-USER root\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/s390x-ibm-linux-gnu/bin\n-\n-ENV \\\n-    CC_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-gcc \\\n-    AR_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-ar \\\n-    CXX_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-g++\n-\n-ENV HOSTS=s390x-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "35b598e20f09932d3fc683f8406e90b8bdf60396", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,216 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  automake \\\n-  bison \\\n-  bzip2 \\\n-  flex \\\n-  help2man \\\n-  libtool-bin \\\n-  texinfo \\\n-  unzip \\\n-  wget \\\n-  xz-utils \\\n-  libncurses-dev \\\n-  gawk \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  xz-utils \\\n-  zlib1g-dev \\\n-  g++-arm-linux-gnueabi \\\n-  g++-arm-linux-gnueabihf \\\n-  g++-aarch64-linux-gnu \\\n-  g++-mips64-linux-gnuabi64 \\\n-  g++-mips64el-linux-gnuabi64 \\\n-  gcc-sparc64-linux-gnu \\\n-  libc6-dev-sparc64-cross \\\n-  bzip2 \\\n-  patch \\\n-  libssl-dev \\\n-  pkg-config \\\n-  libnewlib-arm-none-eabi \\\n-  qemu-system-arm \\\n-# software-properties-common for the add-apt-repository command\n-  software-properties-common\n-\n-WORKDIR /build\n-\n-# Use the team-gcc-arm-embedded PPA for a newer version of Arm GCC\n-RUN add-apt-repository ppa:team-gcc-arm-embedded/ppa && \\\n-    apt-get update && \\\n-    apt-get install -y --no-install-recommends gcc-arm-embedded\n-\n-COPY scripts/rustbuild-setup.sh dist-various-1/build-riscv-toolchain.sh dist-various-1/riscv64-unknown-linux-gnu.config dist-various-1/crosstool-ng.sh /build/\n-RUN ./crosstool-ng.sh\n-\n-# Crosstool-ng will refuse to build as root\n-RUN sh ./rustbuild-setup.sh\n-USER rustbuild\n-\n-RUN ./build-riscv-toolchain.sh\n-\n-USER root\n-ENV PATH=/x-tools/riscv64-unknown-linux-gnu/bin:$PATH\n-\n-COPY dist-various-1/build-rumprun.sh /build\n-RUN ./build-rumprun.sh\n-\n-COPY dist-various-1/install-x86_64-redox.sh /build\n-RUN ./install-x86_64-redox.sh\n-\n-COPY dist-various-1/install-mips-musl.sh /build\n-RUN ./install-mips-musl.sh\n-\n-COPY dist-various-1/install-mipsel-musl.sh /build\n-RUN ./install-mipsel-musl.sh\n-\n-COPY dist-various-1/install-aarch64-none-elf.sh /build\n-RUN ./install-aarch64-none-elf.sh\n-\n-# Suppress some warnings in the openwrt toolchains we downloaded\n-ENV STAGING_DIR=/tmp\n-\n-COPY scripts/musl.sh /build\n-RUN env \\\n-    CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n-    CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n-    bash musl.sh armv5te && \\\n-    env \\\n-    CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv6 -marm\" \\\n-    CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv6 -marm\" \\\n-    bash musl.sh arm && \\\n-    env \\\n-    CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n-    CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n-    bash musl.sh armhf && \\\n-    env \\\n-    CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv7-a\" \\\n-    CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv7-a\" \\\n-    bash musl.sh armv7hf && \\\n-    env \\\n-    CC=aarch64-linux-gnu-gcc \\\n-    CXX=aarch64-linux-gnu-g++ \\\n-    bash musl.sh aarch64 && \\\n-    env \\\n-    CC=mips-openwrt-linux-gcc \\\n-    CXX=mips-openwrt-linux-g++ \\\n-    bash musl.sh mips && \\\n-    env \\\n-    CC=mipsel-openwrt-linux-gcc \\\n-    CXX=mipsel-openwrt-linux-g++ \\\n-    bash musl.sh mipsel && \\\n-    env \\\n-    CC=mips64-linux-gnuabi64-gcc \\\n-    CXX=mips64-linux-gnuabi64-g++ \\\n-    bash musl.sh mips64 && \\\n-    env \\\n-    CC=mips64el-linux-gnuabi64-gcc \\\n-    CXX=mips64el-linux-gnuabi64-g++ \\\n-    bash musl.sh mips64el && \\\n-    rm -rf /build/*\n-\n-# FIXME(mozilla/sccache#235) this shouldn't be necessary but is currently\n-# necessary to disambiguate the mips compiler with the mipsel compiler. We want\n-# to give these two wrapper scripts (currently identical ones) different hashes\n-# to ensure that sccache understands that they're different compilers.\n-RUN \\\n-  echo \"# a\" >> /usr/local/mips-linux-musl/bin/mips-openwrt-linux-musl-wrapper.sh && \\\n-  echo \"# b\" >> /usr/local/mipsel-linux-musl/bin/mipsel-openwrt-linux-musl-wrapper.sh\n-\n-ENV RUN_MAKE_TARGETS=thumbv6m-none-eabi\n-ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7m-none-eabi\n-ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabi\n-ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabihf\n-\n-ENV TARGETS=asmjs-unknown-emscripten\n-ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n-ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n-ENV TARGETS=$TARGETS,mips-unknown-linux-musl\n-ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n-ENV TARGETS=$TARGETS,mips64-unknown-linux-muslabi64\n-ENV TARGETS=$TARGETS,mips64el-unknown-linux-muslabi64\n-ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n-ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n-ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n-ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n-ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n-ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n-ENV TARGETS=$TARGETS,aarch64-unknown-none\n-ENV TARGETS=$TARGETS,aarch64-unknown-none-softfloat\n-ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-ENV TARGETS=$TARGETS,x86_64-unknown-redox\n-ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n-ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n-ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n-ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n-ENV TARGETS=$TARGETS,thumbv8m.base-none-eabi\n-ENV TARGETS=$TARGETS,thumbv8m.main-none-eabi\n-ENV TARGETS=$TARGETS,thumbv8m.main-none-eabihf\n-ENV TARGETS=$TARGETS,riscv32i-unknown-none-elf\n-ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n-ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n-ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n-ENV TARGETS=$TARGETS,riscv64gc-unknown-none-elf\n-ENV TARGETS=$TARGETS,riscv64gc-unknown-linux-gnu\n-ENV TARGETS=$TARGETS,armebv7r-none-eabi\n-ENV TARGETS=$TARGETS,armebv7r-none-eabihf\n-ENV TARGETS=$TARGETS,armv7r-none-eabi\n-ENV TARGETS=$TARGETS,armv7r-none-eabihf\n-ENV TARGETS=$TARGETS,thumbv7neon-unknown-linux-gnueabihf\n-ENV TARGETS=$TARGETS,armv7a-none-eabi\n-\n-# riscv targets currently do not need a C compiler, as compiler_builtins\n-# doesn't currently have it enabled, and the riscv gcc compiler is not\n-# installed.\n-ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n-    CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n-    CC_mips64el_unknown_linux_muslabi64=mips64el-linux-gnuabi64-gcc \\\n-    CC_mips64_unknown_linux_muslabi64=mips64-linux-gnuabi64-gcc \\\n-    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n-    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n-    CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n-    AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n-    CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++ \\\n-    CC_armv7a_none_eabi=arm-none-eabi-gcc \\\n-    CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n-    CFLAGS_armv7a_none_eabi=-march=armv7-a \\\n-    CFLAGS_armv7a_none_eabihf=-march=armv7-a+vfpv3 \\\n-    CC_aarch64_unknown_none_softfloat=aarch64-none-elf-gcc \\\n-    CFLAGS_aarch64_unknown_none_softfloat=-mstrict-align -march=armv8-a+nofp+nosimd \\\n-    CC_aarch64_unknown_none=aarch64-none-elf-gcc \\\n-    CFLAGS_aarch64_unknown_none=-mstrict-align -march=armv8-a+fp+simd \\\n-    CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n-    AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n-    CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\\n-    CC_riscv32i_unknown_none_elf=false \\\n-    CC_riscv32imc_unknown_none_elf=false \\\n-    CC_riscv32imac_unknown_none_elf=false \\\n-    CC_riscv64imac_unknown_none_elf=false \\\n-    CC_riscv64gc_unknown_none_elf=false\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-      --musl-root-armv5te=/musl-armv5te \\\n-      --musl-root-arm=/musl-arm \\\n-      --musl-root-armhf=/musl-armhf \\\n-      --musl-root-armv7hf=/musl-armv7hf \\\n-      --musl-root-aarch64=/musl-aarch64 \\\n-      --musl-root-mips=/musl-mips \\\n-      --musl-root-mipsel=/musl-mipsel \\\n-      --musl-root-mips64=/musl-mips64 \\\n-      --musl-root-mips64el=/musl-mips64el \\\n-      --disable-docs\n-\n-ENV SCRIPT \\\n-      python3 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n-      python3 ../x.py dist --target $TARGETS\n-\n-# sccache\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh"}, {"sha": "5864b5ffab28601bb9e96cb4ab8a24a1345e1a46", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,113 +0,0 @@\n-FROM ubuntu:18.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-# Enable source repositories, which are disabled by default on Ubuntu >= 18.04\n-RUN sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list\n-\n-RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n-  build-essential \\\n-# gcc-multilib can not be installed together with gcc-arm-linux-gnueabi\n-  gcc-7-multilib \\\n-  libedit-dev \\\n-  libgmp-dev \\\n-  libisl-dev \\\n-  libmpc-dev \\\n-  libmpfr-dev \\\n-  ninja-build \\\n-  nodejs \\\n-  python3-dev \\\n-  software-properties-common \\\n-  unzip \\\n-  # Needed for apt-key to work:\n-  dirmngr \\\n-  gpg-agent \\\n-  g++-7-arm-linux-gnueabi\n-\n-RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n-RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n-\n-WORKDIR /build\n-COPY scripts/musl.sh /build\n-RUN env \\\n-    CC=arm-linux-gnueabi-gcc-7 CFLAGS=\"-march=armv7-a\" \\\n-    CXX=arm-linux-gnueabi-g++-7 CXXFLAGS=\"-march=armv7-a\" \\\n-    bash musl.sh armv7 && \\\n-    rm -rf /build/*\n-\n-WORKDIR /tmp\n-COPY dist-various-2/shared.sh /tmp/\n-COPY dist-various-2/build-cloudabi-toolchain.sh /tmp/\n-RUN /tmp/build-cloudabi-toolchain.sh x86_64-unknown-cloudabi\n-COPY dist-various-2/build-fuchsia-toolchain.sh /tmp/\n-RUN /tmp/build-fuchsia-toolchain.sh\n-COPY dist-various-2/build-solaris-toolchain.sh /tmp/\n-RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n-RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n-COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n-# We pass the commit id of the port of LLVM's libunwind to the build script.\n-# Any update to the commit id here, should cause the container image to be re-built from this point on.\n-RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"5125c169b30837208a842f85f7ae44a83533bd0e\"\n-\n-COPY dist-various-2/build-wasi-toolchain.sh /tmp/\n-RUN /tmp/build-wasi-toolchain.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n-    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n-    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n-    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n-    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n-    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n-    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n-    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n-    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n-    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n-    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n-    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n-    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n-    CC=gcc-7 \\\n-    CXX=g++-7\n-\n-ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n-ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n--C link-arg=--sysroot=/usr/local/x86_64-fuchsia \\\n--C link-arg=-L/usr/local/x86_64-fuchsia/lib \\\n--C link-arg=-L/usr/local/lib/x86_64-fuchsia/lib\n-ENV CARGO_TARGET_AARCH64_FUCHSIA_AR /usr/local/bin/llvm-ar\n-ENV CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS \\\n--C link-arg=--sysroot=/usr/local/aarch64-fuchsia \\\n--C link-arg=-L/usr/local/aarch64-fuchsia/lib \\\n--C link-arg=-L/usr/local/lib/aarch64-fuchsia/lib\n-\n-ENV TARGETS=x86_64-fuchsia\n-ENV TARGETS=$TARGETS,aarch64-fuchsia\n-ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n-ENV TARGETS=$TARGETS,wasm32-wasi\n-ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n-ENV TARGETS=$TARGETS,x86_64-sun-solaris\n-ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n-ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n-ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx\n-ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n-ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n-ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n-\n-ENV X86_FORTANIX_SGX_LIBS=\"/x86_64-fortanix-unknown-sgx/lib/\"\n-\n-# As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n-# we need asm in the search path for gcc-7 (for gnux32) but not in the search path of the\n-# cross compilers.\n-# Luckily one of the folders is /usr/local/include so symlink /usr/include/asm-generic there\n-RUN ln -s /usr/include/asm-generic /usr/local/include/asm\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n-  --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n-  --musl-root-armv7=/musl-armv7\n-\n-ENV SCRIPT python3 ../x.py dist --target $TARGETS"}, {"sha": "725ec341b94978041256ef753fdd2a77c080fe14", "filename": "src/ci/docker/dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,52 +0,0 @@\n-#!/bin/bash\n-\n-set -eu\n-source shared.sh\n-\n-if [ -z \"$1\" ]; then\n-    echo \"Usage: ${0} <commit_id>\"\n-    exit -1\n-fi\n-\n-target=\"x86_64-fortanix-unknown-sgx\"\n-url=\"https://github.com/fortanix/llvm-project/archive/${1}.tar.gz\"\n-repo_name=\"llvm-project\"\n-\n-install_prereq() {\n-    apt-get update\n-    apt-get install -y --no-install-recommends \\\n-            build-essential \\\n-            ca-certificates \\\n-            cmake \\\n-            git\n-}\n-\n-build_unwind() {\n-    set -x\n-    dir_name=\"${target}_temp\"\n-    rm -rf ${dir_name}\n-    mkdir -p ${dir_name}\n-    pushd ${dir_name}\n-\n-    # Clone Fortanix's fork of llvm-project which has a port of libunwind\n-    fetch_github_commit_archive \"$repo_name\" \"$url\"\n-    cd \"${repo_name}/libunwind\"\n-\n-    # Build libunwind\n-    mkdir -p build\n-    cd build\n-    cmake -DCMAKE_BUILD_TYPE=\"RELEASE\" -DRUST_SGX=1 -G \"Unix Makefiles\" \\\n-        -DLLVM_ENABLE_WARNINGS=1 -DLIBUNWIND_ENABLE_WERROR=1 -DLIBUNWIND_ENABLE_PEDANTIC=0 \\\n-        -DLLVM_PATH=../../llvm/ ../\n-    make unwind_static\n-    install -D \"lib/libunwind.a\" \"/${target}/lib/libunwind.a\"\n-\n-    popd\n-    rm -rf ${dir_name}\n-\n-    { set +x; } 2>/dev/null\n-}\n-\n-set -x\n-hide_output install_prereq\n-build_unwind"}, {"sha": "2f2a10a0e90ae58c8c562041c290622c19699695", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,116 +0,0 @@\n-FROM centos:5\n-\n-WORKDIR /build\n-\n-# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n-# to http://vault.centos.org/\n-RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n-RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n-RUN sed -i 's|#\\(baseurl.*\\)mirror.centos.org/centos/$releasever|\\1vault.centos.org/5.11|' /etc/yum.repos.d/*.repo\n-\n-RUN yum upgrade -y && yum install -y \\\n-      curl \\\n-      bzip2 \\\n-      gcc \\\n-      gcc-c++ \\\n-      make \\\n-      glibc-devel \\\n-      perl \\\n-      zlib-devel \\\n-      file \\\n-      xz \\\n-      which \\\n-      pkgconfig \\\n-      wget \\\n-      autoconf \\\n-      gettext\n-\n-ENV PATH=/rustroot/bin:$PATH\n-ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n-ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n-WORKDIR /tmp\n-COPY dist-x86_64-linux/shared.sh /tmp/\n-\n-# We need a build of openssl which supports SNI to download artifacts from\n-# static.rust-lang.org. This'll be used to link into libcurl below (and used\n-# later as well), so build a copy of OpenSSL with dynamic libraries into our\n-# generic root.\n-COPY dist-x86_64-linux/build-openssl.sh /tmp/\n-RUN ./build-openssl.sh\n-\n-# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n-# some https urls we have, so install a new version of libcurl + curl which is\n-# using the openssl we just built previously.\n-#\n-# Note that we also disable a bunch of optional features of curl that we don't\n-# really need.\n-COPY dist-x86_64-linux/build-curl.sh /tmp/\n-RUN ./build-curl.sh\n-\n-# binutils < 2.22 has a bug where the 32-bit executables it generates\n-# immediately segfault in Rust, so we need to install our own binutils.\n-#\n-# See https://github.com/rust-lang/rust/issues/20440 for more info\n-COPY dist-x86_64-linux/build-binutils.sh /tmp/\n-RUN ./build-binutils.sh\n-\n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY dist-x86_64-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n-# Build a version of gcc capable of building LLVM 6\n-COPY dist-x86_64-linux/build-gcc.sh /tmp/\n-RUN ./build-gcc.sh\n-\n-# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n-COPY dist-x86_64-linux/build-python.sh /tmp/\n-RUN ./build-python.sh\n-\n-# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n-# clang/clang++ compilers.\n-COPY dist-x86_64-linux/build-clang.sh dist-x86_64-linux/llvm-project-centos.patch /tmp/\n-RUN ./build-clang.sh\n-ENV CC=clang CXX=clang++\n-\n-# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n-# cloning, so download and build it here.\n-COPY dist-x86_64-linux/build-git.sh /tmp/\n-RUN ./build-git.sh\n-\n-# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n-# with so we install newer ones here\n-COPY dist-x86_64-linux/build-headers.sh /tmp/\n-RUN ./build-headers.sh\n-\n-# OpenSSL requires a more recent version of perl\n-# with so we install newer ones here\n-COPY dist-x86_64-linux/build-perl.sh /tmp/\n-RUN ./build-perl.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV HOSTS=x86_64-unknown-linux-gnu\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-      --enable-full-tools \\\n-      --enable-sanitizers \\\n-      --enable-profiler \\\n-      --enable-compiler-docs \\\n-      --set target.x86_64-unknown-linux-gnu.linker=clang \\\n-      --set target.x86_64-unknown-linux-gnu.ar=/rustroot/bin/llvm-ar \\\n-      --set target.x86_64-unknown-linux-gnu.ranlib=/rustroot/bin/llvm-ranlib \\\n-      --set llvm.thin-lto=true \\\n-      --set rust.jemalloc\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n-ENV CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_LINKER=clang\n-\n-# This is the only builder which will create source tarballs\n-ENV DIST_SRC 1\n-\n-# When we build cargo in this container, we don't want it to use the system\n-# libcurl, instead it should compile its own.\n-ENV LIBCURL_NO_PKG_CONFIG 1\n-\n-ENV DIST_REQUIRE_ALL_TOOLS 1"}, {"sha": "135bb33cef71728f24cbc1bffc2956ed8e4e4f57", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,22 +0,0 @@\n-FROM ubuntu:16.04\n-\n-COPY scripts/cross-apt-packages.sh /scripts/\n-RUN sh /scripts/cross-apt-packages.sh\n-\n-COPY dist-x86_64-netbsd/build-netbsd-toolchain.sh /tmp/\n-RUN /tmp/build-netbsd-toolchain.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/x-tools/x86_64-unknown-netbsd/bin\n-\n-ENV \\\n-    AR_x86_64_unknown_netbsd=x86_64--netbsd-ar \\\n-    CC_x86_64_unknown_netbsd=x86_64--netbsd-gcc-sysroot \\\n-    CXX_x86_64_unknown_netbsd=x86_64--netbsd-g++-sysroot\n-\n-ENV HOSTS=x86_64-unknown-netbsd\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "114ac832cf504c38c65e7574fbb9719b8998c080", "filename": "src/ci/docker/host-aarch64/aarch64-gnu/Dockerfile", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:20.04\n+\n+RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n+  xz-utils\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+ --build=aarch64-unknown-linux-gnu \\\n+ --enable-sanitizers \\\n+ --enable-profiler \\\n+ --enable-compiler-docs\n+ENV SCRIPT python3 ../x.py test"}, {"sha": "aa9335c473b5b34190ad9140f9892b5e7e57ac00", "filename": "src/ci/docker/host-x86_64/arm-android/Dockerfile", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,40 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/android-base-apt-get.sh /scripts/\n+RUN sh /scripts/android-base-apt-get.sh\n+\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n+    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm 14\n+\n+RUN dpkg --add-architecture i386 && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  libgl1-mesa-glx \\\n+  libpulse0 \\\n+  libstdc++6:i386 \\\n+  openjdk-9-jre-headless \\\n+  tzdata \\\n+  wget \\\n+  python3\n+\n+COPY scripts/android-sdk.sh /scripts/\n+COPY scripts/android-sdk-manager.py /scripts/\n+COPY host-x86_64/arm-android/android-sdk.lock /android/sdk/android-sdk.lock\n+RUN /scripts/android-sdk.sh\n+\n+ENV PATH=$PATH:/android/sdk/emulator\n+ENV PATH=$PATH:/android/sdk/tools\n+ENV PATH=$PATH:/android/sdk/platform-tools\n+\n+ENV TARGETS=arm-linux-androideabi\n+\n+ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n+\n+ENV SCRIPT python3 ../x.py test --target $TARGETS\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+COPY scripts/android-start-emulator.sh /scripts/\n+ENTRYPOINT [\"/scripts/android-start-emulator.sh\"]"}, {"sha": "a1be8a4346b6d87c2e1f5f5367e70b6a912a4285", "filename": "src/ci/docker/host-x86_64/arm-android/android-sdk.lock", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2Fandroid-sdk.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2Fandroid-sdk.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2Fandroid-sdk.lock?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/arm-android/android-sdk.lock"}, {"sha": "71071761f05cdea1e11063ab3b4a73397ab8ee51", "filename": "src/ci/docker/host-x86_64/armhf-gnu/Dockerfile", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,83 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n+      bc \\\n+      bzip2 \\\n+      ca-certificates \\\n+      cmake \\\n+      cpio \\\n+      curl \\\n+      file \\\n+      g++ \\\n+      gcc-arm-linux-gnueabihf \\\n+      git \\\n+      libc6-dev \\\n+      libc6-dev-armhf-cross \\\n+      make \\\n+      python3 \\\n+      qemu-system-arm \\\n+      xz-utils\n+\n+ENV ARCH=arm \\\n+    CROSS_COMPILE=arm-linux-gnueabihf-\n+\n+WORKDIR /build\n+\n+# Compile the kernel that we're going to run and be emulating with. This is\n+# basically just done to be compatible with the QEMU target that we're going\n+# to be using when running tests. If any other kernel works or if any\n+# other QEMU target works with some other stock kernel, we can use that too!\n+#\n+# The `vexpress_config` config file was a previously generated config file for\n+# the kernel. This file was generated by running `make vexpress_defconfig`\n+# followed by `make menuconfig` and then enabling the IPv6 protocol page.\n+COPY host-x86_64/armhf-gnu/vexpress_config /build/.config\n+RUN curl https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.42.tar.xz | \\\n+      tar xJf - && \\\n+      cd /build/linux-4.4.42 && \\\n+      cp /build/.config . && \\\n+      make -j$(nproc) all && \\\n+      cp arch/arm/boot/zImage /tmp && \\\n+      cd /build &&  \\\n+      rm -rf linux-4.4.42\n+\n+# Compile an instance of busybox as this provides a lightweight system and init\n+# binary which we will boot into. Only trick here is configuring busybox to\n+# build static binaries.\n+RUN curl https://www.busybox.net/downloads/busybox-1.21.1.tar.bz2 | tar xjf - && \\\n+      cd busybox-1.21.1 && \\\n+      make defconfig && \\\n+      sed -i 's/.*CONFIG_STATIC.*/CONFIG_STATIC=y/' .config && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      mv _install /tmp/rootfs && \\\n+      cd /build && \\\n+      rm -rf busybox-1.12.1\n+\n+# Download the ubuntu rootfs, which we'll use as a chroot for all our tests.\n+WORKDIR /tmp\n+RUN mkdir rootfs/ubuntu\n+RUN curl http://cdimage.ubuntu.com/ubuntu-base/releases/16.04/release/ubuntu-base-16.04-core-armhf.tar.gz | \\\n+      tar xzf - -C rootfs/ubuntu && \\\n+      cd rootfs && mkdir proc sys dev etc etc/init.d\n+\n+# Copy over our init script, which starts up our test server and also a few\n+# other misc tasks.\n+COPY scripts/qemu-bare-bones-rcS rootfs/etc/init.d/rcS\n+RUN chmod +x rootfs/etc/init.d/rcS\n+\n+# Helper to quickly fill the entropy pool in the kernel.\n+COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n+RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n+\n+# TODO: What is this?!\n+# Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://ci-mirrors.rust-lang.org/rustc/vexpress-v2p-ca15-tc1.dtb\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n+ENV SCRIPT python3 ../x.py test --target arm-unknown-linux-gnueabihf\n+\n+ENV NO_CHANGE_USER=1"}, {"sha": "35835cff35dcf9f36fcf7bd309be9befe3c11863", "filename": "src/ci/docker/host-x86_64/armhf-gnu/vexpress_config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2Fvexpress_config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2Fvexpress_config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2Fvexpress_config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/armhf-gnu/vexpress_config"}, {"sha": "3fa65511e94f783912f52b7f7d2619b9a7e41cce", "filename": "src/ci/docker/host-x86_64/disabled/asmjs/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fasmjs%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/asmjs/Dockerfile"}, {"sha": "dea445c295c994263ef8ce7886a8b76b84adbaec", "filename": "src/ci/docker/host-x86_64/disabled/dist-aarch64-android/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile"}, {"sha": "7227c41ccca9a7dda4f54bcac161c7163a50384a", "filename": "src/ci/docker/host-x86_64/disabled/dist-armv7-android/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile"}, {"sha": "b74dcefa3516c5566262896a62b18f781cf10b9a", "filename": "src/ci/docker/host-x86_64/disabled/dist-i686-android/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile"}, {"sha": "19df9d6cf6231e4712b79422c22cdf93d295340c", "filename": "src/ci/docker/host-x86_64/disabled/dist-powerpcspe-linux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-powerpcspe-linux/Dockerfile"}, {"sha": "62d0bfc71b2fa76a0cdf5cb635b9aa366804c703", "filename": "src/ci/docker/host-x86_64/disabled/dist-sparc64-linux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-sparc64-linux/Dockerfile"}, {"sha": "d44779763e5443901234b12dc213594a4def7222", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-android/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile"}, {"sha": "5e743f0818a4f43ce26245efe3958f67db591381", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  bzip2 \\\n+  xz-utils \\\n+  wget \\\n+  libssl-dev \\\n+  bsdtar \\\n+  pkg-config\n+\n+\n+COPY host-x86_64/dist-x86_64-dragonfly/build-toolchain.sh /tmp/\n+COPY host-x86_64/dist-x86_64-dragonfly/patch-toolchain /tmp/\n+RUN /tmp/build-toolchain.sh /tmp/patch-toolchain\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-ar \\\n+    CC_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-gcc \\\n+    CXX_x86_64_unknown_dragonfly=x86_64-unknown-dragonfly-g++\n+\n+ENV HOSTS=x86_64-unknown-dragonfly\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "112d747fe4ed6b50b9f6ce2512a0012184eb834a", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-dragonfly/build-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2Fbuild-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/build-toolchain.sh"}, {"sha": "98424309ee23dbca8f8fb1fd82cb678174c9c558", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-dragonfly/patch-toolchain", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2Fpatch-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2Fpatch-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-dragonfly%2Fpatch-toolchain?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/patch-toolchain"}, {"sha": "61b3179d55fd879453901b23faa6aea1dd731cdc", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-haiku/Dockerfile", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,49 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  autoconf \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n+  g++ \\\n+  gawk \\\n+  git \\\n+  libcurl4-openssl-dev \\\n+  libssl-dev \\\n+  make \\\n+  nasm \\\n+  pkg-config \\\n+  python3 \\\n+  sudo \\\n+  texinfo \\\n+  wget \\\n+  xz-utils \\\n+  zlib1g-dev\n+\n+COPY host-x86_64/dist-x86_64-haiku/llvm-config.sh /bin/llvm-config-haiku\n+\n+ENV ARCH=x86_64\n+\n+WORKDIR /tmp\n+COPY host-x86_64/dist-x86_64-haiku/build-toolchain.sh /tmp/\n+RUN /tmp/build-toolchain.sh $ARCH\n+\n+COPY host-x86_64/dist-x86_64-haiku/fetch-packages.sh /tmp/\n+RUN /tmp/fetch-packages.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV HOST=x86_64-unknown-haiku\n+ENV TARGET=target.$HOST\n+\n+ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n+  --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n+  --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n+  --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n+ENV SCRIPT python3 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "faf30f36a20f9e06fa9c2a58af3c218c3f9a6794", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-haiku/build-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Fbuild-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-x86_64-haiku/build-toolchain.sh"}, {"sha": "e4c9f86d268dc5d9a2442174f8adff58bc18f59b", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-haiku/fetch-packages.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Ffetch-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Ffetch-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Ffetch-packages.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-x86_64-haiku/fetch-packages.sh"}, {"sha": "83f3a6e5f121685435e6ee7ca0eac6565deda4ac", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-haiku/llvm-config.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Fllvm-config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Fllvm-config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-haiku%2Fllvm-config.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/disabled/dist-x86_64-haiku/llvm-config.sh"}, {"sha": "b32c498c74eeb0b578f199f2b4a3ff58d869d9d9", "filename": "src/ci/docker/host-x86_64/disabled/dist-x86_64-redox/Dockerfile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,22 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+WORKDIR /tmp\n+COPY host-x86_64/dist-various-1/install-x86_64-redox.sh /scripts/\n+RUN sh /scripts/install-x86_64-redox.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_redox=x86_64-unknown-redox-ar \\\n+    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n+    CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV SCRIPT python3 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "08d0c5b2cac1e70e8b87dbd49348ad32c889c364", "filename": "src/ci/docker/host-x86_64/disabled/riscv64gc-linux/0001-Remove-stime-function-calls.patch", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2F0001-Remove-stime-function-calls.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2F0001-Remove-stime-function-calls.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2F0001-Remove-stime-function-calls.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,96 @@\n+From c820da85c65c7f3aa9e9cb3ed71ada69bf9b783e Mon Sep 17 00:00:00 2001\n+From: Alistair Francis <alistair.francis@wdc.com>\n+Date: Tue, 19 Nov 2019 13:06:40 +0100\n+Subject: [PATCH] Remove stime() function calls\n+\n+stime() has been deprecated in glibc 2.31 and replaced with\n+clock_settime(). Let's replace the stime() function calls with\n+clock_settime() in preperation.\n+\n+function                                             old     new   delta\n+rdate_main                                           197     224     +27\n+clock_settime                                          -      27     +27\n+date_main                                            926     941     +15\n+stime                                                 37       -     -37\n+------------------------------------------------------------------------------\n+(add/remove: 2/2 grow/shrink: 2/0 up/down: 69/-37)             Total: 32 bytes\n+\n+Signed-off-by: Alistair Francis <alistair.francis@wdc.com>\n+Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n+\n+[Tom Eccles: adjust patch context to apply on top of 1.31.1-stable]\n+Signed-off-by: Tom Eccles <tom.eccles@codethink.co.uk>\n+---\n+ coreutils/date.c         | 6 +++++-\n+ libbb/missing_syscalls.c | 8 --------\n+ util-linux/rdate.c       | 8 ++++++--\n+ 3 files changed, 11 insertions(+), 11 deletions(-)\n+\n+diff --git a/coreutils/date.c b/coreutils/date.c\n+index 3414d38ae..4ade6abb4 100644\n+--- a/coreutils/date.c\n++++ b/coreutils/date.c\n+@@ -279,6 +279,9 @@ int date_main(int argc UNUSED_PARAM, char **argv)\n+ \t\ttime(&ts.tv_sec);\n+ #endif\n+ \t}\n++#if !ENABLE_FEATURE_DATE_NANO\n++\tts.tv_nsec = 0;\n++#endif\n+ \tlocaltime_r(&ts.tv_sec, &tm_time);\n+ \n+ \t/* If date string is given, update tm_time, and maybe set date */\n+@@ -301,9 +304,10 @@ int date_main(int argc UNUSED_PARAM, char **argv)\n+ \t\tif (date_str[0] != '@')\n+ \t\t\ttm_time.tm_isdst = -1;\n+ \t\tts.tv_sec = validate_tm_time(date_str, &tm_time);\n++\t\tts.tv_nsec = 0;\n+ \n+ \t\t/* if setting time, set it */\n+-\t\tif ((opt & OPT_SET) && stime(&ts.tv_sec) < 0) {\n++\t\tif ((opt & OPT_SET) && clock_settime(CLOCK_REALTIME, &ts) < 0) {\n+ \t\t\tbb_perror_msg(\"can't set date\");\n+ \t\t}\n+ \t}\n+diff --git a/libbb/missing_syscalls.c b/libbb/missing_syscalls.c\n+index 87cf59b3d..dc40d9155 100644\n+--- a/libbb/missing_syscalls.c\n++++ b/libbb/missing_syscalls.c\n+@@ -15,14 +15,6 @@ pid_t getsid(pid_t pid)\n+ \treturn syscall(__NR_getsid, pid);\n+ }\n+ \n+-int stime(const time_t *t)\n+-{\n+-\tstruct timeval tv;\n+-\ttv.tv_sec = *t;\n+-\ttv.tv_usec = 0;\n+-\treturn settimeofday(&tv, NULL);\n+-}\n+-\n+ int sethostname(const char *name, size_t len)\n+ {\n+ \treturn syscall(__NR_sethostname, name, len);\n+diff --git a/util-linux/rdate.c b/util-linux/rdate.c\n+index 70f829e7f..878375d78 100644\n+--- a/util-linux/rdate.c\n++++ b/util-linux/rdate.c\n+@@ -95,9 +95,13 @@ int rdate_main(int argc UNUSED_PARAM, char **argv)\n+ \tif (!(flags & 2)) { /* no -p (-s may be present) */\n+ \t\tif (time(NULL) == remote_time)\n+ \t\t\tbb_error_msg(\"current time matches remote time\");\n+-\t\telse\n+-\t\t\tif (stime(&remote_time) < 0)\n++\t\telse {\n++\t\t\tstruct timespec ts;\n++\t\t\tts.tv_sec = remote_time;\n++\t\t\tts.tv_nsec = 0;\n++\t\t\tif (clock_settime(CLOCK_REALTIME, &ts) < 0)\n+ \t\t\t\tbb_perror_msg_and_die(\"can't set time of day\");\n++\t\t}\n+ \t}\n+ \n+ \tif (flags != 1) /* not lone -s */\n+-- \n+2.25.1\n+"}, {"sha": "a938899636a45878ad03f8d6a778e10e34c24240", "filename": "src/ci/docker/host-x86_64/disabled/riscv64gc-linux/Dockerfile", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,102 @@\n+# based on armhf-gnu/Dockerfile\n+FROM ubuntu:20.04\n+\n+RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections\n+RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n+    bc \\\n+    bison \\\n+    ca-certificates \\\n+    cmake \\\n+    cpio \\\n+    curl \\\n+    debian-ports-archive-keyring \\\n+    debootstrap \\\n+    flex \\\n+    gcc \\\n+    gcc-riscv64-linux-gnu \\\n+    git \\\n+    g++-riscv64-linux-gnu \\\n+    g++ \\\n+    libc6-dev \\\n+    libc6-dev-riscv64-cross \\\n+    make \\\n+    patch \\\n+    python3 \\\n+    qemu-system-misc \\\n+    xz-utils\n+\n+ENV ARCH=riscv\n+ENV CROSS_COMPILE=riscv64-linux-gnu-\n+\n+WORKDIR /build\n+\n+# From https://github.com/michaeljclark/busybear-linux/blob/master/conf/linux.config\n+COPY host-x86_64/riscv64gc-linux/linux.config /build\n+\n+# Compile the kernel that we're going to be emulating with. This is\n+# basically just done to be compatible with the QEMU target that we're going\n+# to be using when running tests.\n+RUN curl https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.6.16.tar.xz | tar xJf - && \\\n+    cp linux.config linux-5.6.16/.config && \\\n+    cd /build/linux-5.6.16 && \\\n+    make olddefconfig && \\\n+    make -j$(nproc) vmlinux && \\\n+    cp vmlinux /tmp && \\\n+    rm -rf linux-5.6.16\n+\n+# Compile an instance of busybox as this provides a lightweight system and init\n+# binary which we will boot into. Only trick here is configuring busybox to\n+# build static binaries.\n+RUN curl https://busybox.net/downloads/busybox-1.31.1.tar.bz2 | tar xjf -\n+COPY host-x86_64/riscv64gc-linux/0001-Remove-stime-function-calls.patch /build/busybox-1.31.1/\n+RUN cd /build/busybox-1.31.1 && \\\n+    patch -p1 -i 0001-Remove-stime-function-calls.patch && \\\n+    make defconfig && \\\n+    sed -i 's/.*CONFIG_STATIC.*/CONFIG_STATIC=y/' .config && \\\n+    make -j$(nproc) && \\\n+    make install && \\\n+    mv _install /tmp/rootfs && \\\n+    cd /build && \\\n+    rm -rf busybox-1.31.1\n+\n+# Download the ubuntu rootfs, which we'll use as a chroot for all our tests\n+# This is only needed to provide /lib/* and /usr/lib/*\n+WORKDIR /tmp\n+RUN debootstrap --variant=minbase --arch=riscv64 --foreign focal /tmp/rootfs/ubuntu\n+RUN cd rootfs && mkdir proc sys dev etc etc/init.d\n+# rootfs/ubuntu/proc is in a weird state (access fails with ELOOP) until\n+# rootfs/ubuntu/debootstrap/debootstrap --second-stage is run (under emulation),\n+# but this takes ages. Instead hack it into a good enough state.\n+# /proc is used by std::env::current_exe() (which is roughly\n+# `readlink /proc/self/exe`)\n+RUN cd rootfs/ubuntu && rm -rf proc && mkdir proc\n+\n+# Copy over our init script, which starts up our test server and also a few other\n+# misc tasks\n+COPY scripts/qemu-bare-bones-rcS rootfs/etc/init.d/rcS\n+RUN chmod +x rootfs/etc/init.d/rcS\n+\n+# Helper to quickly fill the entropy pool in the kernel\n+COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n+RUN riscv64-linux-gnu-gcc addentropy.c -o rootfs/addentropy -static\n+\n+# download and build the riscv bootloader\n+RUN git clone https://github.com/riscv/riscv-pk\n+WORKDIR /tmp/riscv-pk\n+# nothing special about this revision: it is just master at the time of writing\n+# v1.0.0 doesn't build\n+RUN git checkout 5d9ed238e1cabfbca3c47f50d32894ce94bfc304\n+RUN mkdir build && cd build && \\\n+    ../configure --with-payload=/tmp/vmlinux --host=riscv64-linux-gnu && \\\n+    make -j$(nproc) && \\\n+    cp bbl /tmp\n+WORKDIR /tmp\n+RUN rm -rf /tmp/riscv-pk\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV RUST_CONFIGURE_ARGS --qemu-riscv64-rootfs=/tmp/rootfs\n+ENV SCRIPT python3 ../x.py test --target riscv64gc-unknown-linux-gnu\n+\n+ENV NO_CHANGE_USER=1"}, {"sha": "5142664742f20248d66d550dfdbf64e94167adf5", "filename": "src/ci/docker/host-x86_64/disabled/riscv64gc-linux/linux.config", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2Flinux.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2Flinux.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2Flinux.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,51 @@\n+CONFIG_DEFAULT_HOSTNAME=\"busybear\"\n+CONFIG_SYSVIPC=y\n+CONFIG_POSIX_MQUEUE=y\n+CONFIG_IKCONFIG=y\n+CONFIG_IKCONFIG_PROC=y\n+CONFIG_CGROUPS=y\n+CONFIG_CGROUP_SCHED=y\n+CONFIG_CFS_BANDWIDTH=y\n+CONFIG_CGROUP_BPF=y\n+CONFIG_NAMESPACES=y\n+CONFIG_USER_NS=y\n+CONFIG_CHECKPOINT_RESTORE=y\n+CONFIG_BLK_DEV_INITRD=y\n+CONFIG_EXPERT=y\n+CONFIG_BPF_SYSCALL=y\n+CONFIG_SMP=y\n+CONFIG_MODULES=y\n+CONFIG_NET=y\n+CONFIG_PACKET=y\n+CONFIG_PACKET_DIAG=y\n+CONFIG_UNIX=y\n+CONFIG_INET=y\n+CONFIG_NETLINK_DIAG=y\n+# CONFIG_WIRELESS is not set\n+CONFIG_PCI=y\n+CONFIG_DEVTMPFS=y\n+CONFIG_BLK_DEV_LOOP=y\n+CONFIG_VIRTIO_BLK=y\n+CONFIG_NETDEVICES=y\n+CONFIG_VIRTIO_NET=y\n+# CONFIG_ETHERNET is not set\n+# CONFIG_WLAN is not set\n+CONFIG_SERIAL_8250=y\n+CONFIG_SERIAL_8250_CONSOLE=y\n+CONFIG_SERIAL_OF_PLATFORM=y\n+CONFIG_HVC_RISCV_SBI=y\n+# CONFIG_HW_RANDOM is not set\n+# CONFIG_USB_SUPPORT is not set\n+CONFIG_VIRTIO_MMIO=y\n+CONFIG_SIFIVE_PLIC=y\n+CONFIG_RAS=y\n+CONFIG_EXT2_FS=y\n+CONFIG_EXT3_FS=y\n+CONFIG_EXT4_FS_POSIX_ACL=y\n+CONFIG_AUTOFS4_FS=y\n+CONFIG_MSDOS_FS=y\n+CONFIG_VFAT_FS=y\n+CONFIG_TMPFS=y\n+# CONFIG_CRYPTO_ECHAINIV is not set\n+# CONFIG_CRYPTO_HW is not set\n+CONFIG_PRINTK_TIME=y"}, {"sha": "df65f9df44127002be9037e0da9c8a5ddc6a8e0b", "filename": "src/ci/docker/host-x86_64/dist-aarch64-linux/Dockerfile", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,40 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+# Ubuntu 16.04 (this container) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+COPY scripts/make3.sh /scripts/\n+RUN sh /scripts/make3.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-aarch64-linux/aarch64-linux-gnu.config host-x86_64/dist-aarch64-linux/build-toolchains.sh /tmp/\n+RUN ./build-toolchains.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/aarch64-unknown-linux-gnueabi/bin\n+\n+ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n+    AR_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-ar \\\n+    CXX_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-g++\n+\n+ENV HOSTS=aarch64-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --enable-full-tools \\\n+      --enable-profiler \\\n+      --enable-sanitizers \\\n+      --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "3d30ee49022d8f9318abc0fa52d71cd8310799d1", "filename": "src/ci/docker/host-x86_64/dist-aarch64-linux/aarch64-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2Faarch64-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2Faarch64-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2Faarch64-linux-gnu.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-aarch64-linux/aarch64-linux-gnu.config"}, {"sha": "390ba1a1ddf9cfd28f3566c583365e7736742f6f", "filename": "src/ci/docker/host-x86_64/dist-aarch64-linux/build-toolchains.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-aarch64-linux%2Fbuild-toolchains.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-aarch64-linux/build-toolchains.sh"}, {"sha": "6d38e199564b1d3de503864bbd36847f72031260", "filename": "src/ci/docker/host-x86_64/dist-android/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-android/Dockerfile"}, {"sha": "ba93f6ad8240304966f837b2bd430738701f367f", "filename": "src/ci/docker/host-x86_64/dist-arm-linux/Dockerfile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,31 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-arm-linux/arm-linux-gnueabi.config host-x86_64/dist-arm-linux/build-toolchains.sh /tmp/\n+RUN ./build-toolchains.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabi/bin\n+\n+ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n+    AR_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-ar \\\n+    CXX_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-g++\n+\n+ENV HOSTS=arm-unknown-linux-gnueabi\n+\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "1dcdbd1a9008be2eb76c7f5f8c781e8e234e953c", "filename": "src/ci/docker/host-x86_64/dist-arm-linux/arm-linux-gnueabi.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2Farm-linux-gnueabi.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-arm-linux/arm-linux-gnueabi.config"}, {"sha": "2e790b77a96c2c60f636f99800e3ad3a22ea1515", "filename": "src/ci/docker/host-x86_64/dist-arm-linux/build-toolchains.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2Fbuild-toolchains.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-arm-linux/build-toolchains.sh"}, {"sha": "977ef08c27478330f3d8f417818891a964906827", "filename": "src/ci/docker/host-x86_64/dist-armhf-linux/Dockerfile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,31 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-armhf-linux/arm-linux-gnueabihf.config host-x86_64/dist-armhf-linux/build-toolchains.sh /tmp/\n+RUN ./build-toolchains.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/arm-unknown-linux-gnueabihf/bin\n+\n+ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n+    AR_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-ar \\\n+    CXX_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-g++\n+\n+ENV HOSTS=arm-unknown-linux-gnueabihf\n+\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a3dcff1c9363538d11ca2ad8967d948405d998eb", "filename": "src/ci/docker/host-x86_64/dist-armhf-linux/arm-linux-gnueabihf.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-armhf-linux/arm-linux-gnueabihf.config"}, {"sha": "a01c2e0eb0a7c8817395273447e7f3edf6eeb594", "filename": "src/ci/docker/host-x86_64/dist-armhf-linux/build-toolchains.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armhf-linux%2Fbuild-toolchains.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-armhf-linux/build-toolchains.sh"}, {"sha": "65d713359d99ea841a3c247e54c35c46c50d14e1", "filename": "src/ci/docker/host-x86_64/dist-armv7-linux/Dockerfile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,31 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-armv7-linux/build-toolchains.sh host-x86_64/dist-armv7-linux/armv7-linux-gnueabihf.config /tmp/\n+RUN ./build-toolchains.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/armv7-unknown-linux-gnueabihf/bin\n+\n+ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n+    AR_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-ar \\\n+    CXX_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-g++\n+\n+ENV HOSTS=armv7-unknown-linux-gnueabihf\n+\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "81b3d7477ec8d1537a5a9d787ca2bc6dc947a949", "filename": "src/ci/docker/host-x86_64/dist-armv7-linux/armv7-linux-gnueabihf.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-armv7-linux/armv7-linux-gnueabihf.config"}, {"sha": "28f8ba2437b3d2166d19bd7301dcdeec1617f506", "filename": "src/ci/docker/host-x86_64/dist-armv7-linux/build-toolchains.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2Fbuild-toolchains.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2Fbuild-toolchains.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-armv7-linux%2Fbuild-toolchains.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-armv7-linux/build-toolchains.sh"}, {"sha": "996fffeb871cfc9f7f6fe23e08f7ac33cc7b11ae", "filename": "src/ci/docker/host-x86_64/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile"}, {"sha": "7978bb70869652f8e5c39ad66f2bff6a27a9ee5f", "filename": "src/ci/docker/host-x86_64/dist-i686-freebsd/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-i686-freebsd/Dockerfile"}, {"sha": "eac0ed24d509e94a0be5377eab1af980702bd1a8", "filename": "src/ci/docker/host-x86_64/dist-i686-linux/Dockerfile", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,120 @@\n+FROM centos:5\n+\n+WORKDIR /build\n+\n+# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n+# to http://vault.centos.org/\n+RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n+RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n+RUN sed -i 's|#\\(baseurl.*\\)mirror.centos.org/centos/$releasever|\\1vault.centos.org/5.11|' /etc/yum.repos.d/*.repo\n+\n+RUN yum upgrade -y && yum install -y \\\n+      curl \\\n+      bzip2 \\\n+      gcc \\\n+      gcc-c++ \\\n+      make \\\n+      glibc-devel \\\n+      perl \\\n+      zlib-devel \\\n+      file \\\n+      xz \\\n+      which \\\n+      pkgconfig \\\n+      wget \\\n+      autoconf \\\n+      gettext\n+\n+ENV PATH=/rustroot/bin:$PATH\n+ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n+ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n+WORKDIR /tmp\n+COPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n+\n+# We need a build of openssl which supports SNI to download artifacts from\n+# static.rust-lang.org. This'll be used to link into libcurl below (and used\n+# later as well), so build a copy of OpenSSL with dynamic libraries into our\n+# generic root.\n+COPY host-x86_64/dist-x86_64-linux/build-openssl.sh /tmp/\n+RUN ./build-openssl.sh\n+\n+# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n+# some https urls we have, so install a new version of libcurl + curl which is\n+# using the openssl we just built previously.\n+#\n+# Note that we also disable a bunch of optional features of curl that we don't\n+# really need.\n+COPY host-x86_64/dist-x86_64-linux/build-curl.sh /tmp/\n+RUN ./build-curl.sh\n+\n+# binutils < 2.22 has a bug where the 32-bit executables it generates\n+# immediately segfault in Rust, so we need to install our own binutils.\n+#\n+# See https://github.com/rust-lang/rust/issues/20440 for more info\n+COPY host-x86_64/dist-x86_64-linux/build-binutils.sh /tmp/\n+RUN ./build-binutils.sh\n+\n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# Need a newer version of gcc than centos has to compile LLVM nowadays\n+COPY host-x86_64/dist-x86_64-linux/build-gcc.sh /tmp/\n+RUN ./build-gcc.sh\n+\n+# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n+COPY host-x86_64/dist-x86_64-linux/build-python.sh /tmp/\n+RUN ./build-python.sh\n+\n+# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n+# clang/clang++ compilers.\n+COPY host-x86_64/dist-x86_64-linux/build-clang.sh host-x86_64/dist-x86_64-linux/llvm-project-centos.patch /tmp/\n+RUN ./build-clang.sh\n+ENV CC=clang CXX=clang++\n+\n+# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n+# cloning, so download and build it here.\n+COPY host-x86_64/dist-x86_64-linux/build-git.sh /tmp/\n+RUN ./build-git.sh\n+\n+# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n+# with so we install newer ones here\n+COPY host-x86_64/dist-x86_64-linux/build-headers.sh /tmp/\n+RUN ./build-headers.sh\n+\n+# OpenSSL requires a more recent version of perl\n+# with so we install newer ones here\n+COPY host-x86_64/dist-x86_64-linux/build-perl.sh /tmp/\n+RUN ./build-perl.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV HOSTS=i686-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --enable-full-tools \\\n+      --enable-sanitizers \\\n+      --enable-profiler \\\n+      --set target.i686-unknown-linux-gnu.linker=clang \\\n+      --build=i686-unknown-linux-gnu \\\n+      --set rust.jemalloc\n+ENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\n+ENV CARGO_TARGET_I686_UNKNOWN_LINUX_GNU_LINKER=clang\n+\n+# This was added when we switched from gcc to clang. It's not clear why this is\n+# needed unfortunately, but without this the stage1 bootstrap segfaults\n+# somewhere inside of a build script. The build ends up just hanging instead of\n+# actually killing the process that segfaulted, but if the process is run\n+# manually in a debugger the segfault is immediately seen as well as the\n+# misaligned stack access.\n+#\n+# Added in #50200 there's some more logs there\n+ENV CFLAGS -mstackrealign\n+\n+# When we build cargo in this container, we don't want it to use the system\n+# libcurl, instead it should compile its own.\n+ENV LIBCURL_NO_PKG_CONFIG 1\n+\n+ENV DIST_REQUIRE_ALL_TOOLS 1"}, {"sha": "57a7fc25b5c13ead0cf11168a452b053c94dd58c", "filename": "src/ci/docker/host-x86_64/dist-mips-linux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-mips-linux/Dockerfile"}, {"sha": "63f1028e2be593db9db9c0e533f9ae6c2f0a5f6c", "filename": "src/ci/docker/host-x86_64/dist-mips64-linux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-mips64-linux/Dockerfile"}, {"sha": "a51edbc9c7923a49d0684efe54e5df4d0096f595", "filename": "src/ci/docker/host-x86_64/dist-mips64el-linux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64el-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-mips64el-linux/Dockerfile"}, {"sha": "908cef90cef6900c801a8fab567b0a1f5e8587c5", "filename": "src/ci/docker/host-x86_64/dist-mipsel-linux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mipsel-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-mipsel-linux/Dockerfile"}, {"sha": "651daac86139db706c12f4135de3e9cbf248310d", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/Dockerfile", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,38 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+# Ubuntu 16.04 (this container) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+COPY scripts/make3.sh /scripts/\n+RUN sh /scripts/make3.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-powerpc-linux/patches/ /tmp/patches/\n+COPY host-x86_64/dist-powerpc-linux/powerpc-linux-gnu.config host-x86_64/dist-powerpc-linux/build-powerpc-toolchain.sh /tmp/\n+RUN ./build-powerpc-toolchain.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/powerpc-unknown-linux-gnu/bin\n+\n+ENV \\\n+    CC_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-gcc \\\n+    AR_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-ar \\\n+    CXX_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-g++\n+\n+ENV HOSTS=powerpc-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "d2e39834d6e96317b17984d5c86661410372cbf1", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/build-powerpc-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc-linux/build-powerpc-toolchain.sh"}, {"sha": "744eb180cd1f670cd52f3b47ccce8ce645e20a91", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/patches/glibc/2.12.2/002-newer-gcc.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc-linux/patches/glibc/2.12.2/002-newer-gcc.patch"}, {"sha": "7df41da2bf76e87cc5f3fe670b252b6850318578", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/powerpc-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc-linux/powerpc-linux-gnu.config"}, {"sha": "6ff4d787212a040655158a6f8dcfc3350efb1d4d", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/Dockerfile", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,39 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+\n+# Ubuntu 16.04 (this container) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+COPY scripts/make3.sh /scripts/\n+RUN sh /scripts/make3.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-powerpc64-linux/patches/ /tmp/patches/\n+COPY host-x86_64/dist-powerpc64-linux/shared.sh host-x86_64/dist-powerpc64-linux/powerpc64-linux-gnu.config host-x86_64/dist-powerpc64-linux/build-powerpc64-toolchain.sh /tmp/\n+RUN ./build-powerpc64-toolchain.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/powerpc64-unknown-linux-gnu/bin\n+\n+ENV \\\n+    AR_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-ar \\\n+    CC_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-gcc \\\n+    CXX_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-g++\n+\n+ENV HOSTS=powerpc64-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "fc53849a2ada41f6094b3793e96b093d8ffc606a", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/build-powerpc64-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64-linux/build-powerpc64-toolchain.sh"}, {"sha": "744eb180cd1f670cd52f3b47ccce8ce645e20a91", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch"}, {"sha": "47cc8b28d225a11d496593d510e43f6bc7fa2e7b", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.12.2/002-Prevent-inlining-in-PPC64-initfini.s.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-Prevent-inlining-in-PPC64-initfini.s.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-Prevent-inlining-in-PPC64-initfini.s.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-Prevent-inlining-in-PPC64-initfini.s.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64-linux/patches/glibc/2.12.2/002-Prevent-inlining-in-PPC64-initfini.s.patch"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.12.2/003-newer-gcc.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F003-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F003-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F003-newer-gcc.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64-linux/patches/glibc/2.12.2/003-newer-gcc.patch"}, {"sha": "4aab4f4fd44457eccf86ed90e8290bdd59f1e6e1", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/powerpc64-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64-linux/powerpc64-linux-gnu.config"}, {"sha": "b873569278914e54c8dc3eb7e7871a4c793da72c", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fshared.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64-linux/shared.sh"}, {"sha": "c1a621ff105b7552ff3451223d720abe0b3db0d8", "filename": "src/ci/docker/host-x86_64/dist-powerpc64le-linux/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+# Ubuntu 16.04 (this container) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+COPY scripts/make3.sh /scripts/\n+RUN sh /scripts/make3.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+USER root\n+\n+RUN apt-get install -y --no-install-recommends rpm2cpio cpio\n+COPY host-x86_64/dist-powerpc64le-linux/shared.sh host-x86_64/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh /tmp/\n+RUN ./build-powerpc64le-toolchain.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-ar \\\n+    CC_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-gcc \\\n+    CXX_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-g++\n+\n+ENV HOSTS=powerpc64le-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f866a24287f9e6d9aed7b0758bd4ee258f37ee1c", "filename": "src/ci/docker/host-x86_64/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh"}, {"sha": "b873569278914e54c8dc3eb7e7871a4c793da72c", "filename": "src/ci/docker/host-x86_64/dist-powerpc64le-linux/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2Fshared.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-powerpc64le-linux/shared.sh"}, {"sha": "1b261993cfc4f8a742e6a33e3c8b2837c441efa0", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/Dockerfile", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,38 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+# Ubuntu 16.04 (this container) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+COPY scripts/make3.sh /scripts/\n+RUN sh /scripts/make3.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+COPY scripts/rustbuild-setup.sh /scripts/\n+RUN sh /scripts/rustbuild-setup.sh\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY host-x86_64/dist-s390x-linux/patches/ /tmp/patches/\n+COPY host-x86_64/dist-s390x-linux/s390x-linux-gnu.config host-x86_64/dist-s390x-linux/build-s390x-toolchain.sh /tmp/\n+RUN ./build-s390x-toolchain.sh\n+\n+USER root\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/s390x-ibm-linux-gnu/bin\n+\n+ENV \\\n+    CC_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-gcc \\\n+    AR_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-ar \\\n+    CXX_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-g++\n+\n+ENV HOSTS=s390x-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "df9529da8a1628c910d616a77b506d870e74320a", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/build-s390x-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fbuild-s390x-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-s390x-linux/build-s390x-toolchain.sh"}, {"sha": "cba416ed2f70bc12990229442e23feb47a0fdd3c", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/patches/glibc/2.12.2/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-s390x-linux/patches/glibc/2.12.2/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/patches/glibc/2.12.2/002-newer-gcc.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-s390x-linux/patches/glibc/2.12.2/002-newer-gcc.patch"}, {"sha": "cd1c41b02e3122e53059ac6a9a5565cd8952cb62", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/s390x-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fs390x-linux-gnu.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-s390x-linux/s390x-linux-gnu.config"}, {"sha": "87bab78f796c072b9b1c2e2f90474f426e7b4745", "filename": "src/ci/docker/host-x86_64/dist-various-1/Dockerfile", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,216 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  flex \\\n+  help2man \\\n+  libtool-bin \\\n+  texinfo \\\n+  unzip \\\n+  wget \\\n+  xz-utils \\\n+  libncurses-dev \\\n+  gawk \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  xz-utils \\\n+  zlib1g-dev \\\n+  g++-arm-linux-gnueabi \\\n+  g++-arm-linux-gnueabihf \\\n+  g++-aarch64-linux-gnu \\\n+  g++-mips64-linux-gnuabi64 \\\n+  g++-mips64el-linux-gnuabi64 \\\n+  gcc-sparc64-linux-gnu \\\n+  libc6-dev-sparc64-cross \\\n+  bzip2 \\\n+  patch \\\n+  libssl-dev \\\n+  pkg-config \\\n+  libnewlib-arm-none-eabi \\\n+  qemu-system-arm \\\n+# software-properties-common for the add-apt-repository command\n+  software-properties-common\n+\n+WORKDIR /build\n+\n+# Use the team-gcc-arm-embedded PPA for a newer version of Arm GCC\n+RUN add-apt-repository ppa:team-gcc-arm-embedded/ppa && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends gcc-arm-embedded\n+\n+COPY scripts/rustbuild-setup.sh host-x86_64/dist-various-1/build-riscv-toolchain.sh host-x86_64/dist-various-1/riscv64-unknown-linux-gnu.config host-x86_64/dist-various-1/crosstool-ng.sh /build/\n+RUN ./crosstool-ng.sh\n+\n+# Crosstool-ng will refuse to build as root\n+RUN sh ./rustbuild-setup.sh\n+USER rustbuild\n+\n+RUN ./build-riscv-toolchain.sh\n+\n+USER root\n+ENV PATH=/x-tools/riscv64-unknown-linux-gnu/bin:$PATH\n+\n+COPY host-x86_64/dist-various-1/build-rumprun.sh /build\n+RUN ./build-rumprun.sh\n+\n+COPY host-x86_64/dist-various-1/install-x86_64-redox.sh /build\n+RUN ./install-x86_64-redox.sh\n+\n+COPY host-x86_64/dist-various-1/install-mips-musl.sh /build\n+RUN ./install-mips-musl.sh\n+\n+COPY host-x86_64/dist-various-1/install-mipsel-musl.sh /build\n+RUN ./install-mipsel-musl.sh\n+\n+COPY host-x86_64/dist-various-1/install-aarch64-none-elf.sh /build\n+RUN ./install-aarch64-none-elf.sh\n+\n+# Suppress some warnings in the openwrt toolchains we downloaded\n+ENV STAGING_DIR=/tmp\n+\n+COPY scripts/musl.sh /build\n+RUN env \\\n+    CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    bash musl.sh armv5te && \\\n+    env \\\n+    CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv6 -marm\" \\\n+    CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv6 -marm\" \\\n+    bash musl.sh arm && \\\n+    env \\\n+    CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n+    CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n+    bash musl.sh armhf && \\\n+    env \\\n+    CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv7-a\" \\\n+    CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv7-a\" \\\n+    bash musl.sh armv7hf && \\\n+    env \\\n+    CC=aarch64-linux-gnu-gcc \\\n+    CXX=aarch64-linux-gnu-g++ \\\n+    bash musl.sh aarch64 && \\\n+    env \\\n+    CC=mips-openwrt-linux-gcc \\\n+    CXX=mips-openwrt-linux-g++ \\\n+    bash musl.sh mips && \\\n+    env \\\n+    CC=mipsel-openwrt-linux-gcc \\\n+    CXX=mipsel-openwrt-linux-g++ \\\n+    bash musl.sh mipsel && \\\n+    env \\\n+    CC=mips64-linux-gnuabi64-gcc \\\n+    CXX=mips64-linux-gnuabi64-g++ \\\n+    bash musl.sh mips64 && \\\n+    env \\\n+    CC=mips64el-linux-gnuabi64-gcc \\\n+    CXX=mips64el-linux-gnuabi64-g++ \\\n+    bash musl.sh mips64el && \\\n+    rm -rf /build/*\n+\n+# FIXME(mozilla/sccache#235) this shouldn't be necessary but is currently\n+# necessary to disambiguate the mips compiler with the mipsel compiler. We want\n+# to give these two wrapper scripts (currently identical ones) different hashes\n+# to ensure that sccache understands that they're different compilers.\n+RUN \\\n+  echo \"# a\" >> /usr/local/mips-linux-musl/bin/mips-openwrt-linux-musl-wrapper.sh && \\\n+  echo \"# b\" >> /usr/local/mipsel-linux-musl/bin/mipsel-openwrt-linux-musl-wrapper.sh\n+\n+ENV RUN_MAKE_TARGETS=thumbv6m-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7m-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabihf\n+\n+ENV TARGETS=asmjs-unknown-emscripten\n+ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n+ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n+ENV TARGETS=$TARGETS,mips-unknown-linux-musl\n+ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n+ENV TARGETS=$TARGETS,mips64-unknown-linux-muslabi64\n+ENV TARGETS=$TARGETS,mips64el-unknown-linux-muslabi64\n+ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n+ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n+ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n+ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n+ENV TARGETS=$TARGETS,aarch64-unknown-none\n+ENV TARGETS=$TARGETS,aarch64-unknown-none-softfloat\n+ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n+ENV TARGETS=$TARGETS,thumbv8m.base-none-eabi\n+ENV TARGETS=$TARGETS,thumbv8m.main-none-eabi\n+ENV TARGETS=$TARGETS,thumbv8m.main-none-eabihf\n+ENV TARGETS=$TARGETS,riscv32i-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64gc-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64gc-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,armebv7r-none-eabi\n+ENV TARGETS=$TARGETS,armebv7r-none-eabihf\n+ENV TARGETS=$TARGETS,armv7r-none-eabi\n+ENV TARGETS=$TARGETS,armv7r-none-eabihf\n+ENV TARGETS=$TARGETS,thumbv7neon-unknown-linux-gnueabihf\n+ENV TARGETS=$TARGETS,armv7a-none-eabi\n+\n+# riscv targets currently do not need a C compiler, as compiler_builtins\n+# doesn't currently have it enabled, and the riscv gcc compiler is not\n+# installed.\n+ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n+    CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n+    CC_mips64el_unknown_linux_muslabi64=mips64el-linux-gnuabi64-gcc \\\n+    CC_mips64_unknown_linux_muslabi64=mips64-linux-gnuabi64-gcc \\\n+    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n+    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n+    CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n+    AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n+    CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++ \\\n+    CC_armv7a_none_eabi=arm-none-eabi-gcc \\\n+    CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n+    CFLAGS_armv7a_none_eabi=-march=armv7-a \\\n+    CFLAGS_armv7a_none_eabihf=-march=armv7-a+vfpv3 \\\n+    CC_aarch64_unknown_none_softfloat=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none_softfloat=-mstrict-align -march=armv8-a+nofp+nosimd \\\n+    CC_aarch64_unknown_none=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none=-mstrict-align -march=armv8-a+fp+simd \\\n+    CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n+    AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n+    CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\\n+    CC_riscv32i_unknown_none_elf=false \\\n+    CC_riscv32imc_unknown_none_elf=false \\\n+    CC_riscv32imac_unknown_none_elf=false \\\n+    CC_riscv64imac_unknown_none_elf=false \\\n+    CC_riscv64gc_unknown_none_elf=false\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --musl-root-armv5te=/musl-armv5te \\\n+      --musl-root-arm=/musl-arm \\\n+      --musl-root-armhf=/musl-armhf \\\n+      --musl-root-armv7hf=/musl-armv7hf \\\n+      --musl-root-aarch64=/musl-aarch64 \\\n+      --musl-root-mips=/musl-mips \\\n+      --musl-root-mipsel=/musl-mipsel \\\n+      --musl-root-mips64=/musl-mips64 \\\n+      --musl-root-mips64el=/musl-mips64el \\\n+      --disable-docs\n+\n+ENV SCRIPT \\\n+      python3 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n+      python3 ../x.py dist --target $TARGETS\n+\n+# sccache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh"}, {"sha": "9cb5700b3b6fb1eb352863c3a81f7ce833207c3d", "filename": "src/ci/docker/host-x86_64/dist-various-1/build-riscv-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fbuild-riscv-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fbuild-riscv-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fbuild-riscv-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/build-riscv-toolchain.sh"}, {"sha": "9c7aaef4f436f6cbf5d833a3dc994f0c02183424", "filename": "src/ci/docker/host-x86_64/dist-various-1/build-rumprun.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fbuild-rumprun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fbuild-rumprun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fbuild-rumprun.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/build-rumprun.sh"}, {"sha": "b01fdd0bf65e7f355dc1c28207ee3cf13f3f53a8", "filename": "src/ci/docker/host-x86_64/dist-various-1/crosstool-ng.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fcrosstool-ng.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fcrosstool-ng.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Fcrosstool-ng.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/crosstool-ng.sh"}, {"sha": "d72976c28584225902eeed7ede849610ce3ee586", "filename": "src/ci/docker/host-x86_64/dist-various-1/install-aarch64-none-elf.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-aarch64-none-elf.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/install-aarch64-none-elf.sh"}, {"sha": "9584258d23403b12fcfbb0249cec584535852c6e", "filename": "src/ci/docker/host-x86_64/dist-various-1/install-mips-musl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-mips-musl.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/install-mips-musl.sh"}, {"sha": "50a8e554b1675f789f074c09e657260f242d2ca2", "filename": "src/ci/docker/host-x86_64/dist-various-1/install-mipsel-musl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh"}, {"sha": "dad9792233847fd7ad77a28fc72dc4d5aa439a6a", "filename": "src/ci/docker/host-x86_64/dist-various-1/install-x86_64-redox.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-x86_64-redox.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-x86_64-redox.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Finstall-x86_64-redox.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/install-x86_64-redox.sh"}, {"sha": "dd06065b19740a2456d9ebcaf759d483075f4672", "filename": "src/ci/docker/host-x86_64/dist-various-1/riscv64-unknown-linux-gnu.config", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-1/riscv64-unknown-linux-gnu.config"}, {"sha": "498b289ae1aff40ba98fc3e1763adac8edfe9060", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,116 @@\n+FROM ubuntu:18.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+# Enable source repositories, which are disabled by default on Ubuntu >= 18.04\n+RUN sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list\n+\n+RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n+  build-essential \\\n+# gcc-multilib can not be installed together with gcc-arm-linux-gnueabi\n+  gcc-7-multilib \\\n+  libedit-dev \\\n+  libgmp-dev \\\n+  libisl-dev \\\n+  libmpc-dev \\\n+  libmpfr-dev \\\n+  ninja-build \\\n+  nodejs \\\n+  python3-dev \\\n+  software-properties-common \\\n+  unzip \\\n+  # Needed for apt-key to work:\n+  dirmngr \\\n+  gpg-agent \\\n+  g++-7-arm-linux-gnueabi\n+\n+RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n+RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n+\n+ENV \\\n+    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n+    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n+    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n+    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n+    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n+    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n+    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n+    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n+    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n+    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n+    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n+    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n+    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n+    AR_x86_64_fortanix_unknown_sgx=ar \\\n+    CC_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang-11 \\\n+    CFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    CXX_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang++-11 \\\n+    CXXFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    CC=gcc-7 \\\n+    CXX=g++-7\n+\n+WORKDIR /build\n+COPY scripts/musl.sh /build\n+RUN env \\\n+    CC=arm-linux-gnueabi-gcc-7 CFLAGS=\"-march=armv7-a\" \\\n+    CXX=arm-linux-gnueabi-g++-7 CXXFLAGS=\"-march=armv7-a\" \\\n+    bash musl.sh armv7 && \\\n+    rm -rf /build/*\n+\n+WORKDIR /tmp\n+COPY host-x86_64/dist-various-2/shared.sh /tmp/\n+COPY host-x86_64/dist-various-2/build-cloudabi-toolchain.sh /tmp/\n+RUN /tmp/build-cloudabi-toolchain.sh x86_64-unknown-cloudabi\n+COPY host-x86_64/dist-various-2/build-fuchsia-toolchain.sh /tmp/\n+RUN /tmp/build-fuchsia-toolchain.sh\n+COPY host-x86_64/dist-various-2/build-solaris-toolchain.sh /tmp/\n+RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n+RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n+COPY host-x86_64/dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n+COPY host-x86_64/dist-various-2/x86_64-fortanix-unknown-sgx-clang-wrap.sh /usr/bin/x86_64-fortanix-unknown-sgx-clang-11\n+RUN ln -s /usr/bin/x86_64-fortanix-unknown-sgx-clang-11 /usr/bin/x86_64-fortanix-unknown-sgx-clang++-11\n+RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh\n+\n+COPY host-x86_64/dist-various-2/build-wasi-toolchain.sh /tmp/\n+RUN /tmp/build-wasi-toolchain.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n+ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n+-C link-arg=--sysroot=/usr/local/x86_64-fuchsia \\\n+-C link-arg=-L/usr/local/x86_64-fuchsia/lib \\\n+-C link-arg=-L/usr/local/lib/x86_64-fuchsia/lib\n+ENV CARGO_TARGET_AARCH64_FUCHSIA_AR /usr/local/bin/llvm-ar\n+ENV CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS \\\n+-C link-arg=--sysroot=/usr/local/aarch64-fuchsia \\\n+-C link-arg=-L/usr/local/aarch64-fuchsia/lib \\\n+-C link-arg=-L/usr/local/lib/aarch64-fuchsia/lib\n+\n+ENV TARGETS=x86_64-fuchsia\n+ENV TARGETS=$TARGETS,aarch64-fuchsia\n+ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n+ENV TARGETS=$TARGETS,wasm32-wasi\n+ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n+ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n+ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx\n+ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n+\n+# As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n+# we need asm in the search path for gcc-7 (for gnux32) but not in the search path of the\n+# cross compilers.\n+# Luckily one of the folders is /usr/local/include so symlink /usr/include/asm-generic there\n+RUN ln -s /usr/include/asm-generic /usr/local/include/asm\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n+  --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n+  --musl-root-armv7=/musl-armv7\n+\n+ENV SCRIPT python3 ../x.py dist --target $TARGETS"}, {"sha": "3354a796c357e51672845828d83e4a0e94160722", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-cloudabi-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-2/build-cloudabi-toolchain.sh"}, {"sha": "73acdf5be6356733909ae059d71837f5c64be18d", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-fuchsia-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-2/build-fuchsia-toolchain.sh"}, {"sha": "4b3f284450eaa35a76351d5dc84fd0e1074e78dd", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-solaris-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-solaris-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-solaris-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-solaris-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-2/build-solaris-toolchain.sh"}, {"sha": "c82031690ab6a81b1bcdbaab7311ce515501ba09", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-wasi-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh"}, {"sha": "78bf4527feff19e953c4d06d4f4bd4e0ecc6fd8d", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,20 @@\n+#!/bin/bash\n+\n+set -eu\n+source shared.sh\n+\n+target=\"x86_64-fortanix-unknown-sgx\"\n+\n+install_prereq() {\n+    curl https://apt.llvm.org/llvm-snapshot.gpg.key|apt-key add -\n+    add-apt-repository -y 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main'\n+    apt-get update\n+    apt-get install -y --no-install-recommends \\\n+            build-essential \\\n+            ca-certificates \\\n+            cmake \\\n+            git \\\n+            clang-11\n+}\n+\n+hide_output install_prereq"}, {"sha": "7abace65b9c03a1db28378137404e853c7b8bf4b", "filename": "src/ci/docker/host-x86_64/dist-various-2/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fshared.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-various-2/shared.sh"}, {"sha": "c4ff44c37b1e35aa6e1a2d441d8fcfbaaaa305eb", "filename": "src/ci/docker/host-x86_64/dist-various-2/x86_64-fortanix-unknown-sgx-clang-wrap.sh", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,14 @@\n+#!/bin/bash\n+\n+args=(\"$@\")\n+\n+for i in \"${!args[@]}\"; do\n+    # x86_64-fortanix-unknown-sgx doesn't have a C sysroot for things like\n+    # stdint.h and the C++ STL. Unlike GCC, clang will not use the host's\n+    # sysroot instead. Force it.\n+    if [ \"${args[$i]}\" = \"--target=x86_64-fortanix-unknown-sgx\" ]; then\n+        args[$i]=\"--target=x86_64-unknown-linux-gnu\"\n+    fi\n+done\n+\n+exec \"${0/x86_64-fortanix-unknown-sgx-clang/clang}\" \"${args[@]}\""}, {"sha": "12170a366148755d884b97eb93cfaeb29e82cc2b", "filename": "src/ci/docker/host-x86_64/dist-x86_64-freebsd/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile"}, {"sha": "8b78214fbdd146138dcca92b622c5e51da17c5ed", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,116 @@\n+FROM centos:5\n+\n+WORKDIR /build\n+\n+# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n+# to http://vault.centos.org/\n+RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n+RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n+RUN sed -i 's|#\\(baseurl.*\\)mirror.centos.org/centos/$releasever|\\1vault.centos.org/5.11|' /etc/yum.repos.d/*.repo\n+\n+RUN yum upgrade -y && yum install -y \\\n+      curl \\\n+      bzip2 \\\n+      gcc \\\n+      gcc-c++ \\\n+      make \\\n+      glibc-devel \\\n+      perl \\\n+      zlib-devel \\\n+      file \\\n+      xz \\\n+      which \\\n+      pkgconfig \\\n+      wget \\\n+      autoconf \\\n+      gettext\n+\n+ENV PATH=/rustroot/bin:$PATH\n+ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n+ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n+WORKDIR /tmp\n+COPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n+\n+# We need a build of openssl which supports SNI to download artifacts from\n+# static.rust-lang.org. This'll be used to link into libcurl below (and used\n+# later as well), so build a copy of OpenSSL with dynamic libraries into our\n+# generic root.\n+COPY host-x86_64/dist-x86_64-linux/build-openssl.sh /tmp/\n+RUN ./build-openssl.sh\n+\n+# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n+# some https urls we have, so install a new version of libcurl + curl which is\n+# using the openssl we just built previously.\n+#\n+# Note that we also disable a bunch of optional features of curl that we don't\n+# really need.\n+COPY host-x86_64/dist-x86_64-linux/build-curl.sh /tmp/\n+RUN ./build-curl.sh\n+\n+# binutils < 2.22 has a bug where the 32-bit executables it generates\n+# immediately segfault in Rust, so we need to install our own binutils.\n+#\n+# See https://github.com/rust-lang/rust/issues/20440 for more info\n+COPY host-x86_64/dist-x86_64-linux/build-binutils.sh /tmp/\n+RUN ./build-binutils.sh\n+\n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# Build a version of gcc capable of building LLVM 6\n+COPY host-x86_64/dist-x86_64-linux/build-gcc.sh /tmp/\n+RUN ./build-gcc.sh\n+\n+# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n+COPY host-x86_64/dist-x86_64-linux/build-python.sh /tmp/\n+RUN ./build-python.sh\n+\n+# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n+# clang/clang++ compilers.\n+COPY host-x86_64/dist-x86_64-linux/build-clang.sh host-x86_64/dist-x86_64-linux/llvm-project-centos.patch /tmp/\n+RUN ./build-clang.sh\n+ENV CC=clang CXX=clang++\n+\n+# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n+# cloning, so download and build it here.\n+COPY host-x86_64/dist-x86_64-linux/build-git.sh /tmp/\n+RUN ./build-git.sh\n+\n+# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n+# with so we install newer ones here\n+COPY host-x86_64/dist-x86_64-linux/build-headers.sh /tmp/\n+RUN ./build-headers.sh\n+\n+# OpenSSL requires a more recent version of perl\n+# with so we install newer ones here\n+COPY host-x86_64/dist-x86_64-linux/build-perl.sh /tmp/\n+RUN ./build-perl.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV HOSTS=x86_64-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --enable-full-tools \\\n+      --enable-sanitizers \\\n+      --enable-profiler \\\n+      --enable-compiler-docs \\\n+      --set target.x86_64-unknown-linux-gnu.linker=clang \\\n+      --set target.x86_64-unknown-linux-gnu.ar=/rustroot/bin/llvm-ar \\\n+      --set target.x86_64-unknown-linux-gnu.ranlib=/rustroot/bin/llvm-ranlib \\\n+      --set llvm.thin-lto=true \\\n+      --set rust.jemalloc\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_LINKER=clang\n+\n+# This is the only builder which will create source tarballs\n+ENV DIST_SRC 1\n+\n+# When we build cargo in this container, we don't want it to use the system\n+# libcurl, instead it should compile its own.\n+ENV LIBCURL_NO_PKG_CONFIG 1\n+\n+ENV DIST_REQUIRE_ALL_TOOLS 1"}, {"sha": "ed0b5c85f7ca9e9706c0b4a376d4c516d79112da", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-binutils.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-binutils.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-binutils.sh"}, {"sha": "518f6ef9b701dc249c0924788856f2d78905192e", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-clang.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh"}, {"sha": "84522a7b87a4b194d8f0531b82eb8d636057a959", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-cmake.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-cmake.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-cmake.sh"}, {"sha": "0c7eb5fdac9bea0425b92a8c4a8f31375546b3eb", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-curl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-curl.sh"}, {"sha": "ddc2066537cefa7f69d0b6599695a7da8defa5df", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-gcc.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh"}, {"sha": "38fea2a8094b981317fbb565092439bd6ae8d9d4", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-git.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-git.sh"}, {"sha": "b623e53583b5e6c92fcfb92a751864781c286710", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-headers.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-headers.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-headers.sh"}, {"sha": "d8f6bdb51b8d5bad24e0995de30e5babde6d0fa9", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-openssl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh"}, {"sha": "a678d353d52f5881f69ffde98d10dfac6ceeb465", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-perl.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-perl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-perl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-perl.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-perl.sh"}, {"sha": "c172b9781120d75e2628140c5922e41ebde643d4", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-python.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-python.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/build-python.sh"}, {"sha": "52650062cc4026cae473dabfdcb91c89bf90c819", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/llvm-project-centos.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fllvm-project-centos.patch", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fllvm-project-centos.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fllvm-project-centos.patch?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/llvm-project-centos.patch"}, {"sha": "b873569278914e54c8dc3eb7e7871a4c793da72c", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fshared.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-linux/shared.sh"}, {"sha": "c026506b106618709844c4d7daa534eb9440cb99", "filename": "src/ci/docker/host-x86_64/dist-x86_64-musl/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-musl/Dockerfile"}, {"sha": "f3f7255f154dcde7226ee9b11c0408abd789ed93", "filename": "src/ci/docker/host-x86_64/dist-x86_64-netbsd/Dockerfile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-netbsd%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,22 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+COPY host-x86_64/dist-x86_64-netbsd/build-netbsd-toolchain.sh /tmp/\n+RUN /tmp/build-netbsd-toolchain.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/x-tools/x86_64-unknown-netbsd/bin\n+\n+ENV \\\n+    AR_x86_64_unknown_netbsd=x86_64--netbsd-ar \\\n+    CC_x86_64_unknown_netbsd=x86_64--netbsd-gcc-sysroot \\\n+    CXX_x86_64_unknown_netbsd=x86_64--netbsd-g++-sysroot\n+\n+ENV HOSTS=x86_64-unknown-netbsd\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f8697c698b9fb67aac77c9145a960e9f55437b8e", "filename": "src/ci/docker/host-x86_64/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh"}, {"sha": "c15b437e6d3157dea376b816c82172a449564a41", "filename": "src/ci/docker/host-x86_64/i686-gnu-nopt/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/i686-gnu-nopt/Dockerfile"}, {"sha": "377f07cef4e46e7444e7a21eea56d742e2eafa56", "filename": "src/ci/docker/host-x86_64/i686-gnu/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/i686-gnu/Dockerfile"}, {"sha": "e0607d298f4f4539a1da01cc103ff2bdf1e60be5", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,31 @@\n+FROM ubuntu:18.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  libssl-dev \\\n+  pkg-config \\\n+  mingw-w64\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n+\n+ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n+ENV SCRIPT python3 ../x.py test src/tools/expand-yaml-anchors && \\\n+           python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n+           python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n+           python3 ../x.py test --stage 0 src/tools/compiletest && \\\n+           python3 ../x.py test src/tools/tidy && \\\n+           python3 ../x.py doc --stage 0 src/libstd && \\\n+           /scripts/validate-toolstate.sh"}, {"sha": "c6d728eb80dd080377bf0a575b30cd828b49ab26", "filename": "src/ci/docker/host-x86_64/mingw-check/validate-toolstate.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Fvalidate-toolstate.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Fvalidate-toolstate.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Fvalidate-toolstate.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/mingw-check/validate-toolstate.sh"}, {"sha": "6775baa8c3273e7ef7a7b2a3a35c62a8d05c4eb3", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,61 @@\n+FROM ubuntu:18.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n+  xz-utils \\\n+  wget \\\n+  patch\n+\n+RUN curl -sL https://nodejs.org/dist/v14.4.0/node-v14.4.0-linux-x64.tar.xz | \\\n+  tar -xJ\n+\n+WORKDIR /build/\n+COPY scripts/musl-toolchain.sh /build/\n+RUN bash musl-toolchain.sh x86_64 && rm -rf build\n+WORKDIR /\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+  --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n+  --set build.nodejs=/node-v14.4.0-linux-x64/bin/node \\\n+  --set rust.lld\n+\n+# Some run-make tests have assertions about code size, and enabling debug\n+# assertions in libstd causes the binary to be much bigger than it would\n+# otherwise normally be. We already test libstd with debug assertions in lots of\n+# other contexts as well\n+ENV NO_DEBUG_ASSERTIONS=1\n+\n+ENV WASM_TARGETS=wasm32-unknown-unknown\n+ENV WASM_SCRIPT python3 /checkout/x.py test --target $WASM_TARGETS \\\n+  src/test/run-make \\\n+  src/test/ui \\\n+  src/test/compile-fail \\\n+  src/test/mir-opt \\\n+  src/test/codegen-units \\\n+  src/libcore\n+\n+ENV NVPTX_TARGETS=nvptx64-nvidia-cuda\n+ENV NVPTX_SCRIPT python3 /checkout/x.py test --target $NVPTX_TARGETS \\\n+  src/test/run-make \\\n+  src/test/assembly\n+\n+ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n+    CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n+    CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n+ENV MUSL_SCRIPT python3 /checkout/x.py test --target $MUSL_TARGETS\n+\n+ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "92461305320eee8d67e68f3f67c5d4bcc863c4a7", "filename": "src/ci/docker/host-x86_64/wasm32/Dockerfile", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,61 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  bzip2\n+\n+COPY scripts/emscripten.sh /scripts/\n+RUN bash /scripts/emscripten.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# emcc seems to need python to specifically be \"python\" and not \"python3\"\n+RUN ln `which python3` /usr/bin/python\n+\n+ENV PATH=$PATH:/emsdk-portable\n+ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n+\n+# Rust's build system requires NodeJS to be in the path, but the directory in\n+# which emsdk stores it contains the version number. This caused breakages in\n+# the past when emsdk bumped the node version causing the path to point to a\n+# missing directory.\n+#\n+# To avoid the problem this symlinks the latest NodeJs version available to\n+# \"latest\", and adds that to the path.\n+RUN ln -s /emsdk-portable/node/$(ls /emsdk-portable/node | sort -V | tail -n 1) \\\n+          /emsdk-portable/node/latest\n+ENV PATH=$PATH:/emsdk-portable/node/latest/bin/\n+\n+ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n+ENV EMSDK=/emsdk-portable\n+ENV EM_CONFIG=/emsdk-portable/.emscripten\n+ENV EM_CACHE=/emsdk-portable/upstream/emscripten/cache\n+\n+ENV TARGETS=wasm32-unknown-emscripten\n+\n+# Use -O1 optimizations in the link step to reduce time spent optimizing.\n+ENV EMCC_CFLAGS=-O1\n+\n+# Emscripten installation is user-specific\n+ENV NO_CHANGE_USER=1\n+\n+# FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n+# is picked up by CI\n+ENV SCRIPT python3 ../x.py test --target $TARGETS \\\n+    --exclude src/libcore \\\n+    --exclude src/liballoc \\\n+    --exclude src/libproc_macro \\\n+    --exclude src/libstd \\\n+    --exclude src/libterm \\\n+    --exclude src/libtest"}, {"sha": "86ac0256d28201cd90cf9977171adf8e7fc9365f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-aux/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-aux%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile"}, {"sha": "c5e41b8a75afe506048fa18eba18a27da91ae2d0", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-debug/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile"}, {"sha": "cc07a591cc17bec1c7d1d853f8216f75165aa98f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-distcheck/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile"}, {"sha": "de7ee6950b51b26ca00c06b2c32af0bf8b2c51f0", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-full-bootstrap/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile"}, {"sha": "1d9cad149d9aeb627e34d0a007546ca0cc365831", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-8/Dockerfile", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-8%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-8%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-8%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,64 @@\n+FROM ubuntu:18.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  g++-arm-linux-gnueabi \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-8-tools \\\n+  libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n+  zlib1g-dev \\\n+  xz-utils \\\n+  nodejs\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-8 \\\n+      --enable-llvm-link-shared \\\n+      --set rust.thin-lto-import-instr-limit=10\n+\n+ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n+           # Run the `mir-opt` tests again but this time for a 32-bit target.\n+           # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n+           # both 32-bit and 64-bit outputs updated by the PR author, before\n+           # the PR is approved and tested for merging.\n+           # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n+           # despite having different output on 32-bit vs 64-bit targets.\n+           #\n+           # HACK(eddyb) `armv5te` is used (not `i686`) to support older LLVM than LLVM 9:\n+           # https://github.com/rust-lang/compiler-builtins/pull/311#issuecomment-612270089.\n+           # This also requires `--pass=build` because we can't execute the tests\n+           # on the `x86_64` host when they're built as `armv5te` binaries.\n+           # (we're only interested in the MIR output, so this doesn't matter)\n+           python2.7 ../x.py test src/test/mir-opt --pass=build \\\n+                                  --target=armv5te-unknown-linux-gnueabi && \\\n+           # Run the UI test suite again, but in `--pass=check` mode\n+           #\n+           # This is intended to make sure that both `--pass=check` continues to\n+           # work.\n+           #\n+           # FIXME: We ideally want to test this in 32-bit mode, but currently\n+           # (due to the LLVM problems mentioned above) that isn't readily\n+           # possible.\n+           python2.7 ../x.py test src/test/ui --pass=check && \\\n+           # Run tidy at the very end, after all the other tests.\n+           python2.7 ../x.py test src/tools/tidy\n+\n+# The purpose of this container isn't to test with debug assertions and\n+# this is run on all PRs, so let's get speedier builds by disabling these extra\n+# checks.\n+ENV NO_DEBUG_ASSERTIONS=1\n+ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "096f67e13d1e679c0414ca8445c63abece65cb49", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-nopt/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile"}, {"sha": "ef17f0507ab11a0dfc0010288c3dfe20729e457f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/Dockerfile", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,25 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  libssl-dev \\\n+  sudo \\\n+  xz-utils \\\n+  pkg-config\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+COPY host-x86_64/x86_64-gnu-tools/checktools.sh /tmp/\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+  --build=x86_64-unknown-linux-gnu \\\n+  --save-toolstates=/tmp/toolstate/toolstates.json\n+ENV SCRIPT /tmp/checktools.sh ../x.py"}, {"sha": "b4b23a245e0aa928b0d7689e9ba8b07ba953f25c", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -14,12 +14,13 @@ python3 \"$X_PY\" test --no-fail-fast \\\n     src/doc/rust-by-example \\\n     src/doc/embedded-book \\\n     src/doc/edition-guide \\\n-    src/doc/rustc-dev-guide \\\n-    src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n \n set -e\n \n+# debugging: print out the saved toolstates\n+cat /tmp/toolstate/toolstates.json\n python3 \"$X_PY\" test check-tools\n+python3 \"$X_PY\" test src/tools/clippy", "previous_filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh"}, {"sha": "af6e13180627688b881fc9cc49b7bd3715a5ca01", "filename": "src/ci/docker/host-x86_64/x86_64-gnu/Dockerfile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "previous_filename": "src/ci/docker/x86_64-gnu/Dockerfile"}, {"sha": "17d844a1f99374537df12f097018c4f28f2ee7bc", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,30 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config \\\n-  mingw-w64\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-COPY mingw-check/validate-toolstate.sh /scripts/\n-\n-ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n-ENV SCRIPT python3 ../x.py test src/tools/expand-yaml-anchors && \\\n-           python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n-           python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n-           python3 ../x.py test --stage 0 src/tools/compiletest && \\\n-           python3 ../x.py test src/tools/tidy && \\\n-           /scripts/validate-toolstate.sh"}, {"sha": "c2ff62e74816d1ff80766cec7a2705bc459ddef4", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -5,10 +5,31 @@ set -e\n export MSYS_NO_PATHCONV=1\n \n script=`cd $(dirname $0) && pwd`/`basename $0`\n-image=$1\n \n-docker_dir=\"`dirname $script`\"\n-ci_dir=\"`dirname $docker_dir`\"\n+image=\"\"\n+dev=0\n+\n+while [[ $# -gt 0 ]]\n+do\n+  case \"$1\" in\n+    --dev)\n+      dev=1\n+      ;;\n+    *)\n+      if [ -n \"$image\" ]\n+      then\n+        echo \"expected single argument for the image name\"\n+        exit 1\n+      fi\n+      image=\"$1\"\n+      ;;\n+  esac\n+  shift\n+done\n+\n+script_dir=\"`dirname $script`\"\n+docker_dir=\"${script_dir}/host-$(uname -m)\"\n+ci_dir=\"`dirname $script_dir`\"\n src_dir=\"`dirname $ci_dir`\"\n root_dir=\"`dirname $src_dir`\"\n \n@@ -17,6 +38,8 @@ dist=$objdir/build/dist\n \n source \"$ci_dir/shared.sh\"\n \n+CACHE_DOMAIN=\"${CACHE_DOMAIN:-ci-caches.rust-lang.org}\"\n+\n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n     if [ \"$CI\" != \"\" ]; then\n       hash_key=/tmp/.docker-hash-key.txt\n@@ -29,18 +52,20 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       rm -f \"$copied_files\"\n       for i in $(sed -n -e 's/^COPY \\(.*\\) .*$/\\1/p' \"$docker_dir/$image/Dockerfile\"); do\n         # List the file names\n-        find \"$docker_dir/$i\" -type f >> $copied_files\n+        find \"$script_dir/$i\" -type f >> $copied_files\n       done\n       # Sort the file names and cat the content into the hash key\n       sort $copied_files | xargs cat >> $hash_key\n \n+      # Include the architecture in the hash key, since our Linux CI does not\n+      # only run in x86_64 machines.\n+      uname -m >> $hash_key\n+\n       docker --version >> $hash_key\n       cksum=$(sha512sum $hash_key | \\\n         awk '{print $1}')\n \n-      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n-      url=\"https://$SCCACHE_BUCKET.s3.amazonaws.com/docker/$cksum\"\n-      upload=\"aws s3 cp - $s3url\"\n+      url=\"https://$CACHE_DOMAIN/docker/$cksum\"\n \n       echo \"Attempting to download $url\"\n       rm -f /tmp/rustci_docker_cache\n@@ -53,10 +78,10 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n \n     dockerfile=\"$docker_dir/$image/Dockerfile\"\n     if [ -x /usr/bin/cygpath ]; then\n-        context=\"`cygpath -w $docker_dir`\"\n+        context=\"`cygpath -w $script_dir`\"\n         dockerfile=\"`cygpath -w $dockerfile`\"\n     else\n-        context=\"$docker_dir\"\n+        context=\"$script_dir\"\n     fi\n     retry docker \\\n       build \\\n@@ -65,7 +90,9 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -f \"$dockerfile\" \\\n       \"$context\"\n \n-    if [ \"$upload\" != \"\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      upload=\"aws s3 cp - $s3url\"\n       digest=$(docker inspect rust-ci --format '{{.Id}}')\n       echo \"Built container $digest\"\n       if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then\n@@ -92,14 +119,36 @@ elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n         exit 1\n     fi\n     # Transform changes the context of disabled Dockerfiles to match the enabled ones\n-    tar --transform 's#^./disabled/#./#' -C $docker_dir -c . | docker \\\n+    tar --transform 's#disabled/#./#' -C $script_dir -c . | docker \\\n       build \\\n       --rm \\\n       -t rust-ci \\\n-      -f \"$image/Dockerfile\" \\\n+      -f \"host-$(uname -m)/$image/Dockerfile\" \\\n       -\n else\n     echo Invalid image: $image\n+\n+    # Check whether the image exists for other architectures\n+    for arch_dir in \"${script_dir}\"/host-*; do\n+        # Avoid checking non-directories and the current host architecture directory\n+        if ! [[ -d \"${arch_dir}\" ]]; then\n+            continue\n+        fi\n+        if [[ \"${arch_dir}\" = \"${docker_dir}\" ]]; then\n+            continue\n+        fi\n+\n+        arch_name=\"$(basename \"${arch_dir}\" | sed 's/^host-//')\"\n+        if [[ -f \"${arch_dir}/${image}/Dockerfile\" ]]; then\n+            echo \"Note: the image exists for the ${arch_name} host architecture\"\n+        elif [[ -f \"${arch_dir}/disabled/${image}/Dockerfile\" ]]; then\n+            echo \"Note: the disabled image exists for the ${arch_name} host architecture\"\n+        else\n+            continue\n+        fi\n+        echo \"Note: the current host architecture is $(uname -m)\"\n+    done\n+\n     exit 1\n fi\n \n@@ -161,6 +210,15 @@ else\n   args=\"$args --env LOCAL_USER_ID=`id -u`\"\n fi\n \n+if [ \"$dev\" = \"1\" ]\n+then\n+  # Interactive + TTY\n+  args=\"$args -it\"\n+  command=\"/bin/bash\"\n+else\n+  command=\"/checkout/src/ci/run.sh\"\n+fi\n+\n docker \\\n   run \\\n   --workdir /checkout/obj \\\n@@ -181,7 +239,7 @@ docker \\\n   --init \\\n   --rm \\\n   rust-ci \\\n-  /checkout/src/ci/run.sh\n+  $command\n \n if [ -f /.dockerenv ]; then\n   rm -rf $objdir"}, {"sha": "1ae412340cb114e09c675b2ad92521d108a0526e", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -3,7 +3,7 @@\n #\n # Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n # musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n-# Right now we have: Binutils 2.27, GCC 6.4.0, musl 1.1.22.\n+# Right now we have: Binutils 2.31.1, GCC 9.2.0, musl 1.1.24.\n set -ex\n \n hide_output() {\n@@ -33,11 +33,13 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-git clone https://github.com/richfelker/musl-cross-make -b v0.9.8\n+git clone https://github.com/richfelker/musl-cross-make # -b v0.9.9\n cd musl-cross-make\n+# A few commits ahead of v0.9.9 to include the cowpatch fix:\n+git checkout a54eb56f33f255dfca60be045f12a5cfaf5a72a9\n \n-hide_output make -j$(nproc) TARGET=$TARGET\n-hide_output make install TARGET=$TARGET OUTPUT=$OUTPUT\n+hide_output make -j$(nproc) TARGET=$TARGET MUSL_VER=1.1.24\n+hide_output make install TARGET=$TARGET MUSL_VER=1.1.24 OUTPUT=$OUTPUT\n \n cd -\n "}, {"sha": "58393a5719a10d4854eaf7ce5aa151c3608df13a", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -24,7 +24,7 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.22\n+MUSL=musl-1.1.24\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then"}, {"sha": "cebba57344bfdff0c151e2a7cc434aa71d4fec18", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,6 +1,16 @@\n set -ex\n \n-curl -fo /usr/local/bin/sccache \\\n-  https://ci-mirrors.rust-lang.org/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\n+case \"$(uname -m)\" in\n+    x86_64)\n+        url=\"https://ci-mirrors.rust-lang.org/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\"\n+        ;;\n+    aarch64)\n+        url=\"https://ci-mirrors.rust-lang.org/rustc/2019-12-17-sccache-aarch64-unknown-linux-gnu\"\n+        ;;\n+    *)\n+        echo \"unsupported architecture: $(uname -m)\"\n+        exit 1\n+esac\n \n+curl -fo /usr/local/bin/sccache \"${url}\"\n chmod +x /usr/local/bin/sccache"}, {"sha": "9276e4ed82d78b2c886980927830b1310b25f4d3", "filename": "src/ci/docker/test-various/Dockerfile", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,61 +0,0 @@\n-FROM ubuntu:18.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  libssl-dev \\\n-  pkg-config \\\n-  xz-utils \\\n-  wget \\\n-  patch\n-\n-RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n-  tar -xJ\n-\n-WORKDIR /build/\n-COPY scripts/musl-toolchain.sh /build/\n-RUN bash musl-toolchain.sh x86_64 && rm -rf build\n-WORKDIR /\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-  --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n-  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n-  --set rust.lld\n-\n-# Some run-make tests have assertions about code size, and enabling debug\n-# assertions in libstd causes the binary to be much bigger than it would\n-# otherwise normally be. We already test libstd with debug assertions in lots of\n-# other contexts as well\n-ENV NO_DEBUG_ASSERTIONS=1\n-\n-ENV WASM_TARGETS=wasm32-unknown-unknown\n-ENV WASM_SCRIPT python3 /checkout/x.py test --target $WASM_TARGETS \\\n-  src/test/run-make \\\n-  src/test/ui \\\n-  src/test/compile-fail \\\n-  src/test/mir-opt \\\n-  src/test/codegen-units \\\n-  src/libcore\n-\n-ENV NVPTX_TARGETS=nvptx64-nvidia-cuda\n-ENV NVPTX_SCRIPT python3 /checkout/x.py test --target $NVPTX_TARGETS \\\n-  src/test/run-make \\\n-  src/test/assembly\n-\n-ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n-    CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n-    CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n-ENV MUSL_SCRIPT python3 /checkout/x.py test --target $MUSL_TARGETS\n-\n-ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "91c492d03c179dcdc073b1444ea2ad73fcc2e254", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,47 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils \\\n-  bzip2\n-\n-COPY scripts/emscripten.sh /scripts/\n-RUN bash /scripts/emscripten.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# emcc seems to need python to specifically be \"python\" and not \"python3\"\n-RUN ln `which python3` /usr/bin/python\n-\n-ENV PATH=$PATH:/emsdk-portable\n-ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n-ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n-ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n-\n-ENV TARGETS=wasm32-unknown-emscripten\n-\n-# Use -O1 optimizations in the link step to reduce time spent optimizing.\n-ENV EMCC_CFLAGS=-O1\n-\n-# Emscripten installation is user-specific\n-ENV NO_CHANGE_USER=1\n-\n-# FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n-# is picked up by CI\n-ENV SCRIPT python3 ../x.py test --target $TARGETS \\\n-    --exclude src/libcore \\\n-    --exclude src/liballoc \\\n-    --exclude src/libproc_macro \\\n-    --exclude src/libstd \\\n-    --exclude src/libterm \\\n-    --exclude src/libtest"}, {"sha": "58fdc6f262376c8cc26a2484653be4672df7ffe4", "filename": "src/ci/docker/x86_64-gnu-llvm-8/Dockerfile", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,55 +0,0 @@\n-FROM ubuntu:18.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  g++-arm-linux-gnueabi \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  llvm-8-tools \\\n-  libedit-dev \\\n-  libssl-dev \\\n-  pkg-config \\\n-  zlib1g-dev \\\n-  xz-utils \\\n-  nodejs\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# using llvm-link-shared due to libffi issues -- see #34486\n-ENV RUST_CONFIGURE_ARGS \\\n-      --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-8 \\\n-      --enable-llvm-link-shared \\\n-      --set rust.thin-lto-import-instr-limit=10\n-\n-ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n-           # Run the `mir-opt` tests again but this time for a 32-bit target.\n-           # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n-           # both 32-bit and 64-bit outputs updated by the PR author, before\n-           # the PR is approved and tested for merging.\n-           # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n-           # despite having different output on 32-bit vs 64-bit targets.\n-           #\n-           # HACK(eddyb) `armv5te` is used (not `i686`) to support older LLVM than LLVM 9:\n-           # https://github.com/rust-lang/compiler-builtins/pull/311#issuecomment-612270089.\n-           # This also requires `--pass=build` because we can't execute the tests\n-           # on the `x86_64` host when they're built as `armv5te` binaries.\n-           # (we're only interested in the MIR output, so this doesn't matter)\n-           python2.7 ../x.py test src/test/mir-opt --pass=build \\\n-                                  --target=armv5te-unknown-linux-gnueabi && \\\n-           # Run tidy at the very end, after all the other tests.\n-           python2.7 ../x.py test src/tools/tidy\n-\n-# The purpose of this container isn't to test with debug assertions and\n-# this is run on all PRs, so let's get speedier builds by disabling these extra\n-# checks.\n-ENV NO_DEBUG_ASSERTIONS=1\n-ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "148e09f6ad104c17177b126fcbb9339db907ffc1", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,28 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  libssl-dev \\\n-  sudo \\\n-  xz-utils \\\n-  pkg-config\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-COPY x86_64-gnu-tools/checktools.sh /tmp/\n-\n-# Run rustbook with `linkcheck` feature enabled\n-ENV CHECK_LINKS 1\n-\n-ENV RUST_CONFIGURE_ARGS \\\n-  --build=x86_64-unknown-linux-gnu \\\n-  --save-toolstates=/tmp/toolstate/toolstates.json\n-ENV SCRIPT /tmp/checktools.sh ../x.py"}, {"sha": "502949d5e4c13dc5464b8102833baa2c917e7346", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 86, "deletions": 157, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -37,6 +37,7 @@ x--expand-yaml-anchors--remove:\n   - &public-variables\n     SCCACHE_BUCKET: rust-lang-gha-caches\n     TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n \n   - &prod-variables\n     SCCACHE_BUCKET: rust-lang-gha-caches\n@@ -51,6 +52,7 @@ x--expand-yaml-anchors--remove:\n     # (caches, artifacts...).\n     CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n     ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n \n   - &base-job\n     env: {}\n@@ -70,21 +72,6 @@ x--expand-yaml-anchors--remove:\n   - &step\n     if: success() && !env.SKIP_JOB\n \n-  - &step-run\n-    <<: *step\n-    # While on Linux and macOS builders it just forwards the arguments to the\n-    # system bash, this wrapper allows switching from the host's bash.exe to\n-    # the one we install along with MSYS2 mid-build on Windows.\n-    #\n-    # Once the step to install MSYS2 is executed, the CI_OVERRIDE_SHELL\n-    # environment variable is set pointing to our MSYS2's bash.exe. From that\n-    # moment the host's bash.exe will not be called anymore.\n-    #\n-    # This is needed because we can't launch our own bash.exe from the host\n-    # bash.exe, as that would load two different cygwin1.dll in memory, causing\n-    # \"cygwin heap mismatch\" errors.\n-    shell: python src/ci/exec-with-shell.py {0}\n-\n   - &base-ci-job\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n@@ -114,67 +101,59 @@ x--expand-yaml-anchors--remove:\n           # are passed to the `setup-environment.sh` script encoded in JSON,\n           # which then uses log commands to actually set them.\n           EXTRA_VARIABLES: ${{ toJson(matrix.env) }}\n-        <<: *step-run\n+        <<: *step\n \n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        <<: *step-run\n-\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        <<: *step-run\n-\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        <<: *step-run\n+        <<: *step\n \n       # Disable automatic line ending conversion (again). On Windows, when we're\n       # installing dependencies, something switches the git configuration directory or\n@@ -183,23 +162,23 @@ x--expand-yaml-anchors--remove:\n       # appropriate line endings.\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        <<: *step-run\n+        <<: *step\n \n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n         env:\n           AWS_ACCESS_KEY_ID: ${{ env.CACHES_AWS_ACCESS_KEY_ID }}\n           AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\n           TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\n-        <<: *step-run\n+        <<: *step\n \n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n@@ -212,7 +191,7 @@ x--expand-yaml-anchors--remove:\n         # deploying artifacts from a dist builder if the variables are misconfigured,\n         # erroring about invalid credentials instead.\n         if: success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\n-        <<: *step-run\n+        <<: *step\n \n   # These snippets are used by the try-success, try-failure, auto-success and auto-failure jobs.\n   # Check out their documentation for more information on why they're needed.\n@@ -225,12 +204,14 @@ x--expand-yaml-anchors--remove:\n     steps:\n       - name: mark the job as a success\n         run: exit 0\n+        shell: bash\n     <<: *base-outcome-job\n \n   - &base-failure-job\n     steps:\n       - name: mark the job as a failure\n         run: exit 1\n+        shell: bash\n     <<: *base-outcome-job\n \n ###########################\n@@ -248,6 +229,21 @@ on:\n     branches:\n       - \"**\"\n \n+defaults:\n+  run:\n+    # While on Linux and macOS builders it just forwards the arguments to the\n+    # system bash, this wrapper allows switching from the host's bash.exe to\n+    # the one we install along with MSYS2 mid-build on Windows.\n+    #\n+    # Once the step to install MSYS2 is executed, the CI_OVERRIDE_SHELL\n+    # environment variable is set pointing to our MSYS2's bash.exe. From that\n+    # moment the host's bash.exe will not be called anymore.\n+    #\n+    # This is needed because we can't launch our own bash.exe from the host\n+    # bash.exe, as that would load two different cygwin1.dll in memory, causing\n+    # \"cygwin heap mismatch\" errors.\n+    shell: python src/ci/exec-with-shell.py {0}\n+\n jobs:\n   pr:\n     <<: *base-ci-job\n@@ -257,10 +253,6 @@ jobs:\n     if: github.event_name == 'pull_request'\n     strategy:\n       matrix:\n-        name:\n-          - mingw-check\n-          - x86_64-gnu-llvm-8\n-          - x86_64-gnu-tools\n         include:\n           - name: mingw-check\n             <<: *job-linux-xl\n@@ -281,18 +273,10 @@ jobs:\n     if: github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\n     strategy:\n       matrix:\n-        name:\n-          - dist-x86_64-linux\n-          - dist-x86_64-linux-alt\n         include:\n           - name: dist-x86_64-linux\n             <<: *job-linux-xl\n \n-          - name: dist-x86_64-linux-alt\n-            env:\n-              IMAGE: dist-x86_64-linux\n-            <<: *job-linux-xl\n-\n   auto:\n     <<: *base-ci-job\n     name: auto\n@@ -301,64 +285,6 @@ jobs:\n     if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n     strategy:\n       matrix:\n-        name:\n-          - arm-android\n-          - armhf-gnu\n-          - dist-aarch64-linux\n-          - dist-android\n-          - dist-arm-linux\n-          - dist-armhf-linux\n-          - dist-armv7-linux\n-          - dist-i586-gnu-i586-i686-musl\n-          - dist-i686-freebsd\n-          - dist-i686-linux\n-          - dist-i686-mingw\n-          - dist-i686-msvc\n-          - dist-mips-linux\n-          - dist-mips64-linux\n-          - dist-mips64el-linux\n-          - dist-mipsel-linux\n-          - dist-powerpc-linux\n-          - dist-powerpc64-linux\n-          - dist-powerpc64le-linux\n-          - dist-s390x-linux\n-          - dist-various-1\n-          - dist-various-2\n-          - dist-x86_64-apple\n-          - dist-x86_64-apple-alt\n-          - dist-x86_64-freebsd\n-          - dist-x86_64-linux\n-          - dist-x86_64-linux-alt\n-          - dist-x86_64-mingw\n-          - dist-x86_64-msvc\n-          - dist-x86_64-msvc-alt\n-          - dist-x86_64-musl\n-          - dist-x86_64-netbsd\n-          - i686-gnu\n-          - i686-gnu-nopt\n-          - i686-mingw-1\n-          - i686-mingw-2\n-          - i686-msvc-1\n-          - i686-msvc-2\n-          - mingw-check\n-          - test-various\n-          - wasm32\n-          - x86_64-apple\n-          - x86_64-gnu\n-          - x86_64-gnu-aux\n-          - x86_64-gnu-debug\n-          - x86_64-gnu-distcheck\n-          - x86_64-gnu-full-bootstrap\n-          - x86_64-gnu-llvm-8\n-          - x86_64-gnu-nopt\n-          - x86_64-gnu-tools\n-          - x86_64-mingw-1\n-          - x86_64-mingw-2\n-          - x86_64-msvc-1\n-          - x86_64-msvc-2\n-          - x86_64-msvc-aux\n-          - x86_64-msvc-cargo\n-          - x86_64-msvc-tools\n         include:\n           #############################\n           #   Linux/Docker builders   #\n@@ -484,42 +410,6 @@ jobs:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n             <<: *job-linux-xl\n \n-          ####################\n-          #  macOS Builders  #\n-          ####################\n-\n-          - name: dist-x86_64-apple\n-            env:\n-              SCRIPT: ./x.py dist\n-              RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              DIST_REQUIRE_ALL_TOOLS: 1\n-            <<: *job-macos-xl\n-\n-          - name: dist-x86_64-apple-alt\n-            env:\n-              SCRIPT: ./x.py dist\n-              RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            <<: *job-macos-xl\n-\n-          - name: x86_64-apple\n-            env:\n-              SCRIPT: ./x.py test\n-              RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.8\n-              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            <<: *job-macos-xl\n-\n           ######################\n           #  Windows Builders  #\n           ######################\n@@ -557,16 +447,10 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n             <<: *job-windows-xl\n \n-          - name: x86_64-msvc-aux\n-            env:\n-              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-            <<: *job-windows-xl\n-\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n               VCVARS_BAT: vcvars64.bat\n               # FIXME(#59637)\n               NO_DEBUG_ASSERTIONS: 1\n@@ -575,7 +459,7 @@ jobs:\n \n           - name: x86_64-msvc-tools\n             env:\n-              SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+              SCRIPT: src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n               RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n             <<: *job-windows-xl\n \n@@ -671,6 +555,51 @@ jobs:\n               SCRIPT: python x.py dist\n             <<: *job-windows-xl\n \n+  auto-fallible:\n+    <<: *base-ci-job\n+    name: auto-fallible\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          ####################\n+          #  macOS Builders  #\n+          ####################\n+\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-macos-xl\n+\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: ./x.py test\n+              RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n   master:\n     name: master\n     runs-on: ubuntu-latest\n@@ -687,7 +616,7 @@ jobs:\n         run: src/ci/publish_toolstate.sh\n         env:\n           TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\n-        <<: *step-run\n+        <<: *step\n \n   # These jobs don't actually test anything, but they're used to tell bors the\n   # build completed, as there is no practical way to detect when a workflow is"}, {"sha": "04ca249777a11a55228c5dbb6a94c59254afab20", "filename": "src/ci/scripts/install-innosetup.sh", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fscripts%2Finstall-innosetup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fscripts%2Finstall-innosetup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-innosetup.sh?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,18 +0,0 @@\n-#!/bin/bash\n-# We use InnoSetup and its `iscc` program to also create combined installers.\n-# Honestly at this point WIX above and `iscc` are just holdovers from\n-# oh-so-long-ago and are required for creating installers on Windows. I think\n-# one is MSI installers and one is EXE, but they're not used so frequently at\n-# this point anyway so perhaps it's a wash!\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    curl.exe -o is-install.exe \"${MIRRORS_BASE}/2017-08-22-is.exe\"\n-    cmd.exe //c \"is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\"\n-\n-    ciCommandAddPath \"C:\\\\Program Files (x86)\\\\Inno Setup 5\"\n-fi"}, {"sha": "3874a86e120b18381585ce1ba9fa8320fc1ce5a8", "filename": "src/ci/scripts/install-msys2-packages.sh", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,19 +0,0 @@\n-#!/bin/bash\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar \\\n-        binutils\n-\n-    # Make sure we use the native python interpreter instead of some msys equivalent\n-    # one way or another. The msys interpreters seem to have weird path conversions\n-    # baked in which break LLVM's build system one way or another, so let's use the\n-    # native version which keeps everything as native as possible.\n-    python_home=\"C:/hostedtoolcache/windows/Python/3.7.6/x64\"\n-    cp \"${python_home}/python.exe\" \"${python_home}/python3.exe\"\n-    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.7.6\\\\x64\"\n-fi"}, {"sha": "3a0c965a67710ba45d3e66b5553b50ab83df5c2a", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,28 +1,33 @@\n #!/bin/bash\n # Download and install MSYS2, needed primarily for the test suite (run-make) but\n # also used by the MinGW toolchain for assembling things.\n-#\n-# FIXME: we should probe the default azure image and see if we can use the MSYS2\n-# toolchain there. (if there's even one there). For now though this gets the job\n-# done.\n \n set -euo pipefail\n IFS=$'\\n\\t'\n \n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isWindows; then\n-    # Pre-followed the api/v2 URL to the CDN since the API can be a bit flakey\n-    curl -sSL https://packages.chocolatey.org/msys2.20190524.0.0.20191030.nupkg > \\\n-        msys2.nupkg\n-    curl -sSL https://packages.chocolatey.org/chocolatey-core.extension.1.3.5.1.nupkg > \\\n-        chocolatey-core.extension.nupkg\n-    choco install -s . msys2 \\\n-        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath\" -y --no-progress\n-    rm msys2.nupkg chocolatey-core.extension.nupkg\n-    mkdir -p \"$(ciCheckoutPath)/msys2/home/${USERNAME}\"\n-    ciCommandAddPath \"$(ciCheckoutPath)/msys2/usr/bin\"\n+    msys2Path=\"c:/msys64\"\n+    mkdir -p \"${msys2Path}/home/${USERNAME}\"\n+    ciCommandAddPath \"${msys2Path}/usr/bin\"\n \n     echo \"switching shell to use our own bash\"\n-    ciCommandSetEnv CI_OVERRIDE_SHELL \"$(ciCheckoutPath)/msys2/usr/bin/bash.exe\"\n+    ciCommandSetEnv CI_OVERRIDE_SHELL \"${msys2Path}/usr/bin/bash.exe\"\n+\n+    # Detect the native Python version installed on the agent. On GitHub\n+    # Actions, the C:\\hostedtoolcache\\windows\\Python directory contains a\n+    # subdirectory for each installed Python version.\n+    #\n+    # The -V flag of the sort command sorts the input by version number.\n+    native_python_version=\"$(ls /c/hostedtoolcache/windows/Python | sort -Vr | head -n 1)\"\n+\n+    # Make sure we use the native python interpreter instead of some msys equivalent\n+    # one way or another. The msys interpreters seem to have weird path conversions\n+    # baked in which break LLVM's build system one way or another, so let's use the\n+    # native version which keeps everything as native as possible.\n+    python_home=\"/c/hostedtoolcache/windows/Python/${native_python_version}/x64\"\n+    cp \"${python_home}/python.exe\" \"${python_home}/python3.exe\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\\\\Scripts\"\n fi"}, {"sha": "84a31397b34f9d405df44f2899ff17a4828dba18", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1 +1 @@\n-Subproject commit f5db319e0b19c22964398d56bc63103d669e1bba\n+Subproject commit 84a31397b34f9d405df44f2899ff17a4828dba18"}, {"sha": "82bec5877c77cfad530ca11095db4456d757f668", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1 +1 @@\n-Subproject commit 8204c1d123472cd17f0c1c5c77300ae802eb0271\n+Subproject commit 82bec5877c77cfad530ca11095db4456d757f668"}, {"sha": "94d9ea8460bcbbbfef1877b47cb930260b5849a7", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1 +1 @@\n-Subproject commit 668fb07b6160b9c468f598e839c1e044db65de30\n+Subproject commit 94d9ea8460bcbbbfef1877b47cb930260b5849a7"}, {"sha": "bfe1ab96d717d1dda50e499b360f2e2f57e1750a", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1 +1 @@\n-Subproject commit 6eb24d6e9c0773d4aee68ed5fca121ce3cdf676a\n+Subproject commit bfe1ab96d717d1dda50e499b360f2e2f57e1750a"}, {"sha": "0ea7bc494f1289234d8800bb9185021e0ad946f0", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1 +1 @@\n-Subproject commit 3ce94caed4cf967106c51ae86be5e098f7875f11\n+Subproject commit 0ea7bc494f1289234d8800bb9185021e0ad946f0"}, {"sha": "229c6945a26a53a751ffa4f9cb418388c00029d3", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1 +1 @@\n-Subproject commit c106d1683c3a2b0960f0f0fb01728cbb19807332\n+Subproject commit 229c6945a26a53a751ffa4f9cb418388c00029d3"}, {"sha": "b626923bcb59cfd8ae48872f0bd7cc758a9b8e8a", "filename": "src/doc/rustc-ux-guidelines.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,90 +0,0 @@\n-% Rustc UX guidelines\n-\n-Don't forget the user. Whether human or another program, such as an IDE, a\n-good user experience with the compiler goes a long way toward making developers'\n-lives better. We do not want users to be baffled by compiler output or\n-learn arcane patterns to compile their program.\n-\n-## Error, Warning, Help, Note Messages\n-\n-When the compiler detects a problem, it can emit one of the following: an error, a warning,\n-a note, or a help message.\n-\n-An `error` is emitted when the compiler detects a problem that makes it unable\n- to compile the program, either because the program is invalid or the\n- programmer has decided to make a specific `warning` into an error.\n-\n-A `warning` is emitted when the compiler detects something odd about a\n-program. For instance, dead code and unused `Result` values.\n-\n-A `help` message is emitted following an `error` or `warning` to give additional\n-information to the user about how to solve their problem.\n-\n-A `note` is emitted to identify additional circumstances and parts of the code\n-that caused the warning or error. For example, the borrow checker will note any\n-previous conflicting borrows.\n-\n-* Write in plain simple English. If your message, when shown on a \u2013 possibly\n-small \u2013 screen (which hasn't been cleaned for a while), cannot be understood\n-by a normal programmer, who just came out of bed after a night partying, it's\n-too complex.\n-* `Errors` and `Warnings` should not suggest how to fix the problem. A `Help`\n-message should be emitted instead.\n-* `Error`, `Warning`, `Note`, and `Help` messages start with a lowercase\n-letter and do not end with punctuation.\n-* Error messages should be succinct. Users will see these error messages many\n-times, and more verbose descriptions can be viewed with the `--explain` flag.\n-That said, don't make it so terse that it's hard to understand.\n-* The word \"illegal\" is illegal. Prefer \"invalid\" or a more specific word\n-instead.\n-* Errors should document the span of code where they occur \u2013 the `span_..`\n-methods allow to easily do this. Also `note` other spans that have contributed\n-to the error if the span isn't too large.\n-* When emitting a message with span, try to reduce the span to the smallest\n-amount possible that still signifies the issue\n-* Try not to emit multiple error messages for the same error. This may require\n-detecting duplicates.\n-* When the compiler has too little information for a specific error message,\n-lobby for annotations for library code that allow adding more. For example see\n-`#[on_unimplemented]`. Use these annotations when available!\n-* Keep in mind that Rust's learning curve is rather steep, and that the\n-compiler messages are an important learning tool.\n-\n-## Error Explanations\n-\n-Error explanations are long form descriptions of error messages provided with\n-the compiler. They are accessible via the `--explain` flag. Each explanation\n-comes with an example of how to trigger it and advice on how to fix it.\n-\n-Please read [RFC 1567](https://github.com/rust-lang/rfcs/blob/master/text/1567-long-error-codes-explanation-normalization.md)\n-for details on how to format and write long error codes.\n-\n-* All of them are accessible [online](http://doc.rust-lang.org/error-index.html),\n-  which are auto-generated from rustc source code in different places:\n-  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/error_codes.rs),\n-  [librustc_ast](https://github.com/rust-lang/rust/blob/master/src/librustc_ast/error_codes.rs),\n-  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/error_codes.rs),\n-  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/error_codes.rs),\n-  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/error_codes.rs),\n-  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/error_codes.rs),\n-  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n-  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n-  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n-  [librustc_plugin_impl](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n-  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n-* Explanations have full markdown support. Use it, especially to highlight\n-code with backticks.\n-* When talking about the compiler, call it `the compiler`, not `Rust` or\n-`rustc`.\n-\n-## Compiler Flags\n-\n-* Flags should be orthogonal to each other. For example, if we'd have a\n-json-emitting variant of multiple actions `foo` and `bar`, an additional\n---json flag is better than adding `--foo-json` and `--bar-json`.\n-* Always give options a long descriptive name, if only for more\n-understandable compiler scripts.\n-* The `--verbose` flag is for adding verbose information to `rustc` output\n-when not compiling a program. For example, using it with the `--version` flag\n-gives information about the hashes of the code.\n-* Experimental flags and options must be guarded behind the `-Z unstable-options` flag."}, {"sha": "0b4bb05c1db23e66ead131d085b9ced6d7bf9141", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 328, "deletions": 209, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -7,12 +7,164 @@ a version of this list for your exact compiler by running `rustc -C help`.\n \n This option is deprecated and does nothing.\n \n-## linker\n+## code-model\n \n-This flag controls which linker `rustc` invokes to link your code. It takes a\n-path to the linker executable. If this flag is not specified, the linker will\n-be inferred based on the target. See also the [linker-flavor](#linker-flavor)\n-flag for another way to specify the linker.\n+This option lets you choose which code model to use. \\\n+Code models put constraints on address ranges that the program and its symbols may use. \\\n+With smaller address ranges machine instructions\n+may be able to use use more compact addressing modes.\n+\n+The specific ranges depend on target architectures and addressing modes available to them. \\\n+For x86 more detailed description of its code models can be found in\n+[System V Application Binary Interface](https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf)\n+specification.\n+\n+Supported values for this option are:\n+\n+- `tiny` - Tiny code model.\n+- `small` - Small code model. This is the default model for majority of supported targets.\n+- `kernel` - Kernel code model.\n+- `medium` - Medium code model.\n+- `large` - Large code model.\n+\n+Supported values can also be discovered by running `rustc --print code-models`.\n+\n+## codegen-units\n+\n+This flag controls how many code generation units the crate is split into. It\n+takes an integer greater than 0.\n+\n+When a crate is split into multiple codegen units, LLVM is able to process\n+them in parallel. Increasing parallelism may speed up compile times, but may\n+also produce slower code. Setting this to 1 may improve the performance of\n+generated code, but may be slower to compile.\n+\n+The default value, if not specified, is 16 for non-incremental builds. For\n+incremental builds the default is 256 which allows caching to be more granular.\n+\n+## debug-assertions\n+\n+This flag lets you turn `cfg(debug_assertions)` [conditional\n+compilation](../../reference/conditional-compilation.md#debug_assertions) on\n+or off. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: enable debug-assertions.\n+* `n`, `no`, or `off`: disable debug-assertions.\n+\n+If not specified, debug assertions are automatically enabled only if the\n+[opt-level](#opt-level) is 0.\n+\n+## debuginfo\n+\n+This flag controls the generation of debug information. It takes one of the\n+following values:\n+\n+* `0`: no debug info at all (the default).\n+* `1`: line tables only.\n+* `2`: full debug info.\n+\n+Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n+\n+## default-linker-libraries\n+\n+This flag controls whether or not the linker includes its default libraries.\n+It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: include default libraries (the default).\n+* `n`, `no`, or `off`: exclude default libraries.\n+\n+For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n+the linker.\n+\n+## embed-bitcode\n+\n+This flag controls whether or not the compiler embeds LLVM bitcode into object\n+files. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: put bitcode in rlibs (the default).\n+* `n`, `no`, or `off`: omit bitcode from rlibs.\n+\n+LLVM bitcode is required when rustc is performing link-time optimization (LTO).\n+It is also required on some targets like iOS ones where vendors look for LLVM\n+bitcode. Embedded bitcode will appear in rustc-generated object files inside of\n+a section whose name is defined by the target platform. Most of the time this is\n+`.llvmbc`.\n+\n+The use of `-C embed-bitcode=no` can significantly improve compile times and\n+reduce generated file sizes if your compilation does not actually need bitcode\n+(e.g. if you're not compiling for iOS or you're not performing LTO). For these\n+reasons, Cargo uses `-C embed-bitcode=no` whenever possible. Likewise, if you\n+are building directly with `rustc` we recommend using `-C embed-bitcode=no`\n+whenever you are not using LTO.\n+\n+If combined with `-C lto`, `-C embed-bitcode=no` will cause `rustc` to abort\n+at start-up, because the combination is invalid.\n+\n+> **Note**: if you're building Rust code with LTO then you probably don't even\n+> need the `embed-bitcode` option turned on. You'll likely want to use\n+> `-Clinker-plugin-lto` instead which skips generating object files entirely and\n+> simply replaces object files with LLVM bitcode. The only purpose for\n+> `-Cembed-bitcode` is when you're generating an rlib that is both being used\n+> with and without LTO. For example Rust's standard library ships with embedded\n+> bitcode since users link to it both with and without LTO.\n+>\n+> This also may make you wonder why the default is `yes` for this option. The\n+> reason for that is that it's how it was for rustc 1.44 and prior. In 1.45 this\n+> option was added to turn off what had always been the default.\n+\n+## extra-filename\n+\n+This option allows you to put extra data in each output filename. It takes a\n+string to add as a suffix to the filename. See the [`--emit`\n+flag][option-emit] for more information.\n+\n+## force-frame-pointers\n+\n+This flag forces the use of frame pointers. It takes one of the following\n+values:\n+\n+* `y`, `yes`, `on`, or no value: force-enable frame pointers.\n+* `n`, `no`, or `off`: do not force-enable frame pointers. This does\n+  not necessarily mean frame pointers will be removed.\n+\n+The default behaviour, if frame pointers are not force-enabled, depends on the\n+target.\n+\n+## force-unwind-tables\n+\n+This flag forces the generation of unwind tables. It takes one of the following\n+values:\n+\n+* `y`, `yes`, `on`, or no value: Unwind tables are forced to be generated.\n+* `n`, `no`, or `off`: Unwind tables are not forced to be generated. If unwind\n+  tables are required by the target or `-C panic=unwind`, an error will be\n+  emitted.\n+\n+The default if not specified depends on the target.\n+\n+## incremental\n+\n+This flag allows you to enable incremental compilation, which allows `rustc`\n+to save information after compiling a crate to be reused when recompiling the\n+crate, improving re-compile times. This takes a path to a directory where\n+incremental files will be stored.\n+\n+## inline-threshold\n+\n+This option lets you set the default threshold for inlining a function. It\n+takes an unsigned integer as a value. Inlining is based on a cost model, where\n+a higher threshold will allow more inlining.\n+\n+The default depends on the [opt-level](#opt-level):\n+\n+| opt-level | Threshold |\n+|-----------|-----------|\n+| 0         | N/A, only inlines always-inline functions |\n+| 1         | N/A, only inlines always-inline functions and LLVM lifetime intrinsics |\n+| 2         | 225 |\n+| 3         | 275 |\n+| s         | 75 |\n+| z         | 25 |\n \n ## link-arg\n \n@@ -25,6 +177,24 @@ This flag lets you append a single extra argument to the linker invocation.\n This flag lets you append multiple extra arguments to the linker invocation. The\n options should be separated by spaces.\n \n+## link-dead-code\n+\n+This flag controls whether the linker will keep dead code. It takes one of\n+the following values:\n+\n+* `y`, `yes`, `on`, or no value: keep dead code.\n+* `n`, `no`, or `off`: remove dead code (the default).\n+\n+An example of when this flag might be useful is when trying to construct code coverage\n+metrics.\n+\n+## linker\n+\n+This flag controls which linker `rustc` invokes to link your code. It takes a\n+path to the linker executable. If this flag is not specified, the linker will\n+be inferred based on the target. See also the [linker-flavor](#linker-flavor)\n+flag for another way to specify the linker.\n+\n ## linker-flavor\n \n This flag controls the linker flavor used by `rustc`. If a linker is given with\n@@ -51,16 +221,35 @@ flavor. Valid options are:\n \n [lld-flavor]: https://lld.llvm.org/Driver.html\n \n-## link-dead-code\n+## linker-plugin-lto\n \n-This flag controls whether the linker will keep dead code. It takes one of\n+This flag defers LTO optimizations to the linker. See\n+[linker-plugin-LTO](../linker-plugin-lto.md) for more details. It takes one of\n the following values:\n \n-* `y`, `yes`, `on`, or no value: keep dead code.\n-* `n`, `no`, or `off`: remove dead code (the default).\n+* `y`, `yes`, `on`, or no value: enable linker plugin LTO.\n+* `n`, `no`, or `off`: disable linker plugin LTO (the default).\n+* A path to the linker plugin.\n \n-An example of when this flag might be useful is when trying to construct code coverage\n-metrics.\n+More specifically this flag will cause the compiler to replace its typical\n+object file output with LLVM bitcode files. For example an rlib produced with\n+`-Clinker-plugin-lto` will still have `*.o` files in it, but they'll all be LLVM\n+bitcode instead of actual machine code. It is expected that the native platform\n+linker is capable of loading these LLVM bitcode files and generating code at\n+link time (typically after performing optimizations).\n+\n+Note that rustc can also read its own object files produced with\n+`-Clinker-plugin-lto`. If an rlib is only ever going to get used later with a\n+`-Clto` compilation then you can pass `-Clinker-plugin-lto` to speed up\n+compilation and avoid generating object files that aren't used.\n+\n+## llvm-args\n+\n+This flag can be used to pass a list of arguments directly to LLVM.\n+\n+The list must be separated by spaces.\n+\n+Pass `--help` to see a list of options.\n \n ## lto\n \n@@ -92,78 +281,59 @@ opt-level=0`](#opt-level)). That is:\n \n See also [linker-plugin-lto](#linker-plugin-lto) for cross-language LTO.\n \n-## linker-plugin-lto\n-\n-This flag defers LTO optimizations to the linker. See\n-[linker-plugin-LTO](../linker-plugin-lto.md) for more details. It takes one of\n-the following values:\n-\n-* `y`, `yes`, `on`, or no value: enable linker plugin LTO.\n-* `n`, `no`, or `off`: disable linker plugin LTO (the default).\n-* A path to the linker plugin.\n-\n-## target-cpu\n-\n-This instructs `rustc` to generate code specifically for a particular processor.\n-\n-You can run `rustc --print target-cpus` to see the valid options to pass\n-here. Additionally, `native` can be passed to use the processor of the host\n-machine. Each target has a default base CPU.\n-\n-## target-feature\n-\n-Individual targets will support different features; this flag lets you control\n-enabling or disabling a feature. Each feature should be prefixed with a `+` to\n-enable it or `-` to disable it. Separate multiple features with commas.\n-\n-To see the valid options and an example of use, run `rustc --print\n-target-features`.\n+## metadata\n \n-Using this flag is unsafe and might result in [undefined runtime\n-behavior](../targets/known-issues.md).\n+This option allows you to control the metadata used for symbol mangling. This\n+takes a space-separated list of strings. Mangled symbols will incorporate a\n+hash of the metadata. This may be used, for example, to differentiate symbols\n+between two different versions of the same crate being linked.\n \n-See also the [`target_feature`\n-attribute](../../reference/attributes/codegen.md#the-target_feature-attribute)\n-for controlling features per-function.\n+## no-prepopulate-passes\n \n-This also supports the feature `+crt-static` and `-crt-static` to control\n-[static C runtime linkage](../../reference/linkage.html#static-and-dynamic-c-runtimes).\n+This flag tells the pass manager to use an empty list of passes, instead of the\n+usual pre-populated list of passes.\n \n-Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n-features.\n+## no-redzone\n \n-## passes\n+This flag allows you to disable [the\n+red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). It takes one\n+of the following values:\n \n-This flag can be used to add extra [LLVM\n-passes](http://llvm.org/docs/Passes.html) to the compilation.\n+* `y`, `yes`, `on`, or no value: disable the red zone.\n+* `n`, `no`, or `off`: enable the red zone.\n \n-The list must be separated by spaces.\n+The default behaviour, if the flag is not specified, depends on the target.\n \n-See also the [`no-prepopulate-passes`](#no-prepopulate-passes) flag.\n+## no-stack-check\n \n-## llvm-args\n+This option is deprecated and does nothing.\n \n-This flag can be used to pass a list of arguments directly to LLVM.\n+## no-vectorize-loops\n \n-The list must be separated by spaces.\n+This flag disables [loop\n+vectorization](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer).\n \n-Pass `--help` to see a list of options.\n+## no-vectorize-slp\n \n-## save-temps\n+This flag disables vectorization using\n+[superword-level\n+parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer).\n \n-This flag controls whether temporary files generated during compilation are\n-deleted once compilation finishes. It takes one of the following values:\n+## opt-level\n \n-* `y`, `yes`, `on`, or no value: save temporary files.\n-* `n`, `no`, or `off`: delete temporary files (the default).\n+This flag controls the optimization level.\n \n-## rpath\n+* `0`: no optimizations, also turns on\n+  [`cfg(debug_assertions)`](#debug-assertions) (the default).\n+* `1`: basic optimizations.\n+* `2`: some optimizations.\n+* `3`: all optimizations.\n+* `s`: optimize for binary size.\n+* `z`: optimize for binary size, but also turn off loop vectorization.\n \n-This flag controls whether [`rpath`](https://en.wikipedia.org/wiki/Rpath) is\n-enabled. It takes one of the following values:\n+Note: The [`-O` flag][option-o-optimize] is an alias for `-C opt-level=2`.\n \n-* `y`, `yes`, `on`, or no value: enable rpath.\n-* `n`, `no`, or `off`: disable rpath (the default).\n+The default is `0`.\n \n ## overflow-checks\n \n@@ -178,29 +348,23 @@ one of the following values:\n If not specified, overflow checks are enabled if\n [debug-assertions](#debug-assertions) are enabled, disabled otherwise.\n \n-## no-prepopulate-passes\n-\n-This flag tells the pass manager to use an empty list of passes, instead of the\n-usual pre-populated list of passes.\n+## panic\n \n-## no-vectorize-loops\n+This option lets you control what happens when the code panics.\n \n-This flag disables [loop\n-vectorization](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer).\n+* `abort`: terminate the process upon panic\n+* `unwind`: unwind the stack upon panic\n \n-## no-vectorize-slp\n+If not specified, the default depends on the target.\n \n-This flag disables vectorization using\n-[superword-level\n-parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer).\n+## passes\n \n-## soft-float\n+This flag can be used to add extra [LLVM\n+passes](http://llvm.org/docs/Passes.html) to the compilation.\n \n-This option controls whether `rustc` generates code that emulates floating\n-point instructions in software. It takes one of the following values:\n+The list must be separated by spaces.\n \n-* `y`, `yes`, `on`, or no value: use soft floats.\n-* `n`, `no`, or `off`: use hardware floats (the default).\n+See also the [`no-prepopulate-passes`](#no-prepopulate-passes) flag.\n \n ## prefer-dynamic\n \n@@ -214,56 +378,63 @@ linkage. This flag takes one of the following values:\n * `y`, `yes`, `on`, or no value: use dynamic linking.\n * `n`, `no`, or `off`: use static linking (the default).\n \n-## no-redzone\n+## profile-generate\n \n-This flag allows you to disable [the\n-red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). It takes one\n-of the following values:\n+This flag allows for creating instrumented binaries that will collect\n+profiling data for use with profile-guided optimization (PGO). The flag takes\n+an optional argument which is the path to a directory into which the\n+instrumented binary will emit the collected data. See the chapter on\n+[profile-guided optimization] for more information.\n \n-* `y`, `yes`, `on`, or no value: disable the red zone.\n-* `n`, `no`, or `off`: enable the red zone.\n+## profile-use\n \n-The default behaviour, if the flag is not specified, depends on the target.\n+This flag specifies the profiling data file to be used for profile-guided\n+optimization (PGO). The flag takes a mandatory argument which is the path\n+to a valid `.profdata` file. See the chapter on\n+[profile-guided optimization] for more information.\n \n ## relocation-model\n \n-This option lets you choose which\n-[relocation](https://en.wikipedia.org/wiki/Relocation_\\(computing\\)) model to\n-use.\n+This option controls generation of\n+[position-independent code (PIC)](https://en.wikipedia.org/wiki/Position-independent_code).\n \n-To find the valid options for this flag, run `rustc --print relocation-models`.\n+Supported values for this option are:\n \n-## code-model\n+#### Primary relocation models\n \n-This option lets you choose which code model to use.\n+- `static` - non-relocatable code, machine instructions may use absolute addressing modes.\n \n-To find the valid options for this flag, run `rustc --print code-models`.\n+- `pic` - fully relocatable position independent code,\n+machine instructions need to use relative addressing modes.  \\\n+Equivalent to the \"uppercase\" `-fPIC` or `-fPIE` options in other compilers,\n+depending on the produced crate types.  \\\n+This is the default model for majority of supported targets.\n \n-## metadata\n+#### Special relocation models\n \n-This option allows you to control the metadata used for symbol mangling. This\n-takes a space-separated list of strings. Mangled symbols will incorporate a\n-hash of the metadata. This may be used, for example, to differentiate symbols\n-between two different versions of the same crate being linked.\n+- `dynamic-no-pic` - relocatable external references, non-relocatable code.  \\\n+Only makes sense on Darwin and is rarely used.  \\\n+If StackOverflow tells you to use this as an opt-out of PIC or PIE, don't believe it,\n+use `-C relocation-model=static` instead.\n+- `ropi`, `rwpi` and `ropi-rwpi` - relocatable code and read-only data, relocatable read-write data,\n+and combination of both, respectively.  \\\n+Only makes sense for certain embedded ARM targets.\n+- `default` - relocation model default to the current target.  \\\n+Only makes sense as an override for some other explicitly specified relocation model\n+previously set on the command line.\n \n-## extra-filename\n+Supported values can also be discovered by running `rustc --print relocation-models`.\n \n-This option allows you to put extra data in each output filename. It takes a\n-string to add as a suffix to the filename. See the [`--emit`\n-flag][option-emit] for more information.\n+#### Linking effects\n \n-## codegen-units\n+In addition to codegen effects, `relocation-model` has effects during linking.\n \n-This flag controls how many code generation units the crate is split into. It\n-takes an integer greater than 0.\n-\n-When a crate is split into multiple codegen units, LLVM is able to process\n-them in parallel. Increasing parallelism may speed up compile times, but may\n-also produce slower code. Setting this to 1 may improve the performance of\n-generated code, but may be slower to compile.\n-\n-The default value, if not specified, is 16 for non-incremental builds. For\n-incremental builds the default is 256 which allows caching to be more granular.\n+If the relocation model is `pic` and the current target supports position-independent executables\n+(PIE), the linker will be instructed (`-pie`) to produce one.  \\\n+If the target doesn't support both position-independent and statically linked executables,\n+then `-C target-feature=+crt-static` \"wins\" over `-C relocation-model=pic`,\n+and the linker is instructed (`-static`) to produce a statically linked\n+but not position-independent executable.\n \n ## remark\n \n@@ -273,119 +444,67 @@ The list of passes should be separated by spaces.\n \n `all` will remark on every pass.\n \n-## no-stack-check\n-\n-This option is deprecated and does nothing.\n-\n-## debuginfo\n-\n-This flag controls the generation of debug information. It takes one of the\n-following values:\n-\n-* `0`: no debug info at all (the default).\n-* `1`: line tables only.\n-* `2`: full debug info.\n-\n-Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n-\n-## opt-level\n-\n-This flag controls the optimization level.\n-\n-* `0`: no optimizations, also turns on\n-  [`cfg(debug_assertions)`](#debug-assertions) (the default).\n-* `1`: basic optimizations.\n-* `2`: some optimizations.\n-* `3`: all optimizations.\n-* `s`: optimize for binary size.\n-* `z`: optimize for binary size, but also turn off loop vectorization.\n-\n-Note: The [`-O` flag][option-o-optimize] is an alias for `-C opt-level=2`.\n-\n-The default is `0`.\n-\n-## debug-assertions\n-\n-This flag lets you turn `cfg(debug_assertions)` [conditional\n-compilation](../../reference/conditional-compilation.md#debug_assertions) on\n-or off. It takes one of the following values:\n-\n-* `y`, `yes`, `on`, or no value: enable debug-assertions.\n-* `n`, `no`, or `off`: disable debug-assertions.\n-\n-If not specified, debug assertions are automatically enabled only if the\n-[opt-level](#opt-level) is 0.\n-\n-## inline-threshold\n-\n-This option lets you set the default threshold for inlining a function. It\n-takes an unsigned integer as a value. Inlining is based on a cost model, where\n-a higher threshold will allow more inlining.\n-\n-The default depends on the [opt-level](#opt-level):\n+## rpath\n \n-| opt-level | Threshold |\n-|-----------|-----------|\n-| 0         | N/A, only inlines always-inline functions |\n-| 1         | N/A, only inlines always-inline functions and LLVM lifetime intrinsics |\n-| 2         | 225 |\n-| 3         | 275 |\n-| s         | 75 |\n-| z         | 25 |\n+This flag controls whether [`rpath`](https://en.wikipedia.org/wiki/Rpath) is\n+enabled. It takes one of the following values:\n \n-## panic\n+* `y`, `yes`, `on`, or no value: enable rpath.\n+* `n`, `no`, or `off`: disable rpath (the default).\n \n-This option lets you control what happens when the code panics.\n+## save-temps\n \n-* `abort`: terminate the process upon panic\n-* `unwind`: unwind the stack upon panic\n+This flag controls whether temporary files generated during compilation are\n+deleted once compilation finishes. It takes one of the following values:\n \n-If not specified, the default depends on the target.\n+* `y`, `yes`, `on`, or no value: save temporary files.\n+* `n`, `no`, or `off`: delete temporary files (the default).\n \n-## incremental\n+## soft-float\n \n-This flag allows you to enable incremental compilation, which allows `rustc`\n-to save information after compiling a crate to be reused when recompiling the\n-crate, improving re-compile times. This takes a path to a directory where\n-incremental files will be stored.\n+This option controls whether `rustc` generates code that emulates floating\n+point instructions in software. It takes one of the following values:\n \n-## profile-generate\n+* `y`, `yes`, `on`, or no value: use soft floats.\n+* `n`, `no`, or `off`: use hardware floats (the default).\n \n-This flag allows for creating instrumented binaries that will collect\n-profiling data for use with profile-guided optimization (PGO). The flag takes\n-an optional argument which is the path to a directory into which the\n-instrumented binary will emit the collected data. See the chapter on\n-[profile-guided optimization] for more information.\n+## target-cpu\n \n-## profile-use\n+This instructs `rustc` to generate code specifically for a particular processor.\n \n-This flag specifies the profiling data file to be used for profile-guided\n-optimization (PGO). The flag takes a mandatory argument which is the path\n-to a valid `.profdata` file. See the chapter on\n-[profile-guided optimization] for more information.\n+You can run `rustc --print target-cpus` to see the valid options to pass\n+here. Additionally, `native` can be passed to use the processor of the host\n+machine. Each target has a default base CPU.\n \n-## force-frame-pointers\n+## target-feature\n \n-This flag forces the use of frame pointers. It takes one of the following\n-values:\n+Individual targets will support different features; this flag lets you control\n+enabling or disabling a feature. Each feature should be prefixed with a `+` to\n+enable it or `-` to disable it.\n \n-* `y`, `yes`, `on`, or no value: force-enable frame pointers.\n-* `n`, `no`, or `off`: do not force-enable frame pointers. This does\n-  not necessarily mean frame pointers will be removed.\n+Features from multiple `-C target-feature` options are combined. \\\n+Multiple features can be specified in a single option by separating them\n+with commas - `-C target-feature=+x,-y`. \\\n+If some feature is specified more than once with both `+` and `-`,\n+then values passed later override values passed earlier. \\\n+For example, `-C target-feature=+x,-y,+z -Ctarget-feature=-x,+y`\n+is equivalent to `-C target-feature=-x,+y,+z`.\n \n-The default behaviour, if frame pointers are not force-enabled, depends on the\n-target.\n+To see the valid options and an example of use, run `rustc --print\n+target-features`.\n \n-## default-linker-libraries\n+Using this flag is unsafe and might result in [undefined runtime\n+behavior](../targets/known-issues.md).\n \n-This flag controls whether or not the linker includes its default libraries.\n-It takes one of the following values:\n+See also the [`target_feature`\n+attribute](../../reference/attributes/codegen.md#the-target_feature-attribute)\n+for controlling features per-function.\n \n-* `y`, `yes`, `on`, or no value: include default libraries (the default).\n-* `n`, `no`, or `off`: exclude default libraries.\n+This also supports the feature `+crt-static` and `-crt-static` to control\n+[static C runtime linkage](../../reference/linkage.html#static-and-dynamic-c-runtimes).\n \n-For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n-the linker.\n+Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n+features.\n \n [option-emit]: ../command-line-arguments.md#option-emit\n [option-o-optimize]: ../command-line-arguments.md#option-o-optimize"}, {"sha": "30b18eb56a1256c0d011ce58c7f0a200e8985014", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -273,10 +273,18 @@ This flag, when combined with other flags, makes them produce extra output.\n This flag allows you to pass the name and location for an external crate of a\n direct dependency. Indirect dependencies (dependencies of dependencies) are\n located using the [`-L` flag](#option-l-search-path). The given crate name is\n-added to the [extern prelude], which is the same as specifying `extern crate`\n-within the root module. The given crate name does not need to match the name\n+added to the [extern prelude], similar to specifying `extern crate` within the\n+root module. The given crate name does not need to match the name\n the library was built with.\n \n+Specifying `--extern` has one behavior difference from `extern crate`:\n+`--extern` merely makes the crate a _candidate_ for being linked; it does not\n+actually link it unless it's actively used. In rare occasions you may wish\n+to ensure a crate is linked even if you don't actively use it from your\n+code: for example, if it changes the global allocator or if it contains\n+`#[no_mangle]` symbols for use by other programming languages. In such\n+cases you'll need to use `extern crate`.\n+\n This flag may be specified multiple times. This flag takes an argument with\n either of the following formats:\n "}, {"sha": "c0b14352b7d1a6be4dacb64f0c05188db98d0b4a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -100,11 +100,17 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           |  Clang 7  |  Clang 8  |\n-|-----------|-----------|-----------|\n-| Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |     \u2713     |\n-| Rust 1.36 |     \u2717     |     \u2713     |\n-| Rust 1.37 |     \u2717     |     \u2713     |\n+|           |  Clang 7  |  Clang 8  |  Clang 9  |\n+|-----------|-----------|-----------|-----------|\n+| Rust 1.34 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.35 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.36 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.37 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.38 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.39 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.40 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.41 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.42 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.43 |     \u2717     |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "18010bebcf0e773315655165328e48cd1be793d9", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -416,7 +416,7 @@ without including it in your main documentation. For example, you could write th\n `lib.rs` to test your README as part of your doctests:\n \n ```rust,ignore\n-#![feature(extern_doc)]\n+#![feature(external_doc)]\n \n #[doc(include=\"../README.md\")]\n #[cfg(doctest)]"}, {"sha": "081e477de8010ce0db928b68d7fec560c4a1bba9", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -17,7 +17,7 @@ By default, rustdoc will run some passes, namely:\n * `collapse-docs`\n * `unindent-comments`\n \n-However, `strip-private` implies `strip-private-imports`, and so effectively,\n+However, `strip-private` implies `strip-priv-imports`, and so effectively,\n all passes are run by default.\n \n ## `strip-hidden`"}, {"sha": "eea674f2b84b9193d16322cff968cfb5b285d798", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -38,50 +38,62 @@ future.\n Attempting to use these error numbers on stable will result in the code sample being interpreted as\n plain text.\n \n-### Linking to items by type\n+### Linking to items by name\n \n-As designed in [RFC 1946], Rustdoc can parse paths to items when you use them as links. To resolve\n-these type names, it uses the items currently in-scope, either by declaration or by `use` statement.\n-For modules, the \"active scope\" depends on whether the documentation is written outside the module\n-(as `///` comments on the `mod` statement) or inside the module (at `//!` comments inside the file\n-or block). For all other items, it uses the enclosing module's scope.\n+Rustdoc is capable of directly linking to other rustdoc pages in Markdown documentation using the path of item as a link.\n \n-[RFC 1946]: https://github.com/rust-lang/rfcs/pull/1946\n-\n-For example, in the following code:\n+For example, in the following code all of the links will link to the rustdoc page for `Bar`:\n \n ```rust\n-/// Does the thing.\n-pub fn do_the_thing(_: SomeType) {\n-    println!(\"Let's do the thing!\");\n-}\n+/// This struct is not [Bar]\n+pub struct Foo1;\n+\n+/// This struct is also not [bar](Bar)\n+pub struct Foo2;\n+\n+/// This struct is also not [bar][b]\n+///\n+/// [b]: Bar\n+pub struct Foo3;\n+\n+/// This struct is also not [`Bar`]\n+pub struct Foo4;\n \n-/// Token you use to [`do_the_thing`].\n-pub struct SomeType;\n+pub struct Bar;\n ```\n \n-The link to ``[`do_the_thing`]`` in `SomeType`'s docs will properly link to the page for `fn\n-do_the_thing`. Note that here, rustdoc will insert the link target for you, but manually writing the\n-target out also works:\n+You can refer to anything in scope, and use paths, including `Self`. You may also use `foo()` and `foo!()` to refer to methods/functions and macros respectively.\n \n-```rust\n-pub mod some_module {\n-    /// Token you use to do the thing.\n-    pub struct SomeStruct;\n-}\n+```rust,edition2018\n+use std::sync::mpsc::Receiver;\n \n-/// Does the thing. Requires one [`SomeStruct`] for the thing to work.\n+/// This is an version of [`Receiver`], with support for [`std::future`].\n ///\n-/// [`SomeStruct`]: some_module::SomeStruct\n-pub fn do_the_thing(_: some_module::SomeStruct) {\n-    println!(\"Let's do the thing!\");\n+/// You can obtain a [`std::future::Future`] by calling [`Self::recv()`].\n+pub struct AsyncReceiver<T> {\n+    sender: Receiver<T>\n+}\n+\n+impl<T> AsyncReceiver<T> {\n+    pub async fn recv() -> T {\n+        unimplemented!()\n+    }\n }\n ```\n \n-For more details, check out [the RFC][RFC 1946], and see [the tracking issue][43466] for more\n-information about what parts of the feature are available.\n+Paths in Rust have three namespaces: type, value, and macro. Items from these namespaces are allowed to overlap. In case of ambiguity, rustdoc will warn about the ambiguity and ask you to disambiguate, which can be done by using a prefix like `struct@`, `enum@`, `type@`, `trait@`, `union@`, `const@`, `static@`, `value@`, `function@`, `mod@`, `fn@`, `module@`, `method@` , `macro@`, or `derive@`:\n+\n+```rust\n+/// See also: [`Foo`](struct@Foo)\n+struct Bar;\n+\n+/// This is different from [`Foo`](fn@Foo)\n+struct Foo {}\n+\n+fn Foo() {}\n+```\n \n-[43466]: https://github.com/rust-lang/rust/issues/43466\n+Note: Because of how `macro_rules` macros are scoped in Rust, the intra-doc links of a `macro_rules` macro will be resolved relative to the crate root, as opposed to the module it is defined in.\n \n ## Extensions to the `#[doc]` attribute\n \n@@ -321,7 +333,7 @@ library, as an equivalent command-line argument is provided to `rustc` when buil\n ### `--index-page`: provide a top-level landing page for docs\n \n This feature allows you to generate an index-page with a given markdown file. A good example of it\n-is the [rust documentation index](https://doc.rust-lang.org/index.html).\n+is the [rust documentation index](https://doc.rust-lang.org/nightly/index.html).\n \n With this, you'll have a page which you can custom as much as you want at the top of your crates.\n "}, {"sha": "4115825e920838947ab4dee93124a1811980daaf", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,33 +1,57 @@\n-# `control_flow_guard`\n+# `control-flow-guard`\n \n The tracking issue for this feature is: [#68793](https://github.com/rust-lang/rust/issues/68793).\n \n ------------------------\n \n-The `-Zcontrol_flow_guard=checks` compiler flag enables the Windows [Control Flow Guard][cfguard-docs] platform security feature. When enabled, the compiler outputs a list of valid indirect call targets, and inserts runtime checks on all indirect jump instructions to ensure that the destination is in the list of valid call targets.\n+The rustc flag `-Z control-flow-guard` enables the Windows [Control Flow Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard) (CFG) platform security feature.\n \n-[cfguard-docs]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported Windows platforms (Windows 8.1 onwards). Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete. \n \n-For testing purposes, the `-Zcontrol_flow_guard=nochecks` compiler flag can be used to emit only the list of valid call targets, but not the runtime checks.\n+During compilation, the compiler identifies all indirect calls/jumps and adds CFG checks. It also emits metadata containing the relative addresses of all address-taken functions. At runtime, if the binary is run on a CFG-aware operating system, the loader uses the CFG metadata to generate a bitmap of the address space and marks those addresses that contain valid targets. On each indirect call, the inserted check determines whether the target address is marked in this bitmap. If the target is not valid, the process is terminated.\n \n-It is strongly recommended to also enable Control Flow Guard checks in all linked libraries, including the standard library. \n+In terms of interoperability:\n+- Code compiled with CFG enabled can be linked with libraries and object files that are not compiled with CFG. In this case, a CFG-aware linker can identify address-taken functions in the non-CFG libraries.\n+- Libraries compiled with CFG can linked into non-CFG programs. In this case, the CFG runtime checks in the libraries are not used (i.e. the mitigation is completely disabled).\n \n-To enable Control Flow Guard in the standard library, you can use the [cargo `-Zbuild-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program. \n+CFG functionality is completely implemented in the LLVM backend and is supported for X86 (32-bit and 64-bit), ARM, and Aarch64 targets. The rustc flag adds the relevant LLVM module flags to enable the feature. This flag will be ignored for all non-Windows targets.\n+\n+\n+## When to use Control Flow Guard\n+\n+The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the `unsafe` keyword\n+\n+\n+## Overhead of Control Flow Guard\n+\n+The CFG checks and metadata can potentially increase binary size and runtime overhead. The magnitude of any increase depends on the number and frequency of indirect calls. For example, enabling CFG for the Rust standard library increases binary size by approximately 0.14%. Enabling CFG in the SPEC CPU 2017 Integer Speed benchmark suite (compiled with Clang/LLVM) incurs approximate runtime overheads of between 0% and 8%, with a geometric mean of 2.9%.\n+\n+\n+## Testing Control Flow Guard\n+\n+The rustc flag `-Z control-flow-guard=nochecks` instructs LLVM to emit the list of valid call targets without inserting runtime checks. This flag should only be used for testing purposes as it does not provide security enforcement.\n+\n+\n+## Control Flow Guard in libraries\n+\n+It is strongly recommended to also enable CFG checks for all linked libraries, including the standard library. \n+\n+To enable CFG in the standard library, use the [cargo `-Z build-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program.\n \n [build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n \n For example:\n ```cmd\n rustup toolchain install --force nightly\n rustup component add rust-src\n-SET RUSTFLAGS=-Zcontrol_flow_guard=checks\n+SET RUSTFLAGS=-Z control-flow-guard\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n \n ```PowerShell\n rustup toolchain install --force nightly\n rustup component add rust-src\n-$Env:RUSTFLAGS = \"-Zcontrol_flow_guard=checks\"\n+$Env:RUSTFLAGS = \"-Z control-flow-guard\"\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n "}, {"sha": "7973b3e4f2f322ad40bd1bcea87f85742de9e193", "filename": "src/doc/unstable-book/src/compiler-flags/profile.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -12,10 +12,16 @@ For example:\n ```Bash\n cargo new testgcov --bin\n cd testgcov\n-export RUSTFLAGS=\"-Zprofile\"\n+export RUSTFLAGS=\"-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort\"\n+export CARGO_INCREMENTAL=0\n cargo build\n cargo run\n ```\n \n Once you've built and run your program, files with the `gcno` (after build) and `gcda` (after execution) extensions will be created.\n You can parse them with [llvm-cov gcov](https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/mozilla/grcov).\n+\n+Please note that `RUSTFLAGS` by default applies to everything that cargo builds and runs during a build!\n+When the `--target` flag is explicitly passed to cargo, the `RUSTFLAGS` no longer apply to build scripts and procedural macros. \n+For more fine-grained control consider passing a `RUSTC_WRAPPER` program to cargo that only adds the profiling flags to \n+rustc for the specific crates you want to profile."}, {"sha": "68265d8a9e8108562776d0319f30fa2aadb79d14", "filename": "src/doc/unstable-book/src/compiler-flags/report-time.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -22,7 +22,7 @@ Available options:\n \n ```sh\n --report-time [plain|colored]\n-                Show execution time of each test. Awailable values:\n+                Show execution time of each test. Available values:\n                 plain = do not colorize the execution time (default);\n                 colored = colorize output according to the `color`\n                 parameter value;"}, {"sha": "5e2e04c063bc483abff4700462958c6791e9573a", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -12,8 +12,7 @@ This feature allows for use of one of following sanitizers:\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n To enable a sanitizer compile with `-Zsanitizer=address`, `-Zsanitizer=leak`,\n-`-Zsanitizer=memory` or `-Zsanitizer=thread`. Only a single sanitizer can be\n-enabled at a time.\n+`-Zsanitizer=memory` or `-Zsanitizer=thread`.\n \n # AddressSanitizer\n "}, {"sha": "7305141a427146ada0c2361245e863ac60fda507", "filename": "src/doc/unstable-book/src/compiler-flags/self-profile.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -13,7 +13,7 @@ For example:\n First, run a compilation session and provide the `-Zself-profile` flag:\n \n ```console\n-$ rustc --crate-name foo -Zself-profile`\n+$ rustc --crate-name foo -Zself-profile\n ```\n \n This will generate three files in the working directory such as:"}, {"sha": "52cb98113c0c13296221f34d0daa6bfee04231cf", "filename": "src/doc/unstable-book/src/compiler-flags/strip.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,17 @@\n+# `strip`\n+\n+The tracking issue for this feature is: [#72110](https://github.com/rust-lang/rust/issues/72110).\n+\n+------------------------\n+\n+Option `-Z strip=val` controls stripping of debuginfo and similar auxiliary data from binaries\n+during linking.\n+\n+Supported values for this option are:\n+\n+- `none` - debuginfo and symbols (if they exist) are copied to the produced binary or separate files\n+depending on the target (e.g. `.pdb` files in case of MSVC).\n+- `debuginfo` - debuginfo sections and debuginfo symbols from the symbol table section\n+are stripped at link time and are not copied to the produced binary or separate files.\n+- `symbols` - same as `debuginfo`, but the rest of the symbol table section is stripped as well\n+if the linker supports it."}, {"sha": "0aefaa7fb01773794d5ca522ab18952ea8bc79cb", "filename": "src/doc/unstable-book/src/compiler-flags/tls-model.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,25 @@\n+# `tls_model`\n+\n+The tracking issue for this feature is: None.\n+\n+------------------------\n+\n+Option `-Z tls-model` controls [TLS model](https://www.akkadia.org/drepper/tls.pdf) used to\n+generate code for accessing `#[thread_local]` `static` items.\n+\n+Supported values for this option are:\n+\n+- `global-dynamic` - General Dynamic TLS Model (alternatively called Global Dynamic) is the most\n+general option usable in all circumstances, even if the TLS data is defined in a shared library\n+loaded at runtime and is accessed from code outside of that library.  \n+This is the default for most targets.\n+- `local-dynamic` - model usable if the TLS data is only accessed from the shared library or\n+executable it is defined in. The TLS data may be in a library loaded after startup (via `dlopen`).\n+- `initial-exec` - model usable if the TLS data is defined in the executable or in a shared library\n+loaded at program startup.\n+The TLS data must not be in a library loaded after startup (via `dlopen`).\n+- `local-exec` - model usable only if the TLS data is defined directly in the executable,\n+but not in a shared library, and is accessed only from that executable.\n+\n+`rustc` and LLVM may use a more optimized model than specified if they know that we are producing\n+and executable rather than a library, or that the `static` item is private enough."}, {"sha": "3442abf46df86cae98e4a85482b84b5d37caa2c9", "filename": "src/doc/unstable-book/src/language-features/cfg-sanitize.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -11,26 +11,24 @@ depending on whether a particular sanitizer is enabled or not.\n \n ## Examples\n \n-``` rust\n+```rust\n #![feature(cfg_sanitize)]\n \n #[cfg(sanitize = \"thread\")]\n fn a() {\n-  // ...\n+    // ...\n }\n \n #[cfg(not(sanitize = \"thread\"))]\n fn a() {\n-  // ...\n+    // ...\n }\n \n fn b() {\n-  if cfg!(sanitize = \"leak\") {\n-    // ...\n-  } else {\n-    // ...\n-  }\n+    if cfg!(sanitize = \"leak\") {\n+        // ...\n+    } else {\n+        // ...\n+    }\n }\n-\n ```\n-"}, {"sha": "2b1e50835b7676ace00a28da09b1fdf041113f07", "filename": "src/doc/unstable-book/src/language-features/cfg-version.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,34 @@\n+# `cfg_version`\n+\n+The tracking issue for this feature is: [#64796]\n+\n+[#64796]: https://github.com/rust-lang/rust/issues/64796\n+\n+------------------------\n+\n+The `cfg_version` feature makes it possible to execute different code\n+depending on the compiler version.\n+\n+## Examples\n+\n+```rust\n+#![feature(cfg_version)]\n+\n+#[cfg(version(\"1.42\"))]\n+fn a() {\n+    // ...\n+}\n+\n+#[cfg(not(version(\"1.42\")))]\n+fn a() {\n+    // ...\n+}\n+\n+fn b() {\n+    if cfg!(version(\"1.42\")) {\n+        // ...\n+    } else {\n+        // ...\n+    }\n+}\n+```"}, {"sha": "ee9cfcbd9dee2b9acf73b428f4ac6b0afd36dd4f", "filename": "src/doc/unstable-book/src/language-features/const-if-match.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-if-match.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-if-match.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-if-match.md?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,14 +0,0 @@\n-# `const_if_match`\n-\n-The tracking issue for this feature is: [#49146]\n-\n-[#49146]: https://github.com/rust-lang/rust/issues/49146\n-\n-------------------------\n-\n-Allows for the use of conditionals (`if` and `match`) in a const context.\n-Const contexts include `static`, `static mut`, `const`, `const fn`, const\n-generics, and array initializers. Enabling this feature flag will also make\n-`&&` and `||` function normally in a const-context by removing the hack that\n-replaces them with their non-short-circuiting equivalents, `&` and `|`, in a\n-`const` or `static`."}, {"sha": "9a1ced4033b2201772943a47a642d854bc04e8e2", "filename": "src/doc/unstable-book/src/language-features/ffi-const.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,47 @@\n+# `ffi_const`\n+\n+The `#[ffi_const]` attribute applies clang's `const` attribute to foreign\n+functions declarations.\n+\n+That is, `#[ffi_const]` functions shall have no effects except for its return\n+value, which can only depend on the values of the function parameters, and is\n+not affected by changes to the observable state of the program.\n+\n+Applying the `#[ffi_const]` attribute to a function that violates these\n+requirements is undefined behaviour.\n+\n+This attribute enables Rust to perform common optimizations, like sub-expression\n+elimination, and it can avoid emitting some calls in repeated invocations of the\n+function with the same argument values regardless of other operations being\n+performed in between these functions calls (as opposed to `#[ffi_pure]`\n+functions).\n+\n+## Pitfalls\n+\n+A `#[ffi_const]` function can only read global memory that would not affect\n+its return value for the whole execution of the program (e.g. immutable global\n+memory). `#[ffi_const]` functions are referentially-transparent and therefore\n+more strict than `#[ffi_pure]` functions.\n+\n+A common pitfall involves applying the `#[ffi_const]` attribute to a\n+function that reads memory through pointer arguments which do not necessarily\n+point to immutable global memory.\n+\n+A `#[ffi_const]` function that returns unit has no effect on the abstract\n+machine's state, and a `#[ffi_const]` function cannot be `#[ffi_pure]`.\n+\n+A `#[ffi_const]` function must not diverge, neither via a side effect (e.g. a\n+call to `abort`) nor by infinite loops.\n+\n+When translating C headers to Rust FFI, it is worth verifying for which targets\n+the `const` attribute is enabled in those headers, and using the appropriate\n+`cfg` macros in the Rust side to match those definitions. While the semantics of\n+`const` are implemented identically by many C and C++ compilers, e.g., clang,\n+[GCC], [ARM C/C++ compiler], [IBM ILE C/C++], etc. they are not necessarily\n+implemented in this way on all of them. It is therefore also worth verifying\n+that the semantics of the C toolchain used to compile the binary being linked\n+against are compatible with those of the `#[ffi_const]`.\n+\n+[ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacgigch.html\n+[GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-const-function-attribute\n+[IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_const.htm"}, {"sha": "7bfd7a378f00bff14f17c2e6cd5a9b7bf55deea2", "filename": "src/doc/unstable-book/src/language-features/ffi-pure.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,51 @@\n+# `ffi_pure`\n+\n+The `#[ffi_pure]` attribute applies clang's `pure` attribute to foreign\n+functions declarations.\n+\n+That is, `#[ffi_pure]` functions shall have no effects except for its return\n+value, which shall not change across two consecutive function calls with\n+the same parameters.\n+\n+Applying the `#[ffi_pure]` attribute to a function that violates these\n+requirements is undefined behavior.\n+\n+This attribute enables Rust to perform common optimizations, like sub-expression\n+elimination and loop optimizations. Some common examples of pure functions are\n+`strlen` or `memcmp`.\n+\n+These optimizations are only applicable when the compiler can prove that no\n+program state observable by the `#[ffi_pure]` function has changed between calls\n+of the function, which could alter the result. See also the `#[ffi_const]`\n+attribute, which provides stronger guarantees regarding the allowable behavior\n+of a function, enabling further optimization.\n+\n+## Pitfalls\n+\n+A `#[ffi_pure]` function can read global memory through the function\n+parameters (e.g. pointers), globals, etc. `#[ffi_pure]` functions are not\n+referentially-transparent, and are therefore more relaxed than `#[ffi_const]`\n+functions.\n+\n+However, accesing global memory through volatile or atomic reads can violate the\n+requirement that two consecutive function calls shall return the same value.\n+\n+A `pure` function that returns unit has no effect on the abstract machine's\n+state.\n+\n+A `#[ffi_pure]` function must not diverge, neither via a side effect (e.g. a\n+call to `abort`) nor by infinite loops.\n+\n+When translating C headers to Rust FFI, it is worth verifying for which targets\n+the `pure` attribute is enabled in those headers, and using the appropriate\n+`cfg` macros in the Rust side to match those definitions. While the semantics of\n+`pure` are implemented identically by many C and C++ compilers, e.g., clang,\n+[GCC], [ARM C/C++ compiler], [IBM ILE C/C++], etc. they are not necessarily\n+implemented in this way on all of them. It is therefore also worth verifying\n+that the semantics of the C toolchain used to compile the binary being linked\n+against are compatible with those of the `#[ffi_pure]`.\n+\n+\n+[ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacigdac.html\n+[GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-pure-function-attribute\n+[IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_pure.htm"}, {"sha": "20c7d7dcec8d6a512f668a03ac55b65b391ee047", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -287,6 +287,7 @@ the source code.\n   - `unsize`: `libcore/marker.rs`\n   - `sync`: `libcore/marker.rs`\n   - `phantom_data`: `libcore/marker.rs`\n+  - `discriminant_kind`: `libcore/marker.rs`\n   - `freeze`: `libcore/marker.rs`\n   - `debug_trait`: `libcore/fmt/mod.rs`\n   - `non_zero`: `libcore/nonzero.rs`"}, {"sha": "2967200faf80d263be8b152d04da2baa3d84d6c6", "filename": "src/doc/unstable-book/src/language-features/rustc-attrs.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,53 @@\n+# `rustc_attrs`\n+\n+This feature has no tracking issue, and is therefore internal to\n+the compiler, not being intended for general use.\n+\n+Note: `rustc_attrs` enables many rustc-internal attributes and this page\n+only discuss a few of them.\n+\n+------------------------\n+\n+The `rustc_attrs` feature allows debugging rustc type layouts by using\n+`#[rustc_layout(...)]` to debug layout at compile time (it even works\n+with `cargo check`) as an alternative to `rustc -Z print-type-sizes`\n+that is way more verbose.\n+\n+Options provided by `#[rustc_layout(...)]` are `debug`, `size`, `abi`.\n+Note that it only work best with sized type without generics.\n+\n+## Examples\n+\n+```rust,ignore\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout(abi, size)]\n+pub enum X {\n+    Y(u8, u8, u8),\n+    Z(isize),\n+}\n+```\n+\n+When that is compiled, the compiler will error with something like\n+\n+```text\n+error: abi: Aggregate { sized: true }\n+ --> src/lib.rs:4:1\n+  |\n+4 | / pub enum T {\n+5 | |     Y(u8, u8, u8),\n+6 | |     Z(isize),\n+7 | | }\n+  | |_^\n+\n+error: size: Size { raw: 16 }\n+ --> src/lib.rs:4:1\n+  |\n+4 | / pub enum T {\n+5 | |     Y(u8, u8, u8),\n+6 | |     Z(isize),\n+7 | | }\n+  | |_^\n+\n+error: aborting due to 2 previous errors\n+```"}, {"sha": "afc11a2b9492cfa8ef06de26bebf2a1662a2d195", "filename": "src/doc/unstable-book/src/language-features/track-caller.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,5 +0,0 @@\n-# `track_caller`\n-\n-The tracking issue for this feature is: [#47809](https://github.com/rust-lang/rust/issues/47809).\n-\n-------------------------"}, {"sha": "c4c985dd134ba375dc23c4fc7438fc48373f6293", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "added", "additions": 738, "deletions": 0, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,738 @@\n+# `asm`\n+\n+The tracking issue for this feature is: [#72016]\n+\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n+\n+------------------------\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `asm!` macro.\n+\n+# Guide-level explanation\n+[guide-level-explanation]: #guide-level-explanation\n+\n+Rust provides support for inline assembly via the `asm!` macro.\n+It can be used to embed handwritten assembly in the assembly output generated by the compiler.\n+Generally this should not be necessary, but might be where the required performance or timing\n+cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but ARM, AArch64 and RISC-V are also supported.\n+\n+## Basic usage\n+\n+Let us start with the simplest possible example:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+unsafe {\n+    asm!(\"nop\");\n+}\n+```\n+\n+This will insert a NOP (no operation) instruction into the assembly generated by the compiler.\n+Note that all `asm!` invocations have to be inside an `unsafe` block, as they could insert\n+arbitrary instructions and break various invariants. The instructions to be inserted are listed\n+in the first argument of the `asm!` macro as a string literal.\n+\n+## Inputs and outputs\n+\n+Now inserting an instruction that does nothing is rather boring. Let us do something that\n+actually acts on data:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64;\n+unsafe {\n+    asm!(\"mov {}, 5\", out(reg) x);\n+}\n+assert_eq!(x, 5);\n+```\n+\n+This will write the value `5` into the `u64` variable `x`.\n+You can see that the string literal we use to specify instructions is actually a template string.\n+It is governed by the same rules as Rust [format strings][format-syntax].\n+The arguments that are inserted into the template however look a bit different then you may\n+be familiar with. First we need to specify if the variable is an input or an output of the\n+inline assembly. In this case it is an output. We declared this by writing `out`.\n+We also need to specify in what kind of register the assembly expects the variable.\n+In this case we put it in an arbitrary general purpose register by specifying `reg`.\n+The compiler will choose an appropriate register to insert into\n+the template and will read the variable from there after the inline assembly finishes executing.\n+\n+Let us see another example that also uses an input:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let i: u64 = 3;\n+let o: u64;\n+unsafe {\n+    asm!(\n+        \"mov {0}, {1}\",\n+        \"add {0}, {number}\",\n+        out(reg) o,\n+        in(reg) i,\n+        number = const 5,\n+    );\n+}\n+assert_eq!(o, 8);\n+```\n+\n+This will add `5` to the input in variable `i` and write the result to variable `o`.\n+The particular way this assembly does this is first copying the value from `i` to the output,\n+and then adding `5` to it.\n+\n+The example shows a few things:\n+\n+First, we can see that `asm!` allows multiple template string arguments; each\n+one is treated as a separate line of assembly code, as if they were all joined\n+together with newlines between them. This makes it easy to format assembly\n+code.\n+\n+Second, we can see that inputs are declared by writing `in` instead of `out`.\n+\n+Third, one of our operands has a type we haven't seen yet, `const`.\n+This tells the compiler to expand this argument to value directly inside the assembly template.\n+This is only possible for constants and literals.\n+\n+Fourth, we can see that we can specify an argument number, or name as in any format string.\n+For inline assembly templates this is particularly useful as arguments are often used more than once.\n+For more complex inline assembly using this facility is generally recommended, as it improves\n+readability, and allows reordering instructions without changing the argument order.\n+\n+We can further refine the above example to avoid the `mov` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut x: u64 = 3;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n+}\n+assert_eq!(x, 8);\n+```\n+\n+We can see that `inout` is used to specify an argument that is both input and output.\n+This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.\n+\n+It is also possible to specify different variables for the input and output parts of an `inout` operand:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64 = 3;\n+let y: u64;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x => y, number = const 5);\n+}\n+assert_eq!(y, 8);\n+```\n+\n+## Late output operands\n+\n+The Rust compiler is conservative with its allocation of operands. It is assumed that an `out`\n+can be written at any time, and can therefore not share its location with any other argument.\n+However, to guarantee optimal performance it is important to use as few registers as possible,\n+so they won't have to be saved and reloaded around the inline assembly block.\n+To achieve this Rust provides a `lateout` specifier. This can be used on any output that is\n+written only after all inputs have been consumed.\n+There is also a `inlateout` variant of this specifier.\n+\n+Here is an example where `inlateout` *cannot* be used:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+let c: u64 = 4;\n+unsafe {\n+    asm!(\n+        \"add {0}, {1}\",\n+        \"add {0}, {2}\",\n+        inout(reg) a,\n+        in(reg) b,\n+        in(reg) c,\n+    );\n+}\n+assert_eq!(a, 12);\n+```\n+\n+Here the compiler is free to allocate the same register for inputs `b` and `c` since it knows they have the same value. However it must allocate a separate register for `a` since it uses `inout` and not `inlateout`. If `inlateout` was used, then `a` and `c` could be allocated to the same register, in which case the first instruction to overwrite the value of `c` and cause the assembly code to produce the wrong result.\n+\n+However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+unsafe {\n+    asm!(\"add {0}, {1}\", inlateout(reg) a, in(reg) b);\n+}\n+assert_eq!(a, 8);\n+```\n+\n+As you can see, this assembly fragment will still work correctly if `a` and `b` are assigned to the same register.\n+\n+## Explicit register operands\n+\n+Some instructions require that the operands be in a specific register.\n+Therefore, Rust inline assembly provides some more specific constraint specifiers.\n+While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n+among others can be addressed by their name.\n+\n+```rust,allow_fail,no_run\n+# #![feature(asm)]\n+let cmd = 0xd1;\n+unsafe {\n+    asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n+}\n+```\n+\n+In this example we call the `out` instruction to output the content of the `cmd` variable\n+to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n+we had to use the `eax` constraint specifier.\n+\n+Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n+\n+Consider this example which uses the x86 `mul` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+fn mul(a: u64, b: u64) -> u128 {\n+    let lo: u64;\n+    let hi: u64;\n+\n+    unsafe {\n+        asm!(\n+            // The x86 mul instruction takes rax as an implicit input and writes\n+            // the 128-bit result of the multiplication to rax:rdx.\n+            \"mul {}\",\n+            in(reg) a,\n+            inlateout(\"rax\") b => lo,\n+            lateout(\"rdx\") hi\n+        );\n+    }\n+\n+    ((hi as u128) << 64) + lo as u128\n+}\n+```\n+\n+This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit result.\n+The only explicit operand is a register, that we fill from the variable `a`.\n+The second operand is implicit, and must be the `rax` register, which we fill from the variable `b`.\n+The lower 64 bits of the result are stored in `rax` from which we fill the variable `lo`.\n+The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.\n+\n+## Clobbered registers\n+\n+In many cases inline assembly will modify state that is not needed as an output.\n+Usually this is either because we have to use a scratch register in the assembly,\n+or instructions modify state that we don't need to further examine.\n+This state is generally referred to as being \"clobbered\".\n+We need to tell the compiler about this since it may need to save and restore this state\n+around the inline assembly block.\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let ebx: u32;\n+let ecx: u32;\n+\n+unsafe {\n+    asm!(\n+        \"cpuid\",\n+        // EAX 4 selects the \"Deterministic Cache Parameters\" CPUID leaf\n+        inout(\"eax\") 4 => _,\n+        // ECX 0 selects the L0 cache information.\n+        inout(\"ecx\") 0 => ecx,\n+        lateout(\"ebx\") ebx,\n+        lateout(\"edx\") _,\n+    );\n+}\n+\n+println!(\n+    \"L1 Cache: {}\",\n+    ((ebx >> 22) + 1) * (((ebx >> 12) & 0x3ff) + 1) * ((ebx & 0xfff) + 1) * (ecx + 1)\n+);\n+```\n+\n+In the example above we use the `cpuid` instruction to get the L1 cache size.\n+This instruction writes to `eax`, `ebx`, `ecx`, and `edx`, but for the cache size we only care about the contents of `ebx` and `ecx`.\n+\n+However we still need to tell the compiler that `eax` and `edx` have been modified so that it can save any values that were in these registers before the asm. This is done by declaring these as outputs but with `_` instead of a variable name, which indicates that the output value is to be discarded.\n+\n+This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+// Multiply x by 6 using shifts and adds\n+let mut x: u64 = 4;\n+unsafe {\n+    asm!(\n+        \"mov {tmp}, {x}\",\n+        \"shl {tmp}, 1\",\n+        \"shl {x}, 2\",\n+        \"add {x}, {tmp}\",\n+        x = inout(reg) x,\n+        tmp = out(reg) _,\n+    );\n+}\n+assert_eq!(x, 4 * 6);\n+```\n+\n+## Symbol operands\n+\n+A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n+This allows you to call a function or access a global variable without needing to keep its address in a register.\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+extern \"C\" fn foo(arg: i32) {\n+    println!(\"arg = {}\", arg);\n+}\n+\n+fn call_foo(arg: i32) {\n+    unsafe {\n+        asm!(\n+            \"call {}\",\n+            sym foo,\n+            // 1st argument in rdi, which is caller-saved\n+            inout(\"rdi\") arg => _,\n+            // All caller-saved registers must be marked as clobberred\n+            out(\"rax\") _, out(\"rcx\") _, out(\"rdx\") _, out(\"rsi\") _,\n+            out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n+            out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n+            out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n+            out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n+            out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n+        )\n+    }\n+}\n+```\n+\n+Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n+the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+\n+## Register template modifiers\n+\n+In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a \"view\" over a subset of the register (e.g. the low 32 bits of a 64-bit register).\n+\n+By default the compiler will always choose the name that refers to the full register size (e.g. `rax` on x86-64, `eax` on x86, etc).\n+\n+This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut x: u16 = 0xab;\n+\n+unsafe {\n+    asm!(\"mov {0:h}, {0:l}\", inout(reg_abcd) x);\n+}\n+\n+assert_eq!(x, 0xabab);\n+```\n+\n+In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.\n+\n+Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.\n+The `h` modifier will emit the register name for the high byte of that register and the `l` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.\n+\n+If you use a smaller data type (e.g. `u16`) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.\n+\n+## Options\n+\n+By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n+\n+Let's take our previous example of an `add` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+unsafe {\n+    asm!(\n+        \"add {0}, {1}\",\n+        inlateout(reg) a, in(reg) b,\n+        options(pure, nomem, nostack),\n+    );\n+}\n+assert_eq!(a, 8);\n+```\n+\n+Options can be provided as an optional final argument to the `asm!` macro. We specified three options here:\n+- `pure` means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.\n+- `nomem` means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).\n+- `nostack` means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.\n+\n+These allow the compiler to better optimize code using `asm!`, for example by eliminating pure `asm!` blocks whose outputs are not needed.\n+\n+See the reference for the full list of available options and their effects.\n+\n+# Reference-level explanation\n+[reference-level-explanation]: #reference-level-explanation\n+\n+Inline assembler is implemented as an unsafe macro `asm!()`.\n+The first argument to this macro is a template string literal used to build the final assembly.\n+The following arguments specify input and output operands.\n+When required, options are specified as the final argument.\n+\n+The following ABNF specifies the general syntax:\n+\n+```ignore\n+dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n+reg_spec := <register class> / \"<explicit register>\"\n+operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n+reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n+operand := reg_operand / \"const\" const_expr / \"sym\" path\n+option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"att_syntax\"\n+options := \"options(\" option *[\",\" option] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+```\n+\n+The macro will initially be supported only on ARM, AArch64, Hexagon, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+\n+[format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n+\n+## Template string arguments\n+\n+The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n+\n+An `asm!` invocation may have one or more template string arguments; an `asm!` with multiple template string arguments is treated as if all the strings were concatenated with a `\\n` between them. The expected usage is for each template string argument to correspond to a line of assembly code. All template string arguments must appear before any other arguments.\n+\n+As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after named arguments if any.\n+\n+Explicit register operands cannot be used by placeholders in the template string. All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated.\n+\n+The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n+\n+The 5 targets specified in this RFC (x86, ARM, AArch64, RISC-V, Hexagon) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n+\n+[rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795\n+\n+## Operand type\n+\n+Several types of operands are supported:\n+\n+* `in(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - The allocated register must contain the same value at the end of the asm code (except if a `lateout` is allocated to the same register).\n+* `out(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain an undefined value at the start of the asm code.\n+  - `<expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+* `lateout(<reg>) <expr>`\n+  - Identical to `out` except that the register allocator can reuse a register allocated to an `in`.\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `inout(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - `<expr>` must be a mutable initialized place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+* `inout(<reg>) <in expr> => <out expr>`\n+  - Same as `inout` except that the initial value of the register is taken from the value of `<in expr>`.\n+  - `<out expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression for `<out expr>`, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+  - `<in expr>` and `<out expr>` may have different types.\n+* `inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`\n+  - Identical to `inout` except that the register allocator can reuse a register allocated to an `in` (this can happen if the compiler knows the `in` has the same initial value as the `inlateout`).\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `const <expr>`\n+  - `<expr>` must be an integer or floating-point constant expression.\n+  - The value of the expression is formatted as a string and substituted directly into the asm template string.\n+* `sym <path>`\n+  - `<path>` must refer to a `fn` or `static`.\n+  - A mangled symbol name referring to the item is substituted into the asm template string.\n+  - The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).\n+  - `<path>` is allowed to point to a `#[thread_local]` static, in which case the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) to read from thread-local data.\n+\n+Operand expressions are evaluated from left to right, just like function call arguments. After the `asm!` has executed, outputs are written to in left to right order. This is significant if two outputs point to the same place: that place will contain the value of the rightmost output.\n+\n+## Register operands\n+\n+Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. `\"eax\"`) while register classes are specified as identifiers (e.g. `reg`). Using string literals for register names enables support for architectures that use special characters in register names, such as MIPS (`$0`, `$1`, etc).\n+\n+Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to the base register. It is a compile-time error to use the same explicit register for two input operands or two output operands. Additionally, it is also a compile-time error to use overlapping registers (e.g. ARM VFP) in input operands or in output operands.\n+\n+Only the following types are allowed as operands for inline assembly:\n+- Integers (signed and unsigned)\n+- Floating-point numbers\n+- Pointers (thin only)\n+- Function pointers\n+- SIMD vectors (structs defined with `#[repr(simd)]` and which implement `Copy`). This includes architecture-specific vector types defined in `std::arch` such as `__m128` (x86) or `int8x16_t` (ARM).\n+\n+Here is the list of currently supported register classes:\n+\n+| Architecture | Register class | Registers | LLVM constraint code |\n+| ------------ | -------------- | --------- | -------------------- |\n+| x86 | `reg` | `ax`, `bx`, `cx`, `dx`, `si`, `di`, `r[8-15]` (x86-64 only) | `r` |\n+| x86 | `reg_abcd` | `ax`, `bx`, `cx`, `dx` | `Q` |\n+| x86-32 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh` | `q` |\n+| x86-64 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `sil`, `dil`, `r[8-15]b`, `ah`\\*, `bh`\\*, `ch`\\*, `dh`\\* | `q` |\n+| x86 | `xmm_reg` | `xmm[0-7]` (x86) `xmm[0-15]` (x86-64) | `x` |\n+| x86 | `ymm_reg` | `ymm[0-7]` (x86) `ymm[0-15]` (x86-64) | `x` |\n+| x86 | `zmm_reg` | `zmm[0-7]` (x86) `zmm[0-31]` (x86-64) | `v` |\n+| x86 | `kreg` | `k[1-7]` | `Yk` |\n+| AArch64 | `reg` | `x[0-28]`, `x30` | `r` |\n+| AArch64 | `vreg` | `v[0-31]` | `w` |\n+| AArch64 | `vreg_low16` | `v[0-15]` | `x` |\n+| ARM | `reg` | `r[0-5]` `r7`\\*, `r[8-10]`, `r11`\\*, `r12`, `r14` | `r` |\n+| ARM (Thumb) | `reg_thumb` | `r[0-r7]` | `l` |\n+| ARM (ARM) | `reg_thumb` | `r[0-r10]`, `r12`, `r14` | `l` |\n+| ARM | `sreg` | `s[0-31]` | `t` |\n+| ARM | `sreg_low16` | `s[0-15]` | `x` |\n+| ARM | `dreg` | `d[0-31]` | `w` |\n+| ARM | `dreg_low16` | `d[0-15]` | `t` |\n+| ARM | `dreg_low8` | `d[0-8]` | `x` |\n+| ARM | `qreg` | `q[0-15]` | `w` |\n+| ARM | `qreg_low8` | `q[0-7]` | `t` |\n+| ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| NVPTX | `reg16` | None\\* | `h` |\n+| NVPTX | `reg32` | None\\* | `r` |\n+| NVPTX | `reg64` | None\\* | `l` |\n+| RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n+| RISC-V | `freg` | `f[0-31]` | `f` |\n+| Hexagon | `reg` | `r[0-28]` | `r` |\n+\n+> **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n+>\n+> Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+>\n+> Note #3: NVPTX doesn't have a fixed register set, so named registers are not supported.\n+>\n+> Note #4: On ARM the frame pointer is either `r7` or `r11` depending on the platform.\n+\n+Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n+\n+Each register class has constraints on which value types they can be used with. This is necessary because the way a value is loaded into a register depends on its type. For example, on big-endian systems, loading a `i32x4` and a `i8x16` into a SIMD register may result in different register contents even if the byte-wise memory representation of both values is identical. The availability of supported types for a particular register class may depend on what target features are currently enabled.\n+\n+| Architecture | Register class | Target feature | Allowed types |\n+| ------------ | -------------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `i16`, `i32`, `f32` |\n+| x86-64 | `reg` | None | `i16`, `i32`, `f32`, `i64`, `f64` |\n+| x86 | `reg_byte` | None | `i8` |\n+| x86 | `xmm_reg` | `sse` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| x86 | `ymm_reg` | `avx` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` |\n+| x86 | `zmm_reg` | `avx512f` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` <br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8` |\n+| x86 | `kreg` | `axv512f` | `i8`, `i16` |\n+| x86 | `kreg` | `axv512bw` | `i32`, `i64` |\n+| AArch64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| AArch64 | `vreg` | `fp` | `i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| ARM | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| ARM | `sreg` | `vfp2` | `i32`, `f32` |\n+| ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n+| ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| NVPTX | `reg16` | None | `i8`, `i16` |\n+| NVPTX | `reg32` | None | `i8`, `i16`, `i32`, `f32` |\n+| NVPTX | `reg64` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| RISC-V | `freg` | `f` | `f32` |\n+| RISC-V | `freg` | `d` | `f64` |\n+| Hexagon | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+\n+> **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n+\n+If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. The only exception is the `freg` register class on RISC-V where `f32` values are NaN-boxed in a `f64` as required by the RISC-V architecture.\n+\n+When separate input and output expressions are specified for an `inout` operand, both expressions must have the same type. The only exception is if both operands are pointers or integers, in which case they are only required to have the same size. This restriction exists because the register allocators in LLVM and GCC sometimes cannot handle tied operands with different types.\n+\n+## Register names\n+\n+Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:\n+\n+| Architecture | Base register | Aliases |\n+| ------------ | ------------- | ------- |\n+| x86 | `ax` | `eax`, `rax` |\n+| x86 | `bx` | `ebx`, `rbx` |\n+| x86 | `cx` | `ecx`, `rcx` |\n+| x86 | `dx` | `edx`, `rdx` |\n+| x86 | `si` | `esi`, `rsi` |\n+| x86 | `di` | `edi`, `rdi` |\n+| x86 | `bp` | `bpl`, `ebp`, `rbp` |\n+| x86 | `sp` | `spl`, `esp`, `rsp` |\n+| x86 | `ip` | `eip`, `rip` |\n+| x86 | `st(0)` | `st` |\n+| x86 | `r[8-15]` | `r[8-15]b`, `r[8-15]w`, `r[8-15]d` |\n+| x86 | `xmm[0-31]` | `ymm[0-31]`, `zmm[0-31]` |\n+| AArch64 | `x[0-30]` | `w[0-30]` |\n+| AArch64 | `x29` | `fp` |\n+| AArch64 | `x30` | `lr` |\n+| AArch64 | `sp` | `wsp` |\n+| AArch64 | `xzr` | `wzr` |\n+| AArch64 | `v[0-31]` | `b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]` |\n+| ARM | `r[0-3]` | `a[1-4]` |\n+| ARM | `r[4-9]` | `v[1-6]` |\n+| ARM | `r9` | `rfp` |\n+| ARM | `r10` | `sl` |\n+| ARM | `r11` | `fp` |\n+| ARM | `r12` | `ip` |\n+| ARM | `r13` | `sp` |\n+| ARM | `r14` | `lr` |\n+| ARM | `r15` | `pc` |\n+| RISC-V | `x0` | `zero` |\n+| RISC-V | `x1` | `ra` |\n+| RISC-V | `x2` | `sp` |\n+| RISC-V | `x3` | `gp` |\n+| RISC-V | `x4` | `tp` |\n+| RISC-V | `x[5-7]` | `t[0-2]` |\n+| RISC-V | `x8` | `fp`, `s0` |\n+| RISC-V | `x9` | `s1` |\n+| RISC-V | `x[10-17]` | `a[0-7]` |\n+| RISC-V | `x[18-27]` | `s[2-11]` |\n+| RISC-V | `x[28-31]` | `t[3-6]` |\n+| RISC-V | `f[0-7]` | `ft[0-7]` |\n+| RISC-V | `f[8-9]` | `fs[0-1]` |\n+| RISC-V | `f[10-17]` | `fa[0-7]` |\n+| RISC-V | `f[18-27]` | `fs[2-11]` |\n+| RISC-V | `f[28-31]` | `ft[8-11]` |\n+| Hexagon | `r29` | `sp` |\n+| Hexagon | `r30` | `fr` |\n+| Hexagon | `r31` | `lr` |\n+\n+Some registers cannot be used for input or output operands:\n+\n+| Architecture | Unsupported register | Reason |\n+| ------------ | -------------------- | ------ |\n+| All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n+| All | `bp` (x86), `x29` (AArch64), `x8` (RISC-V), `fr` (Hexagon) | The frame pointer cannot be used as an input or output. |\n+| ARM | `r7` or `r11` | On ARM the frame pointer can be either `r7` or `r11` depending on the target. The frame pointer cannot be used as an input or output. |\n+| ARM | `r6` | `r6` is used internally by LLVM as a base pointer and therefore cannot be used as an input or output. |\n+| x86 | `k0` | This is a constant zero register which can't be modified. |\n+| x86 | `ip` | This is the program counter, not a real register. |\n+| x86 | `mm[0-7]` | MMX registers are not currently supported (but may be in the future). |\n+| x86 | `st([0-7])` | x87 registers are not currently supported (but may be in the future). |\n+| AArch64 | `xzr` | This is a constant zero register which can't be modified. |\n+| ARM | `pc` | This is the program counter, not a real register. |\n+| RISC-V | `x0` | This is a constant zero register which can't be modified. |\n+| RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n+| Hexagon | `lr` | This is the link register which cannot be used as an input or output. |\n+\n+## Template modifiers\n+\n+The placeholders can be augmented by modifiers which are specified after the `:` in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string. Only one modifier is allowed per template placeholder.\n+\n+The supported modifiers are a subset of LLVM's (and GCC's) [asm template argument modifiers][llvm-argmod], but do not use the same letter codes.\n+\n+| Architecture | Register class | Modifier | Example output | LLVM modifier |\n+| ------------ | -------------- | -------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `eax` | `k` |\n+| x86-64 | `reg` | None | `rax` | `q` |\n+| x86-32 | `reg_abcd` | `l` | `al` | `b` |\n+| x86-64 | `reg` | `l` | `al` | `b` |\n+| x86 | `reg_abcd` | `h` | `ah` | `h` |\n+| x86 | `reg` | `x` | `ax` | `w` |\n+| x86 | `reg` | `e` | `eax` | `k` |\n+| x86-64 | `reg` | `r` | `rax` | `q` |\n+| x86 | `reg_byte` | None | `al` / `ah` | None |\n+| x86 | `xmm_reg` | None | `xmm0` | `x` |\n+| x86 | `ymm_reg` | None | `ymm0` | `t` |\n+| x86 | `zmm_reg` | None | `zmm0` | `g` |\n+| x86 | `*mm_reg` | `x` | `xmm0` | `x` |\n+| x86 | `*mm_reg` | `y` | `ymm0` | `t` |\n+| x86 | `*mm_reg` | `z` | `zmm0` | `g` |\n+| x86 | `kreg` | None | `k1` | None |\n+| AArch64 | `reg` | None | `x0` | `x` |\n+| AArch64 | `reg` | `w` | `w0` | `w` |\n+| AArch64 | `reg` | `x` | `x0` | `x` |\n+| AArch64 | `vreg` | None | `v0` | None |\n+| AArch64 | `vreg` | `v` | `v0` | None |\n+| AArch64 | `vreg` | `b` | `b0` | `b` |\n+| AArch64 | `vreg` | `h` | `h0` | `h` |\n+| AArch64 | `vreg` | `s` | `s0` | `s` |\n+| AArch64 | `vreg` | `d` | `d0` | `d` |\n+| AArch64 | `vreg` | `q` | `q0` | `q` |\n+| ARM | `reg` | None | `r0` | None |\n+| ARM | `sreg` | None | `s0` | None |\n+| ARM | `dreg` | None | `d0` | `P` |\n+| ARM | `qreg` | None | `q0` | `q` |\n+| ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| NVPTX | `reg16` | None | `rs0` | None |\n+| NVPTX | `reg32` | None | `r0` | None |\n+| NVPTX | `reg64` | None | `rd0` | None |\n+| RISC-V | `reg` | None | `x1` | None |\n+| RISC-V | `freg` | None | `f0` | None |\n+| Hexagon | `reg` | None | `r0` | None |\n+\n+> Notes:\n+> - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register.\n+> - on x86: our behavior for `reg` with no modifiers differs from what GCC does. GCC will infer the modifier based on the operand value type, while we default to the full register size.\n+> - on x86 `xmm_reg`: the `x`, `t` and `g` LLVM modifiers are not yet implemented in LLVM (they are supported by GCC only), but this should be a simple change.\n+\n+As stated in the previous section, passing an input value smaller than the register width will result in the upper bits of the register containing undefined values. This is not a problem if the inline asm only accesses the lower bits of the register, which can be done by using a template modifier to use a subregister name in the asm code (e.g. `ax` instead of `rax`). Since this an easy pitfall, the compiler will suggest a template modifier to use where appropriate given the input type. If all references to an operand already have modifiers then the warning is suppressed for that operand.\n+\n+[llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n+\n+## Options\n+\n+Flags are used to further influence the behavior of the inline assembly block.\n+Currently the following options are defined:\n+- `pure`: The `asm` block has no side effects, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the `nomem` options is also set). This allows the compiler to execute the `asm` block fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used.\n+- `nomem`: The `asm` blocks does not read or write to any memory. This allows the compiler to cache the values of modified global variables in registers across the `asm` block since it knows that they are not read or written to by the `asm`.\n+- `readonly`: The `asm` block does not write to any memory. This allows the compiler to cache the values of unmodified global variables in registers across the `asm` block since it knows that they are not written to by the `asm`.\n+- `preserves_flags`: The `asm` block does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.\n+- `noreturn`: The `asm` block never returns, and its return type is defined as `!` (never). Behavior is undefined if execution falls through past the end of the asm code. A `noreturn` asm block behaves just like a function which doesn't return; notably, local variables in scope are not dropped before it is invoked.\n+- `nostack`: The `asm` block does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is *not* used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+- `att_syntax`: This option is only valid on x86, and causes the assembler to use the `.att_syntax prefix` mode of the GNU assembler. Register operands are substituted in with a leading `%`.\n+\n+The compiler performs some additional checks on options:\n+- The `nomem` and `readonly` options are mutually exclusive: it is a compile-time error to specify both.\n+- The `pure` option must be combined with either the `nomem` or `readonly` options, otherwise a compile-time error is emitted.\n+- It is a compile-time error to specify `pure` on an asm block with no outputs or only discarded outputs (`_`).\n+- It is a compile-time error to specify `noreturn` on an asm block with outputs.\n+\n+## Rules for inline assembly\n+\n+- Any registers not specified as inputs will contain an undefined value on entry to the asm block.\n+  - An \"undefined value\" in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM `undef` which can have a different value every time you read it (since such a concept does not exist in assembly code).\n+- Any registers not specified as outputs must have the same value upon exiting the asm block as they had on entry, otherwise behavior is undefined.\n+  - This only applies to registers which can be specified as an input or output. Other registers follow target-specific rules.\n+  - Note that a `lateout` may be allocated to the same register as an `in`, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.\n+- Behavior is undefined if execution unwinds out of an asm block.\n+  - This also applies if the assembly code calls a function which then unwinds.\n+- The set of memory locations that assembly code is allowed the read and write are the same as those allowed for an FFI function.\n+  - Refer to the unsafe code guidelines for the exact rules.\n+  - If the `readonly` option is set, then only memory reads are allowed.\n+  - If the `nomem` option is set then no reads or writes to memory are allowed.\n+  - These rules do not apply to memory which is private to the asm code, such as stack space allocated within the asm block.\n+- The compiler cannot assume that the instructions in the asm are the ones that will actually end up executed.\n+  - This effectively means that the compiler must treat the `asm!` as a black box and only take the interface specification into account, not the instructions themselves.\n+  - Runtime code patching is allowed, via target-specific mechanisms (outside the scope of this RFC).\n+- Unless the `nostack` option is set, asm code is allowed to use stack space below the stack pointer.\n+  - On entry to the asm block the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+  - You are responsible for making sure you don't overflow the stack (e.g. use stack probing to ensure you hit a guard page).\n+  - You should adjust the stack pointer when allocating stack memory as required by the target ABI.\n+  - The stack pointer must be restored to its original value before leaving the asm block.\n+- If the `noreturn` option is set then behavior is undefined if execution falls through to the end of the asm block.\n+- If the `pure` option is set then behavior is undefined if the `asm` has side-effects other than its direct outputs. Behavior is also undefined if two executions of the `asm` code with the same inputs result in different outputs.\n+  - When used with the `nomem` option, \"inputs\" are just the direct inputs of the `asm!`.\n+  - When used with the `readonly` option, \"inputs\" comprise the direct inputs of the `asm!` and any memory that the `asm!` block is allowed to read.\n+- These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n+  - x86\n+    - Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF).\n+    - Floating-point status word (all).\n+    - Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE).\n+  - ARM\n+    - Condition flags in `CPSR` (N, Z, C, V)\n+    - Saturation flag in `CPSR` (Q)\n+    - Greater than or equal flags in `CPSR` (GE).\n+    - Condition flags in `FPSCR` (N, Z, C, V)\n+    - Saturation flag in `FPSCR` (QC)\n+    - Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC).\n+  - AArch64\n+    - Condition flags (`NZCV` register).\n+    - Floating-point status (`FPSR` register).\n+  - RISC-V\n+    - Floating-point exception flags in `fcsr` (`fflags`).\n+- On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm block and must be clear on exit.\n+  - Behavior is undefined if the direction flag is set on exiting an asm block.\n+- The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting an `asm!` block.\n+  - This means that `asm!` blocks that never return (even if not marked `noreturn`) don't need to preserve these registers.\n+  - When returning to a different `asm!` block than you entered (e.g. for context switching), these registers must contain the value they had upon entering the `asm!` block that you are *exiting*.\n+    - You cannot exit an `asm!` block that has not been entered. Neither can you exit an `asm!` block that has already been exited.\n+    - You are responsible for switching any target-specific state (e.g. thread-local storage, stack bounds).\n+    - The set of memory locations that you may access is the intersection of those allowed by the `asm!` blocks you entered and exited.\n+- You cannot assume that an `asm!` block will appear exactly once in the output binary. The compiler is allowed to instantiate multiple copies of the `asm!` block, for example when the function containing it is inlined in multiple places.\n+  - As a consequence, you should only use [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+\n+> **Note**: As a general rule, the flags covered by `preserves_flags` are those which are *not* preserved when performing a function call.\n+\n+[local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels"}, {"sha": "5dff73a94dd872c956aa1c231719290d5791271a", "filename": "src/doc/unstable-book/src/library-features/default-free-fn.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,45 @@\n+# `default_free_fn`\n+\n+The tracking issue for this feature is: [#73014]\n+\n+[#73014]: https://github.com/rust-lang/rust/issues/73014\n+\n+------------------------\n+\n+Adds a free `default()` function to the `std::default` module.  This function\n+just forwards to [`Default::default()`], but may remove repetition of the word\n+\"default\" from the call site.\n+\n+Here is an example:\n+\n+```rust\n+#![feature(default_free_fn)]\n+use std::default::default;\n+\n+#[derive(Default)]\n+struct AppConfig {\n+    foo: FooConfig,\n+    bar: BarConfig,\n+}\n+\n+#[derive(Default)]\n+struct FooConfig {\n+    foo: i32,\n+}\n+\n+#[derive(Default)]\n+struct BarConfig {\n+    bar: f32,\n+    baz: u8,\n+}\n+\n+fn main() {\n+    let options = AppConfig {\n+        foo: default(),\n+        bar: BarConfig {\n+            bar: 10.1,\n+            ..default()\n+        },\n+    };\n+}\n+```"}, {"sha": "64b1b3d81bd83ce7641905c906e9f92ce8d7b69a", "filename": "src/doc/unstable-book/src/library-features/format-args-capture.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fformat-args-capture.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fformat-args-capture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fformat-args-capture.md?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,47 @@\n+# `format_args_capture`\n+\n+The tracking issue for this feature is: [#67984]\n+\n+[#67984]: https://github.com/rust-lang/rust/issues/67984\n+\n+------------------------\n+\n+Enables `format_args!` (and macros which use `format_args!` in their implementation, such\n+as `format!`, `print!` and `panic!`) to capture variables from the surrounding scope.\n+This avoids the need to pass named parameters when the binding in question\n+already exists in scope.\n+\n+```rust\n+#![feature(format_args_capture)]\n+\n+let (person, species, name) = (\"Charlie Brown\", \"dog\", \"Snoopy\");\n+\n+// captures named argument `person`\n+print!(\"Hello {person}\");\n+\n+// captures named arguments `species` and `name`\n+format!(\"The {species}'s name is {name}.\");\n+```\n+\n+This also works for formatting parameters such as width and precision:\n+\n+```rust\n+#![feature(format_args_capture)]\n+\n+let precision = 2;\n+let s = format!(\"{:.precision$}\", 1.324223);\n+\n+assert_eq!(&s, \"1.32\");\n+```\n+\n+A non-exhaustive list of macros which benefit from this functionality include:\n+- `format!`\n+- `print!` and `println!`\n+- `eprint!` and `eprintln!`\n+- `write!` and `writeln!`\n+- `panic!`\n+- `unreachable!`\n+- `unimplemented!`\n+- `todo!`\n+- `assert!` and similar\n+- macros in many thirdparty crates, such as `log`"}, {"sha": "b3f8f50636bee754b81d0280b505ece3bb9f1a51", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "removed", "additions": 0, "deletions": 401, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,401 +0,0 @@\n-\"\"\"\n-This module provides an abstraction layer over common Rust pretty printing\n-functionality needed by both GDB and LLDB.\n-\"\"\"\n-\n-import re\n-\n-# Type codes that indicate the kind of type as it appears in DWARF debug\n-# information. This code alone is not sufficient to determine the Rust type.\n-# For example structs, tuples, fat pointers, or enum variants will all have\n-# DWARF_TYPE_CODE_STRUCT.\n-DWARF_TYPE_CODE_STRUCT = 1\n-DWARF_TYPE_CODE_UNION  = 2\n-DWARF_TYPE_CODE_PTR    = 3\n-DWARF_TYPE_CODE_ARRAY  = 4\n-DWARF_TYPE_CODE_ENUM   = 5\n-\n-# These constants specify the most specific kind of type that could be\n-# determined for a given value.\n-TYPE_KIND_UNKNOWN           = -1\n-TYPE_KIND_EMPTY             = 0\n-TYPE_KIND_SLICE             = 1\n-TYPE_KIND_REGULAR_STRUCT    = 2\n-TYPE_KIND_TUPLE             = 3\n-TYPE_KIND_TUPLE_STRUCT      = 4\n-TYPE_KIND_CSTYLE_VARIANT    = 5\n-TYPE_KIND_TUPLE_VARIANT     = 6\n-TYPE_KIND_STRUCT_VARIANT    = 7\n-TYPE_KIND_STR_SLICE         = 8\n-TYPE_KIND_STD_VEC           = 9\n-TYPE_KIND_STD_STRING        = 10\n-TYPE_KIND_REGULAR_ENUM      = 11\n-TYPE_KIND_COMPRESSED_ENUM   = 12\n-TYPE_KIND_SINGLETON_ENUM    = 13\n-TYPE_KIND_CSTYLE_ENUM       = 14\n-TYPE_KIND_PTR               = 15\n-TYPE_KIND_FIXED_SIZE_VEC    = 16\n-TYPE_KIND_REGULAR_UNION     = 17\n-TYPE_KIND_OS_STRING         = 18\n-TYPE_KIND_STD_VECDEQUE      = 19\n-TYPE_KIND_STD_BTREESET      = 20\n-TYPE_KIND_STD_BTREEMAP      = 21\n-\n-ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n-ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n-\n-# Slice related constants\n-SLICE_FIELD_NAME_DATA_PTR = \"data_ptr\"\n-SLICE_FIELD_NAME_LENGTH = \"length\"\n-SLICE_FIELD_NAMES = [SLICE_FIELD_NAME_DATA_PTR, SLICE_FIELD_NAME_LENGTH]\n-\n-# std::Vec<> related constants\n-STD_VEC_FIELD_NAME_LENGTH = \"len\"\n-STD_VEC_FIELD_NAME_BUF = \"buf\"\n-STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_BUF,\n-                       STD_VEC_FIELD_NAME_LENGTH]\n-\n-# std::collections::VecDeque<> related constants\n-STD_VECDEQUE_FIELD_NAME_TAIL = \"tail\"\n-STD_VECDEQUE_FIELD_NAME_HEAD = \"head\"\n-STD_VECDEQUE_FIELD_NAME_BUF = \"buf\"\n-STD_VECDEQUE_FIELD_NAMES = [STD_VECDEQUE_FIELD_NAME_TAIL,\n-                            STD_VECDEQUE_FIELD_NAME_HEAD,\n-                            STD_VECDEQUE_FIELD_NAME_BUF]\n-\n-# std::collections::BTreeSet<> related constants\n-STD_BTREESET_FIELD_NAMES = [\"map\"]\n-\n-# std::collections::BTreeMap<> related constants\n-STD_BTREEMAP_FIELD_NAMES = [\"root\", \"length\"]\n-\n-# std::String related constants\n-STD_STRING_FIELD_NAMES = [\"vec\"]\n-\n-# std::ffi::OsString related constants\n-OS_STRING_FIELD_NAMES = [\"inner\"]\n-\n-\n-class Type(object):\n-    \"\"\"\n-    This class provides a common interface for type-oriented operations.\n-    Sub-classes are supposed to wrap a debugger-specific type-object and\n-    provide implementations for the abstract methods in this class.\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.__type_kind = None\n-\n-    def get_unqualified_type_name(self):\n-        \"\"\"\n-        Implementations of this method should return the unqualified name of the\n-        type-object they are wrapping. Some examples:\n-\n-        'int' -> 'int'\n-        'std::vec::Vec<std::string::String>' -> 'Vec<std::string::String>'\n-        '&std::option::Option<std::string::String>' -> '&std::option::Option<std::string::String>'\n-\n-        As you can see, type arguments stay fully qualified.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_dwarf_type_kind(self):\n-        \"\"\"\n-        Implementations of this method should return the correct\n-        DWARF_TYPE_CODE_* value for the wrapped type-object.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_fields(self):\n-        \"\"\"\n-        Implementations of this method should return a list of field-objects of\n-        this type. For Rust-enums (i.e. with DWARF_TYPE_CODE_UNION) these field-\n-        objects represent the variants of the enum. Field-objects must have a\n-        `name` attribute that gives their name as specified in DWARF.\n-        \"\"\"\n-        assert ((self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION))\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_wrapped_value(self):\n-        \"\"\"\n-        Returns the debugger-specific type-object wrapped by this object. This\n-        is sometimes needed for doing things like pointer-arithmetic in GDB.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_type_kind(self):\n-        \"\"\"This method returns the TYPE_KIND_* value for this type-object.\"\"\"\n-        if self.__type_kind is None:\n-            dwarf_type_code = self.get_dwarf_type_kind()\n-\n-            if dwarf_type_code == DWARF_TYPE_CODE_STRUCT:\n-                self.__type_kind = self.__classify_struct()\n-            elif dwarf_type_code == DWARF_TYPE_CODE_UNION:\n-                self.__type_kind = self.__classify_union()\n-            elif dwarf_type_code == DWARF_TYPE_CODE_PTR:\n-                self.__type_kind = TYPE_KIND_PTR\n-            elif dwarf_type_code == DWARF_TYPE_CODE_ARRAY:\n-                self.__type_kind = TYPE_KIND_FIXED_SIZE_VEC\n-            else:\n-                self.__type_kind = TYPE_KIND_UNKNOWN\n-        return self.__type_kind\n-\n-    def __classify_struct(self):\n-        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT\n-\n-        unqualified_type_name = self.get_unqualified_type_name()\n-\n-        # STR SLICE\n-        if unqualified_type_name == \"&str\":\n-            return TYPE_KIND_STR_SLICE\n-\n-        # REGULAR SLICE\n-        if (unqualified_type_name.startswith((\"&[\", \"&mut [\")) and\n-            unqualified_type_name.endswith(\"]\") and\n-            self.__conforms_to_field_layout(SLICE_FIELD_NAMES)):\n-            return TYPE_KIND_SLICE\n-\n-        fields = self.get_fields()\n-        field_count = len(fields)\n-\n-        # EMPTY STRUCT\n-        if field_count == 0:\n-            return TYPE_KIND_EMPTY\n-\n-        # STD VEC\n-        if (unqualified_type_name.startswith(\"Vec<\") and\n-            self.__conforms_to_field_layout(STD_VEC_FIELD_NAMES)):\n-            return TYPE_KIND_STD_VEC\n-\n-        # STD COLLECTION VECDEQUE\n-        if (unqualified_type_name.startswith(\"VecDeque<\") and\n-            self.__conforms_to_field_layout(STD_VECDEQUE_FIELD_NAMES)):\n-            return TYPE_KIND_STD_VECDEQUE\n-\n-        # STD COLLECTION BTREESET\n-        if (unqualified_type_name.startswith(\"BTreeSet<\") and\n-                self.__conforms_to_field_layout(STD_BTREESET_FIELD_NAMES)):\n-            return TYPE_KIND_STD_BTREESET\n-\n-        # STD COLLECTION BTREEMAP\n-        if (unqualified_type_name.startswith(\"BTreeMap<\") and\n-                self.__conforms_to_field_layout(STD_BTREEMAP_FIELD_NAMES)):\n-            return TYPE_KIND_STD_BTREEMAP\n-\n-        # STD STRING\n-        if (unqualified_type_name.startswith(\"String\") and\n-            self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n-            return TYPE_KIND_STD_STRING\n-\n-        # OS STRING\n-        if (unqualified_type_name == \"OsString\" and\n-            self.__conforms_to_field_layout(OS_STRING_FIELD_NAMES)):\n-            return TYPE_KIND_OS_STRING\n-\n-        # ENUM VARIANTS\n-        if fields[0].name == ENUM_DISR_FIELD_NAME:\n-            if field_count == 1:\n-                return TYPE_KIND_CSTYLE_VARIANT\n-            elif self.__all_fields_conform_to_tuple_field_naming(1):\n-                return TYPE_KIND_TUPLE_VARIANT\n-            else:\n-                return TYPE_KIND_STRUCT_VARIANT\n-\n-        # TUPLE\n-        if self.__all_fields_conform_to_tuple_field_naming(0):\n-            if unqualified_type_name.startswith(\"(\"):\n-                return TYPE_KIND_TUPLE\n-            else:\n-                return TYPE_KIND_TUPLE_STRUCT\n-\n-        # REGULAR STRUCT\n-        return TYPE_KIND_REGULAR_STRUCT\n-\n-    def __classify_union(self):\n-        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n-\n-        union_members = self.get_fields()\n-        union_member_count = len(union_members)\n-        if union_member_count == 0:\n-            return TYPE_KIND_EMPTY\n-\n-        first_variant_name = union_members[0].name\n-        if first_variant_name is None:\n-            if union_member_count == 1:\n-                return TYPE_KIND_SINGLETON_ENUM\n-            else:\n-                return TYPE_KIND_REGULAR_ENUM\n-        elif first_variant_name.startswith(ENCODED_ENUM_PREFIX):\n-            assert union_member_count == 1\n-            return TYPE_KIND_COMPRESSED_ENUM\n-        else:\n-            return TYPE_KIND_REGULAR_UNION\n-\n-    def __conforms_to_field_layout(self, expected_fields):\n-        actual_fields = self.get_fields()\n-        actual_field_count = len(actual_fields)\n-\n-        if actual_field_count != len(expected_fields):\n-            return False\n-\n-        for i in range(0, actual_field_count):\n-            if actual_fields[i].name != expected_fields[i]:\n-                return False\n-\n-        return True\n-\n-    def __all_fields_conform_to_tuple_field_naming(self, start_index):\n-        fields = self.get_fields()\n-        field_count = len(fields)\n-\n-        for i in range(start_index, field_count):\n-            field_name = fields[i].name\n-            if (field_name is None) or (re.match(r\"__\\d+$\", field_name) is None):\n-                return False\n-        return True\n-\n-\n-class Value(object):\n-    \"\"\"\n-    This class provides a common interface for value-oriented operations.\n-    Sub-classes are supposed to wrap a debugger-specific value-object and\n-    provide implementations for the abstract methods in this class.\n-    \"\"\"\n-    def __init__(self, ty):\n-        self.type = ty\n-\n-    def get_child_at_index(self, index):\n-        \"\"\"Returns the value of the field, array element or variant at the given index\"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def as_integer(self):\n-        \"\"\"\n-        Try to convert the wrapped value into a Python integer. This should\n-        always succeed for values that are pointers or actual integers.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_wrapped_value(self):\n-        \"\"\"\n-        Returns the debugger-specific value-object wrapped by this object. This\n-        is sometimes needed for doing things like pointer-arithmetic in GDB.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-\n-class EncodedEnumInfo(object):\n-    \"\"\"\n-    This class provides facilities for handling enum values with compressed\n-    encoding where a non-null field in one variant doubles as the discriminant.\n-    \"\"\"\n-\n-    def __init__(self, enum_val):\n-        assert enum_val.type.get_type_kind() == TYPE_KIND_COMPRESSED_ENUM\n-        variant_name = enum_val.type.get_fields()[0].name\n-        last_separator_index = variant_name.rfind(\"$\")\n-        start_index = len(ENCODED_ENUM_PREFIX)\n-        indices_substring = variant_name[start_index:last_separator_index].split(\"$\")\n-        self.__enum_val = enum_val\n-        self.__disr_field_indices = [int(index) for index in indices_substring]\n-        self.__null_variant_name = variant_name[last_separator_index + 1:]\n-\n-    def is_null_variant(self):\n-        ty = self.__enum_val.type\n-        sole_variant_val = self.__enum_val.get_child_at_index(0)\n-        discriminant_val = sole_variant_val\n-        for disr_field_index in self.__disr_field_indices:\n-            discriminant_val = discriminant_val.get_child_at_index(disr_field_index)\n-\n-        # If the discriminant field is a fat pointer we have to consider the\n-        # first word as the true discriminant\n-        if discriminant_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT:\n-            discriminant_val = discriminant_val.get_child_at_index(0)\n-\n-        return discriminant_val.as_integer() == 0\n-\n-    def get_non_null_variant_val(self):\n-        return self.__enum_val.get_child_at_index(0)\n-\n-    def get_null_variant_name(self):\n-        return self.__null_variant_name\n-\n-\n-def get_discriminant_value_as_integer(enum_val):\n-    assert enum_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n-    # we can take any variant here because the discriminant has to be the same\n-    # for all of them.\n-    variant_val = enum_val.get_child_at_index(0)\n-    disr_val = variant_val.get_child_at_index(0)\n-    return disr_val.as_integer()\n-\n-\n-def extract_length_ptr_and_cap_from_std_vec(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VEC\n-    length_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_LENGTH)\n-    buf_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_BUF)\n-\n-    length = vec_val.get_child_at_index(length_field_index).as_integer()\n-    buf = vec_val.get_child_at_index(buf_field_index)\n-\n-    vec_ptr_val = buf.get_child_at_index(0)\n-    capacity = buf.get_child_at_index(1).as_integer()\n-    data_ptr = vec_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr, capacity)\n-\n-\n-def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VECDEQUE\n-    tail_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_TAIL)\n-    head_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_HEAD)\n-    buf_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_BUF)\n-\n-    tail = vec_val.get_child_at_index(tail_field_index).as_integer()\n-    head = vec_val.get_child_at_index(head_field_index).as_integer()\n-    buf = vec_val.get_child_at_index(buf_field_index)\n-\n-    vec_ptr_val = buf.get_child_at_index(0)\n-    capacity = buf.get_child_at_index(1).as_integer()\n-    data_ptr = vec_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (tail, head, data_ptr, capacity)\n-\n-\n-def extract_length_and_ptr_from_slice(slice_val):\n-    assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n-            slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n-\n-    length_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_LENGTH)\n-    ptr_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_DATA_PTR)\n-\n-    length = slice_val.get_child_at_index(length_field_index).as_integer()\n-    data_ptr = slice_val.get_child_at_index(ptr_field_index)\n-\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr)\n-\n-\n-UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n-\n-\n-def extract_type_name(qualified_type_name):\n-    \"\"\"Extracts the type name from a fully qualified path\"\"\"\n-    if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n-        return qualified_type_name\n-\n-    end_of_search = qualified_type_name.find(\"<\")\n-    if end_of_search < 0:\n-        end_of_search = len(qualified_type_name)\n-\n-    index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n-    if index < 0:\n-        return qualified_type_name\n-    else:\n-        return qualified_type_name[index + 2:]\n-\n-\n-try:\n-    compat_str = unicode  # Python 2\n-except NameError:\n-    compat_str = str"}, {"sha": "856b5df2de70bff896d5b89e61f9a296b1fd0a8c", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,3 +1,3 @@\n import gdb\n-import gdb_rust_pretty_printing\n-gdb_rust_pretty_printing.register_printers(gdb.current_objfile())\n+import gdb_lookup\n+gdb_lookup.register_printers(gdb.current_objfile())"}, {"sha": "2a46eaadad6f9a1b121b706e77d45882e4690959", "filename": "src/etc/gdb_lookup.py", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,92 @@\n+import gdb\n+import re\n+\n+from gdb_providers import *\n+from rust_types import *\n+\n+\n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n+_gdb_version_matched = re.search('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n+gdb_version = [int(num) for num in _gdb_version_matched.groups()] if _gdb_version_matched else []\n+\n+def register_printers(objfile):\n+    objfile.pretty_printers.append(lookup)\n+\n+\n+# BACKCOMPAT: rust 1.35\n+def is_hashbrown_hashmap(hash_map):\n+    return len(hash_map.type.fields()) == 1\n+\n+\n+def classify_rust_type(type):\n+    type_class = type.code\n+    if type_class == gdb.TYPE_CODE_STRUCT:\n+        return classify_struct(type.tag, type.fields())\n+    if type_class == gdb.TYPE_CODE_UNION:\n+        return classify_union(type.fields())\n+\n+    return RustType.OTHER\n+\n+\n+def check_enum_discriminant(valobj):\n+    content = valobj[valobj.type.fields()[0]]\n+    fields = content.type.fields()\n+    if len(fields) > 1:\n+        discriminant = int(content[fields[0]]) + 1\n+        if discriminant > len(fields):\n+            # invalid discriminant\n+            return False\n+    return True\n+\n+\n+def lookup(valobj):\n+    rust_type = classify_rust_type(valobj.type)\n+\n+    if rust_type == RustType.ENUM:\n+        # use enum provider only for GDB <7.12\n+        if gdb_version[0] < 7 or (gdb_version[0] == 7 and gdb_version[1] < 12):\n+            if check_enum_discriminant(valobj):\n+                return EnumProvider(valobj)\n+\n+    if rust_type == RustType.STD_STRING:\n+        return StdStringProvider(valobj)\n+    if rust_type == RustType.STD_OS_STRING:\n+        return StdOsStringProvider(valobj)\n+    if rust_type == RustType.STD_STR and not rust_enabled:\n+        return StdStrProvider(valobj)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return StdVecProvider(valobj)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return StdVecDequeProvider(valobj)\n+    if rust_type == RustType.STD_BTREE_SET:\n+        return StdBTreeSetProvider(valobj)\n+    if rust_type == RustType.STD_BTREE_MAP:\n+        return StdBTreeMapProvider(valobj)\n+    if rust_type == RustType.STD_HASH_MAP:\n+        if is_hashbrown_hashmap(valobj):\n+            return StdHashMapProvider(valobj)\n+        else:\n+            return StdOldHashMapProvider(valobj)\n+    if rust_type == RustType.STD_HASH_SET:\n+        hash_map = valobj[\"map\"]\n+        if is_hashbrown_hashmap(hash_map):\n+            return StdHashMapProvider(hash_map, show_values=False)\n+        else:\n+            return StdOldHashMapProvider(hash_map, show_values=False)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcProvider(valobj)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcProvider(valobj, is_atomic=True)\n+\n+    if rust_type == RustType.STD_CELL:\n+        return StdCellProvider(valobj)\n+    if rust_type == RustType.STD_REF:\n+        return StdRefProvider(valobj)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefProvider(valobj)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefCellProvider(valobj)\n+\n+    return None"}, {"sha": "cec9c56a23522b3ee2dd3feb694ce6c35afa4752", "filename": "src/etc/gdb_providers.py", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,385 @@\n+from sys import version_info\n+\n+import gdb\n+from gdb import lookup_type\n+\n+if version_info[0] >= 3:\n+    xrange = range\n+\n+ZERO_FIELD = \"__0\"\n+FIRST_FIELD = \"__1\"\n+\n+\n+def unwrap_unique_or_non_null(unique_or_nonnull):\n+    # BACKCOMPAT: rust 1.32\n+    # https://github.com/rust-lang/rust/commit/7a0911528058e87d22ea305695f4047572c5e067\n+    ptr = unique_or_nonnull[\"pointer\"]\n+    return ptr if ptr.type.code == gdb.TYPE_CODE_PTR else ptr[ZERO_FIELD]\n+\n+\n+class EnumProvider:\n+    def __init__(self, valobj):\n+        content = valobj[valobj.type.fields()[0]]\n+        fields = content.type.fields()\n+        self.empty = len(fields) == 0\n+        if not self.empty:\n+            if len(fields) == 1:\n+                discriminant = 0\n+            else:\n+                discriminant = int(content[fields[0]]) + 1\n+            self.active_variant = content[fields[discriminant]]\n+            self.name = fields[discriminant].name\n+            self.full_name = \"{}::{}\".format(valobj.type.name, self.name)\n+        else:\n+            self.full_name = valobj.type.name\n+\n+    def to_string(self):\n+        return self.full_name\n+\n+    def children(self):\n+        if not self.empty:\n+            yield self.name, self.active_variant\n+\n+\n+class StdStringProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        vec = valobj[\"vec\"]\n+        self.length = int(vec[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(vec[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"string\"\n+\n+\n+class StdOsStringProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        buf = self.valobj[\"inner\"][\"inner\"]\n+        is_windows = \"Wtf8Buf\" in buf.type.name\n+        vec = buf[ZERO_FIELD] if is_windows else buf\n+\n+        self.length = int(vec[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(vec[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    def display_hint(self):\n+        return \"string\"\n+\n+\n+class StdStrProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.length = int(valobj[\"length\"])\n+        self.data_ptr = valobj[\"data_ptr\"]\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"string\"\n+\n+\n+class StdVecProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.length = int(valobj[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return \"Vec(size={})\".format(self.length)\n+\n+    def children(self):\n+        saw_inaccessible = False\n+        for index in xrange(self.length):\n+            element_ptr = self.data_ptr + index\n+            if saw_inaccessible:\n+                return\n+            try:\n+                # rust-lang/rust#64343: passing deref expr to `str` allows\n+                # catching exception on garbage pointer\n+                str(element_ptr.dereference())\n+                yield \"[{}]\".format(index), element_ptr.dereference()\n+            except RuntimeError:\n+                saw_inaccessible = True\n+                yield str(index), \"inaccessible\"\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdVecDequeProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.head = int(valobj[\"head\"])\n+        self.tail = int(valobj[\"tail\"])\n+        self.cap = int(valobj[\"buf\"][\"cap\"])\n+        self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n+        if self.head >= self.tail:\n+            self.size = self.head - self.tail\n+        else:\n+            self.size = self.cap + self.head - self.tail\n+\n+    def to_string(self):\n+        return \"VecDeque(size={})\".format(self.size)\n+\n+    def children(self):\n+        for index in xrange(0, self.size):\n+            value = (self.data_ptr + ((self.tail + index) % self.cap)).dereference()\n+            yield \"[{}]\".format(index), value\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdRcProvider:\n+    def __init__(self, valobj, is_atomic=False):\n+        self.valobj = valobj\n+        self.is_atomic = is_atomic\n+        self.ptr = unwrap_unique_or_non_null(valobj[\"ptr\"])\n+        self.value = self.ptr[\"data\" if is_atomic else \"value\"]\n+        self.strong = self.ptr[\"strong\"][\"v\" if is_atomic else \"value\"][\"value\"]\n+        self.weak = self.ptr[\"weak\"][\"v\" if is_atomic else \"value\"][\"value\"] - 1\n+\n+    def to_string(self):\n+        if self.is_atomic:\n+            return \"Arc(strong={}, weak={})\".format(int(self.strong), int(self.weak))\n+        else:\n+            return \"Rc(strong={}, weak={})\".format(int(self.strong), int(self.weak))\n+\n+    def children(self):\n+        yield \"value\", self.value\n+        yield \"strong\", self.strong\n+        yield \"weak\", self.weak\n+\n+\n+class StdCellProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        return \"Cell\"\n+\n+    def children(self):\n+        yield \"value\", self.value\n+\n+\n+class StdRefProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"].dereference()\n+        self.borrow = valobj[\"borrow\"][\"borrow\"][\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        borrow = int(self.borrow)\n+        if borrow >= 0:\n+            return \"Ref(borrow={})\".format(borrow)\n+        else:\n+            return \"Ref(borrow_mut={})\".format(-borrow)\n+\n+    def children(self):\n+        yield \"*value\", self.value\n+        yield \"borrow\", self.borrow\n+\n+\n+class StdRefCellProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"][\"value\"]\n+        self.borrow = valobj[\"borrow\"][\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        borrow = int(self.borrow)\n+        if borrow >= 0:\n+            return \"RefCell(borrow={})\".format(borrow)\n+        else:\n+            return \"RefCell(borrow_mut={})\".format(-borrow)\n+\n+    def children(self):\n+        yield \"value\", self.value\n+        yield \"borrow\", self.borrow\n+\n+\n+# Yield each key (and optionally value) from a BoxedNode.\n+def children_of_node(boxed_node, height, want_values):\n+    def cast_to_internal(node):\n+        internal_type_name = str(node.type.target()).replace(\"LeafNode\", \"InternalNode\", 1)\n+        internal_type = lookup_type(internal_type_name)\n+        return node.cast(internal_type.pointer())\n+\n+    node_ptr = unwrap_unique_or_non_null(boxed_node[\"ptr\"])\n+    node_ptr = cast_to_internal(node_ptr) if height > 0 else node_ptr\n+    leaf = node_ptr[\"data\"] if height > 0 else node_ptr.dereference()\n+    keys = leaf[\"keys\"]\n+    values = leaf[\"vals\"]\n+    length = int(leaf[\"len\"])\n+\n+    for i in xrange(0, length + 1):\n+        if height > 0:\n+            child_ptr = node_ptr[\"edges\"][i][\"value\"][\"value\"]\n+            for child in children_of_node(child_ptr, height - 1, want_values):\n+                yield child\n+        if i < length:\n+            if want_values:\n+                yield keys[i][\"value\"][\"value\"], values[i][\"value\"][\"value\"]\n+            else:\n+                yield keys[i][\"value\"][\"value\"]\n+\n+\n+class StdBTreeSetProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+\n+    def to_string(self):\n+        return \"BTreeSet(size={})\".format(self.valobj[\"map\"][\"length\"])\n+\n+    def children(self):\n+        inner_map = self.valobj[\"map\"]\n+        if inner_map[\"length\"] > 0:\n+            root = inner_map[\"root\"]\n+            if \"core::option::Option<\" in root.type.name:\n+                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n+                root = root.cast(gdb.lookup_type(type_name))\n+\n+            node_ptr = root[\"node\"]\n+            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], False)):\n+                yield \"[{}]\".format(i), child\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdBTreeMapProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+\n+    def to_string(self):\n+        return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n+\n+    def children(self):\n+        if self.valobj[\"length\"] > 0:\n+            root = self.valobj[\"root\"]\n+            if \"core::option::Option<\" in root.type.name:\n+                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n+                root = root.cast(gdb.lookup_type(type_name))\n+\n+            node_ptr = root[\"node\"]\n+            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], True)):\n+                yield \"key{}\".format(i), child[0]\n+                yield \"val{}\".format(i), child[1]\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"map\"\n+\n+\n+# BACKCOMPAT: rust 1.35\n+class StdOldHashMapProvider:\n+    def __init__(self, valobj, show_values=True):\n+        self.valobj = valobj\n+        self.show_values = show_values\n+\n+        self.table = self.valobj[\"table\"]\n+        self.size = int(self.table[\"size\"])\n+        self.hashes = self.table[\"hashes\"]\n+        self.hash_uint_type = self.hashes.type\n+        self.hash_uint_size = self.hashes.type.sizeof\n+        self.modulo = 2 ** self.hash_uint_size\n+        self.data_ptr = self.hashes[ZERO_FIELD][\"pointer\"]\n+\n+        self.capacity_mask = int(self.table[\"capacity_mask\"])\n+        self.capacity = (self.capacity_mask + 1) % self.modulo\n+\n+        marker = self.table[\"marker\"].type\n+        self.pair_type = marker.template_argument(0)\n+        self.pair_type_size = self.pair_type.sizeof\n+\n+        self.valid_indices = []\n+        for idx in range(self.capacity):\n+            data_ptr = self.data_ptr.cast(self.hash_uint_type.pointer())\n+            address = data_ptr + idx\n+            hash_uint = address.dereference()\n+            hash_ptr = hash_uint[ZERO_FIELD][\"pointer\"]\n+            if int(hash_ptr) != 0:\n+                self.valid_indices.append(idx)\n+\n+    def to_string(self):\n+        if self.show_values:\n+            return \"HashMap(size={})\".format(self.size)\n+        else:\n+            return \"HashSet(size={})\".format(self.size)\n+\n+    def children(self):\n+        start = int(self.data_ptr) & ~1\n+\n+        hashes = self.hash_uint_size * self.capacity\n+        align = self.pair_type_size\n+        len_rounded_up = (((((hashes + align) % self.modulo - 1) % self.modulo) & ~(\n+                (align - 1) % self.modulo)) % self.modulo - hashes) % self.modulo\n+\n+        pairs_offset = hashes + len_rounded_up\n+        pairs_start = gdb.Value(start + pairs_offset).cast(self.pair_type.pointer())\n+\n+        for index in range(self.size):\n+            table_index = self.valid_indices[index]\n+            idx = table_index & self.capacity_mask\n+            element = (pairs_start + idx).dereference()\n+            if self.show_values:\n+                yield \"key{}\".format(index), element[ZERO_FIELD]\n+                yield \"val{}\".format(index), element[FIRST_FIELD]\n+            else:\n+                yield \"[{}]\".format(index), element[ZERO_FIELD]\n+\n+    def display_hint(self):\n+        return \"map\" if self.show_values else \"array\"\n+\n+\n+class StdHashMapProvider:\n+    def __init__(self, valobj, show_values=True):\n+        self.valobj = valobj\n+        self.show_values = show_values\n+\n+        table = self.valobj[\"base\"][\"table\"]\n+        capacity = int(table[\"bucket_mask\"]) + 1\n+        ctrl = table[\"ctrl\"][\"pointer\"]\n+\n+        self.size = int(table[\"items\"])\n+        self.data_ptr = table[\"data\"][\"pointer\"]\n+        self.pair_type = self.data_ptr.dereference().type\n+\n+        self.valid_indices = []\n+        for idx in range(capacity):\n+            address = ctrl + idx\n+            value = address.dereference()\n+            is_presented = value & 128 == 0\n+            if is_presented:\n+                self.valid_indices.append(idx)\n+\n+    def to_string(self):\n+        if self.show_values:\n+            return \"HashMap(size={})\".format(self.size)\n+        else:\n+            return \"HashSet(size={})\".format(self.size)\n+\n+    def children(self):\n+        pairs_start = self.data_ptr\n+\n+        for index in range(self.size):\n+            idx = self.valid_indices[index]\n+            element = (pairs_start + idx).dereference()\n+            if self.show_values:\n+                yield \"key{}\".format(index), element[ZERO_FIELD]\n+                yield \"val{}\".format(index), element[FIRST_FIELD]\n+            else:\n+                yield \"[{}]\".format(index), element[ZERO_FIELD]\n+\n+    def display_hint(self):\n+        return \"map\" if self.show_values else \"array\""}, {"sha": "d580329cb504ed9c6d40ddf36e486e94f9df5670", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "removed", "additions": 0, "deletions": 466, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,466 +0,0 @@\n-import gdb\n-import re\n-import sys\n-import debugger_pretty_printers_common as rustpp\n-\n-# We want a version of `range` which doesn't allocate an intermediate list,\n-# specifically it should use a lazy iterator. In Python 2 this was `xrange`, but\n-# if we're running with Python 3 then we need to use `range` instead.\n-if sys.version_info[0] >= 3:\n-    xrange = range\n-\n-rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n-\n-# The btree pretty-printers fail in a confusing way unless\n-# https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n-# This fix went in 8.1, so check for that.\n-# See https://github.com/rust-lang/rust/issues/56730\n-gdb_81 = False\n-_match = re.search('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n-if _match:\n-    if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n-        gdb_81 = True\n-\n-# ===============================================================================\n-# GDB Pretty Printing Module for Rust\n-# ===============================================================================\n-\n-\n-class GdbType(rustpp.Type):\n-\n-    def __init__(self, ty):\n-        super(GdbType, self).__init__()\n-        self.ty = ty\n-        self.fields = None\n-\n-    def get_unqualified_type_name(self):\n-        tag = self.ty.tag\n-\n-        if tag is None:\n-            return tag\n-\n-        return rustpp.extract_type_name(tag).replace(\"&'static \", \"&\")\n-\n-    def get_dwarf_type_kind(self):\n-        if self.ty.code == gdb.TYPE_CODE_STRUCT:\n-            return rustpp.DWARF_TYPE_CODE_STRUCT\n-\n-        if self.ty.code == gdb.TYPE_CODE_UNION:\n-            return rustpp.DWARF_TYPE_CODE_UNION\n-\n-        if self.ty.code == gdb.TYPE_CODE_PTR:\n-            return rustpp.DWARF_TYPE_CODE_PTR\n-\n-        if self.ty.code == gdb.TYPE_CODE_ENUM:\n-            return rustpp.DWARF_TYPE_CODE_ENUM\n-\n-    def get_fields(self):\n-        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n-        if self.fields is None:\n-            self.fields = list(self.ty.fields())\n-        return self.fields\n-\n-    def get_wrapped_value(self):\n-        return self.ty\n-\n-\n-class GdbValue(rustpp.Value):\n-    def __init__(self, gdb_val):\n-        super(GdbValue, self).__init__(GdbType(gdb_val.type))\n-        self.gdb_val = gdb_val\n-        self.children = {}\n-\n-    def get_child_at_index(self, index):\n-        child = self.children.get(index)\n-        if child is None:\n-            gdb_field = get_field_at_index(self.gdb_val, index)\n-            child = GdbValue(self.gdb_val[gdb_field])\n-            self.children[index] = child\n-        return child\n-\n-    def as_integer(self):\n-        if self.gdb_val.type.code == gdb.TYPE_CODE_PTR:\n-            as_str = rustpp.compat_str(self.gdb_val).split()[0]\n-            return int(as_str, 0)\n-        return int(self.gdb_val)\n-\n-    def get_wrapped_value(self):\n-        return self.gdb_val\n-\n-\n-def register_printers(objfile):\n-    \"\"\"Registers Rust pretty printers for the given objfile\"\"\"\n-    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n-\n-\n-def rust_pretty_printer_lookup_function(gdb_val):\n-    \"\"\"\n-    Returns the correct Rust pretty printer for the given value\n-    if there is one\n-    \"\"\"\n-\n-    val = GdbValue(gdb_val)\n-    type_kind = val.type.get_type_kind()\n-\n-    if type_kind == rustpp.TYPE_KIND_SLICE:\n-        return RustSlicePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n-        return RustStdVecPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n-        return RustStdVecDequePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_BTREESET and gdb_81:\n-        return RustStdBTreeSetPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP and gdb_81:\n-        return RustStdBTreeMapPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n-        return RustStdStringPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_OS_STRING:\n-        return RustOsStringPrinter(val)\n-\n-    # Checks after this point should only be for \"compiler\" types --\n-    # things that gdb's Rust language support knows about.\n-    if rust_enabled:\n-        return None\n-\n-    if type_kind == rustpp.TYPE_KIND_EMPTY:\n-        return RustEmptyPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=True,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return RustStringSlicePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=True,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n-        return RustCStyleVariantPrinter(val.get_child_at_index(0))\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=True,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n-        variant = get_field_at_index(gdb_val, 0)\n-        return rust_pretty_printer_lookup_function(gdb_val[variant])\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n-        # This is a regular enum, extract the discriminant\n-        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n-        variant = get_field_at_index(gdb_val, discriminant_val)\n-        return rust_pretty_printer_lookup_function(gdb_val[variant])\n-\n-    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n-        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n-        if encoded_enum_info.is_null_variant():\n-            return IdentityPrinter(encoded_enum_info.get_null_variant_name())\n-\n-        non_null_val = encoded_enum_info.get_non_null_variant_val()\n-        return rust_pretty_printer_lookup_function(non_null_val.get_wrapped_value())\n-\n-    # No pretty printer has been found\n-    return None\n-\n-\n-# =------------------------------------------------------------------------------\n-# Pretty Printer Classes\n-# =------------------------------------------------------------------------------\n-class RustEmptyPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        return self.__val.type.get_unqualified_type_name()\n-\n-\n-class RustStructPrinter(object):\n-    def __init__(self, val, omit_first_field, omit_type_name, is_tuple_like):\n-        self.__val = val\n-        self.__omit_first_field = omit_first_field\n-        self.__omit_type_name = omit_type_name\n-        self.__is_tuple_like = is_tuple_like\n-\n-    def to_string(self):\n-        if self.__omit_type_name:\n-            return None\n-        return self.__val.type.get_unqualified_type_name()\n-\n-    def children(self):\n-        cs = []\n-        wrapped_value = self.__val.get_wrapped_value()\n-\n-        for number, field in enumerate(self.__val.type.get_fields()):\n-            field_value = wrapped_value[field.name]\n-            if self.__is_tuple_like:\n-                cs.append((str(number), field_value))\n-            else:\n-                cs.append((field.name, field_value))\n-\n-        if self.__omit_first_field:\n-            cs = cs[1:]\n-\n-        return cs\n-\n-    def display_hint(self):\n-        if self.__is_tuple_like:\n-            return \"array\"\n-        else:\n-            return \"\"\n-\n-\n-class RustSlicePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % length))\n-\n-    def children(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        assert data_ptr.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-        raw_ptr = data_ptr.get_wrapped_value()\n-\n-        for index in xrange(0, length):\n-            yield (str(index), (raw_ptr + index).dereference())\n-\n-\n-class RustStringSlicePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        raw_ptr = data_ptr.get_wrapped_value()\n-        return raw_ptr.lazy_string(encoding=\"utf-8\", length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustStdVecPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (length, cap)))\n-\n-    def children(self):\n-        saw_inaccessible = False\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n-        gdb_ptr = data_ptr.get_wrapped_value()\n-        for index in xrange(0, length):\n-            if saw_inaccessible:\n-                return\n-            try:\n-                # rust-lang/rust#64343: passing deref expr to `str` allows\n-                # catching exception on garbage pointer\n-                str((gdb_ptr + index).dereference())\n-                yield (str(index), (gdb_ptr + index).dereference())\n-            except RuntimeError:\n-                saw_inaccessible = True\n-                yield (str(index), \"inaccessible\")\n-\n-\n-class RustStdVecDequePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (tail, head, data_ptr, cap) = \\\n-            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n-        if head >= tail:\n-            size = head - tail\n-        else:\n-            size = cap + head - tail\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (size, cap)))\n-\n-    def children(self):\n-        (tail, head, data_ptr, cap) = \\\n-            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n-        gdb_ptr = data_ptr.get_wrapped_value()\n-        if head >= tail:\n-            size = head - tail\n-        else:\n-            size = cap + head - tail\n-        for index in xrange(0, size):\n-            yield (str(index), (gdb_ptr + ((tail + index) % cap)).dereference())\n-\n-\n-# Yield each key (and optionally value) from a BoxedNode.\n-def children_of_node(boxed_node, height, want_values):\n-    node_ptr = boxed_node['ptr']['pointer']\n-    if height > 0:\n-        type_name = str(node_ptr.type.target()).replace('LeafNode', 'InternalNode', 1)\n-        node_type = gdb.lookup_type(type_name)\n-        node_ptr = node_ptr.cast(node_type.pointer())\n-        leaf = node_ptr['data']\n-    else:\n-        leaf = node_ptr.dereference()\n-    keys = leaf['keys']\n-    if want_values:\n-        values = leaf['vals']\n-    length = int(leaf['len'])\n-    for i in xrange(0, length + 1):\n-        if height > 0:\n-            child_ptr = node_ptr['edges'][i]['value']['value']\n-            for child in children_of_node(child_ptr, height - 1, want_values):\n-                yield child\n-        if i < length:\n-            if want_values:\n-                yield (keys[i]['value']['value'], values[i]['value']['value'])\n-            else:\n-                yield keys[i]['value']['value']\n-\n-\n-class RustStdBTreeSetPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % self.__val.get_wrapped_value()['map']['length']))\n-\n-    def children(self):\n-        prev_idx = None\n-        innermap = GdbValue(self.__val.get_wrapped_value()['map'])\n-        if innermap.get_wrapped_value()['length'] > 0:\n-            root = GdbValue(innermap.get_wrapped_value()['root'])\n-            type_name = str(root.type.ty.name).replace('core::option::Option<', '', 1)[:-1]\n-            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n-            node_ptr = root['node']\n-            i = 0\n-            for child in children_of_node(node_ptr, root['height'], False):\n-                yield (str(i), child)\n-                i = i + 1\n-\n-\n-class RustStdBTreeMapPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"map\"\n-\n-    def to_string(self):\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % self.__val.get_wrapped_value()['length']))\n-\n-    def children(self):\n-        if self.__val.get_wrapped_value()['length'] > 0:\n-            root = GdbValue(self.__val.get_wrapped_value()['root'])\n-            type_name = str(root.type.ty.name).replace('core::option::Option<', '', 1)[:-1]\n-            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n-            node_ptr = root['node']\n-            i = 0\n-            for child in children_of_node(node_ptr, root['height'], True):\n-                yield (str(i), child[0])\n-                yield (str(i), child[1])\n-                i = i + 1\n-\n-\n-class RustStdStringPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        vec = self.__val.get_child_at_index(0)\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-        return data_ptr.get_wrapped_value().lazy_string(encoding=\"utf-8\",\n-                                                        length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustOsStringPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        buf = self.__val.get_child_at_index(0)\n-        vec = buf.get_child_at_index(0)\n-        if vec.type.get_unqualified_type_name() == \"Wtf8Buf\":\n-            vec = vec.get_child_at_index(0)\n-\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n-            vec)\n-        return data_ptr.get_wrapped_value().lazy_string(length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustCStyleVariantPrinter(object):\n-    def __init__(self, val):\n-        assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM\n-        self.__val = val\n-\n-    def to_string(self):\n-        return str(self.__val.get_wrapped_value())\n-\n-\n-class IdentityPrinter(object):\n-    def __init__(self, string):\n-        self.string = string\n-\n-    def to_string(self):\n-        return self.string\n-\n-\n-def get_field_at_index(gdb_val, index):\n-    i = 0\n-    for field in gdb_val.type.fields():\n-        if i == index:\n-            return field\n-        i += 1\n-    return None"}, {"sha": "2e7958325cd61e975b1027a1e6e8765452181631", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -114,7 +114,10 @@\n     from html.parser import HTMLParser\n except ImportError:\n     from HTMLParser import HTMLParser\n-from xml.etree import cElementTree as ET\n+try:\n+    from xml.etree import cElementTree as ET\n+except ImportError:\n+    from xml.etree import ElementTree as ET\n \n try:\n     from html.entities import name2codepoint"}, {"sha": "2cfc8698c4b67f7e9c8c9cb569aaa54758645542", "filename": "src/etc/installer/exe/modpath.iss", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,219 +0,0 @@\n-// ----------------------------------------------------------------------------\n-//\n-// Inno Setup Ver:\t5.4.2\n-// Script Version:\t1.4.1\n-// Author:\t\t\tJared Breland <jbreland@legroom.net>\n-// Homepage:\t\thttp://www.legroom.net/software\n-// License:\t\t\tGNU Lesser General Public License (LGPL), version 3\n-//\t\t\t\t\t\thttp://www.gnu.org/licenses/lgpl.html\n-//\n-// Script Function:\n-//\tAllow modification of environmental path directly from Inno Setup installers\n-//\n-// Instructions:\n-//\tCopy modpath.iss to the same directory as your setup script\n-//\n-//\tAdd this statement to your [Setup] section\n-//\t\tChangesEnvironment=true\n-//\n-//\tAdd this statement to your [Tasks] section\n-//\tYou can change the Description or Flags\n-//\tYou can change the Name, but it must match the ModPathName setting below\n-//\t\tName: modifypath; Description: &Add application directory to your environmental path; Flags: unchecked\n-//\n-//\tAdd the following to the end of your [Code] section\n-//\tModPathName defines the name of the task defined above\n-//\tModPathType defines whether the 'user' or 'system' path will be modified;\n-//\t\tthis will default to user if anything other than system is set\n-//\tsetArrayLength must specify the total number of dirs to be added\n-//\tResult[0] contains first directory, Result[1] contains second, etc.\n-//\t\tconst\n-//\t\t\tModPathName = 'modifypath';\n-//\t\t\tModPathType = 'user';\n-//\n-//\t\tfunction ModPathDir(): TArrayOfString;\n-//\t\tbegin\n-//\t\t\tsetArrayLength(Result, 1);\n-//\t\t\tResult[0] := ExpandConstant('{app}');\n-//\t\tend;\n-//\t\t#include \"modpath.iss\"\n-// ----------------------------------------------------------------------------\n-\n-procedure ModPath();\n-var\n-\toldpath:\tString;\n-\tnewpath:\tString;\n-\tupdatepath:\tBoolean;\n-\tpathArr:\tTArrayOfString;\n-\taExecFile:\tString;\n-\taExecArr:\tTArrayOfString;\n-\ti, d:\t\tInteger;\n-\tpathdir:\tTArrayOfString;\n-\tregroot:\tInteger;\n-\tregpath:\tString;\n-\n-begin\n-\t// Get constants from main script and adjust behavior accordingly\n-\t// ModPathType MUST be 'system' or 'user'; force 'user' if invalid\n-\tif ModPathType = 'system' then begin\n-\t\tregroot := HKEY_LOCAL_MACHINE;\n-\t\tregpath := 'SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment';\n-\tend else begin\n-\t\tregroot := HKEY_CURRENT_USER;\n-\t\tregpath := 'Environment';\n-\tend;\n-\n-\t// Get array of new directories and act on each individually\n-\tpathdir := ModPathDir();\n-\tfor d := 0 to GetArrayLength(pathdir)-1 do begin\n-\t\tupdatepath := true;\n-\n-\t\t// Modify WinNT path\n-\t\tif UsingWinNT() = true then begin\n-\n-\t\t\t// Get current path, split into an array\n-\t\t\tRegQueryStringValue(regroot, regpath, 'Path', oldpath);\n-\t\t\toldpath := oldpath + ';';\n-\t\t\ti := 0;\n-\n-\t\t\twhile (Pos(';', oldpath) > 0) do begin\n-\t\t\t\tSetArrayLength(pathArr, i+1);\n-\t\t\t\tpathArr[i] := Copy(oldpath, 0, Pos(';', oldpath)-1);\n-\t\t\t\toldpath := Copy(oldpath, Pos(';', oldpath)+1, Length(oldpath));\n-\t\t\t\ti := i + 1;\n-\n-\t\t\t\t// Check if current directory matches app dir\n-\t\t\t\tif pathdir[d] = pathArr[i-1] then begin\n-\t\t\t\t\t// if uninstalling, remove dir from path\n-\t\t\t\t\tif IsUninstaller() = true then begin\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t// if installing, flag that dir already exists in path\n-\t\t\t\t\tend else begin\n-\t\t\t\t\t\tupdatepath := false;\n-\t\t\t\t\tend;\n-\t\t\t\tend;\n-\n-\t\t\t\t// Add current directory to new path\n-\t\t\t\tif i = 1 then begin\n-\t\t\t\t\tnewpath := pathArr[i-1];\n-\t\t\t\tend else begin\n-\t\t\t\t\tnewpath := newpath + ';' + pathArr[i-1];\n-\t\t\t\tend;\n-\t\t\tend;\n-\n-\t\t\t// Append app dir to path if not already included\n-\t\t\tif (IsUninstaller() = false) AND (updatepath = true) then\n-\t\t\t\tnewpath := newpath + ';' + pathdir[d];\n-\n-\t\t\t// Write new path\n-\t\t\tRegWriteStringValue(regroot, regpath, 'Path', newpath);\n-\n-\t\t// Modify Win9x path\n-\t\tend else begin\n-\n-\t\t\t// Convert to shortened dirname\n-\t\t\tpathdir[d] := GetShortName(pathdir[d]);\n-\n-\t\t\t// If autoexec.bat exists, check if app dir already exists in path\n-\t\t\taExecFile := 'C:\\AUTOEXEC.BAT';\n-\t\t\tif FileExists(aExecFile) then begin\n-\t\t\t\tLoadStringsFromFile(aExecFile, aExecArr);\n-\t\t\t\tfor i := 0 to GetArrayLength(aExecArr)-1 do begin\n-\t\t\t\t\tif IsUninstaller() = false then begin\n-\t\t\t\t\t\t// If app dir already exists while installing, skip add\n-\t\t\t\t\t\tif (Pos(pathdir[d], aExecArr[i]) > 0) then\n-\t\t\t\t\t\t\tupdatepath := false;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\tend else begin\n-\t\t\t\t\t\t// If app dir exists and = what we originally set, then delete at uninstall\n-\t\t\t\t\t\tif aExecArr[i] = 'SET PATH=%PATH%;' + pathdir[d] then\n-\t\t\t\t\t\t\taExecArr[i] := '';\n-\t\t\t\t\tend;\n-\t\t\t\tend;\n-\t\t\tend;\n-\n-\t\t\t// If app dir not found, or autoexec.bat didn't exist, then (create and) append to current path\n-\t\t\tif (IsUninstaller() = false) AND (updatepath = true) then begin\n-\t\t\t\tSaveStringToFile(aExecFile, #13#10 + 'SET PATH=%PATH%;' + pathdir[d], True);\n-\n-\t\t\t// If uninstalling, write the full autoexec out\n-\t\t\tend else begin\n-\t\t\t\tSaveStringsToFile(aExecFile, aExecArr, False);\n-\t\t\tend;\n-\t\tend;\n-\tend;\n-end;\n-\n-// Split a string into an array using passed delimiter\n-procedure Explode(var Dest: TArrayOfString; Text: String; Separator: String);\n-var\n-\ti: Integer;\n-begin\n-\ti := 0;\n-\trepeat\n-\t\tSetArrayLength(Dest, i+1);\n-\t\tif Pos(Separator,Text) > 0 then\tbegin\n-\t\t\tDest[i] := Copy(Text, 1, Pos(Separator, Text)-1);\n-\t\t\tText := Copy(Text, Pos(Separator,Text) + Length(Separator), Length(Text));\n-\t\t\ti := i + 1;\n-\t\tend else begin\n-\t\t\t Dest[i] := Text;\n-\t\t\t Text := '';\n-\t\tend;\n-\tuntil Length(Text)=0;\n-end;\n-\n-\n-procedure ModPathCurStepChanged(CurStep: TSetupStep);\n-var\n-\ttaskname:\tString;\n-begin\n-\ttaskname := ModPathName;\n-\tif CurStep = ssPostInstall then\n-\t\tif IsTaskSelected(taskname) then\n-\t\t\tModPath();\n-end;\n-\n-procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);\n-var\n-\taSelectedTasks:\tTArrayOfString;\n-\ti:\t\t\t\tInteger;\n-\ttaskname:\t\tString;\n-\tregpath:\t\tString;\n-\tregstring:\t\tString;\n-\tappid:\t\t\tString;\n-begin\n-\t// only run during actual uninstall\n-\tif CurUninstallStep = usUninstall then begin\n-\t\t// get list of selected tasks saved in registry at install time\n-\t\tappid := '{#emit SetupSetting(\"AppId\")}';\n-\t\tif appid = '' then appid := '{#emit SetupSetting(\"AppName\")}';\n-\t\tregpath := ExpandConstant('Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\'+appid+'_is1');\n-\t\tRegQueryStringValue(HKLM, regpath, 'Inno Setup: Selected Tasks', regstring);\n-\t\tif regstring = '' then RegQueryStringValue(HKCU, regpath, 'Inno Setup: Selected Tasks', regstring);\n-\n-\t\t// check each task; if matches modpath taskname, trigger patch removal\n-\t\tif regstring <> '' then begin\n-\t\t\ttaskname := ModPathName;\n-\t\t\tExplode(aSelectedTasks, regstring, ',');\n-\t\t\tif GetArrayLength(aSelectedTasks) > 0 then begin\n-\t\t\t\tfor i := 0 to GetArrayLength(aSelectedTasks)-1 do begin\n-\t\t\t\t\tif comparetext(aSelectedTasks[i], taskname) = 0 then\n-\t\t\t\t\t\tModPath();\n-\t\t\t\tend;\n-\t\t\tend;\n-\t\tend;\n-\tend;\n-end;\n-\n-function NeedRestart(): Boolean;\n-var\n-\ttaskname:\tString;\n-begin\n-\ttaskname := ModPathName;\n-\tif IsTaskSelected(taskname) and not UsingWinNT() then begin\n-\t\tResult := True;\n-\tend else begin\n-\t\tResult := False;\n-\tend;\n-end;"}, {"sha": "70648beac38b03565f77547f23542998dcce10b0", "filename": "src/etc/installer/exe/rust.iss", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Frust.iss?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,87 +0,0 @@\n-#define CFG_RELEASE_NUM GetEnv(\"CFG_RELEASE_NUM\")\n-#define CFG_RELEASE GetEnv(\"CFG_RELEASE\")\n-#define CFG_PACKAGE_NAME GetEnv(\"CFG_PACKAGE_NAME\")\n-#define CFG_BUILD GetEnv(\"CFG_BUILD\")\n-\n-[Setup]\n-\n-SetupIconFile=rust-logo.ico\n-AppName=Rust\n-AppVersion={#CFG_RELEASE}\n-AppCopyright=Copyright (C) 2006-2014 Mozilla Foundation, MIT license\n-AppPublisher=Mozilla Foundation\n-AppPublisherURL=http://www.rust-lang.org\n-VersionInfoVersion={#CFG_RELEASE_NUM}\n-LicenseFile=LICENSE.txt\n-\n-PrivilegesRequired=lowest\n-DisableWelcomePage=true\n-DisableProgramGroupPage=true\n-DisableReadyPage=true\n-DisableStartupPrompt=true\n-\n-OutputDir=.\\\n-SourceDir=.\\\n-OutputBaseFilename={#CFG_PACKAGE_NAME}-{#CFG_BUILD}\n-DefaultDirName={sd}\\Rust\n-\n-Compression=lzma2/normal\n-InternalCompressLevel=normal\n-SolidCompression=no\n-\n-ChangesEnvironment=true\n-ChangesAssociations=no\n-AllowUNCPath=false\n-AllowNoIcons=true\n-Uninstallable=yes\n-\n-[Tasks]\n-Name: modifypath; Description: &Add {app}\\bin to your PATH (recommended)\n-\n-[Components]\n-Name: rust; Description: \"Rust compiler and standard crates\"; Types: full compact custom; Flags: fixed\n-#ifdef MINGW\n-Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n-#endif\n-Name: docs; Description: \"HTML documentation\"; Types: full\n-Name: cargo; Description: \"Cargo, the Rust package manager\"; Types: full\n-Name: std; Description: \"The Rust Standard Library\"; Types: full\n-// tool-rls-start\n-Name: rls; Description: \"RLS, the Rust Language Server\"\n-// tool-rls-end\n-\n-[Files]\n-Source: \"rustc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n-#ifdef MINGW\n-Source: \"rust-mingw/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: gcc\n-#endif\n-Source: \"rust-docs/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: docs\n-Source: \"cargo/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: cargo\n-Source: \"rust-std/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: std\n-// tool-rls-start\n-Source: \"rls/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n-Source: \"rust-analysis/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n-// tool-rls-end\n-\n-[Code]\n-const\n-\tModPathName = 'modifypath';\n-\tModPathType = 'user';\n-\n-function ModPathDir(): TArrayOfString;\n-begin\n-\tsetArrayLength(Result, 1)\n-\tResult[0] := ExpandConstant('{app}\\bin');\n-end;\n-\n-#include \"modpath.iss\"\n-#include \"upgrade.iss\"\n-\n-// Both modpath.iss and upgrade.iss want to overload CurStepChanged.\n-// This version does the overload then delegates to each.\n-\n-procedure CurStepChanged(CurStep: TSetupStep);\n-begin\n-  UpgradeCurStepChanged(CurStep);\n-  ModPathCurStepChanged(CurStep);\n-end;"}, {"sha": "29da7c333bb72b3c1cc1d6d463b8acc792c16363", "filename": "src/etc/installer/exe/upgrade.iss", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Finstaller%2Fexe%2Fupgrade.iss", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Finstaller%2Fexe%2Fupgrade.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Fupgrade.iss?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,61 +0,0 @@\n-// The following code taken from https://stackoverflow.com/questions/2000296/innosetup-how-to-automatically-uninstall-previous-installed-version\n-// It performs upgrades by running the uninstaller before the install\n-\n-/////////////////////////////////////////////////////////////////////\n-function GetUninstallString(): String;\n-var\n-  sUnInstPath: String;\n-  sUnInstallString: String;\n-begin\n-  sUnInstPath := ExpandConstant('Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Rust_is1');\n-  sUnInstallString := '';\n-  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then\n-    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);\n-  Result := sUnInstallString;\n-end;\n-\n-\n-/////////////////////////////////////////////////////////////////////\n-function IsUpgrade(): Boolean;\n-begin\n-  Result := (GetUninstallString() <> '');\n-end;\n-\n-\n-/////////////////////////////////////////////////////////////////////\n-function UnInstallOldVersion(): Integer;\n-var\n-  sUnInstallString: String;\n-  iResultCode: Integer;\n-begin\n-// Return Values:\n-// 1 - uninstall string is empty\n-// 2 - error executing the UnInstallString\n-// 3 - successfully executed the UnInstallString\n-\n-  // default return value\n-  Result := 0;\n-\n-  // get the uninstall string of the old app\n-  sUnInstallString := GetUninstallString();\n-  if sUnInstallString <> '' then begin\n-    sUnInstallString := RemoveQuotes(sUnInstallString);\n-    if Exec(sUnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then\n-      Result := 3\n-    else\n-      Result := 2;\n-  end else\n-    Result := 1;\n-end;\n-\n-/////////////////////////////////////////////////////////////////////\n-procedure UpgradeCurStepChanged(CurStep: TSetupStep);\n-begin\n-  if (CurStep=ssInstall) then\n-  begin\n-    if (IsUpgrade()) then\n-    begin\n-      UnInstallOldVersion();\n-    end;\n-  end;\n-end;"}, {"sha": "f470c62d8992730b88bdfbba617d411f88a5fb19", "filename": "src/etc/lldb_commands", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Flldb_commands", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Flldb_commands", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_commands?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,19 @@\n+command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_lookup.py\\\"\n+type synthetic add -l lldb_lookup.synthetic_lookup -x \\\".*\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)String$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&str$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&\\\\[.+\\\\]$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::ffi::([a-z_]+::)+)OsString$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Vec<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)VecDeque<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)BTreeSet<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)BTreeMap<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::collections::([a-z_]+::)+)HashMap<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::collections::([a-z_]+::)+)HashSet<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Rc<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Arc<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)Cell<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)Ref<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)RefMut<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)RefCell<.+>$\\\" --category Rust\n+type category enable Rust"}, {"sha": "13420fbaf0a759fa2aa0973b85d01ccc58fb8de9", "filename": "src/etc/lldb_lookup.py", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,115 @@\n+import lldb\n+\n+from lldb_providers import *\n+from rust_types import RustType, classify_struct, classify_union\n+\n+\n+# BACKCOMPAT: rust 1.35\n+def is_hashbrown_hashmap(hash_map):\n+    return len(hash_map.type.fields) == 1\n+\n+\n+def classify_rust_type(type):\n+    type_class = type.GetTypeClass()\n+    if type_class == lldb.eTypeClassStruct:\n+        return classify_struct(type.name, type.fields)\n+    if type_class == lldb.eTypeClassUnion:\n+        return classify_union(type.fields)\n+\n+    return RustType.OTHER\n+\n+\n+def summary_lookup(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    \"\"\"Returns the summary provider for the given value\"\"\"\n+    rust_type = classify_rust_type(valobj.GetType())\n+\n+    if rust_type == RustType.STD_STRING:\n+        return StdStringSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_OS_STRING:\n+        return StdOsStringSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_STR:\n+        return StdStrSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_SLICE:\n+        return SizeSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_HASH_MAP:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_HASH_SET:\n+        return SizeSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_REF:\n+        return StdRefSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefSummaryProvider(valobj, dict)\n+\n+    return \"\"\n+\n+\n+def synthetic_lookup(valobj, dict):\n+    # type: (SBValue, dict) -> object\n+    \"\"\"Returns the synthetic provider for the given value\"\"\"\n+    rust_type = classify_rust_type(valobj.GetType())\n+\n+    if rust_type == RustType.STRUCT:\n+        return StructSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STRUCT_VARIANT:\n+        return StructSyntheticProvider(valobj, dict, is_variant=True)\n+    if rust_type == RustType.TUPLE:\n+        return TupleSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.TUPLE_VARIANT:\n+        return TupleSyntheticProvider(valobj, dict, is_variant=True)\n+    if rust_type == RustType.EMPTY:\n+        return EmptySyntheticProvider(valobj, dict)\n+    if rust_type == RustType.REGULAR_ENUM:\n+        discriminant = valobj.GetChildAtIndex(0).GetChildAtIndex(0).GetValueAsUnsigned()\n+        return synthetic_lookup(valobj.GetChildAtIndex(discriminant), dict)\n+    if rust_type == RustType.SINGLETON_ENUM:\n+        return synthetic_lookup(valobj.GetChildAtIndex(0), dict)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return StdVecSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return StdVecDequeSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_SLICE:\n+        return StdSliceSyntheticProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_HASH_MAP:\n+        if is_hashbrown_hashmap(valobj):\n+            return StdHashMapSyntheticProvider(valobj, dict)\n+        else:\n+            return StdOldHashMapSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_HASH_SET:\n+        hash_map = valobj.GetChildAtIndex(0)\n+        if is_hashbrown_hashmap(hash_map):\n+            return StdHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+        else:\n+            return StdOldHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcSyntheticProvider(valobj, dict, is_atomic=True)\n+\n+    if rust_type == RustType.STD_CELL:\n+        return StdCellSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF:\n+        return StdRefSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefSyntheticProvider(valobj, dict, is_cell=True)\n+\n+    return DefaultSynthteticProvider(valobj, dict)"}, {"sha": "3c7817b3a618d6d33c468d1dbfdd0fd07e308253", "filename": "src/etc/lldb_providers.py", "status": "added", "additions": 715, "deletions": 0, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,715 @@\n+import sys\n+\n+from lldb import SBValue, SBData, SBError, eBasicTypeLong, eBasicTypeUnsignedLong, \\\n+    eBasicTypeUnsignedChar\n+\n+# from lldb.formatters import Logger\n+\n+####################################################################################################\n+# This file contains two kinds of pretty-printers: summary and synthetic.\n+#\n+# Important classes from LLDB module:\n+#   SBValue: the value of a variable, a register, or an expression\n+#   SBType:  the data type; each SBValue has a corresponding SBType\n+#\n+# Summary provider is a function with the type `(SBValue, dict) -> str`.\n+#   The first parameter is the object encapsulating the actual variable being displayed;\n+#   The second parameter is an internal support parameter used by LLDB, and you should not touch it.\n+#\n+# Synthetic children is the way to provide a children-based representation of the object's value.\n+# Synthetic provider is a class that implements the following interface:\n+#\n+#     class SyntheticChildrenProvider:\n+#         def __init__(self, SBValue, dict)\n+#         def num_children(self)\n+#         def get_child_index(self, str)\n+#         def get_child_at_index(self, int)\n+#         def update(self)\n+#         def has_children(self)\n+#         def get_value(self)\n+#\n+#\n+# You can find more information and examples here:\n+#   1. https://lldb.llvm.org/varformats.html\n+#   2. https://lldb.llvm.org/python-reference.html\n+#   3. https://lldb.llvm.org/python_reference/lldb.formatters.cpp.libcxx-pysrc.html\n+#   4. https://github.com/llvm-mirror/lldb/tree/master/examples/summaries/cocoa\n+####################################################################################################\n+\n+PY3 = sys.version_info[0] == 3\n+\n+\n+class ValueBuilder:\n+    def __init__(self, valobj):\n+        # type: (SBValue) -> ValueBuilder\n+        self.valobj = valobj\n+        process = valobj.GetProcess()\n+        self.endianness = process.GetByteOrder()\n+        self.pointer_size = process.GetAddressByteSize()\n+\n+    def from_int(self, name, value):\n+        # type: (str, int) -> SBValue\n+        type = self.valobj.GetType().GetBasicType(eBasicTypeLong)\n+        data = SBData.CreateDataFromSInt64Array(self.endianness, self.pointer_size, [value])\n+        return self.valobj.CreateValueFromData(name, data, type)\n+\n+    def from_uint(self, name, value):\n+        # type: (str, int) -> SBValue\n+        type = self.valobj.GetType().GetBasicType(eBasicTypeUnsignedLong)\n+        data = SBData.CreateDataFromUInt64Array(self.endianness, self.pointer_size, [value])\n+        return self.valobj.CreateValueFromData(name, data, type)\n+\n+\n+def unwrap_unique_or_non_null(unique_or_nonnull):\n+    # BACKCOMPAT: rust 1.32\n+    # https://github.com/rust-lang/rust/commit/7a0911528058e87d22ea305695f4047572c5e067\n+    ptr = unique_or_nonnull.GetChildMemberWithName(\"pointer\")\n+    return ptr if ptr.TypeIsPointerType() else ptr.GetChildAtIndex(0)\n+\n+\n+class DefaultSynthteticProvider:\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> DefaultSynthteticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"Default synthetic provider for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.valobj.GetNumChildren()\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return self.valobj.GetIndexOfChildWithName(name)\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        return self.valobj.GetChildAtIndex(index)\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return self.valobj.MightHaveChildren()\n+\n+\n+class EmptySyntheticProvider:\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> EmptySyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[EmptySyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return 0\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return None\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return False\n+\n+\n+def SizeSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    return 'size=' + str(valobj.GetNumChildren())\n+\n+\n+def vec_to_string(vec):\n+    length = vec.GetNumChildren()\n+    chars = [vec.GetChildAtIndex(i).GetValueAsUnsigned() for i in range(length)]\n+    return bytes(chars).decode(errors='replace') if PY3 else \"\".join(chr(char) for char in chars)\n+\n+\n+def StdStringSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdStringSummaryProvider] for \" + str(valobj.GetName())\n+    vec = valobj.GetChildAtIndex(0)\n+    return '\"%s\"' % vec_to_string(vec)\n+\n+\n+def StdOsStringSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdOsStringSummaryProvider] for \" + str(valobj.GetName())\n+    buf = valobj.GetChildAtIndex(0).GetChildAtIndex(0)\n+    is_windows = \"Wtf8Buf\" in buf.type.name\n+    vec = buf.GetChildAtIndex(0) if is_windows else buf\n+    return '\"%s\"' % vec_to_string(vec)\n+\n+\n+def StdStrSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdStrSummaryProvider] for \" + str(valobj.GetName())\n+\n+    length = valobj.GetChildMemberWithName(\"length\").GetValueAsUnsigned()\n+    if length == 0:\n+        return '\"\"'\n+\n+    data_ptr = valobj.GetChildMemberWithName(\"data_ptr\")\n+\n+    start = data_ptr.GetValueAsUnsigned()\n+    error = SBError()\n+    process = data_ptr.GetProcess()\n+    data = process.ReadMemory(start, length, error)\n+    data = data.decode(encoding='UTF-8') if PY3 else data\n+    return '\"%s\"' % data\n+\n+\n+class StructSyntheticProvider:\n+    \"\"\"Pretty-printer for structs and struct enum variants\"\"\"\n+\n+    def __init__(self, valobj, dict, is_variant=False):\n+        # type: (SBValue, dict, bool) -> StructSyntheticProvider\n+        # logger = Logger.Logger()\n+        self.valobj = valobj\n+        self.is_variant = is_variant\n+        self.type = valobj.GetType()\n+        self.fields = {}\n+\n+        if is_variant:\n+            self.fields_count = self.type.GetNumberOfFields() - 1\n+            real_fields = self.type.fields[1:]\n+        else:\n+            self.fields_count = self.type.GetNumberOfFields()\n+            real_fields = self.type.fields\n+\n+        for number, field in enumerate(real_fields):\n+            self.fields[field.name] = number\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.fields_count\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return self.fields.get(name, -1)\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if self.is_variant:\n+            field = self.type.GetFieldAtIndex(index + 1)\n+        else:\n+            field = self.type.GetFieldAtIndex(index)\n+        return self.valobj.GetChildMemberWithName(field.name)\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class TupleSyntheticProvider:\n+    \"\"\"Pretty-printer for tuples and tuple enum variants\"\"\"\n+\n+    def __init__(self, valobj, dict, is_variant=False):\n+        # type: (SBValue, dict, bool) -> TupleSyntheticProvider\n+        # logger = Logger.Logger()\n+        self.valobj = valobj\n+        self.is_variant = is_variant\n+        self.type = valobj.GetType()\n+\n+        if is_variant:\n+            self.size = self.type.GetNumberOfFields() - 1\n+        else:\n+            self.size = self.type.GetNumberOfFields()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name.isdigit():\n+            return int(name)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if self.is_variant:\n+            field = self.type.GetFieldAtIndex(index + 1)\n+        else:\n+            field = self.type.GetFieldAtIndex(index)\n+        element = self.valobj.GetChildMemberWithName(field.name)\n+        return self.valobj.CreateValueFromData(str(index), element.GetData(), element.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdVecSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::vec::Vec<T>\n+\n+    struct Vec<T> { buf: RawVec<T>, len: usize }\n+    struct RawVec<T> { ptr: Unique<T>, cap: usize, ... }\n+    rust 1.31.1: struct Unique<T: ?Sized> { pointer: NonZero<*const T>, ... }\n+    rust 1.33.0: struct Unique<T: ?Sized> { pointer: *const T, ... }\n+    struct NonZero<T>(T)\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdVecSyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[StdVecSyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.length\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + index * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.length = self.valobj.GetChildMemberWithName(\"len\").GetValueAsUnsigned()\n+        self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n+\n+        self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdSliceSyntheticProvider:\n+    def __init__(self, valobj, dict):\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.length\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + index * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.length = self.valobj.GetChildMemberWithName(\"length\").GetValueAsUnsigned()\n+        self.data_ptr = self.valobj.GetChildMemberWithName(\"data_ptr\")\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdVecDequeSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::collections::vec_deque::VecDeque<T>\n+\n+    struct VecDeque<T> { tail: usize, head: usize, buf: RawVec<T> }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdVecDequeSyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[StdVecDequeSyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit() and self.tail <= index and (self.tail + index) % self.cap < self.head:\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + ((index + self.tail) % self.cap) * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.head = self.valobj.GetChildMemberWithName(\"head\").GetValueAsUnsigned()\n+        self.tail = self.valobj.GetChildMemberWithName(\"tail\").GetValueAsUnsigned()\n+        self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n+        self.cap = self.buf.GetChildMemberWithName(\"cap\").GetValueAsUnsigned()\n+        if self.head >= self.tail:\n+            self.size = self.head - self.tail\n+        else:\n+            self.size = self.cap + self.head - self.tail\n+\n+        self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+# BACKCOMPAT: rust 1.35\n+class StdOldHashMapSyntheticProvider:\n+    \"\"\"Pretty-printer for std::collections::hash::map::HashMap<K, V, S>\n+\n+    struct HashMap<K, V, S> {..., table: RawTable<K, V>, ... }\n+    struct RawTable<K, V> { capacity_mask: usize, size: usize, hashes: TaggedHashUintPtr, ... }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict, show_values=True):\n+        # type: (SBValue, dict, bool) -> StdOldHashMapSyntheticProvider\n+        self.valobj = valobj\n+        self.show_values = show_values\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        # logger = Logger.Logger()\n+        start = self.data_ptr.GetValueAsUnsigned() & ~1\n+\n+        # See `libstd/collections/hash/table.rs:raw_bucket_at\n+        hashes = self.hash_uint_size * self.capacity\n+        align = self.pair_type_size\n+        # See `libcore/alloc.rs:padding_needed_for`\n+        len_rounded_up = (((((hashes + align) % self.modulo - 1) % self.modulo) & ~(\n+                (align - 1) % self.modulo)) % self.modulo - hashes) % self.modulo\n+        # len_rounded_up = ((hashes + align - 1) & ~(align - 1)) - hashes\n+\n+        pairs_offset = hashes + len_rounded_up\n+        pairs_start = start + pairs_offset\n+\n+        table_index = self.valid_indices[index]\n+        idx = table_index & self.capacity_mask\n+        address = pairs_start + idx * self.pair_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n+        if self.show_values:\n+            return element\n+        else:\n+            key = element.GetChildAtIndex(0)\n+            return self.valobj.CreateValueFromData(\"[%s]\" % index, key.GetData(), key.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        # logger = Logger.Logger()\n+\n+        self.table = self.valobj.GetChildMemberWithName(\"table\")  # type: SBValue\n+        self.size = self.table.GetChildMemberWithName(\"size\").GetValueAsUnsigned()\n+        self.hashes = self.table.GetChildMemberWithName(\"hashes\")\n+        self.hash_uint_type = self.hashes.GetType()\n+        self.hash_uint_size = self.hashes.GetType().GetByteSize()\n+        self.modulo = 2 ** self.hash_uint_size\n+        self.data_ptr = self.hashes.GetChildAtIndex(0).GetChildAtIndex(0)\n+\n+        self.capacity_mask = self.table.GetChildMemberWithName(\"capacity_mask\").GetValueAsUnsigned()\n+        self.capacity = (self.capacity_mask + 1) % self.modulo\n+\n+        marker = self.table.GetChildMemberWithName(\"marker\").GetType()  # type: SBType\n+        self.pair_type = marker.template_args[0]\n+        self.pair_type_size = self.pair_type.GetByteSize()\n+\n+        self.valid_indices = []\n+        for idx in range(self.capacity):\n+            address = self.data_ptr.GetValueAsUnsigned() + idx * self.hash_uint_size\n+            hash_uint = self.data_ptr.CreateValueFromAddress(\"[%s]\" % idx, address,\n+                                                             self.hash_uint_type)\n+            hash_ptr = hash_uint.GetChildAtIndex(0).GetChildAtIndex(0)\n+            if hash_ptr.GetValueAsUnsigned() != 0:\n+                self.valid_indices.append(idx)\n+\n+        # logger >> \"Valid indices: {}\".format(str(self.valid_indices))\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdHashMapSyntheticProvider:\n+    \"\"\"Pretty-printer for hashbrown's HashMap\"\"\"\n+\n+    def __init__(self, valobj, dict, show_values=True):\n+        # type: (SBValue, dict, bool) -> StdHashMapSyntheticProvider\n+        self.valobj = valobj\n+        self.show_values = show_values\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        pairs_start = self.data_ptr.GetValueAsUnsigned()\n+        idx = self.valid_indices[index]\n+        address = pairs_start + idx * self.pair_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n+        if self.show_values:\n+            return element\n+        else:\n+            key = element.GetChildAtIndex(0)\n+            return self.valobj.CreateValueFromData(\"[%s]\" % index, key.GetData(), key.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        table = self.valobj.GetChildMemberWithName(\"base\").GetChildMemberWithName(\"table\")\n+        capacity = table.GetChildMemberWithName(\"bucket_mask\").GetValueAsUnsigned() + 1\n+        ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n+\n+        self.size = table.GetChildMemberWithName(\"items\").GetValueAsUnsigned()\n+        self.data_ptr = table.GetChildMemberWithName(\"data\").GetChildAtIndex(0)\n+        self.pair_type = self.data_ptr.Dereference().GetType()\n+        self.pair_type_size = self.pair_type.GetByteSize()\n+\n+        u8_type = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar)\n+        u8_type_size = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar).GetByteSize()\n+\n+        self.valid_indices = []\n+        for idx in range(capacity):\n+            address = ctrl.GetValueAsUnsigned() + idx * u8_type_size\n+            value = ctrl.CreateValueFromAddress(\"ctrl[%s]\" % idx, address,\n+                                                u8_type).GetValueAsUnsigned()\n+            is_present = value & 128 == 0\n+            if is_present:\n+                self.valid_indices.append(idx)\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+def StdRcSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    strong = valobj.GetChildMemberWithName(\"strong\").GetValueAsUnsigned()\n+    weak = valobj.GetChildMemberWithName(\"weak\").GetValueAsUnsigned()\n+    return \"strong={}, weak={}\".format(strong, weak)\n+\n+\n+class StdRcSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::rc::Rc<T> and alloc::sync::Arc<T>\n+\n+    struct Rc<T> { ptr: NonNull<RcBox<T>>, ... }\n+    rust 1.31.1: struct NonNull<T> { pointer: NonZero<*const T> }\n+    rust 1.33.0: struct NonNull<T> { pointer: *const T }\n+    struct NonZero<T>(T)\n+    struct RcBox<T> { strong: Cell<usize>, weak: Cell<usize>, value: T }\n+    struct Cell<T> { value: UnsafeCell<T> }\n+    struct UnsafeCell<T> { value: T }\n+\n+    struct Arc<T> { ptr: NonNull<ArcInner<T>>, ... }\n+    struct ArcInner<T> { strong: atomic::AtomicUsize, weak: atomic::AtomicUsize, data: T }\n+    struct AtomicUsize { v: UnsafeCell<usize> }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict, is_atomic=False):\n+        # type: (SBValue, dict, bool) -> StdRcSyntheticProvider\n+        self.valobj = valobj\n+\n+        self.ptr = unwrap_unique_or_non_null(self.valobj.GetChildMemberWithName(\"ptr\"))\n+\n+        self.value = self.ptr.GetChildMemberWithName(\"data\" if is_atomic else \"value\")\n+\n+        self.strong = self.ptr.GetChildMemberWithName(\"strong\").GetChildAtIndex(\n+            0).GetChildMemberWithName(\"value\")\n+        self.weak = self.ptr.GetChildMemberWithName(\"weak\").GetChildAtIndex(\n+            0).GetChildMemberWithName(\"value\")\n+\n+        self.value_builder = ValueBuilder(valobj)\n+\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        # Actually there are 3 children, but only the `value` should be shown as a child\n+        return 1\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name == \"value\":\n+            return 0\n+        if name == \"strong\":\n+            return 1\n+        if name == \"weak\":\n+            return 2\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        if index == 1:\n+            return self.value_builder.from_uint(\"strong\", self.strong_count)\n+        if index == 2:\n+            return self.value_builder.from_uint(\"weak\", self.weak_count)\n+\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        self.strong_count = self.strong.GetValueAsUnsigned()\n+        self.weak_count = self.weak.GetValueAsUnsigned() - 1\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdCellSyntheticProvider:\n+    \"\"\"Pretty-printer for std::cell::Cell\"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdCellSyntheticProvider\n+        self.valobj = valobj\n+        self.value = valobj.GetChildMemberWithName(\"value\").GetChildAtIndex(0)\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return 1\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name == \"value\":\n+            return 0\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+def StdRefSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    borrow = valobj.GetChildMemberWithName(\"borrow\").GetValueAsSigned()\n+    return \"borrow={}\".format(borrow) if borrow >= 0 else \"borrow_mut={}\".format(-borrow)\n+\n+\n+class StdRefSyntheticProvider:\n+    \"\"\"Pretty-printer for std::cell::Ref, std::cell::RefMut, and std::cell::RefCell\"\"\"\n+\n+    def __init__(self, valobj, dict, is_cell=False):\n+        # type: (SBValue, dict, bool) -> StdRefSyntheticProvider\n+        self.valobj = valobj\n+\n+        borrow = valobj.GetChildMemberWithName(\"borrow\")\n+        value = valobj.GetChildMemberWithName(\"value\")\n+        if is_cell:\n+            self.borrow = borrow.GetChildMemberWithName(\"value\").GetChildMemberWithName(\"value\")\n+            self.value = value.GetChildMemberWithName(\"value\")\n+        else:\n+            self.borrow = borrow.GetChildMemberWithName(\"borrow\").GetChildMemberWithName(\n+                \"value\").GetChildMemberWithName(\"value\")\n+            self.value = value.Dereference()\n+\n+        self.value_builder = ValueBuilder(valobj)\n+\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        # Actually there are 2 children, but only the `value` should be shown as a child\n+        return 1\n+\n+    def get_child_index(self, name):\n+        if name == \"value\":\n+            return 0\n+        if name == \"borrow\":\n+            return 1\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        if index == 1:\n+            return self.value_builder.from_int(\"borrow\", self.borrow_count)\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        self.borrow_count = self.borrow.GetValueAsSigned()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True"}, {"sha": "0c4021b36fb6f6ac7435ea2f40873a26584b5c69", "filename": "src/etc/lldb_rust_formatters.py", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db", "patch": "@@ -1,305 +0,0 @@\n-import lldb\n-import debugger_pretty_printers_common as rustpp\n-\n-# ===============================================================================\n-# LLDB Pretty Printing Module for Rust\n-# ===============================================================================\n-\n-\n-class LldbType(rustpp.Type):\n-\n-    def __init__(self, ty):\n-        super(LldbType, self).__init__()\n-        self.ty = ty\n-        self.fields = None\n-\n-    def get_unqualified_type_name(self):\n-        qualified_name = self.ty.GetName()\n-\n-        if qualified_name is None:\n-            return qualified_name\n-\n-        return rustpp.extract_type_name(qualified_name).replace(\"&'static \", \"&\")\n-\n-    def get_dwarf_type_kind(self):\n-        type_class = self.ty.GetTypeClass()\n-\n-        if type_class == lldb.eTypeClassStruct:\n-            return rustpp.DWARF_TYPE_CODE_STRUCT\n-\n-        if type_class == lldb.eTypeClassUnion:\n-            return rustpp.DWARF_TYPE_CODE_UNION\n-\n-        if type_class == lldb.eTypeClassPointer:\n-            return rustpp.DWARF_TYPE_CODE_PTR\n-\n-        if type_class == lldb.eTypeClassArray:\n-            return rustpp.DWARF_TYPE_CODE_ARRAY\n-\n-        if type_class == lldb.eTypeClassEnumeration:\n-            return rustpp.DWARF_TYPE_CODE_ENUM\n-\n-        return None\n-\n-    def get_fields(self):\n-        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n-        if self.fields is None:\n-            self.fields = list(self.ty.fields)\n-        return self.fields\n-\n-    def get_wrapped_value(self):\n-        return self.ty\n-\n-\n-class LldbValue(rustpp.Value):\n-    def __init__(self, lldb_val):\n-        ty = lldb_val.type\n-        wty = LldbType(ty)\n-        super(LldbValue, self).__init__(wty)\n-        self.lldb_val = lldb_val\n-        self.children = {}\n-\n-    def get_child_at_index(self, index):\n-        child = self.children.get(index)\n-        if child is None:\n-            lldb_field = self.lldb_val.GetChildAtIndex(index)\n-            child = LldbValue(lldb_field)\n-            self.children[index] = child\n-        return child\n-\n-    def as_integer(self):\n-        return self.lldb_val.GetValueAsUnsigned()\n-\n-    def get_wrapped_value(self):\n-        return self.lldb_val\n-\n-\n-def print_val(lldb_val, internal_dict):\n-    val = LldbValue(lldb_val)\n-    type_kind = val.type.get_type_kind()\n-\n-    if (type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT or\n-        type_kind == rustpp.TYPE_KIND_REGULAR_UNION or\n-        type_kind == rustpp.TYPE_KIND_EMPTY):\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=False,\n-                                is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=True,\n-                                omit_type_name=False,\n-                                is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_SLICE:\n-        return print_vec_slice_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return print_str_slice_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n-        return print_std_vec_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n-        return print_std_string_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=True,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=False,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n-        return val.type.get_unqualified_type_name()\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=True,\n-                                omit_type_name=False,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n-        return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_PTR:\n-        return print_pointer_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_FIXED_SIZE_VEC:\n-        return print_fixed_size_vec_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n-        # This is a regular enum, extract the discriminant\n-        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n-        return print_val(lldb_val.GetChildAtIndex(discriminant_val), internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n-        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n-        if encoded_enum_info.is_null_variant():\n-            return encoded_enum_info.get_null_variant_name()\n-\n-        non_null_val = encoded_enum_info.get_non_null_variant_val()\n-        return print_val(non_null_val.get_wrapped_value(), internal_dict)\n-\n-    # No pretty printer has been found\n-    return lldb_val.GetValue()\n-\n-\n-# =---------------------------------------------------------------------------------------\n-# Type-Specialized Printing Functions\n-# =---------------------------------------------------------------------------------------\n-\n-def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n-    \"\"\"\n-    Prints a struct, tuple, or tuple struct value with Rust syntax.\n-    Ignores any fields before field_start_index.\n-    \"\"\"\n-    assert (val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT or\n-            val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION)\n-\n-    if omit_type_name:\n-        type_name = \"\"\n-    else:\n-        type_name = val.type.get_unqualified_type_name()\n-\n-    if is_tuple_like:\n-        template = \"%(type_name)s(%(body)s)\"\n-        separator = \", \"\n-    else:\n-        template = \"%(type_name)s {\\n%(body)s\\n}\"\n-        separator = \", \\n\"\n-\n-    fields = val.type.get_fields()\n-\n-    def render_child(child_index):\n-        this = \"\"\n-        if not is_tuple_like:\n-            field_name = fields[child_index].name\n-            this += field_name + \": \"\n-\n-        field_val = val.get_child_at_index(child_index)\n-\n-        if not field_val.get_wrapped_value().IsValid():\n-            field = fields[child_index]\n-            # LLDB is not good at handling zero-sized values, so we have to help\n-            # it a little\n-            if field.GetType().GetByteSize() == 0:\n-                return this + rustpp.extract_type_name(field.GetType().GetName())\n-            else:\n-                return this + \"<invalid value>\"\n-\n-        return this + print_val(field_val.get_wrapped_value(), internal_dict)\n-\n-    if omit_first_field:\n-        field_start_index = 1\n-    else:\n-        field_start_index = 0\n-\n-    body = separator.join([render_child(idx) for idx in range(field_start_index, len(fields))])\n-\n-    return template % {\"type_name\": type_name,\n-                       \"body\": body}\n-\n-\n-def print_pointer_val(val, internal_dict):\n-    \"\"\"Prints a pointer value with Rust syntax\"\"\"\n-    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-    sigil = \"&\"\n-    type_name = val.type.get_unqualified_type_name()\n-    if type_name and type_name[0:1] in [\"&\", \"*\"]:\n-        sigil = type_name[0:1]\n-\n-    return sigil + hex(val.as_integer())\n-\n-\n-def print_fixed_size_vec_val(val, internal_dict):\n-    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ARRAY\n-    lldb_val = val.get_wrapped_value()\n-\n-    output = \"[\"\n-\n-    for i in range(lldb_val.num_children):\n-        output += print_val(lldb_val.GetChildAtIndex(i), internal_dict)\n-        if i != lldb_val.num_children - 1:\n-            output += \", \"\n-\n-    output += \"]\"\n-    return output\n-\n-\n-def print_vec_slice_val(val, internal_dict):\n-    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n-    return \"&[%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n-                                           data_ptr,\n-                                           length,\n-                                           internal_dict)\n-\n-\n-def print_std_vec_val(val, internal_dict):\n-    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(val)\n-    return \"vec![%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n-                                              data_ptr,\n-                                              length,\n-                                              internal_dict)\n-\n-\n-def print_str_slice_val(val, internal_dict):\n-    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n-    return read_utf8_string(data_ptr, length)\n-\n-\n-def print_std_string_val(val, internal_dict):\n-    vec = val.get_child_at_index(0)\n-    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-    return read_utf8_string(data_ptr, length)\n-\n-# =-----------------------------------------------------------------------\n-# Helper Functions\n-# =-----------------------------------------------------------------------\n-\n-\n-def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n-    \"\"\"Prints a contiguous memory range, interpreting it as values of the\n-       pointee-type of data_ptr_val.\"\"\"\n-\n-    data_ptr_type = data_ptr_val.type\n-    assert data_ptr_type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-\n-    element_type = data_ptr_type.get_wrapped_value().GetPointeeType()\n-    element_type_size = element_type.GetByteSize()\n-\n-    start_address = data_ptr_val.as_integer()\n-    raw_value = data_ptr_val.get_wrapped_value()\n-\n-    def render_element(i):\n-        address = start_address + i * element_type_size\n-        element_val = raw_value.CreateValueFromAddress(array_name + (\"[%s]\" % i),\n-                                                       address,\n-                                                       element_type)\n-        return print_val(element_val, internal_dict)\n-\n-    return ', '.join([render_element(i) for i in range(length)])\n-\n-\n-def read_utf8_string(ptr_val, byte_count):\n-    if byte_count == 0:\n-        return '\"\"'\n-    error = lldb.SBError()\n-    process = ptr_val.get_wrapped_value().GetProcess()\n-    data = process.ReadMemory(ptr_val.as_integer(), byte_count, error)\n-    if error.Success():\n-        return '\"%s\"' % data.decode(encoding='UTF-8')\n-    else:\n-        return '<error: %s>' % error.GetCString()"}, {"sha": "874550da8b0c97b196d1371af91879ca54c39b74", "filename": "src/etc/natvis/intrinsic.natvis", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fintrinsic.natvis?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -21,4 +21,128 @@\n       </ArrayItems>\n     </Expand>\n   </Type>\n+  <Type Name=\"tuple&lt;&gt;\">\n+    <DisplayString>()</DisplayString>\n+  </Type>\n+  <Type Name=\"tuple&lt;*&gt;\">\n+    <DisplayString>({__0})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*&gt;\">\n+    <DisplayString>({__0}, {__1})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4}, {__5})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+      <Item Name=\"[5]\">__5</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4}, {__5}, {__6})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+      <Item Name=\"[5]\">__5</Item>\n+      <Item Name=\"[6]\">__6</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4}, {__5}, {__6}, {__7})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+      <Item Name=\"[5]\">__5</Item>\n+      <Item Name=\"[6]\">__6</Item>\n+      <Item Name=\"[7]\">__7</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4}, {__5}, {__6}, {__7}, {__8})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+      <Item Name=\"[5]\">__5</Item>\n+      <Item Name=\"[6]\">__6</Item>\n+      <Item Name=\"[7]\">__7</Item>\n+      <Item Name=\"[8]\">__8</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*,*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4}, {__5}, {__6}, {__7}, {__8}, {__9})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+      <Item Name=\"[5]\">__5</Item>\n+      <Item Name=\"[6]\">__6</Item>\n+      <Item Name=\"[7]\">__7</Item>\n+      <Item Name=\"[8]\">__8</Item>\n+      <Item Name=\"[9]\">__9</Item>\n+    </Expand>\n+  </Type>\n+  <Type Name=\"tuple&lt;*,*,*,*,*,*,*,*,*,*,*&gt;\">\n+    <DisplayString>({__0}, {__1}, {__2}, {__3}, {__4}, {__5}, {__6}, {__7}, {__8}, {__9}, ...)</DisplayString>\n+    <Expand>\n+      <Item Name=\"[0]\">__0</Item>\n+      <Item Name=\"[1]\">__1</Item>\n+      <Item Name=\"[2]\">__2</Item>\n+      <Item Name=\"[3]\">__3</Item>\n+      <Item Name=\"[4]\">__4</Item>\n+      <Item Name=\"[5]\">__5</Item>\n+      <Item Name=\"[6]\">__6</Item>\n+      <Item Name=\"[7]\">__7</Item>\n+      <Item Name=\"[8]\">__8</Item>\n+      <Item Name=\"[9]\">__9</Item>\n+      <Synthetic Name=\"[...]\"><DisplayString>...</DisplayString></Synthetic>\n+    </Expand>\n+  </Type>\n </AutoVisualizer>"}, {"sha": "28b32ef1ad5328cbef7f3dbc70131d8bbd89906d", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -30,13 +30,5 @@ EOF\n     fi\n fi\n \n-# Prepare commands that will be loaded before any file on the command line has been loaded\n-script_import=\"command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_rust_formatters.py\\\"\"\n-category_definition=\"type summary add --no-value --python-function lldb_rust_formatters.print_val -x \\\".*\\\" --category Rust\"\n-category_enable=\"type category enable Rust\"\n-\n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --one-line-before-file \"$script_import\" \\\n-    --one-line-before-file \"$category_definition\" \\\n-    --one-line-before-file \"$category_enable\" \\\n-    \"$@\"\n+exec \"$lldb\" --source-before-file ./lldb_commands \"$@\""}, {"sha": "b49fd19ed4cbbbe40ba49458037bb4c2fff5e64b", "filename": "src/etc/rust_types.py", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Frust_types.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Frust_types.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust_types.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,113 @@\n+import re\n+\n+\n+class RustType(object):\n+    OTHER = \"Other\"\n+    STRUCT = \"Struct\"\n+    TUPLE = \"Tuple\"\n+    CSTYLE_VARIANT = \"CStyleVariant\"\n+    TUPLE_VARIANT = \"TupleVariant\"\n+    STRUCT_VARIANT = \"StructVariant\"\n+    ENUM = \"Enum\"\n+    EMPTY = \"Empty\"\n+    SINGLETON_ENUM = \"SingletonEnum\"\n+    REGULAR_ENUM = \"RegularEnum\"\n+    COMPRESSED_ENUM = \"CompressedEnum\"\n+    REGULAR_UNION = \"RegularUnion\"\n+\n+    STD_STRING = \"StdString\"\n+    STD_OS_STRING = \"StdOsString\"\n+    STD_STR = \"StdStr\"\n+    STD_SLICE = \"StdSlice\"\n+    STD_VEC = \"StdVec\"\n+    STD_VEC_DEQUE = \"StdVecDeque\"\n+    STD_BTREE_SET = \"StdBTreeSet\"\n+    STD_BTREE_MAP = \"StdBTreeMap\"\n+    STD_HASH_MAP = \"StdHashMap\"\n+    STD_HASH_SET = \"StdHashSet\"\n+    STD_RC = \"StdRc\"\n+    STD_ARC = \"StdArc\"\n+    STD_CELL = \"StdCell\"\n+    STD_REF = \"StdRef\"\n+    STD_REF_MUT = \"StdRefMut\"\n+    STD_REF_CELL = \"StdRefCell\"\n+\n+\n+STD_STRING_REGEX = re.compile(r\"^(alloc::(\\w+::)+)String$\")\n+STD_STR_REGEX = re.compile(r\"^&str$\")\n+STD_SLICE_REGEX = re.compile(r\"^&\\[.+\\]$\")\n+STD_OS_STRING_REGEX = re.compile(r\"^(std::ffi::(\\w+::)+)OsString$\")\n+STD_VEC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Vec<.+>$\")\n+STD_VEC_DEQUE_REGEX = re.compile(r\"^(alloc::(\\w+::)+)VecDeque<.+>$\")\n+STD_BTREE_SET_REGEX = re.compile(r\"^(alloc::(\\w+::)+)BTreeSet<.+>$\")\n+STD_BTREE_MAP_REGEX = re.compile(r\"^(alloc::(\\w+::)+)BTreeMap<.+>$\")\n+STD_HASH_MAP_REGEX = re.compile(r\"^(std::collections::(\\w+::)+)HashMap<.+>$\")\n+STD_HASH_SET_REGEX = re.compile(r\"^(std::collections::(\\w+::)+)HashSet<.+>$\")\n+STD_RC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Rc<.+>$\")\n+STD_ARC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Arc<.+>$\")\n+STD_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)Cell<.+>$\")\n+STD_REF_REGEX = re.compile(r\"^(core::(\\w+::)+)Ref<.+>$\")\n+STD_REF_MUT_REGEX = re.compile(r\"^(core::(\\w+::)+)RefMut<.+>$\")\n+STD_REF_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)RefCell<.+>$\")\n+\n+TUPLE_ITEM_REGEX = re.compile(r\"__\\d+$\")\n+\n+ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n+ENUM_DISR_FIELD_NAME = \"<<variant>>\"\n+\n+STD_TYPE_TO_REGEX = {\n+    RustType.STD_STRING: STD_STRING_REGEX,\n+    RustType.STD_OS_STRING: STD_OS_STRING_REGEX,\n+    RustType.STD_STR: STD_STR_REGEX,\n+    RustType.STD_SLICE: STD_SLICE_REGEX,\n+    RustType.STD_VEC: STD_VEC_REGEX,\n+    RustType.STD_VEC_DEQUE: STD_VEC_DEQUE_REGEX,\n+    RustType.STD_HASH_MAP: STD_HASH_MAP_REGEX,\n+    RustType.STD_HASH_SET: STD_HASH_SET_REGEX,\n+    RustType.STD_BTREE_SET: STD_BTREE_SET_REGEX,\n+    RustType.STD_BTREE_MAP: STD_BTREE_MAP_REGEX,\n+    RustType.STD_RC: STD_RC_REGEX,\n+    RustType.STD_ARC: STD_ARC_REGEX,\n+    RustType.STD_REF: STD_REF_REGEX,\n+    RustType.STD_REF_MUT: STD_REF_MUT_REGEX,\n+    RustType.STD_REF_CELL: STD_REF_CELL_REGEX,\n+    RustType.STD_CELL: STD_CELL_REGEX,\n+}\n+\n+def is_tuple_fields(fields):\n+    # type: (list) -> bool\n+    return all(TUPLE_ITEM_REGEX.match(str(field.name)) for field in fields)\n+\n+\n+def classify_struct(name, fields):\n+    if len(fields) == 0:\n+        return RustType.EMPTY\n+\n+    for ty, regex in STD_TYPE_TO_REGEX.items():\n+        if regex.match(name):\n+            return ty\n+\n+    if fields[0].name == ENUM_DISR_FIELD_NAME:\n+        return RustType.ENUM\n+\n+    if is_tuple_fields(fields):\n+        return RustType.TUPLE\n+\n+    return RustType.STRUCT\n+\n+\n+def classify_union(fields):\n+    if len(fields) == 0:\n+        return RustType.EMPTY\n+\n+    first_variant_name = fields[0].name\n+    if first_variant_name is None:\n+        if len(fields) == 1:\n+            return RustType.SINGLETON_ENUM\n+        else:\n+            return RustType.REGULAR_ENUM\n+    elif first_variant_name.startswith(ENCODED_ENUM_PREFIX):\n+        assert len(fields) == 1\n+        return RustType.COMPRESSED_ENUM\n+    else:\n+        return RustType.REGULAR_UNION"}, {"sha": "7106078f897cf30fa4ce15635b0a124db8c9e9ec", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -195,9 +195,9 @@ def main():\n     global MAILBOX\n     tests = [os.path.splitext(f)[0] for f in glob('*.rs')\n                                     if not f.startswith('_')]\n-    whitelist = sys.argv[1:]\n-    if whitelist:\n-        tests = [test for test in tests if test in whitelist]\n+    listed = sys.argv[1:]\n+    if listed:\n+        tests = [test for test in tests if test in listed]\n     if not tests:\n         print(\"Error: No tests to run\")\n         sys.exit(1)\n@@ -210,8 +210,6 @@ def main():\n     mailman.daemon = True\n     mailman.start()\n     for test in tests:\n-        if whitelist and test not in whitelist:\n-            continue\n         run(test)\n     MAILBOX.put(None)\n     mailman.join()"}, {"sha": "914195f015b5a83daf9325285aa6074c61c79dec", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -25,6 +25,7 @@ path = \"../liballoc/tests/lib.rs\"\n [[bench]]\n name = \"collectionsbenches\"\n path = \"../liballoc/benches/lib.rs\"\n+test = true\n \n [[bench]]\n name = \"vec_deque_append_bench\""}, {"sha": "98c7ac3f2ef17cde30f163dfd658c70a0bfeae45", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -77,7 +77,7 @@ pub struct Global;\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n-    __rust_alloc(layout.size(), layout.align())\n+    unsafe { __rust_alloc(layout.size(), layout.align()) }\n }\n \n /// Deallocate memory with the global allocator.\n@@ -99,7 +99,7 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n-    __rust_dealloc(ptr, layout.size(), layout.align())\n+    unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n }\n \n /// Reallocate memory with the global allocator.\n@@ -121,7 +121,7 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-    __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n+    unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }\n }\n \n /// Allocate zero-initialized memory with the global allocator.\n@@ -158,7 +158,7 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n-    __rust_alloc_zeroed(layout.size(), layout.align())\n+    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n@@ -183,7 +183,7 @@ unsafe impl AllocRef for Global {\n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            dealloc(ptr.as_ptr(), layout)\n+            unsafe { dealloc(ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -209,16 +209,21 @@ unsafe impl AllocRef for Global {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size > size` or something similar.\n-                intrinsics::assume(new_size > size);\n-                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let ptr = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    realloc(ptr.as_ptr(), layout, new_size)\n+                };\n                 let memory =\n                     MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                init.init_offset(memory, size);\n+                unsafe {\n+                    init.init_offset(memory, size);\n+                }\n                 Ok(memory)\n             }\n         }\n@@ -245,13 +250,17 @@ unsafe impl AllocRef for Global {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                self.dealloc(ptr, layout);\n+                unsafe {\n+                    self.dealloc(ptr, layout);\n+                }\n                 Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size < size` or something similar.\n-                intrinsics::assume(new_size < size);\n-                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let ptr = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    realloc(ptr.as_ptr(), layout, new_size)\n+                };\n                 Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n@@ -264,7 +273,7 @@ unsafe impl AllocRef for Global {\n #[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n-    let layout = Layout::from_size_align_unchecked(size, align);\n+    let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n     match Global.alloc(layout, AllocInit::Uninitialized) {\n         Ok(memory) => memory.ptr.as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n@@ -279,10 +288,12 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    let size = size_of_val(ptr.as_ref());\n-    let align = min_align_of_val(ptr.as_ref());\n-    let layout = Layout::from_size_align_unchecked(size, align);\n-    Global.dealloc(ptr.cast().into(), layout)\n+    unsafe {\n+        let size = size_of_val(ptr.as_ref());\n+        let align = min_align_of_val(ptr.as_ref());\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        Global.dealloc(ptr.cast().into(), layout)\n+    }\n }\n \n /// Abort on memory allocation error or failure."}, {"sha": "1c003983df9892a1c13aef1d7796a9ad36594559", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -23,7 +23,7 @@ fn allocate_zeroed() {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn alloc_owned_small(b: &mut Bencher) {\n     b.iter(|| {\n         let _: Box<_> = box 10;"}, {"sha": "38d19c59ad186edfbad8b6d8f972320d9df57f22", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n-use std::ops::Bound::{Excluded, Unbounded};\n+use std::ops::RangeBounds;\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -117,7 +117,7 @@ map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n-fn bench_iter(b: &mut Bencher, size: i32) {\n+fn bench_iteration(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -133,21 +133,21 @@ fn bench_iter(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_20(b: &mut Bencher) {\n-    bench_iter(b, 20);\n+pub fn iteration_20(b: &mut Bencher) {\n+    bench_iteration(b, 20);\n }\n \n #[bench]\n-pub fn iter_1000(b: &mut Bencher) {\n-    bench_iter(b, 1000);\n+pub fn iteration_1000(b: &mut Bencher) {\n+    bench_iteration(b, 1000);\n }\n \n #[bench]\n-pub fn iter_100000(b: &mut Bencher) {\n-    bench_iter(b, 100000);\n+pub fn iteration_100000(b: &mut Bencher) {\n+    bench_iteration(b, 100000);\n }\n \n-fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+fn bench_iteration_mut(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -163,18 +163,18 @@ fn bench_iter_mut(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_mut_20(b: &mut Bencher) {\n-    bench_iter_mut(b, 20);\n+pub fn iteration_mut_20(b: &mut Bencher) {\n+    bench_iteration_mut(b, 20);\n }\n \n #[bench]\n-pub fn iter_mut_1000(b: &mut Bencher) {\n-    bench_iter_mut(b, 1000);\n+pub fn iteration_mut_1000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 1000);\n }\n \n #[bench]\n-pub fn iter_mut_100000(b: &mut Bencher) {\n-    bench_iter_mut(b, 100000);\n+pub fn iteration_mut_100000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 100000);\n }\n \n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n@@ -202,57 +202,83 @@ pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n \n-#[bench]\n-pub fn range_excluded_excluded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+const BENCH_RANGE_SIZE: i32 = 145;\n+const BENCH_RANGE_COUNT: i32 = BENCH_RANGE_SIZE * (BENCH_RANGE_SIZE - 1) / 2;\n+\n+fn bench_range<F, R>(b: &mut Bencher, f: F)\n+where\n+    F: Fn(i32, i32) -> R,\n+    R: RangeBounds<i32>,\n+{\n+    let map: BTreeMap<_, _> = (0..BENCH_RANGE_SIZE).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            for last in first + 1..size {\n-                black_box(map.range((Excluded(first), Excluded(last))));\n+        let mut c = 0;\n+        for i in 0..BENCH_RANGE_SIZE {\n+            for j in i + 1..BENCH_RANGE_SIZE {\n+                black_box(map.range(f(i, j)));\n+                c += 1;\n             }\n         }\n+        debug_assert_eq!(c, BENCH_RANGE_COUNT);\n     });\n }\n \n #[bench]\n-pub fn range_excluded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range((Excluded(first), Unbounded)));\n-        }\n-    });\n+pub fn range_included_excluded(b: &mut Bencher) {\n+    bench_range(b, |i, j| i..j);\n }\n \n #[bench]\n pub fn range_included_included(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            for last in first..size {\n-                black_box(map.range(first..=last));\n-            }\n-        }\n-    });\n+    bench_range(b, |i, j| i..=j);\n }\n \n #[bench]\n pub fn range_included_unbounded(b: &mut Bencher) {\n-    let size = 144;\n+    bench_range(b, |i, _| i..);\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    bench_range(b, |_, _| ..);\n+}\n+\n+fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range(first..));\n+        for _ in 0..repeats {\n+            black_box(map.iter());\n         }\n     });\n }\n \n+/// Contrast range_unbounded_unbounded with `iter()`.\n #[bench]\n-pub fn range_unbounded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| map.range(..));\n+pub fn range_unbounded_vs_iter(b: &mut Bencher) {\n+    bench_iter(b, BENCH_RANGE_COUNT, BENCH_RANGE_SIZE);\n+}\n+\n+#[bench]\n+pub fn iter_0(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 0);\n+}\n+\n+#[bench]\n+pub fn iter_1(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1);\n+}\n+\n+#[bench]\n+pub fn iter_100(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 100);\n+}\n+\n+#[bench]\n+pub fn iter_10k(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 10_000);\n+}\n+\n+#[bench]\n+pub fn iter_1m(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1_000_000);\n }"}, {"sha": "608eafc88d2a6d8b181ad4d504691630180f8c76", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,3 +1,6 @@\n+// Disabling on android for the time being\n+// See https://github.com/rust-lang/rust/issues/73535#event-3477699747\n+#![cfg(not(target_os = \"android\"))]\n #![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]"}, {"sha": "3320ebdf821d054e31217ba4b02591375d268db0", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 100, "deletions": 19, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -92,11 +92,13 @@\n //! pub struct Foo;\n //!\n //! #[no_mangle]\n+//! #[allow(improper_ctypes_definitions)]\n //! pub extern \"C\" fn foo_new() -> Box<Foo> {\n //!     Box::new(Foo)\n //! }\n //!\n //! #[no_mangle]\n+//! #[allow(improper_ctypes_definitions)]\n //! pub extern \"C\" fn foo_delete(_: Option<Box<Foo>>) {}\n //! ```\n //!\n@@ -146,6 +148,7 @@ use core::ptr::{self, NonNull, Unique};\n use core::task::{Context, Poll};\n \n use crate::alloc::{self, AllocInit, AllocRef, Global};\n+use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n use crate::vec::Vec;\n@@ -239,6 +242,16 @@ impl<T> Box<T> {\n     pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n+\n+    /// Converts a `Box<T>` into a `Box<[T]>`\n+    ///\n+    /// This conversion does not allocate on the heap and happens in place.\n+    ///\n+    #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n+    pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n+        // *mut T and *mut [T; 1] have the same size and alignment\n+        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1]) }\n+    }\n }\n \n impl<T> Box<[T]> {\n@@ -300,7 +313,7 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T> {\n-        Box::from_raw(Box::into_raw(self) as *mut T)\n+        unsafe { Box::from_raw(Box::into_raw(self) as *mut T) }\n     }\n }\n \n@@ -338,7 +351,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T]> {\n-        Box::from_raw(Box::into_raw(self) as *mut [T])\n+        unsafe { Box::from_raw(Box::into_raw(self) as *mut [T]) }\n     }\n }\n \n@@ -371,7 +384,10 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// unsafe {\n     ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n-    ///     *ptr = 5;\n+    ///     // In general .write is required to avoid attempting to destruct\n+    ///     // the (uninitialized) previous contents of `ptr`, though for this\n+    ///     // simple example `*ptr = 5` would have worked as well.\n+    ///     ptr.write(5);\n     ///     let x = Box::from_raw(ptr);\n     /// }\n     /// ```\n@@ -382,7 +398,7 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        Box(Unique::new_unchecked(raw))\n+        Box(unsafe { Unique::new_unchecked(raw) })\n     }\n \n     /// Consumes the `Box`, returning a wrapped raw pointer.\n@@ -428,7 +444,12 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        Box::into_raw_non_null(b).as_ptr()\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b) as *mut T\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n@@ -451,6 +472,7 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// ```\n     /// #![feature(box_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// let x = Box::new(5);\n     /// let ptr = Box::into_raw_non_null(x);\n@@ -460,24 +482,34 @@ impl<T: ?Sized> Box<T> {\n     /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(\n+        since = \"1.44.0\",\n+        reason = \"use `Box::leak(b).into()` or `NonNull::from(Box::leak(b))` instead\"\n+    )]\n     #[inline]\n     pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n-        Box::into_unique(b).into()\n-    }\n-\n-    #[unstable(feature = \"ptr_internals\", issue = \"none\", reason = \"use into_raw_non_null instead\")]\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b).into()\n+    }\n+\n+    #[unstable(\n+        feature = \"ptr_internals\",\n+        issue = \"none\",\n+        reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n+    )]\n     #[inline]\n     #[doc(hidden)]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        let b = mem::ManuallyDrop::new(b);\n-        let mut unique = b.0;\n-        // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n-        // Stacked Borrows.  This function here corresponds to \"reborrowing to\n-        // a raw pointer\", but there is no actual reborrow here -- so\n-        // without some care, the pointer we are returning here still carries\n-        // the tag of `b`, with `Unique` permission.\n-        // We round-trip through a mutable reference to avoid that.\n-        unsafe { Unique::new_unchecked(unique.as_mut() as *mut T) }\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b).into()\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -523,7 +555,7 @@ impl<T: ?Sized> Box<T> {\n     where\n         T: 'a, // Technically not needed, but kept to be explicit.\n     {\n-        unsafe { &mut *Box::into_raw(b) }\n+        unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n     }\n \n     /// Converts a `Box<T>` into a `Pin<Box<T>>`\n@@ -774,6 +806,17 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n     }\n }\n \n+#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n+impl<T: Copy> From<Cow<'_, [T]>> for Box<[T]> {\n+    #[inline]\n+    fn from(cow: Cow<'_, [T]>) -> Box<[T]> {\n+        match cow {\n+            Cow::Borrowed(slice) => Box::from(slice),\n+            Cow::Owned(slice) => Box::from(slice),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl From<&str> for Box<str> {\n     /// Converts a `&str` into a `Box<str>`\n@@ -792,6 +835,17 @@ impl From<&str> for Box<str> {\n     }\n }\n \n+#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n+impl From<Cow<'_, str>> for Box<str> {\n+    #[inline]\n+    fn from(cow: Cow<'_, str>) -> Box<str> {\n+        match cow {\n+            Cow::Borrowed(s) => Box::from(s),\n+            Cow::Owned(s) => Box::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n impl From<Box<str>> for Box<[u8]> {\n     /// Converts a `Box<str>>` into a `Box<[u8]>`\n@@ -816,6 +870,25 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n+#[stable(feature = \"box_from_array\", since = \"1.45.0\")]\n+impl<T, const N: usize> From<[T; N]> for Box<[T]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Converts a `[T; N]` into a `Box<[T]>`\n+    ///\n+    /// This conversion moves the array to newly heap-allocated memory.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let boxed: Box<[u8]> = Box::from([4, 2]);\n+    /// println!(\"{:?}\", boxed);\n+    /// ```\n+    fn from(array: [T; N]) -> Box<[T]> {\n+        box array\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n where\n@@ -1041,6 +1114,14 @@ impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {\n         self.to_vec().into_boxed_slice()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        if self.len() == other.len() {\n+            self.clone_from_slice(&other);\n+        } else {\n+            *self = other.clone();\n+        }\n+    }\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]"}, {"sha": "15313e333ce732a876646d5fe533b77a58f4d0bf", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -665,6 +665,34 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n         DrainSorted { inner: self }\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns\n+    /// `false`. The elements are visited in unsorted (and unspecified) order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_retain)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    ///\n+    /// heap.retain(|x| x % 2 == 0); // only keep even numbers\n+    ///\n+    /// assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n+    /// ```\n+    #[unstable(feature = \"binary_heap_retain\", issue = \"71503\")]\n+    pub fn retain<F>(&mut self, f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.data.retain(f);\n+        self.rebuild();\n+    }\n }\n \n impl<T> BinaryHeap<T> {\n@@ -975,7 +1003,7 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n         debug_assert!(pos < data.len());\n         // SAFE: pos should be inside the slice\n-        let elt = ptr::read(data.get_unchecked(pos));\n+        let elt = unsafe { ptr::read(data.get_unchecked(pos)) };\n         Hole { data, elt: ManuallyDrop::new(elt), pos }\n     }\n \n@@ -997,7 +1025,7 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn get(&self, index: usize) -> &T {\n         debug_assert!(index != self.pos);\n         debug_assert!(index < self.data.len());\n-        self.data.get_unchecked(index)\n+        unsafe { self.data.get_unchecked(index) }\n     }\n \n     /// Move hole to new location\n@@ -1007,9 +1035,11 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn move_to(&mut self, index: usize) {\n         debug_assert!(index != self.pos);\n         debug_assert!(index < self.data.len());\n-        let index_ptr: *const _ = self.data.get_unchecked(index);\n-        let hole_ptr = self.data.get_unchecked_mut(self.pos);\n-        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        unsafe {\n+            let index_ptr: *const _ = self.data.get_unchecked(index);\n+            let hole_ptr = self.data.get_unchecked_mut(self.pos);\n+            ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        }\n         self.pos = index;\n     }\n }\n@@ -1241,7 +1271,7 @@ impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n \n         impl<'r, 'a, T: Ord> Drop for DropGuard<'r, 'a, T> {\n             fn drop(&mut self) {\n-                while let Some(_) = self.0.inner.pop() {}\n+                while self.0.inner.pop().is_some() {}\n             }\n         }\n \n@@ -1348,6 +1378,16 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n impl<T: Ord, I: IntoIterator<Item = T>> SpecExtend<I> for BinaryHeap<T> {\n@@ -1378,4 +1418,14 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }"}, {"sha": "bb9091a66594bda1665309811e38deab38fe4bd4", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 120, "deletions": 107, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -215,59 +215,6 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n-\n-    fn clone_from(&mut self, other: &Self) {\n-        BTreeClone::clone_from(self, other);\n-    }\n-}\n-\n-trait BTreeClone {\n-    fn clone_from(&mut self, other: &Self);\n-}\n-\n-impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    default fn clone_from(&mut self, other: &Self) {\n-        *self = other.clone();\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    fn clone_from(&mut self, other: &Self) {\n-        // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists.\n-        let split_off_key = if self.len() > other.len() {\n-            let diff = self.len() - other.len();\n-            if diff <= other.len() {\n-                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n-            } else {\n-                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n-            }\n-        } else {\n-            None\n-        };\n-        if let Some(key) = split_off_key {\n-            self.split_off(&key);\n-        }\n-\n-        let mut siter = self.range_mut(..);\n-        let mut oiter = other.iter();\n-        // After truncation, `self` is at most as long as `other` so this loop\n-        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n-        // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop.\n-        while !siter.is_empty() {\n-            if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because `siter` is nonempty.\n-                let (sk, sv) = unsafe { siter.next_unchecked() };\n-                sk.clone_from(ok);\n-                sv.clone_from(ov);\n-            } else {\n-                break;\n-            }\n-        }\n-        // If `other` is longer than `self`, the remaining elements are inserted.\n-        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n-    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n@@ -541,7 +488,9 @@ struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n-    /// Makes a new empty BTreeMap with a reasonable choice for B.\n+    /// Makes a new empty BTreeMap.\n+    ///\n+    /// Does not allocate anything on its own.\n     ///\n     /// # Examples\n     ///\n@@ -556,7 +505,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// map.insert(1, \"a\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BTreeMap<K, V> {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn new() -> BTreeMap<K, V> {\n         BTreeMap { root: None, length: 0 }\n     }\n \n@@ -923,15 +873,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btreemap_remove_entry)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n     /// assert_eq!(map.remove_entry(&1), None);\n     /// ```\n-    #[unstable(feature = \"btreemap_remove_entry\", issue = \"66714\")]\n+    #[stable(feature = \"btreemap_remove_entry\", since = \"1.45.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n         K: Borrow<Q>,\n@@ -1034,9 +983,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n-            let root1 = root.as_ref();\n-            let root2 = root.as_ref();\n-            let (f, b) = range_search(root1, root2, range);\n+            let (f, b) = range_search(root.as_ref(), range);\n \n             Range { front: Some(f), back: Some(b) }\n         } else {\n@@ -1082,9 +1029,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n-            let root1 = root.as_mut();\n-            let root2 = unsafe { ptr::read(&root1) };\n-            let (f, b) = range_search(root1, root2, range);\n+            let (f, b) = range_search(root.as_mut(), range);\n \n             RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n         } else {\n@@ -1451,6 +1396,14 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1513,6 +1466,14 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1545,16 +1506,10 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n \n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n-        if let Some(root) = me.root.as_mut() {\n-            let root1 = unsafe { ptr::read(root).into_ref() };\n-            let root2 = unsafe { ptr::read(root).into_ref() };\n-            let len = me.length;\n-\n-            IntoIter {\n-                front: Some(root1.first_leaf_edge()),\n-                back: Some(root2.last_leaf_edge()),\n-                length: len,\n-            }\n+        if let Some(root) = me.root.take() {\n+            let (f, b) = full_range_search(root.into_ref());\n+\n+            IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {\n             IntoIter { front: None, back: None, length: 0 }\n         }\n@@ -1656,6 +1611,14 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     fn last(mut self) -> Option<&'a K> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<&'a K> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<&'a K> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1788,7 +1751,7 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n         &mut self,\n     ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n         let edge = self.cur_leaf_edge.as_ref()?;\n-        ptr::read(edge).next_kv().ok()\n+        unsafe { ptr::read(edge).next_kv().ok() }\n     }\n \n     /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n@@ -1829,6 +1792,14 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1871,7 +1842,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n+        unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n \n@@ -1884,7 +1855,7 @@ impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n+        unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n \n@@ -1914,6 +1885,14 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n@@ -1922,7 +1901,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n+        unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n \n@@ -1943,7 +1922,7 @@ impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n+        unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n \n@@ -1964,13 +1943,23 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n             self.insert(k, v);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2042,9 +2031,9 @@ where\n     }\n }\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n-    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R,\n ) -> (\n     Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n@@ -2064,8 +2053,10 @@ where\n         _ => {}\n     };\n \n-    let mut min_node = root1;\n-    let mut max_node = root2;\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n     let mut min_found = false;\n     let mut max_found = false;\n \n@@ -2126,6 +2117,33 @@ where\n     }\n }\n \n+/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n+fn full_range_search<BorrowType, K, V>(\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2150,12 +2168,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            range: Range {\n-                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n-                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n-            },\n-            length: self.length,\n+        if let Some(root) = &self.root {\n+            let (f, b) = full_range_search(root.as_ref());\n+\n+            Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n+        } else {\n+            Iter { range: Range { front: None, back: None }, length: 0 }\n         }\n     }\n \n@@ -2182,19 +2200,15 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut {\n-            range: if let Some(root) = &mut self.root {\n-                let root1 = root.as_mut();\n-                let root2 = unsafe { ptr::read(&root1) };\n-                RangeMut {\n-                    front: Some(root1.first_leaf_edge()),\n-                    back: Some(root2.last_leaf_edge()),\n-                    _marker: PhantomData,\n-                }\n-            } else {\n-                RangeMut { front: None, back: None, _marker: PhantomData }\n-            },\n-            length: self.length,\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = full_range_search(root.as_mut());\n+\n+            IterMut {\n+                range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n+                length: self.length,\n+            }\n+        } else {\n+            IterMut { range: RangeMut { front: None, back: None, _marker: PhantomData }, length: 0 }\n         }\n     }\n \n@@ -2503,15 +2517,14 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n     ///\n-    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n     ///\n-    /// // count the number of occurrences of letters in the vec\n-    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n-    ///     *count.entry(x).or_insert(0) += 1;\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n     /// }\n-    ///\n-    /// assert_eq!(count[\"a\"], 3);\n+    /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {"}, {"sha": "543ff41a4d48d55fc2b4616f39a8a17cc69c2a87", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -19,7 +19,9 @@ pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n         if cfg!(debug_assertions) {\n             panic!(\"'unchecked' unwrap on None in BTreeMap\");\n         } else {\n-            core::intrinsics::unreachable();\n+            unsafe {\n+                core::intrinsics::unreachable();\n+            }\n         }\n     })\n }"}, {"sha": "5478d822438b1ca3afd2f169f7d50422147dbd52", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -64,8 +64,10 @@ macro_rules! def_next_kv_uncheched_dealloc {\n                 edge = match edge.$adjacent_kv() {\n                     Ok(internal_kv) => return internal_kv,\n                     Err(last_edge) => {\n-                        let parent_edge = last_edge.into_node().deallocate_and_ascend();\n-                        unwrap_unchecked(parent_edge).forget_node_type()\n+                        unsafe {\n+                            let parent_edge = last_edge.into_node().deallocate_and_ascend();\n+                            unwrap_unchecked(parent_edge).forget_node_type()\n+                        }\n                     }\n                 }\n             }\n@@ -82,9 +84,11 @@ def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_k\n /// Safety: The change closure must not panic.\n #[inline]\n unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n-    let value = ptr::read(v);\n+    let value = unsafe { ptr::read(v) };\n     let (new_value, ret) = change(value);\n-    ptr::write(v, new_value);\n+    unsafe {\n+        ptr::write(v, new_value);\n+    }\n     ret\n }\n \n@@ -93,22 +97,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (kv.next_leaf_edge(), kv.into_kv())\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (kv.next_leaf_edge(), kv.into_kv())\n+            })\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_back_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (kv.next_back_leaf_edge(), kv.into_kv())\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_back_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (kv.next_back_leaf_edge(), kv.into_kv())\n+            })\n+        }\n     }\n }\n \n@@ -119,14 +127,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let kv = replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (ptr::read(&kv).next_leaf_edge(), kv)\n-        });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        unsafe {\n+            let kv = replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (ptr::read(&kv).next_leaf_edge(), kv)\n+            });\n+            // Doing the descend (and perhaps another move) invalidates the references\n+            // returned by `into_kv_mut`, so we have to do this last.\n+            kv.into_kv_mut()\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n@@ -135,14 +145,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let kv = replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_back_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (ptr::read(&kv).next_back_leaf_edge(), kv)\n-        });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        unsafe {\n+            let kv = replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_back_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (ptr::read(&kv).next_back_leaf_edge(), kv)\n+            });\n+            // Doing the descend (and perhaps another move) invalidates the references\n+            // returned by `into_kv_mut`, so we have to do this last.\n+            kv.into_kv_mut()\n+        }\n     }\n }\n \n@@ -159,12 +171,14 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        replace(self, |leaf_edge| {\n-            let kv = next_kv_unchecked_dealloc(leaf_edge);\n-            let k = ptr::read(kv.reborrow().into_kv().0);\n-            let v = ptr::read(kv.reborrow().into_kv().1);\n-            (kv.next_leaf_edge(), (k, v))\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = next_kv_unchecked_dealloc(leaf_edge);\n+                let k = ptr::read(kv.reborrow().into_kv().0);\n+                let v = ptr::read(kv.reborrow().into_kv().1);\n+                (kv.next_leaf_edge(), (k, v))\n+            })\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -179,12 +193,14 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        replace(self, |leaf_edge| {\n-            let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n-            let k = ptr::read(kv.reborrow().into_kv().0);\n-            let v = ptr::read(kv.reborrow().into_kv().1);\n-            (kv.next_back_leaf_edge(), (k, v))\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n+                let k = ptr::read(kv.reborrow().into_kv().0);\n+                let v = ptr::read(kv.reborrow().into_kv().1);\n+                (kv.next_back_leaf_edge(), (k, v))\n+            })\n+        }\n     }\n }\n "}, {"sha": "a4b6cf12a23bd92671d30db8cdc4eaa8b293aeed", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -107,7 +107,7 @@ impl<K, V> InternalNode<K, V> {\n     /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n     /// such an edge.\n     unsafe fn new() -> Self {\n-        InternalNode { data: LeafNode::new(), edges: [MaybeUninit::UNINIT; 2 * B] }\n+        InternalNode { data: unsafe { LeafNode::new() }, edges: [MaybeUninit::UNINIT; 2 * B] }\n     }\n }\n \n@@ -131,7 +131,7 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(ptr) }\n+        BoxedNode { ptr: unsafe { Unique::new_unchecked(ptr.as_ptr()) } }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n@@ -392,14 +392,16 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(\n-            node.cast(),\n-            if height > 0 {\n-                Layout::new::<InternalNode<K, V>>()\n-            } else {\n-                Layout::new::<LeafNode<K, V>>()\n-            },\n-        );\n+        unsafe {\n+            Global.dealloc(\n+                node.cast(),\n+                if height > 0 {\n+                    Layout::new::<InternalNode<K, V>>()\n+                } else {\n+                    Layout::new::<LeafNode<K, V>>()\n+                },\n+            );\n+        }\n         ret\n     }\n }\n@@ -565,7 +567,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         debug_assert!(first <= self.len());\n         debug_assert!(after_last <= self.len() + 1);\n         for i in first..after_last {\n-            Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n+            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n         }\n     }\n \n@@ -789,7 +791,7 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n-        Handle { node: self.node.reborrow_mut(), idx: self.idx, _marker: PhantomData }\n+        Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n     }\n }\n \n@@ -885,7 +887,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     unsafe fn cast_unchecked<NewType>(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n-        Handle::new_edge(self.node.cast_unchecked(), self.idx)\n+        unsafe { Handle::new_edge(self.node.cast_unchecked(), self.idx) }\n     }\n \n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n@@ -1330,8 +1332,10 @@ unsafe fn move_kv<K, V>(\n     dest_offset: usize,\n     count: usize,\n ) {\n-    ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n-    ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n+    unsafe {\n+        ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n+        ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n+    }\n }\n \n // Source and destination must have the same height.\n@@ -1344,8 +1348,10 @@ unsafe fn move_edges<K, V>(\n ) {\n     let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n-    ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n-    dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+    unsafe {\n+        ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n+        dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+    }\n }\n \n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n@@ -1459,12 +1465,16 @@ pub mod marker {\n }\n \n unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n-    ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n-    ptr::write(slice.get_unchecked_mut(idx), val);\n+    unsafe {\n+        ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n+        ptr::write(slice.get_unchecked_mut(idx), val);\n+    }\n }\n \n unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n-    let ret = ptr::read(slice.get_unchecked(idx));\n-    ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n-    ret\n+    unsafe {\n+        let ret = ptr::read(slice.get_unchecked(idx));\n+        ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n+        ret\n+    }\n }"}, {"sha": "d8959966fe5ad38a8f846780af27892a77fba621", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -309,7 +309,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// let mut set: BTreeSet<i32> = BTreeSet::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BTreeSet<T> {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -1151,13 +1152,23 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n             self.insert(elem);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1280,12 +1291,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next()\n     }\n+\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<&'a T> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n@@ -1310,6 +1331,7 @@ impl<T> Iterator for IntoIter<T> {\n     fn next(&mut self) -> Option<T> {\n         self.iter.next().map(|(k, _)| k)\n     }\n+\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n@@ -1348,6 +1370,14 @@ impl<'a, T> Iterator for Range<'a, T> {\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n     }\n+\n+    fn min(mut self) -> Option<&'a T> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n@@ -1418,6 +1448,10 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n         };\n         (self_len.saturating_sub(other_len), Some(self_len))\n     }\n+\n+    fn min(mut self) -> Option<&'a T> {\n+        self.next()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1449,6 +1483,10 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n         // the number of elements to less than half the range of usize.\n         (0, Some(a_len + b_len))\n     }\n+\n+    fn min(mut self) -> Option<&'a T> {\n+        self.next()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1505,6 +1543,10 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n             IntersectionInner::Answer(Some(_)) => (1, Some(1)),\n         }\n     }\n+\n+    fn min(mut self) -> Option<&'a T> {\n+        self.next()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1530,6 +1572,10 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n         // No checked_add - see SymmetricDifference::size_hint.\n         (max(a_len, b_len), Some(a_len + b_len))\n     }\n+\n+    fn min(mut self) -> Option<&'a T> {\n+        self.next()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "36b5785fdf6c5ed930340eb4b38d772d7dd21f4a", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 80, "deletions": 21, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -143,7 +143,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n-            let node = Some(Box::into_raw_non_null(node));\n+            let node = Some(Box::leak(node).into());\n \n             match self.head {\n                 None => self.tail = node,\n@@ -184,7 +184,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n-            let node = Some(Box::into_raw_non_null(node));\n+            let node = Some(Box::leak(node).into());\n \n             match self.tail {\n                 None => self.head = node,\n@@ -225,17 +225,17 @@ impl<T> LinkedList<T> {\n     /// maintain validity of aliasing pointers.\n     #[inline]\n     unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n-        let node = node.as_mut(); // this one is ours now, we can create an &mut.\n+        let node = unsafe { node.as_mut() }; // this one is ours now, we can create an &mut.\n \n         // Not creating new mutable (unique!) references overlapping `element`.\n         match node.prev {\n-            Some(prev) => (*prev.as_ptr()).next = node.next,\n+            Some(prev) => unsafe { (*prev.as_ptr()).next = node.next },\n             // this node is the head node\n             None => self.head = node.next,\n         };\n \n         match node.next {\n-            Some(next) => (*next.as_ptr()).prev = node.prev,\n+            Some(next) => unsafe { (*next.as_ptr()).prev = node.prev },\n             // this node is the tail node\n             None => self.tail = node.prev,\n         };\n@@ -258,17 +258,23 @@ impl<T> LinkedList<T> {\n         // This method takes care not to create multiple mutable references to whole nodes at the same time,\n         // to maintain validity of aliasing pointers into `element`.\n         if let Some(mut existing_prev) = existing_prev {\n-            existing_prev.as_mut().next = Some(splice_start);\n+            unsafe {\n+                existing_prev.as_mut().next = Some(splice_start);\n+            }\n         } else {\n             self.head = Some(splice_start);\n         }\n         if let Some(mut existing_next) = existing_next {\n-            existing_next.as_mut().prev = Some(splice_end);\n+            unsafe {\n+                existing_next.as_mut().prev = Some(splice_end);\n+            }\n         } else {\n             self.tail = Some(splice_end);\n         }\n-        splice_start.as_mut().prev = existing_prev;\n-        splice_end.as_mut().next = existing_next;\n+        unsafe {\n+            splice_start.as_mut().prev = existing_prev;\n+            splice_end.as_mut().next = existing_next;\n+        }\n \n         self.len += splice_length;\n     }\n@@ -297,9 +303,13 @@ impl<T> LinkedList<T> {\n         if let Some(mut split_node) = split_node {\n             let first_part_head;\n             let first_part_tail;\n-            first_part_tail = split_node.as_mut().prev.take();\n+            unsafe {\n+                first_part_tail = split_node.as_mut().prev.take();\n+            }\n             if let Some(mut tail) = first_part_tail {\n-                tail.as_mut().next = None;\n+                unsafe {\n+                    tail.as_mut().next = None;\n+                }\n                 first_part_head = self.head;\n             } else {\n                 first_part_head = None;\n@@ -333,9 +343,13 @@ impl<T> LinkedList<T> {\n         if let Some(mut split_node) = split_node {\n             let second_part_head;\n             let second_part_tail;\n-            second_part_head = split_node.as_mut().next.take();\n+            unsafe {\n+                second_part_head = split_node.as_mut().next.take();\n+            }\n             if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n+                unsafe {\n+                    head.as_mut().prev = None;\n+                }\n                 second_part_tail = self.tail;\n             } else {\n                 second_part_tail = None;\n@@ -972,7 +986,7 @@ unsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n             fn drop(&mut self) {\n                 // Continue the same loop we do below. This only runs when a destructor has\n                 // panicked. If another one panics this will abort.\n-                while let Some(_) = self.0.pop_front_node() {}\n+                while self.0.pop_front_node().is_some() {}\n             }\n         }\n \n@@ -1133,11 +1147,9 @@ impl<T> IterMut<'_, T> {\n                     Some(prev) => prev,\n                 };\n \n-                let node = Some(Box::into_raw_non_null(box Node {\n-                    next: Some(head),\n-                    prev: Some(prev),\n-                    element,\n-                }));\n+                let node = Some(\n+                    Box::leak(box Node { next: Some(head), prev: Some(prev), element }).into(),\n+                );\n \n                 // Not creating references to entire nodes to not invalidate the\n                 // reference to `element` we handed to the user.\n@@ -1450,7 +1462,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_after(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n             let node_next = match self.current {\n                 None => self.list.head,\n                 Some(node) => node.as_ref().next,\n@@ -1470,7 +1482,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_before(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n             let node_prev = match self.current {\n                 None => self.list.tail,\n                 Some(node) => node.as_ref().prev,\n@@ -1498,6 +1510,31 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n+    /// Removes the current element from the `LinkedList` without deallocating the list node.\n+    ///\n+    /// The node that was removed is returned as a new `LinkedList` containing only this node.\n+    /// The cursor is moved to point to the next element in the current `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove_current_as_list(&mut self) -> Option<LinkedList<T>> {\n+        let mut unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+\n+            unlinked_node.as_mut().prev = None;\n+            unlinked_node.as_mut().next = None;\n+            Some(LinkedList {\n+                head: Some(unlinked_node),\n+                tail: Some(unlinked_node),\n+                len: 1,\n+                marker: PhantomData,\n+            })\n+        }\n+    }\n+\n     /// Inserts the elements from the given `LinkedList` after the current one.\n     ///\n     /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n@@ -1725,6 +1762,11 @@ impl<T> Extend<T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.push_back(elem);\n+    }\n }\n \n impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n@@ -1744,6 +1786,11 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.push_back(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1843,3 +1890,15 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Send for Cursor<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Sync for Cursor<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Send> Send for CursorMut<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Sync for CursorMut<'_, T> {}"}, {"sha": "b8c93a28bba815a1bfa38fea9a49e581a335c13f", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -182,7 +182,6 @@ fn test_insert_prev() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {"}, {"sha": "2efb94e8afe57731485f7bca4665a93e235abf1e", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 194, "deletions": 45, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -7,6 +7,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+// ignore-tidy-filelength\n+\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n@@ -50,6 +52,7 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (64 - 1); // Largest possible power of\n /// [`pop_front`]: #method.pop_front\n /// [`extend`]: #method.extend\n /// [`append`]: #method.append\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"vecdeque_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n@@ -72,7 +75,7 @@ pub struct VecDeque<T> {\n /// It produces the following sequence of matching slices:\n ///\n /// ([0 1], [a b])\n-/// ([2], [c])\n+/// (\\[2\\], \\[c\\])\n /// ([3 4], [d e])\n ///\n /// and the uneven remainder of either A or B is skipped.\n@@ -200,25 +203,27 @@ impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        slice::from_raw_parts(self.ptr(), self.cap())\n+        unsafe { slice::from_raw_parts(self.ptr(), self.cap()) }\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        slice::from_raw_parts_mut(self.ptr(), self.cap())\n+        unsafe { slice::from_raw_parts_mut(self.ptr(), self.cap()) }\n     }\n \n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n-        ptr::read(self.ptr().add(off))\n+        unsafe { ptr::read(self.ptr().add(off)) }\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n     unsafe fn buffer_write(&mut self, off: usize, value: T) {\n-        ptr::write(self.ptr().add(off), value);\n+        unsafe {\n+            ptr::write(self.ptr().add(off), value);\n+        }\n     }\n \n     /// Returns `true` if the buffer is at full capacity.\n@@ -267,7 +272,9 @@ impl<T> VecDeque<T> {\n             len,\n             self.cap()\n         );\n-        ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n+        unsafe {\n+            ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n+        }\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n@@ -289,7 +296,9 @@ impl<T> VecDeque<T> {\n             len,\n             self.cap()\n         );\n-        ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n+        }\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n@@ -329,7 +338,9 @@ impl<T> VecDeque<T> {\n                 // 2 [_ _ A A A A B B _]\n                 //            D . . .\n                 //\n-                self.copy(dst, src, len);\n+                unsafe {\n+                    self.copy(dst, src, len);\n+                }\n             }\n             (false, false, true) => {\n                 // dst before src, src doesn't wrap, dst wraps\n@@ -340,8 +351,10 @@ impl<T> VecDeque<T> {\n                 // 3 [B B B B _ _ _ A A]\n                 //    . .           D .\n                 //\n-                self.copy(dst, src, dst_pre_wrap_len);\n-                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                }\n             }\n             (true, false, true) => {\n                 // src before dst, src doesn't wrap, dst wraps\n@@ -352,8 +365,10 @@ impl<T> VecDeque<T> {\n                 // 3 [B B _ _ _ A A A A]\n                 //    . .           D .\n                 //\n-                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n-                self.copy(dst, src, dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                }\n             }\n             (false, true, false) => {\n                 // dst before src, src wraps, dst doesn't wrap\n@@ -364,8 +379,10 @@ impl<T> VecDeque<T> {\n                 // 3 [C C _ _ _ B B C C]\n                 //              D . . .\n                 //\n-                self.copy(dst, src, src_pre_wrap_len);\n-                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                }\n             }\n             (true, true, false) => {\n                 // src before dst, src wraps, dst doesn't wrap\n@@ -376,8 +393,10 @@ impl<T> VecDeque<T> {\n                 // 3 [C C A A _ _ _ C C]\n                 //    D . . .\n                 //\n-                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n-                self.copy(dst, src, src_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                }\n             }\n             (false, true, true) => {\n                 // dst before src, src wraps, dst wraps\n@@ -391,9 +410,11 @@ impl<T> VecDeque<T> {\n                 //\n                 debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n                 let delta = dst_pre_wrap_len - src_pre_wrap_len;\n-                self.copy(dst, src, src_pre_wrap_len);\n-                self.copy(dst + src_pre_wrap_len, 0, delta);\n-                self.copy(0, delta, len - dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(dst + src_pre_wrap_len, 0, delta);\n+                    self.copy(0, delta, len - dst_pre_wrap_len);\n+                }\n             }\n             (true, true, true) => {\n                 // src before dst, src wraps, dst wraps\n@@ -407,9 +428,11 @@ impl<T> VecDeque<T> {\n                 //\n                 debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n                 let delta = src_pre_wrap_len - dst_pre_wrap_len;\n-                self.copy(delta, 0, len - src_pre_wrap_len);\n-                self.copy(0, self.cap() - delta, delta);\n-                self.copy(dst, src, dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(delta, 0, len - src_pre_wrap_len);\n+                    self.copy(0, self.cap() - delta, delta);\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                }\n             }\n         }\n     }\n@@ -439,13 +462,17 @@ impl<T> VecDeque<T> {\n             // Nop\n         } else if self.head < old_capacity - self.tail {\n             // B\n-            self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            unsafe {\n+                self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            }\n             self.head += old_capacity;\n             debug_assert!(self.head > self.tail);\n         } else {\n             // C\n             let new_tail = new_capacity - (old_capacity - self.tail);\n-            self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            unsafe {\n+                self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            }\n             self.tail = new_tail;\n             debug_assert!(self.head < self.tail);\n         }\n@@ -1057,6 +1084,108 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n+    fn range_start_end<R>(&self, range: R) -> (usize, usize)\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let len = self.len();\n+        let start = match range.start_bound() {\n+            Included(&n) => n,\n+            Excluded(&n) => n + 1,\n+            Unbounded => 0,\n+        };\n+        let end = match range.end_bound() {\n+            Included(&n) => n + 1,\n+            Excluded(&n) => n,\n+            Unbounded => len,\n+        };\n+        assert!(start <= end, \"lower bound was too large\");\n+        assert!(end <= len, \"upper bound was too large\");\n+        (start, end)\n+    }\n+\n+    /// Creates an iterator that covers the specified range in the `VecDeque`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(deque_range)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let range = v.range(2..).copied().collect::<VecDeque<_>>();\n+    /// assert_eq!(range, [3]);\n+    ///\n+    /// // A full range covers all contents\n+    /// let all = v.range(..);\n+    /// assert_eq!(all.len(), 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"deque_range\", issue = \"74217\")]\n+    pub fn range<R>(&self, range: R) -> Iter<'_, T>\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let (start, end) = self.range_start_end(range);\n+        let tail = self.wrap_add(self.tail, start);\n+        let head = self.wrap_add(self.tail, end);\n+        Iter {\n+            tail,\n+            head,\n+            // The shared reference we have in &self is maintained in the '_ of Iter.\n+            ring: unsafe { self.buffer_as_slice() },\n+        }\n+    }\n+\n+    /// Creates an iterator that covers the specified mutable range in the `VecDeque`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(deque_range)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// for v in v.range_mut(2..) {\n+    ///   *v *= 2;\n+    /// }\n+    /// assert_eq!(v, vec![1, 2, 6]);\n+    ///\n+    /// // A full range covers all contents\n+    /// for v in v.range_mut(..) {\n+    ///   *v *= 2;\n+    /// }\n+    /// assert_eq!(v, vec![2, 4, 12]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"deque_range\", issue = \"74217\")]\n+    pub fn range_mut<R>(&mut self, range: R) -> IterMut<'_, T>\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let (start, end) = self.range_start_end(range);\n+        let tail = self.wrap_add(self.tail, start);\n+        let head = self.wrap_add(self.tail, end);\n+        IterMut {\n+            tail,\n+            head,\n+            // The shared reference we have in &mut self is maintained in the '_ of IterMut.\n+            ring: unsafe { self.buffer_as_mut_slice() },\n+        }\n+    }\n+\n     /// Creates a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items.\n     ///\n@@ -1102,19 +1231,7 @@ impl<T> VecDeque<T> {\n         // When finished, the remaining data will be copied back to cover the hole,\n         // and the head/tail values will be restored correctly.\n         //\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n-        assert!(start <= end, \"drain lower bound was too large\");\n-        assert!(end <= len, \"drain upper bound was too large\");\n+        let (start, end) = self.range_start_end(range);\n \n         // The deque's elements are parted into three segments:\n         // * self.tail  -> drain_tail\n@@ -1353,7 +1470,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1376,7 +1495,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1484,7 +1605,9 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -2002,11 +2125,13 @@ impl<T> VecDeque<T> {\n     }\n \n     // This may panic or abort\n-    #[inline]\n-    fn grow_if_necessary(&mut self) {\n+    #[inline(never)]\n+    fn grow(&mut self) {\n         if self.is_full() {\n             let old_cap = self.cap();\n-            self.buf.double();\n+            // Double the buffer size.\n+            self.buf.reserve_exact(old_cap, old_cap);\n+            assert!(self.cap() == old_cap * 2);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -2288,7 +2413,9 @@ impl<T> VecDeque<T> {\n \n     unsafe fn rotate_left_inner(&mut self, mid: usize) {\n         debug_assert!(mid * 2 <= self.len());\n-        self.wrap_copy(self.head, self.tail, mid);\n+        unsafe {\n+            self.wrap_copy(self.head, self.tail, mid);\n+        }\n         self.head = self.wrap_add(self.head, mid);\n         self.tail = self.wrap_add(self.tail, mid);\n     }\n@@ -2297,7 +2424,9 @@ impl<T> VecDeque<T> {\n         debug_assert!(k * 2 <= self.len());\n         self.head = self.wrap_sub(self.head, k);\n         self.tail = self.wrap_sub(self.tail, k);\n-        self.wrap_copy(self.tail, self.head, k);\n+        unsafe {\n+            self.wrap_copy(self.tail, self.head, k);\n+        }\n     }\n }\n \n@@ -2872,13 +3001,33 @@ impl<A> Extend<A> for VecDeque<A> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: A) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &T) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e5edfe02a525fa4e0dce1c09cc759dc10e603f17", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,9 +1,7 @@\n use super::*;\n \n-use test;\n-\n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -16,7 +14,7 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -29,7 +27,7 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n \n@@ -43,7 +41,7 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n \n@@ -248,6 +246,65 @@ fn test_remove() {\n     }\n }\n \n+#[test]\n+fn test_range() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for start in 0..=len {\n+                for end in start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    // Check that we iterate over the correct values\n+                    let range: VecDeque<_> = tester.range(start..end).copied().collect();\n+                    let expected: VecDeque<_> = (start..end).collect();\n+                    assert_eq!(range, expected);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_range_mut() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for start in 0..=len {\n+                for end in start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    let head_was = tester.head;\n+                    let tail_was = tester.tail;\n+\n+                    // Check that we iterate over the correct values\n+                    let range: VecDeque<_> = tester.range_mut(start..end).map(|v| *v).collect();\n+                    let expected: VecDeque<_> = (start..end).collect();\n+                    assert_eq!(range, expected);\n+\n+                    // We shouldn't have changed the capacity or made the\n+                    // head or tail out of bounds\n+                    assert_eq!(tester.capacity(), cap);\n+                    assert_eq!(tester.tail, tail_was);\n+                    assert_eq!(tester.head, head_was);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_drain() {\n     let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n@@ -386,10 +443,8 @@ fn test_vec_from_vecdeque() {\n         assert!(vec.into_iter().eq(vd));\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let max_pwr = 7;\n-    #[cfg(miri)]\n-    let max_pwr = 5;\n+    // Miri is too slow\n+    let max_pwr = if cfg!(miri) { 5 } else { 7 };\n \n     for cap_pwr in 0..max_pwr {\n         // Make capacity as a (2^x)-1, so that the ring size is 2^x"}, {"sha": "26077f3c8d15045820c9912e54d4facd790f9954", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -50,8 +50,8 @@\n //! The internal iterator over the argument has not been advanced by the time\n //! the first `{}` is seen, so it prints the first argument. Then upon reaching\n //! the second `{}`, the iterator has advanced forward to the second argument.\n-//! Essentially, parameters which explicitly name their argument do not affect\n-//! parameters which do not name an argument in terms of positional specifiers.\n+//! Essentially, parameters that explicitly name their argument do not affect\n+//! parameters that do not name an argument in terms of positional specifiers.\n //!\n //! A format string is required to use all of its arguments, otherwise it is a\n //! compile-time error. You may refer to the same argument more than once in the\n@@ -60,7 +60,7 @@\n //! ## Named parameters\n //!\n //! Rust itself does not have a Python-like equivalent of named parameters to a\n-//! function, but the [`format!`] macro is a syntax extension which allows it to\n+//! function, but the [`format!`] macro is a syntax extension that allows it to\n //! leverage named parameters. Named parameters are listed at the end of the\n //! argument list and have the syntax:\n //!\n@@ -77,7 +77,7 @@\n //! ```\n //!\n //! It is not valid to put positional parameters (those without names) after\n-//! arguments which have names. Like with positional parameters, it is not\n+//! arguments that have names. Like with positional parameters, it is not\n //! valid to provide named parameters that are unused by the format string.\n //!\n //! # Formatting Parameters\n@@ -130,7 +130,7 @@\n //!\n //! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n //! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! default for numeric formatters is also a space character but with right-alignment. If\n //! the `0` flag (see below) is specified for numerics, then the implicit fill character is\n //! `0`.\n //!\n@@ -161,7 +161,7 @@\n //!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n //!         should always be printed.\n //! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//! * `#` - This flag indicates that the \"alternate\" form of printing should\n //!         be used. The alternate forms are:\n //!     * `#?` - pretty-print the [`Debug`] formatting\n //!     * `#x` - precedes the argument with a `0x`\n@@ -173,9 +173,9 @@\n //!         like `{:08}` would yield `00000001` for the integer `1`, while the\n //!         same format would yield `-0000001` for the integer `-1`. Notice that\n //!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         Note that padding zeros are always placed after the sign (if any)\n //!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         rule applies: padding zeros are inserted after the prefix but before\n //!         the digits. The prefix is included in the total width.\n //!\n //! ## Precision\n@@ -251,7 +251,7 @@\n //!\n //! In some programming languages, the behavior of string formatting functions\n //! depends on the operating system's locale setting. The format functions\n-//! provided by Rust's standard library do not have any concept of locale, and\n+//! provided by Rust's standard library do not have any concept of locale and\n //! will produce the same results on all systems regardless of user\n //! configuration.\n //!\n@@ -470,7 +470,7 @@\n //!\n //! ### `format_args!`\n //!\n-//! This is a curious macro which is used to safely pass around\n+//! This is a curious macro used to safely pass around\n //! an opaque object describing the format string. This object\n //! does not require any heap allocations to create, and it only\n //! references information on the stack. Under the hood, all of\n@@ -495,7 +495,7 @@\n //! This structure can then be passed to the [`write`] and [`format`] functions\n //! inside this module in order to process the format string.\n //! The goal of this macro is to even further prevent intermediate allocations\n-//! when dealing formatting strings.\n+//! when dealing with formatting strings.\n //!\n //! For example, a logging library could use the standard formatting syntax, but\n //! it would internally pass around this structure until it has been determined"}, {"sha": "2ec777ac85c6651699620d502a525cbca46b4045", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -72,51 +72,57 @@\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n #![feature(allocator_api)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n-#![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(const_btree_new)]\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n-#![feature(const_if_match)]\n+#![cfg_attr(bootstrap, feature(const_if_match))]\n #![feature(cow_is_borrowed)]\n+#![feature(deque_range)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n+#![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(internal_uninit_const)]\n #![feature(lang_items)]\n+#![feature(layout_for_ptr)]\n #![feature(libc)]\n-#![cfg_attr(not(bootstrap), feature(negative_impls))]\n+#![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n+#![feature(raw_ref_op)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode_internals)]\n+#![feature(unsafe_block_in_unsafe_fn)]\n #![feature(unsize)]\n #![feature(unsized_locals)]\n #![feature(allocator_internals)]"}, {"sha": "ed81ce71ddfac76a3614cbf04dc47f39fefa5e94", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 162, "deletions": 249, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,15 +1,15 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::MemoryBlock;\n+use core::alloc::{LayoutErr, MemoryBlock};\n use core::cmp;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n use core::ptr::{NonNull, Unique};\n use core::slice;\n \n use crate::alloc::{\n-    handle_alloc_error, AllocErr,\n+    handle_alloc_error,\n     AllocInit::{self, *},\n     AllocRef, Global, Layout,\n     ReallocPlacement::{self, *},\n@@ -25,9 +25,9 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces `Unique::empty()` on zero-sized types.\n-/// * Produces `Unique::empty()` on zero-length allocations.\n-/// * Avoids freeing `Unique::empty()`.\n+/// * Produces `Unique::dangling()` on zero-sized types.\n+/// * Produces `Unique::dangling()` on zero-length allocations.\n+/// * Avoids freeing `Unique::dangling()`.\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n /// * Guards against overflowing your length.\n@@ -60,7 +60,7 @@ impl<T> RawVec<T, Global> {\n     /// `#[rustc_force_min_const_fn]` attribute which requires conformance\n     /// with `min_const_fn` but does not necessarily allow calling it in\n     /// `stable(...) const fn` / user code not enabling `foo` when\n-    /// `#[rustc_const_unstable(feature = \"foo\", ..)]` is present.\n+    /// `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` is present.\n     pub const NEW: Self = Self::new();\n \n     /// Creates the biggest possible `RawVec` (on the system heap)\n@@ -80,9 +80,7 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n+    /// Panics if the requested capacity exceeds `isize::MAX` bytes.\n     ///\n     /// # Aborts\n     ///\n@@ -108,7 +106,7 @@ impl<T> RawVec<T, Global> {\n     /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     #[inline]\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n-        Self::from_raw_parts_in(ptr, capacity, Global)\n+        unsafe { Self::from_raw_parts_in(ptr, capacity, Global) }\n     }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n@@ -118,14 +116,40 @@ impl<T> RawVec<T, Global> {\n             RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len())\n         }\n     }\n+\n+    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n+    ///\n+    /// Note that this will correctly reconstitute any `cap` changes\n+    /// that may have been performed. (See description of type for details.)\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `len` must be greater than or equal to the most recently requested capacity, and\n+    /// * `len` must be less than or equal to `self.capacity()`.\n+    ///\n+    /// Note, that the requested capacity and `self.capacity()` could differ, as\n+    /// an allocator could overallocate and return a greater memory block than requested.\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        // Sanity-check one half of the safety requirement (we cannot check the other half).\n+        debug_assert!(\n+            len <= self.capacity(),\n+            \"`len` must be smaller than or equal to `self.capacity()`\"\n+        );\n+\n+        let me = ManuallyDrop::new(self);\n+        unsafe {\n+            let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n+            Box::from_raw(slice)\n+        }\n+    }\n }\n \n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n     pub const fn new_in(alloc: A) -> Self {\n         // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n-        Self { ptr: Unique::empty(), cap: 0, alloc }\n+        Self { ptr: Unique::dangling(), cap: 0, alloc }\n     }\n \n     /// Like `with_capacity`, but parameterized over the choice of\n@@ -146,12 +170,23 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         if mem::size_of::<T>() == 0 {\n             Self::new_in(alloc)\n         } else {\n-            let layout = Layout::array::<T>(capacity).unwrap_or_else(|_| capacity_overflow());\n-            alloc_guard(layout.size()).unwrap_or_else(|_| capacity_overflow());\n+            // We avoid `unwrap_or_else` here because it bloats the amount of\n+            // LLVM IR generated.\n+            let layout = match Layout::array::<T>(capacity) {\n+                Ok(layout) => layout,\n+                Err(_) => capacity_overflow(),\n+            };\n+            match alloc_guard(layout.size()) {\n+                Ok(_) => {}\n+                Err(_) => capacity_overflow(),\n+            }\n+            let memory = match alloc.alloc(layout, init) {\n+                Ok(memory) => memory,\n+                Err(_) => handle_alloc_error(layout),\n+            };\n \n-            let memory = alloc.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n             Self {\n-                ptr: memory.ptr.cast().into(),\n+                ptr: unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) },\n                 cap: Self::capacity_from_bytes(memory.size),\n                 alloc,\n             }\n@@ -168,11 +203,11 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     #[inline]\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        Self { ptr: Unique::new_unchecked(ptr), cap: capacity, alloc: a }\n+        Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc: a }\n     }\n \n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n+    /// `Unique::dangling()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -211,99 +246,21 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         }\n     }\n \n-    /// Doubles the size of the type's backing allocation. This is common enough\n-    /// to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// This function is ideal for when pushing elements one-at-a-time because\n-    /// you don't need to incur the costs of the more general computations\n-    /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == capacity`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n-    ///\n-    /// # Examples\n+    /// Ensures that the buffer contains at least enough space to hold `len +\n+    /// additional` elements. If it doesn't already have enough capacity, will\n+    /// reallocate enough space plus comfortable slack space to get amortized\n+    /// `O(1)` behavior. Will limit this behavior if it would needlessly cause\n+    /// itself to panic.\n     ///\n-    /// ```\n-    /// # #![feature(raw_vec_internals)]\n-    /// # extern crate alloc;\n-    /// # use std::ptr;\n-    /// # use alloc::raw_vec::RawVec;\n-    /// struct MyVec<T> {\n-    ///     buf: RawVec<T>,\n-    ///     len: usize,\n-    /// }\n-    ///\n-    /// impl<T> MyVec<T> {\n-    ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n-    ///         // double would have aborted or panicked if the len exceeded\n-    ///         // `isize::MAX` so this is safe to do unchecked now.\n-    ///         unsafe {\n-    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n-    ///         }\n-    ///         self.len += 1;\n-    ///     }\n-    /// }\n-    /// # fn main() {\n-    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n-    /// #   vec.push(1);\n-    /// # }\n-    /// ```\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double(&mut self) {\n-        match self.grow(Double, MayMove, Uninitialized) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n-    }\n-\n-    /// Attempts to double the size of the type's backing allocation in place. This is common\n-    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// Returns `true` if the reallocation attempt has succeeded.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double_in_place(&mut self) -> bool {\n-        self.grow(Double, InPlace, Uninitialized).is_ok()\n-    }\n-\n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n-    /// enough capacity, will reallocate enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behavior. Will limit this behavior\n-    /// if it would needlessly cause itself to panic.\n-    ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n+    /// If `len` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n     /// This is ideal for implementing a bulk-push operation like `extend`.\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n+    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n     ///\n     /// # Aborts\n     ///\n@@ -339,77 +296,42 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.try_reserve(used_capacity, needed_extra_capacity) {\n+    pub fn reserve(&mut self, len: usize, additional: usize) {\n+        match self.try_reserve(len, additional) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n         }\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n-        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+    pub fn try_reserve(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n+        if self.needs_to_grow(len, additional) {\n+            self.grow_amortized(len, additional)\n         } else {\n             Ok(())\n         }\n     }\n \n-    /// Attempts to ensure that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n-    /// enough capacity, will reallocate in place enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behavior. Will limit this behaviour\n-    /// if it would needlessly cause itself to panic.\n-    ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n-    ///\n-    /// Returns `true` if the reallocation attempt has succeeded.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        // This is more readable than putting this in one line:\n-        // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n-        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, InPlace, Uninitialized)\n-                .is_ok()\n-        } else {\n-            true\n-        }\n-    }\n-\n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n-    /// will reallocate the minimum possible amount of memory necessary.\n-    /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n-    /// we asked for.\n+    /// Ensures that the buffer contains at least enough space to hold `len +\n+    /// additional` elements. If it doesn't already, will reallocate the\n+    /// minimum possible amount of memory necessary. Generally this will be\n+    /// exactly the amount of memory necessary, but in principle the allocator\n+    /// is free to give back more than we asked for.\n     ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n+    /// If `len` exceeds `self.capacity()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe code\n+    /// *you* write that relies on the behavior of this function may break.\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n+    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n     ///\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n-    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.try_reserve_exact(used_capacity, needed_extra_capacity) {\n+    pub fn reserve_exact(&mut self, len: usize, additional: usize) {\n+        match self.try_reserve_exact(len, additional) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n@@ -419,14 +341,10 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(\n         &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n+        len: usize,\n+        additional: usize,\n     ) -> Result<(), TryReserveError> {\n-        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Exact { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n-        } else {\n-            Ok(())\n-        }\n+        if self.needs_to_grow(len, additional) { self.grow_exact(len, additional) } else { Ok(()) }\n     }\n \n     /// Shrinks the allocation down to the specified amount. If the given amount\n@@ -448,19 +366,11 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum Strategy {\n-    Double,\n-    Amortized { used_capacity: usize, needed_extra_capacity: usize },\n-    Exact { used_capacity: usize, needed_extra_capacity: usize },\n-}\n-use Strategy::*;\n-\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n-    fn needs_to_grow(&self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        needed_extra_capacity > self.capacity().wrapping_sub(used_capacity)\n+    fn needs_to_grow(&self, len: usize, additional: usize) -> bool {\n+        additional > self.capacity().wrapping_sub(len)\n     }\n \n     fn capacity_from_bytes(excess: usize) -> usize {\n@@ -469,72 +379,73 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     fn set_memory(&mut self, memory: MemoryBlock) {\n-        self.ptr = memory.ptr.cast().into();\n+        self.ptr = unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) };\n         self.cap = Self::capacity_from_bytes(memory.size);\n     }\n \n-    /// Single method to handle all possibilities of growing the buffer.\n-    fn grow(\n-        &mut self,\n-        strategy: Strategy,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n-    ) -> Result<(), TryReserveError> {\n-        let elem_size = mem::size_of::<T>();\n-        if elem_size == 0 {\n+    // This method is usually instantiated many times. So we want it to be as\n+    // small as possible, to improve compile times. But we also want as much of\n+    // its contents to be statically computable as possible, to make the\n+    // generated code run faster. Therefore, this method is carefully written\n+    // so that all of the code that depends on `T` is within it, while as much\n+    // of the code that doesn't depend on `T` as possible is in functions that\n+    // are non-generic over `T`.\n+    fn grow_amortized(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n+        // This is ensured by the calling contexts.\n+        debug_assert!(additional > 0);\n+\n+        if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow);\n         }\n-        let new_layout = match strategy {\n-            Double => unsafe {\n-                // Since we guarantee that we never allocate more than `isize::MAX` bytes,\n-                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow.\n-                // Additionally the alignment will never be too large as to \"not be satisfiable\",\n-                // so `Layout::from_size_align` will always return `Some`.\n-                //\n-                // TL;DR, we bypass runtime checks due to dynamic assertions in this module,\n-                // allowing us to use `from_size_align_unchecked`.\n-                let cap = if self.cap == 0 {\n-                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that would cause overflow.\n-                    if elem_size > usize::MAX / 8 { 1 } else { 4 }\n-                } else {\n-                    self.cap * 2\n-                };\n-                Layout::from_size_align_unchecked(cap * elem_size, mem::align_of::<T>())\n-            },\n-            Amortized { used_capacity, needed_extra_capacity } => {\n-                // Nothing we can really do about these checks, sadly.\n-                let required_cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-                let double_cap = self.cap * 2;\n-                // `double_cap` guarantees exponential growth.\n-                let cap = cmp::max(double_cap, required_cap);\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-            Exact { used_capacity, needed_extra_capacity } => {\n-                let cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-        };\n-        alloc_guard(new_layout.size())?;\n \n-        let memory = if let Some((ptr, old_layout)) = self.current_memory() {\n-            debug_assert_eq!(old_layout.align(), new_layout.align());\n-            unsafe {\n-                self.alloc\n-                    .grow(ptr, old_layout, new_layout.size(), placement, init)\n-                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-            }\n+        // Nothing we can really do about these checks, sadly.\n+        let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n+\n+        // This guarantees exponential growth. The doubling cannot overflow\n+        // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n+        let cap = cmp::max(self.cap * 2, required_cap);\n+\n+        // Tiny Vecs are dumb. Skip to:\n+        // - 8 if the element size is 1, because any heap allocators is likely\n+        //   to round up a request of less than 8 bytes to at least 8 bytes.\n+        // - 4 if elements are moderate-sized (<= 1 KiB).\n+        // - 1 otherwise, to avoid wasting too much space for very short Vecs.\n+        // Note that `min_non_zero_cap` is computed statically.\n+        let elem_size = mem::size_of::<T>();\n+        let min_non_zero_cap = if elem_size == 1 {\n+            8\n+        } else if elem_size <= 1024 {\n+            4\n         } else {\n-            match placement {\n-                MayMove => self.alloc.alloc(new_layout, init),\n-                InPlace => Err(AllocErr),\n-            }\n-            .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n+            1\n         };\n+        let cap = cmp::max(min_non_zero_cap, cap);\n+\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n+\n+    // The constraints on this method are much the same as those on\n+    // `grow_amortized`, but this method is usually instantiated less often so\n+    // it's less critical.\n+    fn grow_exact(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n+        if mem::size_of::<T>() == 0 {\n+            // Since we return a capacity of `usize::MAX` when the type size is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n+\n+        let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -562,30 +473,32 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, Global> {\n-    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n-    ///\n-    /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (See description of type for details.)\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `len` must be greater than or equal to the most recently requested capacity, and\n-    /// * `len` must be less than or equal to `self.capacity()`.\n-    ///\n-    /// Note, that the requested capacity and `self.capacity()` could differ, as\n-    /// an allocator could overallocate and return a greater memory block than requested.\n-    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n-        // Sanity-check one half of the safety requirement (we cannot check the other half).\n-        debug_assert!(\n-            len <= self.capacity(),\n-            \"`len` must be smaller than or equal to `self.capacity()`\"\n-        );\n-\n-        let me = ManuallyDrop::new(self);\n-        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n-        Box::from_raw(slice)\n+// This function is outside `RawVec` to minimize compile times. See the comment\n+// above `RawVec::grow_amortized` for details. (The `A` parameter isn't\n+// significant, because the number of different `A` types seen in practice is\n+// much smaller than the number of `T` types.)\n+fn finish_grow<A>(\n+    new_layout: Result<Layout, LayoutErr>,\n+    current_memory: Option<(NonNull<u8>, Layout)>,\n+    alloc: &mut A,\n+) -> Result<MemoryBlock, TryReserveError>\n+where\n+    A: AllocRef,\n+{\n+    // Check for the error here to minimize the size of `RawVec::grow_*`.\n+    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n+\n+    alloc_guard(new_layout.size())?;\n+\n+    let memory = if let Some((ptr, old_layout)) = current_memory {\n+        debug_assert_eq!(old_layout.align(), new_layout.align());\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), MayMove, Uninitialized) }\n+    } else {\n+        alloc.alloc(new_layout, Uninitialized)\n     }\n+    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n+\n+    Ok(memory)\n }\n \n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {"}, {"sha": "5408faa079c1532ee3462acb023416ffd9ef145e", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -12,7 +12,6 @@ fn allocator_param() {\n     //\n     // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n-\n     // storage.\n \n     // A dumb allocator that consumes a fixed amount of fuel\n@@ -35,7 +34,7 @@ fn allocator_param() {\n             }\n         }\n         unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-            Global.dealloc(ptr, layout)\n+            unsafe { Global.dealloc(ptr, layout) }\n         }\n     }\n \n@@ -59,7 +58,7 @@ fn reserve_does_not_overallocate() {\n         let mut v: RawVec<u32> = RawVec::new();\n         v.reserve(0, 7);\n         assert_eq!(7, v.capacity());\n-        // 97 if more than double of 7, so `reserve` should work\n+        // 97 is more than double of 7, so `reserve` should work\n         // like `reserve_exact`.\n         v.reserve(7, 90);\n         assert_eq!(97, v.capacity());"}, {"sha": "77ff567aa7af172c074b3c744f180900e77c326c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 128, "deletions": 114, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -245,13 +245,14 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{self, PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of_val_raw, forget, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n \n use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -279,7 +280,6 @@ struct RcBox<T: ?Sized> {\n /// type `T`.\n ///\n /// [get_mut]: #method.get_mut\n-#[cfg_attr(all(bootstrap, not(test)), lang = \"rc\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Rc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n@@ -304,7 +304,7 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n-        Self::from_inner(NonNull::new_unchecked(ptr))\n+        Self::from_inner(unsafe { NonNull::new_unchecked(ptr) })\n     }\n }\n \n@@ -324,11 +324,9 @@ impl<T> Rc<T> {\n         // pointers, which ensures that the weak destructor never frees\n         // the allocation while the strong destructor is running, even\n         // if the weak pointer is stored inside the strong one.\n-        Self::from_inner(Box::into_raw_non_null(box RcBox {\n-            strong: Cell::new(1),\n-            weak: Cell::new(1),\n-            value,\n-        }))\n+        Self::from_inner(\n+            Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),\n+        )\n     }\n \n     /// Constructs a new `Rc` with uninitialized contents.\n@@ -546,7 +544,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Rc<[T]> {\n-        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+        unsafe { Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _) }\n     }\n }\n \n@@ -582,8 +580,6 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n     /// let x = Rc::new(\"hello\".to_owned());\n@@ -592,20 +588,14 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(x_ptr, Rc::as_ptr(&y));\n     /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n-        let fake_ptr = ptr as *mut T;\n \n-        // SAFETY: This cannot go through Deref::deref.\n-        // Instead, we manually offset the pointer rather than manifesting a reference.\n-        // This is so that the returned pointer retains the same provenance as our pointer.\n-        // This is required so that e.g. `get_mut` can write through the pointer\n-        // after the Rc is recovered through `from_raw`.\n-        unsafe {\n-            let offset = data_offset(&(*ptr).value);\n-            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n-        }\n+        // SAFETY: This cannot go through Deref::deref or Rc::inner because\n+        // this is required to retain raw/mut provenance such that e.g. `get_mut` can\n+        // write through the pointer after the Rc is recovered through `from_raw`.\n+        unsafe { &raw const (*ptr).value }\n     }\n \n     /// Constructs an `Rc<T>` from a raw pointer.\n@@ -647,13 +637,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        let offset = data_offset(ptr);\n+        let offset = unsafe { data_offset(ptr) };\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n-        let rc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+        let rc_ptr = unsafe { set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset)) };\n \n-        Self::from_ptr(rc_ptr)\n+        unsafe { Self::from_ptr(rc_ptr) }\n     }\n \n     /// Consumes the `Rc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -662,6 +652,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// ```\n     /// #![feature(rc_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::rc::Rc;\n     ///\n@@ -671,6 +662,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(since = \"1.44.0\", reason = \"use `Rc::into_raw` instead\")]\n     #[inline]\n     pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n         // safe because Rc guarantees its pointer is non-null\n@@ -807,7 +799,7 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n-        &mut this.ptr.as_mut().value\n+        unsafe { &mut this.ptr.as_mut().value }\n     }\n \n     #[inline]\n@@ -966,20 +958,24 @@ impl<T: ?Sized> Rc<T> {\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(mem.ptr.as_ptr());\n-        debug_assert_eq!(Layout::for_value(&*inner), layout);\n+        unsafe {\n+            debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n-        ptr::write(&mut (*inner).strong, Cell::new(1));\n-        ptr::write(&mut (*inner).weak, Cell::new(1));\n+            ptr::write(&mut (*inner).strong, Cell::new(1));\n+            ptr::write(&mut (*inner).weak, Cell::new(1));\n+        }\n \n         inner\n     }\n \n     /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-            set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n+                set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n+            })\n+        }\n     }\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n@@ -1008,9 +1004,11 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-            ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n+                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n+            })\n+        }\n     }\n }\n \n@@ -1019,20 +1017,22 @@ impl<T> Rc<[T]> {\n /// For a slice/trait object, this sets the `data` field and leaves the rest\n /// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    unsafe {\n+        ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    }\n     ptr\n }\n \n impl<T> Rc<[T]> {\n-    /// Copy elements from slice into newly allocated Rc<[T]>\n+    /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n-        let ptr = Self::allocate_for_slice(v.len());\n-\n-        ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n-\n-        Self::from_ptr(ptr)\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(v.len());\n+            ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n+            Self::from_ptr(ptr)\n+        }\n     }\n \n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n@@ -1060,25 +1060,27 @@ impl<T> Rc<[T]> {\n             }\n         }\n \n-        let ptr = Self::allocate_for_slice(len);\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(len);\n \n-        let mem = ptr as *mut _ as *mut u8;\n-        let layout = Layout::for_value(&*ptr);\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n \n-        // Pointer to first element\n-        let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+            // Pointer to first element\n+            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n-        let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n+            let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n \n-        for (i, item) in iter.enumerate() {\n-            ptr::write(elems.add(i), item);\n-            guard.n_elems += 1;\n-        }\n+            for (i, item) in iter.enumerate() {\n+                ptr::write(elems.add(i), item);\n+                guard.n_elems += 1;\n+            }\n \n-        // All clear. Forget the guard so it doesn't free the new RcBox.\n-        forget(guard);\n+            // All clear. Forget the guard so it doesn't free the new RcBox.\n+            forget(guard);\n \n-        Self::from_ptr(ptr)\n+            Self::from_ptr(ptr)\n+        }\n     }\n }\n \n@@ -1222,6 +1224,12 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n     }\n }\n \n+// Hack to allow specializing on `Eq` even though `Eq` has a method.\n+#[rustc_unsafe_specialization_marker]\n+pub(crate) trait MarkerEq: PartialEq<Self> {}\n+\n+impl<T: Eq> MarkerEq for T {}\n+\n /// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n /// would otherwise add a cost to all equality checks on refs. We assume that `Rc`s are used to\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n@@ -1230,7 +1238,7 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n+impl<T: ?Sized + MarkerEq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         Rc::ptr_eq(self, other) || **self == **other\n@@ -1492,6 +1500,21 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     }\n }\n \n+#[stable(feature = \"shared_from_cow\", since = \"1.45.0\")]\n+impl<'a, B> From<Cow<'a, B>> for Rc<B>\n+where\n+    B: ToOwned + ?Sized,\n+    Rc<B>: From<&'a B> + From<B::Owned>,\n+{\n+    #[inline]\n+    fn from(cow: Cow<'a, B>) -> Rc<B> {\n+        match cow {\n+            Cow::Borrowed(s) => Rc::from(s),\n+            Cow::Owned(s) => Rc::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]>\n where\n@@ -1549,25 +1572,25 @@ impl<T> iter::FromIterator<T> for Rc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        RcFromIter::from_iter(iter.into_iter())\n+        ToRcSlice::to_rc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Rc<[T]>`.\n-trait RcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToRcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_rc_slice(self) -> Rc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToRcSlice<T> for I {\n+    default fn to_rc_slice(self) -> Rc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n+    fn to_rc_slice(self) -> Rc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -1578,29 +1601,15 @@ impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Rc::from_iter_exact(iter, low)\n+                Rc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1632,6 +1641,7 @@ pub struct Weak<T: ?Sized> {\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n     // to allocate space on the heap.  That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n+    // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<RcBox<T>>,\n }\n \n@@ -1674,8 +1684,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::Rc;\n     /// use std::ptr;\n     ///\n@@ -1693,11 +1701,20 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"rc_as_ptr\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n-        let offset = data_offset_sized::<T>();\n-        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n-        ptr as *const T\n+        let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);\n+\n+        // SAFETY: we must offset the pointer manually, and said pointer may be\n+        // a dangling weak (usize::MAX) if T is sized. data_offset is safe to call,\n+        // because we know that a pointer to unsized T was derived from a real\n+        // unsized T, as dangling weaks are only created for sized T. wrapping_offset\n+        // is used so that we can use the same code path for the non-dangling\n+        // unsized case and the potentially dangling sized case.\n+        unsafe {\n+            let offset = data_offset(ptr as *mut T);\n+            set_data_ptr(ptr as *mut T, (ptr as *mut u8).wrapping_offset(offset))\n+        }\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1711,8 +1728,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n@@ -1728,7 +1743,7 @@ impl<T> Weak<T> {\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n         mem::forget(self);\n@@ -1755,8 +1770,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n@@ -1781,16 +1794,18 @@ impl<T> Weak<T> {\n     /// [`Weak`]: struct.Weak.html\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n             Self::new()\n         } else {\n             // See Rc::from_raw for details\n-            let offset = data_offset(ptr);\n-            let fake_ptr = ptr as *mut RcBox<T>;\n-            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-            Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            unsafe {\n+                let offset = data_offset(ptr);\n+                let fake_ptr = ptr as *mut RcBox<T>;\n+                let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+                Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            }\n         }\n     }\n }\n@@ -2035,10 +2050,8 @@ trait RcBoxPtr<T: ?Sized> {\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if strong == 0 || strong == usize::max_value() {\n-            unsafe {\n-                abort();\n-            }\n+        if strong == 0 || strong == usize::MAX {\n+            abort();\n         }\n         self.inner().strong.set(strong + 1);\n     }\n@@ -2061,10 +2074,8 @@ trait RcBoxPtr<T: ?Sized> {\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if weak == 0 || weak == usize::max_value() {\n-            unsafe {\n-                abort();\n-            }\n+        if weak == 0 || weak == usize::MAX {\n+            abort();\n         }\n         self.inner().weak.set(weak + 1);\n     }\n@@ -2106,19 +2117,22 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> {}\n \n+/// Get the offset within an `ArcInner` for\n+/// a payload of type described by a pointer.\n+///\n+/// # Safety\n+///\n+/// This has the same safety requirements as `align_of_val_raw`. In effect:\n+///\n+/// - This function is safe for any argument if `T` is sized, and\n+/// - if `T` is unsized, the pointer must have appropriate pointer metadata\n+///   aquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `RcBox`.\n     // Because it is ?Sized, it will always be the last field in memory.\n     // Note: This is a detail of the current implementation of the compiler,\n     // and is not a guaranteed language detail. Do not rely on it outside of std.\n-    data_offset_align(align_of_val(&*ptr))\n-}\n-\n-/// Computes the offset of the data field within `RcBox`.\n-///\n-/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n-fn data_offset_sized<T>() -> isize {\n-    data_offset_align(align_of::<T>())\n+    unsafe { data_offset_align(align_of_val_raw(ptr)) }\n }\n \n #[inline]"}, {"sha": "e88385faf4fd4c57283645cf2a25adfe33c71933", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -407,14 +407,14 @@ fn test_from_vec() {\n fn test_downcast() {\n     use std::any::Any;\n \n-    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r1: Rc<dyn Any> = Rc::new(i32::MAX);\n     let r2: Rc<dyn Any> = Rc::new(\"abc\");\n \n     assert!(r1.clone().downcast::<u32>().is_err());\n \n     let r1i32 = r1.downcast::<i32>();\n     assert!(r1i32.is_ok());\n-    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::MAX));\n \n     assert!(r2.clone().downcast::<i32>().is_err());\n "}, {"sha": "3d51115fe01d3ab161d242f5a0ac968d74be7cbf", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -136,8 +136,6 @@ pub use hack::to_vec;\n // `test_permutations` test\n mod hack {\n     use crate::boxed::Box;\n-    #[cfg(test)]\n-    use crate::string::ToString;\n     use crate::vec::Vec;\n \n     // We shouldn't add inline attribute to this since this is used in\n@@ -156,9 +154,9 @@ mod hack {\n     where\n         T: Clone,\n     {\n-        let mut vector = Vec::with_capacity(s.len());\n-        vector.extend_from_slice(s);\n-        vector\n+        let mut vec = Vec::with_capacity(s.len());\n+        vec.extend_from_slice(s);\n+        vec\n     }\n }\n \n@@ -831,8 +829,7 @@ where\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n-    let v_mid = v.add(mid);\n-    let v_end = v.add(len);\n+    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n \n     // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n     // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n@@ -855,8 +852,10 @@ where\n \n     if mid <= len - mid {\n         // The left run is shorter.\n-        ptr::copy_nonoverlapping(v, buf, mid);\n-        hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n+        unsafe {\n+            ptr::copy_nonoverlapping(v, buf, mid);\n+            hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n+        }\n \n         // Initially, these pointers point to the beginnings of their arrays.\n         let left = &mut hole.start;\n@@ -866,17 +865,21 @@ where\n         while *left < hole.end && right < v_end {\n             // Consume the lesser side.\n             // If equal, prefer the left run to maintain stability.\n-            let to_copy = if is_less(&*right, &**left) {\n-                get_and_increment(&mut right)\n-            } else {\n-                get_and_increment(left)\n-            };\n-            ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+            unsafe {\n+                let to_copy = if is_less(&*right, &**left) {\n+                    get_and_increment(&mut right)\n+                } else {\n+                    get_and_increment(left)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+            }\n         }\n     } else {\n         // The right run is shorter.\n-        ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-        hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n+        unsafe {\n+            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n+            hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n+        }\n \n         // Initially, these pointers point past the ends of their arrays.\n         let left = &mut hole.dest;\n@@ -886,25 +889,27 @@ where\n         while v < *left && buf < *right {\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n-            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n-                decrement_and_get(left)\n-            } else {\n-                decrement_and_get(right)\n-            };\n-            ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+            unsafe {\n+                let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n+                    decrement_and_get(left)\n+                } else {\n+                    decrement_and_get(right)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+            }\n         }\n     }\n     // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n     // it will now be copied into the hole in `v`.\n \n     unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n         let old = *ptr;\n-        *ptr = ptr.offset(1);\n+        *ptr = unsafe { ptr.offset(1) };\n         old\n     }\n \n     unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        *ptr = ptr.offset(-1);\n+        *ptr = unsafe { ptr.offset(-1) };\n         *ptr\n     }\n "}, {"sha": "57927c688479b5f72746d6220b271f58dd2c7e41", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -583,5 +583,5 @@ impl str {\n #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n #[inline]\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n-    Box::from_raw(Box::into_raw(v) as *mut str)\n+    unsafe { Box::from_raw(Box::into_raw(v) as *mut str) }\n }"}, {"sha": "5b671b41b5bf673f12f5d27ad9d4d3e6ede22db6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -278,6 +278,7 @@ use crate::vec::Vec;\n /// [`Deref`]: ../../std/ops/trait.Deref.html\n /// [`as_str()`]: struct.String.html#method.as_str\n #[derive(PartialOrd, Eq, Ord)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"string_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n     vec: Vec<u8>,\n@@ -723,7 +724,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n-        String { vec: Vec::from_raw_parts(buf, length, capacity) }\n+        unsafe { String { vec: Vec::from_raw_parts(buf, length, capacity) } }\n     }\n \n     /// Converts a vector of bytes to a `String` without checking that the\n@@ -1328,9 +1329,11 @@ impl String {\n         let amt = bytes.len();\n         self.vec.reserve(amt);\n \n-        ptr::copy(self.vec.as_ptr().add(idx), self.vec.as_mut_ptr().add(idx + amt), len - idx);\n-        ptr::copy(bytes.as_ptr(), self.vec.as_mut_ptr().add(idx), amt);\n-        self.vec.set_len(len + amt);\n+        unsafe {\n+            ptr::copy(self.vec.as_ptr().add(idx), self.vec.as_mut_ptr().add(idx + amt), len - idx);\n+            ptr::copy(bytes.as_ptr(), self.vec.as_mut_ptr().add(idx), amt);\n+            self.vec.set_len(len + amt);\n+        }\n     }\n \n     /// Inserts a string slice into this `String` at a byte position.\n@@ -1771,6 +1774,15 @@ impl FromIterator<String> for String {\n     }\n }\n \n+#[stable(feature = \"box_str2\", since = \"1.45.0\")]\n+impl FromIterator<Box<str>> for String {\n+    fn from_iter<I: IntoIterator<Item = Box<str>>>(iter: I) -> String {\n+        let mut buf = String::new();\n+        buf.extend(iter);\n+        buf\n+    }\n+}\n+\n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> FromIterator<Cow<'a, str>> for String {\n     fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n@@ -1798,34 +1810,76 @@ impl Extend<char> for String {\n         self.reserve(lower_bound);\n         iterator.for_each(move |c| self.push(c));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, c: char) {\n+        self.push(c);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a> Extend<&'a char> for String {\n     fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &c: &'a char) {\n+        self.push(c);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: &'a str) {\n+        self.push_str(s);\n+    }\n+}\n+\n+#[stable(feature = \"box_str2\", since = \"1.45.0\")]\n+impl Extend<Box<str>> for String {\n+    fn extend<I: IntoIterator<Item = Box<str>>>(&mut self, iter: I) {\n+        iter.into_iter().for_each(move |s| self.push_str(&s));\n+    }\n }\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: String) {\n+        self.push_str(&s);\n+    }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> Extend<Cow<'a, str>> for String {\n     fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: Cow<'a, str>) {\n+        self.push_str(&s);\n+    }\n }\n \n /// A convenience impl that delegates to the impl for `&str`.\n@@ -2192,6 +2246,14 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n+#[stable(feature = \"char_to_string_specialization\", since = \"1.46.0\")]\n+impl ToString for char {\n+    #[inline]\n+    fn to_string(&self) -> String {\n+        String::from(self.encode_utf8(&mut [0; 4]))\n+    }\n+}\n+\n #[stable(feature = \"str_to_string_specialization\", since = \"1.9.0\")]\n impl ToString for str {\n     #[inline]\n@@ -2472,3 +2534,11 @@ impl DoubleEndedIterator for Drain<'_> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for Drain<'_> {}\n+\n+#[stable(feature = \"from_char_for_string\", since = \"1.46.0\")]\n+impl From<char> for String {\n+    #[inline]\n+    fn from(c: char) -> Self {\n+        c.to_string()\n+    }\n+}"}, {"sha": "0053a54f20346cbc0408011e13ce4a89e5ba67f5", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 224, "deletions": 122, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -16,15 +16,16 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of, align_of_val, size_of_val};\n+use core::mem::{self, align_of_val, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;\n@@ -207,7 +208,6 @@ macro_rules! acquire {\n /// counting in general.\n ///\n /// [rc_examples]: ../../std/rc/index.html#examples\n-#[cfg_attr(all(bootstrap, not(test)), lang = \"arc\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Arc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n@@ -232,7 +232,7 @@ impl<T: ?Sized> Arc<T> {\n     }\n \n     unsafe fn from_ptr(ptr: *mut ArcInner<T>) -> Self {\n-        Self::from_inner(NonNull::new_unchecked(ptr))\n+        unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }\n     }\n }\n \n@@ -267,6 +267,7 @@ pub struct Weak<T: ?Sized> {\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n     // to allocate space on the heap.  That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n+    // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<ArcInner<T>>,\n }\n \n@@ -325,7 +326,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         };\n-        Self::from_inner(Box::into_raw_non_null(x))\n+        Self::from_inner(Box::leak(x).into())\n     }\n \n     /// Constructs a new `Arc` with uninitialized contents.\n@@ -418,8 +419,7 @@ impl<T> Arc<T> {\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n-        // See `drop` for why all these atomics are like this\n-        if this.inner().strong.compare_exchange(1, 0, Release, Relaxed).is_err() {\n+        if this.inner().strong.compare_exchange(1, 0, Relaxed, Relaxed).is_err() {\n             return Err(this);\n         }\n \n@@ -543,7 +543,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Arc<[T]> {\n-        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+        unsafe { Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _) }\n     }\n }\n \n@@ -579,8 +579,6 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let x = Arc::new(\"hello\".to_owned());\n@@ -589,20 +587,14 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(x_ptr, Arc::as_ptr(&y));\n     /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"rc_as_ptr\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n-        let fake_ptr = ptr as *mut T;\n \n-        // SAFETY: This cannot go through Deref::deref.\n-        // Instead, we manually offset the pointer rather than manifesting a reference.\n-        // This is so that the returned pointer retains the same provenance as our pointer.\n-        // This is required so that e.g. `get_mut` can write through the pointer\n-        // after the Arc is recovered through `from_raw`.\n-        unsafe {\n-            let offset = data_offset(&(*ptr).data);\n-            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n-        }\n+        // SAFETY: This cannot go through Deref::deref or RcBoxPtr::inner because\n+        // this is required to retain raw/mut provenance such that e.g. `get_mut` can\n+        // write through the pointer after the Rc is recovered through `from_raw`.\n+        unsafe { &raw const (*ptr).data }\n     }\n \n     /// Constructs an `Arc<T>` from a raw pointer.\n@@ -644,13 +636,15 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        let offset = data_offset(ptr);\n+        unsafe {\n+            let offset = data_offset(ptr);\n \n-        // Reverse the offset to find the original ArcInner.\n-        let fake_ptr = ptr as *mut ArcInner<T>;\n-        let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            // Reverse the offset to find the original ArcInner.\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n-        Self::from_ptr(arc_ptr)\n+            Self::from_ptr(arc_ptr)\n+        }\n     }\n \n     /// Consumes the `Arc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -659,6 +653,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// ```\n     /// #![feature(rc_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::sync::Arc;\n     ///\n@@ -668,6 +663,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(since = \"1.44.0\", reason = \"use `Arc::into_raw` instead\")]\n     #[inline]\n     pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n         // safe because Arc guarantees its pointer is non-null\n@@ -775,6 +771,81 @@ impl<T: ?Sized> Arc<T> {\n         this.inner().strong.load(SeqCst)\n     }\n \n+    /// Increments the strong reference count on the `Arc<T>` associated with the\n+    /// provided pointer by one.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must have been obtained through `Arc::into_raw`, and the\n+    /// associated `Arc` instance must be valid (i.e. the strong count must be at\n+    /// least 1) for the duration of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_mutate_strong_count)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// unsafe {\n+    ///     let ptr = Arc::into_raw(five);\n+    ///     Arc::incr_strong_count(ptr);\n+    ///\n+    ///     // This assertion is deterministic because we haven't shared\n+    ///     // the `Arc` between threads.\n+    ///     let five = Arc::from_raw(ptr);\n+    ///     assert_eq!(2, Arc::strong_count(&five));\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_mutate_strong_count\", issue = \"71983\")]\n+    pub unsafe fn incr_strong_count(ptr: *const T) {\n+        // Retain Arc, but don't touch refcount by wrapping in ManuallyDrop\n+        let arc = unsafe { mem::ManuallyDrop::new(Arc::<T>::from_raw(ptr)) };\n+        // Now increase refcount, but don't drop new refcount either\n+        let _arc_clone: mem::ManuallyDrop<_> = arc.clone();\n+    }\n+\n+    /// Decrements the strong reference count on the `Arc<T>` associated with the\n+    /// provided pointer by one.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must have been obtained through `Arc::into_raw`, and the\n+    /// associated `Arc` instance must be valid (i.e. the strong count must be at\n+    /// least 1) when invoking this method. This method can be used to release the final\n+    /// `Arc` and backing storage, but **should not** be called after the final `Arc` has been\n+    /// released.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_mutate_strong_count)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// unsafe {\n+    ///     let ptr = Arc::into_raw(five);\n+    ///     Arc::incr_strong_count(ptr);\n+    ///\n+    ///     // Those assertions are deterministic because we haven't shared\n+    ///     // the `Arc` between threads.\n+    ///     let five = Arc::from_raw(ptr);\n+    ///     assert_eq!(2, Arc::strong_count(&five));\n+    ///     Arc::decr_strong_count(ptr);\n+    ///     assert_eq!(1, Arc::strong_count(&five));\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_mutate_strong_count\", issue = \"71983\")]\n+    pub unsafe fn decr_strong_count(ptr: *const T) {\n+        unsafe { mem::drop(Arc::from_raw(ptr)) };\n+    }\n+\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // This unsafety is ok because while this arc is alive we're guaranteed\n@@ -790,12 +861,10 @@ impl<T: ?Sized> Arc<T> {\n     unsafe fn drop_slow(&mut self) {\n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n+        unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };\n \n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            acquire!(self.inner().weak);\n-            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n-        }\n+        // Drop the weak ref collectively held by all strong references\n+        drop(Weak { ptr: self.ptr });\n     }\n \n     #[inline]\n@@ -844,20 +913,24 @@ impl<T: ?Sized> Arc<T> {\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(mem.ptr.as_ptr());\n-        debug_assert_eq!(Layout::for_value(&*inner), layout);\n+        debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);\n \n-        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n-        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+        unsafe {\n+            ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+        }\n \n         inner\n     }\n \n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-            set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n+                set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n+            })\n+        }\n     }\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n@@ -886,9 +959,11 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-            ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n-        })\n+        unsafe {\n+            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n+                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n+            })\n+        }\n     }\n }\n \n@@ -897,20 +972,24 @@ impl<T> Arc<[T]> {\n /// For a slice/trait object, this sets the `data` field and leaves the rest\n /// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    unsafe {\n+        ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    }\n     ptr\n }\n \n impl<T> Arc<[T]> {\n-    /// Copy elements from slice into newly allocated Arc<[T]>\n+    /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n-        let ptr = Self::allocate_for_slice(v.len());\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(v.len());\n \n-        ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n+            ptr::copy_nonoverlapping(v.as_ptr(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n \n-        Self::from_ptr(ptr)\n+            Self::from_ptr(ptr)\n+        }\n     }\n \n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n@@ -938,25 +1017,27 @@ impl<T> Arc<[T]> {\n             }\n         }\n \n-        let ptr = Self::allocate_for_slice(len);\n+        unsafe {\n+            let ptr = Self::allocate_for_slice(len);\n \n-        let mem = ptr as *mut _ as *mut u8;\n-        let layout = Layout::for_value(&*ptr);\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n \n-        // Pointer to first element\n-        let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+            // Pointer to first element\n+            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n-        let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n+            let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };\n \n-        for (i, item) in iter.enumerate() {\n-            ptr::write(elems.add(i), item);\n-            guard.n_elems += 1;\n-        }\n+            for (i, item) in iter.enumerate() {\n+                ptr::write(elems.add(i), item);\n+                guard.n_elems += 1;\n+            }\n \n-        // All clear. Forget the guard so it doesn't free the new ArcInner.\n-        mem::forget(guard);\n+            // All clear. Forget the guard so it doesn't free the new ArcInner.\n+            mem::forget(guard);\n \n-        Self::from_ptr(ptr)\n+            Self::from_ptr(ptr)\n+        }\n     }\n }\n \n@@ -1020,9 +1101,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // We abort because such a program is incredibly degenerate, and we\n         // don't care to support it.\n         if old_size > MAX_REFCOUNT {\n-            unsafe {\n-                abort();\n-            }\n+            abort();\n         }\n \n         Self::from_inner(self.ptr)\n@@ -1125,7 +1204,7 @@ impl<T: Clone> Arc<T> {\n \n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n-        unsafe { &mut this.ptr.as_mut().data }\n+        unsafe { Self::get_mut_unchecked(this) }\n     }\n }\n \n@@ -1201,7 +1280,9 @@ impl<T: ?Sized> Arc<T> {\n     #[inline]\n     #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n-        &mut this.ptr.as_mut().data\n+        // We are careful to *not* create a reference covering the \"count\" fields, as\n+        // this would alias with concurrent access to the reference counts (e.g. by `Weak`).\n+        unsafe { &mut (*this.ptr.as_ptr()).data }\n     }\n \n     /// Determine whether this is the unique reference (including weak refs) to\n@@ -1370,8 +1451,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::Arc;\n     /// use std::ptr;\n     ///\n@@ -1389,11 +1468,20 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n-        let offset = data_offset_sized::<T>();\n-        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n-        ptr as *const T\n+        let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);\n+\n+        // SAFETY: we must offset the pointer manually, and said pointer may be\n+        // a dangling weak (usize::MAX) if T is sized. data_offset is safe to call,\n+        // because we know that a pointer to unsized T was derived from a real\n+        // unsized T, as dangling weaks are only created for sized T. wrapping_offset\n+        // is used so that we can use the same code path for the non-dangling\n+        // unsized case and the potentially dangling sized case.\n+        unsafe {\n+            let offset = data_offset(ptr as *mut T);\n+            set_data_ptr(ptr as *mut T, (ptr as *mut u8).wrapping_offset(offset))\n+        }\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1407,8 +1495,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n@@ -1424,7 +1510,7 @@ impl<T> Weak<T> {\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n         mem::forget(self);\n@@ -1452,8 +1538,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n@@ -1478,20 +1562,29 @@ impl<T> Weak<T> {\n     /// [`Weak`]: struct.Weak.html\n     /// [`Arc`]: struct.Arc.html\n     /// [`forget`]: ../../std/mem/fn.forget.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n             Self::new()\n         } else {\n             // See Arc::from_raw for details\n-            let offset = data_offset(ptr);\n-            let fake_ptr = ptr as *mut ArcInner<T>;\n-            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-            Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            unsafe {\n+                let offset = data_offset(ptr);\n+                let fake_ptr = ptr as *mut ArcInner<T>;\n+                let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+                Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n+            }\n         }\n     }\n }\n \n+/// Helper type to allow accessing the reference counts without\n+/// making any assertions about the data field.\n+struct WeakInner<'a> {\n+    weak: &'a atomic::AtomicUsize,\n+    strong: &'a atomic::AtomicUsize,\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n     /// dropping of the inner value if successful.\n@@ -1538,9 +1631,7 @@ impl<T: ?Sized> Weak<T> {\n \n             // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n             if n > MAX_REFCOUNT {\n-                unsafe {\n-                    abort();\n-                }\n+                abort();\n             }\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n@@ -1597,8 +1688,18 @@ impl<T: ?Sized> Weak<T> {\n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n-    fn inner(&self) -> Option<&ArcInner<T>> {\n-        if is_dangling(self.ptr) { None } else { Some(unsafe { self.ptr.as_ref() }) }\n+    fn inner(&self) -> Option<WeakInner<'_>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            // We are careful to *not* create a reference covering the \"data\" field, as\n+            // the field may be mutated concurrently (for example, if the last `Arc`\n+            // is dropped, the data field will be dropped in-place).\n+            Some(unsafe {\n+                let ptr = self.ptr.as_ptr();\n+                WeakInner { strong: &(*ptr).strong, weak: &(*ptr).weak }\n+            })\n+        }\n     }\n \n     /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n@@ -1677,9 +1778,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n         // See comments in Arc::clone() for why we do this (for mem::forget).\n         if old_size > MAX_REFCOUNT {\n-            unsafe {\n-                abort();\n-            }\n+            abort();\n         }\n \n         Weak { ptr: self.ptr }\n@@ -1778,7 +1877,7 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n+impl<T: ?Sized + crate::rc::MarkerEq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n     fn eq(&self, other: &Arc<T>) -> bool {\n         Arc::ptr_eq(self, other) || **self == **other\n@@ -2047,6 +2146,21 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     }\n }\n \n+#[stable(feature = \"shared_from_cow\", since = \"1.45.0\")]\n+impl<'a, B> From<Cow<'a, B>> for Arc<B>\n+where\n+    B: ToOwned + ?Sized,\n+    Arc<B>: From<&'a B> + From<B::Owned>,\n+{\n+    #[inline]\n+    fn from(cow: Cow<'a, B>) -> Arc<B> {\n+        match cow {\n+            Cow::Borrowed(s) => Arc::from(s),\n+            Cow::Owned(s) => Arc::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]>\n where\n@@ -2104,25 +2218,25 @@ impl<T> iter::FromIterator<T> for Arc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        ArcFromIter::from_iter(iter.into_iter())\n+        ToArcSlice::to_arc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Arc<[T]>`.\n-trait ArcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToArcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_arc_slice(self) -> Arc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToArcSlice<T> for I {\n+    default fn to_arc_slice(self) -> Arc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToArcSlice<T> for I {\n+    fn to_arc_slice(self) -> Arc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -2133,29 +2247,15 @@ impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Arc::from_iter_exact(iter, low)\n+                Arc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Arc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n     fn borrow(&self) -> &T {\n@@ -2173,20 +2273,22 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> {}\n \n-/// Computes the offset of the data field within `ArcInner`.\n+/// Get the offset within an `ArcInner` for\n+/// a payload of type described by a pointer.\n+///\n+/// # Safety\n+///\n+/// This has the same safety requirements as `align_of_val_raw`. In effect:\n+///\n+/// - This function is safe for any argument if `T` is sized, and\n+/// - if `T` is unsized, the pointer must have appropriate pointer metadata\n+///   aquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `ArcInner`.\n     // Because it is `?Sized`, it will always be the last field in memory.\n     // Note: This is a detail of the current implementation of the compiler,\n     // and is not a guaranteed language detail. Do not rely on it outside of std.\n-    data_offset_align(align_of_val(&*ptr))\n-}\n-\n-/// Computes the offset of the data field within `ArcInner`.\n-///\n-/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n-fn data_offset_sized<T>() -> isize {\n-    data_offset_align(align_of::<T>())\n+    unsafe { data_offset_align(align_of_val(&*ptr)) }\n }\n \n #[inline]"}, {"sha": "6f08cd7f123be67c2d036e615f2a5286da21f493", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -32,7 +32,6 @@ impl Drop for Canary {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn manually_share_arc() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = Arc::new(v);\n@@ -337,12 +336,13 @@ fn test_ptr_eq() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_weak_count_locked() {\n     let mut a = Arc::new(atomic::AtomicBool::new(false));\n     let a2 = a.clone();\n     let t = thread::spawn(move || {\n-        for _i in 0..1000000 {\n+        // Miri is too slow\n+        let count = if cfg!(miri) { 1000 } else { 1000000 };\n+        for _i in 0..count {\n             Arc::get_mut(&mut a);\n         }\n         a.store(true, SeqCst);\n@@ -351,6 +351,8 @@ fn test_weak_count_locked() {\n     while !a2.load(SeqCst) {\n         let n = Arc::weak_count(&a2);\n         assert!(n < 2, \"bad weak count: {}\", n);\n+        #[cfg(miri)] // Miri's scheduler does not guarantee liveness, and thus needs this hint.\n+        atomic::spin_loop_hint();\n     }\n     t.join().unwrap();\n }\n@@ -463,14 +465,14 @@ fn test_from_vec() {\n fn test_downcast() {\n     use std::any::Any;\n \n-    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::MAX);\n     let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n \n     assert!(r1.clone().downcast::<u32>().is_err());\n \n     let r1i32 = r1.downcast::<i32>();\n     assert!(r1i32.is_ok());\n-    assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+    assert_eq!(r1i32.unwrap(), Arc::new(i32::MAX));\n \n     assert!(r2.clone().downcast::<i32>().is_err());\n "}, {"sha": "0d1cc99df47c552e24bccd7b7e22bd63b7ddd352", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -1,6 +1,6 @@\n #![unstable(feature = \"wake_trait\", issue = \"69912\")]\n //! Types and Traits for working with asynchronous tasks.\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::ManuallyDrop;\n use core::task::{RawWaker, RawWakerVTable, Waker};\n \n use crate::sync::Arc;\n@@ -60,26 +60,29 @@ impl<W: Wake + Send + Sync + 'static> From<Arc<W>> for RawWaker {\n fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n     // Increment the reference count of the arc to clone it.\n     unsafe fn clone_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) -> RawWaker {\n-        let waker: Arc<W> = Arc::from_raw(waker as *const W);\n-        mem::forget(Arc::clone(&waker));\n-        raw_waker(waker)\n+        unsafe { Arc::incr_strong_count(waker as *const W) };\n+        RawWaker::new(\n+            waker as *const (),\n+            &RawWakerVTable::new(clone_waker::<W>, wake::<W>, wake_by_ref::<W>, drop_waker::<W>),\n+        )\n     }\n \n     // Wake by value, moving the Arc into the Wake::wake function\n     unsafe fn wake<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        let waker: Arc<W> = Arc::from_raw(waker as *const W);\n+        let waker: Arc<W> = unsafe { Arc::from_raw(waker as *const W) };\n         <W as Wake>::wake(waker);\n     }\n \n     // Wake by reference, wrap the waker in ManuallyDrop to avoid dropping it\n     unsafe fn wake_by_ref<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        let waker: ManuallyDrop<Arc<W>> = ManuallyDrop::new(Arc::from_raw(waker as *const W));\n+        let waker: ManuallyDrop<Arc<W>> =\n+            unsafe { ManuallyDrop::new(Arc::from_raw(waker as *const W)) };\n         <W as Wake>::wake_by_ref(&waker);\n     }\n \n     // Decrement the reference count of the Arc on drop\n     unsafe fn drop_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        mem::drop(Arc::from_raw(waker as *const W));\n+        unsafe { Arc::decr_strong_count(waker as *const W) };\n     }\n \n     RawWaker::new("}, {"sha": "62084ccf53c5929f78edcd6c7e1dff45ea614de4", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -372,6 +372,14 @@ fn assert_covariance() {\n     }\n }\n \n+#[test]\n+fn test_retain() {\n+    let mut a = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    a.retain(|x| x % 2 == 0);\n+\n+    assert_eq!(a.into_sorted_vec(), [-10, 2, 4])\n+}\n+\n // old binaryheap failed this test\n //\n // Integrity means that all elements are present after a comparison panics,\n@@ -409,16 +417,14 @@ fn panic_safe() {\n     }\n     let mut rng = thread_rng();\n     const DATASZ: usize = 32;\n-    #[cfg(not(miri))] // Miri is too slow\n-    const NTEST: usize = 10;\n-    #[cfg(miri)]\n-    const NTEST: usize = 1;\n+    // Miri is too slow\n+    let ntest = if cfg!(miri) { 1 } else { 10 };\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n     let data = (1..=DATASZ).collect::<Vec<_>>();\n \n     // since it's a fuzzy test, run several tries.\n-    for _ in 0..NTEST {\n+    for _ in 0..ntest {\n         for i in 1..=DATASZ {\n             DROP_COUNTER.store(0, Ordering::SeqCst);\n "}, {"sha": "8bfcf323f674a74c610038a96cb1ed3beb9b473d", "filename": "src/liballoc/tests/borrow.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fborrow.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -0,0 +1,47 @@\n+use std::borrow::{Cow, ToOwned};\n+use std::ffi::{CStr, OsStr};\n+use std::path::Path;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+macro_rules! test_from_cow {\n+    ($value:ident => $($ty:ty),+) => {$(\n+        let borrowed = <$ty>::from(Cow::Borrowed($value));\n+        let owned = <$ty>::from(Cow::Owned($value.to_owned()));\n+        assert_eq!($value, &*borrowed);\n+        assert_eq!($value, &*owned);\n+    )+};\n+    ($value:ident : & $ty:ty) => {\n+        test_from_cow!($value => Box<$ty>, Rc<$ty>, Arc<$ty>);\n+    }\n+}\n+\n+#[test]\n+fn test_from_cow_slice() {\n+    let slice: &[i32] = &[1, 2, 3];\n+    test_from_cow!(slice: &[i32]);\n+}\n+\n+#[test]\n+fn test_from_cow_str() {\n+    let string = \"hello\";\n+    test_from_cow!(string: &str);\n+}\n+\n+#[test]\n+fn test_from_cow_c_str() {\n+    let string = CStr::from_bytes_with_nul(b\"hello\\0\").unwrap();\n+    test_from_cow!(string: &CStr);\n+}\n+\n+#[test]\n+fn test_from_cow_os_str() {\n+    let string = OsStr::new(\"hello\");\n+    test_from_cow!(string: &OsStr);\n+}\n+\n+#[test]\n+fn test_from_cow_path() {\n+    let path = Path::new(\"hello\");\n+    test_from_cow!(path: &Path);\n+}"}, {"sha": "5377485da8f3b7def467ee749689494cd6399b72", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8", "patch": "@@ -16,3 +16,36 @@ fn unitialized_zero_size_box() {\n         NonNull::<MaybeUninit<String>>::dangling().as_ptr(),\n     );\n }\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct Dummy {\n+    _data: u8,\n+}\n+\n+#[test]\n+fn box_clone_and_clone_from_equivalence() {\n+    for size in (0..8).map(|i| 2usize.pow(i)) {\n+        let control = vec![Dummy { _data: 42 }; size].into_boxed_slice();\n+        let clone = control.clone();\n+        let mut copy = vec![Dummy { _data: 84 }; size].into_boxed_slice();\n+        copy.clone_from(&control);\n+        assert_eq!(control, clone);\n+        assert_eq!(control, copy);\n+    }\n+}\n+\n+/// This test might give a false positive in case the box realocates, but the alocator keeps the\n+/// original pointer.\n+///\n+/// On the other hand it won't give a false negative, if it fails than the memory was definitly not\n+/// reused\n+#[test]\n+fn box_clone_from_ptr_stability() {\n+    for size in (0..8).map(|i| 2usize.pow(i)) {\n+        let control = vec![Dummy { _data: 42 }; size].into_boxed_slice();\n+        let mut copy = vec![Dummy { _data: 84 }; size].into_boxed_slice();\n+        let copy_raw = copy.as_ptr() as usize;\n+        copy.clone_from(&control);\n+        assert_eq!(copy.as_ptr() as usize, copy_raw);\n+    }\n+}"}, {"sha": "f66b5814ca0d43aa5cae4d0d651403d0b7b59a26", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "b6c34b7c6c346dae023617482ffba7cbff6917d7", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "e2dc816b0152647b89036796158a56c35ce3d024", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "75b76bb73ed9e83c327f949c833fb5f9f4022ca9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "eee98d45340429f4f759f8bee607e8bd0ca2f5da", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "d38655af78cb79175e95fd294f28584f71f6f94f", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "ffff543b07fe52cb79ecfa0209b5bddc741beaad", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 179, "deletions": 25, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "762dc4be44d6208950d4bd03e2fba8de66c45fcc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "5db96a504a6a69a1a72c1181464d92a5b7f40e12", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 140, "deletions": 79, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "5158aab8b7dc5c21cca20080e6ffd0f3e374ba17", "filename": "src/libarena/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db"}, {"sha": "0f0bd617f439c6cd8491b57addf70682e2582936", "filename": "src/libarena/lib.rs", "status": "removed", "additions": 0, "deletions": 674, "changes": 674, "blob_url": "https://github.com/rust-lang/rust/blob/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ae4c7345cfd06b06c6996536d7c158ce6970db/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e3ae4c7345cfd06b06c6996536d7c158ce6970db"}, {"sha": "42c555cafac86f187ddeb681fe62eecf85e86c9d", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "c198797e650f6f05e263fc850f0fd2820c44533c", "filename": "src/libcore/alloc/global.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "ae7ae7044655bae38bfd4e7dae87938e31e3b726", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "be4e051b1ca42b71e32f4218eebd39a8ea1e4d1a", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 90, "deletions": 11, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "79b6304958d51332af85ff9987ba5c8740feb385", "filename": "src/libcore/any.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "549228ffffaa4d832ae1c92d750cf7665d6513a9", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "05dd7adff1fbbe4e495fe1de9089e5676bcf1743", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "729b0a04eb6ba092795405ffb85f302ae8b542d3", "filename": "src/libcore/benches/ascii/is_ascii.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fbenches%2Fascii%2Fis_ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fbenches%2Fascii%2Fis_ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii%2Fis_ascii.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "de4ef7949f344a6842fe1d7c8d2a3214f59e18a1", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "51d9695687f4afad7a141c95afb3cde5103715dc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "c329eec76ac3d9e28afc61a2adae447ffa1006b5", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "72555d781ed38e2580a6c2c15be5fc037938b035", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 352, "deletions": 101, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "1b4e906e4e47523615759379f91b63c7636db132", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "7784ec687ea9a9378ad2cca7770b62e148fb99d7", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "79085740119bd4b978be812188cbb766ad1b087a", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "8ff1ced53b071840f45edad5e3c3184804fb90c2", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "336c0b26bc7d71afffc08dae0d249eaf3ae0ffa5", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "9a8d65cd4e06b93e37e075f100a589b18e97eba5", "filename": "src/libcore/default.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "e9689af39d51f649b474a8fef71e99936fe12aba", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "9c5dbb5e6f3567fd567be94c44d00038e638d58b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "abf461338d80a95137e6c1e8f2715ccfdd8e27a4", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "4020c254446e3eb2c10dcf878810467df5e753c3", "filename": "src/libcore/future/into_future.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Finto_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Finto_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Finto_future.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "6d1ad9db74435fca5d1afa81b57ff0283faea49d", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}, {"sha": "74887b68aa0fadf95eaa9b7504f2ffdd3ae51c5c", "filename": "src/libcore/future/pending.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Fpending.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b37aad7f9cbd1c97e416e6b16325b607422b8/src%2Flibcore%2Ffuture%2Fpending.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fpending.rs?ref=bc2b37aad7f9cbd1c97e416e6b16325b607422b8"}]}