{"sha": "62f98c8ff8179c9754718e62285b82b50dfcfe26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjk4YzhmZjgxNzljOTc1NDcxOGU2MjI4NWI4MmI1MGRmY2ZlMjY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-28T00:14:09Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-30T22:05:32Z"}, "message": "Preserve parenthesization in the AST\n\nMaintain explicit \"paren\" nodes in the AST so we can pretty-print\nwithout having to guess where parens should go. We may revisit this\nin the future.\n\nr=graydon", "tree": {"sha": "c3db0a950f995408ea390f1b1952a24d2b982940", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3db0a950f995408ea390f1b1952a24d2b982940"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f98c8ff8179c9754718e62285b82b50dfcfe26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f98c8ff8179c9754718e62285b82b50dfcfe26", "html_url": "https://github.com/rust-lang/rust/commit/62f98c8ff8179c9754718e62285b82b50dfcfe26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f98c8ff8179c9754718e62285b82b50dfcfe26/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17a5d0f3a0a76e172777456cc0f5ed8318149e33", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a5d0f3a0a76e172777456cc0f5ed8318149e33", "html_url": "https://github.com/rust-lang/rust/commit/17a5d0f3a0a76e172777456cc0f5ed8318149e33"}], "stats": {"total": 365, "additions": 148, "deletions": 217}, "files": [{"sha": "a3e57716d173ff4c3ce4f97c62a1d8bd50668f8c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -744,7 +744,10 @@ enum expr_ {\n     expr_struct(@path, ~[field], Option<@expr>),\n \n     // A vector literal constructed from one repeated element.\n-    expr_repeat(@expr /* element */, @expr /* count */, mutability)\n+    expr_repeat(@expr /* element */, @expr /* count */, mutability),\n+\n+    // No-op: used solely so we can pretty-print faithfully\n+    expr_paren(@expr)\n }\n \n #[auto_serialize]"}, {"sha": "5fe3c8feea690438c7f1e993dead0e0b30389ac4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -494,7 +494,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_struct(fld.fold_path(path),\n                         vec::map(fields, |x| fold_field(*x)),\n                         option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n-          }\n+          },\n+          expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n         }\n }\n "}, {"sha": "2f3e29bd90ff3d27df1af65611cf0f67212986a0", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -36,39 +36,3 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n       }\n     }\n }\n-\n-fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n-    match expr.node {\n-      ast::expr_binary(op, _, _) => operator_prec(op) < outer_prec,\n-      ast::expr_cast(_, _) => parse::prec::as_prec < outer_prec,\n-      // This may be too conservative in some cases\n-      ast::expr_assign(_, _) => true,\n-      ast::expr_swap(_, _) => true,\n-      ast::expr_assign_op(_, _, _) => true,\n-      ast::expr_ret(_) => true,\n-      ast::expr_assert(_) => true,\n-      ast::expr_log(_, _, _) => true,\n-      _ => !parse::classify::expr_requires_semi_to_be_stmt(expr)\n-    }\n-}\n-\n-fn ends_in_lit_int(ex: @ast::expr) -> bool {\n-    match ex.node {\n-      ast::expr_lit(node) => match node {\n-        @{node: ast::lit_int(_, ast::ty_i), _}\n-        | @{node: ast::lit_int_unsuffixed(_), _} => true,\n-        _ => false\n-      },\n-      ast::expr_binary(_, _, sub) | ast::expr_unary(_, sub) |\n-      ast::expr_copy(sub) | ast::expr_assign(_, sub) |\n-      ast::expr_assign_op(_, _, sub) | ast::expr_swap(_, sub) |\n-      ast::expr_log(_, _, sub) | ast::expr_assert(sub) => {\n-        ends_in_lit_int(sub)\n-      }\n-      ast::expr_fail(osub) | ast::expr_ret(osub) => match osub {\n-        Some(ex) => ends_in_lit_int(ex),\n-        _ => false\n-      },\n-      _ => false\n-    }\n-}"}, {"sha": "a5bc5013c1759b97bf7bdc4c3c16afe1bc5b1bd4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 52, "deletions": 77, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -36,11 +36,11 @@ use ast::{_mod, add, arg, arm, attribute,\n              expr_call, expr_cast, expr_copy, expr_do_body, expr_fail,\n              expr_field, expr_fn, expr_fn_block, expr_if, expr_index,\n              expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac,\n-             expr_path, expr_rec, expr_repeat, expr_ret, expr_swap,\n-             expr_struct, expr_tup, expr_unary, expr_unary_move, expr_vec,\n-             expr_vstore, expr_while, extern_fn, field, fn_decl, foreign_item,\n-             foreign_item_const, foreign_item_fn, foreign_mod, ident,\n-             impure_fn, infer, inherited,\n+             expr_paren, expr_path, expr_rec, expr_repeat, expr_ret,\n+             expr_swap, expr_struct, expr_tup, expr_unary, expr_unary_move,\n+             expr_vec, expr_vstore, expr_while, extern_fn, field, fn_decl,\n+             foreign_item, foreign_item_const, foreign_item_fn, foreign_mod,\n+             ident, impure_fn, infer, inherited,\n              item, item_, item_class, item_const, item_enum, item_fn,\n              item_foreign_mod, item_impl, item_mac, item_mod, item_trait,\n              item_ty, lit, lit_, lit_bool, lit_float, lit_int,\n@@ -94,18 +94,6 @@ enum restriction {\n \n enum file_type { CRATE_FILE, SOURCE_FILE, }\n \n-\n-// We don't allow single-entry tuples in the true AST; that indicates a\n-// parenthesized expression.  However, we preserve them temporarily while\n-// parsing because `(while{...})+3` parses differently from `while{...}+3`.\n-//\n-// To reflect the fact that the @expr is not a true expr that should be\n-// part of the AST, we wrap such expressions in the pexpr enum.  They\n-// can then be converted to true expressions by a call to `to_expr()`.\n-enum pexpr {\n-    pexpr(@expr),\n-}\n-\n enum class_member {\n     field_member(@struct_field),\n     method_member(@method)\n@@ -141,11 +129,11 @@ macro_rules! maybe_whole_expr (\n     ($p:expr) => { match copy $p.token {\n       INTERPOLATED(token::nt_expr(e)) => {\n         $p.bump();\n-        return pexpr(e);\n+        return e;\n       }\n       INTERPOLATED(token::nt_path(pt)) => {\n         $p.bump();\n-        return $p.mk_pexpr($p.span.lo, $p.span.lo,\n+        return $p.mk_expr($p.span.lo, $p.span.lo,\n                        expr_path(pt));\n       }\n       _ => ()\n@@ -850,26 +838,15 @@ impl Parser {\n               node: expr_lit(lv_lit), span: span};\n     }\n \n-    fn mk_pexpr(lo: uint, hi: uint, node: expr_) -> pexpr {\n-        return pexpr(self.mk_expr(lo, hi, node));\n-    }\n-\n-    fn to_expr(e: pexpr) -> @expr {\n-        match e.node {\n-          expr_tup(es) if vec::len(es) == 1u => es[0u],\n-          _ => *e\n-        }\n-    }\n-\n-    fn parse_bottom_expr() -> pexpr {\n+    fn parse_bottom_expr() -> @expr {\n         maybe_whole_expr!(self);\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n         let mut ex: expr_;\n \n         match self.maybe_parse_dollar_mac() {\n-          Some(x) => return pexpr(self.mk_mac_expr(lo, self.span.hi, x)),\n+          Some(x) => return self.mk_mac_expr(lo, self.span.hi, x),\n           _ => ()\n         }\n \n@@ -879,7 +856,7 @@ impl Parser {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = @spanned(lo, hi, lit_nil);\n-                return self.mk_pexpr(lo, hi, expr_lit(lit));\n+                return self.mk_expr(lo, hi, expr_lit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n             while self.token == token::COMMA {\n@@ -888,45 +865,45 @@ impl Parser {\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n \n-            // Note: we retain the expr_tup() even for simple\n-            // parenthesized expressions, but only for a \"little while\".\n-            // This is so that wrappers around parse_bottom_expr()\n-            // can tell whether the expression was parenthesized or not,\n-            // which affects expr_is_complete().\n-            return self.mk_pexpr(lo, hi, expr_tup(es));\n+            return if es.len() == 1 {\n+                self.mk_expr(lo, self.span.hi, expr_paren(es[0]))\n+            }\n+            else {\n+                self.mk_expr(lo, hi, expr_tup(es))\n+            }\n         } else if self.token == token::LBRACE {\n             if self.looking_at_record_literal() {\n                 ex = self.parse_record_literal();\n                 hi = self.span.hi;\n             } else {\n                 self.bump();\n                 let blk = self.parse_block_tail(lo, default_blk);\n-                return self.mk_pexpr(blk.span.lo, blk.span.hi,\n+                return self.mk_expr(blk.span.lo, blk.span.hi,\n                                      expr_block(blk));\n             }\n         } else if token::is_bar(self.token) {\n-            return pexpr(self.parse_lambda_expr());\n+            return self.parse_lambda_expr();\n         } else if self.eat_keyword(~\"if\") {\n-            return pexpr(self.parse_if_expr());\n+            return self.parse_if_expr();\n         } else if self.eat_keyword(~\"for\") {\n-            return pexpr(self.parse_sugary_call_expr(~\"for\", expr_loop_body));\n+            return self.parse_sugary_call_expr(~\"for\", expr_loop_body);\n         } else if self.eat_keyword(~\"do\") {\n-            return pexpr(self.parse_sugary_call_expr(~\"do\", expr_do_body));\n+            return self.parse_sugary_call_expr(~\"do\", expr_do_body);\n         } else if self.eat_keyword(~\"while\") {\n-            return pexpr(self.parse_while_expr());\n+            return self.parse_while_expr();\n         } else if self.eat_keyword(~\"loop\") {\n-            return pexpr(self.parse_loop_expr());\n+            return self.parse_loop_expr();\n         } else if self.eat_keyword(~\"match\") {\n-            return pexpr(self.parse_alt_expr());\n+            return self.parse_alt_expr();\n         } else if self.eat_keyword(~\"fn\") {\n             let proto = self.parse_fn_ty_proto();\n             match proto {\n               proto_bare => self.fatal(~\"fn expr are deprecated, use fn@\"),\n               _ => { /* fallthrough */ }\n             }\n-            return pexpr(self.parse_fn_expr(proto));\n+            return self.parse_fn_expr(proto);\n         } else if self.eat_keyword(~\"unsafe\") {\n-            return pexpr(self.parse_block_expr(lo, unsafe_blk));\n+            return self.parse_block_expr(lo, unsafe_blk);\n         } else if self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n@@ -962,7 +939,7 @@ impl Parser {\n             hi = self.span.hi;\n         } else if self.token == token::ELLIPSIS {\n             self.bump();\n-            return pexpr(self.mk_mac_expr(lo, self.span.hi, mac_ellipsis));\n+            return self.mk_mac_expr(lo, self.span.hi, mac_ellipsis);\n         } else if self.token == token::POUND {\n             let ex_ext = self.parse_syntax_ext();\n             hi = ex_ext.span.hi;\n@@ -1020,8 +997,8 @@ impl Parser {\n \n                 let hi = self.span.hi;\n \n-                return pexpr(self.mk_mac_expr(\n-                    lo, hi, mac_invoc_tt(pth, tts)));\n+                return self.mk_mac_expr(\n+                    lo, hi, mac_invoc_tt(pth, tts));\n             } else if self.token == token::LBRACE {\n                 // This might be a struct literal.\n                 if self.looking_at_record_literal() {\n@@ -1053,7 +1030,7 @@ impl Parser {\n                     hi = pth.span.hi;\n                     self.expect(token::RBRACE);\n                     ex = expr_struct(pth, fields, base);\n-                    return self.mk_pexpr(lo, hi, ex);\n+                    return self.mk_expr(lo, hi, ex);\n                 }\n             }\n \n@@ -1068,7 +1045,7 @@ impl Parser {\n         let (hi, ex) =\n             self.try_convert_expr_to_obsolete_fixed_length_vstore(lo, hi, ex);\n \n-        return self.mk_pexpr(lo, hi, ex);\n+        return self.mk_expr(lo, hi, ex);\n     }\n \n     fn parse_block_expr(lo: uint, blk_mode: blk_check_mode) -> @expr {\n@@ -1125,7 +1102,7 @@ impl Parser {\n         return self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n     }\n \n-    fn parse_dot_or_call_expr() -> pexpr {\n+    fn parse_dot_or_call_expr() -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n@@ -1134,7 +1111,7 @@ impl Parser {\n         return self.restriction != RESTRICT_NO_CALL_EXPRS;\n     }\n \n-    fn parse_dot_or_call_expr_with(e0: pexpr) -> pexpr {\n+    fn parse_dot_or_call_expr_with(e0: @expr) -> @expr {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -1150,8 +1127,7 @@ impl Parser {\n                         self.parse_seq_to_gt(Some(token::COMMA),\n                                              |p| p.parse_ty(false))\n                     } else { ~[] };\n-                    e = self.mk_pexpr(lo, hi, expr_field(self.to_expr(e), i,\n-                                                         tys));\n+                    e = self.mk_expr(lo, hi, expr_field(e, i, tys));\n                   }\n                   _ => self.unexpected()\n                 }\n@@ -1167,8 +1143,8 @@ impl Parser {\n                     |p| p.parse_expr());\n                 hi = self.span.hi;\n \n-                let nd = expr_call(self.to_expr(e), es, false);\n-                e = self.mk_pexpr(lo, hi, nd);\n+                let nd = expr_call(e, es, false);\n+                e = self.mk_expr(lo, hi, nd);\n               }\n \n               // expr[...]\n@@ -1177,7 +1153,7 @@ impl Parser {\n                 let ix = self.parse_expr();\n                 hi = ix.span.hi;\n                 self.expect(token::RBRACKET);\n-                e = self.mk_pexpr(lo, hi, expr_index(self.to_expr(e), ix));\n+                e = self.mk_expr(lo, hi, expr_index(e, ix));\n               }\n \n               _ => return e\n@@ -1326,15 +1302,15 @@ impl Parser {\n     }\n \n \n-    fn parse_prefix_expr() -> pexpr {\n+    fn parse_prefix_expr() -> @expr {\n         let lo = self.span.lo;\n         let mut hi;\n \n         let mut ex;\n         match copy self.token {\n           token::NOT => {\n             self.bump();\n-            let e = self.to_expr(self.parse_prefix_expr());\n+            let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             self.get_id(); // see ast_util::op_expr_callee_id\n             ex = expr_unary(not, e);\n@@ -1343,21 +1319,21 @@ impl Parser {\n             match b {\n               token::MINUS => {\n                 self.bump();\n-                let e = self.to_expr(self.parse_prefix_expr());\n+                let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n                 self.get_id(); // see ast_util::op_expr_callee_id\n                 ex = expr_unary(neg, e);\n               }\n               token::STAR => {\n                 self.bump();\n-                let e = self.to_expr(self.parse_prefix_expr());\n+                let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n                 ex = expr_unary(deref, e);\n               }\n               token::AND => {\n                 self.bump();\n                 let m = self.parse_mutability();\n-                let e = self.to_expr(self.parse_prefix_expr());\n+                let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n@@ -1374,7 +1350,7 @@ impl Parser {\n           token::AT => {\n             self.bump();\n             let m = self.parse_mutability();\n-            let e = self.to_expr(self.parse_prefix_expr());\n+            let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n             ex = match e.node {\n@@ -1386,7 +1362,7 @@ impl Parser {\n           token::TILDE => {\n             self.bump();\n             let m = self.parse_mutability();\n-            let e = self.to_expr(self.parse_prefix_expr());\n+            let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n@@ -1397,18 +1373,17 @@ impl Parser {\n           }\n           _ => return self.parse_dot_or_call_expr()\n         }\n-        return self.mk_pexpr(lo, hi, ex);\n+        return self.mk_expr(lo, hi, ex);\n     }\n \n \n     fn parse_binops() -> @expr {\n-        return self.parse_more_binops(self.parse_prefix_expr(), 0u);\n+        return self.parse_more_binops(self.parse_prefix_expr(), 0);\n     }\n \n-    fn parse_more_binops(plhs: pexpr, min_prec: uint) ->\n+    fn parse_more_binops(lhs: @expr, min_prec: uint) ->\n         @expr {\n-        let lhs = self.to_expr(plhs);\n-        if self.expr_is_complete(plhs) { return lhs; }\n+        if self.expr_is_complete(lhs) { return lhs; }\n         let peeked = self.token;\n         if peeked == token::BINOP(token::OR) &&\n             (self.restriction == RESTRICT_NO_BAR_OP ||\n@@ -1428,7 +1403,7 @@ impl Parser {\n                 let expr = self.parse_prefix_expr();\n                 let rhs = self.parse_more_binops(expr, cur_prec);\n                 self.get_id(); // see ast_util::op_expr_callee_id\n-                let bin = self.mk_pexpr(lhs.span.lo, rhs.span.hi,\n+                let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n                                         expr_binary(cur_op, lhs, rhs));\n                 return self.parse_more_binops(bin, min_prec);\n             }\n@@ -1438,7 +1413,7 @@ impl Parser {\n         if as_prec > min_prec && self.eat_keyword(~\"as\") {\n             let rhs = self.parse_ty(true);\n             let _as =\n-                self.mk_pexpr(lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n+                self.mk_expr(lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n             return self.parse_more_binops(_as, min_prec);\n         }\n         return lhs;\n@@ -2173,9 +2148,9 @@ impl Parser {\n         }\n     }\n \n-    fn expr_is_complete(e: pexpr) -> bool {\n+    fn expr_is_complete(e: @expr) -> bool {\n         return self.restriction == RESTRICT_STMT_EXPR &&\n-            !classify::expr_requires_semi_to_be_stmt(*e);\n+            !classify::expr_requires_semi_to_be_stmt(e);\n     }\n \n     fn parse_block() -> blk {"}, {"sha": "3836c21ff2449fbaf15fdeeb9ef7c7c4ca972d81", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 62, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -773,7 +773,7 @@ fn print_variant(s: ps, v: ast::variant) {\n     match v.node.kind {\n         ast::tuple_variant_kind(args) => {\n             print_ident(s, v.node.name);\n-            if vec::len(args) > 0u {\n+            if args.is_not_empty() {\n                 popen(s);\n                 fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n                     print_type(s, arg.ty);\n@@ -951,25 +951,11 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n     s.ann.post(ann_node);\n }\n \n-// return and fail, without arguments cannot appear is the discriminant of if,\n-// alt, do, & while unambiguously without being parenthesized\n-fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n-    let disambig = match e.node {\n-      ast::expr_ret(None)\n-      | ast::expr_fail(None)\n-      | ast::expr_again(*) => true,\n-      _ => false\n-    };\n-    if disambig { popen(s); }\n-    print_expr(s, e);\n-    if disambig { pclose(s); }\n-}\n-\n fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n             elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, ~\"if\");\n     if chk { word_nbsp(s, ~\"check\"); }\n-    print_maybe_parens_discrim(s, test);\n+    print_expr(s, test);\n     space(s.s);\n     print_block(s, blk);\n     fn do_else(s: ps, els: Option<@ast::expr>) {\n@@ -981,7 +967,7 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else if \");\n-                print_maybe_parens_discrim(s, i);\n+                print_expr(s, i);\n                 space(s.s);\n                 print_block(s, t);\n                 do_else(s, e);\n@@ -1154,8 +1140,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             }\n             Some(blk_arg)\n         } else { None };\n-        print_expr_parens_if_not_bot(s, func);\n-        if !has_block || vec::len(base_args) > 0u {\n+        print_expr(s, func);\n+        if !has_block || base_args.is_not_empty() {\n             popen(s);\n             commasep_exprs(s, inconsistent, base_args);\n             pclose(s);\n@@ -1178,15 +1164,14 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n       }\n       ast::expr_binary(op, lhs, rhs) => {\n-        let prec = operator_prec(op);\n-        print_op_maybe_parens(s, lhs, prec);\n+        print_expr(s, lhs);\n         space(s.s);\n         word_space(s, ast_util::binop_to_str(op));\n-        print_op_maybe_parens(s, rhs, prec + 1u);\n+        print_expr(s, rhs);\n       }\n       ast::expr_unary(op, expr) => {\n         word(s.s, ast_util::unop_to_str(op));\n-        print_op_maybe_parens(s, expr, parse::prec::unop_prec);\n+        print_expr(s, expr);\n       }\n       ast::expr_addr_of(m, expr) => {\n         word(s.s, ~\"&\");\n@@ -1195,7 +1180,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       }\n       ast::expr_lit(lit) => print_literal(s, lit),\n       ast::expr_cast(expr, ty) => {\n-        print_op_maybe_parens(s, expr, parse::prec::as_prec);\n+        print_expr(s, expr);\n         space(s.s);\n         word_space(s, ~\"as\");\n         print_type_ex(s, ty, true);\n@@ -1205,7 +1190,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       }\n       ast::expr_while(test, blk) => {\n         head(s, ~\"while\");\n-        print_maybe_parens_discrim(s, test);\n+        print_expr(s, test);\n         space(s.s);\n         print_block(s, blk);\n       }\n@@ -1220,9 +1205,9 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       }\n       ast::expr_match(expr, arms) => {\n         cbox(s, alt_indent_unit);\n-        ibox(s, 4u);\n+        ibox(s, 4);\n         word_nbsp(s, ~\"match\");\n-        print_maybe_parens_discrim(s, expr);\n+        print_expr(s, expr);\n         space(s.s);\n         bopen(s);\n         let len = arms.len();\n@@ -1335,12 +1320,9 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n-        // shouldn't parenthesize unless it's needed\n       ast::expr_unary_move(e) => {\n-          popen(s);\n           word_space(s, ~\"move\");\n           print_expr(s, e);\n-          pclose(s);\n       }\n       ast::expr_assign(lhs, rhs) => {\n         print_expr(s, lhs);\n@@ -1362,12 +1344,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_expr(s, rhs);\n       }\n       ast::expr_field(expr, id, tys) => {\n-        // Deal with '10.x'\n-        if ends_in_lit_int(expr) {\n-            popen(s); print_expr(s, expr); pclose(s);\n-        } else {\n-            print_expr_parens_if_not_bot(s, expr);\n-        }\n+        print_expr(s, expr);\n         word(s.s, ~\".\");\n         print_ident(s, id);\n         if vec::len(tys) > 0u {\n@@ -1377,7 +1354,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n       }\n       ast::expr_index(expr, index) => {\n-        print_expr_parens_if_not_bot(s, expr);\n+        print_expr(s, expr);\n         word(s.s, ~\"[\");\n         print_expr(s, index);\n         word(s.s, ~\"]\");\n@@ -1427,27 +1404,16 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_expr(s, expr);\n       }\n       ast::expr_mac(m) => print_mac(s, m),\n+      ast::expr_paren(e) => {\n+          popen(s);\n+          print_expr(s, e);\n+          pclose(s);\n+      }\n     }\n     s.ann.post(ann_node);\n     end(s);\n }\n \n-fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n-    let parens = match ex.node {\n-      ast::expr_fail(_) | ast::expr_ret(_) |\n-      ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n-      ast::expr_copy(_) | ast::expr_assign(_, _) |\n-      ast::expr_assign_op(_, _, _) | ast::expr_swap(_, _) |\n-      ast::expr_log(_, _, _) | ast::expr_assert(_) |\n-      ast::expr_call(_, _, true) |\n-      ast::expr_vstore(_, _) => true,\n-      _ => false\n-    };\n-    if parens { popen(s); }\n-    print_expr(s, ex);\n-    if parens { pclose(s); }\n-}\n-\n fn print_local_decl(s: ps, loc: @ast::local) {\n     print_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n@@ -1557,7 +1523,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         match args_ {\n           None => word(s.s, ~\"(*)\"),\n           Some(args) => {\n-            if vec::len(args) > 0u {\n+            if args.is_not_empty() {\n               popen(s);\n               commasep(s, inconsistent, args, print_pat);\n               pclose(s);\n@@ -1813,7 +1779,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n       ast::view_item_use(id, mta, _) => {\n         head(s, ~\"extern mod\");\n         print_ident(s, id);\n-        if vec::len(mta) > 0u {\n+        if mta.is_not_empty() {\n             popen(s);\n             commasep(s, consistent, mta, print_meta_item);\n             pclose(s);\n@@ -1835,13 +1801,6 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     end(s); // end outer head-block\n }\n \n-fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: uint) {\n-    let add_them = need_parens(expr, outer_prec);\n-    if add_them { popen(s); }\n-    print_expr(s, expr);\n-    if add_them { pclose(s); }\n-}\n-\n fn print_mutability(s: ps, mutbl: ast::mutability) {\n     match mutbl {\n       ast::m_mutbl => word_nbsp(s, ~\"mut\"),"}, {"sha": "2dbe2b16044efed3a37fd09fea1e34005d165a86", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -462,6 +462,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(x, e, v);\n       }\n       expr_mac(mac) => visit_mac(mac, e, v),\n+      expr_paren(x) => v.visit_expr(x, e, v),\n     }\n     v.visit_expr_post(ex, e, v);\n }"}, {"sha": "482ab3041f44cbf4c0ffe77ec884a3f410d37999", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -98,6 +98,8 @@ fn check_expr(sess: Session, def_map: resolve::DefMap,\n               }\n             }\n           }\n+          expr_paren(e) => { check_expr(sess, def_map, method_map,\n+                                         tcx, e, is_const, v); }\n           expr_vstore(_, expr_vstore_slice) |\n           expr_vstore(_, expr_vstore_fixed(_)) |\n           expr_vec(_, m_imm) |"}, {"sha": "3e30bf50e023d5d548c058f63f646e15593229d4", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -72,7 +72,8 @@ fn classify(e: @expr,\n               }\n \n               ast::expr_copy(inner) |\n-              ast::expr_unary(_, inner) => {\n+              ast::expr_unary(_, inner) |\n+              ast::expr_paren(inner) => {\n                 classify(inner, def_map, tcx)\n               }\n \n@@ -376,6 +377,7 @@ fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n       expr_lit(lit) => Ok(lit_to_const(lit)),\n       // If we have a vstore, just keep going; it has to be a string\n       expr_vstore(e, _) => eval_const_expr_partial(tcx, e),\n+      expr_paren(e)     => eval_const_expr_partial(tcx, e),\n       _ => Err(~\"Unsupported constant expr\")\n     }\n }"}, {"sha": "baf083b191ba0b6341f06b46ceccd21fb8d13ce8", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -554,7 +554,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n       expr_break(_) | expr_again(_) | expr_lit(_) | expr_ret(*) |\n       expr_block(*) | expr_unary_move(*) | expr_assign(*) |\n       expr_swap(*) | expr_assign_op(*) | expr_mac(*) | expr_struct(*) |\n-      expr_repeat(*) => {\n+      expr_repeat(*) | expr_paren(*) => {\n           visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -1253,7 +1253,8 @@ impl Liveness {\n           expr_loop_body(e) |\n           expr_do_body(e) |\n           expr_cast(e, _) |\n-          expr_unary(_, e) => {\n+          expr_unary(_, e) |\n+          expr_paren(e) => {\n             self.propagate_through_expr(e, succ)\n           }\n \n@@ -1550,7 +1551,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n       expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break(*) | expr_again(*) | expr_lit(_) |\n       expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) |\n-      expr_struct(*) | expr_repeat(*) => {\n+      expr_struct(*) | expr_repeat(*) | expr_paren(*) => {\n         visit::visit_expr(expr, self, vt);\n       }\n     }"}, {"sha": "83eddc1c21b72fda1be624005644235e150d1290", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -481,6 +481,8 @@ impl &mem_categorization_ctxt {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n+          ast::expr_paren(e) => self.cat_expr_unadjusted(e),\n+\n           ast::expr_addr_of(*) | ast::expr_call(*) |\n           ast::expr_swap(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |"}, {"sha": "54eec8c6de0731d2bab557fb40f628ca4a5eb5e5", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -361,6 +361,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           _ => cx.sess.span_bug(e.span, ~\"expected to find a const def\")\n         }\n       }\n+        ast::expr_paren(e) => { return const_expr(cx, e); }\n       _ => cx.sess.span_bug(e.span,\n             ~\"bad constant expression type in consts::const_expr\")\n     };"}, {"sha": "3aabef8794c4f01d1f8ebd9d38cc5ce93dfc7a1e", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -161,7 +161,6 @@ impl Dest : cmp::Eq {\n \n fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n-\n     return match bcx.tcx().adjustments.find(expr.id) {\n         None => {\n             trans_to_datum_unadjusted(bcx, expr)\n@@ -392,6 +391,9 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         ast::expr_cast(val, _) => {\n             return trans_imm_cast(bcx, val, expr.id);\n         }\n+        ast::expr_paren(e) => {\n+            return trans_rvalue_datum_unadjusted(bcx, e);\n+        }\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n@@ -450,6 +452,9 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         ast::expr_assign_op(op, dst, src) => {\n             return trans_assign_op(bcx, expr, op, dst, src);\n         }\n+        ast::expr_paren(a) => {\n+            return trans_rvalue_stmt_unadjusted(bcx, a);\n+        }\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n@@ -469,6 +474,9 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n+        ast::expr_paren(e) => {\n+            return trans_rvalue_dps_unadjusted(bcx, e, dest);\n+        }\n         ast::expr_path(_) => {\n             return trans_def_dps_unadjusted(bcx, expr,\n                                             bcx.def(expr.id), dest);\n@@ -690,6 +698,9 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let mut bcx = bcx;\n \n         match expr.node {\n+            ast::expr_paren(e) => {\n+                return unrooted(bcx, e);\n+            }\n             ast::expr_path(_) => {\n                 return trans_def_lvalue(bcx, expr, bcx.def(expr.id));\n             }"}, {"sha": "b8a7580e03cc91df7e10008615e8aa8a34528e58", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -267,6 +267,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n               }\n           }\n       }\n+      expr_paren(e) => mark_for_expr(cx, e),\n       expr_match(*) | expr_block(_) | expr_if(*) |\n       expr_while(*) | expr_fail(_) | expr_break(_) | expr_again(_) |\n       expr_unary(_, _) | expr_lit(_) | expr_assert(_) |"}, {"sha": "1402d1c93243dc97d021b04edc7f7e59987341a1", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -2872,24 +2872,6 @@ fn is_pred_ty(fty: t) -> bool {\n     is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n }\n \n-/*\n-fn ty_var_id(typ: t) -> TyVid {\n-    match get(typ).sty {\n-      ty_infer(TyVar(vid)) => return vid,\n-      _ => { error!(\"ty_var_id called on non-var ty\"); fail; }\n-    }\n-}\n-\n-fn int_var_id(typ: t) -> IntVid {\n-    match get(typ).sty {\n-      ty_infer(IntVar(vid)) => return vid,\n-      _ => { error!(\"ty_var_integral_id called on ty other than \\\n-                  ty_var_integral\");\n-         fail; }\n-    }\n-}\n-*/\n-\n // Type accessors for AST nodes\n fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n     return node_id_to_type(cx, b.node.id);\n@@ -3094,6 +3076,8 @@ fn expr_kind(tcx: ctxt,\n             RvalueDatumExpr\n         }\n \n+        ast::expr_paren(e) => expr_kind(tcx, method_map, e),\n+\n         ast::expr_mac(*) => {\n             tcx.sess.span_bug(\n                 expr.span,"}, {"sha": "5fc92b2d0d0ae30b48014fe5aa74904024b8a519", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -990,11 +990,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         debug!(\"check_call_inner: after universal quant., fty=%s\",\n                fcx.infcx().ty_to_str(fty));\n \n-        let supplied_arg_count = vec::len(args);\n+        let supplied_arg_count = args.len();\n \n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n-        let expected_arg_count = vec::len(fn_ty.sig.inputs);\n+        let expected_arg_count = fn_ty.sig.inputs.len();\n         let formal_tys = if expected_arg_count == supplied_arg_count {\n             fn_ty.sig.inputs.map(|a| a.ty)\n         } else {\n@@ -1058,8 +1058,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n                     bot |= check_expr_with_unifier(\n                         fcx, *arg, Some(formal_ty),\n-                        || demand::assign(fcx, arg.span, formal_ty, *arg)\n+                        || demand::assign(fcx, arg.span,\n+                                           formal_ty, *arg)\n                     );\n+                    fcx.write_ty(arg.id, fcx.expr_ty(*arg));\n+\n                 }\n             }\n         }\n@@ -1369,12 +1372,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n-        let n_tys = vec::len(tys);\n+        let n_tys = tys.len();\n+\n         match structure_of(fcx, expr.span, base_t) {\n             ty::ty_rec(fields) => {\n                 match ty::field_idx(field, fields) {\n                     Some(ix) => {\n-                        if n_tys > 0u {\n+                        if n_tys > 0 {\n                             tcx.sess.span_err(\n                                 expr.span,\n                                 ~\"can't provide type parameters \\\n@@ -1680,7 +1684,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(args, mutbl) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, args.len(), vst);\n             let t: ty::t = fcx.infcx().next_ty_var();\n             for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n@@ -1871,6 +1875,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_expr(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n+      ast::expr_paren(a) => {\n+        bot = check_expr_with_unifier(fcx, a, expected, || ());\n+        fcx.write_ty(id, fcx.expr_ty(a));\n+        do expected.iter |i| {\n+            demand::assign(fcx, expr.span, *i, expr);\n+            demand::assign(fcx, a.span, *i, a);\n+        };\n+      }\n       ast::expr_assign(lhs, rhs) => {\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n@@ -2583,9 +2595,9 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n     // determine values for type parameters, using the values given by\n     // the user (if any) and otherwise using fresh type variables\n-    let tps = if ty_substs_len == 0u {\n+    let tps = if ty_substs_len == 0 {\n         fcx.infcx().next_ty_vars(ty_param_count)\n-    } else if ty_param_count == 0u {\n+    } else if ty_param_count == 0 {\n         fcx.ccx.tcx.sess.span_err\n             (span, ~\"this item does not take type parameters\");\n         fcx.infcx().next_ty_vars(ty_param_count)"}, {"sha": "dc1b14e4beb24a18b11ff54d09af7f2c95f646b0", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -132,6 +132,10 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n     instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id,\n                      pcx.block_region);\n \n+    // structure_of requires type variables to be resolved.\n+    // So when we pass in <expected>, it's an error if it\n+    // contains type variables.\n+\n     // Take the enum type params out of `expected`.\n     match structure_of(pcx.fcx, pat.span, expected) {\n       ty::ty_enum(_, ref expected_substs) => {\n@@ -151,7 +155,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             None => arg_len,\n             Some(ps) => ps.len()\n         };\n-        if arg_len > 0u {\n+        if arg_len > 0 {\n             // N-ary variant.\n             if arg_len != subpats_len {\n                 let s = fmt!(\"this pattern has %u field%s, but the \\\n@@ -168,7 +172,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                   check_pat(pcx, *subpat, *arg_ty);\n                 }\n             };\n-        } else if subpats_len > 0u {\n+        } else if subpats_len > 0 {\n             tcx.sess.span_fatal\n                 (pat.span, fmt!(\"this pattern has %u field%s, \\\n                                  but the corresponding variant has no fields\","}, {"sha": "85a65d7432fd872a62419a336c28a39c5f37556b", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -486,6 +486,11 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n           _ => ()\n         }\n       }\n+\n+      ast::expr_paren(e) => {\n+          early_resolve_expr(e, fcx, is_early);\n+      }\n+\n       // Must resolve bounds on methods with bounded params\n       ast::expr_field(*) | ast::expr_binary(*) |\n       ast::expr_unary(*) | ast::expr_assign_op(*) |"}, {"sha": "43c16984bb66791987132bf7a2dcba66a8944bd1", "filename": "src/test/compile-fail/trait-cast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -3,6 +3,9 @@ trait foo<T> { }\n fn bar(x: foo<uint>) -> foo<int> {\n     return (x as foo::<int>);\n     //~^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n+    //~^^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n+    // This is unfortunate -- new handling of parens means the error message\n+    // gets printed twice\n }\n \n fn main() {}"}, {"sha": "fa91049e3aea1060fbe04616dd5190388a2eaa90", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -8,24 +8,24 @@ fn enum_chars(start: u8, end: u8) -> ~[char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = ~[];\n-    while i <= end { r.push(i as char); i += 1u as u8; }\n+    while i <= end { r.push(i as char); i += 1 as u8; }\n     return r;\n }\n \n fn enum_uints(start: uint, end: uint) -> ~[uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = ~[];\n-    while i <= end { r.push(i); i += 1u; }\n+    while i <= end { r.push(i); i += 1; }\n     return r;\n }\n \n fn main() {\n-    let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 9u;\n+    let a = 'a' as u8, j = 'j' as u8, k = 1, l = 9;\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n \n-    assert (same_length(chars, ints));\n+    assert same_length(chars, ints);\n     let ps = zip(chars, ints);\n     fail ~\"the impossible happened\";\n }"}, {"sha": "7afb74fa12172422f962db62a757fb1e06a48420", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f98c8ff8179c9754718e62285b82b50dfcfe26/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=62f98c8ff8179c9754718e62285b82b50dfcfe26", "patch": "@@ -11,10 +11,10 @@ mod m1 {\n }\n \n fn main() {\n-    assert(line!() == 14u);\n-    assert(col!() == 11u);\n+    assert(line!() == 14);\n+    assert(col!() == 11);\n     assert(file!().ends_with(~\"syntax-extension-source-utils.rs\"));\n-    assert(stringify!((2*3) + 5) == ~\"2 * 3 + 5\");\n+    assert(stringify!((2*3) + 5) == ~\"(2 * 3) + 5\");\n     assert(include!(\"syntax-extension-source-utils-files/includeme.fragment\")\n            == ~\"victory robot 6\");\n "}]}