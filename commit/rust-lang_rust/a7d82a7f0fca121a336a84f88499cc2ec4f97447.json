{"sha": "a7d82a7f0fca121a336a84f88499cc2ec4f97447", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZDgyYTdmMGZjYTEyMWEzMzZhODRmODg0OTljYzJlYzRmOTc0NDc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-05T21:19:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-05T21:19:27Z"}, "message": "Factor the ivec code a touch.", "tree": {"sha": "5db402acabe3d897fe4338898eeded7339e8a435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5db402acabe3d897fe4338898eeded7339e8a435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d82a7f0fca121a336a84f88499cc2ec4f97447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d82a7f0fca121a336a84f88499cc2ec4f97447", "html_url": "https://github.com/rust-lang/rust/commit/a7d82a7f0fca121a336a84f88499cc2ec4f97447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d82a7f0fca121a336a84f88499cc2ec4f97447/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5e28567a2769e4d660d3ebe5f820a38fc4e501a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5e28567a2769e4d660d3ebe5f820a38fc4e501a", "html_url": "https://github.com/rust-lang/rust/commit/c5e28567a2769e4d660d3ebe5f820a38fc4e501a"}], "stats": {"total": 92, "additions": 40, "deletions": 52}, "files": [{"sha": "b6897328c2158e3a973550cc0fb64c8f9f1e9d07", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 40, "deletions": 52, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a7d82a7f0fca121a336a84f88499cc2ec4f97447/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d82a7f0fca121a336a84f88499cc2ec4f97447/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a7d82a7f0fca121a336a84f88499cc2ec4f97447", "patch": "@@ -2533,6 +2533,23 @@ fn iter_structural_ty(&@block_ctxt cx, ValueRef v, &ty::t t, val_and_ty_fn f)\n     ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n }\n \n+fn load_inbounds(&@block_ctxt cx, ValueRef p,\n+                 vec[ValueRef] idxs) -> ValueRef {\n+    ret cx.build.Load(cx.build.InBoundsGEP(p, idxs));\n+}\n+\n+fn store_inbounds(&@block_ctxt cx, ValueRef v,\n+                  ValueRef p, vec[ValueRef] idxs) {\n+    cx.build.Store(v, cx.build.InBoundsGEP(p, idxs));\n+}\n+\n+// This uses store and inboundsGEP, but it only doing so superficially; it's\n+// really storing an incremented pointer to another pointer.\n+fn incr_ptr(&@block_ctxt cx, ValueRef p,\n+            ValueRef incr, ValueRef pp) {\n+    cx.build.Store(cx.build.InBoundsGEP(p, [incr]), pp);\n+}\n+\n fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                            &ty::t t, &val_pair_and_ty_fn f) -> result {\n     fn iter_boxpp(@block_ctxt cx, ValueRef box_a_cell, ValueRef box_b_cell,\n@@ -2610,10 +2627,8 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             increment = C_int(1);\n         }\n \n-        loop_body_cx.build.Store(loop_body_cx.build.InBoundsGEP(dest_elem,\n-            [increment]), dest_elem_ptr);\n-        loop_body_cx.build.Store(loop_body_cx.build.InBoundsGEP(src_elem,\n-            [increment]), src_elem_ptr);\n+        incr_ptr(loop_body_cx, dest_elem, increment, dest_elem_ptr);\n+        incr_ptr(loop_body_cx, src_elem, increment, src_elem_ptr);\n         loop_body_cx.build.Br(loop_header_cx.llbb);\n \n         ret rslt(next_cx, C_nil());\n@@ -3450,13 +3465,8 @@ mod ivec {\n         }\n \n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n-        auto stack_len =\n-            {\n-                auto p = bcx.build.InBoundsGEP(v,\n-                                               [C_int(0),\n+        auto stack_len = load_inbounds(bcx, v, [C_int(0),\n                                                 C_uint(abi::ivec_elt_len)]);\n-                bcx.build.Load(p)\n-            };\n         auto stack_elem =\n             bcx.build.InBoundsGEP(v,\n                                   [C_int(0), C_uint(abi::ivec_elt_elems),\n@@ -3468,12 +3478,10 @@ mod ivec {\n         bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n         auto heap_stub =\n             on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-        auto heap_ptr =\n-            {\n-                auto v = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-                on_heap_cx.build.Load(on_heap_cx.build.InBoundsGEP(heap_stub,\n-                                                                   v))\n-            };\n+        auto heap_ptr = load_inbounds(on_heap_cx, heap_stub,\n+                                      [C_int(0),\n+                                       C_uint(abi::ivec_heap_stub_elt_ptr)]);\n+\n         // Check whether the heap pointer is null. If it is, the vector length\n         // is truly zero.\n \n@@ -3494,18 +3502,16 @@ mod ivec {\n         zero_len_cx.build.Br(next_cx.llbb);\n         // If we're here, then we actually have a heapified vector.\n \n-        auto heap_len =\n-            {\n-                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-                auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr, v);\n-                nonzero_len_cx.build.Load(m)\n-            };\n+        auto heap_len = load_inbounds(nonzero_len_cx, heap_ptr,\n+                                      [C_int(0),\n+                                       C_uint(abi::ivec_heap_elt_len)]);\n         auto heap_elem =\n             {\n                 auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n                           C_int(0)];\n                 nonzero_len_cx.build.InBoundsGEP(heap_ptr,v)\n             };\n+\n         nonzero_len_cx.build.Br(next_cx.llbb);\n         // Now we can figure out the length of `v` and get a pointer to its\n         // first element.\n@@ -3529,10 +3535,8 @@ mod ivec {\n         auto stack_len_ptr =\n             cx.build.InBoundsGEP(v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n         auto stack_len = cx.build.Load(stack_len_ptr);\n-        auto alen =\n-            cx.build.Load(cx.build.InBoundsGEP(v,\n-                                               [C_int(0),\n-                                                C_uint(abi::ivec_elt_alen)]));\n+        auto alen = load_inbounds(cx, v, [C_int(0),\n+                                          C_uint(abi::ivec_elt_alen)]);\n         // There are four cases we have to consider:\n         // (1) On heap, no resize necessary.\n         // (2) On heap, need to resize.\n@@ -3552,11 +3556,7 @@ mod ivec {\n         auto stub_ptr =\n             maybe_on_heap_cx.build.PointerCast(v,\n                                                T_ptr(T_ivec_heap(llunitty)));\n-        auto heap_ptr =\n-            {\n-                auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, stub_p);\n-                maybe_on_heap_cx.build.Load(m)\n-            };\n+        auto heap_ptr = load_inbounds(maybe_on_heap_cx, stub_ptr, stub_p);\n         auto on_heap =\n             maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n                                         C_null(val_ty(heap_ptr)));\n@@ -3599,10 +3599,8 @@ mod ivec {\n                                       [cx.fcx.lltaskptr, p, new_heap_len]);\n         }\n         auto heap_ptr_resize =\n-            {\n-                auto m = heap_resize_cx.build.InBoundsGEP(stub_ptr, stub_p);\n-                heap_resize_cx.build.Load(m)\n-            };\n+            load_inbounds(heap_resize_cx, stub_ptr, stub_p);\n+\n         auto heap_data_resize =\n             {\n                 auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n@@ -3642,15 +3640,10 @@ mod ivec {\n         }\n         auto spill_stub =\n             stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+\n         auto heap_ptr_spill =\n-            {\n-                auto p = stack_spill_cx.build.InBoundsGEP(spill_stub, stub_p);\n-                stack_spill_cx.build.Load(p)\n-            };\n-        {\n-                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-                stack_spill_cx.build.InBoundsGEP(heap_ptr_spill, v)\n-            };\n+            load_inbounds(stack_spill_cx, spill_stub, stub_p);\n+\n         auto heap_data_spill =\n             {\n                 auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n@@ -3745,18 +3738,13 @@ mod ivec {\n                       unit_ty);\n         auto post_copy_cx = rs.bcx;\n         // Increment both pointers.\n-\n         if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n             // We have to increment by the dynamically-computed size.\n-            post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(\n-                copy_dest_ptr, [unit_sz]), dest_ptr);\n-            post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(\n-                copy_src_ptr, [unit_sz]), src_ptr);\n+            incr_ptr(post_copy_cx, copy_dest_ptr, unit_sz, dest_ptr);\n+            incr_ptr(post_copy_cx, copy_src_ptr, unit_sz, src_ptr);\n         } else {\n-            post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(\n-                copy_dest_ptr, [C_int(1)]), dest_ptr);\n-            post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(\n-                copy_src_ptr, [C_int(1)]), src_ptr);\n+            incr_ptr(post_copy_cx, copy_dest_ptr, C_int(1), dest_ptr);\n+            incr_ptr(post_copy_cx, copy_src_ptr, C_int(1), src_ptr);\n         }\n \n         post_copy_cx.build.Br(copy_loop_header_cx.llbb);"}]}