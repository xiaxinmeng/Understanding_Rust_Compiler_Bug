{"sha": "a35cdd4e41a2bec5d8896653f898aaff61cb0106", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNWNkZDRlNDFhMmJlYzVkODg5NjY1M2Y4OThhYWZmNjFjYjAxMDY=", "commit": {"author": {"name": "John Downey", "email": "jdowney@gmail.com", "date": "2019-03-06T18:17:26Z"}, "committer": {"name": "John Downey", "email": "jdowney@gmail.com", "date": "2019-03-06T18:17:26Z"}, "message": "Implement `iter::Sum` and `iter::Product` for `Option`\n\nThis is similar to the existing implementation for `Result`. It will\ntake each item into the accumulator unless a `None` is returned.", "tree": {"sha": "d5e86d8d735b99b95bac9dcff987a50f6567d701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5e86d8d735b99b95bac9dcff987a50f6567d701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a35cdd4e41a2bec5d8896653f898aaff61cb0106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a35cdd4e41a2bec5d8896653f898aaff61cb0106", "html_url": "https://github.com/rust-lang/rust/commit/a35cdd4e41a2bec5d8896653f898aaff61cb0106", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a35cdd4e41a2bec5d8896653f898aaff61cb0106/comments", "author": {"login": "jtdowney", "id": 44654, "node_id": "MDQ6VXNlcjQ0NjU0", "avatar_url": "https://avatars.githubusercontent.com/u/44654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtdowney", "html_url": "https://github.com/jtdowney", "followers_url": "https://api.github.com/users/jtdowney/followers", "following_url": "https://api.github.com/users/jtdowney/following{/other_user}", "gists_url": "https://api.github.com/users/jtdowney/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtdowney/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtdowney/subscriptions", "organizations_url": "https://api.github.com/users/jtdowney/orgs", "repos_url": "https://api.github.com/users/jtdowney/repos", "events_url": "https://api.github.com/users/jtdowney/events{/privacy}", "received_events_url": "https://api.github.com/users/jtdowney/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtdowney", "id": 44654, "node_id": "MDQ6VXNlcjQ0NjU0", "avatar_url": "https://avatars.githubusercontent.com/u/44654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtdowney", "html_url": "https://github.com/jtdowney", "followers_url": "https://api.github.com/users/jtdowney/followers", "following_url": "https://api.github.com/users/jtdowney/following{/other_user}", "gists_url": "https://api.github.com/users/jtdowney/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtdowney/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtdowney/subscriptions", "organizations_url": "https://api.github.com/users/jtdowney/orgs", "repos_url": "https://api.github.com/users/jtdowney/repos", "events_url": "https://api.github.com/users/jtdowney/events{/privacy}", "received_events_url": "https://api.github.com/users/jtdowney/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f22dca0a1bef4141e75326caacc3cd59f3d5be8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f22dca0a1bef4141e75326caacc3cd59f3d5be8e", "html_url": "https://github.com/rust-lang/rust/commit/f22dca0a1bef4141e75326caacc3cd59f3d5be8e"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "b67714ca77903e9a258fa0e428a7298c628dee9f", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a35cdd4e41a2bec5d8896653f898aaff61cb0106/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35cdd4e41a2bec5d8896653f898aaff61cb0106/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=a35cdd4e41a2bec5d8896653f898aaff61cb0106", "patch": "@@ -223,3 +223,116 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n         ResultShunt::process(iter, |i| i.product())\n     }\n }\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Option::Some` values.\n+struct OptionShunt<I> {\n+    iter: I,\n+    exited_early: bool,\n+}\n+\n+impl<I, T> OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Option<T>`. Any `None` value will stop the inner iterator and\n+    /// the overall result will be a `None`.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n+    where\n+        F: FnMut(&mut Self) -> U,\n+    {\n+        let mut shunt = OptionShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        OptionShunt {\n+            iter,\n+            exited_early: false,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Option` value.\n+    fn reconstruct<U>(self, val: U) -> Option<U> {\n+        if self.exited_early {\n+            None\n+        } else {\n+            Some(val)\n+        }\n+    }\n+}\n+\n+impl<I, T> Iterator for OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Some(v)) => Some(v),\n+            Some(None) => {\n+                self.exited_early = true;\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.exited_early {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.34.0\")]\n+impl<T, U> Sum<Option<U>> for Option<T>\n+where\n+    T: Sum<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up every integer in a vector, rejecting the sum if a negative\n+    /// element is encountered:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2];\n+    /// let res: Option<i32> = v.iter().map(|&x: &i32|\n+    ///     if x < 0 { None }\n+    ///     else { Some(x) }\n+    /// ).sum();\n+    /// assert_eq!(res, Some(3));\n+    /// ```\n+    fn sum<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.34.0\")]\n+impl<T, U> Product<Option<U>> for Option<T>\n+where\n+    T: Product<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the product of all elements is returned.\n+    fn product<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.product())\n+    }\n+}"}, {"sha": "814f4ec4ca53b273baab0e17df071dd24a797855", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a35cdd4e41a2bec5d8896653f898aaff61cb0106/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35cdd4e41a2bec5d8896653f898aaff61cb0106/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=a35cdd4e41a2bec5d8896653f898aaff61cb0106", "patch": "@@ -1066,6 +1066,14 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n }\n \n+#[test]\n+fn test_iterator_sum_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), Some(10));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_product() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -1082,6 +1090,14 @@ fn test_iterator_product_result() {\n     assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n }\n \n+#[test]\n+fn test_iterator_product_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), Some(24));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}]}