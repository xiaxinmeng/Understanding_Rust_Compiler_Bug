{"sha": "8fe83028870ac6ac48e99a38d2992bedc26ec0d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTgzMDI4ODcwYWM2YWM0OGU5OWEzOGQyOTkyYmVkYzI2ZWMwZDc=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-19T13:34:48Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-19T14:11:45Z"}, "message": "std::str: Use iterators instead of while loops for CharSplitIterator\n\nEmbed an iterator in the CharSplitIterator struct, and combine that with\nthe former bool `only_ascii`; so use an enum instead.", "tree": {"sha": "821bd65530ba050829b9e7da1abd79bef75d7f4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821bd65530ba050829b9e7da1abd79bef75d7f4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe83028870ac6ac48e99a38d2992bedc26ec0d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe83028870ac6ac48e99a38d2992bedc26ec0d7", "html_url": "https://github.com/rust-lang/rust/commit/8fe83028870ac6ac48e99a38d2992bedc26ec0d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe83028870ac6ac48e99a38d2992bedc26ec0d7/comments", "author": null, "committer": null, "parents": [{"sha": "30ab96b27229000d3754e7dee64fc431b5105150", "url": "https://api.github.com/repos/rust-lang/rust/commits/30ab96b27229000d3754e7dee64fc431b5105150", "html_url": "https://github.com/rust-lang/rust/commit/30ab96b27229000d3754e7dee64fc431b5105150"}], "stats": {"total": 78, "additions": 45, "deletions": 33}, "files": [{"sha": "d8f723d9c78012f8e5721092d98dd81c58c07d52", "filename": "src/libstd/str.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8fe83028870ac6ac48e99a38d2992bedc26ec0d7/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe83028870ac6ac48e99a38d2992bedc26ec0d7/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8fe83028870ac6ac48e99a38d2992bedc26ec0d7", "patch": "@@ -23,7 +23,7 @@ use clone::Clone;\n use container::{Container, Mutable};\n use iter::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n-use iterator::{Filter, AdditiveIterator, Map};\n+use iterator::{Filter, AdditiveIterator, Map, Enumerate};\n use iterator::{Invert, DoubleEndedIterator};\n use libc;\n use num::{Saturating, Zero};\n@@ -359,9 +359,18 @@ pub type ByteIterator<'self> =\n /// Use with the `std::iterator` module.\n pub type ByteRevIterator<'self> = Invert<ByteIterator<'self>>;\n \n+/// An iterator over byte index and either &u8 or char\n+#[deriving(Clone)]\n+enum OffsetIterator<'self> {\n+    // use ByteIterator here when it can be cloned\n+    ByteOffset(Enumerate<vec::VecIterator<'self, u8>>),\n+    CharOffset(CharOffsetIterator<'self>),\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n pub struct CharSplitIterator<'self,Sep> {\n+    priv iter: OffsetIterator<'self>,\n     priv string: &'self str,\n     priv position: uint,\n     priv sep: Sep,\n@@ -370,7 +379,6 @@ pub struct CharSplitIterator<'self,Sep> {\n     /// Whether an empty string at the end is allowed\n     priv allow_trailing_empty: bool,\n     priv finished: bool,\n-    priv only_ascii: bool\n }\n \n /// An iterator over the words of a string, separated by an sequence of whitespace\n@@ -386,39 +394,39 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep>\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n \n-        let l = self.string.len();\n         let start = self.position;\n-\n-        if self.only_ascii {\n-            // this gives a *huge* speed up for splitting on ASCII\n-            // characters (e.g. '\\n' or ' ')\n-            while self.position < l && self.count > 0 {\n-                let byte = self.string[self.position];\n-\n-                if self.sep.matches(byte as char) {\n-                    let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n-                    self.position += 1;\n-                    self.count -= 1;\n-                    return Some(slice);\n-                }\n-                self.position += 1;\n-            }\n-        } else {\n-            while self.position < l && self.count > 0 {\n-                let CharRange {ch, next} = self.string.char_range_at(self.position);\n-\n-                if self.sep.matches(ch) {\n-                    let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n-                    self.position = next;\n-                    self.count -= 1;\n-                    return Some(slice);\n-                }\n-                self.position = next;\n+        let len = self.string.len();\n+\n+        if self.count > 0 {\n+            match self.iter {\n+                // this gives a *huge* speed up for splitting on ASCII\n+                // characters (e.g. '\\n' or ' ')\n+                ByteOffset(ref mut iter) =>\n+                    for (idx, &byte) in *iter {\n+                        if self.sep.matches(byte as char) {\n+                            self.position = idx + 1;\n+                            self.count -= 1;\n+                            return Some(unsafe {\n+                                raw::slice_bytes(self.string, start, idx)\n+                            })\n+                        }\n+                    },\n+                CharOffset(ref mut iter) =>\n+                    for (idx, ch) in *iter {\n+                        if self.sep.matches(ch) {\n+                            // skip over the separator\n+                            self.position = self.string.char_range_at(idx).next;\n+                            self.count -= 1;\n+                            return Some(unsafe {\n+                                raw::slice_bytes(self.string, start, idx)\n+                            })\n+                        }\n+                    },\n             }\n         }\n         self.finished = true;\n-        if self.allow_trailing_empty || start < l {\n-            Some(unsafe { raw::slice_bytes(self.string, start, l) })\n+        if self.allow_trailing_empty || start < len {\n+            Some(unsafe { raw::slice_bytes(self.string, start, len) })\n         } else {\n             None\n         }\n@@ -1327,15 +1335,19 @@ impl<'self> StrSlice<'self> for &'self str {\n     #[inline]\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n         -> CharSplitIterator<'self, Sep> {\n-        let only_ascii = sep.only_ascii();\n+        let iter = if sep.only_ascii() {\n+            ByteOffset(self.as_bytes().iter().enumerate())\n+        } else {\n+            CharOffset(self.char_offset_iter())\n+        };\n         CharSplitIterator {\n+            iter: iter,\n             string: *self,\n             position: 0,\n             sep: sep,\n             count: count,\n             allow_trailing_empty: allow_trailing_empty,\n             finished: false,\n-            only_ascii: only_ascii\n         }\n     }\n "}]}