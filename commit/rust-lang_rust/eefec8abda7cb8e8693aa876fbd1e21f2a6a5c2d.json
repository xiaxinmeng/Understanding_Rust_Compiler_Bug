{"sha": "eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZmVjOGFiZGE3Y2I4ZTg2OTNhYTg3NmZiZDFlMjFmMmE2YTVjMmQ=", "commit": {"author": {"name": "Miguel Ojeda", "email": "ojeda@kernel.org", "date": "2021-02-24T04:48:44Z"}, "committer": {"name": "Miguel Ojeda", "email": "ojeda@kernel.org", "date": "2021-02-24T05:13:42Z"}, "message": "library: Normalize safety-for-unsafe-block comments\n\nAlmost all safety comments are of the form `// SAFETY:`,\nso normalize the rest and fix a few of them that should\nhave been a `/// # Safety` section instead.\n\nFurthermore, make `tidy` only allow the uppercase form. While\ncurrently `tidy` only checks `core`, it is a good idea to prevent\n`core` from drifting to non-uppercase comments, so that later\nwe can start checking `alloc` etc. too.\n\nSigned-off-by: Miguel Ojeda <ojeda@kernel.org>", "tree": {"sha": "967ee057ebe74460adc39e7853d4ed4a9e23c47e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967ee057ebe74460adc39e7853d4ed4a9e23c47e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "html_url": "https://github.com/rust-lang/rust/commit/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/comments", "author": {"login": "ojeda", "id": 1054456, "node_id": "MDQ6VXNlcjEwNTQ0NTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1054456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ojeda", "html_url": "https://github.com/ojeda", "followers_url": "https://api.github.com/users/ojeda/followers", "following_url": "https://api.github.com/users/ojeda/following{/other_user}", "gists_url": "https://api.github.com/users/ojeda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ojeda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ojeda/subscriptions", "organizations_url": "https://api.github.com/users/ojeda/orgs", "repos_url": "https://api.github.com/users/ojeda/repos", "events_url": "https://api.github.com/users/ojeda/events{/privacy}", "received_events_url": "https://api.github.com/users/ojeda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ojeda", "id": 1054456, "node_id": "MDQ6VXNlcjEwNTQ0NTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1054456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ojeda", "html_url": "https://github.com/ojeda", "followers_url": "https://api.github.com/users/ojeda/followers", "following_url": "https://api.github.com/users/ojeda/following{/other_user}", "gists_url": "https://api.github.com/users/ojeda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ojeda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ojeda/subscriptions", "organizations_url": "https://api.github.com/users/ojeda/orgs", "repos_url": "https://api.github.com/users/ojeda/repos", "events_url": "https://api.github.com/users/ojeda/events{/privacy}", "received_events_url": "https://api.github.com/users/ojeda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "html_url": "https://github.com/rust-lang/rust/commit/fe1bf8e05c39bdcc73fc09e246b7209444e389bc"}], "stats": {"total": 45, "additions": 26, "deletions": 19}, "files": [{"sha": "941f82a8070a02e1861c23d57a567c4d2993ed4e", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -278,14 +278,14 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         let out_ptr = match self.handle.insert_recursing(self.key, value) {\n             (Fit(_), val_ptr) => {\n-                // Safety: We have consumed self.handle and the handle returned.\n+                // SAFETY: We have consumed self.handle and the handle returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 map.length += 1;\n                 val_ptr\n             }\n             (Split(ins), val_ptr) => {\n                 drop(ins.left);\n-                // Safety: We have consumed self.handle and the reference returned.\n+                // SAFETY: We have consumed self.handle and the reference returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 let root = map.root.as_mut().unwrap();\n                 root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);"}, {"sha": "b1b2619428366fbfcb18d19a9432a0884d83aa0f", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -1938,13 +1938,13 @@ impl<T, A: Allocator> Vec<T, A> {\n     pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n         let ptr = self.as_mut_ptr();\n \n-        // Safety:\n+        // SAFETY:\n         // - `ptr` is guaranteed to be in bounds for `capacity` elements\n         // - `len` is guaranteed to less or equal to `capacity`\n         // - `MaybeUninit<T>` has the same layout as `T`\n         let spare_ptr = unsafe { ptr.cast::<MaybeUninit<T>>().add(self.len) };\n \n-        // Safety:\n+        // SAFETY:\n         // - `ptr` is guaranteed to be valid for `len` elements\n         // - `spare_ptr` is offseted from `ptr` by `len`, so it doesn't overlap `initialized` slice\n         unsafe {\n@@ -2154,7 +2154,8 @@ pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<\n }\n \n trait ExtendFromWithinSpec {\n-    /// Safety:\n+    /// # Safety\n+    ///\n     /// - `src` needs to be valid index\n     /// - `self.capacity() - self.len()` must be `>= src.len()`\n     unsafe fn spec_extend_from_within(&mut self, src: Range<usize>);\n@@ -2165,14 +2166,14 @@ impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         let initialized = {\n             let (this, spare) = self.split_at_spare_mut();\n \n-            // Safety:\n+            // SAFETY:\n             // - caller guaratees that src is a valid index\n             let to_clone = unsafe { this.get_unchecked(src) };\n \n             to_clone.iter().cloned().zip(spare.iter_mut()).map(|(e, s)| s.write(e)).count()\n         };\n \n-        // Safety:\n+        // SAFETY:\n         // - elements were just initialized\n         unsafe {\n             let new_len = self.len() + initialized;\n@@ -2187,11 +2188,11 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         {\n             let (init, spare) = self.split_at_spare_mut();\n \n-            // Safety:\n+            // SAFETY:\n             // - caller guaratees that `src` is a valid index\n             let source = unsafe { init.get_unchecked(src) };\n \n-            // Safety:\n+            // SAFETY:\n             // - Both pointers are created from unique slice references (`&mut [_]`)\n             //   so they are valid and do not overlap.\n             // - Elements are :Copy so it's OK to to copy them, without doing\n@@ -2203,7 +2204,7 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n             unsafe { ptr::copy_nonoverlapping(source.as_ptr(), spare.as_mut_ptr() as _, count) };\n         }\n \n-        // Safety:\n+        // SAFETY:\n         // - The elements were just initialized by `copy_nonoverlapping`\n         self.len += count;\n     }"}, {"sha": "eb60df214c489cff2d420e15b68f811cdbdd2d22", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -106,7 +106,7 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n                     Ok(0) => return Ok(len), // EOF reached\n                     Ok(bytes_read) => {\n                         assert!(bytes_read <= spare_cap.len());\n-                        // Safety: The initializer contract guarantees that either it or `read`\n+                        // SAFETY: The initializer contract guarantees that either it or `read`\n                         // will have initialized these bytes. And we just checked that the number\n                         // of bytes is within the buffer capacity.\n                         unsafe { buf.set_len(buf.len() + bytes_read) };"}, {"sha": "aec2a2aa639edc799f2d87fff6535e595a984dff", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -440,13 +440,17 @@ impl<T> SyncOnceCell<T> {\n         res\n     }\n \n-    /// Safety: The value must be initialized\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n     unsafe fn get_unchecked(&self) -> &T {\n         debug_assert!(self.is_initialized());\n         (&*self.value.get()).assume_init_ref()\n     }\n \n-    /// Safety: The value must be initialized\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n     unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n         debug_assert!(self.is_initialized());\n         (&mut *self.value.get()).assume_init_mut()\n@@ -456,7 +460,7 @@ impl<T> SyncOnceCell<T> {\n unsafe impl<#[may_dangle] T> Drop for SyncOnceCell<T> {\n     fn drop(&mut self) {\n         if self.is_initialized() {\n-            // Safety: The cell is initialized and being dropped, so it can't\n+            // SAFETY: The cell is initialized and being dropped, so it can't\n             // be accessed again. We also don't touch the `T` other than\n             // dropping it, which validates our usage of #[may_dangle].\n             unsafe { (&mut *self.value.get()).assume_init_drop() };"}, {"sha": "b8f512f6a232fc88fdf64fd3b2eb05fa1f3441f6", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -8,7 +8,9 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n-// Safety: `bytes` must be a valid wtf8 encoded slice\n+/// # Safety\n+///\n+/// `bytes` must be a valid wtf8 encoded slice\n #[inline]\n unsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n     // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n@@ -130,7 +132,7 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n             // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n             let path = &path.bytes()[separator_end..];\n \n-            // Safety: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n+            // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n             // is encoded in a single byte, therefore `bytes[separator_start]` and\n             // `bytes[separator_end]` must be code point boundaries and thus\n             // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices."}, {"sha": "70b31b19f824cb16eda7030a235fc7de88d3f4c5", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -103,7 +103,7 @@ impl StaticRWLock {\n     /// The lock is automatically unlocked when the returned guard is dropped.\n     #[inline]\n     pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n-        // Safety: All methods require static references, therefore self\n+        // SAFETY: All methods require static references, therefore self\n         // cannot be moved between invocations.\n         unsafe {\n             self.0.read();\n@@ -117,7 +117,7 @@ impl StaticRWLock {\n     /// The lock is automatically unlocked when the returned guard is dropped.\n     #[inline]\n     pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n-        // Safety: All methods require static references, therefore self\n+        // SAFETY: All methods require static references, therefore self\n         // cannot be moved between invocations.\n         unsafe {\n             self.0.write();"}, {"sha": "75c43343023f9a08ece28e7e1dfdbf092c9d8c73", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=eefec8abda7cb8e8693aa876fbd1e21f2a6a5c2d", "patch": "@@ -289,7 +289,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     suppressible_tidy_err!(err, skip_undocumented_unsafe, \"undocumented unsafe\");\n                 }\n             }\n-            if line.contains(\"// SAFETY:\") || line.contains(\"// Safety:\") {\n+            if line.contains(\"// SAFETY:\") {\n                 last_safety_comment = true;\n             } else if line.trim().starts_with(\"//\") || line.trim().is_empty() {\n                 // keep previous value"}]}