{"sha": "65f96e2b53369f6b403b655b2212272c2ae13d42", "node_id": "C_kwDOAAsO6NoAKDY1Zjk2ZTJiNTMzNjlmNmI0MDNiNjU1YjIyMTIyNzJjMmFlMTNkNDI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-19T22:56:42Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-03-15T18:18:05Z"}, "message": "Rework `undocumented_unsafe_blocks`", "tree": {"sha": "461c65015b29f837e557ba68fc87bee0559fd8f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461c65015b29f837e557ba68fc87bee0559fd8f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65f96e2b53369f6b403b655b2212272c2ae13d42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65f96e2b53369f6b403b655b2212272c2ae13d42", "html_url": "https://github.com/rust-lang/rust/commit/65f96e2b53369f6b403b655b2212272c2ae13d42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65f96e2b53369f6b403b655b2212272c2ae13d42/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc5423ad448877e33cca28db2f1445c9c4473c75", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5423ad448877e33cca28db2f1445c9c4473c75", "html_url": "https://github.com/rust-lang/rust/commit/dc5423ad448877e33cca28db2f1445c9c4473c75"}], "stats": {"total": 470, "additions": 208, "deletions": 262}, "files": [{"sha": "49fc82c0ac7a5b32e98de14e331602f82702bdf3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65f96e2b53369f6b403b655b2212272c2ae13d42/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f96e2b53369f6b403b655b2212272c2ae13d42/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=65f96e2b53369f6b403b655b2212272c2ae13d42", "patch": "@@ -1,5 +1,6 @@\n // error-pattern:cargo-clippy\n \n+#![feature(array_windows)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n@@ -846,7 +847,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             enable_raw_pointer_heuristic_for_send,\n         ))\n     });\n-    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks::default()));\n+    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n     store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n     store.register_late_pass(move || Box::new(format_args::FormatArgs));\n     store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));"}, {"sha": "59c3d42b3538a921456574e5957f3a23c90f4507", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 113, "deletions": 168, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/65f96e2b53369f6b403b655b2212272c2ae13d42/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f96e2b53369f6b403b655b2212272c2ae13d42/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=65f96e2b53369f6b403b655b2212272c2ae13d42", "patch": "@@ -1,16 +1,13 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_lint_allowed;\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, HirId, Local, UnsafeSource};\n-use rustc_lexer::TokenKind;\n-use rustc_lint::{LateContext, LateLintPass};\n+use clippy_utils::source::walk_span_to_context;\n+use rustc_hir::{Block, BlockCheckMode, UnsafeSource};\n+use rustc_lexer::{tokenize, TokenKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{BytePos, Span};\n-use std::borrow::Cow;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Pos, SyntaxContext};\n+use std::rc::Rc;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -44,179 +41,127 @@ declare_clippy_lint! {\n     \"creating an unsafe block without explaining why it is safe\"\n }\n \n-impl_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n-\n-#[derive(Default)]\n-pub struct UndocumentedUnsafeBlocks {\n-    pub local_level: u32,\n-    pub local_span: Option<Span>,\n-    // The local was already checked for an overall safety comment\n-    // There is no need to continue checking the blocks in the local\n-    pub local_checked: bool,\n-    // Since we can only check the blocks from expanded macros\n-    // We have to omit the suggestion due to the actual definition\n-    // Not being available to us\n-    pub macro_expansion: bool,\n-}\n+declare_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n \n impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n     fn check_block(&mut self, cx: &LateContext<'_>, block: &'_ Block<'_>) {\n-        if_chain! {\n-            if !self.local_checked;\n-            if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id);\n-            if !in_external_macro(cx.tcx.sess, block.span);\n-            if let BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) = block.rules;\n-            if let Some(enclosing_scope_hir_id) = cx.tcx.hir().get_enclosing_scope(block.hir_id);\n-            if self.block_has_safety_comment(cx.tcx, enclosing_scope_hir_id, block.span) == Some(false);\n-            then {\n-                let mut span = block.span;\n-\n-                if let Some(local_span) = self.local_span {\n-                    span = local_span;\n-\n-                    let result = self.block_has_safety_comment(cx.tcx, enclosing_scope_hir_id, span);\n-\n-                    if result.unwrap_or(true) {\n-                        self.local_checked = true;\n-                        return;\n-                    }\n-                }\n-\n-                self.lint(cx, span);\n-            }\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'_>, local: &'_ Local<'_>) {\n-        if_chain! {\n-            if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, local.hir_id);\n-            if !in_external_macro(cx.tcx.sess, local.span);\n-            if let Some(init) = local.init;\n-            then {\n-                self.visit_expr(init);\n-\n-                if self.local_level > 0 {\n-                    self.local_span = Some(local.span);\n-                }\n-            }\n-        }\n-    }\n+        if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n+            && !in_external_macro(cx.tcx.sess, block.span)\n+            && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id)\n+            && !block_has_safety_comment(cx, block)\n+        {\n+            let source_map = cx.tcx.sess.source_map();\n+            let span = if source_map.is_multiline(block.span) {\n+                source_map.span_until_char(block.span, '\\n')\n+            } else {\n+                block.span\n+            };\n \n-    fn check_block_post(&mut self, _: &LateContext<'_>, _: &'_ Block<'_>) {\n-        self.local_level = self.local_level.saturating_sub(1);\n-\n-        if self.local_level == 0 {\n-            self.local_checked = false;\n-            self.local_span = None;\n+            span_lint_and_help(\n+                cx,\n+                UNDOCUMENTED_UNSAFE_BLOCKS,\n+                span,\n+                \"unsafe block missing a safety comment\",\n+                None,\n+                \"consider adding a safety comment on the preceding line\",\n+            );\n         }\n     }\n }\n \n-impl<'v> Visitor<'v> for UndocumentedUnsafeBlocks {\n-    fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n-        match ex.kind {\n-            ExprKind::Block(_, _) => self.local_level = self.local_level.saturating_add(1),\n-            _ => walk_expr(self, ex),\n+/// Checks if the lines immediately preceding the block contain a safety comment.\n+fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+    // This intentionally ignores text before the start of a function so something like:\n+    // ```\n+    //     // SAFETY: reason\n+    //     fn foo() { unsafe { .. } }\n+    // ```\n+    // won't work. This is to avoid dealing with where such a comment should be place relative to\n+    // attributes and doc comments.\n+\n+    let source_map = cx.sess().source_map();\n+    let ctxt = block.span.ctxt();\n+    if ctxt != SyntaxContext::root() {\n+        // From a macro expansion. Get the text from the start of the macro declaration to start of the unsafe block.\n+        //     macro_rules! foo { () => { stuff }; (x) => { unsafe { stuff } }; }\n+        //     ^--------------------------------------------^\n+        if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+            && let Ok(macro_line) = source_map.lookup_line(ctxt.outer_expn_data().def_site.lo())\n+            && Rc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            macro_line.line < unsafe_line.line && text_has_safety_comment(\n+                src,\n+                &unsafe_line.sf.lines[macro_line.line + 1..=unsafe_line.line],\n+                unsafe_line.sf.start_pos.to_usize(),\n+            )\n+        } else {\n+            // Problem getting source text. Pretend a comment was found.\n+            true\n         }\n+    } else if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+        && let Some(body) = cx.enclosing_body\n+        && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n+        && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n+        && Rc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n+        && let Some(src) = unsafe_line.sf.src.as_deref()\n+    {\n+        // Get the text from the start of function body to the unsafe block.\n+        //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n+        //              ^-------------^\n+        body_line.line < unsafe_line.line && text_has_safety_comment(\n+            src,\n+            &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n+            unsafe_line.sf.start_pos.to_usize(),\n+        )\n+    } else {\n+        // Problem getting source text. Pretend a comment was found.\n+        true\n     }\n }\n \n-impl UndocumentedUnsafeBlocks {\n-    fn block_has_safety_comment(&mut self, tcx: TyCtxt<'_>, enclosing_hir_id: HirId, block_span: Span) -> Option<bool> {\n-        let map = tcx.hir();\n-        let source_map = tcx.sess.source_map();\n-\n-        let enclosing_scope_span = map.opt_span(enclosing_hir_id)?;\n-\n-        let between_span = if block_span.from_expansion() {\n-            self.macro_expansion = true;\n-            enclosing_scope_span.with_hi(block_span.hi()).source_callsite()\n-        } else {\n-            self.macro_expansion = false;\n-            enclosing_scope_span.to(block_span).source_callsite()\n-        };\n-\n-        let file_name = source_map.span_to_filename(between_span);\n-        let source_file = source_map.get_source_file(&file_name)?;\n-\n-        let lex_start = (between_span.lo().0 - source_file.start_pos.0 + 1) as usize;\n-        let lex_end = (between_span.hi().0 - source_file.start_pos.0) as usize;\n-        let src_str = source_file.src.as_ref()?[lex_start..lex_end].to_string();\n-\n-        let source_start_pos = source_file.start_pos.0 as usize + lex_start;\n-\n-        let mut pos = 0;\n-        let mut comment = false;\n-\n-        for token in rustc_lexer::tokenize(&src_str) {\n-            match token.kind {\n-                TokenKind::LineComment { doc_style: None }\n-                | TokenKind::BlockComment {\n-                    doc_style: None,\n-                    terminated: true,\n-                } => {\n-                    let comment_str = src_str[pos + 2..pos + token.len].to_ascii_uppercase();\n-\n-                    if comment_str.contains(\"SAFETY:\") {\n-                        comment = true;\n-                    }\n-                },\n-                // We need to add all whitespace to `pos` before checking the comment's line number\n-                TokenKind::Whitespace => {},\n-                _ => {\n-                    if comment {\n-                        // Get the line number of the \"comment\" (really wherever the trailing whitespace ended)\n-                        let comment_line_num = source_file\n-                            .lookup_file_pos(BytePos((source_start_pos + pos).try_into().unwrap()))\n-                            .0;\n-                        // Find the block/local's line number\n-                        let block_line_num = tcx.sess.source_map().lookup_char_pos(block_span.lo()).line;\n-\n-                        // Check the comment is immediately followed by the block/local\n-                        if block_line_num == comment_line_num + 1 || block_line_num == comment_line_num {\n-                            return Some(true);\n-                        }\n-\n-                        comment = false;\n-                    }\n-                },\n+/// Checks if the given text has a safety comment for the immediately proceeding line.\n+fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) -> bool {\n+    let mut lines = line_starts\n+        .array_windows::<2>()\n+        .rev()\n+        .map_while(|[start, end]| {\n+            src.get(start.to_usize() - offset..end.to_usize() - offset)\n+                .map(|text| (start.to_usize(), text.trim_start()))\n+        })\n+        .filter(|(_, text)| !text.is_empty());\n+\n+    let Some((line_start, line)) = lines.next() else {\n+        return false;\n+    };\n+    // Check for a sequence of line comments.\n+    if line.starts_with(\"//\") {\n+        let mut line = line;\n+        loop {\n+            if line.to_ascii_uppercase().contains(\"SAFETY:\") {\n+                return true;\n+            }\n+            match lines.next() {\n+                Some((_, x)) if x.starts_with(\"//\") => line = x,\n+                _ => return false,\n             }\n-\n-            pos += token.len;\n         }\n-\n-        Some(false)\n     }\n-\n-    fn lint(&self, cx: &LateContext<'_>, mut span: Span) {\n-        let source_map = cx.tcx.sess.source_map();\n-\n-        if source_map.is_multiline(span) {\n-            span = source_map.span_until_char(span, '\\n');\n+    // No line comments; look for the start of a block comment.\n+    // This will only find them if they are at the start of a line.\n+    let (mut line_start, mut line) = (line_start, line);\n+    loop {\n+        if line.starts_with(\"/*\") {\n+            let src = src[line_start..line_starts.last().unwrap().to_usize()].trim_start();\n+            let mut tokens = tokenize(src);\n+            return src[..tokens.next().unwrap().len]\n+                .to_ascii_uppercase()\n+                .contains(\"SAFETY:\")\n+                && tokens.all(|t| t.kind == TokenKind::Whitespace);\n         }\n-\n-        if self.macro_expansion {\n-            span_lint_and_help(\n-                cx,\n-                UNDOCUMENTED_UNSAFE_BLOCKS,\n-                span,\n-                \"unsafe block in macro expansion missing a safety comment\",\n-                None,\n-                \"consider adding a safety comment in the macro definition\",\n-            );\n-        } else {\n-            let block_indent = indent_of(cx, span);\n-            let suggestion = format!(\"// SAFETY: ...\\n{}\", snippet(cx, span, \"..\"));\n-\n-            span_lint_and_sugg(\n-                cx,\n-                UNDOCUMENTED_UNSAFE_BLOCKS,\n-                span,\n-                \"unsafe block missing a safety comment\",\n-                \"consider adding a safety comment\",\n-                reindent_multiline(Cow::Borrowed(&suggestion), true, block_indent).to_string(),\n-                Applicability::HasPlaceholders,\n-            );\n+        match lines.next() {\n+            Some(x) => (line_start, line) = x,\n+            None => return false,\n         }\n     }\n }"}, {"sha": "1a33e647588f19ea3c6c678285c23ae9e483b57c", "filename": "tests/ui/crashes/ice-7868.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65f96e2b53369f6b403b655b2212272c2ae13d42/tests%2Fui%2Fcrashes%2Fice-7868.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65f96e2b53369f6b403b655b2212272c2ae13d42/tests%2Fui%2Fcrashes%2Fice-7868.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7868.stderr?ref=65f96e2b53369f6b403b655b2212272c2ae13d42", "patch": "@@ -5,11 +5,7 @@ LL |     unsafe { 0 };\n    |     ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::undocumented-unsafe-blocks` implied by `-D warnings`\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL ~     unsafe { 0 };\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: aborting due to previous error\n "}, {"sha": "fcfb49dcdd4497ba8d729a1266506ecd028bedb5", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/65f96e2b53369f6b403b655b2212272c2ae13d42/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f96e2b53369f6b403b655b2212272c2ae13d42/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=65f96e2b53369f6b403b655b2212272c2ae13d42", "patch": "@@ -89,11 +89,6 @@ fn block_comment_newlines() {\n     unsafe {}\n }\n \n-#[rustfmt::skip]\n-fn inline_block_comment() {\n-    /* Safety: */unsafe {}\n-}\n-\n fn block_comment_with_extras() {\n     /* This is a description\n      * SAFETY:\n@@ -209,6 +204,43 @@ fn local_nest() {\n     let _ = [(42, unsafe {}, unsafe {}), (52, unsafe {}, unsafe {})];\n }\n \n+fn in_fn_call(x: *const u32) {\n+    fn f(x: u32) {}\n+\n+    // Safety: reason\n+    f(unsafe { *x });\n+}\n+\n+fn multi_in_fn_call(x: *const u32) {\n+    fn f(x: u32, y: u32) {}\n+\n+    // Safety: reason\n+    f(unsafe { *x }, unsafe { *x });\n+}\n+\n+fn in_multiline_fn_call(x: *const u32) {\n+    fn f(x: u32, y: u32) {}\n+\n+    f(\n+        // Safety: reason\n+        unsafe { *x },\n+        0,\n+    );\n+}\n+\n+fn in_macro_call(x: *const u32) {\n+    // Safety: reason\n+    println!(\"{}\", unsafe { *x });\n+}\n+\n+fn in_multiline_macro_call(x: *const u32) {\n+    println!(\n+        \"{}\",\n+        // Safety: reason\n+        unsafe { *x },\n+    );\n+}\n+\n // Invalid comments\n \n fn no_comment() {"}, {"sha": "4f5c1111c7e373fb490744fc4a7233ac144e931d", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 55, "deletions": 83, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/65f96e2b53369f6b403b655b2212272c2ae13d42/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65f96e2b53369f6b403b655b2212272c2ae13d42/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=65f96e2b53369f6b403b655b2212272c2ae13d42", "patch": "@@ -1,171 +1,143 @@\n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:215:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:247:5\n    |\n LL |     unsafe {}\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::undocumented-unsafe-blocks` implied by `-D warnings`\n-help: consider adding a safety comment\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:251:14\n    |\n-LL ~     // SAFETY: ...\n-LL +     unsafe {}\n+LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+   |              ^^^^^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:219:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:251:29\n    |\n LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^^^^^^^^^^^^^\n    |\n-help: consider adding a safety comment\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:251:48\n    |\n-LL ~     // SAFETY: ...\n-LL +     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+   |                                                ^^^^^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:223:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:255:18\n    |\n LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:255:37\n    |\n-LL ~     // SAFETY: ...\n-LL +     let _ = (42, unsafe {}, \"test\", unsafe {});\n+LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n+   |                                     ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:227:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:259:14\n    |\n LL |     let _ = *unsafe { &42 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = *unsafe { &42 };\n+   |              ^^^^^^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:232:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:264:19\n    |\n LL |     let _ = match unsafe {} {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = match unsafe {} {\n+   |                   ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:238:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:270:14\n    |\n LL |     let _ = &unsafe {};\n-   |     ^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = &unsafe {};\n+   |              ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:242:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:274:14\n    |\n LL |     let _ = [unsafe {}; 5];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = [unsafe {}; 5];\n+   |              ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:246:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:278:13\n    |\n LL |     let _ = unsafe {};\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     let _ = unsafe {};\n+   |             ^^^^^^^^^\n    |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:256:8\n+  --> $DIR/undocumented_unsafe_blocks.rs:288:8\n    |\n LL |     t!(unsafe {});\n    |        ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     t!(// SAFETY: ...\n-LL ~     unsafe {});\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n-error: unsafe block in macro expansion missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:262:13\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:294:13\n    |\n LL |             unsafe {}\n    |             ^^^^^^^^^\n ...\n LL |     t!();\n    |     ---- in this macro invocation\n    |\n-   = help: consider adding a safety comment in the macro definition\n+   = help: consider adding a safety comment on the preceding line\n    = note: this error originates in the macro `t` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:270:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:302:5\n    |\n LL |     unsafe {} // SAFETY:\n    |     ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL ~     unsafe {} // SAFETY:\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:274:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:306:5\n    |\n LL |     unsafe {\n    |     ^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL +     unsafe {\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:284:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:316:5\n    |\n LL |     unsafe {};\n    |     ^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     // SAFETY: ...\n-LL ~     unsafe {};\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:288:20\n+  --> $DIR/undocumented_unsafe_blocks.rs:320:20\n    |\n LL |     println!(\"{}\", unsafe { String::from_utf8_unchecked(vec![]) });\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: consider adding a safety comment\n-   |\n-LL ~     println!(\"{}\", // SAFETY: ...\n-LL ~     unsafe { String::from_utf8_unchecked(vec![]) });\n-   |\n+   = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 17 previous errors\n "}]}