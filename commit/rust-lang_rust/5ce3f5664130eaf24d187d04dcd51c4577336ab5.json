{"sha": "5ce3f5664130eaf24d187d04dcd51c4577336ab5", "node_id": "C_kwDOAAsO6NoAKDVjZTNmNTY2NDEzMGVhZjI0ZDE4N2QwNGRjZDUxYzQ1NzczMzZhYjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-12-05T04:51:36Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-28T00:20:18Z"}, "message": "Make deref suggestion better", "tree": {"sha": "73ee3b4dba7f39de73082fd8c8f6ac87ecd2d5b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73ee3b4dba7f39de73082fd8c8f6ac87ecd2d5b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ce3f5664130eaf24d187d04dcd51c4577336ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce3f5664130eaf24d187d04dcd51c4577336ab5", "html_url": "https://github.com/rust-lang/rust/commit/5ce3f5664130eaf24d187d04dcd51c4577336ab5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ce3f5664130eaf24d187d04dcd51c4577336ab5/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a705566166debf5eff88c57140df607fa409aaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a705566166debf5eff88c57140df607fa409aaa", "html_url": "https://github.com/rust-lang/rust/commit/6a705566166debf5eff88c57140df607fa409aaa"}], "stats": {"total": 274, "additions": 214, "deletions": 60}, "files": [{"sha": "47fc4b66833688abe0794d7047df173d2e6887e7", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-    ) -> Option<(Span, &'static str, String, Applicability, bool /* verbose */)> {\n+    ) -> Option<(Span, String, String, Applicability, bool /* verbose */)> {\n         let sess = self.sess();\n         let sp = expr.span;\n \n@@ -593,7 +593,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let pos = sp.lo() + BytePos(1);\n                                 return Some((\n                                     sp.with_hi(pos),\n-                                    \"consider removing the leading `b`\",\n+                                    \"consider removing the leading `b`\".to_string(),\n                                     String::new(),\n                                     Applicability::MachineApplicable,\n                                     true,\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some() {\n                                 return Some((\n                                     sp.shrink_to_lo(),\n-                                    \"consider adding a leading `b`\",\n+                                    \"consider adding a leading `b`\".to_string(),\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n@@ -669,7 +669,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n                             return Some((\n                                 sugg.0,\n-                                sugg.1,\n+                                sugg.1.to_string(),\n                                 sugg.2,\n                                 Applicability::MachineApplicable,\n                                 false,\n@@ -697,7 +697,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     return Some((\n                                         left_expr.span.shrink_to_lo(),\n                                         \"consider dereferencing here to assign to the mutable \\\n-                                         borrowed piece of memory\",\n+                                         borrowed piece of memory\"\n+                                            .to_string(),\n                                         \"*\".to_string(),\n                                         Applicability::MachineApplicable,\n                                         true,\n@@ -709,14 +710,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         return Some(match mutability {\n                             hir::Mutability::Mut => (\n                                 sp,\n-                                \"consider mutably borrowing here\",\n+                                \"consider mutably borrowing here\".to_string(),\n                                 format!(\"{}&mut {}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n-                                \"consider borrowing here\",\n+                                \"consider borrowing here\".to_string(),\n                                 format!(\"{}&{}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n@@ -745,7 +746,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if sm.span_to_snippet(call_span).is_ok() {\n                             return Some((\n                                 sp.with_hi(call_span.lo()),\n-                                \"consider removing the borrow\",\n+                                \"consider removing the borrow\".to_string(),\n                                 String::new(),\n                                 Applicability::MachineApplicable,\n                                 true,\n@@ -758,7 +759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if sm.span_to_snippet(expr.span).is_ok() {\n                         return Some((\n                             sp.with_hi(expr.span.lo()),\n-                            \"consider removing the borrow\",\n+                            \"consider removing the borrow\".to_string(),\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n@@ -824,7 +825,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } {\n                                 return Some((\n                                     span,\n-                                    \"consider dereferencing\",\n+                                    \"consider dereferencing\".to_string(),\n                                     src,\n                                     applicability,\n                                     true,\n@@ -835,60 +836,93 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             _ if sp == expr.span => {\n-                if let Some(steps) = self.deref_steps(checked_ty, expected) {\n-                    let expr = expr.peel_blocks();\n+                if let Some(mut steps) = self.deref_steps(checked_ty, expected) {\n+                    let mut expr = expr.peel_blocks();\n+                    let mut prefix_span = expr.span.shrink_to_lo();\n+                    let mut remove = String::new();\n \n-                    if steps == 1 {\n+                    // Try peeling off any existing `&` and `&mut` to reach our target type\n+                    while steps > 0 {\n                         if let hir::ExprKind::AddrOf(_, mutbl, inner) = expr.kind {\n                             // If the expression has `&`, removing it would fix the error\n-                            let prefix_span = expr.span.with_hi(inner.span.lo());\n-                            let message = match mutbl {\n-                                hir::Mutability::Not => \"consider removing the `&`\",\n-                                hir::Mutability::Mut => \"consider removing the `&mut`\",\n+                            prefix_span = prefix_span.with_hi(inner.span.lo());\n+                            expr = inner;\n+                            remove += match mutbl {\n+                                hir::Mutability::Not => \"&\",\n+                                hir::Mutability::Mut => \"&mut \",\n                             };\n-                            let suggestion = String::new();\n-                            return Some((\n-                                prefix_span,\n-                                message,\n-                                suggestion,\n-                                Applicability::MachineApplicable,\n-                                false,\n-                            ));\n+                            steps -= 1;\n+                        } else {\n+                            break;\n                         }\n-\n-                        // For this suggestion to make sense, the type would need to be `Copy`,\n-                        // or we have to be moving out of a `Box<T>`\n-                        if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n-                            || checked_ty.is_box()\n-                        {\n-                            let message = if checked_ty.is_box() {\n-                                \"consider unboxing the value\"\n-                            } else if checked_ty.is_region_ptr() {\n-                                \"consider dereferencing the borrow\"\n-                            } else {\n-                                \"consider dereferencing the type\"\n-                            };\n-                            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                                Some(ident) => format!(\"{}: \", ident),\n-                                None => String::new(),\n-                            };\n-                            let (span, suggestion) = if self.is_else_if_block(expr) {\n-                                // Don't suggest nonsense like `else *if`\n-                                return None;\n-                            } else if let Some(expr) = self.maybe_get_block_expr(expr) {\n-                                // prefix should be empty here..\n-                                (expr.span.shrink_to_lo(), \"*\".to_string())\n+                    }\n+                    // If we've reached our target type with just removing `&`, then just print now.\n+                    if steps == 0 {\n+                        return Some((\n+                            prefix_span,\n+                            format!(\"consider removing the `{}`\", remove.trim()),\n+                            String::new(),\n+                            // Do not remove `&&` to get to bool, because it might be something like\n+                            // { a } && b, which we have a separate fixup suggestion that is more\n+                            // likely correct...\n+                            if remove.trim() == \"&&\" && expected == self.tcx.types.bool {\n+                                Applicability::MaybeIncorrect\n                             } else {\n-                                (expr.span.shrink_to_lo(), format!(\"{}*\", prefix))\n-                            };\n-                            return Some((\n-                                span,\n-                                message,\n-                                suggestion,\n-                                Applicability::MachineApplicable,\n-                                true,\n-                            ));\n-                        }\n+                                Applicability::MachineApplicable\n+                            },\n+                            true,\n+                        ));\n+                    }\n+\n+                    // For this suggestion to make sense, the type would need to be `Copy`,\n+                    // or we have to be moving out of a `Box<T>`\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                        // FIXME(compiler-errors): We can actually do this if the checked_ty is\n+                        // `steps` layers of boxes, not just one, but this is easier and most likely.\n+                        || (checked_ty.is_box() && steps == 1)\n+                    {\n+                        let deref_kind = if checked_ty.is_box() {\n+                            \"unboxing the value\"\n+                        } else if checked_ty.is_region_ptr() {\n+                            \"dereferencing the borrow\"\n+                        } else {\n+                            \"dereferencing the type\"\n+                        };\n+\n+                        // Suggest removing `&` if we have removed any, otherwise suggest just\n+                        // dereferencing the remaining number of steps.\n+                        let message = if remove.is_empty() {\n+                            format!(\"consider {}\", deref_kind)\n+                        } else {\n+                            format!(\n+                                \"consider removing the `{}` and {} instead\",\n+                                remove.trim(),\n+                                deref_kind\n+                            )\n+                        };\n+\n+                        let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                            Some(ident) => format!(\"{}: \", ident),\n+                            None => String::new(),\n+                        };\n+\n+                        let (span, suggestion) = if self.is_else_if_block(expr) {\n+                            // Don't suggest nonsense like `else *if`\n+                            return None;\n+                        } else if let Some(expr) = self.maybe_get_block_expr(expr) {\n+                            // prefix should be empty here..\n+                            (expr.span.shrink_to_lo(), \"*\".to_string())\n+                        } else {\n+                            (prefix_span, format!(\"{}{}\", prefix, \"*\".repeat(steps)))\n+                        };\n+\n+                        return Some((\n+                            span,\n+                            message,\n+                            suggestion,\n+                            Applicability::MachineApplicable,\n+                            true,\n+                        ));\n                     }\n                 }\n             }"}, {"sha": "523602d5b1888dbcc3b2756fdbee760724c95adc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -218,9 +218,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.check_ref(expr, found, expected)\n         {\n             if verbose {\n-                err.span_suggestion_verbose(sp, msg, suggestion, applicability);\n+                err.span_suggestion_verbose(sp, &msg, suggestion, applicability);\n             } else {\n-                err.span_suggestion(sp, msg, suggestion, applicability);\n+                err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n         } else if let (ty::FnDef(def_id, ..), true) =\n             (&found.kind(), self.suggest_fn_call(err, expr, expected, found))"}, {"sha": "b7516babc1330ad252556b890a496b6e48cd1bcb", "filename": "src/test/ui/parser/expr-as-stmt-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -36,6 +36,11 @@ LL | /     &&\n LL | |     if let Some(y) = a { true } else { false }\n    | |______________________________________________^ expected `bool`, found `&&bool`\n    |\n+help: consider removing the `&&`\n+   |\n+LL -     &&\n+LL +     if let Some(y) = a { true } else { false }\n+   | \n help: parentheses are required to parse this as an expression\n    |\n LL |     (if let Some(x) = a { true } else { false })"}, {"sha": "e63da52c8fe1d6480054a2c76b68850e26db302e", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -170,6 +170,11 @@ LL | fn revenge_from_mars() -> bool {\n LL |     { true } && { true }\n    |              ^^^^^^^^^^^ expected `bool`, found `&&bool`\n    |\n+help: consider removing the `&&`\n+   |\n+LL -     { true } && { true }\n+LL +     { true } { true }\n+   | \n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) && { true }"}, {"sha": "897de54a7bf8cde5dbbc205c5026e8d3699200f1", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -676,6 +676,12 @@ error[E0308]: mismatched types\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |                                            ^^^^^^^ expected `bool`, found `&&bool`\n+   |\n+help: consider removing the `&&`\n+   |\n+LL -     if let Range { start: true, end } = t..&&false {}\n+LL +     if let Range { start: true, end } = t..false {}\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:83:8\n@@ -866,6 +872,12 @@ error[E0308]: mismatched types\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |                                               ^^^^^^^ expected `bool`, found `&&bool`\n+   |\n+help: consider removing the `&&`\n+   |\n+LL -     while let Range { start: true, end } = t..&&false {}\n+LL +     while let Range { start: true, end } = t..false {}\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:147:11"}, {"sha": "3dc4771fefb0727d3b2c05938321a696c74a0617", "filename": "src/test/ui/typeck/deref-multi.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.rs?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -0,0 +1,26 @@\n+fn a(x: &&i32) -> i32 {\n+    x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn a2(x: &&&&&i32) -> i32 {\n+    x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn b(x: &i32) -> i32 {\n+    &x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn c(x: Box<i32>) -> i32 {\n+    &x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn d(x: std::sync::Mutex<&i32>) -> i32 {\n+    x.lock().unwrap()\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "bd6575c73d244f749380af0abe7be33553536aa5", "filename": "src/test/ui/typeck/deref-multi.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ce3f5664130eaf24d187d04dcd51c4577336ab5/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.stderr?ref=5ce3f5664130eaf24d187d04dcd51c4577336ab5", "patch": "@@ -0,0 +1,72 @@\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:2:5\n+   |\n+LL | fn a(x: &&i32) -> i32 {\n+   |                   --- expected `i32` because of return type\n+LL |     x\n+   |     ^ expected `i32`, found `&&i32`\n+   |\n+help: consider dereferencing the borrow\n+   |\n+LL |     **x\n+   |     ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:7:5\n+   |\n+LL | fn a2(x: &&&&&i32) -> i32 {\n+   |                       --- expected `i32` because of return type\n+LL |     x\n+   |     ^ expected `i32`, found `&&&&&i32`\n+   |\n+help: consider dereferencing the borrow\n+   |\n+LL |     *****x\n+   |     +++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:12:5\n+   |\n+LL | fn b(x: &i32) -> i32 {\n+   |                  --- expected `i32` because of return type\n+LL |     &x\n+   |     ^^ expected `i32`, found `&&i32`\n+   |\n+help: consider removing the `&` and dereferencing the borrow instead\n+   |\n+LL |     *x\n+   |     ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:17:5\n+   |\n+LL | fn c(x: Box<i32>) -> i32 {\n+   |                      --- expected `i32` because of return type\n+LL |     &x\n+   |     ^^ expected `i32`, found `&Box<i32>`\n+   |\n+   = note:   expected type `i32`\n+           found reference `&Box<i32>`\n+help: consider removing the `&` and dereferencing the borrow instead\n+   |\n+LL |     *x\n+   |     ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:22:5\n+   |\n+LL | fn d(x: std::sync::Mutex<&i32>) -> i32 {\n+   |                                    --- expected `i32` because of return type\n+LL |     x.lock().unwrap()\n+   |     ^^^^^^^^^^^^^^^^^ expected `i32`, found struct `MutexGuard`\n+   |\n+   = note: expected type `i32`\n+            found struct `MutexGuard<'_, &i32>`\n+help: consider dereferencing the type\n+   |\n+LL |     **x.lock().unwrap()\n+   |     ++\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}