{"sha": "faf14ae63308fc75ee59448f215a38db73dae645", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZjE0YWU2MzMwOGZjNzVlZTU5NDQ4ZjIxNWEzOGRiNzNkYWU2NDU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-10T21:02:37Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-10T21:02:37Z"}, "message": "Fix vector terminology in the manual.\n\nfixes #17148", "tree": {"sha": "b58116f1066236db3bbe8cfbe6d7e145ba020c7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b58116f1066236db3bbe8cfbe6d7e145ba020c7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faf14ae63308fc75ee59448f215a38db73dae645", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faf14ae63308fc75ee59448f215a38db73dae645", "html_url": "https://github.com/rust-lang/rust/commit/faf14ae63308fc75ee59448f215a38db73dae645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faf14ae63308fc75ee59448f215a38db73dae645/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "651106462c357b71a4ca2c02ba2bfedfc38b0035", "url": "https://api.github.com/repos/rust-lang/rust/commits/651106462c357b71a4ca2c02ba2bfedfc38b0035", "html_url": "https://github.com/rust-lang/rust/commit/651106462c357b71a4ca2c02ba2bfedfc38b0035"}], "stats": {"total": 41, "additions": 21, "deletions": 20}, "files": [{"sha": "112e6d0c1940e129551cb426bd039aa7b95af67a", "filename": "src/doc/rust.md", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/faf14ae63308fc75ee59448f215a38db73dae645/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/faf14ae63308fc75ee59448f215a38db73dae645/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=faf14ae63308fc75ee59448f215a38db73dae645", "patch": "@@ -349,7 +349,7 @@ enclosed within two `U+0022` (double-quote) characters,\n with the exception of `U+0022` itself,\n which must be _escaped_ by a preceding `U+005C` character (`\\`),\n or a _raw byte string literal_.\n-It is equivalent to a `&'static [u8]` borrowed vector of unsigned 8-bit integers.\n+It is equivalent to a `&'static [u8]` borrowed array of unsigned 8-bit integers.\n \n Some additional _escapes_ are available in either byte or non-raw byte string\n literals. An escape starts with a `U+005C` (`\\`) and continues with one of\n@@ -2809,16 +2809,17 @@ When the type providing the field inherits mutabilty, it can be [assigned](#assi\n Also, if the type of the expression to the left of the dot is a pointer,\n it is automatically dereferenced to make the field access possible.\n \n-### Vector expressions\n+### Array expressions\n \n ~~~~ {.ebnf .gram}\n-vec_expr : '[' \"mut\" ? vec_elems? ']' ;\n+array_expr : '[' \"mut\" ? vec_elems? ']' ;\n \n-vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n+array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n ~~~~\n \n-A [_vector_](#vector-types) _expression_ is written by enclosing zero or\n-more comma-separated expressions of uniform type in square brackets.\n+An [array](#vector,-array,-and-slice-types) _expression_ is written by\n+enclosing zero or more comma-separated expressions of uniform type in square\n+brackets.\n \n In the `[expr ',' \"..\" expr]` form, the expression after the `\"..\"`\n must be a constant expression that can be evaluated at compile time, such\n@@ -2827,7 +2828,7 @@ as a [literal](#literals) or a [static item](#static-items).\n ~~~~\n [1i, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n-[0i, ..128];             // vector with 128 zeros\n+[0i, ..128];             // array with 128 zeros\n [0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n@@ -2837,9 +2838,9 @@ as a [literal](#literals) or a [static item](#static-items).\n idx_expr : expr '[' expr ']' ;\n ~~~~\n \n-[Vector](#vector-types)-typed expressions can be indexed by writing a\n+[Array](#vector,-array,-and-slice-types)-typed expressions can be indexed by writing a\n square-bracket-enclosed expression (the index) after them. When the\n-vector is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can be assigned to.\n+array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n@@ -2900,7 +2901,7 @@ This means that arithmetic operators can be overridden for user-defined types.\n The default meaning of the operators on standard types is given here.\n \n * `+`\n-  : Addition and vector/string concatenation.\n+  : Addition and array/string concatenation.\n     Calls the `add` method on the `std::ops::Add` trait.\n * `-`\n   : Subtraction.\n@@ -3203,7 +3204,7 @@ for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n A `for` expression is a syntactic construct for looping over elements\n provided by an implementation of `std::iter::Iterator`.\n \n-An example of a for loop over the contents of a vector:\n+An example of a for loop over the contents of an array:\n \n ~~~~\n # type Foo = int;\n@@ -3261,7 +3262,7 @@ match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n \n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n-literals, destructured vectors or enum constructors, structures and\n+literals, destructured arrays or enum constructors, structures and\n tuples, variable binding specifications, wildcards (`..`), and placeholders\n (`_`). A `match` expression has a *head expression*, which is the value to\n compare to the patterns. The type of the patterns must equal the type of the\n@@ -3290,11 +3291,11 @@ between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n exactly one argument, while the pattern `C(..)` is type-correct for any enum\n variant `C`, regardless of how many arguments `C` has.\n \n-Used inside a vector pattern, `..` stands for any number of elements, when the\n+Used inside a array pattern, `..` stands for any number of elements, when the\n `advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n-at most once for a given vector, which implies that it cannot be used to\n+at most once for a given array, which implies that it cannot be used to\n specifically match elements that are at an unknown distance from both ends of a\n-vector, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n+array, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n corresponding slice to the variable.  Example:\n \n ~~~~\n@@ -3427,7 +3428,7 @@ let message = match x {\n ~~~~\n \n Range patterns only work on scalar types\n-(like integers and characters; not like vectors and structs, which have sub-components).\n+(like integers and characters; not like arrays and structs, which have sub-components).\n A range pattern may not be a sub-range of another range pattern inside the same `match`.\n \n Finally, match patterns can accept *pattern guards* to further refine the\n@@ -3535,10 +3536,10 @@ http://www.unicode.org/glossary/#unicode_scalar_value)\n (ie. a code point that is not a surrogate),\n represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF\n or 0xE000 to 0x10FFFF range.\n-A `[char]` vector is effectively an UCS-4 / UTF-32 string.\n+A `[char]` array is effectively an UCS-4 / UTF-32 string.\n \n A value of type `str` is a Unicode string,\n-represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n+represented as a array of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n Since `str` is of unknown size, it is not a _first class_ type,\n but can only be instantiated through a pointer type,\n such as `&str` or `String`.\n@@ -3649,7 +3650,7 @@ Such recursion has restrictions:\n \n * Recursive types must include a nominal type in the recursion\n   (not mere [type definitions](#type-definitions),\n-   or other structural types such as [vectors](#vector-types) or [tuples](#tuple-types)).\n+   or other structural types such as [arrays](#vector,-array,-and-slice-types) or [tuples](#tuple-types)).\n * A recursive `enum` item must have at least one non-recursive constructor\n   (in order to give the recursion a basis case).\n * The size of a recursive type must be finite;\n@@ -4153,7 +4154,7 @@ heap data.\n ### Built in types\n \n The runtime provides C and Rust code to assist with various built-in types,\n-such as vectors, strings, and the low level communication system (ports,\n+such as arrays, strings, and the low level communication system (ports,\n channels, tasks).\n \n Support for other built-in types such as simple types, tuples and"}]}