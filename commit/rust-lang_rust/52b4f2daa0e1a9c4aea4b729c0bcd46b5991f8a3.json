{"sha": "52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYjRmMmRhYTBlMWE5YzRhZWE0YjcyOWMwYmNkNDZiNTk5MWY4YTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-25T10:11:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: remove PrintCx from ty::Print and rely on printers carrying TyCtxt.", "tree": {"sha": "1de54fca6a8ad1edaeb1b43e4c3dd52e7c850e78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1de54fca6a8ad1edaeb1b43e4c3dd52e7c850e78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "html_url": "https://github.com/rust-lang/rust/commit/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a656828acc6fa619e2e83f928ca21f2281c911b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a656828acc6fa619e2e83f928ca21f2281c911b", "html_url": "https://github.com/rust-lang/rust/commit/2a656828acc6fa619e2e83f928ca21f2281c911b"}], "stats": {"total": 1895, "additions": 919, "deletions": 976}, "files": [{"sha": "52b4288103813133d74a8acf9a939b107be575bf", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -445,82 +445,82 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         sp: Span,\n     ) {\n         use hir::def_id::CrateNum;\n-        use ty::print::{PrintCx, Printer};\n+        use ty::print::Printer;\n         use ty::subst::Kind;\n \n-        struct AbsolutePathPrinter;\n+        struct AbsolutePathPrinter<'a, 'gcx, 'tcx> {\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        }\n \n         struct NonTrivialPath;\n \n-        impl Printer for AbsolutePathPrinter {\n+        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'_, 'gcx, 'tcx> {\n             type Error = NonTrivialPath;\n \n             type Path = Vec<String>;\n             type Region = !;\n             type Type = !;\n             type DynExistential = !;\n \n+            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+                self.tcx\n+            }\n+\n             fn print_region(\n-                self: PrintCx<'_, '_, '_, Self>,\n+                self,\n                 _region: ty::Region<'_>,\n             ) -> Result<Self::Region, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n \n-            fn print_type<'tcx>(\n-                self: PrintCx<'_, '_, 'tcx, Self>,\n+            fn print_type(\n+                self,\n                 _ty: Ty<'tcx>,\n             ) -> Result<Self::Type, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n \n-            fn print_dyn_existential<'tcx>(\n-                self: PrintCx<'_, '_, 'tcx, Self>,\n+            fn print_dyn_existential(\n+                self,\n                 _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n \n             fn path_crate(\n-                self: PrintCx<'_, '_, '_, Self>,\n+                self,\n                 cnum: CrateNum,\n             ) -> Result<Self::Path, Self::Error> {\n                 Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n             }\n-            fn path_qualified<'tcx>(\n-                self: PrintCx<'_, '_, 'tcx, Self>,\n+            fn path_qualified(\n+                self,\n                 _self_ty: Ty<'tcx>,\n                 _trait_ref: Option<ty::TraitRef<'tcx>>,\n             ) -> Result<Self::Path, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n \n-            fn path_append_impl<'gcx, 'tcx>(\n-                self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-                _print_prefix: impl FnOnce(\n-                    PrintCx<'_, 'gcx, 'tcx, Self>,\n-                ) -> Result<Self::Path, Self::Error>,\n+            fn path_append_impl(\n+                self,\n+                _print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n                 _self_ty: Ty<'tcx>,\n                 _trait_ref: Option<ty::TraitRef<'tcx>>,\n             ) -> Result<Self::Path, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n-            fn path_append<'gcx, 'tcx>(\n-                self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-                print_prefix: impl FnOnce(\n-                    PrintCx<'_, 'gcx, 'tcx, Self>,\n-                ) -> Result<Self::Path, Self::Error>,\n+            fn path_append(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n                 text: &str,\n             ) -> Result<Self::Path, Self::Error> {\n                 let mut path = print_prefix(self)?;\n                 path.push(text.to_string());\n                 Ok(path)\n             }\n-            fn path_generic_args<'gcx, 'tcx>(\n-                self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-                print_prefix: impl FnOnce(\n-                    PrintCx<'_, 'gcx, 'tcx, Self>,\n-                ) -> Result<Self::Path, Self::Error>,\n+            fn path_generic_args(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n                 _args: &[Kind<'tcx>],\n             ) -> Result<Self::Path, Self::Error> {\n                 print_prefix(self)\n@@ -532,7 +532,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let abs_path = |def_id| {\n-                    PrintCx::new(self.tcx, AbsolutePathPrinter)\n+                    AbsolutePathPrinter { tcx: self.tcx }\n                         .print_def_path(def_id, None)\n                 };\n "}, {"sha": "0a83b839201ed299557903253fd250e8b7c47e70", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -80,11 +80,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(&mut s, Namespace::TypeNS);\n+        let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n         if let Some(highlight) = highlight {\n             printer.region_highlight_mode = highlight;\n         }\n-        let _ = ty.print(ty::print::PrintCx::new(self.tcx, printer));\n+        let _ = ty.print(printer);\n         s\n     }\n "}, {"sha": "e708454b5b672fcd936f3c0e42ef53059ba6bbc8", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -337,17 +337,17 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'tcx, T> fmt::Display for Highlighted<'_, '_, 'tcx, T>\n-            where T: for<'a, 'b> Print<'tcx,\n-                FmtPrinter<&'a mut fmt::Formatter<'b>>,\n+        impl<'a, 'gcx, 'tcx, T> fmt::Display for Highlighted<'a, 'gcx, 'tcx, T>\n+            where T: for<'b, 'c> Print<'gcx, 'tcx,\n+                FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n                 Error = fmt::Error,\n             >,\n         {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                let mut printer = ty::print::FmtPrinter::new(f, Namespace::TypeNS);\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, f, Namespace::TypeNS);\n                 printer.region_highlight_mode = self.highlight;\n \n-                self.value.print(ty::print::PrintCx::new(self.tcx, printer))?;\n+                self.value.print(printer)?;\n                 Ok(())\n             }\n         }"}, {"sha": "3218f8ea5de4823cec756703a11d097b4f599506", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -34,7 +34,7 @@ use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n-use crate::ty::print::{FmtPrinter, Printer, PrintCx};\n+use crate::ty::print::{FmtPrinter, Printer};\n \n pub use crate::mir::interpret::AssertMessage;\n \n@@ -2407,9 +2407,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let variant_def = &adt_def.variants[variant];\n \n                         let f = &mut *fmt;\n-                        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::ValueNS), |cx| {\n-                            let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n-                            cx.print_def_path(variant_def.did, Some(substs))?;\n+                        ty::tls::with(|tcx| {\n+                            let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n+                            FmtPrinter::new(tcx, f, Namespace::ValueNS)\n+                                .print_def_path(variant_def.did, Some(substs))?;\n                             Ok(())\n                         })?;\n "}, {"sha": "89d956c8bfae3f0bdfc78132a09dc81dfc2d51b5", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -2,7 +2,7 @@ use crate::hir::Unsafety;\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n-use crate::ty::print::{FmtPrinter, Printer, PrintCx};\n+use crate::ty::print::{FmtPrinter, Printer};\n use crate::traits;\n use rustc_target::spec::abi::Abi;\n use rustc_macros::HashStable;\n@@ -176,9 +176,10 @@ impl<'tcx> InstanceDef<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(&mut *f, Namespace::ValueNS), |cx| {\n-            let substs = cx.tcx.lift(&self.substs).expect(\"could not lift for printing\");\n-            cx.print_def_path(self.def_id(), Some(substs))?;\n+        ty::tls::with(|tcx| {\n+            let substs = tcx.lift(&self.substs).expect(\"could not lift for printing\");\n+            FmtPrinter::new(tcx, &mut *f, Namespace::ValueNS)\n+                .print_def_path(self.def_id(), Some(substs))?;\n             Ok(())\n         })?;\n "}, {"sha": "ad17a8114cabf6da64dc7a4bc3bb40c7d7e116b0", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 50, "deletions": 93, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -5,75 +5,36 @@ use crate::ty::subst::{Kind, Subst, SubstsRef};\n \n use rustc_data_structures::fx::FxHashSet;\n \n-use std::ops::{Deref, DerefMut};\n-\n // `pretty` is a separate module only for organization.\n mod pretty;\n pub use self::pretty::*;\n \n-pub struct PrintCx<'a, 'gcx, 'tcx, P> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    inner: P,\n-}\n-\n-impl<P> Deref for PrintCx<'_, '_, '_, P> {\n-    type Target = P;\n-    fn deref(&self) -> &P {\n-        &self.inner\n-    }\n-}\n-\n-impl<P> DerefMut for PrintCx<'_, '_, '_, P> {\n-    fn deref_mut(&mut self) -> &mut P {\n-        &mut self.inner\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx, P> PrintCx<'a, 'gcx, 'tcx, P> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, inner: P) -> Self {\n-        PrintCx {\n-            tcx,\n-            inner,\n-        }\n-    }\n-\n-    pub fn with_tls_tcx<R>(inner: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n-        ty::tls::with(|tcx| f(PrintCx::new(tcx, inner)))\n-    }\n-\n-    pub fn into_inner(self) -> P {\n-        self.inner\n-    }\n-\n-    pub fn ok<E>(self) -> Result<P, E> {\n-        Ok(self.into_inner())\n-    }\n-}\n-\n-pub trait Print<'tcx, P> {\n+pub trait Print<'gcx, 'tcx, P> {\n     type Output;\n     type Error;\n \n-    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error>;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error>;\n }\n \n-pub trait Printer: Sized {\n+pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     type Error;\n \n     type Path;\n     type Region;\n     type Type;\n     type DynExistential;\n \n+    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+\n     fn print_def_path(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs)\n     }\n     fn print_impl_path(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         impl_def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         self_ty: Ty<'tcx>,\n@@ -83,62 +44,56 @@ pub trait Printer: Sized {\n     }\n \n     fn print_region(\n-        self: PrintCx<'_, '_, '_, Self>,\n+        self,\n         region: ty::Region<'_>,\n     ) -> Result<Self::Region, Self::Error>;\n \n     fn print_type(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         ty: Ty<'tcx>,\n     ) -> Result<Self::Type, Self::Error>;\n \n     fn print_dyn_existential(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n     fn path_crate(\n-        self: PrintCx<'_, '_, '_, Self>,\n+        self,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error>;\n     fn path_qualified(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n \n-    fn path_append_impl<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n-    fn path_append<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error>;\n-    fn path_generic_args<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n+    fn path_generic_args(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         args: &[Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error>;\n-}\n \n-impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n-    pub fn default_print_def_path(\n+    // Defaults (should not be overriden):\n+\n+    fn default_print_def_path(\n         self,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n+    ) -> Result<Self::Path, Self::Error> {\n         debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n-        let key = self.tcx.def_key(def_id);\n+        let key = self.tcx().def_key(def_id);\n         debug!(\"default_print_def_path: key={:?}\", key);\n \n         match key.disambiguated_data.data {\n@@ -148,29 +103,29 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n \n             DefPathData::Impl => {\n-                let mut self_ty = self.tcx.type_of(def_id);\n+                let mut self_ty = self.tcx().type_of(def_id);\n                 if let Some(substs) = substs {\n-                    self_ty = self_ty.subst(self.tcx, substs);\n+                    self_ty = self_ty.subst(self.tcx(), substs);\n                 }\n \n-                let mut impl_trait_ref = self.tcx.impl_trait_ref(def_id);\n+                let mut impl_trait_ref = self.tcx().impl_trait_ref(def_id);\n                 if let Some(substs) = substs {\n-                    impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n+                    impl_trait_ref = impl_trait_ref.subst(self.tcx(), substs);\n                 }\n                 self.print_impl_path(def_id, substs, self_ty, impl_trait_ref)\n             }\n \n             _ => {\n-                let generics = substs.map(|_| self.tcx.generics_of(def_id));\n+                let generics = substs.map(|_| self.tcx().generics_of(def_id));\n                 let generics_parent = generics.as_ref().and_then(|g| g.parent);\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let print_parent_path = |cx: PrintCx<'_, 'gcx, 'tcx, P>| {\n+                let print_parent_path = |cx: Self| {\n                     if let Some(generics_parent_def_id) = generics_parent {\n                         assert_eq!(parent_def_id, generics_parent_def_id);\n \n                         // FIXME(eddyb) try to move this into the parent's printing\n                         // logic, instead of doing it when printing the child.\n-                        let parent_generics = cx.tcx.generics_of(parent_def_id);\n+                        let parent_generics = cx.tcx().generics_of(parent_def_id);\n                         let parent_has_own_self =\n                             parent_generics.has_self && parent_generics.parent_count == 0;\n                         if let (Some(substs), true) = (substs, parent_has_own_self) {\n@@ -183,7 +138,7 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n                         cx.print_def_path(parent_def_id, None)\n                     }\n                 };\n-                let print_path = |cx: PrintCx<'_, 'gcx, 'tcx, P>| {\n+                let print_path = |cx: Self| {\n                     match key.disambiguated_data.data {\n                         // Skip `::{{constructor}}` on tuple/unit structs.\n                         DefPathData::StructCtor => print_parent_path(cx),\n@@ -207,7 +162,7 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n         }\n     }\n \n-    pub fn generic_args_to_print(\n+    fn generic_args_to_print(\n         &self,\n         generics: &'tcx ty::Generics,\n         substs: SubstsRef<'tcx>,\n@@ -225,7 +180,7 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n                 ty::GenericParamDefKind::Lifetime => false,\n                 ty::GenericParamDefKind::Type { has_default, .. } => {\n                     has_default && substs[param.index as usize] == Kind::from(\n-                        self.tcx.type_of(param.def_id).subst(self.tcx, substs)\n+                        self.tcx().type_of(param.def_id).subst(self.tcx(), substs)\n                     )\n                 }\n                 ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n@@ -241,7 +196,7 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n         _substs: Option<SubstsRef<'tcx>>,\n         self_ty: Ty<'tcx>,\n         impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n+    ) -> Result<Self::Path, Self::Error> {\n         debug!(\"default_print_impl_path: impl_def_id={:?}, self_ty={}, impl_trait_ref={:?}\",\n                impl_def_id, self_ty, impl_trait_ref);\n \n@@ -250,14 +205,14 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n+        let parent_def_id = self.tcx().parent(impl_def_id).unwrap();\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n-            Some(ty_def_id) => self.tcx.parent(ty_def_id) == Some(parent_def_id),\n+            Some(ty_def_id) => self.tcx().parent(ty_def_id) == Some(parent_def_id),\n         };\n         let in_trait_mod = match impl_trait_ref {\n             None => false,\n-            Some(trait_ref) => self.tcx.parent(trait_ref.def_id) == Some(parent_def_id),\n+            Some(trait_ref) => self.tcx().parent(trait_ref.def_id) == Some(parent_def_id),\n         };\n \n         if !in_self_mod && !in_trait_mod {\n@@ -325,34 +280,36 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     }\n }\n \n-impl<P: Printer> Print<'tcx, P> for ty::RegionKind {\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::RegionKind {\n     type Output = P::Region;\n     type Error = P::Error;\n-    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_region(self)\n     }\n }\n \n-impl<P: Printer> Print<'tcx, P> for ty::Region<'_> {\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::Region<'_> {\n     type Output = P::Region;\n     type Error = P::Error;\n-    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_region(self)\n     }\n }\n \n-impl<P: Printer> Print<'tcx, P> for Ty<'tcx> {\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for Ty<'tcx> {\n     type Output = P::Type;\n     type Error = P::Error;\n-    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_type(self)\n     }\n }\n \n-impl<P: Printer> Print<'tcx, P> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n+{\n     type Output = P::DynExistential;\n     type Error = P::Error;\n-    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_dyn_existential(self)\n     }\n }"}, {"sha": "fff4ca822d20efe4f93e5c81e19f42c380651a79", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 676, "deletions": 718, "changes": 1394, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -19,17 +19,12 @@ use std::ops::{Deref, DerefMut};\n // `pretty` is a separate module only for organization.\n use super::*;\n \n-macro_rules! nest {\n-    ($e:expr) => {\n-        scoped_cx!() = PrintCx::new(scoped_cx!().tcx, $e?)\n-    }\n-}\n macro_rules! print_inner {\n     (write ($($data:expr),+)) => {\n         write!(scoped_cx!(), $($data),+)?\n     };\n     ($kind:ident ($data:expr)) => {\n-        nest!($data.$kind(scoped_cx!()))\n+        scoped_cx!() = $data.$kind(scoped_cx!())?\n     };\n }\n macro_rules! p {\n@@ -170,8 +165,8 @@ impl RegionHighlightMode {\n }\n \n /// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter:\n-    Printer<\n+pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n+    Printer<'gcx, 'tcx,\n         Error = fmt::Error,\n         Path = Self,\n         Region = Self,\n@@ -182,101 +177,62 @@ pub trait PrettyPrinter:\n {\n     /// Like `print_def_path` but for value paths.\n     fn print_value_path(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n         self.print_def_path(def_id, substs)\n     }\n \n     fn in_binder<T>(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         value: &ty::Binder<T>,\n     ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n     {\n         value.skip_binder().print(self)\n     }\n \n     /// Print comma-separated elements.\n     fn comma_sep<T>(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        mut self,\n         mut elems: impl Iterator<Item = T>,\n     ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error>\n     {\n-        define_scoped_cx!(self);\n-\n         if let Some(first) = elems.next() {\n-            nest!(first.print(self));\n+            self = first.print(self)?;\n             for elem in elems {\n                 self.write_str(\", \")?;\n-                nest!(elem.print(self));\n+                self = elem.print(self)?;\n             }\n         }\n-        self.ok()\n+        Ok(self)\n     }\n \n     /// Print `<...>` around what `f` prints.\n-    fn generic_delimiters<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    fn generic_delimiters(\n+        self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error>;\n \n     /// Return `true` if the region should be printed in\n     /// optional positions, e.g. `&'a T` or `dyn Tr + 'b`.\n     /// This is typically the case for all non-`'_` regions.\n     fn region_should_not_be_omitted(\n-        self: &PrintCx<'_, '_, '_, Self>,\n+        &self,\n         region: ty::Region<'_>,\n     ) -> bool;\n-}\n-\n-impl<P: PrettyPrinter> fmt::Write for PrintCx<'_, '_, '_, P> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        (**self).write_str(s)\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n-    // (but also some things just print a `DefId` generally so maybe we need this?)\n-    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n-        match self.def_key(def_id).disambiguated_data.data {\n-            DefPathData::ValueNs(..) |\n-            DefPathData::EnumVariant(..) |\n-            DefPathData::Field(..) |\n-            DefPathData::AnonConst |\n-            DefPathData::ConstParam(..) |\n-            DefPathData::ClosureExpr |\n-            DefPathData::StructCtor => Namespace::ValueNS,\n-\n-            DefPathData::MacroDef(..) => Namespace::MacroNS,\n-\n-            _ => Namespace::TypeNS,\n-        }\n-    }\n \n-    /// Returns a string identifying this `DefId. This string is\n-    /// suitable for user output.\n-    pub fn def_path_str(self, def_id: DefId) -> String {\n-        let ns = self.guess_def_namespace(def_id);\n-        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n-        let mut s = String::new();\n-        let _ = PrintCx::new(self, FmtPrinter::new(&mut s, ns))\n-            .print_def_path(def_id, None);\n-        s\n-    }\n-}\n+    // Defaults (should not be overriden):\n \n-impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n     /// If possible, this returns a global path resolving to `def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     fn try_print_visible_def_path(\n         mut self,\n         def_id: DefId,\n-    ) -> Result<(P, bool), P::Error> {\n+    ) -> Result<(Self, bool), Self::Error> {\n         define_scoped_cx!(self);\n \n         debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n@@ -300,7 +256,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             // 2. for an extern inferred from a path or an indirect crate,\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n-            match *self.tcx.extern_crate(def_id) {\n+            match *self.tcx().extern_crate(def_id) {\n                 Some(ExternCrate {\n                     src: ExternCrateSource::Extern(def_id),\n                     direct: true,\n@@ -322,12 +278,12 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         }\n \n         if def_id.is_local() {\n-            return self.ok().map(|path| (path, false));\n+            return Ok((self, false));\n         }\n \n-        let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n+        let visible_parent_map = self.tcx().visible_parent_map(LOCAL_CRATE);\n \n-        let mut cur_def_key = self.tcx.def_key(def_id);\n+        let mut cur_def_key = self.tcx().def_key(def_id);\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n         // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n@@ -337,27 +293,22 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n             };\n \n-            cur_def_key = self.tcx.def_key(parent);\n+            cur_def_key = self.tcx().def_key(parent);\n         }\n \n         let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n             Some(parent) => parent,\n-            None => return self.ok().map(|path| (path, false)),\n-        };\n-        // HACK(eddyb) this uses `nest` to avoid knowing ahead of time whether\n-        // the entire path will succeed or not. To support printers that do not\n-        // implement `PrettyPrinter`, a `Vec` or linked list on the stack would\n-        // need to be built, before starting to print anything.\n-        let prefix_success;\n-        nest!({\n-            let (path, success) = self.try_print_visible_def_path(visible_parent)?;\n-            prefix_success = success;\n-            Ok(path)\n-        });\n-        if !prefix_success {\n-            return self.ok().map(|path| (path, false));\n+            None => return Ok((self, false)),\n         };\n-        let actual_parent = self.tcx.parent(def_id);\n+        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n+        // knowing ahead of time whether the entire path will succeed or not.\n+        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n+        // linked list on the stack would need to be built, before any printing.\n+        match self.try_print_visible_def_path(visible_parent)? {\n+            (cx, false) => return Ok((cx, false)),\n+            (cx, true) => self = cx,\n+        }\n+        let actual_parent = self.tcx().parent(def_id);\n         debug!(\n             \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n             visible_parent, actual_parent,\n@@ -403,7 +354,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             // have access to the re-exported name.\n             DefPathData::Module(actual_name) |\n             DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n-                self.tcx.item_children(visible_parent)\n+                self.tcx().item_children(visible_parent)\n                     .iter()\n                     .find(|child| child.def.def_id() == def_id)\n                     .map(|child| child.ident.as_str())\n@@ -413,22 +364,22 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n                     // Re-exported `extern crate` (#43189).\n                     if let DefPathData::CrateRoot = data {\n-                        self.tcx.original_crate_name(def_id.krate).as_str()\n+                        self.tcx().original_crate_name(def_id.krate).as_str()\n                     } else {\n                         Symbol::intern(\"<unnamed>\").as_str()\n                     }\n                 })\n             },\n         };\n         debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n-        Ok((self.path_append(|cx| cx.ok(), &symbol)?, true))\n+        Ok((self.path_append(Ok, &symbol)?, true))\n     }\n \n-    pub fn pretty_path_qualified(\n+    fn pretty_path_qualified(\n         self,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n+    ) -> Result<Self::Path, Self::Error> {\n         if trait_ref.is_none() {\n             // Inherent impls. Try to print `Foo::bar` for an inherent\n             // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n@@ -451,19 +402,17 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             if let Some(trait_ref) = trait_ref {\n                 p!(write(\" as \"), print(trait_ref));\n             }\n-            cx.ok()\n+            Ok(cx)\n         })\n     }\n \n-    pub fn pretty_path_append_impl(\n+    fn pretty_path_append_impl(\n         mut self,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, P>,\n-        ) -> Result<P::Path, P::Error>,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n-        self = PrintCx::new(self.tcx, print_prefix(self)?);\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n \n         self.generic_delimiters(|mut cx| {\n             define_scoped_cx!(cx);\n@@ -474,502 +423,78 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n             p!(print(self_ty));\n \n-            cx.ok()\n+            Ok(cx)\n         })\n     }\n-}\n-\n-// HACK(eddyb) boxed to avoid moving around a large struct by-value.\n-pub struct FmtPrinter<F>(Box<FmtPrinterData<F>>);\n-\n-pub struct FmtPrinterData<F> {\n-    fmt: F,\n-\n-    empty_path: bool,\n-    in_value: bool,\n-\n-    used_region_names: FxHashSet<InternedString>,\n-    region_index: usize,\n-    binder_depth: usize,\n-\n-    pub region_highlight_mode: RegionHighlightMode,\n-}\n-\n-impl<F> Deref for FmtPrinter<F> {\n-    type Target = FmtPrinterData<F>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-impl<F> DerefMut for FmtPrinter<F> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.0\n-    }\n-}\n-\n-impl<F> FmtPrinter<F> {\n-    pub fn new(fmt: F, ns: Namespace) -> Self {\n-        FmtPrinter(Box::new(FmtPrinterData {\n-            fmt,\n-            empty_path: false,\n-            in_value: ns == Namespace::ValueNS,\n-            used_region_names: Default::default(),\n-            region_index: 0,\n-            binder_depth: 0,\n-            region_highlight_mode: RegionHighlightMode::default(),\n-        }))\n-    }\n-}\n-\n-impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.fmt.write_str(s)\n-    }\n-}\n \n-impl<F: fmt::Write> Printer for FmtPrinter<F> {\n-    type Error = fmt::Error;\n-\n-    type Path = Self;\n-    type Region = Self;\n-    type Type = Self;\n-    type DynExistential = Self;\n-\n-    fn print_def_path(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n+    fn pretty_print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n         define_scoped_cx!(self);\n \n-        // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n-        // both here and in `default_print_def_path`.\n-        let generics = substs.map(|_| self.tcx.generics_of(def_id));\n-        if generics.as_ref().and_then(|g| g.parent).is_none() {\n-            let visible_path_success;\n-            nest!({\n-                let (path, success) = self.try_print_visible_def_path(def_id)?;\n-                visible_path_success = success;\n-                Ok(path)\n-            });\n-            if visible_path_success {\n-                return if let (Some(generics), Some(substs)) = (generics, substs) {\n-                    let args = self.generic_args_to_print(generics, substs);\n-                    self.path_generic_args(|cx| cx.ok(), args)\n-                } else {\n-                    self.ok()\n-                };\n+        match ty.sty {\n+            ty::Bool => p!(write(\"bool\")),\n+            ty::Char => p!(write(\"char\")),\n+            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::RawPtr(ref tm) => {\n+                p!(write(\"*{} \", match tm.mutbl {\n+                    hir::MutMutable => \"mut\",\n+                    hir::MutImmutable => \"const\",\n+                }));\n+                p!(print(tm.ty))\n             }\n-        }\n-\n-        let key = self.tcx.def_key(def_id);\n-        if let DefPathData::Impl = key.disambiguated_data.data {\n-            // Always use types for non-local impls, where types are always\n-            // available, and filename/line-number is mostly uninteresting.\n-            let use_types =\n-                !def_id.is_local() || {\n-                    // Otherwise, use filename/line-number if forced.\n-                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-                    !force_no_types\n-                };\n-\n-            if !use_types {\n-                // If no type info is available, fall back to\n-                // pretty printing some span information. This should\n-                // only occur very early in the compiler pipeline.\n-                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let span = self.tcx.def_span(def_id);\n-                return self.path_append(\n-                    |cx| cx.print_def_path(parent_def_id, None),\n-                    &format!(\"<impl at {:?}>\", span),\n-                );\n+            ty::Ref(r, ty, mutbl) => {\n+                p!(write(\"&\"));\n+                if self.region_should_not_be_omitted(r) {\n+                    p!(print(r), write(\" \"));\n+                }\n+                p!(print(ty::TypeAndMut { ty, mutbl }))\n             }\n-        }\n-\n-        self.default_print_def_path(def_id, substs)\n-    }\n-\n-    fn print_region(\n-        self: PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n-        self.pretty_print_region(region)\n-    }\n-\n-    fn print_type(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n-        self.pretty_print_type(ty)\n-    }\n-\n-    fn print_dyn_existential(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<Self::DynExistential, Self::Error> {\n-        self.pretty_print_dyn_existential(predicates)\n-    }\n-\n-    fn path_crate(\n-        mut self: PrintCx<'_, '_, '_, Self>,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.empty_path = true;\n-        if cnum == LOCAL_CRATE {\n-            if self.tcx.sess.rust_2018() {\n-                // We add the `crate::` keyword on Rust 2018, only when desired.\n-                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                    write!(self, \"{}\", keywords::Crate.name())?;\n-                    self.empty_path = false;\n+            ty::Never => p!(write(\"!\")),\n+            ty::Tuple(ref tys) => {\n+                p!(write(\"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    p!(print(ty), write(\",\"));\n+                    if let Some(&ty) = tys.next() {\n+                        p!(write(\" \"), print(ty));\n+                        for &ty in tys {\n+                            p!(write(\", \"), print(ty));\n+                        }\n+                    }\n                 }\n+                p!(write(\")\"))\n             }\n-        } else {\n-            write!(self, \"{}\", self.tcx.crate_name(cnum))?;\n-            self.empty_path = false;\n-        }\n-        self.ok()\n-    }\n-    fn path_qualified(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut path = self.pretty_path_qualified(self_ty, trait_ref)?;\n-        path.empty_path = false;\n-        Ok(path)\n-    }\n-\n-    fn path_append_impl<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut path = self.pretty_path_append_impl(|cx| {\n-            let mut path = print_prefix(cx)?;\n-            if !path.empty_path {\n-                write!(path, \"::\")?;\n+            ty::FnDef(def_id, substs) => {\n+                let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n+                p!(print(sig), write(\" {{\"));\n+                self = self.print_value_path(def_id, Some(substs))?;\n+                p!(write(\"}}\"))\n             }\n-\n-            Ok(path)\n-        }, self_ty, trait_ref)?;\n-        path.empty_path = false;\n-        Ok(path)\n-    }\n-    fn path_append<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n-        text: &str,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut path = print_prefix(self)?;\n-\n-        // FIXME(eddyb) `text` should never be empty, but it\n-        // currently is for `extern { ... }` \"foreign modules\".\n-        if !text.is_empty() {\n-            if !path.empty_path {\n-                write!(path, \"::\")?;\n+            ty::FnPtr(ref bare_fn) => {\n+                p!(print(bare_fn))\n             }\n-            write!(path, \"{}\", text)?;\n-            path.empty_path = false;\n-        }\n-\n-        Ok(path)\n-    }\n-    fn path_generic_args<'gcx, 'tcx>(\n-        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n-    ) -> Result<Self::Path, Self::Error> {\n-        define_scoped_cx!(self);\n-\n-        nest!(print_prefix(self));\n+            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n+            ty::Error => p!(write(\"[type error]\")),\n+            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n+            ty::Bound(debruijn, bound_ty) => {\n+                match bound_ty.kind {\n+                    ty::BoundTyKind::Anon => {\n+                        if debruijn == ty::INNERMOST {\n+                            p!(write(\"^{}\", bound_ty.var.index()))\n+                        } else {\n+                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n+                        }\n+                    }\n \n-        // Don't print `'_` if there's no unerased regions.\n-        let print_regions = args.iter().any(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n-                _ => false,\n+                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n+                }\n             }\n-        });\n-        let args = args.iter().cloned().filter(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => print_regions,\n-                _ => true,\n-            }\n-        });\n-\n-        if args.clone().next().is_some() {\n-            if self.in_value {\n-                write!(self, \"::\")?;\n-            }\n-            self.generic_delimiters(|cx| cx.comma_sep(args))\n-        } else {\n-            self.ok()\n-        }\n-    }\n-}\n-\n-impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n-    fn print_value_path(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n-        def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let was_in_value = std::mem::replace(&mut self.in_value, true);\n-        let mut path = self.print_def_path(def_id, substs)?;\n-        path.in_value = was_in_value;\n-\n-        Ok(path)\n-    }\n-\n-    fn in_binder<T>(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n-    {\n-        self.pretty_in_binder(value)\n-    }\n-\n-    fn generic_delimiters<'gcx, 'tcx>(\n-        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error> {\n-        write!(self, \"<\")?;\n-\n-        let was_in_value = std::mem::replace(&mut self.in_value, false);\n-        let mut inner = f(self)?;\n-        inner.in_value = was_in_value;\n-\n-        write!(inner, \">\")?;\n-        Ok(inner)\n-    }\n-\n-    fn region_should_not_be_omitted(\n-        self: &PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> bool {\n-        let highlight = self.region_highlight_mode;\n-        if highlight.region_highlighted(region).is_some() {\n-            return true;\n-        }\n-\n-        if self.tcx.sess.verbose() {\n-            return true;\n-        }\n-\n-        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n-\n-        match *region {\n-            ty::ReEarlyBound(ref data) => {\n-                data.name != \"\" && data.name != \"'_\"\n-            }\n-\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n-                        return true;\n-                    }\n-                }\n-\n-                if let Some((region, _)) = highlight.highlight_bound_region {\n-                    if br == region {\n-                        return true;\n-                    }\n-                }\n-\n-                false\n-            }\n-\n-            ty::ReScope(_) |\n-            ty::ReVar(_) if identify_regions => true,\n-\n-            ty::ReVar(_) |\n-            ty::ReScope(_) |\n-            ty::ReErased => false,\n-\n-            ty::ReStatic |\n-            ty::ReEmpty |\n-            ty::ReClosureBound(_) => true,\n-        }\n-    }\n-}\n-\n-// HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n-impl<F: fmt::Write> FmtPrinter<F> {\n-    pub fn pretty_print_region(\n-        mut self: PrintCx<'_, '_, '_, Self>,\n-        region: ty::Region<'_>,\n-    ) -> Result<Self, fmt::Error> {\n-        define_scoped_cx!(self);\n-\n-        // Watch out for region highlights.\n-        let highlight = self.region_highlight_mode;\n-        if let Some(n) = highlight.region_highlighted(region) {\n-            p!(write(\"'{}\", n));\n-            return self.ok();\n-        }\n-\n-        if self.tcx.sess.verbose() {\n-            p!(write(\"{:?}\", region));\n-            return self.ok();\n-        }\n-\n-        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n-\n-        // These printouts are concise.  They do not contain all the information\n-        // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n-        // `explain_region()` or `note_and_explain_region()`.\n-        match *region {\n-            ty::ReEarlyBound(ref data) => {\n-                if data.name != \"\" {\n-                    p!(write(\"{}\", data.name));\n-                    return self.ok();\n-                }\n-            }\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n-                        p!(write(\"{}\", name));\n-                        return self.ok();\n-                    }\n-                }\n-\n-                if let Some((region, counter)) = highlight.highlight_bound_region {\n-                    if br == region {\n-                        p!(write(\"'{}\", counter));\n-                        return self.ok();\n-                    }\n-                }\n-            }\n-            ty::ReScope(scope) if identify_regions => {\n-                match scope.data {\n-                    region::ScopeData::Node =>\n-                        p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::CallSite =>\n-                        p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::Arguments =>\n-                        p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::Destruction =>\n-                        p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n-                        \"'{}_{}rs\",\n-                        scope.item_local_id().as_usize(),\n-                        first_statement_index.index()\n-                    )),\n-                }\n-                return self.ok();\n-            }\n-            ty::ReVar(region_vid) if identify_regions => {\n-                p!(write(\"{:?}\", region_vid));\n-                return self.ok();\n-            }\n-            ty::ReVar(_) => {}\n-            ty::ReScope(_) |\n-            ty::ReErased => {}\n-            ty::ReStatic => {\n-                p!(write(\"'static\"));\n-                return self.ok();\n-            }\n-            ty::ReEmpty => {\n-                p!(write(\"'<empty>\"));\n-                return self.ok();\n-            }\n-\n-            // The user should never encounter these in unsubstituted form.\n-            ty::ReClosureBound(vid) => {\n-                p!(write(\"{:?}\", vid));\n-                return self.ok();\n-            }\n-        }\n-\n-        p!(write(\"'_\"));\n-\n-        self.ok()\n-    }\n-}\n-\n-impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n-    pub fn pretty_print_type(\n-        mut self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<P::Type, P::Error> {\n-        define_scoped_cx!(self);\n-\n-        match ty.sty {\n-            ty::Bool => p!(write(\"bool\")),\n-            ty::Char => p!(write(\"char\")),\n-            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::RawPtr(ref tm) => {\n-                p!(write(\"*{} \", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n-                }));\n-                p!(print(tm.ty))\n-            }\n-            ty::Ref(r, ty, mutbl) => {\n-                p!(write(\"&\"));\n-                if self.region_should_not_be_omitted(r) {\n-                    p!(print(r), write(\" \"));\n-                }\n-                p!(print(ty::TypeAndMut { ty, mutbl }))\n-            }\n-            ty::Never => p!(write(\"!\")),\n-            ty::Tuple(ref tys) => {\n-                p!(write(\"(\"));\n-                let mut tys = tys.iter();\n-                if let Some(&ty) = tys.next() {\n-                    p!(print(ty), write(\",\"));\n-                    if let Some(&ty) = tys.next() {\n-                        p!(write(\" \"), print(ty));\n-                        for &ty in tys {\n-                            p!(write(\", \"), print(ty));\n-                        }\n-                    }\n-                }\n-                p!(write(\")\"))\n-            }\n-            ty::FnDef(def_id, substs) => {\n-                let sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n-                p!(print(sig), write(\" {{\"));\n-                nest!(self.print_value_path(def_id, Some(substs)));\n-                p!(write(\"}}\"))\n-            }\n-            ty::FnPtr(ref bare_fn) => {\n-                p!(print(bare_fn))\n-            }\n-            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n-            ty::Error => p!(write(\"[type error]\")),\n-            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n-            ty::Bound(debruijn, bound_ty) => {\n-                match bound_ty.kind {\n-                    ty::BoundTyKind::Anon => {\n-                        if debruijn == ty::INNERMOST {\n-                            p!(write(\"^{}\", bound_ty.var.index()))\n-                        } else {\n-                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n-                        }\n-                    }\n-\n-                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n-                }\n-            }\n-            ty::Adt(def, substs) => {\n-                nest!(self.print_def_path(def.did, Some(substs)));\n+            ty::Adt(def, substs) => {\n+                self = self.print_def_path(def.did, Some(substs))?;\n             }\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n@@ -982,7 +507,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Foreign(def_id) => {\n-                nest!(self.print_def_path(def_id, None));\n+                self = self.print_def_path(def_id, None)?;\n             }\n             ty::Projection(ref data) => p!(print(data)),\n             ty::UnnormalizedProjection(ref data) => {\n@@ -993,12 +518,12 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n             ty::Opaque(def_id, substs) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n-                if self.tcx.sess.verbose() {\n+                if self.tcx().sess.verbose() {\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n-                    return self.ok();\n+                    return Ok(self);\n                 }\n \n-                let def_key = self.tcx.def_key(def_id);\n+                let def_key = self.tcx().def_key(def_id);\n                 if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n                     p!(write(\"{}\", name));\n                     let mut substs = substs.iter();\n@@ -1011,19 +536,19 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                         }\n                         p!(write(\">\"));\n                     }\n-                    return self.ok();\n+                    return Ok(self);\n                 }\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n+                let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n \n                 let mut first = true;\n                 let mut is_sized = false;\n                 p!(write(\"impl\"));\n                 for predicate in bounds.predicates {\n                     if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                         // Don't print +Sized, but rather +?Sized if absent.\n-                        if Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n+                        if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                             is_sized = true;\n                             continue;\n                         }\n@@ -1042,19 +567,19 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n             ty::Str => p!(write(\"str\")),\n             ty::Generator(did, substs, movability) => {\n-                let upvar_tys = substs.upvar_tys(did, self.tcx);\n-                let witness = substs.witness(did, self.tcx);\n+                let upvar_tys = substs.upvar_tys(did, self.tcx());\n+                let witness = substs.witness(did, self.tcx());\n                 if movability == hir::GeneratorMovability::Movable {\n                     p!(write(\"[generator\"));\n                 } else {\n                     p!(write(\"[static generator\"));\n                 }\n \n                 // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n-                    p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n+                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                    p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n+                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n                         .as_ref()\n                         .map_or(&[][..], |fv| &fv[..])\n                         .iter()\n@@ -1063,7 +588,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx.hir().name(freevar.var_id())),\n+                                    self.tcx().hir().name(freevar.var_id())),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }\n@@ -1083,21 +608,21 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 p!(write(\" \"), print(witness), write(\"]\"))\n             },\n             ty::GeneratorWitness(types) => {\n-                nest!(self.in_binder(&types))\n+                self = self.in_binder(&types)?;\n             }\n             ty::Closure(did, substs) => {\n-                let upvar_tys = substs.upvar_tys(did, self.tcx);\n+                let upvar_tys = substs.upvar_tys(did, self.tcx());\n                 p!(write(\"[closure\"));\n \n                 // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n-                    if self.tcx.sess.opts.debugging_opts.span_free_formats {\n+                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                    if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@{:?}\", hir_id));\n                     } else {\n-                        p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n+                        p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     }\n                     let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n+                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n                         .as_ref()\n                         .map_or(&[][..], |fv| &fv[..])\n                         .iter()\n@@ -1106,7 +631,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx.hir().name(freevar.var_id())),\n+                                    self.tcx().hir().name(freevar.var_id())),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }\n@@ -1123,11 +648,11 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                     }\n                 }\n \n-                if self.tcx.sess.verbose() {\n+                if self.tcx().sess.verbose() {\n                     p!(write(\n                         \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                        substs.closure_kind_ty(did, self.tcx),\n-                        substs.closure_sig_ty(did, self.tcx)\n+                        substs.closure_kind_ty(did, self.tcx()),\n+                        substs.closure_sig_ty(did, self.tcx())\n                     ));\n                 }\n \n@@ -1144,7 +669,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                             ConstValue::Infer(..) => p!(write(\"_\")),\n                             ConstValue::Param(ParamConst { name, .. }) =>\n                                 p!(write(\"{}\", name)),\n-                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx))),\n+                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx()))),\n                         }\n                     }\n                 }\n@@ -1155,30 +680,30 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n         }\n \n-        self.ok()\n+        Ok(self)\n     }\n \n     fn pretty_print_dyn_existential(\n         mut self,\n         predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<P::DynExistential, P::Error> {\n+    ) -> Result<Self::DynExistential, Self::Error> {\n         define_scoped_cx!(self);\n \n         // Generate the main trait ref, including associated types.\n         let mut first = true;\n \n         if let Some(principal) = predicates.principal() {\n-            nest!(self.print_def_path(principal.def_id, None));\n+            self = self.print_def_path(principal.def_id, None)?;\n \n             let mut resugared = false;\n \n             // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx.lang_items().fn_trait_kind(principal.def_id);\n-            if !self.tcx.sess.verbose() && fn_trait_kind.is_some() {\n+            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n                     let mut projections = predicates.projection_bounds();\n                     if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                        nest!(self.pretty_fn_sig(args, false, proj.ty));\n+                        self = self.pretty_fn_sig(args, false, proj.ty)?;\n                         resugared = true;\n                     }\n                 }\n@@ -1188,11 +713,11 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             // in order to place the projections inside the `<...>`.\n             if !resugared {\n                 // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = self.tcx.mk_infer(ty::FreshTy(0));\n-                let principal = principal.with_self_ty(self.tcx, dummy_self);\n+                let dummy_self = self.tcx().mk_infer(ty::FreshTy(0));\n+                let principal = principal.with_self_ty(self.tcx(), dummy_self);\n \n                 let args = self.generic_args_to_print(\n-                    self.tcx.generics_of(principal.def_id),\n+                    self.tcx().generics_of(principal.def_id),\n                     principal.substs,\n                 );\n \n@@ -1217,13 +742,13 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                     let args = arg0.into_iter().chain(args);\n                     let projections = projection0.into_iter().chain(projections);\n \n-                    nest!(self.generic_delimiters(|mut cx| {\n-                        cx = PrintCx::new(cx.tcx, cx.comma_sep(args)?);\n+                    self = self.generic_delimiters(|mut cx| {\n+                        cx = cx.comma_sep(args)?;\n                         if arg0.is_some() && projection0.is_some() {\n                             write!(cx, \", \")?;\n                         }\n                         cx.comma_sep(projections)\n-                    }));\n+                    })?;\n                 }\n             }\n             first = false;\n@@ -1233,7 +758,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         // FIXME(eddyb) avoid printing twice (needed to ensure\n         // that the auto traits are sorted *and* printed via cx).\n         let mut auto_traits: Vec<_> = predicates.auto_traits().map(|did| {\n-            (self.tcx.def_path_str(did), did)\n+            (self.tcx().def_path_str(did), did)\n         }).collect();\n \n         // The auto traits come ordered by `DefPathHash`. While\n@@ -1251,18 +776,18 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n             first = false;\n \n-            nest!(self.print_def_path(def_id, None));\n+            self = self.print_def_path(def_id, None)?;\n         }\n \n-        self.ok()\n+        Ok(self)\n     }\n \n-    pub fn pretty_fn_sig(\n+    fn pretty_fn_sig(\n         mut self,\n         inputs: &[Ty<'tcx>],\n         c_variadic: bool,\n         output: Ty<'tcx>,\n-    ) -> Result<P, fmt::Error> {\n+    ) -> Result<Self, Self::Error> {\n         define_scoped_cx!(self);\n \n         p!(write(\"(\"));\n@@ -1281,30 +806,476 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             p!(write(\" -> \"), print(output));\n         }\n \n-        self.ok()\n+        Ok(self)\n     }\n }\n \n-// HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n-// `region_index` and `used_region_names`.\n-impl<F: fmt::Write> FmtPrinter<F> {\n-    pub fn pretty_in_binder<T>(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, fmt::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n-    {\n-        fn name_by_region_index(index: usize) -> InternedString {\n-            match index {\n-                0 => Symbol::intern(\"'r\"),\n-                1 => Symbol::intern(\"'s\"),\n-                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n-            }.as_interned_str()\n-        }\n+// HACK(eddyb) boxed to avoid moving around a large struct by-value.\n+pub struct FmtPrinter<'a, 'gcx, 'tcx, F>(Box<FmtPrinterData<'a, 'gcx, 'tcx, F>>);\n \n-        // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n-        // clearly differentiate between named and unnamed regions in\n+pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fmt: F,\n+\n+    empty_path: bool,\n+    in_value: bool,\n+\n+    used_region_names: FxHashSet<InternedString>,\n+    region_index: usize,\n+    binder_depth: usize,\n+\n+    pub region_highlight_mode: RegionHighlightMode,\n+}\n+\n+impl<F> Deref for FmtPrinter<'a, 'gcx, 'tcx, F> {\n+    type Target = FmtPrinterData<'a, 'gcx, 'tcx, F>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<F> DerefMut for FmtPrinter<'_, '_, '_, F> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n+        FmtPrinter(Box::new(FmtPrinterData {\n+            tcx,\n+            fmt,\n+            empty_path: false,\n+            in_value: ns == Namespace::ValueNS,\n+            used_region_names: Default::default(),\n+            region_index: 0,\n+            binder_depth: 0,\n+            region_highlight_mode: RegionHighlightMode::default(),\n+        }))\n+    }\n+}\n+\n+impl TyCtxt<'_, '_, '_> {\n+    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n+    // (but also some things just print a `DefId` generally so maybe we need this?)\n+    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n+        match self.def_key(def_id).disambiguated_data.data {\n+            DefPathData::ValueNs(..) |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::Field(..) |\n+            DefPathData::AnonConst |\n+            DefPathData::ConstParam(..) |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor => Namespace::ValueNS,\n+\n+            DefPathData::MacroDef(..) => Namespace::MacroNS,\n+\n+            _ => Namespace::TypeNS,\n+        }\n+    }\n+\n+    /// Returns a string identifying this `DefId`. This string is\n+    /// suitable for user output.\n+    pub fn def_path_str(self, def_id: DefId) -> String {\n+        let ns = self.guess_def_namespace(def_id);\n+        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        let mut s = String::new();\n+        let _ = FmtPrinter::new(self, &mut s, ns)\n+            .print_def_path(def_id, None);\n+        s\n+    }\n+}\n+\n+impl<F: fmt::Write> fmt::Write for FmtPrinter<'_, '_, '_, F> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.fmt.write_str(s)\n+    }\n+}\n+\n+impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_def_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n+        // both here and in `default_print_def_path`.\n+        let generics = substs.map(|_| self.tcx.generics_of(def_id));\n+        if generics.as_ref().and_then(|g| g.parent).is_none() {\n+            match self.try_print_visible_def_path(def_id)? {\n+                (cx, true) => return if let (Some(generics), Some(substs)) = (generics, substs) {\n+                    let args = cx.generic_args_to_print(generics, substs);\n+                    cx.path_generic_args(Ok, args)\n+                } else {\n+                    Ok(cx)\n+                },\n+                (cx, false) => self = cx,\n+            }\n+        }\n+\n+        let key = self.tcx.def_key(def_id);\n+        if let DefPathData::Impl = key.disambiguated_data.data {\n+            // Always use types for non-local impls, where types are always\n+            // available, and filename/line-number is mostly uninteresting.\n+            let use_types =\n+                !def_id.is_local() || {\n+                    // Otherwise, use filename/line-number if forced.\n+                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+                    !force_no_types\n+                };\n+\n+            if !use_types {\n+                // If no type info is available, fall back to\n+                // pretty printing some span information. This should\n+                // only occur very early in the compiler pipeline.\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let span = self.tcx.def_span(def_id);\n+                return self.path_append(\n+                    |cx| cx.print_def_path(parent_def_id, None),\n+                    &format!(\"<impl at {:?}>\", span),\n+                );\n+            }\n+        }\n+\n+        self.default_print_def_path(def_id, substs)\n+    }\n+\n+    fn print_region(\n+        self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        self.pretty_print_region(region)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        self.pretty_print_type(ty)\n+    }\n+\n+    fn print_dyn_existential(\n+        self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        self.pretty_print_dyn_existential(predicates)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.empty_path = true;\n+        if cnum == LOCAL_CRATE {\n+            if self.tcx.sess.rust_2018() {\n+                // We add the `crate::` keyword on Rust 2018, only when desired.\n+                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                    write!(self, \"{}\", keywords::Crate.name())?;\n+                    self.empty_path = false;\n+                }\n+            }\n+        } else {\n+            write!(self, \"{}\", self.tcx.crate_name(cnum))?;\n+            self.empty_path = false;\n+        }\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        mut self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = self.pretty_path_qualified(self_ty, trait_ref)?;\n+        self.empty_path = false;\n+        Ok(self)\n+    }\n+\n+    fn path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = self.pretty_path_append_impl(|mut cx| {\n+            cx = print_prefix(cx)?;\n+            if !cx.empty_path {\n+                write!(cx, \"::\")?;\n+            }\n+\n+            Ok(cx)\n+        }, self_ty, trait_ref)?;\n+        self.empty_path = false;\n+        Ok(self)\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        text: &str,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // FIXME(eddyb) `text` should never be empty, but it\n+        // currently is for `extern { ... }` \"foreign modules\".\n+        if !text.is_empty() {\n+            if !self.empty_path {\n+                write!(self, \"::\")?;\n+            }\n+            write!(self, \"{}\", text)?;\n+            self.empty_path = false;\n+        }\n+\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Don't print `'_` if there's no unerased regions.\n+        let print_regions = args.iter().any(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            if self.in_value {\n+                write!(self, \"::\")?;\n+            }\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    fn print_value_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: Option<SubstsRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let was_in_value = std::mem::replace(&mut self.in_value, true);\n+        self = self.print_def_path(def_id, substs)?;\n+        self.in_value = was_in_value;\n+\n+        Ok(self)\n+    }\n+\n+    fn in_binder<T>(\n+        self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        self.pretty_in_binder(value)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let was_in_value = std::mem::replace(&mut self.in_value, false);\n+        let mut inner = f(self)?;\n+        inner.in_value = was_in_value;\n+\n+        write!(inner, \">\")?;\n+        Ok(inner)\n+    }\n+\n+    fn region_should_not_be_omitted(\n+        &self,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        let highlight = self.region_highlight_mode;\n+        if highlight.region_highlighted(region).is_some() {\n+            return true;\n+        }\n+\n+        if self.tcx.sess.verbose() {\n+            return true;\n+        }\n+\n+        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n+\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                data.name != \"\" && data.name != \"'_\"\n+            }\n+\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some((region, _)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            ty::ReScope(_) |\n+            ty::ReVar(_) if identify_regions => true,\n+\n+            ty::ReVar(_) |\n+            ty::ReScope(_) |\n+            ty::ReErased => false,\n+\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReClosureBound(_) => true,\n+        }\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n+impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n+    pub fn pretty_print_region(\n+        mut self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self, fmt::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Watch out for region highlights.\n+        let highlight = self.region_highlight_mode;\n+        if let Some(n) = highlight.region_highlighted(region) {\n+            p!(write(\"'{}\", n));\n+            return Ok(self);\n+        }\n+\n+        if self.tcx.sess.verbose() {\n+            p!(write(\"{:?}\", region));\n+            return Ok(self);\n+        }\n+\n+        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n+\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                if data.name != \"\" {\n+                    p!(write(\"{}\", data.name));\n+                    return Ok(self);\n+                }\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        p!(write(\"{}\", name));\n+                        return Ok(self);\n+                    }\n+                }\n+\n+                if let Some((region, counter)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        p!(write(\"'{}\", counter));\n+                        return Ok(self);\n+                    }\n+                }\n+            }\n+            ty::ReScope(scope) if identify_regions => {\n+                match scope.data {\n+                    region::ScopeData::Node =>\n+                        p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::CallSite =>\n+                        p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Arguments =>\n+                        p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Destruction =>\n+                        p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n+                        \"'{}_{}rs\",\n+                        scope.item_local_id().as_usize(),\n+                        first_statement_index.index()\n+                    )),\n+                }\n+                return Ok(self);\n+            }\n+            ty::ReVar(region_vid) if identify_regions => {\n+                p!(write(\"{:?}\", region_vid));\n+                return Ok(self);\n+            }\n+            ty::ReVar(_) => {}\n+            ty::ReScope(_) |\n+            ty::ReErased => {}\n+            ty::ReStatic => {\n+                p!(write(\"'static\"));\n+                return Ok(self);\n+            }\n+            ty::ReEmpty => {\n+                p!(write(\"'<empty>\"));\n+                return Ok(self);\n+            }\n+\n+            // The user should never encounter these in unsubstituted form.\n+            ty::ReClosureBound(vid) => {\n+                p!(write(\"{:?}\", vid));\n+                return Ok(self);\n+            }\n+        }\n+\n+        p!(write(\"'_\"));\n+\n+        Ok(self)\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n+// `region_index` and `used_region_names`.\n+impl<F: fmt::Write> FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    pub fn pretty_in_binder<T>(\n+        mut self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, fmt::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n+    {\n+        fn name_by_region_index(index: usize) -> InternedString {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }.as_interned_str()\n+        }\n+\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         if self.binder_depth == 0 {\n@@ -1382,107 +1353,94 @@ impl<F: fmt::Write> FmtPrinter<F> {\n     }\n }\n \n-impl<T, P: PrettyPrinter> Print<'tcx, P> for ty::Binder<T>\n-    where T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n+impl<'gcx: 'tcx, 'tcx, T, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for ty::Binder<T>\n+    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n {\n     type Output = P;\n     type Error = P::Error;\n-    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.in_binder(self)\n     }\n }\n \n-pub trait LiftAndPrintToFmt<'tcx> {\n-    fn lift_and_print_to_fmt(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        f: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result;\n-}\n-\n-impl<T> LiftAndPrintToFmt<'tcx> for T\n-    where T: ty::Lift<'tcx>,\n-          for<'a, 'b> <T as ty::Lift<'tcx>>::Lifted:\n-            Print<'tcx, FmtPrinter<&'a mut fmt::Formatter<'b>>, Error = fmt::Error>\n+impl<'gcx: 'tcx, 'tcx, T, U, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for ty::OutlivesPredicate<T, U>\n+    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n+          U: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n {\n-    fn lift_and_print_to_fmt(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        f: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        tcx.lift(self)\n-            .expect(\"could not lift for printing\")\n-            .print(PrintCx::new(tcx, FmtPrinter::new(f, Namespace::TypeNS)))?;\n-        Ok(())\n-    }\n-}\n-\n-// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n-impl LiftAndPrintToFmt<'tcx> for ty::RegionKind {\n-    fn lift_and_print_to_fmt(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        f: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        self.print(PrintCx::new(tcx, FmtPrinter::new(f, Namespace::TypeNS)))?;\n-        Ok(())\n+    type Output = P;\n+    type Error = P::Error;\n+    fn print(&self, mut cx: P) -> Result<Self::Output, Self::Error> {\n+        define_scoped_cx!(cx);\n+        p!(print(self.0), write(\" : \"), print(self.1));\n+        Ok(cx)\n     }\n }\n \n macro_rules! forward_display_to_print {\n-    (<$($T:ident),*> $ty:ty) => {\n-        impl<$($T),*> fmt::Display for $ty\n-            where Self: for<'a> LiftAndPrintToFmt<'a>\n-        {\n+    ($($ty:ty),+) => {\n+        $(impl fmt::Display for $ty {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                ty::tls::with(|tcx| self.lift_and_print_to_fmt(tcx, f))\n+                ty::tls::with(|tcx| {\n+                    tcx.lift(self)\n+                        .expect(\"could not lift for printing\")\n+                        .print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n+                    Ok(())\n+                })\n             }\n-        }\n-    };\n-\n-    ($ty:ty) => {\n-        forward_display_to_print!(<> $ty);\n+        })+\n     };\n }\n \n macro_rules! define_print_and_forward_display {\n-    (($self:ident, $cx:ident): <$($T:ident),*> $ty:ty $print:block) => {\n-        impl<$($T,)* P: PrettyPrinter> Print<'tcx, P> for $ty\n-            where $($T: Print<'tcx, P, Output = P, Error = P::Error>),*\n-        {\n+    (($self:ident, $cx:ident): $($ty:ty $print:block)+) => {\n+        $(impl<'gcx: 'tcx, 'tcx, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for $ty {\n             type Output = P;\n             type Error = fmt::Error;\n-            fn print(&$self, $cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+            fn print(&$self, $cx: P) -> Result<Self::Output, Self::Error> {\n                 #[allow(unused_mut)]\n                 let mut $cx = $cx;\n                 define_scoped_cx!($cx);\n                 let _: () = $print;\n                 #[allow(unreachable_code)]\n-                $cx.ok()\n+                Ok($cx)\n             }\n-        }\n+        })+\n \n-        forward_display_to_print!(<$($T),*> $ty);\n-    };\n-\n-    (($self:ident, $cx:ident): $($ty:ty $print:block)+) => {\n-        $(define_print_and_forward_display!(($self, $cx): <> $ty $print);)+\n+        forward_display_to_print!($($ty),+);\n     };\n }\n \n-forward_display_to_print!(ty::RegionKind);\n-forward_display_to_print!(Ty<'tcx>);\n-forward_display_to_print!(&'tcx ty::List<ty::ExistentialPredicate<'tcx>>);\n-forward_display_to_print!(<T> ty::Binder<T>);\n-\n-define_print_and_forward_display! {\n-    (self, cx):\n-\n-    <T, U> ty::OutlivesPredicate<T, U> {\n-        p!(print(self.0), write(\" : \"), print(self.1))\n+// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n+impl fmt::Display for ty::RegionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            self.print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n+            Ok(())\n+        })\n     }\n }\n \n+forward_display_to_print! {\n+    Ty<'tcx>,\n+    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+\n+    // HACK(eddyb) these are exhaustive instead of generic,\n+    // because `for<'gcx: 'tcx, 'tcx>` isn't possible yet.\n+    ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+    ty::Binder<ty::TraitRef<'tcx>>,\n+    ty::Binder<ty::FnSig<'tcx>>,\n+    ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n+\n+    ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n+    ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+}\n+\n define_print_and_forward_display! {\n     (self, cx):\n \n@@ -1505,13 +1463,13 @@ define_print_and_forward_display! {\n \n     ty::ExistentialTraitRef<'tcx> {\n         // Use a type that can't appear in defaults of type parameters.\n-        let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n-        let trait_ref = self.with_self_ty(cx.tcx, dummy_self);\n+        let dummy_self = cx.tcx().mk_infer(ty::FreshTy(0));\n+        let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n         p!(print(trait_ref))\n     }\n \n     ty::ExistentialProjection<'tcx> {\n-        let name = cx.tcx.associated_item(self.item_def_id).ident;\n+        let name = cx.tcx().associated_item(self.item_def_id).ident;\n         p!(write(\"{}=\", name), print(self.ty))\n     }\n \n@@ -1520,7 +1478,7 @@ define_print_and_forward_display! {\n             ty::ExistentialPredicate::Trait(x) => p!(print(x)),\n             ty::ExistentialPredicate::Projection(x) => p!(print(x)),\n             ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                nest!(cx.print_def_path(def_id, None))\n+                cx = cx.print_def_path(def_id, None)?;\n             }\n         }\n     }\n@@ -1535,13 +1493,13 @@ define_print_and_forward_display! {\n         }\n \n         p!(write(\"fn\"));\n-        nest!(cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+        cx = cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output())?;\n     }\n \n     ty::InferTy {\n-        if cx.tcx.sess.verbose() {\n+        if cx.tcx().sess.verbose() {\n             p!(write(\"{:?}\", self));\n-            return cx.ok();\n+            return Ok(cx);\n         }\n         match *self {\n             ty::TyVar(_) => p!(write(\"_\")),\n@@ -1554,7 +1512,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitRef<'tcx> {\n-        nest!(cx.print_def_path(self.def_id, Some(self.substs)));\n+        cx = cx.print_def_path(self.def_id, Some(self.substs))?;\n     }\n \n     ConstValue<'tcx> {\n@@ -1569,7 +1527,7 @@ define_print_and_forward_display! {\n         p!(write(\"{} : {}\", self.val, self.ty))\n     }\n \n-    ty::LazyConst<'tcx> {\n+    &'tcx ty::LazyConst<'tcx> {\n         match self {\n             // FIXME(const_generics) this should print at least the type.\n             ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n@@ -1598,7 +1556,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ProjectionTy<'tcx> {\n-        nest!(cx.print_def_path(self.item_def_id, Some(self.substs)));\n+        cx = cx.print_def_path(self.item_def_id, Some(self.substs))?;\n     }\n \n     ty::ClosureKind {\n@@ -1619,17 +1577,17 @@ define_print_and_forward_display! {\n             ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"));\n-                nest!(cx.print_def_path(trait_def_id, None));\n+                cx = cx.print_def_path(trait_def_id, None)?;\n                 p!(write(\"` is object-safe\"))\n             }\n             ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"));\n-                nest!(cx.print_value_path(closure_def_id, None));\n+                cx = cx.print_value_path(closure_def_id, None)?;\n                 p!(write(\"` implements the trait `{}`\", kind))\n             }\n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 p!(write(\"the constant `\"));\n-                nest!(cx.print_value_path(def_id, Some(substs)));\n+                cx = cx.print_value_path(def_id, Some(substs))?;\n                 p!(write(\"` can be evaluated\"))\n             }\n         }"}, {"sha": "4cbb315cefadb5a4d8b84c87e2cacdc6037a0977", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -8,7 +8,7 @@ use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::print::{FmtPrinter, PrintCx, Printer};\n+use crate::ty::print::{FmtPrinter, Printer};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n@@ -34,17 +34,19 @@ impl fmt::Debug for ty::GenericParamDef {\n \n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.print_def_path(self.def_id, None)?;\n+        ty::tls::with(|tcx| {\n+            FmtPrinter::new(tcx, f, Namespace::TypeNS)\n+                .print_def_path(self.def_id, None)?;\n             Ok(())\n         })\n     }\n }\n \n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.print_def_path(self.did, None)?;\n+        ty::tls::with(|tcx| {\n+            FmtPrinter::new(tcx, f, Namespace::TypeNS)\n+                .print_def_path(self.did, None)?;\n             Ok(())\n         })\n     }\n@@ -333,6 +335,7 @@ CloneTypeFoldableAndLiftImpls! {\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n+// FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -429,6 +432,23 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n+    type Lifted = ty::ExistentialPredicate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::ExistentialPredicate::Trait(x) => {\n+                tcx.lift(x).map(ty::ExistentialPredicate::Trait)\n+            }\n+            ty::ExistentialPredicate::Projection(x) => {\n+                tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n+            }\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                Some(ty::ExistentialPredicate::AutoTrait(*def_id))\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)"}, {"sha": "d1fcc88e59900b7769012213fb3ff1568fdeb320", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 90, "deletions": 87, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -92,7 +92,7 @@ use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::print::{PrettyPrinter, PrintCx, Printer, Print};\n+use rustc::ty::print::{PrettyPrinter, Printer, Print};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -223,10 +223,11 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    PrintCx::new(tcx, SymbolPath::new(tcx))\n-        .print_def_path(def_id, None)\n-        .unwrap()\n-        .into_interned()\n+    SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::new(),\n+        keep_within_component: false,\n+    }.print_def_path(def_id, None).unwrap().path.into_interned()\n }\n \n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n@@ -318,13 +319,17 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n \n-    let mut buf = SymbolPath::from_interned(tcx.def_symbol_name(def_id), tcx);\n+    let mut printer = SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::from_interned(tcx.def_symbol_name(def_id)),\n+        keep_within_component: false,\n+    };\n \n     if instance.is_vtable_shim() {\n-        let _ = buf.write_str(\"{{vtable-shim}}\");\n+        let _ = printer.write_str(\"{{vtable-shim}}\");\n     }\n \n-    buf.finish(hash)\n+    printer.path.finish(hash)\n }\n \n // Follow C++ namespace-mangling style, see\n@@ -344,33 +349,22 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n struct SymbolPath {\n     result: String,\n     temp_buf: String,\n-    strict_naming: bool,\n-\n-    // When `true`, `finalize_pending_component` isn't used.\n-    // This is needed when recursing into `path_qualified`,\n-    // or `path_generic_args`, as any nested paths are\n-    // logically within one component.\n-    keep_within_component: bool,\n }\n \n impl SymbolPath {\n-    fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    fn new() -> Self {\n         let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            strict_naming: tcx.has_strict_asm_symbol_naming(),\n-            keep_within_component: false,\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n     }\n \n-    fn from_interned(symbol: ty::SymbolName, tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    fn from_interned(symbol: ty::SymbolName) -> Self {\n         let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            strict_naming: tcx.has_strict_asm_symbol_naming(),\n-            keep_within_component: false,\n         };\n         result.result.push_str(&symbol.as_str());\n         result\n@@ -398,27 +392,42 @@ impl SymbolPath {\n     }\n }\n \n+struct SymbolPrinter<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    path: SymbolPath,\n+\n+    // When `true`, `finalize_pending_component` isn't used.\n+    // This is needed when recursing into `path_qualified`,\n+    // or `path_generic_args`, as any nested paths are\n+    // logically within one component.\n+    keep_within_component: bool,\n+}\n+\n // HACK(eddyb) this relies on using the `fmt` interface to get\n // `PrettyPrinter` aka pretty printing of e.g. types in paths,\n // symbol names should have their own printing machinery.\n \n-impl Printer for SymbolPath {\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n     type Region = Self;\n     type Type = Self;\n     type DynExistential = Self;\n \n+    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n     fn print_region(\n-        self: PrintCx<'_, '_, '_, Self>,\n+        self,\n         _region: ty::Region<'_>,\n     ) -> Result<Self::Region, Self::Error> {\n-        self.ok()\n+        Ok(self)\n     }\n \n     fn print_type(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         ty: Ty<'tcx>,\n     ) -> Result<Self::Type, Self::Error> {\n         match ty.sty {\n@@ -436,7 +445,7 @@ impl Printer for SymbolPath {\n     }\n \n     fn print_dyn_existential(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        mut self,\n         predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         let mut first = false;\n@@ -445,20 +454,20 @@ impl Printer for SymbolPath {\n                 write!(self, \"+\")?;\n             }\n             first = false;\n-            self = PrintCx::new(self.tcx, p.print(self)?);\n+            self = p.print(self)?;\n         }\n-        self.ok()\n+        Ok(self)\n     }\n \n     fn path_crate(\n-        mut self: PrintCx<'_, '_, '_, Self>,\n+        mut self,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error> {\n         self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n-        self.ok()\n+        Ok(self)\n     }\n     fn path_qualified(\n-        self: PrintCx<'_, '_, 'tcx, Self>,\n+        self,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n@@ -480,11 +489,9 @@ impl Printer for SymbolPath {\n         }\n     }\n \n-    fn path_append_impl<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n@@ -494,33 +501,29 @@ impl Printer for SymbolPath {\n             trait_ref,\n         )\n     }\n-    fn path_append<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error> {\n-        let mut path = print_prefix(self)?;\n+        self = print_prefix(self)?;\n \n-        if path.keep_within_component {\n+        if self.keep_within_component {\n             // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n-            path.write_str(\"::\")?;\n+            self.write_str(\"::\")?;\n         } else {\n-            path.finalize_pending_component();\n+            self.path.finalize_pending_component();\n         }\n \n-        path.write_str(text)?;\n-        Ok(path)\n+        self.write_str(text)?;\n+        Ok(self)\n     }\n-    fn path_generic_args<'gcx, 'tcx>(\n-        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, Self>,\n-        ) -> Result<Self::Path, Self::Error>,\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         args: &[Kind<'tcx>],\n     )  -> Result<Self::Path, Self::Error> {\n-        self = PrintCx::new(self.tcx, print_prefix(self)?);\n+        self = print_prefix(self)?;\n \n         let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n@@ -532,52 +535,52 @@ impl Printer for SymbolPath {\n         if args.clone().next().is_some() {\n             self.generic_delimiters(|cx| cx.comma_sep(args))\n         } else {\n-            self.ok()\n+            Ok(self)\n         }\n     }\n }\n \n-impl PrettyPrinter for SymbolPath {\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     fn region_should_not_be_omitted(\n-        self: &PrintCx<'_, '_, '_, Self>,\n+        &self,\n         _region: ty::Region<'_>,\n     ) -> bool {\n         false\n     }\n     fn comma_sep<T>(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        mut self,\n         mut elems: impl Iterator<Item = T>,\n     ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n+        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n     {\n         if let Some(first) = elems.next() {\n-            self = PrintCx::new(self.tcx, first.print(self)?);\n+            self = first.print(self)?;\n             for elem in elems {\n                 self.write_str(\",\")?;\n-                self = PrintCx::new(self.tcx, elem.print(self)?);\n+                self = elem.print(self)?;\n             }\n         }\n-        self.ok()\n+        Ok(self)\n     }\n \n-    fn generic_delimiters<'gcx, 'tcx>(\n-        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error> {\n         write!(self, \"<\")?;\n \n         let kept_within_component =\n             mem::replace(&mut self.keep_within_component, true);\n-        let mut path = f(self)?;\n-        path.keep_within_component = kept_within_component;\n+        self = f(self)?;\n+        self.keep_within_component = kept_within_component;\n \n-        write!(path, \">\")?;\n+        write!(self, \">\")?;\n \n-        Ok(path)\n+        Ok(self)\n     }\n }\n \n-impl fmt::Write for SymbolPath {\n+impl fmt::Write for SymbolPrinter<'_, '_> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         // Name sanitation. LLVM will happily accept identifiers with weird names, but\n         // gas doesn't!\n@@ -586,45 +589,45 @@ impl fmt::Write for SymbolPath {\n         // are replaced with '$' there.\n \n         for c in s.chars() {\n-            if self.temp_buf.is_empty() {\n+            if self.path.temp_buf.is_empty() {\n                 match c {\n                     'a'..='z' | 'A'..='Z' | '_' => {}\n                     _ => {\n                         // Underscore-qualify anything that didn't start as an ident.\n-                        self.temp_buf.push('_');\n+                        self.path.temp_buf.push('_');\n                     }\n                 }\n             }\n             match c {\n                 // Escape these with $ sequences\n-                '@' => self.temp_buf.push_str(\"$SP$\"),\n-                '*' => self.temp_buf.push_str(\"$BP$\"),\n-                '&' => self.temp_buf.push_str(\"$RF$\"),\n-                '<' => self.temp_buf.push_str(\"$LT$\"),\n-                '>' => self.temp_buf.push_str(\"$GT$\"),\n-                '(' => self.temp_buf.push_str(\"$LP$\"),\n-                ')' => self.temp_buf.push_str(\"$RP$\"),\n-                ',' => self.temp_buf.push_str(\"$C$\"),\n-\n-                '-' | ':' | '.' if self.strict_naming => {\n+                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.path.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n                     // NVPTX doesn't support these characters in symbol names.\n-                    self.temp_buf.push('$')\n+                    self.path.temp_buf.push('$')\n                 }\n \n                 // '.' doesn't occur in types and functions, so reuse it\n                 // for ':' and '-'\n-                '-' | ':' => self.temp_buf.push('.'),\n+                '-' | ':' => self.path.temp_buf.push('.'),\n \n                 // These are legal symbols\n-                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.temp_buf.push(c),\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n \n                 _ => {\n-                    self.temp_buf.push('$');\n+                    self.path.temp_buf.push('$');\n                     for c in c.escape_unicode().skip(1) {\n                         match c {\n                             '{' => {}\n-                            '}' => self.temp_buf.push('$'),\n-                            c => self.temp_buf.push(c),\n+                            '}' => self.path.temp_buf.push('$'),\n+                            c => self.path.temp_buf.push(c),\n                         }\n                     }\n                 }"}, {"sha": "861346473245729c3ad44b1b800b56de8d4edc99", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -2326,7 +2326,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// name where required.\n     fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(&mut s, Namespace::TypeNS);\n+        let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n@@ -2341,15 +2341,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let _ = ty.print(ty::print::PrintCx::new(self.infcx.tcx, printer));\n+        let _ = ty.print(printer);\n         s\n     }\n \n     /// Returns the name of the provided `Ty` (that must be a reference)'s region with a\n     /// synthesized lifetime name where required.\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(&mut s, Namespace::TypeNS);\n+        let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n         let region = match ty.sty {\n             ty::TyKind::Ref(region, _, _) => {\n@@ -2366,7 +2366,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n         };\n \n-        let _ = region.print(ty::print::PrintCx::new(self.infcx.tcx, printer));\n+        let _ = region.print(printer);\n         s\n     }\n }"}, {"sha": "53087eb1b1abab3c2751388efc402af8af665330", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=52b4f2daa0e1a9c4aea4b729c0bcd46b5991f8a3", "patch": "@@ -4223,49 +4223,58 @@ pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n-where F: Fn(DefId) -> Def {\n-    use rustc::ty::print::{PrintCx, Printer};\n+pub fn get_path_for_type(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    def_id: DefId,\n+    def_ctor: impl Fn(DefId) -> Def,\n+) -> hir::Path {\n+    use rustc::ty::print::Printer;\n \n-    struct AbsolutePathPrinter;\n+    struct AbsolutePathPrinter<'a, 'tcx> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    }\n \n-    impl Printer for AbsolutePathPrinter {\n+    impl Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n         type Error = !;\n \n         type Path = Vec<String>;\n         type Region = ();\n         type Type = ();\n         type DynExistential = ();\n \n+        fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+            self.tcx\n+        }\n+\n         fn print_region(\n-            self: PrintCx<'_, '_, '_, Self>,\n+            self,\n             _region: ty::Region<'_>,\n         ) -> Result<Self::Region, Self::Error> {\n             Ok(())\n         }\n \n         fn print_type(\n-            self: PrintCx<'_, '_, 'tcx, Self>,\n+            self,\n             _ty: Ty<'tcx>,\n         ) -> Result<Self::Type, Self::Error> {\n             Ok(())\n         }\n \n-        fn print_dyn_existential<'tcx>(\n-            self: PrintCx<'_, '_, 'tcx, Self>,\n+        fn print_dyn_existential(\n+            self,\n             _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n         ) -> Result<Self::DynExistential, Self::Error> {\n             Ok(())\n         }\n \n         fn path_crate(\n-            self: PrintCx<'_, '_, '_, Self>,\n+            self,\n             cnum: CrateNum,\n         ) -> Result<Self::Path, Self::Error> {\n             Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n         }\n         fn path_qualified(\n-            self: PrintCx<'_, '_, 'tcx, Self>,\n+            self,\n             self_ty: Ty<'tcx>,\n             trait_ref: Option<ty::TraitRef<'tcx>>,\n         ) -> Result<Self::Path, Self::Error> {\n@@ -4276,11 +4285,9 @@ where F: Fn(DefId) -> Def {\n             }])\n         }\n \n-        fn path_append_impl<'gcx, 'tcx>(\n-            self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-            print_prefix: impl FnOnce(\n-                PrintCx<'_, 'gcx, 'tcx, Self>,\n-            ) -> Result<Self::Path, Self::Error>,\n+        fn path_append_impl(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n             self_ty: Ty<'tcx>,\n             trait_ref: Option<ty::TraitRef<'tcx>>,\n         ) -> Result<Self::Path, Self::Error> {\n@@ -4296,29 +4303,25 @@ where F: Fn(DefId) -> Def {\n \n             Ok(path)\n         }\n-        fn path_append<'gcx, 'tcx>(\n-            self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-            print_prefix: impl FnOnce(\n-                PrintCx<'_, 'gcx, 'tcx, Self>,\n-            ) -> Result<Self::Path, Self::Error>,\n+        fn path_append(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n             text: &str,\n         ) -> Result<Self::Path, Self::Error> {\n             let mut path = print_prefix(self)?;\n             path.push(text.to_string());\n             Ok(path)\n         }\n-        fn path_generic_args<'gcx, 'tcx>(\n-            self: PrintCx<'_, 'gcx, 'tcx, Self>,\n-            print_prefix: impl FnOnce(\n-                PrintCx<'_, 'gcx, 'tcx, Self>,\n-            ) -> Result<Self::Path, Self::Error>,\n+        fn path_generic_args(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n             _args: &[Kind<'tcx>],\n         ) -> Result<Self::Path, Self::Error> {\n             print_prefix(self)\n         }\n     }\n \n-    let names = PrintCx::new(tcx, AbsolutePathPrinter)\n+    let names = AbsolutePathPrinter { tcx: tcx.global_tcx() }\n         .print_def_path(def_id, None)\n         .unwrap();\n "}]}