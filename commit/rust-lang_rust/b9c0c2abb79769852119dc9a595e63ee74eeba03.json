{"sha": "b9c0c2abb79769852119dc9a595e63ee74eeba03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YzBjMmFiYjc5NzY5ODUyMTE5ZGM5YTU5NWU2M2VlNzRlZWJhMDM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-20T10:34:36Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-04T16:18:30Z"}, "message": "Chalk integration\n\n - add proper canonicalization logic\n - add conversions from/to Chalk IR", "tree": {"sha": "39bf8f14438771f20337eaf57c421aebe3e7dfdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39bf8f14438771f20337eaf57c421aebe3e7dfdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9c0c2abb79769852119dc9a595e63ee74eeba03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c0c2abb79769852119dc9a595e63ee74eeba03", "html_url": "https://github.com/rust-lang/rust/commit/b9c0c2abb79769852119dc9a595e63ee74eeba03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9c0c2abb79769852119dc9a595e63ee74eeba03/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6269791d3626b9a9e5ea6a11c15e14470c0809a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6269791d3626b9a9e5ea6a11c15e14470c0809a0", "html_url": "https://github.com/rust-lang/rust/commit/6269791d3626b9a9e5ea6a11c15e14470c0809a0"}], "stats": {"total": 945, "additions": 798, "deletions": 147}, "files": [{"sha": "0bb62cb88da12f915d6a08f1bce6e4151edce8c3", "filename": "Cargo.lock", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -143,6 +143,61 @@ name = \"cfg-if\"\n version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"chalk-engine\"\n+version = \"0.9.0\"\n+source = \"git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match#b508031b92c754a677d46236aae1dcd2fa2fd68a\"\n+dependencies = [\n+ \"chalk-macros 0.1.1 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"stacker 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-ir\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match#b508031b92c754a677d46236aae1dcd2fa2fd68a\"\n+dependencies = [\n+ \"chalk-engine 0.9.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-macros\"\n+version = \"0.1.1\"\n+source = \"git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match#b508031b92c754a677d46236aae1dcd2fa2fd68a\"\n+dependencies = [\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-rust-ir\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match#b508031b92c754a677d46236aae1dcd2fa2fd68a\"\n+dependencies = [\n+ \"chalk-engine 0.9.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+]\n+\n+[[package]]\n+name = \"chalk-solve\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match#b508031b92c754a677d46236aae1dcd2fa2fd68a\"\n+dependencies = [\n+ \"chalk-engine 0.9.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"chrono\"\n version = \"0.4.6\"\n@@ -306,6 +361,14 @@ name = \"either\"\n version = \"1.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ena\"\n version = \"0.11.0\"\n@@ -362,6 +425,11 @@ dependencies = [\n  \"redox_syscall 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"flexi_logger\"\n version = \"0.11.4\"\n@@ -540,6 +608,14 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"itertools\"\n+version = \"0.7.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.8.0\"\n@@ -595,6 +671,11 @@ dependencies = [\n  \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"lalrpop-intern\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.3.0\"\n@@ -789,6 +870,11 @@ name = \"opaque-debug\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ordermap\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"owning_ref\"\n version = \"0.4.0\"\n@@ -862,6 +948,15 @@ dependencies = [\n  \"sha-1 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"petgraph\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"0.4.28\"\n@@ -979,6 +1074,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.11.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1498,6 +1596,17 @@ name = \"stable_deref_trait\"\n version = \"1.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"stacker\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"strsim\"\n version = \"0.8.0\"\n@@ -1888,6 +1997,11 @@ dependencies = [\n \"checksum cargo_metadata 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"178d62b240c34223f265a4c1e275e37d62da163d421fc8d7f7e3ee340f803c57\"\n \"checksum cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e5f3fee5eeb60324c2781f1e41286bdee933850fff9b3c672587fed5ec58c83\"\n \"checksum cfg-if 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d43355396e872eefb45ce6342e4374ed7bc2b3a502d1b28e36d6e23c05d1f4\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/detrumi/chalk.git?branch=program_clauses_that_could_match)\" = \"<none>\"\n \"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878\"\n \"checksum ci_info 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e5e881307a989a3a5e20d52a32cc05950e3c2178cccfcc9428271a6cde09f902\"\n \"checksum clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n@@ -1907,13 +2021,15 @@ dependencies = [\n \"checksum drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69b26e475fd29098530e709294e94e661974c851aed42512793f120fed4e199f\"\n \"checksum dtoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d301140eb411af13d3115f9a562c85cc6b541ade9dfa314132244aaee7489dd\"\n \"checksum either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5527cfe0d098f36e3f8839852688e63c8fff1c90b2b405aef730615f9a7bcf7b\"\n+\"checksum ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25b4e5febb25f08c49f1b07dc33a182729a6b21edfb562b5aef95f78e0dbe5bb\"\n \"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n \"checksum encode_unicode 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90b2c9496c001e8cb61827acdefad780795c42264c137744cae6f7d9e3450abd\"\n \"checksum error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e791d3be96241c77c43846b665ef1384606da2cd2a48730abe606a12906e02\"\n \"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \"checksum filetime 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f8c63033fcba1f51ef744505b3cad42510432b904c062afa67ad7ece008429d\"\n+\"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \"checksum flexi_logger 0.11.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73de04baa435682b03677bb28f7b3e9d72b0489a551da5ba413c9b29f7979a19\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \"checksum fsevent 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4bbbf71584aeed076100b5665ac14e3d85eeb31fdbb45fbd41ef9a682b5ec05\"\n@@ -1934,13 +2050,15 @@ dependencies = [\n \"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n \"checksum insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"03e7d88a87d342ce8bd698516151be43e6eb2e84b683db528696cb4a382f734a\"\n \"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n+\"checksum itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d47946d458e94a1b7bcabbf6521ea7c037062c81f534615abcad76e84d4970d\"\n \"checksum itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n \"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b\"\n \"checksum jemalloc-ctl 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e93b0f37e7d735c6b610176d5b1bde8e1621ff3f6f7ac23cdfa4e7f7d0111b5\"\n \"checksum jemalloc-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bfc62c8e50e381768ce8ee0428ee53741929f7ebd73e4d83f669bcf7693e00ae\"\n \"checksum jemallocator 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9f0cd42ac65f758063fea55126b0148b1ce0a6354ff78e07a4d6806bc65c4ab3\"\n \"checksum join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dc7a5290e8c2606ce2be49f456d50f69173cb96d1541e4f66e34ac8b331a98f\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+\"checksum lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cc4fd87be4a815fd373e02773983940f0d75fb26fde8c098e9e45f7af03154c0\"\n \"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \"checksum libc 0.2.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bedcc7a809076656486ffe045abeeac163da1b558e963a31e29fbfbeba916917\"\n@@ -1965,6 +2083,7 @@ dependencies = [\n \"checksum number_prefix 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbf9993e59c894e3c08aa1c2712914e9e6bf1fcbfc6bef283e2183df345a4fee\"\n \"checksum numtoa 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8f8bdf33df195859076e54ab11ee78a1b208382d3a26ec40d142ffc1ecc49ef\"\n \"checksum opaque-debug 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"93f5bb2e8e8dec81642920ccff6b61f1eb94fa3020c5a325c9851ff604152409\"\n+\"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13\"\n \"checksum parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n \"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9\"\n@@ -1973,6 +2092,7 @@ dependencies = [\n \"checksum pest_derive 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"833d1ae558dc601e9a60366421196a8d94bc0ac980476d0b67e1d0988d72b2d0\"\n \"checksum pest_generator 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n \"checksum pest_meta 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f249ea6de7c7b7aba92b4ff4376a994c6dbd98fd2166c89d5c4947397ecb574d\"\n+\"checksum petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9c3659d1ee90221741f65dd128d9998311b0e40c5d3c23a62445938214abce4f\"\n \"checksum proc-macro2 0.4.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba92c84f814b3f9a44c5cfca7d2ad77fa10710867d2bbb1b3d175ab5f47daa12\"\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n@@ -2019,6 +2139,7 @@ dependencies = [\n \"checksum smallvec 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4488ae950c49d403731982257768f48fada354a5203fe81f9bb6f43ca9002be\"\n \"checksum smol_str 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d077b3367211e9c6e2e012fb804c444e0d80ab5a51ae4137739b58e6446dcaef\"\n \"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n+\"checksum stacker 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fb79482f57cf598af52094ec4cc3b3c42499d3ce5bd426f2ac41515b7e57404b\"\n \"checksum strsim 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \"checksum superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \"checksum syn 0.15.32 (registry+https://github.com/rust-lang/crates.io-index)\" = \"846620ec526c1599c070eff393bfeeeb88a93afa2513fc3b49f1fea84cf7b0ed\""}, {"sha": "ae7e7df6237337724600e7ca4647ee9d237a6e7e", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -19,7 +19,14 @@ ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n test_utils = { path = \"../test_utils\" }\n-ra_prof = {path = \"../ra_prof\" }\n+ra_prof = { path = \"../ra_prof\" }\n+\n+# chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\" }\n+# chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\" }\n+# chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\" }\n+chalk-solve = { git = \"https://github.com/detrumi/chalk.git\", branch = \"program_clauses_that_could_match\" }\n+chalk-rust-ir = { git = \"https://github.com/detrumi/chalk.git\", branch = \"program_clauses_that_could_match\" }\n+chalk-ir = { git = \"https://github.com/detrumi/chalk.git\", branch = \"program_clauses_that_could_match\" }\n \n [dev-dependencies]\n flexi_logger = \"0.11.0\""}, {"sha": "9dcae50a5507391ef34f3299694011f16a393414", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n     expr::{Body, BodySourceMap},\n-    ty::InferenceResult,\n+    ty::{ TraitRef, InferenceResult},\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n@@ -696,6 +696,10 @@ impl Trait {\n         db.trait_data(self)\n     }\n \n+    pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n+        TraitRef::for_trait(db, self)\n+    }\n+\n     pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module(db).resolver(db);\n         // add generic params, if present"}, {"sha": "b2c4fccf28f7e6ad8116dd0e9895a534f0c0a521", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -1,4 +1,4 @@\n-use std::sync::Arc;\n+use std::sync::{Arc, Mutex};\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile, SmolStr, ast};\n use ra_db::{SourceDatabase, salsa};\n@@ -8,16 +8,16 @@ use crate::{\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n-    DefWithBody,\n+    DefWithBody, Trait,\n+    ids,\n     nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig, TypeCtor},\n     adt::{StructData, EnumData},\n-    impl_block::{ModuleImplBlocks, ImplSourceMap},\n+    impl_block::{ModuleImplBlocks, ImplSourceMap, ImplBlock},\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n-    traits::TraitData, Trait, ty::TraitRef,\n+    traits::TraitData,\n     lang_item::{LangItems, LangItemTarget},\n-    ids\n };\n \n #[salsa::query_group(DefDatabaseStorage)]\n@@ -39,6 +39,12 @@ pub trait DefDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_type_alias(&self, loc: ids::ItemLoc<ast::TypeAliasDef>) -> ids::TypeAliasId;\n \n+    // Interned IDs for Chalk integration\n+    #[salsa::interned]\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n+    #[salsa::interned]\n+    fn intern_impl_block(&self, impl_block: ImplBlock) -> ids::GlobalImplId;\n+\n     #[salsa::invoke(crate::ids::macro_def_query)]\n     fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n \n@@ -144,8 +150,12 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n \n-    #[salsa::invoke(crate::ty::traits::implements)]\n-    fn implements(&self, trait_ref: TraitRef) -> Option<crate::ty::traits::Solution>;\n+    #[salsa::invoke(crate::ty::traits::impls_for_trait)]\n+    fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;\n+\n+    #[salsa::invoke(crate::ty::traits::solver)]\n+    #[salsa::volatile]\n+    fn chalk_solver(&self, krate: Crate) -> Arc<Mutex<chalk_solve::Solver>>;\n }\n \n #[test]"}, {"sha": "2e52c587111110690930ba0189af93b96954bfea", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::ast::{self, NameOwner, TypeParamsOwner, TypeBoundsOwner};\n \n use crate::{\n     db::DefDatabase,\n-    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef\n+    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef, AdtDef\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -157,6 +157,15 @@ impl From<Container> for GenericDef {\n     }\n }\n \n+impl From<crate::adt::AdtDef> for GenericDef {\n+    fn from(adt: crate::adt::AdtDef) -> Self {\n+        match adt {\n+            AdtDef::Struct(s) => s.into(),\n+            AdtDef::Enum(e) => e.into(),\n+        }\n+    }\n+}\n+\n pub trait HasGenericParams {\n     fn generic_params(self, db: &impl DefDatabase) -> Arc<GenericParams>;\n }"}, {"sha": "6875b006d6c8d8fb3ce28e55c82697e46be48821", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -323,6 +323,25 @@ impl AstItemDef<ast::TraitDef> for TraitId {\n     }\n }\n \n+fn from_chalk<T: salsa::InternKey>(chalk_id: chalk_ir::RawId) -> T {\n+    T::from_intern_id(salsa::InternId::from(chalk_id.index))\n+}\n+fn to_chalk<T: salsa::InternKey>(salsa_id: T) -> chalk_ir::RawId {\n+    chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n+}\n+\n+impl From<chalk_ir::TraitId> for TraitId {\n+    fn from(trait_id: chalk_ir::TraitId) -> Self {\n+        from_chalk(trait_id.0)\n+    }\n+}\n+\n+impl From<TraitId> for chalk_ir::TraitId {\n+    fn from(trait_id: TraitId) -> Self {\n+        chalk_ir::TraitId(to_chalk(trait_id))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n impl_intern_key!(TypeAliasId);\n@@ -354,3 +373,38 @@ impl MacroCallId {\n         )\n     }\n }\n+\n+/// This exists just for chalk, because chalk doesn't differentiate between\n+/// enums and structs.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeCtorId(salsa::InternId);\n+impl_intern_key!(TypeCtorId);\n+\n+impl From<chalk_ir::StructId> for TypeCtorId {\n+    fn from(struct_id: chalk_ir::StructId) -> Self {\n+        from_chalk(struct_id.0)\n+    }\n+}\n+\n+impl From<TypeCtorId> for chalk_ir::StructId {\n+    fn from(adt_id: TypeCtorId) -> Self {\n+        chalk_ir::StructId(to_chalk(adt_id))\n+    }\n+}\n+\n+/// This exists just for chalk, because our ImplIds are only unique per module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GlobalImplId(salsa::InternId);\n+impl_intern_key!(GlobalImplId);\n+\n+impl From<chalk_ir::ImplId> for GlobalImplId {\n+    fn from(impl_id: chalk_ir::ImplId) -> Self {\n+        from_chalk(impl_id.0)\n+    }\n+}\n+\n+impl From<GlobalImplId> for chalk_ir::ImplId {\n+    fn from(impl_id: GlobalImplId) -> Self {\n+        chalk_ir::ImplId(to_chalk(impl_id))\n+    }\n+}"}, {"sha": "707556ef8428981c58f0df2a3d1de0ffaea8b2d4", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    ModuleDef,\n+    ModuleDef, Trait,\n     code_model_api::Crate,\n     MacroCallId,\n     MacroCallLoc,\n@@ -18,7 +18,6 @@ use crate::{\n     expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n     path::Path,\n-    Trait,\n };\n \n #[derive(Debug, Clone, Default)]"}, {"sha": "538148956a81b9f2744dd8ca94aaa2ff4fe3ed77", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -15,7 +15,7 @@ pub(crate) mod display;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait, GenericParams};\n use display::{HirDisplay, HirFormatter};\n \n pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig};\n@@ -118,6 +118,7 @@ pub enum Ty {\n         /// surrounding impl, then the current function).\n         idx: u32,\n         /// The name of the parameter, for displaying.\n+        // FIXME get rid of this\n         name: Name,\n     },\n \n@@ -177,6 +178,30 @@ impl Substs {\n         }\n         &self.0[0]\n     }\n+\n+    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n+    pub fn identity(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n+                .collect::<Vec<_>>()\n+                .into(),\n+        )\n+    }\n+\n+    /// Return Substs that replace each parameter by a bound variable.\n+    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Bound(p.idx))\n+                .collect::<Vec<_>>()\n+                .into(),\n+        )\n+    }\n }\n \n impl From<Vec<Ty>> for Substs {\n@@ -198,6 +223,14 @@ impl TraitRef {\n     pub fn self_ty(&self) -> &Ty {\n         &self.substs.0[0]\n     }\n+\n+    pub fn subst(mut self, substs: &Substs) -> TraitRef {\n+        self.substs.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = ty.subst(substs);\n+        });\n+        self\n+    }\n }\n \n /// A function signature as seen by type inference: Several parameter types and\n@@ -376,6 +409,20 @@ impl Ty {\n         })\n     }\n \n+    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n+    pub fn subst_bound_vars(self, substs: &Substs) -> Ty {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => {\n+                if (idx as usize) < substs.0.len() {\n+                    substs.0[idx as usize].clone()\n+                } else {\n+                    Ty::Bound(idx)\n+                }\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     fn substs(&self) -> Option<Substs> {"}, {"sha": "a6d08dbcbf6c6355f01abb222a3a14a554a2da4f", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -44,9 +44,13 @@ use crate::{\n };\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n-    traits::{ Solution, Obligation, Guidance},\n+    traits::{Solution, Obligation, Guidance},\n };\n \n+mod unify;\n+\n+pub(super) use unify::Canonical;\n+\n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n     db.check_canceled();\n@@ -321,30 +325,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_obligations_as_possible(&mut self) {\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n-            // FIXME resolve types in the obligation first\n-            let (solution, var_mapping) = match &obligation {\n+            let mut canonicalizer = self.canonicalizer();\n+            let solution = match &obligation {\n                 Obligation::Trait(tr) => {\n-                    let (tr, var_mapping) = super::traits::canonicalize(tr.clone());\n-                    (self.db.implements(tr), var_mapping)\n+                    let canonical = canonicalizer.canonicalize_trait_ref(tr.clone());\n+                    super::traits::implements(\n+                        canonicalizer.ctx.db,\n+                        canonicalizer.ctx.resolver.krate().unwrap(),\n+                        canonical,\n+                    )\n                 }\n             };\n             match solution {\n                 Some(Solution::Unique(substs)) => {\n-                    for (i, subst) in substs.0.iter().enumerate() {\n-                        let uncanonical = var_mapping[i];\n-                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n-                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n-                    }\n+                    canonicalizer.apply_solution(substs.0);\n                 }\n                 Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                    for (i, subst) in substs.0.iter().enumerate() {\n-                        let uncanonical = var_mapping[i];\n-                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n-                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n-                    }\n+                    canonicalizer.apply_solution(substs.0);\n                     self.obligations.push(obligation);\n                 }\n                 Some(_) => {\n+                    // FIXME use this when trying to resolve everything at the end\n                     self.obligations.push(obligation);\n                 }\n                 None => {"}, {"sha": "7918b007b6d0b16fef9622876fa021303cfa54fc", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -0,0 +1,81 @@\n+//! Unification and canonicalization logic.\n+\n+use super::{InferenceContext, Ty, TraitRef, InferTy, HirDatabase};\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n+    where\n+        'a: 'b,\n+    {\n+        Canonicalizer { ctx: self, free_vars: Vec::new() }\n+    }\n+}\n+\n+// TODO improve the interface of this\n+\n+// TODO move further up?\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct Canonical<T> {\n+    pub value: T,\n+    pub num_vars: usize,\n+}\n+\n+pub(super) struct Canonicalizer<'a, 'b, D: HirDatabase>\n+where\n+    'a: 'b,\n+{\n+    pub ctx: &'b mut InferenceContext<'a, D>,\n+    pub free_vars: Vec<InferTy>,\n+}\n+\n+impl<'a, 'b, D: HirDatabase> Canonicalizer<'a, 'b, D>\n+where\n+    'a: 'b,\n+{\n+    fn add(&mut self, free_var: InferTy) -> usize {\n+        self.free_vars.iter().position(|&v| v == free_var).unwrap_or_else(|| {\n+            let next_index = self.free_vars.len();\n+            self.free_vars.push(free_var);\n+            next_index\n+        })\n+    }\n+\n+    pub fn canonicalize_ty(&mut self, ty: Ty) -> Canonical<Ty> {\n+        let value = ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                // TODO prevent infinite loops? => keep var stack\n+                if let Some(known_ty) = self.ctx.var_unification_table.probe_value(inner).known() {\n+                    self.canonicalize_ty(known_ty.clone()).value\n+                } else {\n+                    let free_var = InferTy::TypeVar(self.ctx.var_unification_table.find(inner));\n+                    let position = self.add(free_var);\n+                    Ty::Bound(position as u32)\n+                }\n+            }\n+            _ => ty,\n+        });\n+        Canonical { value, num_vars: self.free_vars.len() }\n+    }\n+\n+    pub fn canonicalize_trait_ref(&mut self, trait_ref: TraitRef) -> Canonical<TraitRef> {\n+        let substs = trait_ref\n+            .substs\n+            .0\n+            .iter()\n+            .map(|ty| self.canonicalize_ty(ty.clone()).value)\n+            .collect::<Vec<_>>();\n+        let value = TraitRef { trait_: trait_ref.trait_, substs: substs.into() };\n+        Canonical { value, num_vars: self.free_vars.len() }\n+    }\n+\n+    pub fn apply_solution(&mut self, solution: Canonical<Vec<Ty>>) {\n+        // the solution may contain new variables, which we need to convert to new inference vars\n+        let new_vars =\n+            (0..solution.num_vars).map(|_| self.ctx.new_type_var()).collect::<Vec<_>>().into();\n+        for (i, ty) in solution.value.into_iter().enumerate() {\n+            let var = self.free_vars[i].clone();\n+            self.ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+        }\n+    }\n+}"}, {"sha": "2bbd17068780ae5dca43fbf6074b416a6892b734", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -238,6 +238,11 @@ impl TraitRef {\n         let segment = path.segments.last().expect(\"path should have at least one segment\");\n         substs_from_path_segment(db, resolver, segment, &resolved.generic_params(db), true)\n     }\n+\n+    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {\n+        let substs = Substs::identity(&trait_.generic_params(db));\n+        TraitRef { trait_, substs }\n+    }\n }\n \n /// Build the declared type of an item. This depends on the namespace; e.g. for\n@@ -299,7 +304,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let generics = def.generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n@@ -341,7 +346,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n         return type_for_struct(db, def); // Unit struct\n     }\n     let generics = def.generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n@@ -357,7 +362,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant)\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n     let generics = def.parent_enum(db).generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     let ret = type_for_enum(db, def.parent_enum(db)).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n }\n@@ -369,36 +374,25 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) ->\n         return type_for_enum(db, def.parent_enum(db)); // Unit variant\n     }\n     let generics = def.parent_enum(db).generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n-fn make_substs(generics: &GenericParams) -> Substs {\n-    Substs(\n-        generics\n-            .params_including_parent()\n-            .into_iter()\n-            .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-            .collect::<Vec<_>>()\n-            .into(),\n-    )\n-}\n-\n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n+    Ty::apply(TypeCtor::Adt(s.into()), Substs::identity(&generics))\n }\n \n fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n+    Ty::apply(TypeCtor::Adt(s.into()), Substs::identity(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n     let generics = t.generic_params(db);\n     let resolver = t.resolver(db);\n     let type_ref = t.type_ref(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     let inner = Ty::from_hir(db, &resolver, &type_ref);\n     inner.subst(&substs)\n }"}, {"sha": "ea7da0b629374321db47661ce2f8a8c0b86766f0", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     generics::HasGenericParams,\n     ty::primitive::{UncertainIntTy, UncertainFloatTy}\n };\n-use super::{TraitRef, Substs};\n+use super::{TraitRef, infer::Canonical, Substs};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -183,6 +183,7 @@ impl Ty {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n+        let krate = resolver.krate()?;\n         'traits: for t in resolver.traits_in_scope() {\n             let data = t.trait_data(db);\n             // we'll be lazy about checking whether the type implements the\n@@ -195,12 +196,19 @@ impl Ty {\n                         let sig = m.signature(db);\n                         if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n                             if !known_implemented {\n+                                // TODO the self type may contain type\n+                                // variables, so we need to do proper\n+                                // canonicalization here\n                                 let trait_ref = TraitRef {\n                                     trait_: t,\n                                     substs: fresh_substs_for_trait(db, t, self.clone()),\n                                 };\n-                                let (trait_ref, _) = super::traits::canonicalize(trait_ref);\n-                                if db.implements(trait_ref).is_none() {\n+                                let canonical = Canonical {\n+                                    num_vars: trait_ref.substs.len(),\n+                                    value: trait_ref,\n+                                };\n+                                // FIXME cache this implements check (without solution) in a query?\n+                                if super::traits::implements(db, krate, canonical).is_none() {\n                                     continue 'traits;\n                                 }\n                             }\n@@ -271,15 +279,18 @@ impl Ty {\n }\n \n /// This creates Substs for a trait with the given Self type and type variables\n-/// for all other parameters. This is kind of a hack since these aren't 'real'\n-/// type variables; the resulting trait reference is just used for the\n-/// preliminary method candidate check.\n+/// for all other parameters, to query Chalk with it.\n fn fresh_substs_for_trait(db: &impl HirDatabase, tr: Trait, self_ty: Ty) -> Substs {\n     let mut substs = Vec::new();\n     let generics = tr.generic_params(db);\n     substs.push(self_ty);\n-    substs.extend(generics.params_including_parent().into_iter().skip(1).enumerate().map(\n-        |(i, _p)| Ty::Infer(super::infer::InferTy::TypeVar(super::infer::TypeVarId(i as u32))),\n-    ));\n+    substs.extend(\n+        generics\n+            .params_including_parent()\n+            .into_iter()\n+            .skip(1)\n+            .enumerate()\n+            .map(|(i, _p)| Ty::Bound(i as u32)),\n+    );\n     substs.into()\n }"}, {"sha": "0aecde37c4de48c4b9911db70c7f398768087e92", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -2140,7 +2140,7 @@ fn test() {\n [102; 127) '{     ...d(); }': ()\n [108; 109) 'S': S<u32>(T) -> S<T>\n [108; 115) 'S(1u32)': S<u32>\n-[108; 124) 'S(1u32...thod()': {unknown}\n+[108; 124) 'S(1u32...thod()': u32\n [110; 114) '1u32': u32\"###\n     );\n }"}, {"sha": "367322ed2933cf85544f3d79b17bd3a0e0863c07", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 403, "deletions": 90, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c0c2abb79769852119dc9a595e63ee74eeba03/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=b9c0c2abb79769852119dc9a595e63ee74eeba03", "patch": "@@ -1,115 +1,428 @@\n-//! Stuff that will probably mostly replaced by Chalk.\n-use std::collections::HashMap;\n+//! Chalk integration.\n+use std::sync::{Arc, Mutex};\n \n-use crate::{db::HirDatabase, generics::HasGenericParams};\n-use super::{TraitRef, Substs, infer::{TypeVarId, InferTy}, Ty};\n+use chalk_ir::{TypeId, TraitId, StructId, ImplId, TypeKindId, ProjectionTy, Parameter, Identifier, cast::Cast};\n+use chalk_rust_ir::{AssociatedTyDatum, TraitDatum, StructDatum, ImplDatum};\n \n-// Copied (and simplified) from Chalk\n+use crate::{Crate, Trait, db::HirDatabase, HasGenericParams, ImplBlock};\n+use super::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, infer::Canonical};\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// A (possible) solution for a proposed goal. Usually packaged in a `Result`,\n-/// where `Err` represents definite *failure* to prove a goal.\n-pub enum Solution {\n-    /// The goal indeed holds, and there is a unique value for all existential\n-    /// variables.\n-    Unique(Substs),\n+#[derive(Debug, Copy, Clone)]\n+struct ChalkContext<'a, DB> {\n+    db: &'a DB,\n+    krate: Crate,\n+}\n \n-    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n-    /// for type inference.\n-    Ambig(Guidance),\n+pub(crate) trait ToChalk {\n+    type Chalk;\n+    fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n+    fn from_chalk(db: &impl HirDatabase, chalk: Self::Chalk) -> Self;\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// When a goal holds ambiguously (e.g., because there are multiple possible\n-/// solutions), we issue a set of *guidance* back to type inference.\n-pub enum Guidance {\n-    /// The existential variables *must* have the given values if the goal is\n-    /// ever to hold, but that alone isn't enough to guarantee the goal will\n-    /// actually hold.\n-    Definite(Substs),\n+pub(crate) fn from_chalk<T, ChalkT>(db: &impl HirDatabase, chalk: ChalkT) -> T\n+where\n+    T: ToChalk<Chalk = ChalkT>,\n+{\n+    T::from_chalk(db, chalk)\n+}\n \n-    /// There are multiple plausible values for the existentials, but the ones\n-    /// here are suggested as the preferred choice heuristically. These should\n-    /// be used for inference fallback only.\n-    Suggested(Substs),\n+impl ToChalk for Ty {\n+    type Chalk = chalk_ir::Ty;\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty {\n+        match self {\n+            Ty::Apply(apply_ty) => chalk_ir::Ty::Apply(apply_ty.to_chalk(db)),\n+            Ty::Param { idx, .. } => {\n+                chalk_ir::PlaceholderIndex { ui: chalk_ir::UniverseIndex::ROOT, idx: idx as usize }\n+                    .to_ty()\n+            }\n+            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n+            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n+            Ty::Unknown => unimplemented!(), // TODO turn into placeholder?\n+        }\n+    }\n+    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n+        match chalk {\n+            chalk_ir::Ty::Apply(apply_ty) => {\n+                match apply_ty.name {\n+                    // FIXME handle TypeKindId::Trait/Type here\n+                    chalk_ir::TypeName::TypeKindId(_) => Ty::Apply(from_chalk(db, apply_ty)),\n+                    chalk_ir::TypeName::AssociatedType(_) => unimplemented!(),\n+                    chalk_ir::TypeName::Placeholder(idx) => {\n+                        assert_eq!(idx.ui, chalk_ir::UniverseIndex::ROOT);\n+                        Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n+                    }\n+                }\n+            }\n+            chalk_ir::Ty::Projection(_) => unimplemented!(),\n+            chalk_ir::Ty::UnselectedProjection(_) => unimplemented!(),\n+            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n+            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n+            chalk_ir::Ty::InferenceVar(_iv) => panic!(\"unexpected chalk infer ty\"),\n+        }\n+    }\n+}\n \n-    /// There's no useful information to feed back to type inference\n-    Unknown,\n+impl ToChalk for ApplicationTy {\n+    type Chalk = chalk_ir::ApplicationTy;\n+\n+    fn to_chalk(self: ApplicationTy, db: &impl HirDatabase) -> chalk_ir::ApplicationTy {\n+        let struct_id = self.ctor.to_chalk(db);\n+        let name = chalk_ir::TypeName::TypeKindId(struct_id.into());\n+        let parameters = self.parameters.to_chalk(db);\n+        chalk_ir::ApplicationTy { name, parameters }\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, apply_ty: chalk_ir::ApplicationTy) -> ApplicationTy {\n+        let ctor = match apply_ty.name {\n+            chalk_ir::TypeName::TypeKindId(chalk_ir::TypeKindId::StructId(struct_id)) => {\n+                from_chalk(db, struct_id)\n+            }\n+            chalk_ir::TypeName::TypeKindId(_) => unimplemented!(),\n+            chalk_ir::TypeName::Placeholder(_) => unimplemented!(),\n+            chalk_ir::TypeName::AssociatedType(_) => unimplemented!(),\n+        };\n+        let parameters = from_chalk(db, apply_ty.parameters);\n+        ApplicationTy { ctor, parameters }\n+    }\n+}\n+\n+impl ToChalk for Substs {\n+    type Chalk = Vec<chalk_ir::Parameter>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> Vec<chalk_ir::Parameter> {\n+        self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter>) -> Substs {\n+        parameters\n+            .into_iter()\n+            .map(|p| match p {\n+                chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n+                chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+            })\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+}\n+\n+impl ToChalk for TraitRef {\n+    type Chalk = chalk_ir::TraitRef;\n+\n+    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef {\n+        let trait_id = self.trait_.to_chalk(db);\n+        let parameters = self.substs.to_chalk(db);\n+        chalk_ir::TraitRef { trait_id, parameters }\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef) -> Self {\n+        let trait_ = from_chalk(db, trait_ref.trait_id);\n+        let substs = from_chalk(db, trait_ref.parameters);\n+        TraitRef { trait_, substs }\n+    }\n+}\n+\n+impl ToChalk for Trait {\n+    type Chalk = TraitId;\n+\n+    fn to_chalk(self, _db: &impl HirDatabase) -> TraitId {\n+        self.id.into()\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: TraitId) -> Trait {\n+        Trait { id: trait_id.into() }\n+    }\n+}\n+\n+impl ToChalk for TypeCtor {\n+    type Chalk = chalk_ir::StructId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::StructId {\n+        db.intern_type_ctor(self).into()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, struct_id: chalk_ir::StructId) -> TypeCtor {\n+        db.lookup_intern_type_ctor(struct_id.into())\n+    }\n+}\n+\n+impl ToChalk for ImplBlock {\n+    type Chalk = chalk_ir::ImplId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n+        db.intern_impl_block(self).into()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> ImplBlock {\n+        db.lookup_intern_impl_block(impl_id.into())\n+    }\n+}\n+\n+fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n+    chalk_ir::Binders {\n+        value,\n+        binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n+    }\n+}\n+\n+impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n+where\n+    DB: HirDatabase,\n+{\n+    fn associated_ty_data(&self, _ty: TypeId) -> Arc<AssociatedTyDatum> {\n+        unimplemented!()\n+    }\n+    fn trait_datum(&self, trait_id: TraitId) -> Arc<TraitDatum> {\n+        eprintln!(\"trait_datum {:?}\", trait_id);\n+        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let generic_params = trait_.generic_params(self.db);\n+        let bound_vars = Substs::bound_vars(&generic_params);\n+        let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n+        let flags = chalk_rust_ir::TraitFlags {\n+            // FIXME set these flags correctly\n+            auto: false,\n+            marker: false,\n+            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n+            fundamental: false,\n+        };\n+        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags };\n+        let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n+        Arc::new(trait_datum)\n+    }\n+    fn struct_datum(&self, struct_id: StructId) -> Arc<StructDatum> {\n+        eprintln!(\"struct_datum {:?}\", struct_id);\n+        let type_ctor = from_chalk(self.db, struct_id);\n+        // TODO might be nicer if we can create a fake GenericParams for the TypeCtor\n+        let (num_params, upstream) = match type_ctor {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Never\n+            | TypeCtor::Str => (0, true),\n+            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => (1, true),\n+            TypeCtor::FnPtr | TypeCtor::Tuple => unimplemented!(), // FIXME tuples and FnPtr are currently variadic... we need to make the parameter number explicit\n+            TypeCtor::FnDef(_) => unimplemented!(),\n+            TypeCtor::Adt(adt) => {\n+                let generic_params = adt.generic_params(self.db);\n+                (\n+                    generic_params.count_params_including_parent(),\n+                    adt.krate(self.db) != Some(self.krate),\n+                )\n+            }\n+        };\n+        let flags = chalk_rust_ir::StructFlags {\n+            upstream,\n+            // FIXME set fundamental flag correctly\n+            fundamental: false,\n+        };\n+        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let ty = ApplicationTy {\n+            ctor: type_ctor,\n+            parameters: (0..num_params).map(|i| Ty::Bound(i as u32)).collect::<Vec<_>>().into(),\n+        };\n+        let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n+            self_ty: ty.to_chalk(self.db),\n+            fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n+            where_clauses,\n+            flags,\n+        };\n+        let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+        Arc::new(struct_datum)\n+    }\n+    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n+        eprintln!(\"impl_datum {:?}\", impl_id);\n+        let impl_block: ImplBlock = from_chalk(self.db, impl_id);\n+        let generic_params = impl_block.generic_params(self.db);\n+        let bound_vars = Substs::bound_vars(&generic_params);\n+        let trait_ref = impl_block\n+            .target_trait_ref(self.db)\n+            .expect(\"FIXME handle unresolved impl block trait ref\")\n+            .subst(&bound_vars);\n+        let impl_type = if impl_block.module().krate(self.db) == Some(self.krate) {\n+            chalk_rust_ir::ImplType::Local\n+        } else {\n+            chalk_rust_ir::ImplType::External\n+        };\n+        let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n+            // FIXME handle negative impls (impl !Sync for Foo)\n+            trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n+            where_clauses: Vec::new(),        // FIXME add where clauses\n+            associated_ty_values: Vec::new(), // FIXME add associated type values\n+            impl_type,\n+        };\n+        let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n+        Arc::new(impl_datum)\n+    }\n+    fn impls_for_trait(&self, trait_id: TraitId) -> Vec<ImplId> {\n+        eprintln!(\"impls_for_trait {:?}\", trait_id);\n+        let trait_ = from_chalk(self.db, trait_id);\n+        self.db\n+            .impls_for_trait(self.krate, trait_)\n+            .iter()\n+            // FIXME temporary hack -- as long as we're not lowering where clauses\n+            // correctly, ignore impls with them completely so as to not treat\n+            // impl<T> Trait for T where T: ... as a blanket impl on all types\n+            .filter(|impl_block| impl_block.generic_params(self.db).where_predicates.is_empty())\n+            .map(|impl_block| impl_block.to_chalk(self.db))\n+            .collect()\n+    }\n+    fn impl_provided_for(&self, auto_trait_id: TraitId, struct_id: StructId) -> bool {\n+        eprintln!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n+        false // FIXME\n+    }\n+    fn type_name(&self, _id: TypeKindId) -> Identifier {\n+        unimplemented!()\n+    }\n+    fn split_projection<'p>(\n+        &self,\n+        projection: &'p ProjectionTy,\n+    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n+        eprintln!(\"split_projection {:?}\", projection);\n+        unimplemented!()\n+    }\n+}\n+\n+pub(crate) fn solver(_db: &impl HirDatabase, _krate: Crate) -> Arc<Mutex<chalk_solve::Solver>> {\n+    // krate parameter is just so we cache a unique solver per crate\n+    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 10 };\n+    Arc::new(Mutex::new(solver_choice.into_solver()))\n+}\n+\n+/// Collects impls for the given trait in the whole dependency tree of `krate`.\n+pub(crate) fn impls_for_trait(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    trait_: Trait,\n+) -> Arc<[ImplBlock]> {\n+    let mut impls = Vec::new();\n+    // We call the query recursively here. On the one hand, this means we can\n+    // reuse results from queries for different crates; on the other hand, this\n+    // will only ever get called for a few crates near the root of the tree (the\n+    // ones the user is editing), so this may actually be a waste of memory. I'm\n+    // doing it like this mainly for simplicity for now.\n+    for dep in krate.dependencies(db) {\n+        impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n+    }\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_));\n+    impls.into()\n+}\n+\n+fn solve(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal>>,\n+) -> Option<chalk_solve::Solution> {\n+    let context = ChalkContext { db, krate };\n+    let solver = db.chalk_solver(krate);\n+    let solution = solver.lock().unwrap().solve(&context, goal);\n+    eprintln!(\"solve({:?}) => {:?}\", goal, solution);\n+    solution\n }\n \n /// Something that needs to be proven (by Chalk) during type checking, e.g. that\n /// a certain type implements a certain trait. Proving the Obligation might\n /// result in additional information about inference variables.\n-///\n-/// This might be handled by Chalk when we integrate it?\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum Obligation {\n     /// Prove that a certain type implements a trait (the type is the `Self` type\n     /// parameter to the `TraitRef`).\n     Trait(TraitRef),\n }\n \n-/// Rudimentary check whether an impl exists for a given type and trait; this\n-/// will actually be done by chalk.\n-pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> Option<Solution> {\n-    // FIXME use all trait impls in the whole crate graph\n-    let krate = trait_ref.trait_.module(db).krate(db);\n-    let krate = match krate {\n-        Some(krate) => krate,\n-        None => return None,\n-    };\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    let mut impl_blocks = crate_impl_blocks\n-        .lookup_impl_blocks_for_trait(&trait_ref.trait_)\n-        // we don't handle where clauses at all, waiting for Chalk for that\n-        .filter(|impl_block| impl_block.generic_params(db).where_predicates.is_empty());\n-    impl_blocks\n-        .find_map(|impl_block| unify_trait_refs(&trait_ref, &impl_block.target_trait_ref(db)?))\n-}\n-\n-pub(super) fn canonicalize(trait_ref: TraitRef) -> (TraitRef, Vec<TypeVarId>) {\n-    let mut canonical = HashMap::new(); // mapping uncanonical -> canonical\n-    let mut uncanonical = Vec::new(); // mapping canonical -> uncanonical (which is dense)\n-    let mut substs = trait_ref.substs.0.to_vec();\n-    for ty in &mut substs {\n-        ty.walk_mut(&mut |ty| match ty {\n-            Ty::Infer(InferTy::TypeVar(tv)) => {\n-                let tv: &mut TypeVarId = tv;\n-                *tv = *canonical.entry(*tv).or_insert_with(|| {\n-                    let i = uncanonical.len();\n-                    uncanonical.push(*tv);\n-                    TypeVarId(i as u32)\n-                });\n-            }\n-            _ => {}\n-        });\n-    }\n-    (TraitRef { substs: substs.into(), ..trait_ref }, uncanonical)\n+/// Check using Chalk whether trait is implemented for given parameters including `Self` type.\n+pub(crate) fn implements(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    trait_ref: Canonical<TraitRef>,\n+) -> Option<Solution> {\n+    let goal: chalk_ir::Goal = trait_ref.value.to_chalk(db).cast();\n+    eprintln!(\"goal: {:?}\", goal);\n+    let env = chalk_ir::Environment::new();\n+    let in_env = chalk_ir::InEnvironment::new(&env, goal);\n+    let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n+    let canonical =\n+        chalk_ir::Canonical { value: in_env, binders: vec![parameter; trait_ref.num_vars] };\n+    // We currently don't deal with universes (I think / hope they're not yet\n+    // relevant for our use cases?)\n+    let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n+    let solution = solve(db, krate, &u_canonical);\n+    solution_from_chalk(db, solution)\n }\n \n-fn unify_trait_refs(tr1: &TraitRef, tr2: &TraitRef) -> Option<Solution> {\n-    if tr1.trait_ != tr2.trait_ {\n-        return None;\n-    }\n-    let mut solution_substs = Vec::new();\n-    for (t1, t2) in tr1.substs.0.iter().zip(tr2.substs.0.iter()) {\n-        // this is very bad / hacky 'unification' logic, just enough to make the simple tests pass\n-        match (t1, t2) {\n-            (_, Ty::Infer(InferTy::TypeVar(_))) | (_, Ty::Unknown) | (_, Ty::Param { .. }) => {\n-                // type variable (or similar) in the impl, we just assume it works\n-            }\n-            (Ty::Infer(InferTy::TypeVar(v1)), _) => {\n-                // type variable in the query and fixed type in the impl, record its value\n-                solution_substs.resize_with(v1.0 as usize + 1, || Ty::Unknown);\n-                solution_substs[v1.0 as usize] = t2.clone();\n-            }\n-            _ => {\n-                // check that they're equal (actually we'd have to recurse etc.)\n-                if t1 != t2 {\n-                    return None;\n-                }\n-            }\n+fn solution_from_chalk(\n+    db: &impl HirDatabase,\n+    solution: Option<chalk_solve::Solution>,\n+) -> Option<Solution> {\n+    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution>| {\n+        let value = subst\n+            .value\n+            .parameters\n+            .into_iter()\n+            .map(|p| {\n+                let ty = match p {\n+                    chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n+                    chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+                };\n+                ty\n+            })\n+            .collect();\n+        let result = Canonical { value, num_vars: subst.binders.len() };\n+        SolutionVariables(result)\n+    };\n+    match solution {\n+        Some(chalk_solve::Solution::Unique(constr_subst)) => {\n+            let subst = chalk_ir::Canonical {\n+                value: constr_subst.value.subst,\n+                binders: constr_subst.binders,\n+            };\n+            Some(Solution::Unique(convert_subst(subst)))\n+        }\n+        Some(chalk_solve::Solution::Ambig(chalk_solve::Guidance::Definite(subst))) => {\n+            Some(Solution::Ambig(Guidance::Definite(convert_subst(subst))))\n+        }\n+        Some(chalk_solve::Solution::Ambig(chalk_solve::Guidance::Suggested(subst))) => {\n+            Some(Solution::Ambig(Guidance::Suggested(convert_subst(subst))))\n         }\n+        Some(chalk_solve::Solution::Ambig(chalk_solve::Guidance::Unknown)) => {\n+            Some(Solution::Ambig(Guidance::Unknown))\n+        }\n+        None => None,\n     }\n-    Some(Solution::Unique(solution_substs.into()))\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) struct SolutionVariables(pub Canonical<Vec<Ty>>);\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// A (possible) solution for a proposed goal.\n+pub(crate) enum Solution {\n+    /// The goal indeed holds, and there is a unique value for all existential\n+    /// variables.\n+    Unique(SolutionVariables),\n+\n+    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n+    /// for type inference. In this case, we don't return any lifetime\n+    /// constraints, since we have not \"committed\" to any particular solution\n+    /// yet.\n+    Ambig(Guidance),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// When a goal holds ambiguously (e.g., because there are multiple possible\n+/// solutions), we issue a set of *guidance* back to type inference.\n+pub(crate) enum Guidance {\n+    /// The existential variables *must* have the given values if the goal is\n+    /// ever to hold, but that alone isn't enough to guarantee the goal will\n+    /// actually hold.\n+    Definite(SolutionVariables),\n+\n+    /// There are multiple plausible values for the existentials, but the ones\n+    /// here are suggested as the preferred choice heuristically. These should\n+    /// be used for inference fallback only.\n+    Suggested(SolutionVariables),\n+\n+    /// There's no useful information to feed back to type inference\n+    Unknown,\n }"}]}