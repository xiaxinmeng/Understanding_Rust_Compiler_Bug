{"sha": "f07011bad8a4ca3bd65ce1ed236f017f55108816", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNzAxMWJhZDhhNGNhM2JkNjVjZTFlZDIzNmYwMTdmNTUxMDg4MTY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-25T19:02:21Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-25T19:02:21Z"}, "message": "Always treat `dlsym` returning NULL as an error\n\nThis simplifies the code somewhat. Also updates comments to reflect\nnotes from reviw about thread-safety of `dlerror`.", "tree": {"sha": "4320f954d532974ace7fbc6df668bca1c1f1f18c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4320f954d532974ace7fbc6df668bca1c1f1f18c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f07011bad8a4ca3bd65ce1ed236f017f55108816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f07011bad8a4ca3bd65ce1ed236f017f55108816", "html_url": "https://github.com/rust-lang/rust/commit/f07011bad8a4ca3bd65ce1ed236f017f55108816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f07011bad8a4ca3bd65ce1ed236f017f55108816/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2326a1eecfe5562712649e8696c579bc919a9af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2326a1eecfe5562712649e8696c579bc919a9af", "html_url": "https://github.com/rust-lang/rust/commit/e2326a1eecfe5562712649e8696c579bc919a9af"}], "stats": {"total": 55, "additions": 24, "deletions": 31}, "files": [{"sha": "8c3c7b70f6c7c40622983947413fae1635dfd335", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f07011bad8a4ca3bd65ce1ed236f017f55108816/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07011bad8a4ca3bd65ce1ed236f017f55108816/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=f07011bad8a4ca3bd65ce1ed236f017f55108816", "patch": "@@ -54,8 +54,16 @@ mod dl {\n     use std::ffi::{CString, OsStr};\n     use std::os::unix::prelude::*;\n \n-    // `dlerror` is process global, so we can only allow a single thread at a\n-    // time to call `dlsym` and `dlopen` if we want to check the error message.\n+    // As of the 2017 revision of the POSIX standard (IEEE 1003.1-2017), it is\n+    // implementation-defined whether `dlerror` is thread-safe (in which case it returns the most\n+    // recent error in the calling thread) or not thread-safe (in which case it returns the most\n+    // recent error in *any* thread).\n+    //\n+    // There's no easy way to tell what strategy is used by a given POSIX implementation, so we\n+    // lock around all calls that can modify `dlerror` in this module lest we accidentally read an\n+    // error from a different thread. This is bulletproof when we are the *only* code using the\n+    // dynamic library APIs at a given point in time. However, it's still possible for us to race\n+    // with other code (see #74469) on platforms where `dlerror` is not thread-safe.\n     mod error {\n         use std::ffi::CStr;\n         use std::lazy::SyncLazy;\n@@ -97,51 +105,36 @@ mod dl {\n             return Ok(ret);\n         }\n \n-        // A NULL return from `dlopen` indicates that an error has\n-        // definitely occurred, so if nothing is in `dlerror`, we are\n-        // racing with another thread that has stolen our error message.\n+        // A NULL return from `dlopen` indicates that an error has definitely occurred, so if\n+        // nothing is in `dlerror`, we are racing with another thread that has stolen our error\n+        // message. See the explanation on the `dl::error` module for more information.\n         dlerror.get().and_then(|()| Err(\"Unknown error\".to_string()))\n     }\n \n     pub(super) unsafe fn symbol(\n         handle: *mut u8,\n         symbol: *const libc::c_char,\n     ) -> Result<*mut u8, String> {\n-        // HACK(#74469): On some platforms, users observed foreign code\n-        // (specifically libc) invoking `dlopen`/`dlsym` in parallel with the\n-        // functions in this module. This is problematic because, according to\n-        // the POSIX API documentation, `dlerror` must be called to determine\n-        // whether `dlsym` succeeded. Unlike `dlopen`, a NULL return value may\n-        // indicate a successfully resolved symbol with an address of zero.\n-        //\n-        // Because symbols with address zero shouldn't occur in practice, we\n-        // treat them as errors on platforms with misbehaving libc\n-        // implementations.\n-        const DLSYM_NULL_IS_ERROR: bool = cfg!(target_os = \"illumos\");\n-\n         let mut dlerror = error::lock();\n \n-        // No need to flush `dlerror` if we aren't using it to determine whether\n-        // the subsequent call to `dlsym` succeeded. If an error occurs, any\n-        // stale value will be overwritten.\n-        if !DLSYM_NULL_IS_ERROR {\n-            dlerror.clear();\n-        }\n+        // Unlike `dlopen`, it's possible for `dlsym` to return NULL without overwriting `dlerror`.\n+        // Because of this, we clear `dlerror` before calling `dlsym` to avoid picking up a stale\n+        // error message by accident.\n+        dlerror.clear();\n \n         let ret = libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8;\n \n-        // A non-NULL return value *always* indicates success. There's no need\n-        // to check `dlerror`.\n         if !ret.is_null() {\n             return Ok(ret);\n         }\n \n-        match dlerror.get() {\n-            Ok(()) if DLSYM_NULL_IS_ERROR => Err(\"Unknown error\".to_string()),\n-            Ok(()) => Ok(ret),\n-\n-            Err(msg) => Err(msg),\n-        }\n+        // If `dlsym` returns NULL but there is nothing in `dlerror` it means one of two things:\n+        // - We tried to load a symbol mapped to address 0. This is not technically an error but is\n+        //   unlikely to occur in practice and equally unlikely to be handled correctly by calling\n+        //   code. Therefore we treat it as an error anyway.\n+        // - An error has occurred, but we are racing with another thread that has stolen our error\n+        //   message. See the explanation on the `dl::error` module for more information.\n+        dlerror.get().and_then(|()| Err(\"Tried to load symbol mapped to address 0\".to_string()))\n     }\n \n     pub(super) unsafe fn close(handle: *mut u8) {"}]}