{"sha": "80d47fd11f702910bf15fa356abd3a4e6b0005f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZDQ3ZmQxMWY3MDI5MTBiZjE1ZmEzNTZhYmQzYTRlNmIwMDA1Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T00:00:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T00:00:57Z"}, "message": "auto merge of #5476 : thestinger/rust/bench, r=graydon\n\nThe old string benchmarks weren't very useful because the strings weren't long enough, so I just threw those out for now. I left out benchmarks of `oldmap` because it's clear that it's 30-40% slower and it doesn't implement the `Map` trait.\r\n\r\nThis also cleanly divides up `insert`, `search` and `remove`.", "tree": {"sha": "b9e5d41feccbbcac78ea130e2f5b8e35ef6daf6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9e5d41feccbbcac78ea130e2f5b8e35ef6daf6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80d47fd11f702910bf15fa356abd3a4e6b0005f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80d47fd11f702910bf15fa356abd3a4e6b0005f7", "html_url": "https://github.com/rust-lang/rust/commit/80d47fd11f702910bf15fa356abd3a4e6b0005f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80d47fd11f702910bf15fa356abd3a4e6b0005f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec8345b18abef2fba6153ae999446e3f05b8275a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec8345b18abef2fba6153ae999446e3f05b8275a", "html_url": "https://github.com/rust-lang/rust/commit/ec8345b18abef2fba6153ae999446e3f05b8275a"}, {"sha": "5acfe3d5376d58a549b508e4fbfe21cf31a79396", "url": "https://api.github.com/repos/rust-lang/rust/commits/5acfe3d5376d58a549b508e4fbfe21cf31a79396", "html_url": "https://github.com/rust-lang/rust/commit/5acfe3d5376d58a549b508e4fbfe21cf31a79396"}], "stats": {"total": 337, "additions": 87, "deletions": 250}, "files": [{"sha": "3b9d3ad4b7313b2d54a3997361f553a8c14f6879", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80d47fd11f702910bf15fa356abd3a4e6b0005f7/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d47fd11f702910bf15fa356abd3a4e6b0005f7/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=80d47fd11f702910bf15fa356abd3a4e6b0005f7", "patch": "@@ -136,15 +136,13 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n }\n \n-impl<T> TrieMap<T> {\n+pub impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n     #[inline(always)]\n     static pure fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n-}\n \n-impl<T> TrieMap<T> {\n     /// Visit all keys in reverse order\n     #[inline(always)]\n     pure fn each_key_reverse(&self, f: &fn(&uint) -> bool) {"}, {"sha": "67281594a395a1df073ba4ec4490353e96b862f2", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 86, "deletions": 247, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/80d47fd11f702910bf15fa356abd3a4e6b0005f7/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d47fd11f702910bf15fa356abd3a4e6b0005f7/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=80d47fd11f702910bf15fa356abd3a4e6b0005f7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,322 +9,161 @@\n // except according to those terms.\n \n extern mod std;\n-use std::oldmap;\n-use std::treemap::TreeMap;\n-use core::hashmap::linear::*;\n-use core::io::WriterUtil;\n-\n-struct Results {\n-    sequential_ints: float,\n-    random_ints: float,\n-    delete_ints: float,\n-\n-    sequential_strings: float,\n-    random_strings: float,\n-    delete_strings: float\n-}\n \n-fn timed(result: &mut float,\n-         op: &fn()) {\n-    let start = std::time::precise_time_s();\n-    op();\n-    let end = std::time::precise_time_s();\n-    *result = (end - start);\n+use core::io;\n+use std::time;\n+use std::treemap::TreeMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::trie::TrieMap;\n+\n+fn timed(label: &str, f: &fn()) {\n+    let start = time::precise_time_s();\n+    f();\n+    let end = time::precise_time_s();\n+    io::println(fmt!(\"  %s: %f\", label, end - start));\n }\n \n-fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-\n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.sequential_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(i, i+1);\n-            }\n+fn ascending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n+    io::println(\" Ascending integers:\");\n \n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.get(&i) == i+1);\n-            }\n+    do timed(\"insert\") {\n+        for uint::range(0, n_keys) |i| {\n+            map.insert(i, i + 1);\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.random_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(rng.next() as uint, i);\n-            }\n+    do timed(\"search\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.find(&i).unwrap() == &(i + 1));\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(i, i);;\n-        }\n-\n-        do timed(&mut results.delete_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&i));\n-            }\n+    do timed(\"remove\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.remove(&i));\n         }\n     }\n }\n \n-fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.sequential_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                map.insert(s, i);\n-            }\n+fn descending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n+    io::println(\" Descending integers:\");\n \n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                fail_unless!(map.get(&s) == i);\n-            }\n+    do timed(\"insert\") {\n+        for uint::range(0, n_keys) |i| {\n+            map.insert(i, i + 1);\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.random_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint);\n-                map.insert(s, i);\n-            }\n+    do timed(\"search\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.find(&i).unwrap() == &(i + 1));\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i), i);\n-        }\n-        do timed(&mut results.delete_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&uint::to_str(i)));\n-            }\n+    do timed(\"remove\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.remove(&i));\n         }\n     }\n }\n \n-fn linear_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.sequential_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(i, i+1);\n-            }\n+fn vector<M: Map<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.find(&i).unwrap() == &(i+1));\n-            }\n+    do timed(\"insert\") {\n+        for uint::range(0, n_keys) |i| {\n+            map.insert(dist[i], i + 1);\n         }\n     }\n \n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.random_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(rng.next() as uint, i);\n-            }\n+    do timed(\"search\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.find(&dist[i]).unwrap() == &(i + 1));\n         }\n     }\n \n-    {\n-        let mut map = LinearMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(i, i);;\n-        }\n-\n-        do timed(&mut results.delete_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&i));\n-            }\n+    do timed(\"remove\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.remove(&dist[i]));\n         }\n     }\n }\n \n-fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.sequential_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                map.insert(s, i);\n-            }\n-\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                fail_unless!(map.find(&s).unwrap() == &i);\n-            }\n+fn main() {\n+    let args = os::args();\n+    let n_keys = {\n+        if args.len() == 2 {\n+            uint::from_str(args[1]).get()\n+        } else {\n+            1000000\n         }\n-    }\n+    };\n \n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.random_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint);\n-                map.insert(s, i);\n-            }\n-        }\n-    }\n+    let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let mut map = LinearMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i), i);\n-        }\n-        do timed(&mut results.delete_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&uint::to_str(i)));\n+        let rng = core::rand::seeded_rng([1, 1, 1, 1, 1, 1, 1]);\n+        let mut set = LinearSet::new();\n+        while set.len() != n_keys {\n+            let next = rng.next() as uint;\n+            if set.insert(next) {\n+                rand.push(next);\n             }\n         }\n     }\n-}\n \n-fn tree_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.sequential_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(i, i+1);\n-            }\n+    io::println(fmt!(\"%? keys\", n_keys));\n \n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.find(&i).unwrap() == &(i+1));\n-            }\n-        }\n-    }\n+    io::println(\"\\nTreeMap:\");\n \n     {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.random_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(rng.next() as uint, i);\n-            }\n-        }\n+        let mut map = TreeMap::new::<uint, uint>();\n+        ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = TreeMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(i, i);;\n-        }\n-\n-        do timed(&mut results.delete_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&i));\n-            }\n-        }\n+        let mut map = TreeMap::new::<uint, uint>();\n+        descending(&mut map, n_keys);\n     }\n-}\n \n-fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.sequential_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                map.insert(s, i);\n-            }\n-\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                fail_unless!(map.find(&s).unwrap() == &i);\n-            }\n-        }\n+        io::println(\" Random integers:\");\n+        let mut map = TreeMap::new::<uint, uint>();\n+        vector(&mut map, n_keys, rand);\n     }\n \n+    io::println(\"\\nLinearMap:\");\n+\n     {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.random_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint);\n-                map.insert(s, i);\n-            }\n-        }\n+        let mut map = LinearMap::new::<uint, uint>();\n+        ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = TreeMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i), i);\n-        }\n-        do timed(&mut results.delete_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&uint::to_str(i)));\n-            }\n-        }\n+        let mut map = LinearMap::new::<uint, uint>();\n+        descending(&mut map, n_keys);\n     }\n-}\n-\n-fn write_header(header: &str) {\n-    io::stdout().write_str(header);\n-    io::stdout().write_str(\"\\n\");\n-}\n-\n-fn write_row(label: &str, value: float) {\n-    io::stdout().write_str(fmt!(\"%30s %f s\\n\", label, value));\n-}\n-\n-fn write_results(label: &str, results: &Results) {\n-    write_header(label);\n-    write_row(\"sequential_ints\", results.sequential_ints);\n-    write_row(\"random_ints\", results.random_ints);\n-    write_row(\"delete_ints\", results.delete_ints);\n-    write_row(\"sequential_strings\", results.sequential_strings);\n-    write_row(\"random_strings\", results.random_strings);\n-    write_row(\"delete_strings\", results.delete_strings);\n-}\n \n-fn empty_results() -> Results {\n-    Results {\n-        sequential_ints: 0f,\n-        random_ints: 0f,\n-        delete_ints: 0f,\n-\n-        sequential_strings: 0f,\n-        random_strings: 0f,\n-        delete_strings: 0f,\n+    {\n+        io::println(\" Random integers:\");\n+        let mut map = LinearMap::new::<uint, uint>();\n+        vector(&mut map, n_keys, rand);\n     }\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let num_keys = {\n-        if args.len() == 2 {\n-            uint::from_str(args[1]).get()\n-        } else {\n-            100 // woefully inadequate for any real measurement\n-        }\n-    };\n \n-    let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    io::println(\"\\nTrieMap:\");\n \n     {\n-        let rng = rand::seeded_rng(seed);\n-        let mut results = empty_results();\n-        old_int_benchmarks(rng, num_keys, &mut results);\n-        old_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"std::oldmap::HashMap\", &results);\n+        let mut map = TrieMap::new::<uint>();\n+        ascending(&mut map, n_keys);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n-        let mut results = empty_results();\n-        linear_int_benchmarks(rng, num_keys, &mut results);\n-        linear_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"core::hashmap::linear::LinearMap\", &results);\n+        let mut map = TrieMap::new::<uint>();\n+        descending(&mut map, n_keys);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n-        let mut results = empty_results();\n-        tree_int_benchmarks(rng, num_keys, &mut results);\n-        tree_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"std::treemap::TreeMap\", &results);\n+        io::println(\" Random integers:\");\n+        let mut map = TrieMap::new::<uint>();\n+        vector(&mut map, n_keys, rand);\n     }\n }"}]}