{"sha": "de85948ac0a6bc0fde0484790296cb4e041e993f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODU5NDhhYzBhNmJjMGZkZTA0ODQ3OTAyOTZjYjRlMDQxZTk5M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-26T08:41:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-26T08:41:57Z"}, "message": "auto merge of #13117 : alexcrichton/rust/no-crate-map, r=brson\n\nThis can be done now that logging has been moved out and libnative is the default (not libgreen)", "tree": {"sha": "71c6553b77c1abad61ab27a6e2886fa4b7a017aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71c6553b77c1abad61ab27a6e2886fa4b7a017aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de85948ac0a6bc0fde0484790296cb4e041e993f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de85948ac0a6bc0fde0484790296cb4e041e993f", "html_url": "https://github.com/rust-lang/rust/commit/de85948ac0a6bc0fde0484790296cb4e041e993f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de85948ac0a6bc0fde0484790296cb4e041e993f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bac5607c963c61d488a0d832458341589a560b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bac5607c963c61d488a0d832458341589a560b3", "html_url": "https://github.com/rust-lang/rust/commit/6bac5607c963c61d488a0d832458341589a560b3"}, {"sha": "e2ae4585481879290879e46881916ce6e3dd22c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ae4585481879290879e46881916ce6e3dd22c1", "html_url": "https://github.com/rust-lang/rust/commit/e2ae4585481879290879e46881916ce6e3dd22c1"}], "stats": {"total": 454, "additions": 116, "deletions": 338}, "files": [{"sha": "6c70362dbb336ab3ef33d92b9406931059950842", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -43,7 +43,9 @@ pub mod common;\n pub mod errors;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n \n pub fn main() {\n     let args = os::args();"}, {"sha": "b52c520761e233773865cc2f7f54e0a1c5965dfb", "filename": "src/doc/guide-runtime.md", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Fdoc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Fdoc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-runtime.md?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -223,27 +223,49 @@ Having a default decision made in the compiler is done out of necessity and\n convenience. The compiler's decision of runtime to link to is *not* an\n endorsement of one over the other. As always, this decision can be overridden.\n \n-For example, this program will be linked to \"the default runtime\"\n+For example, this program will be linked to \"the default runtime\". The current\n+default runtime is to use libnative.\n \n ~~~{.rust}\n fn main() {}\n ~~~\n \n-Whereas this program explicitly opts into using a particular runtime\n+### Force booting with libgreen\n+\n+In this example, the `main` function will be booted with I/O support powered by\n+libuv. This is done by linking to the `rustuv` crate and specifying the\n+`rustuv::event_loop` function as the event loop factory.\n+\n+To create a pool of green tasks which have no I/O support, you may shed the\n+`rustuv` dependency and use the `green::basic::event_loop` function instead of\n+`rustuv::event_loop`. All tasks will have no I/O support, but they will still be\n+able to deschedule/reschedule (use channels, locks, etc).\n \n ~~~{.rust}\n extern crate green;\n+extern crate rustuv;\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, main)\n+    green::start(argc, argv, rustuv::event_loop, main)\n }\n \n fn main() {}\n ~~~\n \n-Both libgreen/libnative provide a top-level `start` function which is used to\n-boot an initial Rust task in that specified runtime.\n+### Force booting with libnative\n+\n+This program's `main` function will always be booted with libnative, running\n+inside of an OS thread.\n+\n+~~~{.rust}\n+extern crate native;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+\n+fn main() {}\n+~~~\n \n # Finding the runtime\n "}, {"sha": "b2596e568157ff24e463f4519d88dd5a75cc13de", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -237,7 +237,7 @@ mod test {\n     fn pool() -> SchedPool {\n         SchedPool::new(PoolConfig {\n             threads: 1,\n-            event_loop_factory: Some(basic::event_loop),\n+            event_loop_factory: basic::event_loop,\n         })\n     }\n \n@@ -267,7 +267,7 @@ mod test {\n     fn multi_thread() {\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 2,\n-            event_loop_factory: Some(basic::event_loop),\n+            event_loop_factory: basic::event_loop,\n         });\n \n         for _ in range(0, 20) {"}, {"sha": "3f7685d6c20a38033963dbdefb958ffbfcaacf69", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -116,13 +116,34 @@\n //! extern crate green;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+//! fn start(argc: int, argv: **u8) -> int {\n+//!     green::start(argc, argv, green::basic::event_loop, main)\n+//! }\n //!\n //! fn main() {\n //!     // this code is running in a pool of schedulers\n //! }\n //! ```\n //!\n+//! > **Note**: This `main` funciton in this example does *not* have I/O\n+//! >           support. The basic event loop does not provide any support\n+//!\n+//! # Starting with I/O support in libgreen\n+//!\n+//! ```rust\n+//! extern crate green;\n+//! extern crate rustuv;\n+//!\n+//! #[start]\n+//! fn start(argc: int, argv: **u8) -> int {\n+//!     green::start(argc, argv, rustuv::event_loop, main)\n+//! }\n+//!\n+//! fn main() {\n+//!     // this code is running in a pool of schedulers all powered by libuv\n+//! }\n+//! ```\n+//!\n //! # Using a scheduler pool\n //!\n //! ```rust\n@@ -176,11 +197,11 @@\n #[allow(visible_private_types)];\n \n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n+#[cfg(test)] extern crate rustuv;\n extern crate rand;\n \n use std::mem::replace;\n use std::os;\n-use std::rt::crate_map;\n use std::rt::rtio;\n use std::rt::thread::Thread;\n use std::rt;\n@@ -225,12 +246,14 @@ pub mod task;\n ///\n /// The return value is used as the process return code. 0 on success, 101 on\n /// error.\n-pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n+pub fn start(argc: int, argv: **u8,\n+             event_loop_factory: fn() -> ~rtio::EventLoop,\n+             main: proc()) -> int {\n     rt::init(argc, argv);\n     let mut main = Some(main);\n     let mut ret = None;\n     simple::task().run(|| {\n-        ret = Some(run(main.take_unwrap()));\n+        ret = Some(run(event_loop_factory, main.take_unwrap()));\n     });\n     // unsafe is ok b/c we're sure that the runtime is gone\n     unsafe { rt::cleanup() }\n@@ -245,10 +268,12 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n ///\n /// This function will not return until all schedulers in the associated pool\n /// have returned.\n-pub fn run(main: proc()) -> int {\n+pub fn run(event_loop_factory: fn() -> ~rtio::EventLoop, main: proc()) -> int {\n     // Create a scheduler pool and spawn the main task into this pool. We will\n     // get notified over a channel when the main task exits.\n-    let mut pool = SchedPool::new(PoolConfig::new());\n+    let mut cfg = PoolConfig::new();\n+    cfg.event_loop_factory = event_loop_factory;\n+    let mut pool = SchedPool::new(cfg);\n     let (tx, rx) = channel();\n     let mut opts = TaskOpts::new();\n     opts.notify_chan = Some(tx);\n@@ -273,7 +298,7 @@ pub struct PoolConfig {\n     threads: uint,\n     /// A factory function used to create new event loops. If this is not\n     /// specified then the default event loop factory is used.\n-    event_loop_factory: Option<fn() -> ~rtio::EventLoop>,\n+    event_loop_factory: fn() -> ~rtio::EventLoop,\n }\n \n impl PoolConfig {\n@@ -282,7 +307,7 @@ impl PoolConfig {\n     pub fn new() -> PoolConfig {\n         PoolConfig {\n             threads: rt::default_sched_threads(),\n-            event_loop_factory: None,\n+            event_loop_factory: basic::event_loop,\n         }\n     }\n }\n@@ -324,7 +349,6 @@ impl SchedPool {\n             threads: nscheds,\n             event_loop_factory: factory\n         } = config;\n-        let factory = factory.unwrap_or(default_event_loop_factory());\n         assert!(nscheds > 0);\n \n         // The pool of schedulers that will be returned from this function\n@@ -493,20 +517,3 @@ impl Drop for SchedPool {\n         }\n     }\n }\n-\n-fn default_event_loop_factory() -> fn() -> ~rtio::EventLoop {\n-    match crate_map::get_crate_map() {\n-        None => {}\n-        Some(map) => {\n-            match map.event_loop_factory {\n-                None => {}\n-                Some(factory) => return factory\n-            }\n-        }\n-    }\n-\n-    // If the crate map didn't specify a factory to create an event loop, then\n-    // instead just use a basic event loop missing all I/O services to at least\n-    // get the scheduler running.\n-    return basic::event_loop;\n-}"}, {"sha": "5571d4f4687234a2291537b14dbb2fe409380314", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -1003,6 +1003,8 @@ fn new_sched_rng() -> XorShiftRng {\n \n #[cfg(test)]\n mod test {\n+    use rustuv;\n+\n     use std::comm;\n     use std::task::TaskOpts;\n     use std::rt::Runtime;\n@@ -1017,7 +1019,7 @@ mod test {\n     fn pool() -> SchedPool {\n         SchedPool::new(PoolConfig {\n             threads: 1,\n-            event_loop_factory: Some(basic::event_loop),\n+            event_loop_factory: basic::event_loop,\n         })\n     }\n \n@@ -1262,7 +1264,7 @@ mod test {\n \n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 2,\n-            event_loop_factory: None,\n+            event_loop_factory: rustuv::event_loop,\n         });\n \n         // This is a regression test that when there are no schedulable tasks in\n@@ -1413,7 +1415,7 @@ mod test {\n     fn dont_starve_1() {\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 2, // this must be > 1\n-            event_loop_factory: Some(basic::event_loop),\n+            event_loop_factory: basic::event_loop,\n         });\n         pool.spawn(TaskOpts::new(), proc() {\n             let (tx, rx) = channel();"}, {"sha": "25e868470bf392b391056fb8d320a6c997c1ba38", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -494,7 +494,7 @@ mod tests {\n     fn spawn_opts(opts: TaskOpts, f: proc()) {\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 1,\n-            event_loop_factory: None,\n+            event_loop_factory: ::rustuv::event_loop,\n         });\n         pool.spawn(opts, f);\n         pool.shutdown();"}, {"sha": "29bf5b9c93f9d066ed9fcea025d81e888547c0cd", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -451,8 +451,6 @@ cgoptions!(\n         \"don't run LLVM's SLP vectorization pass\"),\n     soft_float: bool = (false, parse_bool,\n         \"generate software floating point library calls\"),\n-    gen_crate_map: bool = (false, parse_bool,\n-        \"force generation of a toplevel crate map\"),\n     prefer_dynamic: bool = (false, parse_bool,\n         \"prefer dynamic linking to static linking\"),\n     no_integrated_as: bool = (false, parse_bool,"}, {"sha": "2ba408bfa005b7ebfb2b99764bc462507cf5f0c0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -254,8 +254,6 @@ lets_do_this! {\n     TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n     OpaqueStructLangItem,            \"opaque\",                  opaque;\n \n-    EventLoopFactoryLangItem,        \"event_loop_factory\",      event_loop_factory;\n-\n     TypeIdLangItem,                  \"type_id\",                 type_id;\n \n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;"}, {"sha": "8c20cf39b49fe47b6e5481fa6624c99f47f407b1", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -980,7 +980,7 @@ static other_attrs: &'static [&'static str] = &[\n     \"thread_local\", // for statics\n     \"allow\", \"deny\", \"forbid\", \"warn\", // lint options\n     \"deprecated\", \"experimental\", \"unstable\", \"stable\", \"locked\", \"frozen\", //item stability\n-    \"crate_map\", \"cfg\", \"doc\", \"export_name\", \"link_section\",\n+    \"cfg\", \"doc\", \"export_name\", \"link_section\",\n     \"no_mangle\", \"static_assert\", \"unsafe_no_drop_flag\", \"packed\",\n     \"simd\", \"repr\", \"deriving\", \"unsafe_destructor\", \"link\", \"phase\",\n     \"macro_export\", \"must_use\", \"automatically_derived\","}, {"sha": "b5e649721153bfd18141d8f65bc73b63ead3d04c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -76,7 +76,7 @@ use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::libc::c_uint;\n use std::local_data;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n+use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_map::PathName;\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n@@ -2316,65 +2316,6 @@ pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n     link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n }\n \n-pub fn decl_crate_map(ccx: &mut CrateContext) {\n-    let mut n_subcrates = 1;\n-    while ccx.sess().cstore.have_crate_data(n_subcrates) {\n-        n_subcrates += 1;\n-    }\n-    let is_top = !ccx.sess().building_library.get() || ccx.sess().opts.cg.gen_crate_map;\n-    let sym_name = if is_top {\n-        ~\"_rust_crate_map_toplevel\"\n-    } else {\n-        symname(\"_rust_crate_map_\" + ccx.link_meta.crateid.name,\n-                ccx.link_meta.crate_hash.as_str(),\n-                ccx.link_meta.crateid.version_or_default())\n-    };\n-\n-    let maptype = Type::struct_(ccx, [\n-        Type::i32(ccx),        // version\n-        ccx.int_type.ptr_to(), // event loop factory\n-    ], false);\n-    let map = sym_name.with_c_str(|buf| {\n-        unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n-        }\n-    });\n-    lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n-\n-    // On windows we'd like to export the toplevel cratemap\n-    // such that we can find it from libstd.\n-    if ccx.sess().targ_cfg.os == OsWin32 && is_top {\n-        unsafe { llvm::LLVMRustSetDLLExportStorageClass(map) }\n-    }\n-\n-    ccx.crate_map_name = sym_name;\n-    ccx.crate_map = map;\n-}\n-\n-pub fn fill_crate_map(ccx: &CrateContext, map: ValueRef) {\n-    let event_loop_factory = match ccx.tcx.lang_items.event_loop_factory() {\n-        Some(did) => unsafe {\n-            if is_local(did) {\n-                llvm::LLVMConstPointerCast(get_item_val(ccx, did.node),\n-                                           ccx.int_type.ptr_to().to_ref())\n-            } else {\n-                let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-                let global = name.with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n-                });\n-                global\n-            }\n-        },\n-        None => C_null(ccx.int_type.ptr_to())\n-    };\n-    unsafe {\n-        llvm::LLVMSetInitializer(map, C_struct(ccx,\n-            [C_i32(ccx, 2),\n-            event_loop_factory,\n-        ], false));\n-    }\n-}\n-\n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n \n@@ -2467,26 +2408,6 @@ pub fn trans_crate(krate: ast::Crate,\n         trans_mod(&ccx, &krate.module);\n     }\n \n-    fill_crate_map(&ccx, ccx.crate_map);\n-\n-    // win32: wart with exporting crate_map symbol\n-    // We set the crate map (_rust_crate_map_toplevel) to use dll_export\n-    // linkage but that ends up causing the linker to look for a\n-    // __rust_crate_map_toplevel symbol (extra underscore) which it will\n-    // subsequently fail to find. So to mitigate that we just introduce\n-    // an alias from the symbol it expects to the one that actually exists.\n-    if ccx.sess().targ_cfg.os == OsWin32 && !ccx.sess().building_library.get() {\n-\n-        let maptype = val_ty(ccx.crate_map).to_ref();\n-\n-        \"__rust_crate_map_toplevel\".with_c_str(|buf| {\n-            unsafe {\n-                llvm::LLVMAddAlias(ccx.llmod, maptype,\n-                                   ccx.crate_map, buf);\n-            }\n-        })\n-    }\n-\n     glue::emit_tydescs(&ccx);\n     if ccx.sess().opts.debuginfo != NoDebugInfo {\n         debuginfo::finalize(&ccx);\n@@ -2537,7 +2458,6 @@ pub fn trans_crate(krate: ast::Crate,\n     // symbol. This symbol is required for use by the libmorestack library that\n     // we link in, so we must ensure that this symbol is not internalized (if\n     // defined in the crate).\n-    reachable.push(ccx.crate_map_name.to_owned());\n     reachable.push(~\"main\");\n     reachable.push(~\"rust_stack_exhausted\");\n     reachable.push(~\"rust_eh_personality\"); // referenced from .eh_frame section on some platforms"}, {"sha": "a8ff0760eaa4b3df963b87e06f54c39387985928", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -22,7 +22,6 @@ use middle::trans::base;\n use middle::trans::builder::Builder;\n use middle::trans::common::{C_i32, C_null};\n use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n-use middle::trans::base::{decl_crate_map};\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -105,8 +104,6 @@ pub struct CrateContext {\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n-    crate_map: ValueRef,\n-    crate_map_name: ~str,\n     // Set when at least one function uses GC. Needed so that\n     // decl_gc_metadata knows whether to link to the module metadata, which\n     // is not emitted by LLVM's GC pass when no functions use GC.\n@@ -200,8 +197,6 @@ impl CrateContext {\n                 int_type: Type::from_ref(ptr::null()),\n                 opaque_vec_type: Type::from_ref(ptr::null()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                crate_map: ptr::null(),\n-                crate_map_name: ~\"\",\n                 uses_gc: false,\n                 dbg_cx: dbg_cx,\n             };\n@@ -215,8 +210,6 @@ impl CrateContext {\n             str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type], false);\n             ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-            decl_crate_map(&mut ccx);\n-\n             base::declare_intrinsics(&mut ccx);\n \n             if ccx.sess().count_llvm_insns() {"}, {"sha": "4aa272a63a3e740631e937380c3e2604b0b094f3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -134,28 +134,6 @@ pub fn register_static(ccx: &CrateContext,\n     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n     let llty = type_of::type_of(ccx, ty);\n \n-    // Treat the crate map static specially in order to\n-    // a weak-linkage-like functionality where it's\n-    // dynamically resolved at runtime. If we're\n-    // building a library, then we declare the static\n-    // with weak linkage, but if we're building a\n-    // library then we've already declared the crate map\n-    // so use that instead.\n-    if attr::contains_name(foreign_item.attrs.as_slice(), \"crate_map\") {\n-        return if ccx.sess().building_library.get() {\n-            let s = \"_rust_crate_map_toplevel\";\n-            let g = unsafe {\n-                s.with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n-                })\n-            };\n-            lib::llvm::SetLinkage(g, lib::llvm::ExternalWeakLinkage);\n-            g\n-        } else {\n-            ccx.crate_map\n-        }\n-    }\n-\n     let ident = link_name(foreign_item);\n     match attr::first_attr_value_str_by_name(foreign_item.attrs.as_slice(),\n                                              \"linkage\") {"}, {"sha": "3ece7662dd57c3a1391eadc9dbd4d1aeaf7ed061", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -167,7 +167,7 @@ mod test {\n         let (tx, rx) = channel();\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 1,\n-            event_loop_factory: None,\n+            event_loop_factory: ::event_loop,\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {\n@@ -188,7 +188,7 @@ mod test {\n         let (tx, rx) = channel();\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 1,\n-            event_loop_factory: None,\n+            event_loop_factory: ::event_loop,\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {"}, {"sha": "cf1d95588bb9f24ffa1bffcf73664c0d701f2cd8", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -54,6 +54,7 @@ use std::libc::{c_int, c_void};\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n+use std::rt::rtio;\n use std::rt::task::{BlockedTask, Task};\n use std::str::raw::from_c_str;\n use std::str;\n@@ -76,7 +77,7 @@ pub use self::tty::TtyWatcher;\n //        '__test' module.\n #[cfg(test)] #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, __test::main)\n+    green::start(argc, argv, event_loop, __test::main)\n }\n \n mod macros;\n@@ -104,6 +105,31 @@ pub mod tty;\n pub mod signal;\n pub mod stream;\n \n+/// Creates a new event loop which is powered by libuv\n+///\n+/// This function is used in tandem with libgreen's `PoolConfig` type as a value\n+/// for the `event_loop_factory` field. Using this function as the event loop\n+/// factory will power programs with libuv and enable green threading.\n+///\n+/// # Example\n+///\n+/// ```\n+/// extern crate rustuv;\n+/// extern crate green;\n+///\n+/// #[start]\n+/// fn start(argc: int, argv: **u8) -> int {\n+///     green::start(argc, argv, rustuv::event_loop, main)\n+/// }\n+///\n+/// fn main() {\n+///     // this code is running inside of a green task powered by libuv\n+/// }\n+/// ```\n+pub fn event_loop() -> ~rtio::EventLoop {\n+    ~uvio::UvEventLoop::new() as ~rtio::EventLoop\n+}\n+\n /// A type that wraps a uv handle\n pub trait UvHandle<T> {\n     fn uv_handle(&self) -> *T;"}, {"sha": "15de0408795395e7d2c70b42b29e7c82c5557928", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -105,12 +105,6 @@ impl rtio::EventLoop for UvEventLoop {\n     }\n }\n \n-#[cfg(not(test))]\n-#[lang = \"event_loop_factory\"]\n-pub fn new_loop() -> ~rtio::EventLoop {\n-    ~UvEventLoop::new() as ~rtio::EventLoop\n-}\n-\n #[test]\n fn test_callback_run_once() {\n     use std::rt::rtio::EventLoop;"}, {"sha": "9e13d70b0ce18a339b024bf02f80648ce20eaab5", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -84,7 +84,7 @@\n //        '__test' module.\n #[cfg(test)] #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, __test::main)\n+    green::start(argc, argv, rustuv::event_loop, __test::main)\n }\n \n pub mod macros;"}, {"sha": "98f4986b2c72a4d1aec0a0cd3b524d5dd30b476b", "filename": "src/libstd/rt/crate_map.rs", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6bac5607c963c61d488a0d832458341589a560b3/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bac5607c963c61d488a0d832458341589a560b3/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=6bac5607c963c61d488a0d832458341589a560b3", "patch": "@@ -1,104 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use cast;\n-use option::{Some, None, Option};\n-use ptr::RawPtr;\n-use rt::rtio::EventLoop;\n-\n-// Need to tell the linker on OS X to not barf on undefined symbols\n-// and instead look them up at runtime, which we need to resolve\n-// the crate_map properly.\n-#[cfg(target_os = \"macos\")]\n-#[link_args = \"-Wl,-U,__rust_crate_map_toplevel\"]\n-extern {}\n-\n-pub struct CrateMap<'a> {\n-    version: i32,\n-    event_loop_factory: Option<fn() -> ~EventLoop>,\n-}\n-\n-// When working on android, apparently weak symbols don't work so well for\n-// finding the crate map, and neither does dlopen + dlsym. This is mainly a\n-// problem when integrating a shared library with an existing application.\n-// Standalone binaries do not appear to have this problem. The reasons are a\n-// little mysterious, and more information can be found in #11731.\n-//\n-// For now we provide a way to tell libstd about the crate map manually that's\n-// checked before the normal weak symbol/dlopen paths. In theory this is useful\n-// on other platforms where our dlopen/weak linkage strategy mysteriously fails\n-// but the crate map can be specified manually.\n-static mut MANUALLY_PROVIDED_CRATE_MAP: *CrateMap<'static> =\n-                                                    0 as *CrateMap<'static>;\n-#[no_mangle]\n-#[cfg(not(test))]\n-pub extern fn rust_set_crate_map(map: *CrateMap<'static>) {\n-    unsafe { MANUALLY_PROVIDED_CRATE_MAP = map; }\n-}\n-\n-fn manual_crate_map() -> Option<&'static CrateMap<'static>> {\n-    unsafe {\n-        if MANUALLY_PROVIDED_CRATE_MAP.is_null() {\n-            None\n-        } else {\n-            Some(cast::transmute(MANUALLY_PROVIDED_CRATE_MAP))\n-        }\n-    }\n-}\n-\n-#[cfg(not(windows))]\n-pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n-    extern {\n-        #[crate_map]\n-        static CRATE_MAP: CrateMap<'static>;\n-    }\n-\n-    manual_crate_map().or_else(|| {\n-        let ptr: (*CrateMap) = &'static CRATE_MAP;\n-        if ptr.is_null() {\n-            None\n-        } else {\n-            Some(&'static CRATE_MAP)\n-        }\n-    })\n-}\n-\n-#[cfg(windows)]\n-pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n-    use c_str::ToCStr;\n-    use unstable::dynamic_lib::dl;\n-\n-    match manual_crate_map() {\n-        Some(cm) => return Some(cm),\n-        None => {}\n-    }\n-\n-    let sym = unsafe {\n-        let module = dl::open_internal();\n-        let rust_crate_map_toplevel = if cfg!(target_arch = \"x86\") {\n-            \"__rust_crate_map_toplevel\"\n-        } else {\n-            \"_rust_crate_map_toplevel\"\n-        };\n-        let sym = rust_crate_map_toplevel.with_c_str(|buf| {\n-            dl::symbol(module, buf)\n-        });\n-        dl::close(module);\n-        sym\n-    };\n-    let ptr: (*CrateMap) = sym as *CrateMap;\n-    if ptr.is_null() {\n-        return None;\n-    } else {\n-        unsafe {\n-            return Some(cast::transmute(sym));\n-        }\n-    }\n-}"}, {"sha": "795281026a4266f5055762105810bddc0cacd882", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -104,9 +104,6 @@ pub mod env;\n /// The local, managed heap\n pub mod local_heap;\n \n-/// Crate map\n-pub mod crate_map;\n-\n /// The runtime needs to be able to put a pointer into thread-local storage.\n mod local_ptr;\n "}, {"sha": "43388fd9a6f941787c61bf9d8c4ee364dc9e77f2", "filename": "src/test/run-make/bootstrap-from-c-with-green/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) lib.rs -C gen-crate-map\n+\t$(RUSTC) lib.rs\n \tln -nsf $(call DYLIB,boot-*) $(call DYLIB,boot)\n \t$(CC) main.c -o $(call RUN,main) -lboot\n \t$(call RUN,main)"}, {"sha": "36b92e127f9d2fe9649630abf6d59a3411b21e06", "filename": "src/test/run-make/bootstrap-from-c-with-green/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -16,7 +16,7 @@ extern crate green;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, proc() {\n+    green::start(argc, argv, rustuv::event_loop, proc() {\n         spawn(proc() {\n             println!(\"hello\");\n         });"}, {"sha": "43388fd9a6f941787c61bf9d8c4ee364dc9e77f2", "filename": "src/test/run-make/bootstrap-from-c-with-native/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) lib.rs -C gen-crate-map\n+\t$(RUSTC) lib.rs\n \tln -nsf $(call DYLIB,boot-*) $(call DYLIB,boot)\n \t$(CC) main.c -o $(call RUN,main) -lboot\n \t$(call RUN,main)"}, {"sha": "134d15f37aa7e3007dbce62827880aa86bdd6c3b", "filename": "src/test/run-make/c-link-to-rust-staticlib/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -5,7 +5,7 @@ ifneq ($(shell uname),Darwin)\n endif\n \n all:\n-\t$(RUSTC) foo.rs -C gen-crate-map\n+\t$(RUSTC) foo.rs\n \tln -s $(call STATICLIB,foo-*) $(call STATICLIB,foo)\n \t$(CC) bar.c -lfoo -o $(call RUN,bar) $(EXTRAFLAGS) -lstdc++\n \t$(call RUN,bar)"}, {"sha": "954f10d3eddfdb36b0aaf77a1b7325a483c0681e", "filename": "src/test/run-make/c-set-crate-map-manually/Makefile", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bac5607c963c61d488a0d832458341589a560b3/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6bac5607c963c61d488a0d832458341589a560b3/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2FMakefile?ref=6bac5607c963c61d488a0d832458341589a560b3", "patch": "@@ -1,7 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) lib.rs -C gen-crate-map\n-\tln -nsf $(call DYLIB,boot-*) $(call DYLIB,boot)\n-\t$(CC) main.c -o $(call RUN,main) -lboot -Wl,-rpath,$(TMPDIR)\n-\tRUST_LOG=boot $(call RUN,main)"}, {"sha": "d5bada4a127f902ba503dd9b532f2834d7458130", "filename": "src/test/run-make/c-set-crate-map-manually/lib.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6bac5607c963c61d488a0d832458341589a560b3/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bac5607c963c61d488a0d832458341589a560b3/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2Flib.rs?ref=6bac5607c963c61d488a0d832458341589a560b3", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[crate_id=\"boot#0.1\"];\n-#[crate_type=\"dylib\"];\n-#[no_uv];\n-#[feature(phase)];\n-\n-extern crate rustuv;\n-extern crate green;\n-#[phase(syntax, link)] extern crate log;\n-\n-use std::rt::crate_map::{CrateMap, rust_set_crate_map};\n-\n-// pull in this symbol from libstd into this crate (for convenience)\n-#[no_mangle]\n-pub static set_crate_map: extern \"C\" fn(*CrateMap<'static>) = rust_set_crate_map;\n-\n-#[no_mangle] // this needs to get called from C\n-pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, proc() {\n-        if log_enabled!(log::DEBUG) { return }\n-        fail!()\n-    })\n-}"}, {"sha": "a69ec7d0c86e573355bfd658dbaff9938edce512", "filename": "src/test/run-make/c-set-crate-map-manually/main.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bac5607c963c61d488a0d832458341589a560b3/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/6bac5607c963c61d488a0d832458341589a560b3/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fc-set-crate-map-manually%2Fmain.c?ref=6bac5607c963c61d488a0d832458341589a560b3", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// this is the rust entry point that we're going to call.\n-int foo(int argc, char *argv[]);\n-\n-extern void (*set_crate_map)(void *map);\n-extern int _rust_crate_map_toplevel;\n-\n-int main(int argc, char *argv[]) {\n-  set_crate_map(&_rust_crate_map_toplevel);\n-  return foo(argc, argv);\n-}"}, {"sha": "6a7039277365291e5832a349881b5b3e12465c49", "filename": "src/test/run-make/lto-smoke-c/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-smoke-c%2FMakefile?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -5,7 +5,7 @@ ifneq ($(shell uname),Darwin)\n endif\n \n all:\n-\t$(RUSTC) foo.rs -C gen-crate-map -Z lto\n+\t$(RUSTC) foo.rs -Z lto\n \tln -s $(call STATICLIB,foo-*) $(call STATICLIB,foo)\n \t$(CC) bar.c -lfoo -o $(call RUN,bar) $(EXTRAFLAGS) -lstdc++\n \t$(call RUN,bar)"}, {"sha": "87d3c337bddb01b7359c5e26e379e1ef4503aafc", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -49,7 +49,7 @@ macro_rules! iotest (\n \n #[cfg(test)] #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, __test::main)\n+    green::start(argc, argv, rustuv::event_loop, __test::main)\n }\n \n iotest!(fn test_destroy_once() {"}, {"sha": "40c087b5c25b9db29da508e62e3b66c9fc6f9f71", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -15,7 +15,9 @@ extern crate green;\n extern crate rustuv;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n \n fn main() {\n     native::task::spawn(proc() customtask());"}, {"sha": "d20d0eeb58c82388d3877d03639f69517ca53361", "filename": "src/test/run-pass/issue-8860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8860.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -18,7 +18,7 @@ static mut DROP_T: int = 0i;\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    let ret = green::start(argc, argv, main);\n+    let ret = green::start(argc, argv, green::basic::event_loop, main);\n     unsafe {\n         assert_eq!(2, DROP);\n         assert_eq!(1, DROP_S);"}, {"sha": "3b80d9ce491ccdac200278976aca945deebd1fbe", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de85948ac0a6bc0fde0484790296cb4e041e993f/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=de85948ac0a6bc0fde0484790296cb4e041e993f", "patch": "@@ -28,7 +28,9 @@ use std::io::process;\n use std::io::signal::{Listener, Interrupt};\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n \n fn main() {\n     unsafe { libc::setsid(); }"}]}