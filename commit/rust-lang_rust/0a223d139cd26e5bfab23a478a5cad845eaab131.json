{"sha": "0a223d139cd26e5bfab23a478a5cad845eaab131", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMjIzZDEzOWNkMjZlNWJmYWIyM2E0NzhhNWNhZDg0NWVhYWIxMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-10T14:14:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-10T14:14:35Z"}, "message": "Auto merge of #50395 - Zoxc:small-tys, r=michaelwoerister\n\nOptimize layout of TypeVariants\n\nThis makes references to `Slice` use thin pointers by storing the slice length in the slice itself. `GeneratorInterior` is replaced by storing the movability of generators in `TyGenerator` and the interior witness is stored in `GeneratorSubsts` (which is just a wrapper around `&'tcx Substs`, like `ClosureSubsts`). Finally the fields of `TypeAndMut` is stored inline in `TyRef`. These changes combine to reduce `TypeVariants` from 48 bytes to 24 bytes on x86_64.\n\nr? @michaelwoerister", "tree": {"sha": "00f4e6c1a696643b74d0c5d1bdb3455faffe2979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00f4e6c1a696643b74d0c5d1bdb3455faffe2979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a223d139cd26e5bfab23a478a5cad845eaab131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a223d139cd26e5bfab23a478a5cad845eaab131", "html_url": "https://github.com/rust-lang/rust/commit/0a223d139cd26e5bfab23a478a5cad845eaab131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a223d139cd26e5bfab23a478a5cad845eaab131/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57dc98434eb818733dbc941405fdee59e5c3a023", "url": "https://api.github.com/repos/rust-lang/rust/commits/57dc98434eb818733dbc941405fdee59e5c3a023", "html_url": "https://github.com/rust-lang/rust/commit/57dc98434eb818733dbc941405fdee59e5c3a023"}, {"sha": "c9d9c249ec95afa53a1862fcb99bf04c339b126c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d9c249ec95afa53a1862fcb99bf04c339b126c", "html_url": "https://github.com/rust-lang/rust/commit/c9d9c249ec95afa53a1862fcb99bf04c339b126c"}], "stats": {"total": 1152, "additions": 615, "deletions": 537}, "files": [{"sha": "c71b10ce142c56da1153841fbbd933dc141e6072", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -483,10 +483,10 @@ for mir::AggregateKind<'gcx> {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            mir::AggregateKind::Generator(def_id, ref substs, ref interior) => {\n+            mir::AggregateKind::Generator(def_id, ref substs, movability) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n-                interior.hash_stable(hcx, hasher);\n+                movability.hash_stable(hcx, hasher);\n             }\n         }\n     }"}, {"sha": "d0d0ab093c87ffbd976c77489d6beebc9a7f89da", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -517,8 +517,7 @@ for ::middle::const_val::ErrKind<'gcx> {\n }\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n-\n-impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness, movable });\n+impl_stable_hash_for!(struct ty::GeneratorSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,\n@@ -889,9 +888,10 @@ for ty::TypeVariants<'gcx>\n             TyRawPtr(pointee_ty) => {\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyRef(region, pointee_ty) => {\n+            TyRef(region, pointee_ty, mutbl) => {\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n+                mutbl.hash_stable(hcx, hasher);\n             }\n             TyFnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n@@ -908,10 +908,10 @@ for ty::TypeVariants<'gcx>\n                 def_id.hash_stable(hcx, hasher);\n                 closure_substs.hash_stable(hcx, hasher);\n             }\n-            TyGenerator(def_id, closure_substs, interior) => {\n+            TyGenerator(def_id, generator_substs, movability) => {\n                 def_id.hash_stable(hcx, hasher);\n-                closure_substs.hash_stable(hcx, hasher);\n-                interior.hash_stable(hcx, hasher);\n+                generator_substs.hash_stable(hcx, hasher);\n+                movability.hash_stable(hcx, hasher);\n             }\n             TyGeneratorWitness(types) => {\n                 types.hash_stable(hcx, hasher)\n@@ -1315,11 +1315,11 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableGeneratorData {\n-            closure_def_id,\n+            generator_def_id,\n             substs,\n             ref nested,\n         } = *self;\n-        closure_def_id.hash_stable(hcx, hasher);\n+        generator_def_id.hash_stable(hcx, hasher);\n         substs.hash_stable(hcx, hasher);\n         nested.hash_stable(hcx, hasher);\n     }"}, {"sha": "da93156b0b0bd53c2acfd930d7346b08bbbca934", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -665,21 +665,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         fn push_ty_ref<'tcx>(\n             r: &ty::Region<'tcx>,\n-            tnm: &ty::TypeAndMut<'tcx>,\n+            ty: Ty<'tcx>,\n+            mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n         ) {\n             let r = &format!(\"{}\", r);\n             s.push_highlighted(format!(\n                 \"&{}{}{}\",\n                 r,\n                 if r == \"\" { \"\" } else { \" \" },\n-                if tnm.mutbl == hir::MutMutable {\n+                if mutbl == hir::MutMutable {\n                     \"mut \"\n                 } else {\n                     \"\"\n                 }\n             ));\n-            s.push_normal(format!(\"{}\", tnm.ty));\n+            s.push_normal(format!(\"{}\", ty));\n         }\n \n         match (&t1.sty, &t2.sty) {\n@@ -803,24 +804,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // When finding T != &T, highlight only the borrow\n-            (&ty::TyRef(r1, ref tnm1), _) if equals(&tnm1.ty, &t2) => {\n+            (&ty::TyRef(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                push_ty_ref(&r1, tnm1, &mut values.0);\n+                push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 values.1.push_normal(format!(\"{}\", t2));\n                 values\n             }\n-            (_, &ty::TyRef(r2, ref tnm2)) if equals(&t1, &tnm2.ty) => {\n+            (_, &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 values.0.push_normal(format!(\"{}\", t1));\n-                push_ty_ref(&r2, tnm2, &mut values.1);\n+                push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n-            (&ty::TyRef(r1, ref tnm1), &ty::TyRef(r2, ref tnm2)) if equals(&tnm1.ty, &tnm2.ty) => {\n+            (&ty::TyRef(r1, ref_ty1, mutbl1),\n+             &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                push_ty_ref(&r1, tnm1, &mut values.0);\n-                push_ty_ref(&r2, tnm2, &mut values.1);\n+                push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n+                push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n "}, {"sha": "614ae17fa46923b7afb9c5ebfdf605e69c670bcc", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::TyRef(r, _) = expr_ty.sty {\n+                if let ty::TyRef(r, _, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -859,7 +859,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match bm {\n                     ty::BindByReference(m) => {\n-                        if let ty::TyRef(r, _) = pat_ty.sty {\n+                        if let ty::TyRef(r, _, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n                         }"}, {"sha": "3875770a5ff5c50298de2c1154e0d2be4d243241", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -1012,7 +1012,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n         let (region, mutbl) = match base_ty.sty {\n-            ty::TyRef(region, mt) => (region, mt.mutbl),\n+            ty::TyRef(region, _, mutbl) => (region, mutbl),\n             _ => {\n                 span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n             }\n@@ -1046,8 +1046,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let ptr = match base_cmt.ty.sty {\n             ty::TyAdt(def, ..) if def.is_box() => Unique,\n             ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n-            ty::TyRef(r, mt) => {\n-                let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n+            ty::TyRef(r, _, mutbl) => {\n+                let bk = ty::BorrowKind::from_mutbl(mutbl);\n                 if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n             ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)"}, {"sha": "11e25322f00726b2e2226f7ae09bfed9f81cf96b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -27,9 +27,8 @@ use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n use mir::interpret::{Value, PrimVal, EvalErrorKind};\n use ty::subst::{Subst, Substs};\n-use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n+use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::TypeAndMut;\n use util::ppaux;\n use std::slice;\n use hir::{self, InlineAsm};\n@@ -1641,7 +1640,7 @@ pub enum AggregateKind<'tcx> {\n     Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n \n     Closure(DefId, ClosureSubsts<'tcx>),\n-    Generator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n+    Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n@@ -1905,9 +1904,8 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n             write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n         (Value::ByVal(PrimVal::Undef), &TyFnDef(did, _)) =>\n             write!(f, \"{}\", item_path_str(did)),\n-        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)), &TyRef(_, TypeAndMut {\n-            ty: &ty::TyS { sty: TyStr, .. }, ..\n-        })) => {\n+        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)),\n+         &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n                 let alloc = tcx\n                     .interpret_interner\n@@ -2375,10 +2373,8 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                         AggregateKind::Adt(def, v, substs.fold_with(folder), n),\n                     AggregateKind::Closure(id, substs) =>\n                         AggregateKind::Closure(id, substs.fold_with(folder)),\n-                    AggregateKind::Generator(id, substs, interior) =>\n-                        AggregateKind::Generator(id,\n-                                                 substs.fold_with(folder),\n-                                                 interior.fold_with(folder)),\n+                    AggregateKind::Generator(id, substs, movablity) =>\n+                        AggregateKind::Generator(id, substs.fold_with(folder), movablity),\n                 };\n                 Aggregate(kind, fields.fold_with(folder))\n             }\n@@ -2405,8 +2401,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                     AggregateKind::Tuple => false,\n                     AggregateKind::Adt(_, _, substs, _) => substs.visit_with(visitor),\n                     AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n-                    AggregateKind::Generator(_, substs, interior) => substs.visit_with(visitor) ||\n-                        interior.visit_with(visitor),\n+                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n                 }) || fields.visit_with(visitor)\n             }\n         }"}, {"sha": "6a9ff39c5f56b191163d8e59256b10a020501ade", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -184,10 +184,10 @@ impl<'tcx> Rvalue<'tcx> {\n                         tcx.type_of(def.did).subst(tcx, substs)\n                     }\n                     AggregateKind::Closure(did, substs) => {\n-                        tcx.mk_closure_from_closure_substs(did, substs)\n+                        tcx.mk_closure(did, substs)\n                     }\n-                    AggregateKind::Generator(did, substs, interior) => {\n-                        tcx.mk_generator(did, substs, interior)\n+                    AggregateKind::Generator(did, substs, movability) => {\n+                        tcx.mk_generator(did, substs, movability)\n                     }\n                 }\n             }"}, {"sha": "b647ba553dd6c1f782f8d0d69ca16754bd35d53a", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{CanonicalTy, ClosureSubsts, Region, Ty, GeneratorInterior};\n+use ty::{CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty};\n use mir::*;\n use syntax_pos::Span;\n \n@@ -243,10 +243,10 @@ macro_rules! make_mir_visitor {\n                 self.super_closure_substs(substs);\n             }\n \n-            fn visit_generator_interior(&mut self,\n-                                    interior: & $($mutability)* GeneratorInterior<'tcx>,\n+            fn visit_generator_substs(&mut self,\n+                                      substs: & $($mutability)* GeneratorSubsts<'tcx>,\n                                     _: Location) {\n-                self.super_generator_interior(interior);\n+                self.super_generator_substs(substs);\n             }\n \n             fn visit_local_decl(&mut self,\n@@ -595,11 +595,10 @@ macro_rules! make_mir_visitor {\n                                 self.visit_closure_substs(closure_substs, location);\n                             }\n                             AggregateKind::Generator(ref $($mutability)* def_id,\n-                                                   ref $($mutability)* closure_substs,\n-                                                   ref $($mutability)* interior) => {\n+                                                     ref $($mutability)* generator_substs,\n+                                                     _movability) => {\n                                 self.visit_def_id(def_id, location);\n-                                self.visit_closure_substs(closure_substs, location);\n-                                self.visit_generator_interior(interior, location);\n+                                self.visit_generator_substs(generator_substs, location);\n                             }\n                         }\n \n@@ -786,8 +785,8 @@ macro_rules! make_mir_visitor {\n             fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n             }\n \n-            fn super_generator_interior(&mut self,\n-                                    _interior: & $($mutability)* GeneratorInterior<'tcx>) {\n+            fn super_generator_substs(&mut self,\n+                                      _substs: & $($mutability)* GeneratorSubsts<'tcx>) {\n             }\n \n             fn super_closure_substs(&mut self,"}, {"sha": "25be4a2ff5c8b086633c4d87de95ff94e4fbdeb5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -878,9 +878,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let mut trait_type = trait_ref.self_ty();\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n-                    trait_type.sty {\n-\n+                if let ty::TypeVariants::TyRef(_, t_type, _) = trait_type.sty {\n                     trait_type = t_type;\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);"}, {"sha": "10d88063ac35faea1c358253ffb82fbb42207169", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -482,8 +482,8 @@ pub struct VtableImplData<'tcx, N> {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableGeneratorData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: ty::ClosureSubsts<'tcx>,\n+    pub generator_def_id: DefId,\n+    pub substs: ty::GeneratorSubsts<'tcx>,\n     /// Nested obligations. This can be non-empty if the generator\n     /// signature contains associated types.\n     pub nested: Vec<N>\n@@ -991,7 +991,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n             VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n-                closure_def_id: c.closure_def_id,\n+                generator_def_id: c.generator_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),"}, {"sha": "bfa32f8e7faf3393058be9bc51da36c956081c1e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -1288,7 +1288,7 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n     vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let gen_sig = vtable.substs.generator_poly_sig(vtable.closure_def_id, selcx.tcx());\n+    let gen_sig = vtable.substs.poly_sig(vtable.generator_def_id, selcx.tcx());\n     let Normalized {\n         value: gen_sig,\n         obligations"}, {"sha": "3ed1e7ea5ebd65d99c7e3af6cb86be0631eb7177", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -2174,14 +2174,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::TyRef(_, _, hir::MutImmutable) => {\n                 // Implementations provided in libcore\n                 None\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyGenerator(..) | ty::TyGeneratorWitness(..) | ty::TyForeign(..) |\n-            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::TyRef(_, _, hir::MutMutable) => {\n                 Never\n             }\n \n@@ -2270,7 +2270,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n-            ty::TyRef(_, ty::TypeAndMut { ty: element_ty, ..}) => {\n+            ty::TyRef(_, element_ty, _) => {\n                 vec![element_ty]\n             },\n \n@@ -2287,8 +2287,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n-            ty::TyGenerator(def_id, ref substs, interior) => {\n-                substs.upvar_tys(def_id, self.tcx()).chain(iter::once(interior.witness)).collect()\n+            ty::TyGenerator(def_id, ref substs, _) => {\n+                let witness = substs.witness(def_id, self.tcx());\n+                substs.upvar_tys(def_id, self.tcx()).chain(iter::once(witness)).collect()\n             }\n \n             ty::TyGeneratorWitness(types) => {\n@@ -2762,18 +2763,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs) = match self_ty.sty {\n+        let (generator_def_id, substs) = match self_ty.sty {\n             ty::TyGenerator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n         };\n \n         debug!(\"confirm_generator_candidate({:?},{:?},{:?})\",\n                obligation,\n-               closure_def_id,\n+               generator_def_id,\n                substs);\n \n         let trait_ref =\n-            self.generator_trait_ref_unnormalized(obligation, closure_def_id, substs);\n+            self.generator_trait_ref_unnormalized(obligation, generator_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n             mut obligations\n@@ -2783,8 +2784,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  obligation.recursion_depth+1,\n                                  &trait_ref);\n \n-        debug!(\"confirm_generator_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n-               closure_def_id,\n+        debug!(\"confirm_generator_candidate(generator_def_id={:?}, \\\n+                trait_ref={:?}, obligations={:?})\",\n+               generator_def_id,\n                trait_ref,\n                obligations);\n \n@@ -2795,7 +2797,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                         trait_ref)?);\n \n         Ok(VtableGeneratorData {\n-            closure_def_id: closure_def_id,\n+            generator_def_id: generator_def_id,\n             substs: substs.clone(),\n             nested: obligations\n         })\n@@ -3301,10 +3303,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn generator_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: DefId,\n-                                      substs: ty::ClosureSubsts<'tcx>)\n+                                      substs: ty::GeneratorSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let gen_sig = substs.generator_poly_sig(closure_def_id, self.tcx());\n+        let gen_sig = substs.poly_sig(closure_def_id, self.tcx());\n \n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an generator type and hence is"}, {"sha": "822ea17009b6b0fe60abf65f1391f7862b06e105", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -83,8 +83,8 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableGenerator(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.closure_def_id,\n+        write!(f, \"VtableGenerator(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.generator_def_id,\n                self.substs,\n                self.nested)\n     }\n@@ -294,13 +294,13 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n             }\n             traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n             traits::VtableGenerator(traits::VtableGeneratorData {\n-                closure_def_id,\n+                generator_def_id,\n                 substs,\n                 nested\n             }) => {\n                 tcx.lift(&substs).map(|substs| {\n                     traits::VtableGenerator(traits::VtableGeneratorData {\n-                        closure_def_id: closure_def_id,\n+                        generator_def_id: generator_def_id,\n                         substs: substs,\n                         nested: nested\n                     })\n@@ -373,7 +373,7 @@ BraceStructTypeFoldableImpl! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n-        closure_def_id, substs, nested\n+        generator_def_id, substs, nested\n     } where N: TypeFoldable<'tcx>\n }\n "}, {"sha": "908335424e71320d7e061c4e19078eeba572104c", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -36,9 +36,9 @@ pub enum CastTy<'tcx> {\n     /// Function Pointers\n     FnPtr,\n     /// Raw pointers\n-    Ptr(&'tcx ty::TypeAndMut<'tcx>),\n+    Ptr(ty::TypeAndMut<'tcx>),\n     /// References\n-    RPtr(&'tcx ty::TypeAndMut<'tcx>),\n+    RPtr(ty::TypeAndMut<'tcx>),\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n@@ -69,8 +69,8 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyFloat(_) => Some(CastTy::Float),\n             ty::TyAdt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n-            ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n-            ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n+            ty::TyRawPtr(mt) => Some(CastTy::Ptr(mt)),\n+            ty::TyRef(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n             ty::TyFnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }"}, {"sha": "36eb091cb6e5bcefc5d6f5b34ba14b1706e41199", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -41,7 +41,7 @@ use traits;\n use traits::{Clause, Clauses, Goal, Goals};\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region, Const};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -2351,7 +2351,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyRef(r, tm))\n+        self.mk_ty(TyRef(r, tm.ty, tm.mutbl))\n     }\n \n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2436,26 +2436,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }))\n         }\n \n-    pub fn mk_closure(self,\n-                      closure_id: DefId,\n-                      substs: ClosureSubsts<'tcx>)\n-                      -> Ty<'tcx> {\n-        self.mk_closure_from_closure_substs(closure_id, substs)\n-    }\n-\n-    pub fn mk_closure_from_closure_substs(self,\n-                                          closure_id: DefId,\n-                                          closure_substs: ClosureSubsts<'tcx>)\n+    pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n                                           -> Ty<'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n     pub fn mk_generator(self,\n                         id: DefId,\n-                        closure_substs: ClosureSubsts<'tcx>,\n-                        interior: GeneratorInterior<'tcx>)\n+                        generator_substs: GeneratorSubsts<'tcx>,\n+                        movability: hir::GeneratorMovability)\n                         -> Ty<'tcx> {\n-        self.mk_ty(TyGenerator(id, closure_substs, interior))\n+        self.mk_ty(TyGenerator(id, generator_substs, movability))\n     }\n \n     pub fn mk_generator_witness(self, types: ty::Binder<&'tcx Slice<Ty<'tcx>>>) -> Ty<'tcx> {"}, {"sha": "cfde35de93c3b1ac2963dd0186bb2b628d74f93a", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -189,20 +189,17 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             }\n             ty::TySlice(_) => \"slice\".to_string(),\n             ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n-            ty::TyRef(region, tymut) => {\n+            ty::TyRef(region, ty, mutbl) => {\n+                let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n                 if tymut_string == \"_\" ||         //unknown type name,\n                    tymut_string.len() > 10 ||     //name longer than saying \"reference\",\n                    region.to_string() != \"\"       //... or a complex type\n                 {\n-                    match tymut {\n-                        ty::TypeAndMut{mutbl, ..} => {\n-                            format!(\"{}reference\", match mutbl {\n-                                hir::Mutability::MutMutable => \"mutable \",\n-                                _ => \"\"\n-                            })\n-                        }\n-                    }\n+                    format!(\"{}reference\", match mutbl {\n+                        hir::Mutability::MutMutable => \"mutable \",\n+                        _ => \"\"\n+                    })\n                 } else {\n                     format!(\"&{}\", tymut_string)\n                 }"}, {"sha": "cf5e55a59f713e10cd16534bba946745570adaba", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -80,11 +80,11 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyDynamic(ref trait_info, ..) => {\n             trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n-        ty::TyRef(_, mt) => {\n+        ty::TyRef(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n             // view of possibly unifying\n-            simplify_type(tcx, mt.ty, can_simplify_params)\n+            simplify_type(tcx, ty, can_simplify_params)\n         }\n         ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => {"}, {"sha": "01de848e0f076b077010336b17cf02ec42eba7e8", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -87,11 +87,10 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyGenerator(_, ref substs, ref interior) => {\n+            &ty::TyGenerator(_, ref substs, _) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n                 self.add_substs(&substs.substs);\n-                self.add_ty(interior.witness);\n             }\n \n             &ty::TyGeneratorWitness(ref ts) => {\n@@ -174,9 +173,9 @@ impl FlagComputation {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty::TyRef(r, ref m) => {\n+            &ty::TyRef(r, ty, _) => {\n                 self.add_region(r);\n-                self.add_ty(m.ty);\n+                self.add_ty(ty);\n             }\n \n             &ty::TyTuple(ref ts) => {"}, {"sha": "17a3d0011eddfe5276eadb910ff9dc214583568f", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -269,8 +269,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                     _ => DefIdForest::empty()\n                 }\n             }\n-            TyRef(_, ref tm) => {\n-                tm.ty.uninhabited_from(visited, tcx)\n+            TyRef(_, ty, _) => {\n+                ty.uninhabited_from(visited, tcx)\n             }\n \n             _ => DefIdForest::empty(),"}, {"sha": "e7b71ca2b228e2da11da91b1dd8ebf3a69072f14", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -270,10 +270,10 @@ fn resolve_associated_item<'a, 'tcx>(\n             let substs = tcx.erase_regions(&substs);\n             Some(ty::Instance::new(def_id, substs))\n         }\n-        traits::VtableGenerator(closure_data) => {\n+        traits::VtableGenerator(generator_data) => {\n             Some(Instance {\n-                def: ty::InstanceDef::Item(closure_data.closure_def_id),\n-                substs: closure_data.substs.substs\n+                def: ty::InstanceDef::Item(generator_data.generator_def_id),\n+                substs: generator_data.substs.substs\n             })\n         }\n         traits::VtableClosure(closure_data) => {\n@@ -356,8 +356,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n         .unwrap().def_id;\n     let def = ty::InstanceDef::ClosureOnceShim { call_once };\n \n-    let self_ty = tcx.mk_closure_from_closure_substs(\n-        closure_did, substs);\n+    let self_ty = tcx.mk_closure(closure_did, substs);\n \n     let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);"}, {"sha": "41625afec86a02a659b6d2582ce8ae5a2d3f1ce9", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -360,8 +360,9 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) => characteristic_def_id_of_type(subty),\n \n-        ty::TyRawPtr(mt) |\n-        ty::TyRef(_, mt) => characteristic_def_id_of_type(mt.ty),\n+        ty::TyRawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+\n+        ty::TyRef(_, ty, _) => characteristic_def_id_of_type(ty),\n \n         ty::TyTuple(ref tys) => tys.iter()\n                                    .filter_map(|ty| characteristic_def_id_of_type(ty))"}, {"sha": "0688dcabe5585db0d83089b372f918c30b07dbb3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n@@ -1262,7 +1262,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         };\n \n         match ty.sty {\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail(pointee);\n@@ -1560,7 +1560,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 assert!(i < 2);\n "}, {"sha": "7076112e3715a285b6377140e3319d40332fcff3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -63,7 +63,7 @@ use hir;\n pub use self::sty::{Binder, CanonicalVar, DebruijnIndex};\n pub use self::sty::{FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n-pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n+pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n@@ -514,7 +514,7 @@ impl<'tcx> TyS<'tcx> {\n                 TypeVariants::TyInfer(InferTy::FloatVar(_)) |\n                 TypeVariants::TyInfer(InferTy::FreshIntTy(_)) |\n                 TypeVariants::TyInfer(InferTy::FreshFloatTy(_)) => true,\n-            TypeVariants::TyRef(_, x) => x.ty.is_primitive_ty(),\n+            TypeVariants::TyRef(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n     }"}, {"sha": "109dfebf154de67730d3e0294d5cf092af1dee30", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -415,16 +415,15 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n-        (&ty::TyGenerator(a_id, a_substs, a_interior),\n-         &ty::TyGenerator(b_id, b_substs, b_interior))\n+        (&ty::TyGenerator(a_id, a_substs, movability),\n+         &ty::TyGenerator(b_id, b_substs, _))\n             if a_id == b_id =>\n         {\n             // All TyGenerator types with the same id represent\n             // the (anonymous) type of the same generator expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n-            let interior = relation.relate(&a_interior, &b_interior)?;\n-            Ok(tcx.mk_generator(a_id, substs, interior))\n+            Ok(tcx.mk_generator(a_id, substs, movability))\n         }\n \n         (&ty::TyGeneratorWitness(a_types), &ty::TyGeneratorWitness(b_types)) =>\n@@ -446,7 +445,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n-            Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n+            Ok(tcx.mk_closure(a_id, substs))\n         }\n \n         (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n@@ -455,10 +454,12 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_ptr(mt))\n         }\n \n-        (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n+        (&ty::TyRef(a_r, a_ty, a_mutbl), &ty::TyRef(b_r, b_ty, b_mutbl)) =>\n         {\n             let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n-            let mt = relation.relate(a_mt, b_mt)?;\n+            let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n+            let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n+            let mt = relation.relate(&a_mt, &b_mt)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n@@ -607,20 +608,19 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n-        Ok(ty::ClosureSubsts { substs: substs })\n+        Ok(ty::ClosureSubsts { substs })\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::GeneratorInterior<'tcx> {\n+impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::GeneratorInterior<'tcx>,\n-                           b: &ty::GeneratorInterior<'tcx>)\n-                           -> RelateResult<'tcx, ty::GeneratorInterior<'tcx>>\n+                           a: &ty::GeneratorSubsts<'tcx>,\n+                           b: &ty::GeneratorSubsts<'tcx>)\n+                           -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        assert_eq!(a.movable, b.movable);\n-        let witness = relation.relate(&a.witness, &b.witness)?;\n-        Ok(ty::GeneratorInterior { witness, movable: a.movable })\n+        let substs = relate_substs(relation, None, a.substs, b.substs)?;\n+        Ok(ty::GeneratorSubsts { substs })\n     }\n }\n "}, {"sha": "e77ede72143b1afd819f169f0d5355dbf7bc0373", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -304,16 +304,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n-            ty::ClosureSubsts { substs: substs }\n+            ty::ClosureSubsts { substs }\n         })\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorInterior<'a> {\n-    type Lifted = ty::GeneratorInterior<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n+    type Lifted = ty::GeneratorSubsts<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.witness).map(|witness| {\n-            ty::GeneratorInterior { witness, movable: self.movable }\n+        tcx.lift(&self.substs).map(|substs| {\n+            ty::GeneratorSubsts { substs }\n         })\n     }\n }\n@@ -864,11 +864,14 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n                 ty::TyFnDef(def_id, substs.fold_with(folder))\n             }\n             ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n-            ty::TyRef(ref r, tm) => {\n-                ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n+            ty::TyRef(ref r, ty, mutbl) => {\n+                ty::TyRef(r.fold_with(folder), ty.fold_with(folder), mutbl)\n             }\n-            ty::TyGenerator(did, substs, interior) => {\n-                ty::TyGenerator(did, substs.fold_with(folder), interior.fold_with(folder))\n+            ty::TyGenerator(did, substs, movability) => {\n+                ty::TyGenerator(\n+                    did,\n+                    substs.fold_with(folder),\n+                    movability)\n             }\n             ty::TyGeneratorWitness(types) => ty::TyGeneratorWitness(types.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n@@ -901,9 +904,9 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n-            ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n-            ty::TyGenerator(_did, ref substs, ref interior) => {\n-                substs.visit_with(visitor) || interior.visit_with(visitor)\n+            ty::TyRef(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n+            ty::TyGenerator(_did, ref substs, _) => {\n+                substs.visit_with(visitor)\n             }\n             ty::TyGeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n@@ -980,8 +983,8 @@ BraceStructTypeFoldableImpl! {\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n-        witness, movable,\n+    impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorSubsts<'tcx> {\n+        substs,\n     }\n }\n "}, {"sha": "7518f008fb316515be6f8b4ce65e1f2ffe442b6d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 111, "deletions": 53, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -121,7 +121,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    TyRef(Region<'tcx>, TypeAndMut<'tcx>),\n+    TyRef(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n@@ -139,7 +139,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n-    TyGenerator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n+    TyGenerator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n     /// A type representin the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n@@ -328,37 +328,6 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         self.split(def_id, tcx).closure_sig_ty\n     }\n \n-    /// Returns the type representing the yield type of the generator.\n-    pub fn generator_yield_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n-        self.closure_kind_ty(def_id, tcx)\n-    }\n-\n-    /// Returns the type representing the return type of the generator.\n-    pub fn generator_return_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n-        self.closure_sig_ty(def_id, tcx)\n-    }\n-\n-    /// Return the \"generator signature\", which consists of its yield\n-    /// and return types.\n-    ///\n-    /// NB. Some bits of the code prefers to see this wrapped in a\n-    /// binder, but it never contains bound regions. Probably this\n-    /// function should be removed.\n-    pub fn generator_poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> PolyGenSig<'tcx> {\n-        ty::Binder::dummy(self.generator_sig(def_id, tcx))\n-    }\n-\n-    /// Return the \"generator signature\", which consists of its yield\n-    /// and return types.\n-    pub fn generator_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> GenSig<'tcx> {\n-        ty::GenSig {\n-            yield_ty: self.generator_yield_ty(def_id, tcx),\n-            return_ty: self.generator_return_ty(def_id, tcx),\n-        }\n-    }\n-}\n-\n-impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n@@ -381,7 +350,84 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct GeneratorSubsts<'tcx> {\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+struct SplitGeneratorSubsts<'tcx> {\n+    yield_ty: Ty<'tcx>,\n+    return_ty: Ty<'tcx>,\n+    witness: Ty<'tcx>,\n+    upvar_kinds: &'tcx [Kind<'tcx>],\n+}\n+\n+impl<'tcx> GeneratorSubsts<'tcx> {\n+    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> SplitGeneratorSubsts<'tcx> {\n+        let generics = tcx.generics_of(def_id);\n+        let parent_len = generics.parent_count();\n+        SplitGeneratorSubsts {\n+            yield_ty: self.substs.type_at(parent_len),\n+            return_ty: self.substs.type_at(parent_len + 1),\n+            witness: self.substs.type_at(parent_len + 2),\n+            upvar_kinds: &self.substs[parent_len + 3..],\n+        }\n+    }\n+\n+    /// This describes the types that can be contained in a generator.\n+    /// It will be a type variable initially and unified in the last stages of typeck of a body.\n+    /// It contains a tuple of all the types that could end up on a generator frame.\n+    /// The state transformation MIR pass may only produce layouts which mention types\n+    /// in this tuple. Upvars are not counted here.\n+    pub fn witness(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.split(def_id, tcx).witness\n+    }\n+\n+    #[inline]\n+    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'tcx\n+    {\n+        let SplitGeneratorSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n+        upvar_kinds.iter().map(|t| {\n+            if let UnpackedKind::Type(ty) = t.unpack() {\n+                ty\n+            } else {\n+                bug!(\"upvar should be type\")\n+            }\n+        })\n+    }\n+\n+    /// Returns the type representing the yield type of the generator.\n+    pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.split(def_id, tcx).yield_ty\n+    }\n+\n+    /// Returns the type representing the return type of the generator.\n+    pub fn return_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.split(def_id, tcx).return_ty\n+    }\n+\n+    /// Return the \"generator signature\", which consists of its yield\n+    /// and return types.\n+    ///\n+    /// NB. Some bits of the code prefers to see this wrapped in a\n+    /// binder, but it never contains bound regions. Probably this\n+    /// function should be removed.\n+    pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> PolyGenSig<'tcx> {\n+        ty::Binder::dummy(self.sig(def_id, tcx))\n+    }\n+\n+    /// Return the \"generator signature\", which consists of its yield\n+    /// and return types.\n+    pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> GenSig<'tcx> {\n+        ty::GenSig {\n+            yield_ty: self.yield_ty(def_id, tcx),\n+            return_ty: self.return_ty(def_id, tcx),\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// This returns the types of the MIR locals which had to be stored across suspension points.\n     /// It is calculated in rustc_mir::transform::generator::StateTransform.\n     /// All the types here must be in the tuple in GeneratorInterior.\n@@ -412,15 +458,29 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-/// This describes the types that can be contained in a generator.\n-/// It will be a type variable initially and unified in the last stages of typeck of a body.\n-/// It contains a tuple of all the types that could end up on a generator frame.\n-/// The state transformation MIR pass may only produce layouts which mention types in this tuple.\n-/// Upvars are not counted here.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct GeneratorInterior<'tcx> {\n-    pub witness: Ty<'tcx>,\n-    pub movable: bool,\n+#[derive(Debug, Copy, Clone)]\n+pub enum UpvarSubsts<'tcx> {\n+    Closure(ClosureSubsts<'tcx>),\n+    Generator(GeneratorSubsts<'tcx>),\n+}\n+\n+impl<'tcx> UpvarSubsts<'tcx> {\n+    #[inline]\n+    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'tcx\n+    {\n+        let upvar_kinds = match self {\n+            UpvarSubsts::Closure(substs) => substs.split(def_id, tcx).upvar_kinds,\n+            UpvarSubsts::Generator(substs) => substs.split(def_id, tcx).upvar_kinds,\n+        };\n+        upvar_kinds.iter().map(|t| {\n+            if let UnpackedKind::Type(ty) = t.unpack() {\n+                ty\n+            } else {\n+                bug!(\"upvar should be type\")\n+            }\n+        })\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1332,7 +1392,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_slice(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n+            TyRawPtr(TypeAndMut { ty, .. }) | TyRef(_, ty, _) => match ty.sty {\n                 TySlice(_) | TyStr => true,\n                 _ => false,\n             },\n@@ -1381,11 +1441,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_mutable_pointer(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(tnm) | TyRef(_, tnm) => if let hir::Mutability::MutMutable = tnm.mutbl {\n-                true\n-            } else {\n-                false\n-            },\n+            TyRawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n+            TyRef(_, _, hir::Mutability::MutMutable) => true,\n             _ => false\n         }\n     }\n@@ -1538,7 +1595,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                     mutbl: hir::MutImmutable,\n                 })\n             },\n-            TyRef(_, mt) => Some(mt),\n+            TyRef(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n             TyRawPtr(mt) if explicit => Some(mt),\n             _ => None,\n         }\n@@ -1592,7 +1649,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// ignores late-bound regions binders.\n     pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n         match self.sty {\n-            TyRef(region, _) => {\n+            TyRef(region, _, _) => {\n                 vec![region]\n             }\n             TyDynamic(ref obj, region) => {\n@@ -1605,8 +1662,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyAdt(_, substs) | TyAnon(_, substs) => {\n                 substs.regions().collect()\n             }\n-            TyClosure(_, ref substs) | TyGenerator(_, ref substs, _) => {\n-                substs.substs.regions().collect()\n+            TyClosure(_, ClosureSubsts { ref substs }) |\n+            TyGenerator(_, GeneratorSubsts { ref substs }, _) => {\n+                substs.regions().collect()\n             }\n             TyProjection(ref data) => {\n                 data.substs.regions().collect()"}, {"sha": "80dc3b2b452ce4047370fcf5683b9da55872d8fa", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -201,7 +201,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // Now libcore provides that impl.\n                 ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n                 ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => return Ok(()),\n+                ty::TyRef(_, _, hir::MutImmutable) => return Ok(()),\n \n                 ty::TyAdt(adt, substs) => (adt, substs),\n \n@@ -664,8 +664,8 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                     _ => bug!(\"arrays should not have {:?} as length\", n)\n                 }\n             }\n-            TyRawPtr(m) |\n-            TyRef(_, m) => self.hash(m.mutbl),\n+            TyRawPtr(m) => self.hash(m.mutbl),\n+            TyRef(_, _, mutbl) => self.hash(mutbl),\n             TyClosure(def_id, _) |\n             TyGenerator(def_id, _, _) |\n             TyAnon(def_id, _) |\n@@ -1141,7 +1141,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n \n         match self_arg_ty.sty {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n-            ty::TyRef(region, ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n+            ty::TyRef(region, ty, mutbl) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {"}, {"sha": "ebe88d60ed12f0ec9b624d4744d10603b67e2f78", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -92,9 +92,12 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TySlice(ty) => {\n             stack.push(ty);\n         }\n-        ty::TyRawPtr(ref mt) | ty::TyRef(_, ref mt) => {\n+        ty::TyRawPtr(ref mt) => {\n             stack.push(mt.ty);\n         }\n+        ty::TyRef(_, ty, _) => {\n+            stack.push(ty);\n+        }\n         ty::TyProjection(ref data) => {\n             stack.extend(data.substs.types().rev());\n         }\n@@ -118,8 +121,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyClosure(_, ref substs) => {\n             stack.extend(substs.substs.types().rev());\n         }\n-        ty::TyGenerator(_, ref substs, ref interior) => {\n-            stack.push(interior.witness);\n+        ty::TyGenerator(_, ref substs, _) => {\n             stack.extend(substs.substs.types().rev());\n         }\n         ty::TyGeneratorWitness(ts) => {"}, {"sha": "62fed1ecb668aa5402809263a630db9d6733c01b", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -298,17 +298,17 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.out.extend(obligations);\n                 }\n \n-                ty::TyRef(r, mt) => {\n+                ty::TyRef(r, rty, _) => {\n                     // WfReference\n-                    if !r.has_escaping_regions() && !mt.ty.has_escaping_regions() {\n+                    if !r.has_escaping_regions() && !rty.has_escaping_regions() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n                         self.out.push(\n                             traits::Obligation::new(\n                                 cause,\n                                 param_env,\n                                 ty::Predicate::TypeOutlives(\n                                     ty::Binder::dummy(\n-                                        ty::OutlivesPredicate(mt.ty, r)))));\n+                                        ty::OutlivesPredicate(rty, r)))));\n                     }\n                 }\n "}, {"sha": "4fb1017035168497b5d42b9534251e736a9e2e43", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -995,14 +995,6 @@ define_print! {\n     }\n }\n \n-define_print! {\n-    ('tcx) ty::GeneratorInterior<'tcx>, (self, f, cx) {\n-        display {\n-            self.witness.print(f, cx)\n-        }\n-    }\n-}\n-\n define_print! {\n     ('tcx) ty::TypeVariants<'tcx>, (self, f, cx) {\n         display {\n@@ -1019,14 +1011,14 @@ define_print! {\n                     })?;\n                     tm.ty.print(f, cx)\n                 }\n-                TyRef(r, ref tm) => {\n+                TyRef(r, ty, mutbl) => {\n                     write!(f, \"&\")?;\n                     let s = r.print_to_string(cx);\n                     write!(f, \"{}\", s)?;\n                     if !s.is_empty() {\n                         write!(f, \" \")?;\n                     }\n-                    tm.print(f, cx)\n+                    ty::TypeAndMut { ty, mutbl }.print(f, cx)\n                 }\n                 TyNever => write!(f, \"!\"),\n                 TyTuple(ref tys) => {\n@@ -1110,9 +1102,10 @@ define_print! {\n                     })\n                 }\n                 TyStr => write!(f, \"str\"),\n-                TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                TyGenerator(did, substs, movability) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n-                    if interior.movable {\n+                    let witness = substs.witness(did, tcx);\n+                    if movability == hir::GeneratorMovability::Movable {\n                         write!(f, \"[generator\")?;\n                     } else {\n                         write!(f, \"[static generator\")?;\n@@ -1145,7 +1138,7 @@ define_print! {\n                         }\n                     }\n \n-                    print!(f, cx, write(\" \"), print(interior), write(\"]\"))\n+                    print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n                 }),\n                 TyGeneratorWitness(types) => {\n                     ty::tls::with(|tcx| cx.in_binder(f, tcx, &types, tcx.lift(&types)))"}, {"sha": "5102bfe766eeff2370e63610b3043b9fa2357797", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -1173,9 +1173,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n-            Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {\n-                if to_mt.mutbl == hir::Mutability::MutMutable &&\n-                   from_mt.mutbl == hir::Mutability::MutImmutable {\n+            Some((&ty::TyRef(_, _, from_mt), &ty::TyRef(_, _, to_mt))) => {\n+                if to_mt == hir::Mutability::MutMutable &&\n+                   from_mt == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }"}, {"sha": "32963146893bbf2e9c2ff1b5e148c05b42109e5d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -662,8 +662,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 help: Some(\"consider using a struct instead\"),\n             },\n \n-            ty::TyRawPtr(ref m) |\n-            ty::TyRef(_, ref m) => self.check_type_for_ffi(cache, m.ty),\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyRef(_, ty, _) => self.check_type_for_ffi(cache, ty),\n \n             ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n "}, {"sha": "fde740bce3f3566129adbdf7b8322d42fe27eb15", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -773,8 +773,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     format!(\"{}\", def.non_enum_variant().fields[field.index()].name)\n                 },\n                 ty::TyTuple(_) => format!(\"{}\", field.index()),\n-                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n-                    self.describe_field_from_ty(&tnm.ty, field)\n+                ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                    self.describe_field_from_ty(&ty, field)\n                 }\n                 ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n                 ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {"}, {"sha": "1cc69351b4750578633dbfb8992f9f7e2f68f3a1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -835,10 +835,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tys.iter().cloned().enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n-            // Closures and generators also have disjoint fields, but they are only\n-            // directly accessed in the body of the closure/generator.\n+            // Closures also have disjoint fields, but they are only\n+            // directly accessed in the body of the closure.\n             ty::TyClosure(def, substs)\n-            | ty::TyGenerator(def, substs, ..)\n+                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n+            => {\n+                substs.upvar_tys(def, self.tcx).enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Generators also have disjoint fields, but they are only\n+            // directly accessed in the body of the generator.\n+            ty::TyGenerator(def, substs, _)\n                 if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n             => {\n                 substs.upvar_tys(def, self.tcx).enumerate()\n@@ -1906,8 +1913,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n-                            ty::TyRef(_, tnm) => {\n-                                match tnm.mutbl {\n+                            ty::TyRef(_, _, mutbl) => {\n+                                match mutbl {\n                                     // Shared borrowed data is never mutable\n                                     hir::MutImmutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n@@ -2341,13 +2348,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                         (\n                             ProjectionElem::Deref,\n-                            ty::TyRef(\n-                                _,\n-                                ty::TypeAndMut {\n-                                    ty: _,\n-                                    mutbl: hir::MutImmutable,\n-                                },\n-                            ),\n+                            ty::TyRef( _, _, hir::MutImmutable),\n                             _,\n                         ) => {\n                             // the borrow goes through a dereference of a shared reference."}, {"sha": "4f87a2b30ae843bae1587d3a75e91631edc5ffb0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -20,7 +20,7 @@ use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n \n use super::region_infer::{Cause, RegionInferenceContext};\n use super::ToRegionVid;\n@@ -97,6 +97,13 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_ty(ty);\n     }\n \n+    /// We sometimes have `generator_substs` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_generator_substs(&mut self, substs: &GeneratorSubsts<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.super_generator_substs(substs);\n+    }\n+\n     /// We sometimes have `closure_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n@@ -263,7 +270,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n-                        ty::TyRef(ref_region, ty::TypeAndMut { ty: _, mutbl }) => {\n+                        ty::TyRef(ref_region, _, mutbl) => {\n                             let span = self.mir.source_info(location).span;\n                             self.regioncx.add_outlives(\n                                 span,"}, {"sha": "fbff17e58985594bf59517d797bb6c225623934e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/annotation.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -30,12 +30,11 @@ impl<'gcx, 'tcx> RegionInferenceContext<'tcx> {\n                     &substs.substs[..]\n                 ));\n             }\n-            DefiningTy::Generator(def_id, substs, interior) => {\n+            DefiningTy::Generator(def_id, substs, _) => {\n                 err.note(&format!(\n-                    \"defining type: {:?} with closure substs {:#?} and interior {:?}\",\n+                    \"defining type: {:?} with generator substs {:#?}\",\n                     def_id,\n-                    &substs.substs[..],\n-                    interior\n+                    &substs.substs[..]\n                 ));\n             }\n             DefiningTy::FnDef(def_id, substs) => {"}, {"sha": "7edee42b78ff71eab23c338d74ffc0a662a082a9", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorInterior, Ty, TypeFoldable};\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n@@ -90,19 +90,19 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         *constant = self.renumber_regions(ty_context, &*constant);\n     }\n \n-    fn visit_generator_interior(&mut self,\n-                                interior: &mut GeneratorInterior<'tcx>,\n-                                location: Location) {\n+    fn visit_generator_substs(&mut self,\n+                              substs: &mut GeneratorSubsts<'tcx>,\n+                              location: Location) {\n         debug!(\n-            \"visit_generator_interior(interior={:?}, location={:?})\",\n-            interior,\n+            \"visit_generator_substs(substs={:?}, location={:?})\",\n+            substs,\n             location,\n         );\n \n         let ty_context = TyContext::Location(location);\n-        *interior = self.renumber_regions(ty_context, interior);\n+        *substs = self.renumber_regions(ty_context, substs);\n \n-        debug!(\"visit_generator_interior: interior={:?}\", interior);\n+        debug!(\"visit_generator_substs: substs={:?}\", substs);\n     }\n \n     fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {"}, {"sha": "52ebf38c668c229c6c5f48ba6d7775ecae1366bc", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -22,13 +22,13 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n-use rustc::hir::{BodyOwnerKind, HirId};\n+use rustc::hir::{self, BodyOwnerKind, HirId};\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::outlives::bounds::{self, OutlivesBound};\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n-use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt, ClosureSubsts, GeneratorSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::FxHashMap;\n@@ -116,7 +116,7 @@ pub enum DefiningTy<'tcx> {\n     /// The MIR is a generator. The signature is that generators take\n     /// no parameters and return the result of\n     /// `ClosureSubsts::generator_return_ty`.\n-    Generator(DefId, ty::ClosureSubsts<'tcx>, ty::GeneratorInterior<'tcx>),\n+    Generator(DefId, ty::GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n     /// The MIR is a fn item with the given def-id and substs. The signature\n     /// of the function can be bound then with the `fn_sig` query.\n@@ -509,7 +509,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n \n         let yield_ty = match defining_ty {\n             DefiningTy::Generator(def_id, substs, _) => {\n-                Some(substs.generator_yield_ty(def_id, self.infcx.tcx))\n+                Some(substs.yield_ty(def_id, self.infcx.tcx))\n             }\n             _ => None,\n         };\n@@ -550,8 +550,8 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n \n                 match defining_ty.sty  {\n                     ty::TyClosure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n-                    ty::TyGenerator(def_id, substs, interior) => {\n-                        DefiningTy::Generator(def_id, substs, interior)\n+                    ty::TyGenerator(def_id, substs, movability) => {\n+                        DefiningTy::Generator(def_id, substs, movability)\n                     }\n                     ty::TyFnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n                     _ => span_bug!(\n@@ -587,17 +587,18 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n         let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, substs) | DefiningTy::Generator(_, substs, _) => {\n+            DefiningTy::Closure(_, ClosureSubsts { ref substs }) |\n+            DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `closure_base_def_id`.\n                 // Therefore, when we zip together (below) with\n                 // `identity_substs`, we will get only those regions\n                 // that correspond to early-bound regions declared on\n                 // the `closure_base_def_id`.\n-                assert!(substs.substs.len() >= identity_substs.len());\n-                assert_eq!(substs.substs.regions().count(), identity_substs.regions().count());\n-                substs.substs\n+                assert!(substs.len() >= identity_substs.len());\n+                assert_eq!(substs.regions().count(), identity_substs.regions().count());\n+                substs\n             }\n \n             DefiningTy::FnDef(_, substs) | DefiningTy::Const(_, substs) => substs,\n@@ -648,10 +649,10 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                 )\n             }\n \n-            DefiningTy::Generator(def_id, substs, interior) => {\n+            DefiningTy::Generator(def_id, substs, movability) => {\n                 assert_eq!(self.mir_def_id, def_id);\n-                let output = substs.generator_return_ty(def_id, tcx);\n-                let generator_ty = tcx.mk_generator(def_id, substs, interior);\n+                let output = substs.return_ty(def_id, tcx);\n+                let generator_ty = tcx.mk_generator(def_id, substs, movability);\n                 let inputs_and_output = self.infcx.tcx.intern_type_list(&[generator_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)\n             }"}, {"sha": "dee78341265bf536ba7500b536c762b334c4edc9", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -156,10 +156,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n                 ty::TyRawPtr(_) |\n                 ty::TyRef(\n                     _, /*rgn*/\n-                    ty::TypeAndMut {\n-                        ty: _,\n-                            mutbl: hir::MutImmutable,\n-                        },\n+                    _, /*ty*/\n+                    hir::MutImmutable\n                     ) => {\n                     // don't continue traversing over derefs of raw pointers or shared borrows.\n                     self.next = None;\n@@ -168,10 +166,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n                 ty::TyRef(\n                     _, /*rgn*/\n-                    ty::TypeAndMut {\n-                        ty: _,\n-                        mutbl: hir::MutMutable,\n-                    },\n+                    _, /*ty*/\n+                    hir::MutMutable,\n                     ) => {\n                     self.next = Some(&proj.base);\n                     return Some(cursor);"}, {"sha": "648746b6e9047d9e21978a1940990ff77c0a9187", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -18,7 +18,7 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, UpvarSubsts};\n use rustc::mir::*;\n use rustc::mir::interpret::{Value, PrimVal, EvalErrorKind};\n use syntax_pos::Span;\n@@ -185,27 +185,32 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars, interior } => { // see (*) above\n+            ExprKind::Closure { closure_id, substs, upvars, movability } => {\n+                // see (*) above\n                 let mut operands: Vec<_> =\n                     upvars.into_iter()\n                           .map(|upvar| unpack!(block = this.as_operand(block, scope, upvar)))\n                           .collect();\n-                let result = if let Some(interior) = interior {\n-                    // Add the state operand since it follows the upvars in the generator\n-                    // struct. See librustc_mir/transform/generator.rs for more details.\n-                    operands.push(Operand::Constant(box Constant {\n-                        span: expr_span,\n-                        ty: this.hir.tcx().types.u32,\n-                        literal: Literal::Value {\n-                            value: this.hir.tcx().mk_const(ty::Const {\n-                                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n-                                ty: this.hir.tcx().types.u32\n-                            }),\n-                        },\n-                    }));\n-                    box AggregateKind::Generator(closure_id, substs, interior)\n-                } else {\n-                    box AggregateKind::Closure(closure_id, substs)\n+                let result = match substs {\n+                    UpvarSubsts::Generator(substs) => {\n+                        let movability = movability.unwrap();\n+                        // Add the state operand since it follows the upvars in the generator\n+                        // struct. See librustc_mir/transform/generator.rs for more details.\n+                        operands.push(Operand::Constant(box Constant {\n+                            span: expr_span,\n+                            ty: this.hir.tcx().types.u32,\n+                            literal: Literal::Value {\n+                                value: this.hir.tcx().mk_const(ty::Const {\n+                                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n+                                    ty: this.hir.tcx().types.u32\n+                                }),\n+                            },\n+                        }));\n+                        box AggregateKind::Generator(closure_id, substs, movability)\n+                    }\n+                    UpvarSubsts::Closure(substs) => {\n+                        box AggregateKind::Closure(closure_id, substs)\n+                    }\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))\n             }"}, {"sha": "d6ddfea1f19fb7dfd137360f0dcbd7a700f2b58b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // array, so we can call `<[u8]>::eq` rather than having to find an\n                     // `<[u8; N]>::eq`.\n                     let unsize = |ty: Ty<'tcx>| match ty.sty {\n-                        ty::TyRef(region, tam) => match tam.ty.sty {\n+                        ty::TyRef(region, rty, _) => match rty.sty {\n                             ty::TyArray(inner_ty, n) => Some((region, inner_ty, n)),\n                             _ => None,\n                         },"}, {"sha": "afbcf100b056a010ee21c5e05d37f291dc898a50", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -130,7 +130,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             let (yield_ty, return_ty) = if body.is_generator {\n                 let gen_sig = match ty.sty {\n                     ty::TyGenerator(gen_def_id, gen_substs, ..) =>\n-                        gen_substs.generator_sig(gen_def_id, tcx),\n+                        gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n                         span_bug!(tcx.hir.span(id), \"generator w/o generator type: {:?}\", ty),\n                 };"}, {"sha": "76605a7aa04840a05aac63af6f619f3a5a5883b8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -283,7 +283,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprAddrOf(mutbl, ref expr) => {\n             let region = match expr_ty.sty {\n-                ty::TyRef(r, _) => r,\n+                ty::TyRef(r, _, _) => r,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n             };\n             ExprKind::Borrow {\n@@ -470,9 +470,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprClosure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n-            let (def_id, substs, interior) = match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, substs, None),\n-                ty::TyGenerator(def_id, substs, interior) => (def_id, substs, Some(interior)),\n+            let (def_id, substs, movability) = match closure_ty.sty {\n+                ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n+                ty::TyGenerator(def_id, substs, movability) => {\n+                    (def_id, UpvarSubsts::Generator(substs), Some(movability))\n+                }\n                 _ => {\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n@@ -487,7 +489,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 closure_id: def_id,\n                 substs,\n                 upvars,\n-                interior,\n+                movability,\n             }\n         }\n \n@@ -985,13 +987,13 @@ fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // Reconstruct the output assuming it's a reference with the\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mt) = match recv_ty.sty {\n-        ty::TyRef(region, mt) => (region, mt),\n+    let (region, mutbl) = match recv_ty.sty {\n+        ty::TyRef(region, _, mutbl) => (region, mutbl),\n         _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {\n         ty: place_ty,\n-        mutbl: mt.mutbl,\n+        mutbl,\n     });\n \n     // construct the complete expression `foo()` for the overloaded call,"}, {"sha": "c27250267bbc822091615ac6badeace929dedb76", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, ClosureSubsts, Region, Ty, GeneratorInterior};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty};\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -266,9 +266,9 @@ pub enum ExprKind<'tcx> {\n     },\n     Closure {\n         closure_id: DefId,\n-        substs: ClosureSubsts<'tcx>,\n+        substs: UpvarSubsts<'tcx>,\n         upvars: Vec<ExprRef<'tcx>>,\n-        interior: Option<GeneratorInterior<'tcx>>,\n+        movability: Option<hir::GeneratorMovability>,\n     },\n     Literal {\n         literal: Literal<'tcx>,"}, {"sha": "1245f506955c133a4ebc2f51fc3d44b9850797bb", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -46,13 +46,13 @@ struct LiteralExpander;\n impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         match (&pat.ty.sty, &*pat.kind) {\n-            (&ty::TyRef(_, mt), &PatternKind::Constant { ref value }) => {\n+            (&ty::TyRef(_, rty, _), &PatternKind::Constant { ref value }) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n                     kind: box PatternKind::Deref {\n                         subpattern: Pattern {\n-                            ty: mt.ty,\n+                            ty: rty,\n                             span: pat.span,\n                             kind: box PatternKind::Constant { value: value.clone() },\n                         }\n@@ -907,7 +907,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n-        ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n+        ty::TyRef(_, rty, _) => vec![rty],\n         ty::TyAdt(adt, substs) => {\n             if adt.is_box() {\n                 // Use T as the sub pattern type of Box<T>."}, {"sha": "2585447fa0a04f6cdecfe14bb2777a7a04fb4d31", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -238,9 +238,9 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Deref { ref subpattern } => {\n                 match self.ty.sty {\n                     ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::TyRef(_, mt) => {\n+                    ty::TyRef(_, _, mutbl) => {\n                         write!(f, \"&\")?;\n-                        if mt.mutbl == hir::MutMutable {\n+                        if mutbl == hir::MutMutable {\n                             write!(f, \"mut \")?;\n                         }\n                     }\n@@ -424,13 +424,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n                 let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n-                    ty::TyRef(_, mt) =>\n+                    ty::TyRef(_, ty, _) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n-                                ty: mt.ty,\n+                                ty,\n                                 span: pat.span,\n                                 kind: Box::new(self.slice_or_array_pattern(\n-                                    pat.span, mt.ty, prefix, slice, suffix))\n+                                    pat.span, ty, prefix, slice, suffix))\n                             },\n                         },\n \n@@ -469,7 +469,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Binding(_, id, ref name, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n-                    ty::TyRef(r, _) => Some(r),\n+                    ty::TyRef(r, _, _) => Some(r),\n                     _ => None,\n                 };\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n@@ -490,8 +490,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n                 if let ty::BindByReference(_) = bm {\n-                    if let ty::TyRef(_, mt) = ty.sty {\n-                        ty = mt.ty;\n+                    if let ty::TyRef(_, rty, _) = ty.sty {\n+                        ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", name.node, ty);\n                     }"}, {"sha": "3d670acf98cb2d3f20993f9fc7f8f96268613625", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n use rustc::ty::maps::TyCtxtAt;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::middle::const_val::FrameInfo;\n@@ -778,8 +778,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(super) fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyRawPtr(ref tam) |\n-            ty::TyRef(_, ref tam) => !self.type_is_sized(tam.ty),\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n             ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n             _ => false,\n         }\n@@ -1262,8 +1262,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             ty::TyFnPtr(_) => PrimValKind::FnPtr,\n \n-            ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) if self.type_is_sized(tam.ty) => PrimValKind::Ptr,\n+            ty::TyRef(_, ty, _) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if self.type_is_sized(ty) => {\n+                PrimValKind::Ptr\n+            }\n \n             ty::TyAdt(def, _) if def.is_box() => PrimValKind::Ptr,\n \n@@ -1403,8 +1405,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             ty::TyFnPtr(_) => self.memory.read_ptr_sized(ptr, ptr_align)?,\n-            ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, ptr_align, tam.ty).map(Some),\n+            ty::TyRef(_, rty, _) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: rty, .. }) => {\n+                return self.read_ptr(ptr, ptr_align, rty).map(Some)\n+            }\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n@@ -1504,10 +1508,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         dst_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match (&src_layout.ty.sty, &dst_layout.ty.sty) {\n-            (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n-            (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n-            (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => {\n-                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s.ty, d.ty)\n+            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n+            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n+            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n+             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n+                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s, d)\n             }\n             (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);"}, {"sha": "b5a06286e4eed18430d12f9460043b0ecd27d4aa", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -369,8 +369,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let val = self.read_place(base)?;\n \n                 let pointee_type = match base_ty.sty {\n-                    ty::TyRawPtr(ref tam) |\n-                    ty::TyRef(_, ref tam) => tam.ty,\n+                    ty::TyRawPtr(ref tam) => tam.ty,\n+                    ty::TyRef(_, ty, _) => ty,\n                     ty::TyAdt(def, _) if def.is_box() => base_ty.boxed_ty(),\n                     _ => bug!(\"can only deref pointer types\"),\n                 };"}, {"sha": "c61487f106b66f272f2440ea367a63cfb4e9da91", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // mutability of raw pointers.\n                 // TODO: Should not be allowed when fat pointers are involved.\n                 (&ty::TyRawPtr(_), &ty::TyRawPtr(_)) => true,\n-                (&ty::TyRef(_, _), &ty::TyRef(_, _)) => {\n+                (&ty::TyRef(_, _, _), &ty::TyRef(_, _, _)) => {\n                     ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n                 }\n                 // rule out everything else"}, {"sha": "e051b848c011fe21a193cfc193fbf88719413b34", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -844,9 +844,9 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     match (&source_ty.sty, &target_ty.sty) {\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+        (&ty::TyRef(_, a, _),\n+         &ty::TyRef(_, b, _)) |\n+        (&ty::TyRef(_, a, _),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {"}, {"sha": "176ed8c5bca745c53e4c8f0cf2c7f80f9ba86bd7", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -18,7 +18,7 @@ use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::OptLevel;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, ClosureSubsts, GeneratorSubsts};\n use rustc::ty::subst::Substs;\n use syntax::ast;\n use syntax::attr::InlineAttr;\n@@ -302,7 +302,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 self.push_type_name(inner_type, output);\n             },\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+            ty::TyRef(_, inner_type, mutbl) => {\n                 output.push('&');\n                 if mutbl == hir::MutMutable {\n                     output.push_str(\"mut \");\n@@ -376,11 +376,11 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     self.push_type_name(sig.output(), output);\n                 }\n             },\n-            ty::TyGenerator(def_id, ref closure_substs, _) |\n-            ty::TyClosure(def_id, ref closure_substs) => {\n+            ty::TyGenerator(def_id, GeneratorSubsts { ref substs }, _) |\n+            ty::TyClosure(def_id, ClosureSubsts { ref substs }) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n-                let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n+                let substs = substs.truncate_to(self.tcx, generics);\n                 self.push_type_params(substs, iter::empty(), output);\n             }\n             ty::TyError |"}, {"sha": "04d4f7a3968eeace512f7f4af04e29a530340925", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -84,8 +84,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n         .unwrap().def_id;\n     let def = ty::InstanceDef::ClosureOnceShim { call_once };\n \n-    let self_ty = tcx.mk_closure_from_closure_substs(\n-        closure_did, substs);\n+    let self_ty = tcx.mk_closure(closure_did, substs);\n \n     let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);"}, {"sha": "584887d03738fe27d8812fc7a3c5f9bdc81fefdc", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -44,14 +44,14 @@ fn place_context<'a, 'tcx, D>(\n                     // A Deref projection may restrict the context, this depends on the type\n                     // being deref'd.\n                     let context = match ty.sty {\n-                        ty::TyRef(re, tam) => {\n+                        ty::TyRef(re, _, mutbl) => {\n                             let re = match re {\n                                 &RegionKind::ReScope(ce) => Some(ce),\n                                 &RegionKind::ReErased =>\n                                     bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n                                 _ => None\n                             };\n-                            (re, tam.mutbl)\n+                            (re, mutbl)\n                         }\n                         ty::TyRawPtr(_) =>\n                             // There is no guarantee behind even a mutable raw pointer,"}, {"sha": "cd5ebae2d9dfd375139378b93de2bd2b1cb52f53", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -54,12 +54,6 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n         *substs = self.tcx.erase_regions(substs);\n     }\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &mut ty::ClosureSubsts<'tcx>,\n-                            _: Location) {\n-        *substs = self.tcx.erase_regions(substs);\n-    }\n-\n     fn visit_statement(&mut self,\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,"}, {"sha": "c4e700cdd1f41aa2d62c720dc0a2d0ef5b2f9a72", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -64,7 +64,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, LivenessMode};\n@@ -464,7 +464,8 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource,\n                             upvars: Vec<Ty<'tcx>>,\n-                            interior: GeneratorInterior<'tcx>,\n+                            interior: Ty<'tcx>,\n+                            movable: bool,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n@@ -474,11 +475,11 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,\n                                                                             mir,\n                                                                             source,\n-                                                                            interior.movable);\n+                                                                            movable);\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n     let allowed_upvars = tcx.erase_regions(&upvars);\n-    let allowed = match interior.witness.sty {\n+    let allowed = match interior.sty {\n         ty::TyGeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => bug!(),\n     };\n@@ -853,9 +854,11 @@ impl MirPass for StateTransform {\n         let gen_ty = mir.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n-        let (upvars, interior) = match gen_ty.sty {\n-            ty::TyGenerator(_, substs, interior) => {\n-                (substs.upvar_tys(def_id, tcx).collect(), interior)\n+        let (upvars, interior, movable) = match gen_ty.sty {\n+            ty::TyGenerator(_, substs, movability) => {\n+                (substs.upvar_tys(def_id, tcx).collect(),\n+                 substs.witness(def_id, tcx),\n+                 movability == hir::GeneratorMovability::Movable)\n             }\n             _ => bug!(),\n         };\n@@ -874,7 +877,13 @@ impl MirPass for StateTransform {\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n-        let (remap, layout, storage_liveness) = compute_layout(tcx, source, upvars, interior, mir);\n+        let (remap, layout, storage_liveness) = compute_layout(\n+            tcx,\n+            source,\n+            upvars,\n+            interior,\n+            movable,\n+            mir);\n \n         let state_field = mir.upvar_decls.len();\n "}, {"sha": "a641cf3d93ecfeff5dab38d05389ee2c448a5761", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -780,7 +780,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.place_ty(self.place);\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) |\n+            ty::TyClosure(def_id, substs) => {\n+                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n+                self.open_drop_for_tuple(&tys)\n+            }\n             // Note that `elaborate_drops` only drops the upvars of a generator,\n             // and this is ok because `open_drop` here can only be reached\n             // within that own generator's resume function."}, {"sha": "71012ca6d5f7992045124a4af6997ed39a65351d", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -418,11 +418,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n                     self.push(&format!(\"+ substs: {:#?}\", substs));\n                 }\n \n-                AggregateKind::Generator(def_id, substs, interior) => {\n+                AggregateKind::Generator(def_id, substs, movability) => {\n                     self.push(&format!(\"generator\"));\n                     self.push(&format!(\"+ def_id: {:?}\", def_id));\n                     self.push(&format!(\"+ substs: {:#?}\", substs));\n-                    self.push(&format!(\"+ interior: {:?}\", interior));\n+                    self.push(&format!(\"+ movability: {:?}\", movability));\n                 }\n \n                 _ => {}"}, {"sha": "ce5707276ee1a543a73b96483fd453abec3c5740", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -193,7 +193,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n-        ty::TyGenerator(def_id, substs, _interior) => {\n+        ty::TyGenerator(def_id, substs, _movability) => {\n             // rust-lang/rust#49918: types can be constructed, stored\n             // in the interior, and sit idle when generator yields\n             // (and is subsequently dropped)."}, {"sha": "33dc9b3b7ab90087caf3291f7c1ae6aabe53115d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -228,9 +228,9 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n ) -> (ValueRef, ValueRef) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+        (&ty::TyRef(_, a, _),\n+         &ty::TyRef(_, b, _)) |\n+        (&ty::TyRef(_, a, _),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {"}, {"sha": "75b56be3c162aa20a4e983eef4e8f291e85a936c", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -423,7 +423,7 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n             let tcx = cx.tcx;\n-            let sig = substs.generator_poly_sig(def_id, cx.tcx);\n+            let sig = substs.poly_sig(def_id, cx.tcx);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);"}, {"sha": "ae23b523cbfaebcb68fa9dc4e56e44a2a5d2a297", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -555,7 +555,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             false)\n         }\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) => {\n+        ty::TyRef(_, ty, _) => {\n             match ptr_metadata(ty) {\n                 Ok(res) => res,\n                 Err(metadata) => return metadata,\n@@ -591,7 +591,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyGenerator(def_id, substs, _) => {\n+        ty::TyGenerator(def_id, substs,  _) => {\n             let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();"}, {"sha": "565a9bedef0f51d724bf78e044bcb1e7c66891b0", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -80,7 +80,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('*');\n             }\n         },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+        ty::TyRef(_, inner_type, mutbl) => {\n             if !cpp_like_names {\n                 output.push('&');\n             }"}, {"sha": "8ea0983075dc403212b49619bd703ceed78660c2", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -12,7 +12,7 @@ use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n@@ -571,15 +571,17 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n-                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bx.cx.layout_of(mt.ty), true),\n+                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+                ty::TyRef(_, ty, _)  => (bx.cx.layout_of(ty), true),\n                 _ => (arg.layout, false)\n             };\n \n-            let upvar_tys = match closure_layout.ty.sty {\n-                ty::TyClosure(def_id, substs) |\n-                ty::TyGenerator(def_id, substs, _) => substs.upvar_tys(def_id, tcx),\n+            let (def_id, upvar_substs) = match closure_layout.ty.sty {\n+                ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+                ty::TyGenerator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n                 _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n+            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n \n             // Store the pointer to closure data in an alloca for debuginfo\n             // because that's what the llvm.dbg.declare intrinsic expects.\n@@ -614,8 +616,8 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 // a pointer in an alloca for debuginfo atm.\n                 let mut ops = if env_ref || true { &ops[..] } else { &ops[1..] };\n \n-                let ty = if let (true, &ty::TyRef(_, mt)) = (decl.by_ref, &ty.sty) {\n-                    mt.ty\n+                let ty = if let (true, &ty::TyRef(_, ty, _)) = (decl.by_ref, &ty.sty) {\n+                    ty\n                 } else {\n                     ops = &ops[..ops.len() - 1];\n                     ty"}, {"sha": "f736e81202a38c92b32df094c1991599fe74b711", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -250,7 +250,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n-                ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                ty::TyRef(_, ty, _) |\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                     cx.layout_of(ty).llvm_type(cx).ptr_to()\n                 }\n@@ -418,11 +418,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 });\n             }\n \n-            ty::TyRef(_, mt) if offset.bytes() == 0 => {\n-                let (size, align) = cx.size_and_align_of(mt.ty);\n+            ty::TyRef(_, ty, mt) if offset.bytes() == 0 => {\n+                let (size, align) = cx.size_and_align_of(ty);\n \n-                let kind = match mt.mutbl {\n-                    hir::MutImmutable => if cx.type_is_freeze(mt.ty) {\n+                let kind = match mt {\n+                    hir::MutImmutable => if cx.type_is_freeze(ty) {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared"}, {"sha": "c7585c827ce11eaf92b0f0cbf59cd5ec1b0ec7a3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -84,9 +84,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expected = loop {\n                 debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n                 match exp_ty.sty {\n-                    ty::TypeVariants::TyRef(_, ty::TypeAndMut{\n-                        ty: inner_ty, mutbl: inner_mutability,\n-                    }) => {\n+                    ty::TypeVariants::TyRef(_, inner_ty, inner_mutability) => {\n                         debug!(\"current discriminant is TyRef, inserting implicit deref\");\n                         // Preserve the reference type. We'll need it later during HAIR lowering.\n                         pat_adjustments.push(exp_ty);\n@@ -152,8 +150,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let hir::ExprLit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::TyRef(_, mt) = expected_ty.sty {\n-                            if let ty::TySlice(_) = mt.ty.sty {\n+                        if let ty::TyRef(_, r_ty, _) = expected_ty.sty {\n+                            if let ty::TySlice(_) = r_ty.sty {\n                                 pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n                                                          tcx.mk_slice(tcx.types.u8))\n                             }\n@@ -334,8 +332,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // hack detailed in (*) below.\n                     debug!(\"check_pat_walk: expected={:?}\", expected);\n                     let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n-                            (expected, mt.ty)\n+                        ty::TyRef(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n+                            (expected, r_ty)\n                         }\n                         _ => {\n                             let inner_ty = self.next_ty_var(\n@@ -408,7 +406,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 tcx.sess, pat.span, E0529,\n                                 \"expected an array or slice, found `{}`\",\n                                 expected_ty);\n-                            if let ty::TyRef(_, ty::TypeAndMut { mutbl: _, ty }) = expected_ty.sty {\n+                            if let ty::TyRef(_, ty, _) = expected_ty.sty {\n                                 match ty.sty {\n                                     ty::TyArray(..) | ty::TySlice(..) => {\n                                         err.help(\"the semantics of slice patterns changed \\"}, {"sha": "e1ce6073ce43698e0947d77b9be65e7dcc8bb9d8", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -177,10 +177,10 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 self.fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n-                        if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                        if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n                             Some(OverloadedDeref {\n                                 region,\n-                                mutbl: mt.mutbl,\n+                                mutbl,\n                             })\n                         } else {\n                             None"}, {"sha": "b0f9a4c8b85adee737418d841f3b118a29c6d69c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -175,8 +175,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let method = self.register_infer_ok_obligations(ok);\n                     let mut autoref = None;\n                     if borrow {\n-                        if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                            let mutbl = match mt.mutbl {\n+                        if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                            let mutbl = match mutbl {\n                                 hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                 hir::MutMutable => AutoBorrowMutability::Mutable {\n                                     // For initial two-phase borrow"}, {"sha": "f0d7ca8ebf14f6c5ee29d6a15b5c1437fff3b57a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -46,7 +46,7 @@ use lint;\n use rustc::hir;\n use rustc::session::Session;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable, TypeAndMut};\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::subst::Substs;\n@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                          fcx.resolve_type_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n-            ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n+            ty::TyRef(_, _, mt) => {\n                 let mtstr = match mt {\n                     hir::MutMutable => \"mut \",\n                     hir::MutImmutable => \"\",\n@@ -511,8 +511,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_ptr_cast(&self,\n                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                          m_expr: &'tcx ty::TypeAndMut<'tcx>,\n-                          m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                          m_expr: ty::TypeAndMut<'tcx>,\n+                          m_cast: ty::TypeAndMut<'tcx>)\n                           -> Result<CastKind, CastError> {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\", m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n@@ -552,7 +552,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_fptr_ptr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                           m_cast: ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // fptr-ptr cast. must be to thin ptr\n \n@@ -565,7 +565,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_addr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_expr: &'tcx ty::TypeAndMut<'tcx>)\n+                           m_expr: ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // ptr-addr cast. must be from thin ptr\n \n@@ -578,8 +578,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_ref_cast(&self,\n                       fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                      m_expr: &'tcx ty::TypeAndMut<'tcx>,\n-                      m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                      m_expr: ty::TypeAndMut<'tcx>,\n+                      m_cast: ty::TypeAndMut<'tcx>)\n                       -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n@@ -603,7 +603,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_addr_ptr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                           m_cast: TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // ptr-addr cast. pointer must be thin.\n         match fcx.pointer_kind(m_cast.ty, self.span)? {"}, {"sha": "94ef040d80a4f81e58180b0ef3861cdbb37f7353", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -113,23 +113,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n             },\n         );\n-        let substs = ty::ClosureSubsts { substs };\n-        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n-\n-        if let Some(GeneratorTypes { yield_ty, interior }) = generator_types {\n+        if let Some(GeneratorTypes { yield_ty, interior, movability }) = generator_types {\n+            let substs = ty::GeneratorSubsts { substs };\n             self.demand_eqtype(\n                 expr.span,\n                 yield_ty,\n-                substs.generator_yield_ty(expr_def_id, self.tcx),\n+                substs.yield_ty(expr_def_id, self.tcx),\n             );\n             self.demand_eqtype(\n                 expr.span,\n                 liberated_sig.output(),\n-                substs.generator_return_ty(expr_def_id, self.tcx),\n+                substs.return_ty(expr_def_id, self.tcx),\n             );\n-            return self.tcx.mk_generator(expr_def_id, substs, interior);\n+            self.demand_eqtype(\n+                expr.span,\n+                interior,\n+                substs.witness(expr_def_id, self.tcx),\n+            );\n+            return self.tcx.mk_generator(expr_def_id, substs, movability);\n         }\n \n+        let substs = ty::ClosureSubsts { substs };\n+        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n+\n         debug!(\n             \"check_closure: expr.id={:?} closure_type={:?}\",\n             expr.id, closure_type"}, {"sha": "c1ef916e27db3130204e7090ce92e89eacaca698", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -214,7 +214,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n \n-            ty::TyRef(r_b, mt_b) => {\n+            ty::TyRef(r_b, ty, mutbl) => {\n+                let mt_b = ty::TypeAndMut { ty, mutbl };\n                 return self.coerce_borrowed_pointer(a, b, r_b, mt_b);\n             }\n \n@@ -266,7 +267,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // yield.\n \n         let (r_a, mt_a) = match a.sty {\n-            ty::TyRef(r_a, mt_a) => {\n+            ty::TyRef(r_a, ty, mutbl) => {\n+                let mt_a = ty::TypeAndMut { ty, mutbl };\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n@@ -427,7 +429,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n-            ty::TyRef(r_borrow, _) => r_borrow,\n+            ty::TyRef(r_borrow, _, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n@@ -471,12 +473,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n         let reborrow = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n-                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n+            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRef(_, _, mutbl_b)) => {\n+                coerce_mutbls(mutbl_a, mutbl_b)?;\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                let mutbl = match mt_b.mutbl {\n+                let mutbl = match mutbl_b {\n                     hir::MutImmutable => AutoBorrowMutability::Immutable,\n                     hir::MutMutable => AutoBorrowMutability::Mutable {\n                         // We don't allow two-phase borrows here, at least for initial\n@@ -487,26 +489,26 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 };\n                 Some((Adjustment {\n                     kind: Adjust::Deref(None),\n-                    target: mt_a.ty\n+                    target: ty_a\n                 }, Adjustment {\n                     kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n                     target:  self.tcx.mk_ref(r_borrow, ty::TypeAndMut {\n-                        mutbl: mt_b.mutbl,\n-                        ty: mt_a.ty\n+                        mutbl: mutbl_b,\n+                        ty: ty_a\n                     })\n                 }))\n             }\n-            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n-                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n+            (&ty::TyRef(_, ty_a, mt_a), &ty::TyRawPtr(ty::TypeAndMut { mutbl: mt_b, .. })) => {\n+                coerce_mutbls(mt_a, mt_b)?;\n \n                 Some((Adjustment {\n                     kind: Adjust::Deref(None),\n-                    target: mt_a.ty\n+                    target: ty_a\n                 }, Adjustment {\n-                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mt_b.mutbl)),\n+                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mt_b)),\n                     target:  self.tcx.mk_ptr(ty::TypeAndMut {\n-                        mutbl: mt_b.mutbl,\n-                        ty: mt_a.ty\n+                        mutbl: mt_b,\n+                        ty: ty_a\n                     })\n                 }))\n             }\n@@ -719,7 +721,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n         let (is_ref, mt_a) = match a.sty {\n-            ty::TyRef(_, mt) => (true, mt),\n+            ty::TyRef(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n                 return self.unify_and(a, b, identity);\n@@ -886,12 +888,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n                     match self.node_ty(expr.hir_id).sty {\n-                        ty::TyRef(_, mt_orig) => {\n+                        ty::TyRef(_, _, mt_orig) => {\n                             let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref\n                             // which will be merged into it.\n-                            mutbl_adj == mt_orig.mutbl\n+                            mutbl_adj == mt_orig\n                         }\n                         _ => false,\n                     }"}, {"sha": "06d854c15fe5beb7ad842d42079016d1e74babf5", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  expected: Ty<'tcx>)\n                  -> Option<(&'static str, String)> {\n         match (&expected.sty, &checked_ty.sty) {\n-            (&ty::TyRef(_, exp), &ty::TyRef(_, check)) => match (&exp.ty.sty, &check.ty.sty) {\n+            (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::TyStr, &ty::TyArray(arr, _)) |\n                 (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprLit(_) = expr.node {\n@@ -241,7 +241,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 _ => None,\n             },\n-            (&ty::TyRef(_, mutability), _) => {\n+            (&ty::TyRef(_, _, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //\n                 // ```\n@@ -250,7 +250,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // let x = 0u32;\n                 // bar(&x); // error, expected &mut\n                 // ```\n-                let ref_ty = match mutability.mutbl {\n+                let ref_ty = match mutability {\n                     hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n                                                        self.tcx.mk_region(ty::ReStatic),\n                                                        checked_ty),\n@@ -266,7 +266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::ExprCast(_, _) | hir::ExprBinary(_, _, _) => format!(\"({})\", src),\n                             _ => src,\n                         };\n-                        return Some(match mutability.mutbl {\n+                        return Some(match mutability {\n                             hir::Mutability::MutMutable => {\n                                 (\"consider mutably borrowing here\", format!(\"&mut {}\", sugg_expr))\n                             }\n@@ -278,15 +278,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 None\n             }\n-            (_, &ty::TyRef(_, checked)) => {\n+            (_, &ty::TyRef(_, checked, _)) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest adding a `*`, or removing\n                 // a `&`.\n                 //\n                 // (But, also check check the `expn_info()` to see if this is\n                 // a macro; if so, it's hard to extract the text and make a good\n                 // suggestion, so don't bother.)\n-                if self.infcx.can_sub(self.param_env, checked.ty, &expected).is_ok() &&\n+                if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() &&\n                    expr.span.ctxt().outer().expn_info().is_none() {\n                     match expr.node {\n                         // Maybe remove `&`?\n@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // Maybe add `*`? Only if `T: Copy`.\n                         _ => {\n                             if !self.infcx.type_moves_by_default(self.param_env,\n-                                                                checked.ty,\n+                                                                checked,\n                                                                 expr.span) {\n                                 let sp = self.sess().codemap().call_span_if_macro(expr.span);\n                                 if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(sp) {"}, {"sha": "b3d2a09a72cc714b69b23acdedafe22935af35cb", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Pat, PatKind, Expr};\n use rustc::middle::region;\n-use rustc::ty::{self, Ty, GeneratorInterior};\n+use rustc::ty::{self, Ty};\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::Span;\n use super::FnCtxt;\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                                         def_id: DefId,\n                                         body_id: hir::BodyId,\n-                                        interior: GeneratorInterior<'tcx>) {\n+                                        interior: Ty<'tcx>) {\n     let body = fcx.tcx.hir.body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n@@ -135,7 +135,7 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n             witness, body.value.span);\n \n     // Unify the type variable inside the generator with the new witness\n-    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(interior.witness, witness) {\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(interior, witness) {\n         Ok(ok) => fcx.register_infer_ok_obligations(ok),\n         _ => bug!(),\n     }"}, {"sha": "46288181037f49d596968d4bfa0b29736ec15b99", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -462,10 +462,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n                         if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                            if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n                                 *deref = OverloadedDeref {\n                                     region,\n-                                    mutbl: mt.mutbl\n+                                    mutbl,\n                                 };\n                             }\n                         }\n@@ -521,8 +521,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n-        let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n-            (r, mt.mutbl)\n+        let (region, mutbl) = if let ty::TyRef(r, _, mutbl) = method.sig.inputs()[0].sty {\n+            (r, mutbl)\n         } else {\n             span_bug!(expr.span, \"input to place op is not a ref?\");\n         };"}, {"sha": "e45565c2f52203783f1389b2a79d11f21d6f1869", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -917,9 +917,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::TyRef(_, mt) = step.self_ty.sty {\n+                if let ty::TyRef(_, _, mutbl) = step.self_ty.sty {\n                     pick.autoderefs += 1;\n-                    pick.autoref = Some(mt.mutbl);\n+                    pick.autoref = Some(mutbl);\n                 }\n \n                 pick"}, {"sha": "ef14fa9a12248eb5a49d189eda474601d617e778", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -208,7 +208,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n-    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, ty::GeneratorInterior<'tcx>)>>,\n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n \n     // Anonymized types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n@@ -1009,7 +1009,10 @@ struct GeneratorTypes<'tcx> {\n     yield_ty: ty::Ty<'tcx>,\n \n     /// Types that are captured (see `GeneratorInterior` for more).\n-    interior: ty::GeneratorInterior<'tcx>\n+    interior: ty::Ty<'tcx>,\n+\n+    /// Indicates if the generator is movable or static (immovable)\n+    movability: hir::GeneratorMovability,\n }\n \n /// Helper used for fns and closures. Does the grungy work of checking a function\n@@ -1084,13 +1087,13 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n     let gen_ty = if can_be_generator.is_some() && body.is_generator {\n-        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n-        let interior = ty::GeneratorInterior {\n-            witness,\n-            movable: can_be_generator.unwrap() == hir::GeneratorMovability::Movable,\n-        };\n+        let interior = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n         fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior));\n-        Some(GeneratorTypes { yield_ty: fcx.yield_ty.unwrap(), interior: interior })\n+        Some(GeneratorTypes {\n+            yield_ty: fcx.yield_ty.unwrap(),\n+            interior,\n+            movability: can_be_generator.unwrap(),\n+        })\n     } else {\n         None\n     };\n@@ -2390,8 +2393,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n \n                 let mut adjustments = autoderef.adjust_steps(needs);\n-                if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                    let mutbl = match mt.mutbl {\n+                if let ty::TyRef(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n+                    let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                         hir::MutMutable => AutoBorrowMutability::Mutable {\n                             // Indexing can be desugared to a method call,\n@@ -2404,7 +2407,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                         target: self.tcx.mk_ref(region, ty::TypeAndMut {\n-                            mutbl: mt.mutbl,\n+                            mutbl: r_mutbl,\n                             ty: adjusted_ty\n                         })\n                     });\n@@ -3612,8 +3615,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         } else if let Some(ok) = self.try_overloaded_deref(\n                                 expr.span, oprnd_t, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                                let mutbl = match mt.mutbl {\n+                            if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                let mutbl = match mutbl {\n                                     hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                     hir::MutMutable => AutoBorrowMutability::Mutable {\n                                         // (It shouldn't actually matter for unary ops whether\n@@ -3657,14 +3660,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                 match ty.sty {\n-                    ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n+                    ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                         if self.is_place_expr(&oprnd) {\n                             // Places may legitimately have unsized types.\n                             // For example, dereferences of a fat pointer and\n                             // the last field of a struct can be unsized.\n-                            ExpectHasType(mt.ty)\n+                            ExpectHasType(ty)\n                         } else {\n-                            Expectation::rvalue_hint(self, mt.ty)\n+                            Expectation::rvalue_hint(self, ty)\n                         }\n                     }\n                     _ => NoExpectation"}, {"sha": "9e8e00594e60afc9074322c7b080ac6c09294f7f", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -197,8 +197,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(method) => {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n-                    if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                        let mutbl = match mt.mutbl {\n+                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n@@ -214,8 +214,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 if by_ref_binop {\n-                    if let ty::TyRef(region, mt) = method.sig.inputs()[1].sty {\n-                        let mutbl = match mt.mutbl {\n+                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[1].sty {\n+                        let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n@@ -262,12 +262,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             op.node.as_str(),\n                             lhs_ty);\n \n-                        if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n+                        if let TypeVariants::TyRef(_, rty, _) = lhs_ty.sty {\n                             if {\n                                 !self.infcx.type_moves_by_default(self.param_env,\n-                                                                  ty_mut.ty,\n+                                                                  rty,\n                                                                   lhs_expr.span) &&\n-                                    self.lookup_op_method(ty_mut.ty,\n+                                    self.lookup_op_method(rty,\n                                                           &[rhs_ty],\n                                                           Op::Binary(op, is_assign))\n                                         .is_ok()\n@@ -341,8 +341,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n         match (&lhs_ty.sty, &rhs_ty.sty) {\n-            (&TyRef(_, ref l_ty), &TyRef(_, ref r_ty))\n-            if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr => {\n+            (&TyRef(_, l_ty, _), &TyRef(_, r_ty, _))\n+            if l_ty.sty == TyStr && r_ty.sty == TyStr => {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate two `&str` strings\");\n                 match codemap.span_to_snippet(lhs_expr.span) {\n@@ -353,8 +353,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 true\n             }\n-            (&TyRef(_, ref l_ty), &TyAdt(..))\n-            if l_ty.ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n+            (&TyRef(_, l_ty, _), &TyAdt(..))\n+            if l_ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate a `&str` with a `String`\");\n                 match codemap.span_to_snippet(lhs_expr.span) {"}, {"sha": "badf5bcb6a9a0d45e7ececfb78b3381171c5593a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n                 let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::TyRef(r_ptr, _) = base_ty.sty {\n+                if let ty::TyRef(r_ptr, _, _) = base_ty.sty {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n@@ -701,11 +701,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                from_ty,\n                to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n-            /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n+            /*From:*/ (&ty::TyRef(from_r, from_ty, _),\n+            /*To:  */  &ty::TyRef(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n-                self.walk_cast(cast_expr, from_mt.ty, to_mt.ty);\n+                self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n             /*From:*/ (_,\n@@ -913,8 +913,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                self.ty_to_string(indexed_ty));\n \n         let r_index_expr = ty::ReScope(region::Scope::Node(index_expr.hir_id.local_id));\n-        if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n-            match mt.ty.sty {\n+        if let ty::TyRef(r_ptr, r_ty, _) = indexed_ty.sty {\n+            match r_ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n                     self.sub_regions(infer::IndexSlice(index_expr.span),\n                                      self.tcx.mk_region(r_index_expr), r_ptr);\n@@ -1086,7 +1086,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::TyRef(r, _) = rptr_ty.sty {\n+        if let ty::TyRef(r, _, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }"}, {"sha": "6bede52b239632cfcbef885ef0f09cfb8a40926c", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -46,7 +46,7 @@ use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -74,11 +74,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, body_id, _, gen) => {\n+            hir::ExprClosure(cc, _, body_id, _, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n                 self.fcx\n-                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc, gen);\n+                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n             }\n \n             _ => {}\n@@ -96,7 +96,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         body: &hir::Body,\n         capture_clause: hir::CaptureClause,\n-        gen: Option<hir::GeneratorMovability>,\n     ) {\n         /*!\n          * Analysis starting point.\n@@ -109,8 +108,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         // Extract the type of the closure.\n-        let (closure_def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n-            ty::TyClosure(def_id, substs) | ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n+        let (closure_def_id, substs) = match self.node_ty(closure_hir_id).sty {\n+            ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+            ty::TyGenerator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n             ref t => {\n                 span_bug!(\n                     span,\n@@ -121,10 +121,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let infer_kind = if gen.is_some() {\n-            false\n+        let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs{\n+            if self.closure_kind(closure_def_id, closure_substs).is_none() {\n+                Some(closure_substs)\n+            } else {\n+                None\n+            }\n         } else {\n-            self.closure_kind(closure_def_id, closure_substs).is_none()\n+            None\n         };\n \n         self.tcx.with_freevars(closure_node_id, |freevars| {\n@@ -172,7 +176,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             &self.tables.borrow(),\n         ).consume_body(body);\n \n-        if infer_kind {\n+        if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n             let inferred_kind = delegate.current_closure_kind;\n@@ -208,14 +212,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Equate the type variables for the upvars with the actual types.\n         let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n         debug!(\n-            \"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n+            \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n             closure_node_id,\n-            closure_substs,\n+            substs,\n             final_upvar_tys\n         );\n-        for (upvar_ty, final_upvar_ty) in closure_substs\n-            .upvar_tys(closure_def_id, self.tcx)\n-            .zip(final_upvar_tys)\n+        for (upvar_ty, final_upvar_ty) in substs.upvar_tys(closure_def_id, self.tcx)\n+                                                .zip(final_upvar_tys)\n         {\n             self.demand_suptype(span, upvar_ty, final_upvar_ty);\n         }"}, {"sha": "57c1d33cb5d2ae608bf7d9dce6b1d4eb73f5d3aa", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -172,7 +172,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             match tables.expr_ty_adjusted(&base).sty {\n                 // All valid indexing looks like this\n-                ty::TyRef(_, ty::TypeAndMut { ty: ref base_ty, .. }) => {\n+                ty::TyRef(_, base_ty, _) => {\n                     let index_ty = tables.expr_ty_adjusted(&index);\n                     let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n "}, {"sha": "3424a31e09df09245058b1315be2b9c54450c6c2", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -223,12 +223,18 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+            (&ty::TyRef(r_a, ty_a, mutbl_a), &ty::TyRef(r_b, ty_b, mutbl_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+                let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n-            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRawPtr(mt_b)) => {\n+                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+            }\n+\n             (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }"}, {"sha": "f0f392a2458e9079389458bfd3aa7239299fb37f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -933,38 +933,36 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) = node {\n-        // add a dummy parameter for the closure kind\n-        types.push(ty::TypeParameterDef {\n-            index: type_start,\n-            name: Symbol::intern(\"<closure_kind>\").as_interned_str(),\n-            def_id,\n-            has_default: false,\n-            object_lifetime_default: rl::Set1::Empty,\n-            pure_wrt_drop: false,\n-            synthetic: None,\n-        });\n-\n-        // add a dummy parameter for the closure signature\n-        types.push(ty::TypeParameterDef {\n-            index: type_start + 1,\n-            name: Symbol::intern(\"<closure_signature>\").as_interned_str(),\n-            def_id,\n-            has_default: false,\n-            object_lifetime_default: rl::Set1::Empty,\n-            pure_wrt_drop: false,\n-            synthetic: None,\n-        });\n+    if let NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) = node {\n+        let dummy_args = if gen.is_some() {\n+            &[\"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n+        } else {\n+            &[\"<closure_kind>\", \"<closure_signature>\"][..]\n+        };\n \n-        tcx.with_freevars(node_id, |fv| {\n-            types.extend(fv.iter().zip(2..).map(|(_, i)| ty::TypeParameterDef {\n-                index: type_start + i,\n-                name: Symbol::intern(\"<upvar>\").as_interned_str(),\n+        for (i, &arg) in dummy_args.iter().enumerate() {\n+            types.push(ty::TypeParameterDef {\n+                index: type_start + i as u32,\n+                name: Symbol::intern(arg).as_interned_str(),\n                 def_id,\n                 has_default: false,\n                 object_lifetime_default: rl::Set1::Empty,\n                 pure_wrt_drop: false,\n                 synthetic: None,\n+            });\n+        }\n+\n+        tcx.with_freevars(node_id, |fv| {\n+            types.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n+                ty::TypeParameterDef {\n+                    index: type_start + i,\n+                    name: Symbol::intern(\"<upvar>\").as_interned_str(),\n+                    def_id,\n+                    has_default: false,\n+                    object_lifetime_default: rl::Set1::Empty,\n+                    pure_wrt_drop: false,\n+                    synthetic: None,\n+                }\n             }));\n         });\n     }"}, {"sha": "5a9539a8badf01ab87a6fbd1756733f39361f0fc", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -149,8 +149,8 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             // a predicate requirement of T: 'a (T outlives 'a).\n             //\n             // We also want to calculate potential predicates for the T\n-            ty::TyRef(region, mt) => {\n-                insert_outlives_predicate(tcx, mt.ty.into(), region, required_predicates);\n+            ty::TyRef(region, rty, _) => {\n+                insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n             }\n \n             // For each TyAdt (struct/enum/union) type `Foo<'a, T>`, we"}, {"sha": "ad7a3051f6402f2d59bace747e33ccdaba857e38", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -272,10 +272,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n-            ty::TyRef(region, ref mt) => {\n+            ty::TyRef(region, ty, mutbl) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, region, contra);\n-                self.add_constraints_from_mt(current, mt, variance);\n+                self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n             ty::TyArray(typ, _) |"}, {"sha": "007938e86ed9d9f37addd9624cd71b897b7c8c1a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a223d139cd26e5bfab23a478a5cad845eaab131/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0a223d139cd26e5bfab23a478a5cad845eaab131", "patch": "@@ -1480,7 +1480,7 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n         for ty_s in trait_ref.input_types().skip(1) {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n-                    if let ty::TyRef(ref reg, _) = ty_s.sty {\n+                    if let ty::TyRef(ref reg, _, _) = ty_s.sty {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n@@ -2231,8 +2231,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n-                    } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n-                        if mt.ty == self_ty {\n+                    } else if let ty::TyRef(_, ty, _) = self_arg_ty.sty {\n+                        if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef{ref mut type_, ..} => {\n                                     **type_ = Generic(String::from(\"Self\"))\n@@ -2786,10 +2786,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 Array(box ty.clean(cx), n)\n             }\n             ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n-            ty::TyRef(r, mt) => BorrowedRef {\n+            ty::TyRef(r, ty, mutbl) => BorrowedRef {\n                 lifetime: r.clean(cx),\n-                mutability: mt.mutbl.clean(cx),\n-                type_: box mt.ty.clean(cx),\n+                mutability: mutbl.clean(cx),\n+                type_: box ty.clean(cx),\n             },\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) => {"}]}