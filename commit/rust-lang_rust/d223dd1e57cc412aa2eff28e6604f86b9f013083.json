{"sha": "d223dd1e57cc412aa2eff28e6604f86b9f013083", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMjNkZDFlNTdjYzQxMmFhMmVmZjI4ZTY2MDRmODZiOWYwMTMwODM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-02-22T05:33:23Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-02-22T05:33:23Z"}, "message": "std: rewrite Hash to make it more generic\n\nThis patch merges IterBytes and Hash traits, which clears up the\nconfusion of using `#[deriving(IterBytes)]` to support hashing.\nInstead, it now is much easier to use the new `#[deriving(Hash)]`\nfor making a type hashable with a stream hash.\n\nFurthermore, it supports custom non-stream-based hashers, such as\nif a value's hash was cached in a database.\n\nThis does not yet replace the old IterBytes-hash with this new\nversion.", "tree": {"sha": "aa8d3f01f77b0a74c024d1632df29d5a95f4724e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa8d3f01f77b0a74c024d1632df29d5a95f4724e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d223dd1e57cc412aa2eff28e6604f86b9f013083", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d223dd1e57cc412aa2eff28e6604f86b9f013083", "html_url": "https://github.com/rust-lang/rust/commit/d223dd1e57cc412aa2eff28e6604f86b9f013083", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d223dd1e57cc412aa2eff28e6604f86b9f013083/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0135b521ad38615e9a07aac54d9c22627af57ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0135b521ad38615e9a07aac54d9c22627af57ca4", "html_url": "https://github.com/rust-lang/rust/commit/0135b521ad38615e9a07aac54d9c22627af57ca4"}], "stats": {"total": 1169, "additions": 1154, "deletions": 15}, "files": [{"sha": "cf895d2b6dee5f47ef66ffd3aad3560023d0316a", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -119,7 +119,8 @@ def write_file(name, string):\n                               ('Clone', [], 1), ('DeepClone', ['Clone'], 1),\n                               ('Eq', [], 2), ('Ord', [], 8),\n                               ('TotalEq', [], 1), ('TotalOrd', ['TotalEq'], 1),\n-                              ('Show', [], 1)]:\n+                              ('Show', [], 1),\n+                              ('Hash', [], 1)]:\n     traits[trait] = (ALL, supers, errs)\n \n for (trait, (types, super_traits, error_count)) in traits.items():"}, {"sha": "6738275c4c1f1673fdc1886c381f87d5a387a400", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -11,6 +11,7 @@\n #[allow(missing_doc)];\n \n use std::cmp;\n+use std::hash_old::Hash;\n use std::hashmap;\n use std::io;\n use std::mem;"}, {"sha": "88aff133fb069d05f1c9a8a43bf20ce9fd11c6ca", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -27,6 +27,7 @@ use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n use std::u64;\n+use std::hash_old::Hash;\n use std::io;\n use std::io::extensions::u64_from_be_bytes;\n use std::option;"}, {"sha": "7b7f45b2d2d493f2e37ead0a2e5d54eb928777a1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -26,6 +26,7 @@ use middle;\n use serialize::Encodable;\n use std::cast;\n use std::cell::{Cell, RefCell};\n+use std::hash_old::Hash;\n use std::hashmap::{HashMap, HashSet};\n use std::io::MemWriter;\n use std::str;"}, {"sha": "f47c2f84e99c0f6c3a56321bdd2d0b9caf0743cc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -4916,7 +4916,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n-    use std::hash::{SipState, Streaming};\n+    use std::hash_old::{SipState, Streaming};\n \n     let mut hash = SipState::new(0, 0);\n     let region = |_hash: &mut SipState, r: Region| {"}, {"sha": "f350bb0761f7fd7d9d145b3cf058f2e8bdfc2eab", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -14,6 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::hash_old::Hash;\n use std::hashmap::{HashMap, HashSet};\n use std::rc::Rc;\n use std::trie::{TrieMap, TrieSet};"}, {"sha": "ac079cb3fb33567ff1805ad8205015f99166ff7d", "filename": "src/libstd/hash/mod.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,369 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Generic hashing support.\n+ *\n+ * This module provides a generic way to compute the hash of a value. The\n+ * simplest way to make a type hashable is to use `#[deriving(Hash)]`:\n+ *\n+ * # Example\n+ *\n+ * ```rust\n+ * use std::hash;\n+ * use std::hash::Hash;\n+ *\n+ * #[deriving(Hash)]\n+ * struct Person {\n+ *     id: uint,\n+ *     name: ~str,\n+ *     phone: uint,\n+ * }\n+ *\n+ * let person1 = Person { id: 5, name: ~\"Janet\", phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: ~\"Bob\", phone: 555_666_7777 };\n+ *\n+ * assert!(hash::hash(&person1) != hash::hash(&person2));\n+ * ```\n+ *\n+ * If you need more control over how a value is hashed, you need to implement\n+ * the trait `Hash`:\n+ *\n+ * ```rust\n+ * use std::hash;\n+ * use std::hash::Hash;\n+ * use std::hash::sip::SipState;\n+ *\n+ * struct Person {\n+ *     id: uint,\n+ *     name: ~str,\n+ *     phone: uint,\n+ * }\n+ *\n+ * impl Hash for Person {\n+ *     fn hash(&self, state: &mut SipState) {\n+ *         self.id.hash(state);\n+ *         self.phone.hash(state);\n+ *     }\n+ * }\n+ *\n+ * let person1 = Person { id: 5, name: ~\"Janet\", phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: ~\"Bob\", phone: 555_666_7777 };\n+ *\n+ * assert!(hash::hash(&person1) == hash::hash(&person2));\n+ * ```\n+ */\n+\n+#[allow(unused_must_use)];\n+\n+use container::Container;\n+use io::Writer;\n+use iter::Iterator;\n+use option::{Option, Some, None};\n+use rc::Rc;\n+use str::{Str, StrSlice};\n+use vec::{Vector, ImmutableVector};\n+\n+/// Reexport the `sip::hash` function as our default hasher.\n+pub use hash = self::sip::hash;\n+\n+pub mod sip;\n+\n+/// A trait that represents a hashable type. The `S` type parameter is an\n+/// abstract hash state that is used by the `Hash` to compute the hash.\n+/// It defaults to `std::hash::sip::SipState`.\n+pub trait Hash<S = sip::SipState> {\n+    /// Compute a hash of the value.\n+    fn hash(&self, state: &mut S);\n+}\n+\n+/// A trait that computes a hash for a value. The main users of this trait are\n+/// containers like `HashMap`, which need a generic way hash multiple types.\n+pub trait Hasher<S> {\n+    /// Compute a hash of the value.\n+    fn hash<T: Hash<S>>(&self, value: &T) -> u64;\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+\n+macro_rules! impl_hash(\n+    ( $( $ty:ty => $method:ident;)* ) => (\n+        $(\n+            impl<S: Writer> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    state.$method(*self);\n+                }\n+            }\n+        )*\n+    )\n+)\n+\n+impl_hash!(\n+    u8 => write_u8;\n+    u16 => write_le_u16;\n+    u32 => write_le_u32;\n+    u64 => write_le_u64;\n+    uint => write_le_uint;\n+    i8 => write_i8;\n+    i16 => write_le_i16;\n+    i32 => write_le_i32;\n+    i64 => write_le_i64;\n+    int => write_le_int;\n+)\n+\n+impl<S: Writer> Hash<S> for bool {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (*self as u8).hash(state);\n+    }\n+}\n+\n+impl<S: Writer> Hash<S> for char {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (*self as u32).hash(state);\n+    }\n+}\n+\n+impl<'a, S: Writer> Hash<S> for &'a str {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        state.write(self.as_bytes());\n+        state.write_u8(0xFF);\n+    }\n+}\n+\n+impl<S: Writer> Hash<S> for ~str {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n+macro_rules! impl_hash_tuple(\n+    () => (\n+        impl<S: Writer> Hash<S> for () {\n+            #[inline]\n+            fn hash(&self, state: &mut S) {\n+                state.write([]);\n+            }\n+        }\n+    );\n+\n+    ($A:ident $($B:ident)*) => (\n+        impl<\n+            S: Writer,\n+            $A: Hash<S> $(, $B: Hash<S>)*\n+        > Hash<S> for ($A, $($B),*) {\n+            #[inline]\n+            fn hash(&self, state: &mut S) {\n+                match *self {\n+                    (ref $A, $(ref $B),*) => {\n+                        $A.hash(state);\n+                        $(\n+                            $B.hash(state);\n+                        )*\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl_hash_tuple!($($B)*)\n+    );\n+)\n+\n+impl_hash_tuple!(A0 A1 A2 A3 A4 A5 A6 A7)\n+\n+impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a [T] {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.len().hash(state);\n+        for elt in self.iter() {\n+            elt.hash(state);\n+        }\n+    }\n+}\n+\n+\n+impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a mut [T] {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for ~[T] {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n+impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n+impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a mut T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for ~T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for @T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.borrow().hash(state);\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for Option<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        match *self {\n+            Some(ref x) => {\n+                0u8.hash(state);\n+                x.hash(state);\n+            }\n+            None => {\n+                1u8.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+impl<S: Writer, T> Hash<S> for *T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        // NB: raw-pointer Hash does _not_ dereference\n+        // to the target; it just gives you the pointer-bytes.\n+        (*self as uint).hash(state);\n+    }\n+}\n+\n+impl<S: Writer, T> Hash<S> for *mut T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        // NB: raw-pointer Hash does _not_ dereference\n+        // to the target; it just gives you the pointer-bytes.\n+        (*self as uint).hash(state);\n+    }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+\n+#[cfg(test)]\n+mod tests {\n+    use cast;\n+    use io::{IoResult, Writer};\n+    use iter::{Iterator};\n+    use option::{Some, None};\n+    use result::Ok;\n+    use vec::ImmutableVector;\n+\n+    use super::{Hash, Hasher};\n+\n+    struct MyWriterHasher;\n+\n+    impl Hasher<MyWriter> for MyWriterHasher {\n+        fn hash<T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n+            let mut state = MyWriter { hash: 0 };\n+            value.hash(&mut state);\n+            state.hash\n+        }\n+    }\n+\n+    struct MyWriter {\n+        hash: u64,\n+    }\n+\n+    impl Writer for MyWriter {\n+        // Most things we'll just add up the bytes.\n+        fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+            for byte in buf.iter() {\n+                self.hash += *byte as u64;\n+            }\n+            Ok(())\n+        }\n+    }\n+\n+    #[test]\n+    fn test_writer_hasher() {\n+        let hasher = MyWriterHasher;\n+\n+        assert_eq!(hasher.hash(&()), 0);\n+\n+        assert_eq!(hasher.hash(&5u8), 5);\n+        assert_eq!(hasher.hash(&5u16), 5);\n+        assert_eq!(hasher.hash(&5u32), 5);\n+        assert_eq!(hasher.hash(&5u64), 5);\n+        assert_eq!(hasher.hash(&5u), 5);\n+\n+        assert_eq!(hasher.hash(&5i8), 5);\n+        assert_eq!(hasher.hash(&5i16), 5);\n+        assert_eq!(hasher.hash(&5i32), 5);\n+        assert_eq!(hasher.hash(&5i64), 5);\n+        assert_eq!(hasher.hash(&5i), 5);\n+\n+        assert_eq!(hasher.hash(&false), 0);\n+        assert_eq!(hasher.hash(&true), 1);\n+\n+        assert_eq!(hasher.hash(&'a'), 97);\n+\n+        assert_eq!(hasher.hash(& &\"a\"), 97 + 0xFF);\n+        assert_eq!(hasher.hash(& &[1u8, 2u8, 3u8]), 9);\n+\n+        unsafe {\n+            let ptr: *int = cast::transmute(5);\n+            assert_eq!(hasher.hash(&ptr), 5);\n+        }\n+\n+        unsafe {\n+            let ptr: *mut int = cast::transmute(5);\n+            assert_eq!(hasher.hash(&ptr), 5);\n+        }\n+    }\n+\n+    struct Custom {\n+        hash: u64\n+    }\n+\n+    impl Hash<u64> for Custom {\n+        fn hash(&self, state: &mut u64) {\n+            *state = self.hash;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_custom_state() {\n+        let custom = Custom { hash: 5 };\n+        let mut state = 0;\n+        custom.hash(&mut state);\n+        assert_eq!(state, 5);\n+    }\n+}"}, {"sha": "ce5e0d6b2edd2eaf7e859cf84e01c0256f33257e", "filename": "src/libstd/hash/sip.rs", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,519 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Implementation of SipHash 2-4\n+ *\n+ * See: http://131002.net/siphash/\n+ *\n+ * Consider this as a main \"general-purpose\" hash for all hashtables: it\n+ * runs at good speed (competitive with spooky and city) and permits\n+ * strong _keyed_ hashing. Key your hashtables from a strong RNG,\n+ * such as `rand::Rng`.\n+ *\n+ * Although the SipHash algorithm is considered to be cryptographically\n+ * strong, this implementation has not been reviewed for such purposes.\n+ * As such, all cryptographic uses of this implementation are strongly\n+ * discouraged.\n+ */\n+\n+use container::Container;\n+use io::{IoResult, Writer};\n+use iter::Iterator;\n+use result::Ok;\n+use vec::ImmutableVector;\n+\n+use super::{Hash, Hasher};\n+\n+/// `SipState` computes a SipHash 2-4 hash over a stream of bytes.\n+pub struct SipState {\n+    priv k0: u64,\n+    priv k1: u64,\n+    priv length: uint, // how many bytes we've processed\n+    priv v0: u64,      // hash state\n+    priv v1: u64,\n+    priv v2: u64,\n+    priv v3: u64,\n+    priv tail: [u8, ..8], // unprocessed bytes\n+    priv ntail: uint,  // how many bytes in tail are valid\n+}\n+\n+// sadly, these macro definitions can't appear later,\n+// because they're needed in the following defs;\n+// this design could be improved.\n+\n+macro_rules! u8to64_le (\n+    ($buf:expr, $i:expr) =>\n+    ($buf[0+$i] as u64 |\n+     $buf[1+$i] as u64 << 8 |\n+     $buf[2+$i] as u64 << 16 |\n+     $buf[3+$i] as u64 << 24 |\n+     $buf[4+$i] as u64 << 32 |\n+     $buf[5+$i] as u64 << 40 |\n+     $buf[6+$i] as u64 << 48 |\n+     $buf[7+$i] as u64 << 56)\n+)\n+\n+macro_rules! rotl (\n+    ($x:expr, $b:expr) =>\n+    (($x << $b) | ($x >> (64 - $b)))\n+)\n+\n+macro_rules! compress (\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+    ({\n+        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n+        $v0 = rotl!($v0, 32);\n+        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n+        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n+        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n+        $v2 = rotl!($v2, 32);\n+    })\n+)\n+\n+impl SipState {\n+    /// Create a `SipState` that is keyed off the provided keys.\n+    #[inline]\n+    pub fn new(key0: u64, key1: u64) -> SipState {\n+        let mut state = SipState {\n+            k0: key0,\n+            k1: key1,\n+            length: 0,\n+            v0: 0,\n+            v1: 0,\n+            v2: 0,\n+            v3: 0,\n+            tail: [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n+            ntail: 0,\n+        };\n+        state.reset();\n+        state\n+    }\n+\n+    /// Reset the state back to it's initial state.\n+    #[inline]\n+    pub fn reset(&mut self) {\n+        self.length = 0;\n+        self.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+    }\n+\n+    /// Return the computed hash.\n+    #[inline]\n+    pub fn result(&self) -> u64 {\n+        let mut v0 = self.v0;\n+        let mut v1 = self.v1;\n+        let mut v2 = self.v2;\n+        let mut v3 = self.v3;\n+\n+        let mut b : u64 = (self.length as u64 & 0xff) << 56;\n+\n+        if self.ntail > 0 { b |= self.tail[0] as u64 <<  0; }\n+        if self.ntail > 1 { b |= self.tail[1] as u64 <<  8; }\n+        if self.ntail > 2 { b |= self.tail[2] as u64 << 16; }\n+        if self.ntail > 3 { b |= self.tail[3] as u64 << 24; }\n+        if self.ntail > 4 { b |= self.tail[4] as u64 << 32; }\n+        if self.ntail > 5 { b |= self.tail[5] as u64 << 40; }\n+        if self.ntail > 6 { b |= self.tail[6] as u64 << 48; }\n+\n+        v3 ^= b;\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        v0 ^= b;\n+\n+        v2 ^= 0xff;\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+\n+        v0 ^ v1 ^ v2 ^ v3\n+    }\n+}\n+\n+impl Writer for SipState {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) -> IoResult<()> {\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let mut needed = 0u;\n+\n+        if self.ntail != 0 {\n+            needed = 8 - self.ntail;\n+\n+            if length < needed {\n+                let mut t = 0;\n+                while t < length {\n+                    self.tail[self.ntail+t] = msg[t];\n+                    t += 1;\n+                }\n+                self.ntail += length;\n+                return Ok(());\n+            }\n+\n+            let mut t = 0;\n+            while t < needed {\n+                self.tail[self.ntail+t] = msg[t];\n+                t += 1;\n+            }\n+\n+            let m = u8to64_le!(self.tail, 0);\n+\n+            self.v3 ^= m;\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            self.v0 ^= m;\n+\n+            self.ntail = 0;\n+        }\n+\n+        // Buffered tail is now flushed, process new input.\n+        let len = length - needed;\n+        let end = len & (!0x7);\n+        let left = len & 0x7;\n+\n+        let mut i = needed;\n+        while i < end {\n+            let mi = u8to64_le!(msg, i);\n+\n+            self.v3 ^= mi;\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            self.v0 ^= mi;\n+\n+            i += 8;\n+        }\n+\n+        let mut t = 0u;\n+        while t < left {\n+            self.tail[t] = msg[i+t];\n+            t += 1\n+        }\n+        self.ntail = left;\n+\n+        Ok(())\n+    }\n+}\n+\n+/// `Sip` computes the SipHash algorithm from a stream of bytes.\n+pub struct SipHasher {\n+    priv state: SipState,\n+}\n+\n+impl SipHasher {\n+    /// Create a `Sip`.\n+    #[inline]\n+    pub fn new() -> SipHasher {\n+        SipHasher::new_with_keys(0, 0)\n+    }\n+\n+    /// Create a `Sip` that is keyed off the provided keys.\n+    #[inline]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n+        SipHasher {\n+            state: SipState::new(key0, key1),\n+        }\n+    }\n+}\n+\n+impl Hasher<SipState> for SipHasher {\n+    #[inline]\n+    fn hash<T: Hash<SipState>>(&self, value: &T) -> u64 {\n+        let mut state = self.state; // implicitly copy the state.\n+        value.hash(&mut state);\n+        state.result()\n+    }\n+}\n+\n+\n+/// Hash a value using the SipHash algorithm.\n+#[inline]\n+pub fn hash<T: Hash<SipState>>(value: &T) -> u64 {\n+    hash_with_keys(0, 0, value)\n+}\n+\n+/// Hash a value with the SipHash algorithm with the provided keys.\n+#[inline]\n+pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n+    let mut state = SipState::new(k0, k1);\n+    value.hash(&mut state);\n+    state.result()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate test;\n+    use io::Writer;\n+    use iter::Iterator;\n+    use num::ToStrRadix;\n+    use option::{Some, None};\n+    use str::{Str, OwnedStr};\n+    use vec::{Vector, ImmutableVector, OwnedVector};\n+    use self::test::BenchHarness;\n+\n+    use super::super::Hash;\n+    use super::{SipState, hash, hash_with_keys};\n+\n+    // Hash just the bytes of the slice, without length prefix\n+    struct Bytes<'a>(&'a [u8]);\n+\n+    impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n+        #[allow(unused_must_use)]\n+        fn hash(&self, state: &mut S) {\n+            let Bytes(v) = *self;\n+            state.write(v);\n+        }\n+    }\n+\n+    #[test]\n+    #[allow(unused_must_use)]\n+    fn test_siphash() {\n+        let vecs : [[u8, ..8], ..64] = [\n+            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n+            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n+            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n+            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n+            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n+            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n+            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n+            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n+            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n+            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n+            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n+            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n+            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n+            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n+            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n+            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n+            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n+            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n+            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n+            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n+            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n+            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n+            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n+            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n+            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n+            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n+            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n+            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n+            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n+            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n+            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n+            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n+            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n+            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n+            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n+            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n+            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n+            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n+            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n+            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n+            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n+            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n+            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n+            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n+            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n+            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n+            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n+            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n+            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n+            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n+            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n+            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n+            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n+            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n+            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n+            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n+            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n+            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n+            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n+            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n+            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n+            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n+            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n+            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n+        ];\n+\n+        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n+        let mut buf : ~[u8] = ~[];\n+        let mut t = 0;\n+        let mut state_inc = SipState::new(k0, k1);\n+        let mut state_full = SipState::new(k0, k1);\n+\n+        fn to_hex_str(r: &[u8, ..8]) -> ~str {\n+            let mut s = ~\"\";\n+            for b in r.iter() {\n+                s.push_str((*b as uint).to_str_radix(16u));\n+            }\n+            s\n+        }\n+\n+        fn result_bytes(h: u64) -> ~[u8] {\n+            ~[(h >> 0) as u8,\n+              (h >> 8) as u8,\n+              (h >> 16) as u8,\n+              (h >> 24) as u8,\n+              (h >> 32) as u8,\n+              (h >> 40) as u8,\n+              (h >> 48) as u8,\n+              (h >> 56) as u8,\n+            ]\n+        }\n+\n+        fn result_str(h: u64) -> ~str {\n+            let r = result_bytes(h);\n+            let mut s = ~\"\";\n+            for b in r.iter() {\n+                s.push_str((*b as uint).to_str_radix(16u));\n+            }\n+            s\n+        }\n+\n+        while t < 64 {\n+            debug!(\"siphash test {}\", t);\n+            let vec = u8to64_le!(vecs[t], 0);\n+            let out = hash_with_keys(k0, k1, &Bytes(buf.as_slice()));\n+            debug!(\"got {:?}, expected {:?}\", out, vec);\n+            assert_eq!(vec, out);\n+\n+            state_full.reset();\n+            state_full.write(buf);\n+            let f = result_str(state_full.result());\n+            let i = result_str(state_inc.result());\n+            let v = to_hex_str(&vecs[t]);\n+            debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n+\n+            assert!(f == i && f == v);\n+\n+            buf.push(t as u8);\n+            state_inc.write_u8(t);\n+\n+            t += 1;\n+        }\n+    }\n+\n+    #[test] #[cfg(target_arch = \"arm\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as uint)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86_64\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n+        assert!(hash(&(val as u32)) != hash(&(val as uint)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as uint)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    }\n+\n+    #[test]\n+    fn test_hash_idempotent() {\n+        let val64 = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&val64), hash(&val64));\n+        let val32 = 0xdeadbeef_u32;\n+        assert_eq!(hash(&val32), hash(&val32));\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_64() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+        fn zero_byte(val: u64, byte: uint) -> u64 {\n+            assert!(byte < 8);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_32() {\n+        let val = 0xdeadbeef_u32;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+        fn zero_byte(val: u32, byte: uint) -> u32 {\n+            assert!(byte < 4);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_concat_alias() {\n+        let s = (\"aa\", \"bb\");\n+        let t = (\"aabb\", \"\");\n+        let u = (\"a\", \"abb\");\n+\n+        assert!(s != t && t != u);\n+        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+        let v = (&[1u8], &[0u8, 0], &[0u8]);\n+        let w = (&[1u8, 0, 0, 0], &[], &[]);\n+\n+        assert!(v != w);\n+        assert!(hash(&v) != hash(&w));\n+    }\n+\n+    #[bench]\n+    fn bench_str(bh: &mut BenchHarness) {\n+        let s = \"foo\";\n+        bh.iter(|| {\n+            assert_eq!(hash(&s), 16262950014981195938);\n+        })\n+    }\n+\n+    struct Compound {\n+        x: u8,\n+        y: u16,\n+        z: ~str,\n+    }\n+\n+    impl<S: Writer> Hash<S> for Compound {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.x.hash(state);\n+            self.y.hash(state);\n+            self.z.hash(state);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_compound_1(bh: &mut BenchHarness) {\n+        let compound = Compound {\n+            x: 1,\n+            y: 2,\n+            z: ~\"foobarbaz\",\n+        };\n+        bh.iter(|| {\n+            assert_eq!(hash(&compound), 3581836382593270478);\n+        })\n+    }\n+}"}, {"sha": "07b16db95f867e24d87bf1000a3a1f88a84ceed5", "filename": "src/libstd/hash_old.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhash_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhash_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash_old.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -36,7 +36,7 @@ use to_bytes::IterBytes;\n use vec::ImmutableVector;\n \n // Alias `SipState` to `State`.\n-pub use State = hash::SipState;\n+pub use State = hash_old::SipState;\n \n /**\n  * Types that can meaningfully be hashed should implement this.\n@@ -298,9 +298,13 @@ impl Streaming for SipState {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use prelude::*;\n-    use super::SipState;\n+    use super::{Hash, Streaming, SipState};\n+    use iter::Iterator;\n+    use num::ToStrRadix;\n+    use option::Some;\n+    use str::OwnedStr;\n+    use to_bytes::IterBytes;\n+    use vec::{Vector, OwnedVector, ImmutableVector};\n \n     // Hash just the bytes of the slice, without length prefix\n     struct Bytes<'a>(&'a [u8]);", "previous_filename": "src/libstd/hash.rs"}, {"sha": "f3783c27b54728c6f388be3b4ee13c33ce6578b0", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -57,7 +57,7 @@ use clone::Clone;\n use cmp::{Eq, Equiv, max};\n use default::Default;\n use fmt;\n-use hash::Hash;\n+use hash_old::Hash;\n use iter;\n use iter::{Iterator, FromIterator, Extendable};\n use iter::{FilterMap, Chain, Repeat, Zip};"}, {"sha": "6996cba42b40ee379989d51868ff7ea7dc0dafa7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -54,6 +54,10 @@\n \n #[feature(macro_rules, globs, asm, managed_boxes, thread_local, link_args, simd)];\n \n+// Turn on default type parameters.\n+#[feature(default_type_params)];\n+#[allow(default_type_param_usage)];\n+\n // Don't link to std. We are std.\n #[no_std];\n \n@@ -141,6 +145,7 @@ pub mod iter;\n pub mod to_str;\n pub mod to_bytes;\n pub mod clone;\n+pub mod hash_old;\n pub mod hash;\n pub mod container;\n pub mod default;\n@@ -213,6 +218,7 @@ mod std {\n     pub use cmp;\n     pub use comm;\n     pub use fmt;\n+    pub use hash;\n     pub use io;\n     pub use kinds;\n     pub use local_data;"}, {"sha": "83ef85fc35b4adfcd50448ce43303d3af46e79af", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -45,7 +45,6 @@ pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv}\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use default::Default;\n pub use from_str::FromStr;\n-pub use hash::Hash;\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};"}, {"sha": "0e5627fa066695b9b702404af49874f2f1e1d367", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -18,7 +18,7 @@ use option::{Some, None};\n use str::OwnedStr;\n use hashmap::HashMap;\n use hashmap::HashSet;\n-use hash::Hash;\n+use hash_old::Hash;\n use iter::Iterator;\n use cmp::Eq;\n use vec::ImmutableVector;"}, {"sha": "99ac07ba4d7b022ad33e7943d5a42743ea636ef1", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -416,11 +416,11 @@ impl<'a> TraitDef<'a> {\n                           self_type, methods.map(|x| *x)))\n     }\n \n-    pub fn expand_struct_def(&self,\n-                             cx: &mut ExtCtxt,\n-                             struct_def: &StructDef,\n-                             type_ident: Ident,\n-                             generics: &Generics) -> @ast::Item {\n+    fn expand_struct_def(&self,\n+                         cx: &mut ExtCtxt,\n+                         struct_def: &StructDef,\n+                         type_ident: Ident,\n+                         generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n@@ -450,7 +450,7 @@ impl<'a> TraitDef<'a> {\n         self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n \n-    pub fn expand_enum_def(&self,\n+    fn expand_enum_def(&self,\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,"}, {"sha": "0b9158547ed83abd3f4e8f3d61685ff8b104c19d", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{MetaItem, Item, Expr, MutMutable};\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+use parse::token::InternedString;\n+\n+pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n+                            span: Span,\n+                            mitem: @MetaItem,\n+                            item: @Item,\n+                            push: |@Item|) {\n+\n+    let allow_default_type_param_usage = cx.attribute(\n+        span,\n+        cx.meta_list(\n+            span,\n+            InternedString::new(\"allow\"),\n+            ~[cx.meta_word(span, InternedString::new(\"default_type_param_usage\"))]));\n+\n+    let hash_trait_def = TraitDef {\n+        span: span,\n+        attributes: ~[allow_default_type_param_usage],\n+        path: Path::new_(~[\"std\", \"hash\", \"Hash\"], None,\n+                         ~[~Literal(Path::new_local(\"__H\"))], true),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds {\n+            lifetimes: ~[],\n+            bounds: ~[(\"__H\", ~[Path::new(~[\"std\", \"io\", \"Writer\"])])],\n+        },\n+        methods: ~[\n+            MethodDef {\n+                name: \"hash\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: ~[Ptr(~Literal(Path::new_local(\"__H\")),\n+                            Borrowed(None, MutMutable))],\n+                ret_ty: nil_ty(),\n+                inline: true,\n+                const_nonmatching: false,\n+                combine_substructure: hash_substructure\n+            }\n+        ]\n+    };\n+\n+    hash_trait_def.expand(cx, mitem, item, push);\n+}\n+\n+fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+    let state_expr = match substr.nonself_args {\n+        [state_expr] => state_expr,\n+        _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")\n+    };\n+    let hash_ident = substr.method_ident;\n+    let call_hash = |span, thing_expr| {\n+        let expr = cx.expr_method_call(span, thing_expr, hash_ident, ~[state_expr]);\n+        cx.stmt_expr(expr)\n+    };\n+    let mut stmts = ~[];\n+\n+    let fields = match *substr.fields {\n+        Struct(ref fs) => fs,\n+        EnumMatching(index, variant, ref fs) => {\n+            // Determine the discriminant. We will feed this value to the byte\n+            // iteration function.\n+            let discriminant = match variant.node.disr_expr {\n+                Some(d) => d,\n+                None => cx.expr_uint(trait_span, index)\n+            };\n+\n+            stmts.push(call_hash(trait_span, discriminant));\n+\n+            fs\n+        }\n+        _ => cx.span_bug(trait_span, \"impossible substructure in `deriving(Hash)`\")\n+    };\n+\n+    for &FieldInfo { self_, span, .. } in fields.iter() {\n+        stmts.push(call_hash(span, self_));\n+    }\n+\n+    if stmts.len() == 0 {\n+        cx.span_bug(trait_span, \"#[deriving(Hash)] needs at least one field\");\n+    }\n+\n+    cx.expr_block(cx.block(trait_span, stmts, None))\n+}"}, {"sha": "31ee99fbd260e00212d7b79121306e0d57254ca5", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -26,6 +26,7 @@ pub mod clone;\n pub mod iter_bytes;\n pub mod encodable;\n pub mod decodable;\n+pub mod hash;\n pub mod rand;\n pub mod to_str;\n pub mod show;\n@@ -74,6 +75,7 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             \"DeepClone\" => expand!(clone::expand_deriving_deep_clone),\n \n                             \"IterBytes\" => expand!(iter_bytes::expand_deriving_iter_bytes),\n+                            \"Hash\" => expand!(hash::expand_deriving_hash),\n \n                             \"Encodable\" => expand!(encodable::expand_deriving_encodable),\n                             \"Decodable\" => expand!(decodable::expand_deriving_decodable),"}, {"sha": "1c801f7d970570e2f059ac3330966fddaf29e786", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -17,6 +17,7 @@ use ast::Name;\n use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n+use std::hash_old::Hash;\n use std::hashmap::HashMap;\n use std::rc::Rc;\n "}, {"sha": "182c669cbea1c03c16364d0fb18b2a36057099ec", "filename": "src/test/compile-fail/deriving-span-Hash-enum-struct-variant.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum-struct-variant.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern crate extra;\n+\n+use std::hash::Hash;\n+\n+struct Error;\n+\n+#[deriving(Hash)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "7617e0a33c385131240c6300ae78b8286122ef65", "filename": "src/test/compile-fail/deriving-span-Hash-enum.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern crate extra;\n+\n+use std::hash::Hash;\n+\n+struct Error;\n+\n+#[deriving(Hash)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "f20da9a9d16a7a3e604537a7a2502abf8ef14b13", "filename": "src/test/compile-fail/deriving-span-Hash-struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-struct.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern crate extra;\n+\n+use std::hash::Hash;\n+\n+struct Error;\n+\n+#[deriving(Hash)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "9b7ae50b738b81db9b436d73910d5748e3c857fc", "filename": "src/test/compile-fail/deriving-span-Hash-tuple-struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-tuple-struct.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern crate extra;\n+\n+use std::hash::Hash;\n+\n+struct Error;\n+\n+#[deriving(Hash)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "087b7ce56ab47116d73e4fa7f062fd8436e777d3", "filename": "src/test/run-pass/deriving-hash.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+use std::hash;\n+use std::hash::Hash;\n+\n+#[deriving(Hash)]\n+struct Person {\n+    id: uint,\n+    name: ~str,\n+    phone: uint,\n+}\n+\n+fn main() {\n+    let person1 = Person { id: 5, name: ~\"Janet\", phone: 555_666_7777 };\n+    let person2 = Person { id: 5, name: ~\"Bob\", phone: 555_666_7777 };\n+    assert!(hash::hash(&person1) == hash::hash(&person1));\n+    assert!(hash::hash(&person1) != hash::hash(&person2));\n+}"}, {"sha": "49bf101954b714dbaeaae9d1046c065d4257f19d", "filename": "src/test/run-pass/deriving-meta-multiple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -10,6 +10,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::hash_old::Hash;\n+\n #[deriving(Eq)]\n #[deriving(Clone)]\n #[deriving(IterBytes)]"}, {"sha": "93193fc9d65e0cd9f2f9d57ba25ac2531d18827a", "filename": "src/test/run-pass/deriving-meta.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -10,6 +10,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::hash_old::Hash;\n+\n #[deriving(Eq, Clone, IterBytes)]\n struct Foo {\n     bar: uint,"}, {"sha": "2d5c1d100be8b91cdbdb92688305050157c4f753", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d223dd1e57cc412aa2eff28e6604f86b9f013083/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=d223dd1e57cc412aa2eff28e6604f86b9f013083", "patch": "@@ -15,6 +15,7 @@\n extern crate other1 = \"typeid-intrinsic\";\n extern crate other2 = \"typeid-intrinsic2\";\n \n+use std::hash_old::Hash;\n use std::unstable::intrinsics;\n use std::unstable::intrinsics::TypeId;\n "}]}