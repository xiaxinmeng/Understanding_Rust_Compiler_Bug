{"sha": "bf80fec326d0fa7b58882d6f2102808a3f220651", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmODBmZWMzMjZkMGZhN2I1ODg4MmQ2ZjIxMDI4MDhhM2YyMjA2NTE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-06T10:58:51Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:06Z"}, "message": "translate function shims using MIR", "tree": {"sha": "ead778b4bac4f6b1a90687dae76a7a22db4e6ce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ead778b4bac4f6b1a90687dae76a7a22db4e6ce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf80fec326d0fa7b58882d6f2102808a3f220651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf80fec326d0fa7b58882d6f2102808a3f220651", "html_url": "https://github.com/rust-lang/rust/commit/bf80fec326d0fa7b58882d6f2102808a3f220651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf80fec326d0fa7b58882d6f2102808a3f220651/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffee9566bbd7728e6411e6094105d6905373255d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffee9566bbd7728e6411e6094105d6905373255d", "html_url": "https://github.com/rust-lang/rust/commit/ffee9566bbd7728e6411e6094105d6905373255d"}], "stats": {"total": 339, "additions": 199, "deletions": 140}, "files": [{"sha": "bf0b1796dffaf065d8c94cbc968a77ce3e921c1a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 122, "deletions": 5, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=bf80fec326d0fa7b58882d6f2102808a3f220651", "patch": "@@ -12,30 +12,42 @@ use rustc::hir;\n use rustc::infer;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n+use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n use syntax_pos::Span;\n \n use std::cell::RefCell;\n use std::iter;\n+use std::mem;\n \n pub fn provide(providers: &mut Providers) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'a, 'tcx>(_tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                        instance: ty::InstanceDef<'tcx>)\n                        -> &'tcx RefCell<Mir<'tcx>>\n {\n-    match instance {\n+    debug!(\"make_shim({:?})\", instance);\n+    let result = match instance {\n         ty::InstanceDef::Item(..) =>\n             bug!(\"item {:?} passed to make_shim\", instance),\n-        ty::InstanceDef::FnPtrShim(..) => unimplemented!()\n-    }\n+        ty::InstanceDef::FnPtrShim(_, ty) => {\n+            build_fn_ptr_shim(tcx, ty, instance.def_ty(tcx))\n+        }\n+    };\n+    debug!(\"make_shim({:?}) = {:?}\", instance, result);\n+\n+    let result = tcx.alloc_mir(result);\n+    // Perma-borrow MIR from shims to prevent mutation.\n+    mem::forget(result.borrow());\n+    result\n }\n \n fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n@@ -54,6 +66,111 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n     })).collect()\n }\n \n+\n+fn build_fn_ptr_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                               fn_ty: Ty<'tcx>,\n+                               sig_ty: Ty<'tcx>)\n+                               -> Mir<'tcx>\n+{\n+    debug!(\"build_fn_ptr_shim(fn_ty={:?}, sig_ty={:?})\", fn_ty, sig_ty);\n+    let trait_sig = match sig_ty.sty {\n+        ty::TyFnDef(_, _, fty) => tcx.erase_late_bound_regions(&fty),\n+        _ => bug!(\"unexpected type for shim {:?}\", sig_ty)\n+    };\n+\n+    let self_ty = match trait_sig.inputs()[0].sty {\n+        ty::TyParam(..) => fn_ty,\n+        ty::TyRef(r, mt) => tcx.mk_ref(r, ty::TypeAndMut {\n+            ty: fn_ty,\n+            mutbl: mt.mutbl\n+        }),\n+        _ => bug!(\"unexpected self_ty {:?}\", trait_sig),\n+    };\n+\n+    let fn_ptr_sig = match fn_ty.sty {\n+        ty::TyFnPtr(fty) |\n+        ty::TyFnDef(_, _, fty) =>\n+            tcx.erase_late_bound_regions_and_normalize(&fty),\n+        _ => bug!(\"non-fn-ptr {:?} in build_fn_ptr_shim\", fn_ty)\n+    };\n+\n+    let sig = tcx.mk_fn_sig(\n+        [\n+            self_ty,\n+            tcx.intern_tup(fn_ptr_sig.inputs(), false)\n+        ].iter().cloned(),\n+        fn_ptr_sig.output(),\n+        false,\n+        hir::Unsafety::Normal,\n+        Abi::RustCall,\n+    );\n+\n+    let local_decls = local_decls_for_sig(&sig);\n+    let source_info = SourceInfo {\n+        span: DUMMY_SP,\n+        scope: ARGUMENT_VISIBILITY_SCOPE\n+    };\n+\n+    let fn_ptr = Lvalue::Local(Local::new(1+0));\n+    let fn_ptr = match trait_sig.inputs()[0].sty {\n+        ty::TyParam(..) => fn_ptr,\n+        ty::TyRef(..) => Lvalue::Projection(box Projection {\n+            base: fn_ptr, elem: ProjectionElem::Deref\n+        }),\n+        _ => bug!(\"unexpected self_ty {:?}\", trait_sig),\n+    };\n+    let fn_args = Local::new(1+1);\n+\n+    let return_block_id = BasicBlock::new(1);\n+\n+    // return = ADT(arg0, arg1, ...); return\n+    let start_block = BasicBlockData {\n+        statements: vec![],\n+        terminator: Some(Terminator {\n+            source_info: source_info,\n+            kind: TerminatorKind::Call {\n+                func: Operand::Consume(fn_ptr),\n+                args: fn_ptr_sig.inputs().iter().enumerate().map(|(i, ity)| {\n+                    Operand::Consume(Lvalue::Projection(box Projection {\n+                        base: Lvalue::Local(fn_args),\n+                        elem: ProjectionElem::Field(\n+                            Field::new(i), *ity\n+                        )\n+                    }))\n+                }).collect(),\n+                // FIXME: can we pass a Some destination for an uninhabited ty?\n+                destination: Some((Lvalue::Local(RETURN_POINTER),\n+                                   return_block_id)),\n+                cleanup: None\n+            }\n+        }),\n+        is_cleanup: false\n+    };\n+    let return_block = BasicBlockData {\n+        statements: vec![],\n+        terminator: Some(Terminator {\n+            source_info: source_info,\n+            kind: TerminatorKind::Return\n+        }),\n+        is_cleanup: false\n+    };\n+\n+    let mut mir = Mir::new(\n+        vec![start_block, return_block].into_iter().collect(),\n+        IndexVec::from_elem_n(\n+            VisibilityScopeData { span: DUMMY_SP, parent_scope: None }, 1\n+        ),\n+        IndexVec::new(),\n+        sig.output(),\n+        local_decls,\n+        sig.inputs().len(),\n+        vec![],\n+        DUMMY_SP\n+    );\n+    mir.spread_arg = Some(fn_args);\n+    mir\n+}\n+\n pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                       ctor_id: ast::NodeId,\n                                       fields: &[hir::StructField],"}, {"sha": "2294e8a0002e04d516b858d16585d7b33fccb366", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 7, "deletions": 127, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=bf80fec326d0fa7b58882d6f2102808a3f220651", "patch": "@@ -36,7 +36,6 @@ use back::symbol_names::symbol_name;\n use trans_item::TransItem;\n use type_of;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::hir;\n use std::iter;\n \n use syntax_pos::DUMMY_SP;\n@@ -130,15 +129,14 @@ impl<'tcx> Callee<'tcx> {\n                 let method_ty = instance_ty(ccx.shared(), &instance);\n                 Callee::ptr(llfn, method_ty)\n             }\n-            traits::VtableFnPointer(vtable_fn_pointer) => {\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let instance = Instance::new(def_id, substs);\n-                let llfn = trans_fn_pointer_shim(ccx, instance,\n-                                                 trait_closure_kind,\n-                                                 vtable_fn_pointer.fn_ty);\n+            traits::VtableFnPointer(data) => {\n+                let instance = ty::Instance {\n+                    def: ty::InstanceDef::FnPtrShim(def_id, data.fn_ty),\n+                    substs: substs,\n+                };\n \n-                let method_ty = instance_ty(ccx.shared(), &instance);\n-                Callee::ptr(llfn, method_ty)\n+                let (llfn, ty) = get_fn(ccx, instance);\n+                Callee::ptr(llfn, ty)\n             }\n             traits::VtableObject(ref data) => {\n                 Callee {\n@@ -363,124 +361,6 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     lloncefn\n }\n \n-/// Translates an adapter that implements the `Fn` trait for a fn\n-/// pointer. This is basically the equivalent of something like:\n-///\n-/// ```\n-/// impl<'a> Fn(&'a int) -> &'a int for fn(&int) -> &int {\n-///     extern \"rust-abi\" fn call(&self, args: (&'a int,)) -> &'a int {\n-///         (*self)(args.0)\n-///     }\n-/// }\n-/// ```\n-///\n-/// but for the bare function type given.\n-fn trans_fn_pointer_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    method_instance: Instance<'tcx>,\n-    closure_kind: ty::ClosureKind,\n-    bare_fn_ty: Ty<'tcx>)\n-    -> ValueRef\n-{\n-    let tcx = ccx.tcx();\n-\n-    // Normalize the type for better caching.\n-    let bare_fn_ty = tcx.normalize_associated_type(&bare_fn_ty);\n-\n-    // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n-    let is_by_ref = match closure_kind {\n-        ty::ClosureKind::Fn | ty::ClosureKind::FnMut => true,\n-        ty::ClosureKind::FnOnce => false,\n-    };\n-\n-    let llfnpointer = match bare_fn_ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => {\n-            // Function definitions have to be turned into a pointer.\n-            let llfn = Callee::def(ccx, def_id, substs).reify(ccx);\n-            if !is_by_ref {\n-                // A by-value fn item is ignored, so the shim has\n-                // the same signature as the original function.\n-                return llfn;\n-            }\n-            Some(llfn)\n-        }\n-        _ => None\n-    };\n-\n-    let bare_fn_ty_maybe_ref = if is_by_ref {\n-        tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), bare_fn_ty)\n-    } else {\n-        bare_fn_ty\n-    };\n-\n-    // Check if we already trans'd this shim.\n-    if let Some(&llval) = ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n-        return llval;\n-    }\n-\n-    debug!(\"trans_fn_pointer_shim(bare_fn_ty={:?})\",\n-           bare_fn_ty);\n-\n-    // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n-    // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let sig = bare_fn_ty.fn_sig();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    assert_eq!(sig.unsafety, hir::Unsafety::Normal);\n-    assert_eq!(sig.abi, Abi::Rust);\n-    let tuple_input_ty = tcx.intern_tup(sig.inputs(), false);\n-    let sig = tcx.mk_fn_sig(\n-        [bare_fn_ty_maybe_ref, tuple_input_ty].iter().cloned(),\n-        sig.output(),\n-        false,\n-        hir::Unsafety::Normal,\n-        Abi::RustCall\n-    );\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n-    let tuple_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n-    debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n-\n-    //\n-    let function_name = symbol_name(method_instance, ccx.shared());\n-    let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-    //\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-\n-    let mut llargs = get_params(llfn);\n-\n-    let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n-    let llfnpointer = llfnpointer.unwrap_or_else(|| {\n-        // the first argument (`self`) will be ptr to the fn pointer\n-        if is_by_ref {\n-            bcx.load(self_arg, None)\n-        } else {\n-            self_arg\n-        }\n-    });\n-\n-    let callee = Callee {\n-        data: Fn(llfnpointer),\n-        ty: bare_fn_ty\n-    };\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(ccx, &[]);\n-    let llret = bcx.call(llfnpointer, &llargs, None);\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    } else {\n-        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n-            bcx.ret_void();\n-        } else {\n-            bcx.ret(llret);\n-        }\n-    }\n-\n-    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n-\n-    llfn\n-}\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes."}, {"sha": "c4239fa2ae65faa131e36af07681eff42b0eda2d", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=bf80fec326d0fa7b58882d6f2102808a3f220651", "patch": "@@ -907,14 +907,12 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             }\n         }\n         traits::VtableFnPointer(ref data) => {\n-            // If we know the destination of this fn-pointer, we'll have to make\n-            // sure that this destination actually gets instantiated.\n-            if let ty::TyFnDef(def_id, substs, _) = data.fn_ty.sty {\n-                // The destination of the pointer might be something that needs\n-                // further dispatching, such as a trait method, so we do that.\n-                do_static_dispatch(scx, def_id, substs)\n-            } else {\n-                StaticDispatchResult::Unknown\n+            StaticDispatchResult::Dispatched {\n+                instance: Instance {\n+                    def: ty::InstanceDef::FnPtrShim(trait_method.def_id, data.fn_ty),\n+                    substs: trait_ref.substs\n+                },\n+                fn_once_adjustment: None,\n             }\n         }\n         // Trait object shims are always instantiated in-place, and as they are"}, {"sha": "51df38cabef30d61f7d290e90043bb1e7ba3a4f1", "filename": "src/test/codegen-units/item-collection/function-as-argument.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs?ref=bf80fec326d0fa7b58882d6f2102808a3f220651", "patch": "@@ -28,10 +28,12 @@ fn main() {\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<u32, &str, fn(u32, &str)>\n     //~ TRANS_ITEM fn function_as_argument::function[0]<u32, &str>\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(u32, &str), (u32, &str)>\n     take_fn_once(function, 0u32, \"abc\");\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<char, f64, fn(char, f64)>\n     //~ TRANS_ITEM fn function_as_argument::function[0]<char, f64>\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(char, f64), (char, f64)>\n     take_fn_once(function, 'c', 0f64);\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<i32, ()>"}, {"sha": "f7afd3f0891e318b7ff0f9771762e326541c800e", "filename": "src/test/codegen-units/item-collection/trait-method-as-argument.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs?ref=bf80fec326d0fa7b58882d6f2102808a3f220651", "patch": "@@ -40,22 +40,28 @@ fn take_foo_mut<T, F: FnMut(T) -> T>(mut f: F, arg: T) -> T {\n fn main() {\n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n     //~ TRANS_ITEM fn trait_method_as_argument::{{impl}}[0]::foo[0]\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(u32) -> u32, (u32)>\n     take_foo_once(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>\n     //~ TRANS_ITEM fn trait_method_as_argument::Trait[0]::foo[0]<char>\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(char) -> char, (char)>\n     take_foo_once(Trait::foo, 'c');\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<u32, fn(u32) -> u32>\n+    //~ TRANS_ITEM fn core::ops[0]::Fn[0]::call[0]<fn(u32) -> u32, (u32)>\n     take_foo(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<char, fn(char) -> char>\n+    //~ TRANS_ITEM fn core::ops[0]::Fn[0]::call[0]<fn(char) -> char, (char)>\n     take_foo(Trait::foo, 'c');\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<u32, fn(u32) -> u32>\n+    //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(char) -> char, (char)>\n     take_foo_mut(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<char, fn(char) -> char>\n+    //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n     take_foo_mut(Trait::foo, 'c');\n }\n "}, {"sha": "7300a322ec4b73868623c005aaf7c5780d3d88c8", "filename": "src/test/run-pass/mir_calls_to_shims.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf80fec326d0fa7b58882d6f2102808a3f220651/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs?ref=bf80fec326d0fa7b58882d6f2102808a3f220651", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(fn_traits)]\n+#![feature(never_type)]\n+\n+use std::panic;\n+\n+fn foo(x: u32, y: u32) -> u32 { x/y }\n+fn foo_diverges() -> ! { panic!() }\n+\n+fn test_fn_ptr<T>(mut t: T)\n+    where T: Fn(u32, u32) -> u32,\n+{\n+    let as_fn = <T as Fn<(u32, u32)>>::call;\n+    assert_eq!(as_fn(&t, (9, 3)), 3);\n+    let as_fn_mut = <T as FnMut<(u32, u32)>>::call_mut;\n+    assert_eq!(as_fn_mut(&mut t, (18, 3)), 6);\n+    let as_fn_once = <T as FnOnce<(u32, u32)>>::call_once;\n+    assert_eq!(as_fn_once(t, (24, 3)), 8);\n+}\n+\n+fn assert_panics<F>(f: F) where F: FnOnce() {\n+    let f = panic::AssertUnwindSafe(f);\n+    let result = panic::catch_unwind(move || {\n+        f.0()\n+    });\n+    if let Ok(..) = result {\n+        panic!(\"diverging function returned\");\n+    }\n+}\n+\n+fn test_fn_ptr_panic<T>(mut t: T)\n+    where T: Fn() -> !\n+{\n+    let as_fn = <T as Fn<()>>::call;\n+    assert_panics(|| as_fn(&t, ()));\n+    let as_fn_mut = <T as FnMut<()>>::call_mut;\n+    assert_panics(|| as_fn_mut(&mut t, ()));\n+    let as_fn_once = <T as FnOnce<()>>::call_once;\n+    assert_panics(|| as_fn_once(t, ()));\n+}\n+\n+fn main() {\n+    test_fn_ptr(foo);\n+    test_fn_ptr(foo as fn(u32, u32) -> u32);\n+    test_fn_ptr_panic(foo_diverges);\n+    test_fn_ptr_panic(foo_diverges as fn() -> !);\n+}"}]}