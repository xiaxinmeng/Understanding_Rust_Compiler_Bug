{"sha": "d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYWUyYzgxNDIzMmJjZmZkODNiYmIyZTM2NTNkZmI4Yzg3NDY5NzU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2016-11-24T17:25:59Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2016-11-29T12:04:27Z"}, "message": "Refactor inlined items some more\n\nThey don't implement FnLikeNode anymore, instead are handled differently\nfurther up in the call tree. Also, keep less information (just def ids\nfor the args).", "tree": {"sha": "4e4e384d9f0443c737cb23ede27d931aa914006f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e4e384d9f0443c737cb23ede27d931aa914006f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "html_url": "https://github.com/rust-lang/rust/commit/d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd1491cfbee8ec271438e6a56123fcc725468f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1491cfbee8ec271438e6a56123fcc725468f0f", "html_url": "https://github.com/rust-lang/rust/commit/dd1491cfbee8ec271438e6a56123fcc725468f0f"}], "stats": {"total": 193, "additions": 91, "deletions": 102}, "files": [{"sha": "068e7ed8624ed77300f10252a13fa392639634ee", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "patch": "@@ -25,7 +25,6 @@ use hir as ast;\n use hir::map::{self, Node};\n use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n-use middle::cstore::{InlinedItem, InlinedItemKind};\n use syntax::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n use syntax_pos::Span;\n@@ -152,7 +151,6 @@ impl<'a> FnLikeNode<'a> {\n             map::NodeTraitItem(tm) => tm.is_fn_like(),\n             map::NodeImplItem(_) => true,\n             map::NodeExpr(e) => e.is_fn_like(),\n-            map::NodeInlinedItem(ii) => ii.is_fn(),\n             _ => false\n         };\n         if fn_like {\n@@ -175,21 +173,12 @@ impl<'a> FnLikeNode<'a> {\n     }\n \n     pub fn body(self) -> ast::ExprId {\n-        if let map::NodeInlinedItem(ii) = self.node {\n-            return ast::ExprId(ii.body.id);\n-        }\n         self.handle(|i: ItemFnParts<'a>|  i.body,\n                     |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n-        if let map::NodeInlinedItem(&InlinedItem {\n-            kind: InlinedItemKind::Fn(ref decl),\n-            ..\n-        }) = self.node {\n-            return &decl;\n-        }\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n                     |_, _, sig: &'a ast::MethodSig, _, _, _, _|  &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n@@ -208,9 +197,6 @@ impl<'a> FnLikeNode<'a> {\n     }\n \n     pub fn constness(self) -> ast::Constness {\n-        if let map::NodeInlinedItem(..) = self.node {\n-            return ast::Constness::Const;\n-        }\n         match self.kind() {\n             FnKind::ItemFn(_, _, _, constness, ..) => {\n                 constness"}, {"sha": "4fd8f96ba046a7a74526317c37d12a2bd09a69f6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "patch": "@@ -870,6 +870,12 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>,\n }\n \n+impl Expr {\n+    pub fn expr_id(&self) -> ExprId {\n+        ExprId(self.id)\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, print::expr_to_string(self))"}, {"sha": "022cca5e7f28197ade9a60d7dfe0886d1354c79a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 24, "deletions": 45, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "patch": "@@ -43,7 +43,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::{self, Visitor};\n+use hir::intravisit::Visitor;\n use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -140,54 +140,47 @@ pub struct NativeLibrary {\n pub struct InlinedItem {\n     pub def_id: DefId,\n     pub body: P<hir::Expr>,\n-    pub kind: InlinedItemKind,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItemKind {\n-    Const(P<hir::Ty>),\n-    Fn(P<hir::FnDecl>)\n+    pub const_fn_args: Vec<DefId>,\n }\n \n /// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n /// a crate; it then gets read as an InlinedItem.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n pub struct InlinedItemRef<'a> {\n     pub def_id: DefId,\n     pub body: &'a hir::Expr,\n-    pub kind: InlinedItemKindRef<'a>,\n+    pub const_fn_args: Vec<DefId>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n-pub enum InlinedItemKindRef<'a> {\n-    Const(&'a hir::Ty),\n-    Fn(&'a hir::FnDecl)\n+fn get_fn_args(tcx: TyCtxt, decl: &hir::FnDecl) -> Vec<DefId> {\n+    decl.inputs.iter().map(|arg| tcx.expect_def(arg.pat.id).def_id()).collect()\n }\n \n impl<'a> InlinedItemRef<'a> {\n-    pub fn from_item<'ast: 'a>(def_id: DefId,\n+    pub fn from_item<'b, 'tcx>(def_id: DefId,\n                                item: &'a hir::Item,\n-                               map: &hir_map::Map<'ast>)\n+                               tcx: TyCtxt<'b, 'a, 'tcx>)\n                                -> InlinedItemRef<'a> {\n-        let (body, kind) = match item.node {\n+        let (body, args) = match item.node {\n             hir::ItemFn(ref decl, _, _, _, _, body_id) =>\n-                (map.expr(body_id), InlinedItemKindRef::Fn(&decl)),\n-            hir::ItemConst(ref ty, ref body) => (&**body, InlinedItemKindRef::Const(ty)),\n+                (tcx.map.expr(body_id), get_fn_args(tcx, decl)),\n+            hir::ItemConst(_, ref body) => (&**body, Vec::new()),\n             _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n             body: body,\n-            kind: kind\n+            const_fn_args: args\n         }\n     }\n \n     pub fn from_trait_item(def_id: DefId,\n                            item: &'a hir::TraitItem,\n-                           _map: &hir_map::Map)\n+                           _tcx: TyCtxt)\n                            -> InlinedItemRef<'a> {\n-        let (body, kind) = match item.node {\n-            hir::ConstTraitItem(ref ty, Some(ref body)) => (&**body, InlinedItemKindRef::Const(ty)),\n+        let (body, args) = match item.node {\n+            hir::ConstTraitItem(_, Some(ref body)) =>\n+                (&**body, Vec::new()),\n             hir::ConstTraitItem(_, None) => {\n                 bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n             },\n@@ -196,35 +189,32 @@ impl<'a> InlinedItemRef<'a> {\n         InlinedItemRef {\n             def_id: def_id,\n             body: body,\n-            kind: kind\n+            const_fn_args: args\n         }\n     }\n \n-    pub fn from_impl_item<'ast: 'a>(def_id: DefId,\n+    pub fn from_impl_item<'b, 'tcx>(def_id: DefId,\n                                     item: &'a hir::ImplItem,\n-                                    map: &hir_map::Map<'ast>)\n+                                    tcx: TyCtxt<'b, 'a, 'tcx>)\n                                     -> InlinedItemRef<'a> {\n-        let (body, kind) = match item.node {\n+        let (body, args) = match item.node {\n             hir::ImplItemKind::Method(ref sig, body_id) =>\n-                (map.expr(body_id), InlinedItemKindRef::Fn(&sig.decl)),\n-            hir::ImplItemKind::Const(ref ty, ref body) => (&**body, InlinedItemKindRef::Const(ty)),\n+                (tcx.map.expr(body_id), get_fn_args(tcx, &sig.decl)),\n+            hir::ImplItemKind::Const(_, ref body) =>\n+                (&**body, Vec::new()),\n             _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n             body: body,\n-            kind: kind\n+            const_fn_args: args\n         }\n     }\n \n     pub fn visit<V>(&self, visitor: &mut V)\n         where V: Visitor<'a>\n     {\n         visitor.visit_expr(&self.body);\n-        match self.kind {\n-            InlinedItemKindRef::Const(ty) => visitor.visit_ty(ty),\n-            InlinedItemKindRef::Fn(decl) => intravisit::walk_fn_decl(visitor, decl)\n-        }\n     }\n }\n \n@@ -233,17 +223,6 @@ impl InlinedItem {\n         where V: Visitor<'ast>\n     {\n         visitor.visit_expr(&self.body);\n-        match self.kind {\n-            InlinedItemKind::Const(ref ty) => visitor.visit_ty(ty),\n-            InlinedItemKind::Fn(ref decl) => intravisit::walk_fn_decl(visitor, decl)\n-        }\n-    }\n-\n-    pub fn is_fn(&self) -> bool {\n-        match self.kind {\n-            InlinedItemKind::Const(_) => false,\n-            InlinedItemKind::Fn(_) => true\n-        }\n     }\n }\n "}, {"sha": "6e074d8f53b3731d36c6712b508b526d813615c0", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "patch": "@@ -17,7 +17,7 @@ use self::EvalHint::*;\n \n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::cstore::{InlinedItem, InlinedItemKind};\n+use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -142,9 +142,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem { body: ref const_expr,\n-                                 kind: InlinedItemKind::Const(ref ty), .. }, _)) => {\n-                Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n+            Some((&InlinedItem { body: ref const_expr, .. }, _)) => {\n+                Some((&**const_expr, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n             }\n             _ => None\n         };\n@@ -166,8 +165,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 } else {\n                     expr_ty\n                 }\n-            }\n-            _ => expr_ty\n+            },\n+            Some(Def::Const(..)) => expr_ty,\n+            _ => None\n         };\n         // If we used the substitutions, particularly to choose an impl\n         // of a trait-associated const, don't cache that, because the next\n@@ -195,23 +195,29 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return None;\n     }\n \n-    let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        Some((&InlinedItem { kind: InlinedItemKind::Fn(_), .. }, node_id)) => Some(node_id),\n-        _ => None\n-    };\n+    let fn_id = tcx.sess.cstore.maybe_get_item_ast(tcx, def_id).map(|t| t.1);\n     tcx.extern_const_fns.borrow_mut().insert(def_id,\n                                              fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n     fn_id\n }\n \n+pub enum ConstFnNode<'tcx> {\n+    Local(FnLikeNode<'tcx>),\n+    Inlined(&'tcx InlinedItem)\n+}\n+\n pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                       -> Option<FnLikeNode<'tcx>>\n+                                       -> Option<ConstFnNode<'tcx>>\n {\n     let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         node_id\n     } else {\n         if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n-            fn_id\n+            if let ast_map::NodeInlinedItem(ii) = tcx.map.get(fn_id) {\n+                return Some(ConstFnNode::Inlined(ii));\n+            } else {\n+                bug!(\"Got const fn from external crate, but it's not inlined\")\n+            }\n         } else {\n             return None;\n         }\n@@ -223,7 +229,7 @@ pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n     };\n \n     if fn_like.constness() == hir::Constness::Const {\n-        Some(fn_like)\n+        Some(ConstFnNode::Local(fn_like))\n     } else {\n         None\n     }\n@@ -858,16 +864,19 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (decl, body_id) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n-              (fn_like.decl(), fn_like.body())\n-          } else {\n-              signal!(e, NonConstPath)\n+          let (arg_defs, body_id) = match lookup_const_fn_by_id(tcx, did) {\n+              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), ii.body.expr_id()),\n+              Some(ConstFnNode::Local(fn_like)) =>\n+                  (fn_like.decl().inputs.iter()\n+                   .map(|arg| tcx.expect_def(arg.pat.id).def_id()).collect(),\n+                   fn_like.body()),\n+              None => signal!(e, NonConstPath),\n           };\n           let result = tcx.map.expr(body_id);\n-          assert_eq!(decl.inputs.len(), args.len());\n+          assert_eq!(arg_defs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n-          for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n+          for (arg, arg_expr) in arg_defs.iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n               let arg_val = eval_const_expr_partial(\n                   tcx,"}, {"sha": "67b0be0dfcdac33907d67d03e7f71d5fb81f0dc4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // (InlinedItemRef::from_trait_item panics otherwise)\n                 let trait_def_id = trait_item.container.id();\n                 Some(self.encode_inlined_item(\n-                    InlinedItemRef::from_trait_item(trait_def_id, ast_item, &tcx.map)\n+                    InlinedItemRef::from_trait_item(trait_def_id, ast_item, tcx)\n                 ))\n             } else {\n                 None\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ast: if ast {\n                 Some(self.encode_inlined_item(\n-                    InlinedItemRef::from_impl_item(impl_def_id, ast_item, &tcx.map)\n+                    InlinedItemRef::from_impl_item(impl_def_id, ast_item, tcx)\n                 ))\n             } else {\n                 None\n@@ -826,7 +826,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemConst(..) |\n                 hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n                     Some(self.encode_inlined_item(\n-                        InlinedItemRef::from_item(def_id, item, &tcx.map)\n+                        InlinedItemRef::from_item(def_id, item, tcx)\n                     ))\n                 }\n                 _ => None,"}, {"sha": "94110ca58f8561327c84e54031ee7166e2c13d02", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ae2c814232bcffd83bbb2e3653dfb8c8746975/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=d0ae2c814232bcffd83bbb2e3653dfb8c8746975", "patch": "@@ -27,7 +27,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n-use rustc_const_eval::{eval_const_expr_partial, lookup_const_by_id};\n+use rustc_const_eval::{ConstFnNode, eval_const_expr_partial, lookup_const_by_id};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n use rustc_const_eval::ErrKind::UnresolvedPath;\n@@ -180,30 +180,39 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n-        if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n-            let node_id = fn_like.body().node_id();\n-            let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(node_id) {\n-                Entry::Occupied(entry) => Some(*entry.get()),\n-                _ => None\n-            };\n+        match lookup_const_fn_by_id(self.tcx, def_id) {\n+            Some(ConstFnNode::Local(fn_like)) => {\n+                let qualif = self.fn_like(fn_like.kind(),\n+                                          fn_like.decl(),\n+                                          fn_like.body(),\n+                                          fn_like.span(),\n+                                          fn_like.id());\n+\n+                self.add_qualif(qualif);\n \n-            let qualif = qualif.unwrap_or_else(|| {\n-                self.fn_like(fn_like.kind(),\n-                             fn_like.decl(),\n-                             fn_like.body(),\n-                             fn_like.span(),\n-                             fn_like.id())\n-            });\n+                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n+                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n+                }\n \n-            self.add_qualif(qualif);\n+                true\n+            },\n+            Some(ConstFnNode::Inlined(ii)) => {\n+                let node_id = ii.body.id;\n \n-            if ret_ty.type_contents(self.tcx).interior_unsafe() {\n-                self.add_qualif(ConstQualif::MUTABLE_MEM);\n-            }\n+                let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(node_id) {\n+                    Entry::Occupied(entry) => *entry.get(),\n+                    _ => bug!(\"const qualif entry missing for inlined item\")\n+                };\n+\n+                self.add_qualif(qualif);\n+\n+                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n+                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n+                }\n \n-            true\n-        } else {\n-            false\n+                true\n+            },\n+            None => false\n         }\n     }\n "}]}