{"sha": "90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6", "node_id": "C_kwDOAAsO6NoAKDkwY2IwZmEyZjM3OWQ3ZmRmOGJmZDk3MzA2ZTk3YzZhMGQ2ZmJiYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-16T21:17:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-16T21:17:46Z"}, "message": "Auto merge of #10652 - blyxyas:book-macro_expansions, r=flip1995\n\nClippy Book Chapter Updates Reborn: Macro Expansions\n\nThis PR adds a new chapter to the book: \"Macro Expansions\". There weren't big changes apart from grammar, re-phrasing and stylistic choices.\n\n## Notes\n\n- **Does not require any other chapter** to be merged before this\n- To talk about the whole project, please use the tracking issue for the project #10597 (It also contains a timeline, discussions and more information)\n\nchangelog: Add a new \"Macro Expansions\" chapter to the book\n\nr? `@flip1995`", "tree": {"sha": "9cb81677c51ee61960e96f169ee785d998f8011d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cb81677c51ee61960e96f169ee785d998f8011d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6", "html_url": "https://github.com/rust-lang/rust/commit/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a34e75be592bf1dae4ccb8bfbd5b9e259a698388", "url": "https://api.github.com/repos/rust-lang/rust/commits/a34e75be592bf1dae4ccb8bfbd5b9e259a698388", "html_url": "https://github.com/rust-lang/rust/commit/a34e75be592bf1dae4ccb8bfbd5b9e259a698388"}, {"sha": "e3a352d0bb5345489e1a1995adab1acfd3687055", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a352d0bb5345489e1a1995adab1acfd3687055", "html_url": "https://github.com/rust-lang/rust/commit/e3a352d0bb5345489e1a1995adab1acfd3687055"}], "stats": {"total": 159, "additions": 159, "deletions": 0}, "files": [{"sha": "22fbdce75e8f88dff32c1443c040a6c4be359208", "filename": "book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6/book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6/book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FSUMMARY.md?ref=90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6", "patch": "@@ -15,6 +15,7 @@\n     - [Adding Lints](development/adding_lints.md)\n     - [Lint Passes](development/lint_passes.md)\n     - [Type Checking](development/type_checking.md)\n+    - [Macro Expansions](development/macro_expansions.md)\n     - [Common Tools](development/common_tools_writing_lints.md)\n     - [Infrastructure](development/infrastructure/README.md)\n         - [Syncing changes between Clippy and rust-lang/rust](development/infrastructure/sync.md)"}, {"sha": "c5eb000272d39e348900c5448bb2c55b6ee62e42", "filename": "book/src/development/macro_expansions.md", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6/book%2Fsrc%2Fdevelopment%2Fmacro_expansions.md", "raw_url": "https://github.com/rust-lang/rust/raw/90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6/book%2Fsrc%2Fdevelopment%2Fmacro_expansions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fmacro_expansions.md?ref=90cb0fa2f379d7fdf8bfd97306e97c6a0d6fbbc6", "patch": "@@ -0,0 +1,158 @@\n+# Dealing with macros and expansions\n+\n+Sometimes we might encounter Rust macro expansions while working with Clippy.\n+While macro expansions are not as dramatic and profound as the expansion\n+of our universe, they can certainly bring chaos to the orderly world\n+of code and logic.\n+\n+The general rule of thumb is that we should ignore code with macro\n+expansions when working with Clippy because the code can be dynamic\n+in ways that are difficult or impossible for us to foresee.\n+\n+## False Positives\n+\n+What exactly do we mean by _dynamic in ways that are difficult to foresee_?\n+\n+Macros are [expanded][expansion] in the `EarlyLintPass` level,\n+so the Abstract Syntax Tree (AST) is generated in place of macros.\n+This means the code which we work with in Clippy is already expanded.\n+\n+If we wrote a new lint, there is a possibility that the lint is\n+triggered in macro-generated code. Since this expanded macro code\n+is not written by the macro's user but really by the macro's author,\n+the user cannot and should not be responsible for fixing the issue\n+that triggers the lint.\n+\n+Besides, a [Span] in a macro can be changed by the macro author.\n+Therefore, any lint check related to lines or columns should be\n+avoided since they might be changed at any time and become unreliable\n+or incorrect information.\n+\n+Because of these unforeseeable or unstable behaviors, macro expansion\n+should often not be regarded as a part of the stable API.\n+This is also why most lints check if they are inside a macro or not\n+before emitting suggestions to the end user to avoid false positives.\n+\n+## How to Work with Macros\n+\n+Several functions are available for working with macros.\n+\n+### The `Span.from_expansion` method\n+\n+We could utilize a `span`'s [`from_expansion`] method, which\n+detects if the `span` is from a macro expansion / desugaring.\n+This is a very common first step in a lint:\n+\n+```rust\n+if expr.span.from_expansion() {\n+    // We most likely want to ignore it.\n+    return;\n+}\n+```\n+\n+### `Span.ctxt` method\n+\n+The `span`'s context, given by the method [`ctxt`] and returning [SpanContext],\n+represents if the span is from a macro expansion and, if it is, which\n+macro call expanded this span.\n+\n+Sometimes, it is useful to check if the context of two spans are equal.\n+For instance, suppose we have the following line of code that would\n+expand into `1 + 0`:\n+\n+```rust\n+// The following code expands to `1 + 0` for both `EarlyLintPass` and `LateLintPass`\n+1 + mac!()\n+```\n+\n+Assuming that we'd collect the `1` expression as a variable `left` and the\n+`0`/`mac!()` expression as a variable `right`, we can simply compare their\n+contexts. If the context is different, then we most likely are dealing with a\n+macro expansion and should just ignore it:\n+\n+```rust\n+if left.span.ctxt() != right.span.ctxt() {\n+    // The code author most likely cannot modify this expression\n+    return;\n+}\n+```\n+\n+> **Note**: Code that is not from expansion is in the \"root\" context.\n+> So any spans whose `from_expansion` returns `false` can be assumed\n+> to have the same context. Because of this, using `span.from_expansion()`\n+> is often sufficient.\n+\n+Going a bit deeper, in a simple expression such as `a == b`,\n+`a` and `b` have the same context.\n+However, in a `macro_rules!` with `a == $b`, `$b` is expanded to\n+an expression that contains a different context from `a`.\n+\n+Take a look at the following macro `m`:\n+\n+```rust\n+macro_rules! m {\n+    ($a:expr, $b:expr) => {\n+        if $a.is_some() {\n+            $b;\n+        }\n+    }\n+}\n+\n+let x: Option<u32> = Some(42);\n+m!(x, x.unwrap());\n+```\n+\n+If the `m!(x, x.unwrapp());` line is expanded, we would get two expanded\n+expressions:\n+\n+- `x.is_some()` (from the `$a.is_some()` line in the `m` macro)\n+- `x.unwrap()` (corresponding to `$b` in the `m` macro)\n+\n+Suppose `x.is_some()` expression's span is associated with the `x_is_some_span` variable\n+and `x.unwrap()` expression's span is associated with `x_unwrap_span` variable,\n+we could assume that these two spans do not share the same context:\n+\n+```rust\n+// x.is_some() is from inside the macro\n+// x.unwrap() is from outside the macro\n+assert_ne!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n+```\n+\n+### The `in_external_macro` function\n+\n+`rustc_middle::lint` provides a function ([`in_external_macro`]) that can\n+detect if the given span is from a macro defined in a foreign crate.\n+\n+Therefore, if we really want a new lint to work with macro-generated code,\n+this is the next line of defense to avoid macros not defined inside\n+the current crate since it is unfair to the user if Clippy lints code\n+which the user cannot change.\n+\n+For example, assume we have the following code that is being examined\n+by Clippy:\n+\n+```rust\n+#[macro_use]\n+extern crate a_foreign_crate_with_macros;\n+\n+// `foo` macro is defined in `a_foreign_crate_with_macros`\n+foo!(\"bar\");\n+```\n+\n+Also assume that we get the corresponding variable `foo_span` for the\n+`foo` macro call, we could decide not to lint if `in_external_macro`\n+results in `true` (note that `cx` can be `EarlyContext` or `LateContext`):\n+\n+```rust\n+if in_external_macro(cx.sess(), foo_span) {\n+    // We should ignore macro from a foreign crate.\n+    return;\n+}\n+```\n+\n+[`ctxt`]: https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.ctxt\n+[expansion]: https://rustc-dev-guide.rust-lang.org/macro-expansion.html#expansion-and-ast-integration\n+[`from_expansion`]: https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n+[`in_external_macro`]: https://doc.rust-lang.org/stable/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html\n+[Span]: https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html\n+[SpanContext]: https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html"}]}