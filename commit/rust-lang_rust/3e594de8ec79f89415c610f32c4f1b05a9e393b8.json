{"sha": "3e594de8ec79f89415c610f32c4f1b05a9e393b8", "node_id": "C_kwDOAAsO6NoAKDNlNTk0ZGU4ZWM3OWY4OTQxNWM2MTBmMzJjNGYxYjA1YTllMzkzYjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T15:55:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T15:55:05Z"}, "message": "Auto merge of #9349 - Alexendoo:format-args-expn, r=flip1995\n\nRefactor `FormatArgsExpn`\n\nIt now for each format argument `{..}` has:\n- The `Expr` it points to, and how it does so (named/named inline/numbered/implicit)\n- The parsed `FormatSpec` (format trait/fill/align/etc., the precision/width and any value they point to)\n- Many spans\n\nThe caller no longer needs to pair up arguments to their value, or separately interpret the `specs` `Expr`s when it isn't `None`\n\nThe gist is that it combines the result of [`rustc_parse_format::Parser`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse_format/struct.Parser.html) with the macro expansion itself\n\nThis unfortunately makes the code a bit longer, however we need to use both as neither have all the information we're after. `rustc_parse_format` doesn't have the information to resolve named arguments to their values. The macro expansion doesn't contain whether the positions are implicit/numbered/named, or the spans for format arguments\n\nWanted by #9233 and #8518 to be able to port the changes from #9040\n\nAlso fixes #8643, previously the format args seem to have been paired up with the wrong values somehow\n\nchangelog: [`format_in_format_args`]: Fix false positive due to misattributed arguments\n\nr? `@flip1995`\ncc `@nyurik`", "tree": {"sha": "0adf7006560ef4250a540f287730e6a08ed2f0fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0adf7006560ef4250a540f287730e6a08ed2f0fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e594de8ec79f89415c610f32c4f1b05a9e393b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e594de8ec79f89415c610f32c4f1b05a9e393b8", "html_url": "https://github.com/rust-lang/rust/commit/3e594de8ec79f89415c610f32c4f1b05a9e393b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e594de8ec79f89415c610f32c4f1b05a9e393b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "477c16d45bb93cc92611b56614ce2b823bffab8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/477c16d45bb93cc92611b56614ce2b823bffab8d", "html_url": "https://github.com/rust-lang/rust/commit/477c16d45bb93cc92611b56614ce2b823bffab8d"}, {"sha": "4f049f5a695b003168125a3251f5c0295e64f261", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f049f5a695b003168125a3251f5c0295e64f261", "html_url": "https://github.com/rust-lang/rust/commit/4f049f5a695b003168125a3251f5c0295e64f261"}], "stats": {"total": 833, "additions": 580, "deletions": 253}, "files": [{"sha": "0c5851cdbed2a4241e0a3f2d35901f311dd732ec", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n-use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -56,29 +56,27 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n         };\n \n         let mut applicability = Applicability::MachineApplicable;\n-        if format_args.value_args.is_empty() {\n-            match *format_args.format_string_parts {\n+        if format_args.args.is_empty() {\n+            match *format_args.format_string.parts {\n                 [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n                 [_] => {\n-                    if let Some(s_src) = snippet_opt(cx, format_args.format_string_span) {\n-                        // Simulate macro expansion, converting {{ and }} to { and }.\n-                        let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                        let sugg = format!(\"{}.to_string()\", s_expand);\n-                        span_useless_format(cx, call_site, sugg, applicability);\n-                    }\n+                    // Simulate macro expansion, converting {{ and }} to { and }.\n+                    let s_expand = format_args.format_string.snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let sugg = format!(\"{}.to_string()\", s_expand);\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 },\n                 [..] => {},\n             }\n-        } else if let [value] = *format_args.value_args {\n+        } else if let [arg] = &*format_args.args {\n+            let value = arg.param.value;\n             if_chain! {\n-                if format_args.format_string_parts == [kw::Empty];\n+                if format_args.format_string.parts == [kw::Empty];\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n                     ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did()),\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if let Some(args) = format_args.args();\n-                if args.iter().all(|arg| arg.format_trait == sym::Display && !arg.has_string_formatting());\n+                if !arg.format.has_string_formatting();\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "5347ff880ce010826103879c8d9ac741e72a6919", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::is_diag_trait_item;\n-use clippy_utils::macros::{is_format_macro, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::macros::{is_format_macro, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n use if_chain::if_chain;\n+use itertools::Itertools;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n@@ -74,20 +75,16 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n             if is_format_macro(cx, macro_def_id);\n             if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n-            if let Some(args) = format_args.args();\n             then {\n-                for (i, arg) in args.iter().enumerate() {\n-                    if arg.format_trait != sym::Display {\n+                for arg in &format_args.args {\n+                    if arg.format.has_string_formatting() {\n                         continue;\n                     }\n-                    if arg.has_string_formatting() {\n+                    if is_aliased(&format_args, arg.param.value.hir_id) {\n                         continue;\n                     }\n-                    if is_aliased(&args, i) {\n-                        continue;\n-                    }\n-                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.value);\n-                    check_to_string_in_format_args(cx, name, arg.value);\n+                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n+                    check_to_string_in_format_args(cx, name, arg.param.value);\n                 }\n             }\n         }\n@@ -167,12 +164,12 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n     }\n }\n \n-// Returns true if `args[i]` \"refers to\" or \"is referred to by\" another argument.\n-fn is_aliased(args: &[FormatArgsArg<'_>], i: usize) -> bool {\n-    let value = args[i].value;\n-    args.iter()\n-        .enumerate()\n-        .any(|(j, arg)| i != j && std::ptr::eq(value, arg.value))\n+// Returns true if `hir_id` is referred to by multiple format params\n+fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n+    args.params()\n+        .filter(|param| param.value.hir_id == hir_id)\n+        .at_most_one()\n+        .is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)"}, {"sha": "d8bc0bf08f2b314b8513902d14f6da434e229d74", "filename": "clippy_lints/src/format_impl.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArg, FormatArgsExpn};\n use clippy_utils::{get_parent_as_impl, is_diag_trait_item, path_to_local, peel_ref_operators};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -168,10 +168,9 @@ fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>,\n         if let macro_def_id = outer_macro.def_id;\n         if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n         if is_format_macro(cx, macro_def_id);\n-        if let Some(args) = format_args.args();\n         then {\n-            for arg in args {\n-                if arg.format_trait != impl_trait.name {\n+            for arg in format_args.args {\n+                if arg.format.r#trait != impl_trait.name {\n                     continue;\n                 }\n                 check_format_arg_self(cx, expr, &arg, impl_trait);\n@@ -180,11 +179,11 @@ fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>,\n     }\n }\n \n-fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArgsArg<'_>, impl_trait: FormatTrait) {\n+fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArg<'_>, impl_trait: FormatTrait) {\n     // Handle multiple dereferencing of references e.g. &&self\n     // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n     // Since the argument to fmt is itself a reference: &self\n-    let reference = peel_ref_operators(cx, arg.value);\n+    let reference = peel_ref_operators(cx, arg.param.value);\n     let map = cx.tcx.hir();\n     // Is the reference self?\n     if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {"}, {"sha": "a1c6294737cf87225631efca472c0ed5f03e93cf", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expr_diagnostic_item, ty::is_uninit_value_valid_for_ty};\n+use clippy_utils::{is_path_diagnostic_item, ty::is_uninit_value_valid_for_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -12,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n     if_chain! {\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n-        if is_expr_diagnostic_item(cx, callee, sym::maybe_uninit_uninit);\n+        if is_path_diagnostic_item(cx, callee, sym::maybe_uninit_uninit);\n         if !is_uninit_value_valid_for_ty(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint("}, {"sha": "d8e349af7af8e46ecbcb64897054ddbade8f7cca", "filename": "clippy_lints/src/transmute/transmuting_null.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_expr_diagnostic_item;\n+use clippy_utils::is_path_diagnostic_item;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n@@ -45,7 +45,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n     // `std::mem::transmute(std::ptr::null::<i32>())`\n     if_chain! {\n         if let ExprKind::Call(func1, []) = arg.kind;\n-        if is_expr_diagnostic_item(cx, func1, sym::ptr_null);\n+        if is_path_diagnostic_item(cx, func1, sym::ptr_null);\n         then {\n             span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n             return true;"}, {"sha": "c36bca06507d67b8544dd51850235166b9cf0015", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -7,6 +7,7 @@ publish = false\n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n if_chain = \"1.0\"\n+itertools = \"0.10.1\"\n rustc-semver = \"1.1\"\n \n [features]"}, {"sha": "9308f085214f159fdb4d5b8418bc905f3855a1a8", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -27,6 +27,7 @@ extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n+extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -371,15 +372,19 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n \n /// If the expression is a path, resolves it to a `DefId` and checks if it matches the given path.\n ///\n-/// Please use `is_expr_diagnostic_item` if the target is a diagnostic item.\n+/// Please use `is_path_diagnostic_item` if the target is a diagnostic item.\n pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[&str]) -> bool {\n     path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, segments))\n }\n \n-/// If the expression is a path, resolves it to a `DefId` and checks if it matches the given\n-/// diagnostic item.\n-pub fn is_expr_diagnostic_item(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol) -> bool {\n-    path_def_id(cx, expr).map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n+/// If `maybe_path` is a path node which resolves to an item, resolves it to a `DefId` and checks if\n+/// it matches the given diagnostic item.\n+pub fn is_path_diagnostic_item<'tcx>(\n+    cx: &LateContext<'_>,\n+    maybe_path: &impl MaybePath<'tcx>,\n+    diag_item: Symbol,\n+) -> bool {\n+    path_def_id(cx, maybe_path).map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n }\n \n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the"}, {"sha": "37d8f1e458df3a5d5e2d1567c36dde5e67f247e4", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 494, "deletions": 180, "changes": 674, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,16 +1,21 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n+use crate::is_path_diagnostic_item;\n+use crate::source::snippet_opt;\n use crate::visitors::expr_visitor_no_bodies;\n \n use arrayvec::ArrayVec;\n-use if_chain::if_chain;\n+use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n+use rustc_lexer::unescape::unescape_literal;\n+use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use rustc_lint::LateContext;\n+use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n-use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n use std::ops::ControlFlow;\n \n const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[\n@@ -332,121 +337,495 @@ fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) ->\n     }\n }\n \n-/// A parsed `format_args!` expansion\n+/// The format string doesn't exist in the HIR, so we reassemble it from source code\n #[derive(Debug)]\n-pub struct FormatArgsExpn<'tcx> {\n-    /// Span of the first argument, the format string\n-    pub format_string_span: Span,\n-    /// The format string split by formatted args like `{..}`\n-    pub format_string_parts: Vec<Symbol>,\n-    /// Values passed after the format string\n-    pub value_args: Vec<&'tcx Expr<'tcx>>,\n-    /// Each element is a `value_args` index and a formatting trait (e.g. `sym::Debug`)\n-    pub formatters: Vec<(usize, Symbol)>,\n-    /// List of `fmt::v1::Argument { .. }` expressions. If this is empty,\n-    /// then `formatters` represents the format args (`{..}`).\n-    /// If this is non-empty, it represents the format args, and the `position`\n-    /// parameters within the struct expressions are indexes of `formatters`.\n-    pub specs: Vec<&'tcx Expr<'tcx>>,\n+pub struct FormatString {\n+    /// Span of the whole format string literal, including `[r#]\"`.\n+    pub span: Span,\n+    /// Snippet of the whole format string literal, including `[r#]\"`.\n+    pub snippet: String,\n+    /// If the string is raw `r\"...\"`/`r#\"\"#`, how many `#`s does it have on each side.\n+    pub style: Option<usize>,\n+    /// The unescaped value of the format string, e.g. `\"val \u2013 {}\"` for the literal\n+    /// `\"val \\u{2013} {}\"`.\n+    pub unescaped: String,\n+    /// The format string split by format args like `{..}`.\n+    pub parts: Vec<Symbol>,\n }\n \n-impl<'tcx> FormatArgsExpn<'tcx> {\n-    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n-    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        macro_backtrace(expr.span).find(|macro_call| {\n-            matches!(\n-                cx.tcx.item_name(macro_call.def_id),\n-                sym::const_format_args | sym::format_args | sym::format_args_nl\n-            )\n-        })?;\n-        let mut format_string_span: Option<Span> = None;\n-        let mut format_string_parts: Vec<Symbol> = Vec::new();\n-        let mut value_args: Vec<&Expr<'_>> = Vec::new();\n-        let mut formatters: Vec<(usize, Symbol)> = Vec::new();\n-        let mut specs: Vec<&Expr<'_>> = Vec::new();\n-        expr_visitor_no_bodies(|e| {\n-            // if we're still inside of the macro definition...\n-            if e.span.ctxt() == expr.span.ctxt() {\n-                // ArgumentV1::new_<format_trait>(<value>)\n-                if_chain! {\n-                    if let ExprKind::Call(callee, [val]) = e.kind;\n-                    if let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind;\n-                    if let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-                    if path.segments.last().unwrap().ident.name == sym::ArgumentV1;\n-                    if seg.ident.name.as_str().starts_with(\"new_\");\n-                    then {\n-                        let val_idx = if_chain! {\n-                            if val.span.ctxt() == expr.span.ctxt();\n-                            if let ExprKind::Field(_, field) = val.kind;\n-                            if let Ok(idx) = field.name.as_str().parse();\n-                            then {\n-                                // tuple index\n-                                idx\n-                            } else {\n-                                // assume the value expression is passed directly\n-                                formatters.len()\n-                            }\n-                        };\n-                        let fmt_trait = match seg.ident.name.as_str() {\n-                            \"new_display\" => \"Display\",\n-                            \"new_debug\" => \"Debug\",\n-                            \"new_lower_exp\" => \"LowerExp\",\n-                            \"new_upper_exp\" => \"UpperExp\",\n-                            \"new_octal\" => \"Octal\",\n-                            \"new_pointer\" => \"Pointer\",\n-                            \"new_binary\" => \"Binary\",\n-                            \"new_lower_hex\" => \"LowerHex\",\n-                            \"new_upper_hex\" => \"UpperHex\",\n-                            _ => unreachable!(),\n-                        };\n-                        formatters.push((val_idx, Symbol::intern(fmt_trait)));\n-                    }\n-                }\n-                if let ExprKind::Struct(QPath::Resolved(_, path), ..) = e.kind {\n-                    if path.segments.last().unwrap().ident.name == sym::Argument {\n-                        specs.push(e);\n-                    }\n+impl FormatString {\n+    fn new(cx: &LateContext<'_>, pieces: &Expr<'_>) -> Option<Self> {\n+        // format_args!(r\"a {} b \\\", 1);\n+        //\n+        // expands to\n+        //\n+        // ::core::fmt::Arguments::new_v1(&[\"a \", \" b \\\\\"],\n+        //      &[::core::fmt::ArgumentV1::new_display(&1)]);\n+        //\n+        // where `pieces` is the expression `&[\"a \", \" b \\\\\"]`. It has the span of `r\"a {} b \\\"`\n+        let span = pieces.span;\n+        let snippet = snippet_opt(cx, span)?;\n+\n+        let (inner, style) = match tokenize(&snippet).next()?.kind {\n+            TokenKind::Literal { kind, .. } => {\n+                let style = match kind {\n+                    LiteralKind::Str { .. } => None,\n+                    LiteralKind::RawStr { n_hashes: Some(n), .. } => Some(n.into()),\n+                    _ => return None,\n+                };\n+\n+                let start = style.map_or(1, |n| 2 + n);\n+                let end = snippet.len() - style.map_or(1, |n| 1 + n);\n+\n+                (&snippet[start..end], style)\n+            },\n+            _ => return None,\n+        };\n+\n+        let mode = if style.is_some() {\n+            unescape::Mode::RawStr\n+        } else {\n+            unescape::Mode::Str\n+        };\n+\n+        let mut unescaped = String::with_capacity(inner.len());\n+        unescape_literal(inner, mode, &mut |_, ch| {\n+            unescaped.push(ch.unwrap());\n+        });\n+\n+        let mut parts = Vec::new();\n+        expr_visitor_no_bodies(|expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind {\n+                if let LitKind::Str(symbol, _) = lit.node {\n+                    parts.push(symbol);\n                 }\n-                // walk through the macro expansion\n-                return true;\n             }\n-            // assume that the first expr with a differing context represents\n-            // (and has the span of) the format string\n-            if format_string_span.is_none() {\n-                format_string_span = Some(e.span);\n-                let span = e.span;\n-                // walk the expr and collect string literals which are format string parts\n-                expr_visitor_no_bodies(|e| {\n-                    if e.span.ctxt() != span.ctxt() {\n-                        // defensive check, probably doesn't happen\n-                        return false;\n-                    }\n-                    if let ExprKind::Lit(lit) = &e.kind {\n-                        if let LitKind::Str(symbol, _s) = lit.node {\n-                            format_string_parts.push(symbol);\n-                        }\n-                    }\n-                    true\n-                })\n-                .visit_expr(e);\n+\n+            true\n+        })\n+        .visit_expr(pieces);\n+\n+        Some(Self {\n+            span,\n+            snippet,\n+            style,\n+            unescaped,\n+            parts,\n+        })\n+    }\n+}\n+\n+struct FormatArgsValues<'tcx> {\n+    /// See `FormatArgsExpn::value_args`\n+    value_args: Vec<&'tcx Expr<'tcx>>,\n+    /// Maps an `rt::v1::Argument::position` or an `rt::v1::Count::Param` to its index in\n+    /// `value_args`\n+    pos_to_value_index: Vec<usize>,\n+    /// Used to check if a value is declared inline & to resolve `InnerSpan`s.\n+    format_string_span: SpanData,\n+}\n+\n+impl<'tcx> FormatArgsValues<'tcx> {\n+    fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n+        let mut pos_to_value_index = Vec::new();\n+        let mut value_args = Vec::new();\n+        expr_visitor_no_bodies(|expr| {\n+            if expr.span.ctxt() == args.span.ctxt() {\n+                // ArgumentV1::new_<format_trait>(<val>)\n+                // ArgumentV1::from_usize(<val>)\n+                if let ExprKind::Call(callee, [val]) = expr.kind\n+                    && let ExprKind::Path(QPath::TypeRelative(ty, _)) = callee.kind\n+                    && let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind\n+                    && path.segments.last().unwrap().ident.name == sym::ArgumentV1\n+                {\n+                    let val_idx = if val.span.ctxt() == expr.span.ctxt()\n+                        && let ExprKind::Field(_, field) = val.kind\n+                        && let Ok(idx) = field.name.as_str().parse()\n+                    {\n+                        // tuple index\n+                        idx\n+                    } else {\n+                        // assume the value expression is passed directly\n+                        pos_to_value_index.len()\n+                    };\n+\n+                    pos_to_value_index.push(val_idx);\n+                }\n+\n+                true\n             } else {\n-                // assume that any further exprs with a differing context are value args\n-                value_args.push(e);\n+                // assume that any expr with a differing span is a value\n+                value_args.push(expr);\n+\n+                false\n             }\n-            // don't walk anything not from the macro expansion (e.a. inputs)\n-            false\n         })\n-        .visit_expr(expr);\n-        Some(FormatArgsExpn {\n-            format_string_span: format_string_span?,\n-            format_string_parts,\n+        .visit_expr(args);\n+\n+        Self {\n             value_args,\n-            formatters,\n-            specs,\n+            pos_to_value_index,\n+            format_string_span,\n+        }\n+    }\n+}\n+\n+/// The positions of a format argument's value, precision and width\n+///\n+/// A position is an index into the second argument of `Arguments::new_v1[_formatted]`\n+#[derive(Debug, Default, Copy, Clone)]\n+struct ParamPosition {\n+    /// The position stored in `rt::v1::Argument::position`.\n+    value: usize,\n+    /// The position stored in `rt::v1::FormatSpec::width` if it is a `Count::Param`.\n+    width: Option<usize>,\n+    /// The position stored in `rt::v1::FormatSpec::precision` if it is a `Count::Param`.\n+    precision: Option<usize>,\n+}\n+\n+/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n+fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n+    fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n+        // ::core::fmt::rt::v1::Count::Param(1usize),\n+        if let ExprKind::Call(ctor, [val]) = expr.kind\n+            && let ExprKind::Path(QPath::Resolved(_, path)) = ctor.kind\n+            && path.segments.last()?.ident.name == sym::Param\n+            && let ExprKind::Lit(lit) = &val.kind\n+            && let LitKind::Int(pos, _) = lit.node\n+        {\n+            Some(pos as usize)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n+        && let ExprKind::Array(specs) = array.kind\n+    {\n+        Some(specs.iter().map(|spec| {\n+            let mut position = ParamPosition::default();\n+\n+            // ::core::fmt::rt::v1::Argument {\n+            //     position: 0usize,\n+            //     format: ::core::fmt::rt::v1::FormatSpec {\n+            //         ..\n+            //         precision: ::core::fmt::rt::v1::Count::Implied,\n+            //         width: ::core::fmt::rt::v1::Count::Implied,\n+            //     },\n+            // }\n+\n+            // TODO: this can be made much nicer next sync with `Visitor::visit_expr_field`\n+            if let ExprKind::Struct(_, fields, _) = spec.kind {\n+                for field in fields {\n+                    match (field.ident.name, &field.expr.kind) {\n+                        (sym::position, ExprKind::Lit(lit)) => {\n+                            if let LitKind::Int(pos, _) = lit.node {\n+                                position.value = pos as usize;\n+                            }\n+                        },\n+                        (sym::format, &ExprKind::Struct(_, spec_fields, _)) => {\n+                            for spec_field in spec_fields {\n+                                match spec_field.ident.name {\n+                                    sym::precision => {\n+                                        position.precision = parse_count(spec_field.expr);\n+                                    },\n+                                    sym::width => {\n+                                        position.width = parse_count(spec_field.expr);\n+                                    },\n+                                    _ => {},\n+                                }\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                }\n+            }\n+\n+            position\n+        }))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// `Span::from_inner`, but for `rustc_parse_format`'s `InnerSpan`\n+fn span_from_inner(base: SpanData, inner: rpf::InnerSpan) -> Span {\n+    Span::new(\n+        base.lo + BytePos::from_usize(inner.start),\n+        base.lo + BytePos::from_usize(inner.end),\n+        base.ctxt,\n+        base.parent,\n+    )\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum FormatParamKind {\n+    /// An implicit parameter , such as `{}` or `{:?}`.\n+    Implicit,\n+    /// A parameter with an explicit number, or an asterisk precision. e.g. `{1}`, `{0:?}`,\n+    /// `{:.0$}` or `{:.*}`.\n+    Numbered,\n+    /// A named parameter with a named `value_arg`, such as the `x` in `format!(\"{x}\", x = 1)`.\n+    Named(Symbol),\n+    /// An implicit named paramter, such as the `y` in `format!(\"{y}\")`.\n+    NamedInline(Symbol),\n+}\n+\n+/// A `FormatParam` is any place in a `FormatArgument` that refers to a supplied value, e.g.\n+///\n+/// ```\n+/// let precision = 2;\n+/// format!(\"{:.precision$}\", 0.1234);\n+/// ```\n+///\n+/// has two `FormatParam`s, a [`FormatParamKind::Implicit`] `.kind` with a `.value` of `0.1234`\n+/// and a [`FormatParamKind::NamedInline(\"precision\")`] `.kind` with a `.value` of `2`\n+#[derive(Debug, Copy, Clone)]\n+pub struct FormatParam<'tcx> {\n+    /// The expression this parameter refers to.\n+    pub value: &'tcx Expr<'tcx>,\n+    /// How this paramter refers to its `value`.\n+    pub kind: FormatParamKind,\n+    /// Span of the parameter, may be zero width. Includes the whitespace of implicit parameters.\n+    ///\n+    /// ```text\n+    /// format!(\"{}, {  }, {0}, {name}\", ...);\n+    ///          ^    ~~    ~    ~~~~\n+    /// ```\n+    pub span: Span,\n+}\n+\n+impl<'tcx> FormatParam<'tcx> {\n+    fn new(\n+        mut kind: FormatParamKind,\n+        position: usize,\n+        inner: rpf::InnerSpan,\n+        values: &FormatArgsValues<'tcx>,\n+    ) -> Option<Self> {\n+        let value_index = *values.pos_to_value_index.get(position)?;\n+        let value = *values.value_args.get(value_index)?;\n+        let span = span_from_inner(values.format_string_span, inner);\n+\n+        // if a param is declared inline, e.g. `format!(\"{x}\")`, the generated expr's span points\n+        // into the format string\n+        if let FormatParamKind::Named(name) = kind && values.format_string_span.contains(value.span.data()) {\n+            kind = FormatParamKind::NamedInline(name);\n+        }\n+\n+        Some(Self { value, kind, span })\n+    }\n+}\n+\n+/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and\n+/// [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n+#[derive(Debug, Copy, Clone)]\n+pub enum Count<'tcx> {\n+    /// Specified with a literal number, stores the value.\n+    Is(usize, Span),\n+    /// Specified using `$` and `*` syntaxes. The `*` format is still considered to be\n+    /// `FormatParamKind::Numbered`.\n+    Param(FormatParam<'tcx>),\n+    /// Not specified.\n+    Implied,\n+}\n+\n+impl<'tcx> Count<'tcx> {\n+    fn new(\n+        count: rpf::Count<'_>,\n+        position: Option<usize>,\n+        inner: Option<rpf::InnerSpan>,\n+        values: &FormatArgsValues<'tcx>,\n+    ) -> Option<Self> {\n+        Some(match count {\n+            rpf::Count::CountIs(val) => Self::Is(val, span_from_inner(values.format_string_span, inner?)),\n+            rpf::Count::CountIsName(name, span) => Self::Param(FormatParam::new(\n+                FormatParamKind::Named(Symbol::intern(name)),\n+                position?,\n+                span,\n+                values,\n+            )?),\n+            rpf::Count::CountIsParam(_) => {\n+                Self::Param(FormatParam::new(FormatParamKind::Numbered, position?, inner?, values)?)\n+            },\n+            rpf::Count::CountImplied => Self::Implied,\n+        })\n+    }\n+\n+    pub fn is_implied(self) -> bool {\n+        matches!(self, Count::Implied)\n+    }\n+\n+    pub fn param(self) -> Option<FormatParam<'tcx>> {\n+        match self {\n+            Count::Param(param) => Some(param),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Specification for the formatting of an argument in the format string. See\n+/// <https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters> for the precise meanings.\n+#[derive(Debug)]\n+pub struct FormatSpec<'tcx> {\n+    /// Optionally specified character to fill alignment with.\n+    pub fill: Option<char>,\n+    /// Optionally specified alignment.\n+    pub align: Alignment,\n+    /// Packed version of various flags provided, see [`rustc_parse_format::Flag`].\n+    pub flags: u32,\n+    /// Represents either the maximum width or the integer precision.\n+    pub precision: Count<'tcx>,\n+    /// The minimum width, will be padded according to `width`/`align`\n+    pub width: Count<'tcx>,\n+    /// The formatting trait used by the argument, e.g. `sym::Display` for `{}`, `sym::Debug` for\n+    /// `{:?}`.\n+    pub r#trait: Symbol,\n+    pub trait_span: Option<Span>,\n+}\n+\n+impl<'tcx> FormatSpec<'tcx> {\n+    fn new(spec: rpf::FormatSpec<'_>, positions: ParamPosition, values: &FormatArgsValues<'tcx>) -> Option<Self> {\n+        Some(Self {\n+            fill: spec.fill,\n+            align: spec.align,\n+            flags: spec.flags,\n+            precision: Count::new(spec.precision, positions.precision, spec.precision_span, values)?,\n+            width: Count::new(spec.width, positions.width, spec.width_span, values)?,\n+            r#trait: match spec.ty {\n+                \"\" => sym::Display,\n+                \"?\" => sym::Debug,\n+                \"o\" => sym!(Octal),\n+                \"x\" => sym!(LowerHex),\n+                \"X\" => sym!(UpperHex),\n+                \"p\" => sym::Pointer,\n+                \"b\" => sym!(Binary),\n+                \"e\" => sym!(LowerExp),\n+                \"E\" => sym!(UpperExp),\n+                _ => return None,\n+            },\n+            trait_span: spec\n+                .ty_span\n+                .map(|span| span_from_inner(values.format_string_span, span)),\n         })\n     }\n \n-    /// Finds a nested call to `format_args!` within a `format!`-like macro call\n+    /// Returns true if this format spec would change the contents of a string when formatted\n+    pub fn has_string_formatting(&self) -> bool {\n+        self.r#trait != sym::Display || !self.width.is_implied() || !self.precision.is_implied()\n+    }\n+}\n+\n+/// A format argument, such as `{}`, `{foo:?}`.\n+#[derive(Debug)]\n+pub struct FormatArg<'tcx> {\n+    /// The parameter the argument refers to.\n+    pub param: FormatParam<'tcx>,\n+    /// How to format `param`.\n+    pub format: FormatSpec<'tcx>,\n+    /// span of the whole argument, `{..}`.\n+    pub span: Span,\n+}\n+\n+/// A parsed `format_args!` expansion.\n+#[derive(Debug)]\n+pub struct FormatArgsExpn<'tcx> {\n+    /// The format string literal.\n+    pub format_string: FormatString,\n+    // The format arguments, such as `{:?}`.\n+    pub args: Vec<FormatArg<'tcx>>,\n+    /// Has an added newline due to `println!()`/`writeln!()`/etc. The last format string part will\n+    /// include this added newline.\n+    pub newline: bool,\n+    /// Values passed after the format string and implicit captures. `[1, z + 2, x]` for\n+    /// `format!(\"{x} {} {y}\", 1, z + 2)`.\n+    value_args: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsExpn<'tcx> {\n+    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        let macro_name = macro_backtrace(expr.span)\n+            .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n+            .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n+        let newline = macro_name == sym::format_args_nl;\n+\n+        // ::core::fmt::Arguments::new_v1(pieces, args)\n+        // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n+        if let ExprKind::Call(callee, [pieces, args, rest @ ..]) = expr.kind\n+            && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n+            && is_path_diagnostic_item(cx, ty, sym::Arguments)\n+            && matches!(seg.ident.as_str(), \"new_v1\" | \"new_v1_formatted\")\n+        {\n+            let format_string = FormatString::new(cx, pieces)?;\n+\n+            let mut parser = rpf::Parser::new(\n+                &format_string.unescaped,\n+                format_string.style,\n+                Some(format_string.snippet.clone()),\n+                // `format_string.unescaped` does not contain the appended newline\n+                false,\n+                rpf::ParseMode::Format,\n+            );\n+\n+            let parsed_args = parser\n+                .by_ref()\n+                .filter_map(|piece| match piece {\n+                    rpf::Piece::NextArgument(a) => Some(a),\n+                    rpf::Piece::String(_) => None,\n+                })\n+                .collect_vec();\n+            if !parser.errors.is_empty() {\n+                return None;\n+            }\n+\n+            let positions = if let Some(fmt_arg) = rest.first() {\n+                // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n+                // them.\n+\n+                Either::Left(parse_rt_fmt(fmt_arg)?)\n+            } else {\n+                // If no format specs are given, the positions are in the given order and there are\n+                // no `precision`/`width`s to consider.\n+\n+                Either::Right((0..).map(|n| ParamPosition {\n+                    value: n,\n+                    width: None,\n+                    precision: None,\n+                }))\n+            };\n+\n+            let values = FormatArgsValues::new(args, format_string.span.data());\n+\n+            let args = izip!(positions, parsed_args, parser.arg_places)\n+                .map(|(position, parsed_arg, arg_span)| {\n+                    Some(FormatArg {\n+                        param: FormatParam::new(\n+                            match parsed_arg.position {\n+                                rpf::Position::ArgumentImplicitlyIs(_) => FormatParamKind::Implicit,\n+                                rpf::Position::ArgumentIs(_) => FormatParamKind::Numbered,\n+                                // NamedInline is handled by `FormatParam::new()`\n+                                rpf::Position::ArgumentNamed(name) => FormatParamKind::Named(Symbol::intern(name)),\n+                            },\n+                            position.value,\n+                            parsed_arg.position_span,\n+                            &values,\n+                        )?,\n+                        format: FormatSpec::new(parsed_arg.format, position, &values)?,\n+                        span: span_from_inner(values.format_string_span, arg_span),\n+                    })\n+                })\n+                .collect::<Option<Vec<_>>>()?;\n+\n+            Some(Self {\n+                format_string,\n+                args,\n+                value_args: values.value_args,\n+                newline,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n         let mut format_args = None;\n         expr_visitor_no_bodies(|e| {\n@@ -466,88 +845,23 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n         format_args\n     }\n \n-    /// Returns a vector of `FormatArgsArg`.\n-    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n-        if self.specs.is_empty() {\n-            let args = std::iter::zip(&self.value_args, &self.formatters)\n-                .map(|(value, &(_, format_trait))| FormatArgsArg {\n-                    value,\n-                    format_trait,\n-                    spec: None,\n-                })\n-                .collect();\n-            return Some(args);\n-        }\n-        self.specs\n-            .iter()\n-            .map(|spec| {\n-                if_chain! {\n-                    // struct `core::fmt::rt::v1::Argument`\n-                    if let ExprKind::Struct(_, fields, _) = spec.kind;\n-                    if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n-                    if let ExprKind::Lit(lit) = &position_field.expr.kind;\n-                    if let LitKind::Int(position, _) = lit.node;\n-                    if let Ok(i) = usize::try_from(position);\n-                    if let Some(&(j, format_trait)) = self.formatters.get(i);\n-                    then {\n-                        Some(FormatArgsArg {\n-                            value: self.value_args[j],\n-                            format_trait,\n-                            spec: Some(spec),\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n     /// Source callsite span of all inputs\n     pub fn inputs_span(&self) -> Span {\n         match *self.value_args {\n-            [] => self.format_string_span,\n+            [] => self.format_string.span,\n             [.., last] => self\n-                .format_string_span\n-                .to(hygiene::walk_chain(last.span, self.format_string_span.ctxt())),\n+                .format_string\n+                .span\n+                .to(hygiene::walk_chain(last.span, self.format_string.span.ctxt())),\n         }\n     }\n-}\n \n-/// Type representing a `FormatArgsExpn`'s format arguments\n-pub struct FormatArgsArg<'tcx> {\n-    /// An element of `value_args` according to `position`\n-    pub value: &'tcx Expr<'tcx>,\n-    /// An element of `args` according to `position`\n-    pub format_trait: Symbol,\n-    /// An element of `specs`\n-    pub spec: Option<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsArg<'tcx> {\n-    /// Returns true if any formatting parameters are used that would have an effect on strings,\n-    /// like `{:+2}` instead of just `{}`.\n-    pub fn has_string_formatting(&self) -> bool {\n-        self.spec.map_or(false, |spec| {\n-            // `!` because these conditions check that `self` is unformatted.\n-            !if_chain! {\n-                // struct `core::fmt::rt::v1::Argument`\n-                if let ExprKind::Struct(_, fields, _) = spec.kind;\n-                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n-                // struct `core::fmt::rt::v1::FormatSpec`\n-                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n-                if subfields.iter().all(|field| match field.ident.name {\n-                    sym::precision | sym::width => match field.expr.kind {\n-                        ExprKind::Path(QPath::Resolved(_, path)) => {\n-                            path.segments.last().unwrap().ident.name == sym::Implied\n-                        }\n-                        _ => false,\n-                    }\n-                    _ => true,\n-                });\n-                then { true } else { false }\n-            }\n-        })\n+    /// Iterator of all format params, both values and those referenced by `width`/`precision`s.\n+    pub fn params(&'tcx self) -> impl Iterator<Item = FormatParam<'tcx>> {\n+        self.args\n+            .iter()\n+            .flat_map(|arg| [Some(arg.param), arg.format.precision.param(), arg.format.width.param()])\n+            .flatten()\n     }\n }\n "}, {"sha": "199a3ab12ae0669e43e6b5c23e20a9fc2ce9b1f0", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -71,7 +71,6 @@ pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];"}, {"sha": "4322891db7620f60c3203e26c62dd6d486659642", "filename": "tests/ui/format_args.fixed", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/tests%2Fui%2Fformat_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/tests%2Fui%2Fformat_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.fixed?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,8 +1,6 @@\n // run-rustfix\n \n-#![allow(unreachable_code)]\n-#![allow(unused_macros)]\n-#![allow(unused_variables)]\n+#![allow(unused)]\n #![allow(clippy::assertions_on_constants)]\n #![allow(clippy::eq_op)]\n #![allow(clippy::print_literal)]\n@@ -115,3 +113,12 @@ fn main() {\n     // https://github.com/rust-lang/rust-clippy/issues/7903\n     println!(\"{foo}{foo:?}\", foo = \"foo\".to_string());\n }\n+\n+fn issue8643(vendor_id: usize, product_id: usize, name: &str) {\n+    println!(\n+        \"{:<9}  {:<10}  {}\",\n+        format!(\"0x{:x}\", vendor_id),\n+        format!(\"0x{:x}\", product_id),\n+        name\n+    );\n+}"}, {"sha": "61ad04612cdc94b8ab4932ff2d2c9d3ce8f2692d", "filename": "tests/ui/format_args.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/tests%2Fui%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/tests%2Fui%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.rs?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,8 +1,6 @@\n // run-rustfix\n \n-#![allow(unreachable_code)]\n-#![allow(unused_macros)]\n-#![allow(unused_variables)]\n+#![allow(unused)]\n #![allow(clippy::assertions_on_constants)]\n #![allow(clippy::eq_op)]\n #![allow(clippy::print_literal)]\n@@ -115,3 +113,12 @@ fn main() {\n     // https://github.com/rust-lang/rust-clippy/issues/7903\n     println!(\"{foo}{foo:?}\", foo = \"foo\".to_string());\n }\n+\n+fn issue8643(vendor_id: usize, product_id: usize, name: &str) {\n+    println!(\n+        \"{:<9}  {:<10}  {}\",\n+        format!(\"0x{:x}\", vendor_id),\n+        format!(\"0x{:x}\", product_id),\n+        name\n+    );\n+}"}, {"sha": "0aca1c1a0dfb9a3608fcc455211ef2f2977266d1", "filename": "tests/ui/format_args.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e594de8ec79f89415c610f32c4f1b05a9e393b8/tests%2Fui%2Fformat_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e594de8ec79f89415c610f32c4f1b05a9e393b8/tests%2Fui%2Fformat_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.stderr?ref=3e594de8ec79f89415c610f32c4f1b05a9e393b8", "patch": "@@ -1,127 +1,127 @@\n error: `to_string` applied to a type that implements `Display` in `format!` args\n-  --> $DIR/format_args.rs:76:72\n+  --> $DIR/format_args.rs:74:72\n    |\n LL |     let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                        ^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::to-string-in-format-args` implied by `-D warnings`\n \n error: `to_string` applied to a type that implements `Display` in `write!` args\n-  --> $DIR/format_args.rs:80:27\n+  --> $DIR/format_args.rs:78:27\n    |\n LL |         Location::caller().to_string()\n    |                           ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `writeln!` args\n-  --> $DIR/format_args.rs:85:27\n+  --> $DIR/format_args.rs:83:27\n    |\n LL |         Location::caller().to_string()\n    |                           ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `print!` args\n-  --> $DIR/format_args.rs:87:63\n+  --> $DIR/format_args.rs:85:63\n    |\n LL |     print!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                               ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:88:65\n+  --> $DIR/format_args.rs:86:65\n    |\n LL |     println!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                 ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `eprint!` args\n-  --> $DIR/format_args.rs:89:64\n+  --> $DIR/format_args.rs:87:64\n    |\n LL |     eprint!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `eprintln!` args\n-  --> $DIR/format_args.rs:90:66\n+  --> $DIR/format_args.rs:88:66\n    |\n LL |     eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                  ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `format_args!` args\n-  --> $DIR/format_args.rs:91:77\n+  --> $DIR/format_args.rs:89:77\n    |\n LL |     let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                             ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert!` args\n-  --> $DIR/format_args.rs:92:70\n+  --> $DIR/format_args.rs:90:70\n    |\n LL |     assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                      ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert_eq!` args\n-  --> $DIR/format_args.rs:93:73\n+  --> $DIR/format_args.rs:91:73\n    |\n LL |     assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                         ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert_ne!` args\n-  --> $DIR/format_args.rs:94:73\n+  --> $DIR/format_args.rs:92:73\n    |\n LL |     assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                         ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `panic!` args\n-  --> $DIR/format_args.rs:95:63\n+  --> $DIR/format_args.rs:93:63\n    |\n LL |     panic!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                               ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:96:20\n+  --> $DIR/format_args.rs:94:20\n    |\n LL |     println!(\"{}\", X(1).to_string());\n    |                    ^^^^^^^^^^^^^^^^ help: use this: `*X(1)`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:97:20\n+  --> $DIR/format_args.rs:95:20\n    |\n LL |     println!(\"{}\", Y(&X(1)).to_string());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: use this: `***Y(&X(1))`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:98:24\n+  --> $DIR/format_args.rs:96:24\n    |\n LL |     println!(\"{}\", Z(1).to_string());\n    |                        ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:99:20\n+  --> $DIR/format_args.rs:97:20\n    |\n LL |     println!(\"{}\", x.to_string());\n    |                    ^^^^^^^^^^^^^ help: use this: `**x`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:100:20\n+  --> $DIR/format_args.rs:98:20\n    |\n LL |     println!(\"{}\", x_ref.to_string());\n    |                    ^^^^^^^^^^^^^^^^^ help: use this: `***x_ref`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:102:39\n+  --> $DIR/format_args.rs:100:39\n    |\n LL |     println!(\"{foo}{bar}\", foo = \"foo\".to_string(), bar = \"bar\");\n    |                                       ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:103:52\n+  --> $DIR/format_args.rs:101:52\n    |\n LL |     println!(\"{foo}{bar}\", foo = \"foo\", bar = \"bar\".to_string());\n    |                                                    ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:104:39\n+  --> $DIR/format_args.rs:102:39\n    |\n LL |     println!(\"{foo}{bar}\", bar = \"bar\".to_string(), foo = \"foo\");\n    |                                       ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:105:52\n+  --> $DIR/format_args.rs:103:52\n    |\n LL |     println!(\"{foo}{bar}\", bar = \"bar\", foo = \"foo\".to_string());\n    |                                                    ^^^^^^^^^^^^ help: remove this"}]}