{"sha": "39c047317f39df2b0f55da10f276b88826f54d3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YzA0NzMxN2YzOWRmMmIwZjU1ZGExMGYyNzZiODg4MjZmNTRkM2I=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-10T20:57:00Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-10T20:57:00Z"}, "message": "progress", "tree": {"sha": "ada9379878d970fa0b9841f28998af8c5533eddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ada9379878d970fa0b9841f28998af8c5533eddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39c047317f39df2b0f55da10f276b88826f54d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39c047317f39df2b0f55da10f276b88826f54d3b", "html_url": "https://github.com/rust-lang/rust/commit/39c047317f39df2b0f55da10f276b88826f54d3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39c047317f39df2b0f55da10f276b88826f54d3b/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2a37fce151c2eeef1edea7001c34b2588e80f5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a37fce151c2eeef1edea7001c34b2588e80f5c", "html_url": "https://github.com/rust-lang/rust/commit/f2a37fce151c2eeef1edea7001c34b2588e80f5c"}], "stats": {"total": 324, "additions": 324, "deletions": 0}, "files": [{"sha": "2fd750bb6649e8300cf38780214c51f3327bab08", "filename": "conversions.md", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/39c047317f39df2b0f55da10f276b88826f54d3b/conversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/39c047317f39df2b0f55da10f276b88826f54d3b/conversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/conversions.md?ref=39c047317f39df2b0f55da10f276b88826f54d3b", "patch": "@@ -1,7 +1,77 @@\n % Type Conversions\n \n+At the end of the day, everything is just a pile of bits somewhere, and type systems\n+are just there to help us use those bits right. Needing to reinterpret those piles\n+of bits as different types is a common problem and Rust consequently gives you\n+several ways to do that.\n+\n # Safe Rust\n \n+First we'll look at the ways that *Safe Rust* gives you to reinterpret values. The\n+most trivial way to do this is to just destructure a value into its constituent\n+parts and then build a new type out of them. e.g.\n+\n+```rust\n+struct Foo {\n+\tx: u32,\n+\ty: u16,\n+}\n+\n+struct Bar {\n+\ta: u32,\n+\tb: u16,\n+}\n+\n+fn reinterpret(foo: Foo) -> Bar {\n+\tlet Foo { x, y } = foo;\n+\tBar { a: x, b: y }\n+}\n+```\n+\n+But this is, at best, annoying to do. For common conversions, rust provides\n+more ergonomic alternatives.\n+\n+## Auto-Deref\n+\n+Deref is a trait that allows you to overload the unary `*` to specify a type\n+you dereference to. This is largely only intended to be implemented by pointer\n+types like `&`, `Box`, and `Rc`. The dot operator will automatically perform\n+automatic dereferencing, so that foo.bar() will work uniformly on `Foo`, `&Foo`, `&&Foo`,\n+`&Rc<Box<&mut&Box<Foo>>>` and so-on. Search bottoms out on the *first* match,\n+so implementing methods on pointers is generally to be avoided, as it will shadow\n+\"actual\" methods.\n+\n+## Coercions\n+\n+Types can implicitly be coerced to change in certain contexts. These changes are generally\n+just *weakening* of types, largely focused around pointers. They mostly exist to make\n+Rust \"just work\" in more cases. For instance\n+`&mut T` coerces to `&T`, and `&T` coerces to `*const T`. The most useful coercion you will\n+actually think about it is probably the general *Deref Coercion*: `&T` coerces to `&U` when\n+`T: Deref<U>`. This enables us to pass an `&String` where an `&str` is expected, for instance.\n+\n+## Casts\n+\n+Casts are a superset of coercions: every coercion can be explicitly invoked via a cast,\n+but some changes require a cast. These \"true casts\" are generally regarded as dangerous or\n+problematic actions. The set of true casts is actually quite small, and once again revolves\n+largely around pointers. However it also introduces the primary mechanism to convert between\n+numeric types.\n+\n+* rawptr -> rawptr (e.g. `*mut T as *const T` or `*mut T as *mut U`)\n+* rawptr <-> usize (e.g. `*mut T as usize` or `usize as *mut T`)\n+* primitive -> primitive (e.g. `u32 as u8` or `u8 as u32`)\n+* c-like enum -> integer/bool (e.g. `DaysOfWeek as u8`)\n+* `u8` -> `char`\n+\n+\n+## Conversion Traits\n+\n+For full formal specification of all the kinds of coercions and coercion sites, see:\n+https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+\n+\n+\n * Coercions\n * Casts\n * Conversion Traits (Into/As/...)"}, {"sha": "6fa63568862c5883cc8cc7707adfac5e942c4ab3", "filename": "data.md", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/39c047317f39df2b0f55da10f276b88826f54d3b/data.md", "raw_url": "https://github.com/rust-lang/rust/raw/39c047317f39df2b0f55da10f276b88826f54d3b/data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/data.md?ref=39c047317f39df2b0f55da10f276b88826f54d3b", "patch": "@@ -0,0 +1,254 @@\n+% Data Representation in Rust\n+\n+Low-level programming cares a lot about data layout. It's a big deal. It also pervasively\n+influences the rest of the language, so we're going to start by digging into how data is\n+represented in Rust.\n+\n+# The `rust` repr\n+\n+Rust gives you the following ways to lay out composite data:\n+\n+* structs (named product types)\n+* tuples (anonymous product types)\n+* arrays (homogeneous product types)\n+* enums (named sum types -- tagged unions)\n+\n+For all these, individual fields are aligned to their preferred alignment.\n+For primitives this is equal to\n+their size. For instance, a u32 will be aligned to a multiple of 32 bits, and a u16 will\n+be aligned to a multiple of 16 bits. Composite structures will have their size rounded\n+up to be a multiple of the highest alignment required by their fields, and an alignment\n+requirement equal to the highest alignment required by their fields. So for instance,\n+\n+```rust\n+struct A {\n+    a: u8,\n+    c: u64,\n+    b: u32,\n+}\n+```\n+\n+will have a size that is a multiple of 64-bits, and 64-bit alignment.\n+\n+There is *no indirection* for these types; all data is stored contiguously as you would\n+expect in C. However with the exception of arrays, the layout of data is not by\n+default specified in Rust. Given the two following struct definitions:\n+\n+```rust\n+struct A {\n+    a: i32,\n+    b: u64,\n+}\n+\n+struct B {\n+    x: i32,\n+    b: u64,\n+}\n+```\n+\n+Rust *does* guarantee that two instances of A have their data laid out in exactly\n+the same way. However Rust *does not* guarantee that an instance of A has the same\n+field ordering or padding as an instance of B (in practice there's no *particular*\n+reason why they wouldn't, other than that its not currently guaranteed).\n+\n+With A and B as written, this is basically nonsensical, but several other features\n+of Rust make it desirable for the language to play with data layout in complex ways.\n+\n+For instance, consider this struct:\n+\n+```rust\n+struct Foo<T, U> {\n+    count: u16,\n+    data1: T,\n+    data2: U,\n+}\n+```\n+\n+Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If Rust lays out the\n+fields in the order specified, we expect it to *pad* the values in the struct to satisfy\n+their *alignment* requirements. So if Rust didn't reorder fields, we would expect Rust to\n+produce the following:\n+\n+```rust\n+struct Foo<u16, u32> {\n+    count: u16,\n+    data1: u16,\n+    data2: u32,\n+}\n+\n+struct Foo<u32, u16> {\n+    count: u16,\n+    _pad1: u16,\n+    data1: u32,\n+    data2: u16,\n+    _pad2: u16,\n+}\n+```\n+\n+The former case quite simply wastes space. An optimal use of space therefore requires\n+different monomorphizations to *have different field orderings*.\n+\n+**Note: this is a hypothetical optimization that is not yet implemented in Rust 1.0.0**\n+\n+Enums make this consideration even more complicated. Naively, an enum such as:\n+\n+```rust\n+enum Foo {\n+    A(u32),\n+    B(u64),\n+    C(u8),\n+}\n+```\n+\n+would be laid out as:\n+\n+```rust\n+struct FooRepr {\n+    data: u64, // this is *really* either a u64, u32, or u8 based on `tag`\n+    tag: u8, // 0 = A, 1 = B, 2 = C\n+}\n+```\n+\n+And indeed this is approximately how it would be laid out in general\n+(modulo the size and position of `tag`). However there are several cases where\n+such a representation is ineffiecient. The classic case of this is Rust's\n+\"null pointer optimization\". Given a pointer that is known to not be null\n+(e.g. `&u32`), an enum can *store* a discriminant bit *inside* the pointer\n+by using null as a special value. The net result is that\n+`sizeof(Option<&T>) == sizeof<&T>`\n+\n+There are many types in Rust that are, or contain, \"not null\" pointers such as `Box<T>`, `Vec<T>`,\n+`String`, `&T`, and `&mut T`. Similarly, one can imagine nested enums pooling their tags into\n+a single descriminant, as they are by definition known to have a limited range of valid values.\n+In principle enums can use fairly elaborate algorithms to cache bits throughout nested types\n+with special constrained representations. As such it is *especially* desirable that we leave\n+enum layout unspecified today.\n+\n+# Dynamically Sized Types (DSTs)\n+\n+Rust also supports types without a statically known size. On the surface,\n+this is a bit nonsensical: Rust must know the size of something in order to\n+work with it. DSTs are generally produced as views, or through type-erasure\n+of types that *do* have a known size. Due to their lack of a statically known\n+size, these types can only exist *behind* some kind of pointer. They consequently\n+produce a *fat* pointer consisting of the pointer and the information that\n+*completes* them.\n+\n+For instance, the slice type, `[T]`, is some statically unknown number of elements\n+stored contiguously. `&[T]` consequently consists of a `(&T, usize)` pair that specifies\n+where the slice starts, and how many elements it contains. Similarly Trait Objects\n+support interface-oriented type erasure through a `(data_ptr, vtable_ptr)` pair.\n+\n+Structs can actually store a single DST directly as their last field, but this\n+makes them a DST as well:\n+\n+```rust\n+// Can't be stored on the stack directly\n+struct Foo {\n+    info: u32,\n+    data: [u8],\n+}\n+```\n+\n+# Zero Sized Types (ZSTs)\n+\n+Rust actually allows types to be specified that occupy *no* space:\n+\n+```rust\n+struct Foo; // No fields = no size\n+enum Bar; // No variants = no size\n+\n+// All fields have no size = no size\n+struct Baz {\n+    foo: Foo,\n+    bar: Bar,\n+    qux: (), // empty tuple has no size\n+}\n+```\n+\n+On their own, ZSTs are, for obvious reasons, pretty useless. However\n+as with many curious layout choices in Rust, their potential is realized in a generic\n+context.\n+\n+Rust largely understands that any operation that produces or stores a ZST\n+can be reduced to a no-op. For instance, a `HashSet<T>` can be effeciently implemented\n+as a thin wrapper around `HashMap<T, ()>` because all the operations `HashMap` normally\n+does to store and retrieve keys will be completely stripped in monomorphization.\n+\n+Similarly `Result<(), ()>` and `Option<()>` are effectively just fancy `bool`s.\n+\n+Safe code need not worry about ZSTs, but *unsafe* code must be careful about the\n+consequence of types with no size. In particular, pointer offsets are no-ops, and\n+standard allocators (including jemalloc, the one used by Rust) generally consider\n+passing in `0` as Undefined Behaviour.\n+\n+# Drop Flags\n+\n+For unfortunate legacy implementation reasons, Rust as of 1.0.0 will do a nasty trick to\n+any type that implements the `Drop` trait (has a destructor): it will insert a secret field\n+in the type. That is,\n+\n+```rust\n+struct Foo {\n+    a: u32,\n+    b: u32,\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { }\n+}\n+```\n+\n+will cause Foo to secretly become:\n+\n+```rust\n+struct Foo {\n+    a: u32,\n+    b: u32,\n+    _drop_flag: u8,\n+}\n+```\n+\n+For details as to *why* this is done, and how to make it not happen, check out\n+[SOME OTHER SECTION].\n+\n+# Alternative representations\n+\n+Rust allows you to specify alternative data layout strategies from the default Rust\n+one.\n+\n+# repr(C)\n+\n+This is the most important `repr`. It has fairly simple intent: do what C does.\n+The order, size, and alignment of fields is exactly what you would expect from\n+C or C++. Any type you expect to pass through an FFI boundary should have `repr(C)`,\n+as C is the lingua-franca of the programming world. However this is also necessary\n+to soundly do more elaborate tricks with data layout such as reintepretting values\n+as a different type.\n+\n+However, the interaction with Rust's more exotic data layout features must be kept\n+in mind. Due to its dual purpose as a \"for FFI\" and \"for layout control\", repr(C)\n+can be applied to types that will be nonsensical or problematic if passed through\n+the FFI boundary.\n+\n+* ZSTs are still zero-sized, even though this is not a standard behaviour\n+in C, and is explicitly contrary to the behaviour of an empty type in C++, which\n+still consumes a byte of space.\n+\n+* DSTs are not a concept in C\n+\n+* **The drop flag will still be added**\n+\n+* This is equivalent to repr(u32) for enums (see below)\n+\n+# repr(packed)\n+\n+`repr(packed)` forces rust to strip any padding it would normally apply.\n+This may improve the memory footprint of a type, but will have negative\n+side-effects from \"field access is heavily penalized\" to \"completely breaks\n+everything\" based on target platform.\n+\n+# repr(u8), repr(u16), repr(u32), repr(u64)\n+\n+These specify the size to make a c-like enum (one which has no values in its variants).\n+"}]}