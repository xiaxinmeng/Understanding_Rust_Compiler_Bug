{"sha": "d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzY2IyNWQ1ZDFlZGU5ZDllZjA2ZGI2YzMwY2Q4NDQ4ZWQ0MjUxMjc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-23T00:27:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-23T00:27:00Z"}, "message": "Check and translate 'as' cast-operator, lower target-specific types, reindent rustc.rs, enable uint test.", "tree": {"sha": "51c12e7f2c5396f7af8e57d2d4e77bbf5a9d2373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c12e7f2c5396f7af8e57d2d4e77bbf5a9d2373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "html_url": "https://github.com/rust-lang/rust/commit/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c262543d3b353c46611059b70ee7ee3771b5df14", "url": "https://api.github.com/repos/rust-lang/rust/commits/c262543d3b353c46611059b70ee7ee3771b5df14", "html_url": "https://github.com/rust-lang/rust/commit/c262543d3b353c46611059b70ee7ee3771b5df14"}], "stats": {"total": 310, "additions": 229, "deletions": 81}, "files": [{"sha": "74f0dbd1dbea2f4287d14e9ca62676019779d39b", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "patch": "@@ -533,6 +533,7 @@ TEST_XFAILS_SELF := $(filter-out \\\n                         lazy-init.rs \\\n                         multiline-comment.rs \\\n                         return-nil.rs \\\n+                        uint.rs \\\n                         unit.rs \\\n                         while-and-do-while.rs \\\n                         ), \\"}, {"sha": "9c0b248400dff8433680bd38fa0facb51db458bc", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 93, "deletions": 78, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "patch": "@@ -5,6 +5,7 @@ import front.token;\n import middle.trans;\n import middle.resolve;\n import middle.typeck;\n+import util.common;\n \n import std.option;\n import std.option.some;\n@@ -13,18 +14,18 @@ import std._str;\n import std._vec;\n \n impure fn compile_input(session.session sess, str input, str output) {\n-          auto p = parser.new_parser(sess, 0, input);\n-          auto crate = parser.parse_crate(p);\n-          crate = resolve.resolve_crate(sess, crate);\n-          crate = typeck.check_crate(sess, crate);\n-          trans.trans_crate(sess, crate, output);\n+    auto p = parser.new_parser(sess, 0, input);\n+    auto crate = parser.parse_crate(p);\n+    crate = resolve.resolve_crate(sess, crate);\n+    crate = typeck.check_crate(sess, crate);\n+    trans.trans_crate(sess, crate, output);\n }\n \n fn warn_wrong_compiler() {\n-  log \"This is the rust 'self-hosted' compiler.\";\n-  log \"The one written in rust.\";\n-  log \"It does nothing yet, it's a placeholder.\";\n-  log \"You want rustboot, the compiler next door.\";\n+    log \"This is the rust 'self-hosted' compiler.\";\n+    log \"The one written in rust.\";\n+    log \"It does nothing yet, it's a placeholder.\";\n+    log \"You want rustboot, the compiler next door.\";\n }\n \n fn usage(session.session sess, str argv0) {\n@@ -38,81 +39,95 @@ fn usage(session.session sess, str argv0) {\n     log \"\";\n }\n \n+fn get_os() -> session.os {\n+    auto s = std.os.target_os();\n+    if (_str.eq(s, \"win32\")) { ret session.os_win32; }\n+    if (_str.eq(s, \"macos\")) { ret session.os_macos; }\n+    if (_str.eq(s, \"linux\")) { ret session.os_linux; }\n+}\n+\n impure fn main(vec[str] args) {\n \n-  auto sess = session.session();\n-  let option.t[str] input_file = none[str];\n-  let option.t[str] output_file = none[str];\n-  let bool do_warn = true;\n+    // FIXME: don't hard-wire this.\n+    auto target_cfg = rec(os = get_os(),\n+                          arch = session.arch_x86,\n+                          int_type = common.ty_i32,\n+                          uint_type = common.ty_u32,\n+                          float_type = common.ty_f64 );\n+\n+    auto sess = session.session(target_cfg);\n+    let option.t[str] input_file = none[str];\n+    let option.t[str] output_file = none[str];\n+    let bool do_warn = true;\n \n-  auto i = 1u;\n-  auto len = _vec.len[str](args);\n+    auto i = 1u;\n+    auto len = _vec.len[str](args);\n \n-  // FIXME: a getopt module would be nice.\n-  while (i < len) {\n-      auto arg = args.(i);\n-      if (_str.byte_len(arg) > 0u && arg.(0) == '-' as u8) {\n-          if (_str.eq(arg, \"-nowarn\")) {\n-              do_warn = false;\n-          } else {\n-              // FIXME: rust could use an elif construct.\n-              if (_str.eq(arg, \"-o\")) {\n-                  if (i+1u < len) {\n-                      output_file = some(args.(i+1u));\n-                      i += 1u;\n-                  } else {\n-                      usage(sess, args.(0));\n-                      sess.err(\"-o requires an argument\");\n-                  }\n-              } else {\n-                  if (_str.eq(arg, \"-h\")) {\n-                      usage(sess, args.(0));\n-                  } else {\n-                      usage(sess, args.(0));\n-                      sess.err(\"unrecognized option: \" + arg);\n-                  }\n-              }\n-          }\n-      } else {\n-          alt (input_file) {\n-              case (some[str](_)) {\n-                  usage(sess, args.(0));\n-                  sess.err(\"multiple inputs provided\");\n-              }\n-              case (none[str]) {\n-                  input_file = some[str](arg);\n-              }\n-          }\n-          // FIXME: dummy node to work around typestate mis-wiring bug.\n-          i = i;\n-      }\n-      i += 1u;\n-  }\n+    // FIXME: a getopt module would be nice.\n+    while (i < len) {\n+        auto arg = args.(i);\n+        if (_str.byte_len(arg) > 0u && arg.(0) == '-' as u8) {\n+            if (_str.eq(arg, \"-nowarn\")) {\n+                do_warn = false;\n+            } else {\n+                // FIXME: rust could use an elif construct.\n+                if (_str.eq(arg, \"-o\")) {\n+                    if (i+1u < len) {\n+                        output_file = some(args.(i+1u));\n+                        i += 1u;\n+                    } else {\n+                        usage(sess, args.(0));\n+                        sess.err(\"-o requires an argument\");\n+                    }\n+                } else {\n+                    if (_str.eq(arg, \"-h\")) {\n+                        usage(sess, args.(0));\n+                    } else {\n+                        usage(sess, args.(0));\n+                        sess.err(\"unrecognized option: \" + arg);\n+                    }\n+                }\n+            }\n+        } else {\n+            alt (input_file) {\n+                case (some[str](_)) {\n+                    usage(sess, args.(0));\n+                    sess.err(\"multiple inputs provided\");\n+                }\n+                case (none[str]) {\n+                    input_file = some[str](arg);\n+                }\n+            }\n+            // FIXME: dummy node to work around typestate mis-wiring bug.\n+            i = i;\n+        }\n+        i += 1u;\n+    }\n \n-  if (do_warn) {\n-      warn_wrong_compiler();\n-  }\n+    if (do_warn) {\n+        warn_wrong_compiler();\n+    }\n \n-  alt (input_file) {\n-      case (none[str]) {\n-          usage(sess, args.(0));\n-          sess.err(\"no input filename\");\n-      }\n-      case (some[str](?ifile)) {\n-          alt (output_file) {\n-              case (none[str]) {\n-                  let vec[str] parts = _str.split(ifile, '.' as u8);\n-                  parts = _vec.pop[str](parts);\n-                  parts += \".bc\";\n-                  auto ofile = _str.concat(parts);\n-                  compile_input(sess, ifile, ofile);\n-              }\n-              case (some[str](?ofile)) {\n-                  compile_input(sess, ifile, ofile);\n-              }\n-          }\n-      }\n-  }\n+    alt (input_file) {\n+        case (none[str]) {\n+            usage(sess, args.(0));\n+            sess.err(\"no input filename\");\n+        }\n+        case (some[str](?ifile)) {\n+            alt (output_file) {\n+                case (none[str]) {\n+                    let vec[str] parts = _str.split(ifile, '.' as u8);\n+                    parts = _vec.pop[str](parts);\n+                    parts += \".bc\";\n+                    auto ofile = _str.concat(parts);\n+                    compile_input(sess, ifile, ofile);\n+                }\n+                case (some[str](?ofile)) {\n+                    compile_input(sess, ifile, ofile);\n+                }\n+            }\n+        }\n+    }\n }\n \n "}, {"sha": "e23dbeed58a4dd654d76b82b416166a482358310", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "patch": "@@ -1,7 +1,31 @@\n import util.common.span;\n+import util.common.ty_mach;\n import std._uint;\n \n-obj session() {\n+tag os {\n+    os_win32;\n+    os_macos;\n+    os_linux;\n+}\n+\n+tag arch {\n+    arch_x86;\n+    arch_x64;\n+    arch_arm;\n+}\n+\n+type cfg = rec(os os,\n+               arch arch,\n+               ty_mach int_type,\n+               ty_mach uint_type,\n+               ty_mach float_type);\n+\n+obj session(cfg targ) {\n+\n+    fn get_targ_cfg() -> cfg {\n+        ret targ;\n+    }\n+\n     fn span_err(span sp, str msg) {\n         log #fmt(\"%s:%u:%u:%u:%u: error: %s\",\n                  sp.filename,\n@@ -16,6 +40,11 @@ obj session() {\n         fail;\n     }\n \n+    fn bug(str msg) {\n+        log #fmt(\"error: internal compiler error %s\", msg);\n+        fail;\n+    }\n+\n     fn unimpl(str msg) {\n         log #fmt(\"error: unimplemented %s\", msg);\n         fail;"}, {"sha": "9bc1f19ce92cb290445c9e3b1b3ab694f98b5850", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "patch": "@@ -551,18 +551,36 @@ impure fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n     }\n }\n \n-fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n+fn target_type(@crate_ctxt cx, @typeck.ty t) -> @typeck.ty {\n+    alt (t.struct) {\n+        case (typeck.ty_int) {\n+            auto tm = typeck.ty_machine(cx.sess.get_targ_cfg().int_type);\n+            ret @rec(struct=tm with *t);\n+        }\n+        case (typeck.ty_uint) {\n+            auto tm = typeck.ty_machine(cx.sess.get_targ_cfg().uint_type);\n+            ret @rec(struct=tm with *t);\n+        }\n+    }\n+    ret t;\n+}\n+\n+fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @typeck.ty {\n     alt (a) {\n         case (ast.ann_none) {\n             log \"missing type annotation\";\n             fail;\n         }\n         case (ast.ann_type(?t)) {\n-            ret type_of(cx, t);\n+            ret target_type(cx, t);\n         }\n     }\n }\n \n+fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n+    ret type_of(cx, node_ann_type(cx, a));\n+}\n+\n impure fn trans_unary(@block_ctxt cx, ast.unop op,\n                       &ast.expr e, &ast.ann a) -> result {\n \n@@ -962,6 +980,36 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n                     args_res._0.build.FastCall(f_res._0.val, llargs));\n         }\n \n+        case (ast.expr_cast(?e, _, ?ann)) {\n+            auto e_res = trans_expr(cx, *e);\n+            auto llsrctype = val_ty(e_res.val);\n+            auto t = node_ann_type(cx.fcx.ccx, ann);\n+            auto lldsttype = type_of(cx.fcx.ccx, t);\n+            if (!typeck.type_is_fp(t)) {\n+                if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n+                    llvm.LLVMGetIntTypeWidth(llsrctype)) {\n+                    if (typeck.type_is_signed(t)) {\n+                        // Widening signed cast.\n+                        e_res.val =\n+                            e_res.bcx.build.SExtOrBitCast(e_res.val,\n+                                                          lldsttype);\n+                    } else {\n+                        // Widening unsigned cast.\n+                        e_res.val =\n+                            e_res.bcx.build.ZExtOrBitCast(e_res.val,\n+                                                          lldsttype);\n+                    }\n+                } else {\n+                    // Narrowing cast.\n+                    e_res.val =\n+                        e_res.bcx.build.TruncOrBitCast(e_res.val,\n+                                                       lldsttype);\n+                }\n+            } else {\n+                cx.fcx.ccx.sess.unimpl(\"fp cast\");\n+            }\n+            ret e_res;\n+        }\n     }\n     cx.fcx.ccx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;"}, {"sha": "7bdbd9e9592b1577fe92ab986a73a781c6d8f025", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "patch": "@@ -391,6 +391,44 @@ fn mode_is_alias(ast.mode m) -> bool {\n     }\n }\n \n+fn type_is_scalar(@ty t) -> bool {\n+    alt (t.struct) {\n+        case (ty_bool) { ret true; }\n+        case (ty_int) { ret true; }\n+        case (ty_uint) { ret true; }\n+        case (ty_machine(_)) { ret true; }\n+        case (ty_char) { ret true; }\n+    }\n+    ret false;\n+}\n+\n+fn type_is_fp(@ty t) -> bool {\n+    alt (t.struct) {\n+        case (ty_machine(?tm)) {\n+            alt (tm) {\n+                case (common.ty_f32) { ret true; }\n+                case (common.ty_f64) { ret true; }\n+            }\n+        }\n+    }\n+    ret false;\n+}\n+\n+fn type_is_signed(@ty t) -> bool {\n+    alt (t.struct) {\n+        case (ty_int) { ret true; }\n+        case (ty_machine(?tm)) {\n+            alt (tm) {\n+                case (common.ty_i8) { ret true; }\n+                case (common.ty_i16) { ret true; }\n+                case (common.ty_i32) { ret true; }\n+                case (common.ty_i64) { ret true; }\n+            }\n+        }\n+    }\n+    ret false;\n+}\n+\n fn plain_ty(&sty st) -> @ty {\n     ret @rec(struct=st, cname=none[str]);\n }\n@@ -873,6 +911,23 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                       ast.ann_type(ret_t)));\n         }\n \n+        case (ast.expr_cast(?e, ?t, _)) {\n+            auto e_1 = check_expr(fcx, e);\n+            auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n+            // FIXME: there are more forms of cast to support, eventually.\n+            if (! (type_is_scalar(expr_ty(e_1)) &&\n+                   type_is_scalar(t_1))) {\n+                fcx.ccx.sess.span_err(expr.span,\n+                                      \"non-scalar cast: \"\n+                                      + ty_to_str(expr_ty(e_1))\n+                                      + \" as \"\n+                                      +  ty_to_str(t_1));\n+            }\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_cast(e_1, t,\n+                                                      ast.ann_type(t_1)));\n+        }\n+\n         case (_) {\n             // TODO\n             ret expr;"}]}