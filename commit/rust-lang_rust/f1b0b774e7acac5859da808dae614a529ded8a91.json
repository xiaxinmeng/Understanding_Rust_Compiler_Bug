{"sha": "f1b0b774e7acac5859da808dae614a529ded8a91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYjBiNzc0ZTdhY2FjNTg1OWRhODA4ZGFlNjE0YTUyOWRlZDhhOTE=", "commit": {"author": {"name": "sinkuu", "email": "sinkuupump@gmail.com", "date": "2017-02-20T07:45:37Z"}, "committer": {"name": "sinkuu", "email": "sinkuupump@gmail.com", "date": "2017-02-20T07:45:37Z"}, "message": "Support non-moving usages at `match`\n\nThis `match` is not moving the `String`:\n\n```rust\nfn foo(x: Option<String>) -> i32 {\n    match x {\n        Some(_) => 1,\n        None => 2,\n    }\n}\n```\n\nWith this change, it will be linted and suggested to add `*` to deref it.\n\n```rust\nfn foo(x: &Option<String>) -> i32 {\n    match *x {\n        Some(_) => 1,\n        None => 2,\n    }\n}\n```", "tree": {"sha": "a0f2a753233ca276b343ad008c89fbb78d621029", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f2a753233ca276b343ad008c89fbb78d621029"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1b0b774e7acac5859da808dae614a529ded8a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b0b774e7acac5859da808dae614a529ded8a91", "html_url": "https://github.com/rust-lang/rust/commit/f1b0b774e7acac5859da808dae614a529ded8a91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1b0b774e7acac5859da808dae614a529ded8a91/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a6bc6031aa9bca562941a33f385c81e1eeda5af", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6bc6031aa9bca562941a33f385c81e1eeda5af", "html_url": "https://github.com/rust-lang/rust/commit/0a6bc6031aa9bca562941a33f385c81e1eeda5af"}], "stats": {"total": 168, "additions": 128, "deletions": 40}, "files": [{"sha": "2ab70da8c734d5ea4d0abef0798e74ebff182b50", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1b0b774e7acac5859da808dae614a529ded8a91/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b0b774e7acac5859da808dae614a529ded8a91/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=f1b0b774e7acac5859da808dae614a529ded8a91", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n                         .map(|end| constcx.eval(end, ExprTypeChecked))\n                         .map(|v| v.ok());\n \n-                    if let Some((start, end)) = to_const_range(start, end, range.limits, size) {\n+                    if let Some((start, end)) = to_const_range(&start, &end, range.limits, size) {\n                         if start > size || end > size {\n                             utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"range is out of bounds\");\n                         }\n@@ -109,18 +109,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n \n /// Returns an option containing a tuple with the start and end (exclusive) of the range.\n fn to_const_range(\n-    start: Option<Option<ConstVal>>,\n-    end: Option<Option<ConstVal>>,\n+    start: &Option<Option<ConstVal>>,\n+    end: &Option<Option<ConstVal>>,\n     limits: RangeLimits,\n     array_size: ConstInt\n ) -> Option<(ConstInt, ConstInt)> {\n-    let start = match start {\n+    let start = match *start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n         None => ConstInt::Infer(0),\n     };\n \n-    let end = match end {\n+    let end = match *end {\n         Some(Some(ConstVal::Integral(x))) => {\n             if limits == RangeLimits::Closed {\n                 (x + ConstInt::Infer(1)).expect(\"such a big array is not realistic\")"}, {"sha": "46371b938bc7e44d1de8a539a8ffd80b36120a55", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b0b774e7acac5859da808dae614a529ded8a91/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b0b774e7acac5859da808dae614a529ded8a91/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=f1b0b774e7acac5859da808dae614a529ded8a91", "patch": "@@ -203,9 +203,9 @@ pub fn lit_to_constant(lit: &LitKind) -> Constant {\n     }\n }\n \n-fn constant_not(o: Constant) -> Option<Constant> {\n+fn constant_not(o: &Constant) -> Option<Constant> {\n     use self::Constant::*;\n-    match o {\n+    match *o {\n         Bool(b) => Some(Bool(!b)),\n         Int(value) => (!value).ok().map(Int),\n         _ => None,\n@@ -271,7 +271,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| match op {\n-                    UnNot => constant_not(o),\n+                    UnNot => constant_not(&o),\n                     UnNeg => constant_negate(o),\n                     UnDeref => Some(o),\n                 })"}, {"sha": "e4491eda03859715a10437760ca98688e8aea7c5", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f1b0b774e7acac5859da808dae614a529ded8a91/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b0b774e7acac5859da808dae614a529ded8a91/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f1b0b774e7acac5859da808dae614a529ded8a91", "patch": "@@ -10,7 +10,7 @@ use syntax::ast::NodeId;\n use syntax_pos::Span;\n use utils::{in_macro, is_self, is_copy, implements_trait, get_trait_def_id, match_type, snippet, span_lint_and_then,\n             paths};\n-use std::collections::HashSet;\n+use std::collections::{HashSet, HashMap};\n \n /// **What it does:** Checks for functions taking arguments by value, but not consuming them in its\n /// body.\n@@ -71,15 +71,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 .collect()\n         };\n \n-        // Collect moved variables from the function body\n-        let moved_vars = {\n+        // Collect moved variables and non-moving usages at `match`es from the function body\n+        let MovedVariablesCtxt { moved_vars, non_moving_matches, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n             let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n             {\n                 let mut v = euv::ExprUseVisitor::new(&mut ctx, &infcx);\n                 v.consume_body(body);\n             }\n-            ctx.moved_vars\n+            ctx\n         };\n \n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n@@ -90,16 +90,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         for ((input, ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n \n             // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n-            // `implements_trait(.., borrow_trait, ..)` is useless\n-            // due to the `Borrow<T> for T` blanket impl.\n+            // This is needed due to the `Borrow<T> for T` blanket impl.\n             let implements_borrow_trait = preds.iter()\n                 .filter_map(|pred| if let ty::Predicate::Trait(ref poly_trait_ref) = *pred {\n                     Some(poly_trait_ref.skip_binder())\n                 } else {\n                     None\n                 })\n                 .filter(|tpred| tpred.def_id() == borrow_trait && &tpred.self_ty() == ty)\n-                .any(|tpred| &tpred.input_types().nth(1).expect(\"Borrow trait must have an input\") != ty);\n+                .any(|tpred| &tpred.input_types().nth(1).expect(\"Borrow trait must have an parameter\") != ty);\n \n             if_let_chain! {[\n                 !is_self(arg),\n@@ -148,6 +147,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                                            \"consider taking a reference instead\",\n                                            format!(\"&{}\", snippet(cx, input.span, \"_\")));\n                     }\n+\n+                    // For non-moving consumption at `match`es,\n+                    // suggests adding `*` to dereference the added reference.\n+                    // e.g. `match x { Some(_) => 1, None => 2 }`\n+                    //   -> `match *x { .. }`\n+                    if let Some(matches) = non_moving_matches.get(&defid) {\n+                        for (i, m) in matches.iter().enumerate() {\n+                            if let ExprMatch(ref e, ..) = cx.tcx.hir.expect_expr(*m).node {\n+                                db.span_suggestion(e.span,\n+                                                   if i == 0 {\n+                                                       \"...and dereference it here\"\n+                                                   } else {\n+                                                       \"...and here\"\n+                                                   },\n+                                                   format!(\"*{}\", snippet(cx, e.span, \"<expr>\")));\n+                            }\n+                        }\n+                    }\n                 });\n             }}\n         }\n@@ -157,50 +174,69 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     moved_vars: HashSet<DefId>,\n+    non_moving_matches: HashMap<DefId, HashSet<NodeId>>,\n }\n \n impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         MovedVariablesCtxt {\n             cx: cx,\n             moved_vars: HashSet::new(),\n+            non_moving_matches: HashMap::new(),\n         }\n     }\n \n-    fn consume_common(&mut self, _span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n-        /*::utils::span_lint(self.cx,\n-                           NEEDLESS_PASS_BY_VALUE,\n-                           span,\n-                           &format!(\"consumed here, {:?} {:?}\", mode, cmt.cat));*/\n+    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt<'tcx>) {\n+        let cmt = unwrap_downcast_or_interior(cmt);\n+\n         if_let_chain! {[\n-            let euv::ConsumeMode::Move(_) = mode,\n             let mc::Categorization::Local(vid) = cmt.cat,\n+            let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid),\n         ], {\n-            if let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid) {\n                 self.moved_vars.insert(def_id);\n-            }\n         }}\n-\n     }\n }\n \n impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n-    fn consume(&mut self, _consume_id: NodeId, consume_span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n-        self.consume_common(consume_span, cmt, mode);\n+    fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+        if let euv::ConsumeMode::Move(_) = mode {\n+            self.move_common(consume_id, consume_span, cmt);\n+        }\n     }\n \n-    fn matched_pat(&mut self, matched_pat: &Pat, mut cmt: mc::cmt<'tcx>, _mode: euv::MatchMode) {\n-        if let mc::Categorization::Downcast(c, _) = cmt.cat.clone() {\n-            cmt = c;\n-        }\n+    fn matched_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>, mode: euv::MatchMode) {\n+        if let euv::MatchMode::MovingMatch = mode {\n+            self.move_common(matched_pat.id, matched_pat.span, cmt);\n+        } else {\n+            let cmt = unwrap_downcast_or_interior(cmt);\n \n-        // if let euv::MatchMode::MovingMatch = mode {\n-        self.consume_common(matched_pat.span, cmt, euv::ConsumeMode::Move(euv::MoveReason::PatBindingMove));\n-        // }\n+            if_let_chain! {[\n+                let mc::Categorization::Local(vid) = cmt.cat,\n+                let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid),\n+            ], {\n+                // Find the `ExprMatch` which contains this pattern\n+                let mut match_id = matched_pat.id;\n+                loop {\n+                    match_id = self.cx.tcx.hir.get_parent_node(match_id);\n+                    if_let_chain! {[\n+                        let Some(map::Node::NodeExpr(e)) = self.cx.tcx.hir.find(match_id),\n+                        let ExprMatch(..) = e.node,\n+                    ], {\n+                        break;\n+                    }}\n+                }\n+\n+                self.non_moving_matches.entry(def_id).or_insert_with(HashSet::new)\n+                    .insert(match_id);\n+            }}\n+        }\n     }\n \n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n-        self.consume_common(consume_pat.span, cmt, mode);\n+        if let euv::ConsumeMode::Move(_) = mode {\n+            self.move_common(consume_pat.id, consume_pat.span, cmt);\n+        }\n     }\n \n     fn borrow(\n@@ -225,3 +261,16 @@ impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n \n     fn decl_without_init(&mut self, _id: NodeId, _span: Span) {}\n }\n+\n+\n+fn unwrap_downcast_or_interior(mut cmt: mc::cmt) -> mc::cmt {\n+    loop {\n+        match cmt.cat.clone() {\n+            mc::Categorization::Downcast(c, _) |\n+            mc::Categorization::Interior(c, _) => {\n+                cmt = c;\n+            },\n+            _ => return cmt,\n+        }\n+    }\n+}"}, {"sha": "74554aa974b1b1088f611bf9c10f359d46b82a8c", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1b0b774e7acac5859da808dae614a529ded8a91/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b0b774e7acac5859da808dae614a529ded8a91/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=f1b0b774e7acac5859da808dae614a529ded8a91", "patch": "@@ -2,9 +2,9 @@\n #![plugin(clippy)]\n \n #![deny(needless_pass_by_value)]\n-#![allow(dead_code)]\n+#![allow(dead_code, single_match)]\n \n-// `v` will be warned\n+// `v` should be warned\n // `w`, `x` and `y` are allowed (moved or mutated)\n fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n     assert_eq!(v.len(), 42);\n@@ -25,8 +25,8 @@ fn bar(x: String, y: Wrapper) {\n     assert_eq!(y.0.len(), 42);\n }\n \n+// U implements `Borrow<U>`, but should be warned correctly\n fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n-    // U implements `Borrow<U>`, but warned correctly\n     println!(\"{}\", t.borrow());\n     consume(&u);\n }\n@@ -36,4 +36,23 @@ fn test_fn<F: Fn(i32) -> i32>(f: F) {\n     f(1);\n }\n \n+// x should be warned, but y is ok\n+fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n+    match x {\n+        Some(Some(_)) => 1, // not moved\n+        _ => 0,\n+    };\n+\n+    match y {\n+        Some(Some(s)) => consume(s), // moved\n+        _ => (),\n+    };\n+}\n+\n+// x should be warned, but y is ok\n+fn test_destructure(x: Wrapper, y: Wrapper) {\n+    let Wrapper(s) = y; // moved\n+    assert_eq!(x.0.len(), s.len());\n+}\n+\n fn main() {}"}, {"sha": "cd7cadb885d4918f41dd5eb9449224b127a9538c", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1b0b774e7acac5859da808dae614a529ded8a91/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b0b774e7acac5859da808dae614a529ded8a91/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=f1b0b774e7acac5859da808dae614a529ded8a91", "patch": "@@ -31,13 +31,33 @@ help: consider taking a reference instead\n    | fn bar(x: String, y: &Wrapper) {\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:28:63\n+  --> $DIR/needless_pass_by_value.rs:29:63\n    |\n-28 | fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n+29 | fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n    |                                                               ^\n    |\n help: consider taking a reference instead\n    | fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: &U) {\n \n-error: aborting due to 4 previous errors\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:40:18\n+   |\n+40 | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider taking a reference instead\n+   | fn test_match(x: &Option<Option<String>>, y: Option<Option<String>>) {\n+help: ...and dereference it here\n+   |     match *x {\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:53:24\n+   |\n+53 | fn test_destructure(x: Wrapper, y: Wrapper) {\n+   |                        ^^^^^^^\n+   |\n+help: consider taking a reference instead\n+   | fn test_destructure(x: &Wrapper, y: Wrapper) {\n+\n+error: aborting due to 6 previous errors\n "}]}