{"sha": "069c4fc50871acfcf41f8726107daa26a29b488c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OWM0ZmM1MDg3MWFjZmNmNDFmODcyNjEwN2RhYTI2YTI5YjQ4OGM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T20:42:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T20:43:30Z"}, "message": "Refactoring: summary\n\nMove the timer from Summary to Session.\n\nMove Summary from config to formatting.", "tree": {"sha": "8fcaf440d236bd80cb18841ad2255ba39221f050", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fcaf440d236bd80cb18841ad2255ba39221f050"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/069c4fc50871acfcf41f8726107daa26a29b488c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/069c4fc50871acfcf41f8726107daa26a29b488c", "html_url": "https://github.com/rust-lang/rust/commit/069c4fc50871acfcf41f8726107daa26a29b488c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/069c4fc50871acfcf41f8726107daa26a29b488c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "html_url": "https://github.com/rust-lang/rust/commit/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1"}], "stats": {"total": 316, "additions": 143, "deletions": 173}, "files": [{"sha": "42686483419df3e52c2e0032cf87b5f6d4267a7b", "filename": "src/config/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=069c4fc50871acfcf41f8726107daa26a29b488c", "patch": "@@ -29,7 +29,6 @@ pub mod options;\n pub mod file_lines;\n pub mod license;\n pub mod lists;\n-pub mod summary;\n \n /// This macro defines configuration options used in rustfmt. Each option\n /// is defined as follows:"}, {"sha": "1ef6d18a5402f0b6fb2d4e32795d339b548fc9ab", "filename": "src/config/summary.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/src%2Fconfig%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/src%2Fconfig%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fsummary.rs?ref=09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "patch": "@@ -1,160 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::default::Default;\n-use std::time::{Duration, Instant};\n-\n-/// A summary of a Rustfmt run.\n-#[derive(Debug, Default, Clone, Copy)]\n-pub struct Summary {\n-    // Encountered e.g. an IO error.\n-    has_operational_errors: bool,\n-\n-    // Failed to reformat code because of parsing errors.\n-    has_parsing_errors: bool,\n-\n-    // Code is valid, but it is impossible to format it properly.\n-    has_formatting_errors: bool,\n-\n-    // Code contains macro call that was unable to format.\n-    pub(crate) has_macro_format_failure: bool,\n-\n-    // Failed a check, such as the license check or other opt-in checking.\n-    has_check_errors: bool,\n-\n-    /// Formatted code differs from existing code (--check only).\n-    pub has_diff: bool,\n-\n-    // Keeps track of time spent in parsing and formatting steps.\n-    timer: Timer,\n-}\n-\n-impl Summary {\n-    pub(crate) fn mark_parse_time(&mut self) {\n-        self.timer = self.timer.done_parsing();\n-    }\n-\n-    pub(crate) fn mark_format_time(&mut self) {\n-        self.timer = self.timer.done_formatting();\n-    }\n-\n-    /// Returns the time it took to parse the source files in nanoseconds.\n-    pub(crate) fn get_parse_time(&self) -> Option<Duration> {\n-        match self.timer {\n-            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n-                // This should never underflow since `Instant::now()` guarantees monotonicity.\n-                Some(parse_time.duration_since(init))\n-            }\n-            Timer::Initialized(..) => None,\n-        }\n-    }\n-\n-    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n-    /// not included.\n-    pub(crate) fn get_format_time(&self) -> Option<Duration> {\n-        match self.timer {\n-            Timer::DoneFormatting(_init, parse_time, format_time) => {\n-                Some(format_time.duration_since(parse_time))\n-            }\n-            Timer::DoneParsing(..) | Timer::Initialized(..) => None,\n-        }\n-    }\n-\n-    pub fn has_operational_errors(&self) -> bool {\n-        self.has_operational_errors\n-    }\n-\n-    pub fn has_parsing_errors(&self) -> bool {\n-        self.has_parsing_errors\n-    }\n-\n-    pub fn has_formatting_errors(&self) -> bool {\n-        self.has_formatting_errors\n-    }\n-\n-    pub fn has_check_errors(&self) -> bool {\n-        self.has_check_errors\n-    }\n-\n-    pub(crate) fn has_macro_formatting_failure(&self) -> bool {\n-        self.has_macro_format_failure\n-    }\n-\n-    pub fn add_operational_error(&mut self) {\n-        self.has_operational_errors = true;\n-    }\n-\n-    pub(crate) fn add_parsing_error(&mut self) {\n-        self.has_parsing_errors = true;\n-    }\n-\n-    pub(crate) fn add_formatting_error(&mut self) {\n-        self.has_formatting_errors = true;\n-    }\n-\n-    pub(crate) fn add_check_error(&mut self) {\n-        self.has_check_errors = true;\n-    }\n-\n-    pub(crate) fn add_diff(&mut self) {\n-        self.has_diff = true;\n-    }\n-\n-    pub(crate) fn add_macro_foramt_failure(&mut self) {\n-        self.has_macro_format_failure = true;\n-    }\n-\n-    pub fn has_no_errors(&self) -> bool {\n-        !(self.has_operational_errors\n-            || self.has_parsing_errors\n-            || self.has_formatting_errors\n-            || self.has_diff)\n-    }\n-\n-    /// Combine two summaries together.\n-    pub fn add(&mut self, other: Summary) {\n-        self.has_operational_errors |= other.has_operational_errors;\n-        self.has_formatting_errors |= other.has_formatting_errors;\n-        self.has_parsing_errors |= other.has_parsing_errors;\n-        self.has_check_errors |= other.has_check_errors;\n-        self.has_diff |= other.has_diff;\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-enum Timer {\n-    Initialized(Instant),\n-    DoneParsing(Instant, Instant),\n-    DoneFormatting(Instant, Instant, Instant),\n-}\n-\n-impl Default for Timer {\n-    fn default() -> Self {\n-        Timer::Initialized(Instant::now())\n-    }\n-}\n-\n-impl Timer {\n-    fn done_parsing(self) -> Self {\n-        match self {\n-            Timer::Initialized(init_time) => Timer::DoneParsing(init_time, Instant::now()),\n-            _ => panic!(\"Timer can only transition to DoneParsing from Initialized state\"),\n-        }\n-    }\n-\n-    fn done_formatting(self) -> Self {\n-        match self {\n-            Timer::DoneParsing(init_time, parse_time) => {\n-                Timer::DoneFormatting(init_time, parse_time, Instant::now())\n-            }\n-            _ => panic!(\"Timer can only transition to DoneFormatting from DoneParsing state\"),\n-        }\n-    }\n-}"}, {"sha": "43651fb45592e5884465d0f8c8f0a8cf0ad96e0e", "filename": "src/formatting.rs", "status": "modified", "additions": 137, "deletions": 8, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=069c4fc50871acfcf41f8726107daa26a29b488c", "patch": "@@ -4,7 +4,7 @@ use std::collections::HashMap;\n use std::io::{self, Write};\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n-use std::time::Duration;\n+use std::time::{Duration, Instant};\n \n use syntax::ast;\n use syntax::codemap::{CodeMap, FilePathMapping, Span};\n@@ -13,12 +13,11 @@ use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n \n use comment::{CharClasses, FullCodeCharKind};\n+use config::{Config, FileName, NewlineStyle, Verbosity};\n use issues::BadIssueSeeker;\n use visitor::{FmtVisitor, SnippetProvider};\n use {filemap, modules, ErrorKind, FormatReport, Input, Session};\n \n-use config::{Config, FileName, NewlineStyle, Verbosity};\n-\n // A map of the files of a crate, with their new content\n pub(crate) type FileMap = Vec<FileRecord>;\n \n@@ -343,16 +342,15 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n \n             println!(\n                 \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-                duration_to_f32(self.summary.get_parse_time().unwrap()),\n-                duration_to_f32(self.summary.get_format_time().unwrap()),\n+                duration_to_f32(self.get_parse_time().unwrap()),\n+                duration_to_f32(self.get_format_time().unwrap()),\n             )\n         });\n \n         format_result.map(|r| (filemap, r))\n     }\n \n     // TODO name, only uses config and summary\n-    // TODO move timing from summary to Session\n     // Formatting which depends on the AST.\n     fn format_ast<F>(\n         &mut self,\n@@ -389,7 +387,7 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n                 return Err(ErrorKind::ParseError);\n             }\n         };\n-        self.summary.mark_parse_time();\n+        self.timer = self.timer.done_parsing();\n \n         // Suppress error output if we have to do any further parsing.\n         let silent_emitter = Box::new(EmitterWriter::new(\n@@ -460,7 +458,7 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n \n             formatted_file(self, path, visitor.buffer)?;\n         }\n-        self.summary.mark_format_time();\n+        self.timer = self.timer.done_formatting();\n \n         if report.has_warnings() {\n             self.summary.add_formatting_error();\n@@ -527,6 +525,28 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             NewlineStyle::Native => unreachable!(),\n         }\n     }\n+\n+    /// Returns the time it took to parse the source files in nanoseconds.\n+    fn get_parse_time(&self) -> Option<Duration> {\n+        match self.timer {\n+            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n+                // This should never underflow since `Instant::now()` guarantees monotonicity.\n+                Some(parse_time.duration_since(init))\n+            }\n+            Timer::Initialized(..) => None,\n+        }\n+    }\n+\n+    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n+    /// not included.\n+    fn get_format_time(&self) -> Option<Duration> {\n+        match self.timer {\n+            Timer::DoneFormatting(_init, parse_time, format_time) => {\n+                Some(format_time.duration_since(parse_time))\n+            }\n+            Timer::DoneParsing(..) | Timer::Initialized(..) => None,\n+        }\n+    }\n }\n \n /// A single span of changed lines, with 0 or more removed lines\n@@ -547,3 +567,112 @@ pub(crate) struct ModifiedLines {\n     /// The set of changed chunks.\n     pub chunks: Vec<ModifiedChunk>,\n }\n+\n+#[derive(Clone, Copy, Debug)]\n+pub(crate) enum Timer {\n+    Initialized(Instant),\n+    DoneParsing(Instant, Instant),\n+    DoneFormatting(Instant, Instant, Instant),\n+}\n+\n+impl Timer {\n+    fn done_parsing(self) -> Self {\n+        match self {\n+            Timer::Initialized(init_time) => Timer::DoneParsing(init_time, Instant::now()),\n+            _ => panic!(\"Timer can only transition to DoneParsing from Initialized state\"),\n+        }\n+    }\n+\n+    fn done_formatting(self) -> Self {\n+        match self {\n+            Timer::DoneParsing(init_time, parse_time) => {\n+                Timer::DoneFormatting(init_time, parse_time, Instant::now())\n+            }\n+            _ => panic!(\"Timer can only transition to DoneFormatting from DoneParsing state\"),\n+        }\n+    }\n+}\n+\n+/// A summary of a Rustfmt run.\n+#[derive(Debug, Default, Clone, Copy)]\n+pub struct Summary {\n+    // Encountered e.g. an IO error.\n+    has_operational_errors: bool,\n+\n+    // Failed to reformat code because of parsing errors.\n+    has_parsing_errors: bool,\n+\n+    // Code is valid, but it is impossible to format it properly.\n+    has_formatting_errors: bool,\n+\n+    // Code contains macro call that was unable to format.\n+    pub(crate) has_macro_format_failure: bool,\n+\n+    // Failed a check, such as the license check or other opt-in checking.\n+    has_check_errors: bool,\n+\n+    /// Formatted code differs from existing code (--check only).\n+    pub has_diff: bool,\n+}\n+\n+impl Summary {\n+    pub fn has_operational_errors(&self) -> bool {\n+        self.has_operational_errors\n+    }\n+\n+    pub fn has_parsing_errors(&self) -> bool {\n+        self.has_parsing_errors\n+    }\n+\n+    pub fn has_formatting_errors(&self) -> bool {\n+        self.has_formatting_errors\n+    }\n+\n+    pub fn has_check_errors(&self) -> bool {\n+        self.has_check_errors\n+    }\n+\n+    pub(crate) fn has_macro_formatting_failure(&self) -> bool {\n+        self.has_macro_format_failure\n+    }\n+\n+    pub fn add_operational_error(&mut self) {\n+        self.has_operational_errors = true;\n+    }\n+\n+    pub(crate) fn add_parsing_error(&mut self) {\n+        self.has_parsing_errors = true;\n+    }\n+\n+    pub(crate) fn add_formatting_error(&mut self) {\n+        self.has_formatting_errors = true;\n+    }\n+\n+    pub(crate) fn add_check_error(&mut self) {\n+        self.has_check_errors = true;\n+    }\n+\n+    pub(crate) fn add_diff(&mut self) {\n+        self.has_diff = true;\n+    }\n+\n+    pub(crate) fn add_macro_foramt_failure(&mut self) {\n+        self.has_macro_format_failure = true;\n+    }\n+\n+    pub fn has_no_errors(&self) -> bool {\n+        !(self.has_operational_errors\n+            || self.has_parsing_errors\n+            || self.has_formatting_errors\n+            || self.has_diff)\n+    }\n+\n+    /// Combine two summaries together.\n+    pub fn add(&mut self, other: Summary) {\n+        self.has_operational_errors |= other.has_operational_errors;\n+        self.has_formatting_errors |= other.has_formatting_errors;\n+        self.has_parsing_errors |= other.has_parsing_errors;\n+        self.has_check_errors |= other.has_check_errors;\n+        self.has_diff |= other.has_diff;\n+    }\n+}"}, {"sha": "2cbe5c46e30387a2bd9ddd73c613026fcc7474e1", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=069c4fc50871acfcf41f8726107daa26a29b488c", "patch": "@@ -45,15 +45,15 @@ use std::io::{self, Write};\n use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n+use std::time::Instant;\n use syntax::ast;\n \n use comment::LineClasses;\n use failure::Fail;\n-use formatting::{FormatErrorMap, FormattingError, ReportedErrors};\n+use formatting::{FormatErrorMap, FormattingError, ReportedErrors, Summary, Timer};\n use issues::Issue;\n use shape::Indent;\n \n-pub use config::summary::Summary;\n pub use config::{\n     load_config, CliOptions, Color, Config, EmitMode, FileLines, FileName, NewlineStyle, Range,\n     Verbosity,\n@@ -445,6 +445,8 @@ pub struct Session<'b, T: Write + 'b> {\n     pub config: Config,\n     pub out: Option<&'b mut T>,\n     pub summary: Summary,\n+    // Keeps track of time spent in parsing and formatting steps.\n+    timer: Timer,\n }\n \n impl<'b, T: Write + 'b> Session<'b, T> {\n@@ -457,6 +459,7 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             config,\n             out,\n             summary: Summary::default(),\n+            timer: Timer::Initialized(Instant::now()),\n         }\n     }\n "}, {"sha": "d670bc1d5dbf7f7a8989300464cf3a70ccdc7eda", "filename": "src/test/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/069c4fc50871acfcf41f8726107daa26a29b488c/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=069c4fc50871acfcf41f8726107daa26a29b488c", "patch": "@@ -20,10 +20,9 @@ use std::iter::{Enumerate, Peekable};\n use std::path::{Path, PathBuf};\n use std::str::Chars;\n \n-use config::summary::Summary;\n use config::{Color, Config, EmitMode, FileName, ReportTactic};\n use filemap;\n-use formatting::{FileMap, ModifiedChunk};\n+use formatting::{FileMap, ModifiedChunk, Summary};\n use rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, OutputWriter};\n use {FormatReport, Input, Session};\n "}]}