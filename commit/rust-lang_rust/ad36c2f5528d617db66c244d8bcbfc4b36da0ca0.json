{"sha": "ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMzZjMmY1NTI4ZDYxN2RiNjZjMjQ0ZDhiY2JmYzRiMzZkYTBjYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-09T20:54:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-09T20:54:50Z"}, "message": "Auto merge of #41136 - estebank:multiline, r=jonathandturner\n\nAlways show end line of multiline annotations\n\n```rust\nerror[E0046]: not all trait items implemented, missing: `Item`\n  --> $DIR/issue-23729.rs:20:9\n   |\n20 |           impl Iterator for Recurrence {\n   |  _________^ starting here...\n21 | |             //~^ ERROR E0046\n22 | |             //~| NOTE missing `Item` in implementation\n23 | |             //~| NOTE `Item` from trait: `type Item;`\n...  |\n36 | |             }\n37 | |         }\n   | |_________^ ...ending here: missing `Item` in implementation\n   |\n   = note: `Item` from trait: `type Item;`\n```\n\ninstead of\n\n```rust\nerror[E0046]: not all trait items implemented, missing: `Item`\n  --> $DIR/issue-23729.rs:20:9\n   |\n20 |         impl Iterator for Recurrence {\n   |         ^ missing `Item` in implementation\n   |\n   = note: `Item` from trait: `type Item;`\n```", "tree": {"sha": "cac5538352053b2e9f2dfdab11458f8d2987fc13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cac5538352053b2e9f2dfdab11458f8d2987fc13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "html_url": "https://github.com/rust-lang/rust/commit/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "html_url": "https://github.com/rust-lang/rust/commit/d616f47cd03a65fed13be2ee5527f24f6a4f7f92"}, {"sha": "4bc7f5b52c41ffd45aaf8f27e7ec667f549011c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc7f5b52c41ffd45aaf8f27e7ec667f549011c6", "html_url": "https://github.com/rust-lang/rust/commit/4bc7f5b52c41ffd45aaf8f27e7ec667f549011c6"}], "stats": {"total": 366, "additions": 269, "deletions": 97}, "files": [{"sha": "a52628ceb47abf75382f84b1dda1b8247b18db1e", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 119, "deletions": 77, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "patch": "@@ -21,6 +21,8 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use term;\n+use std::collections::HashMap;\n+use std::cmp::min;\n \n /// Emitter trait for emitting errors.\n pub trait Emitter {\n@@ -156,15 +158,6 @@ impl EmitterWriter {\n                 }\n                 let lo = cm.lookup_char_pos(span_label.span.lo);\n                 let mut hi = cm.lookup_char_pos(span_label.span.hi);\n-                let mut is_minimized = false;\n-\n-                // If the span is long multi-line, simplify down to the span of one character\n-                let max_multiline_span_length = 8;\n-                if lo.line != hi.line && (hi.line - lo.line) > max_multiline_span_length {\n-                    hi.line = lo.line;\n-                    hi.col = CharPos(lo.col.0 + 1);\n-                    is_minimized = true;\n-                }\n \n                 // Watch out for \"empty spans\". If we get a span like 6..6, we\n                 // want to just display a `^` at 6, so convert that to\n@@ -175,16 +168,7 @@ impl EmitterWriter {\n                     hi.col = CharPos(lo.col.0 + 1);\n                 }\n \n-                let mut ann = Annotation {\n-                    start_col: lo.col.0,\n-                    end_col: hi.col.0,\n-                    is_primary: span_label.is_primary,\n-                    label: span_label.label.clone(),\n-                    annotation_type: AnnotationType::Singleline,\n-                };\n-                if is_minimized {\n-                    ann.annotation_type = AnnotationType::Minimized;\n-                } else if lo.line != hi.line {\n+                let ann_type = if lo.line != hi.line {\n                     let ml = MultilineAnnotation {\n                         depth: 1,\n                         line_start: lo.line,\n@@ -194,8 +178,17 @@ impl EmitterWriter {\n                         is_primary: span_label.is_primary,\n                         label: span_label.label.clone(),\n                     };\n-                    ann.annotation_type = AnnotationType::Multiline(ml.clone());\n-                    multiline_annotations.push((lo.file.clone(), ml));\n+                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n+                    AnnotationType::Multiline(ml)\n+                } else {\n+                    AnnotationType::Singleline\n+                };\n+                let ann = Annotation {\n+                    start_col: lo.col.0,\n+                    end_col: hi.col.0,\n+                    is_primary: span_label.is_primary,\n+                    label: span_label.label.clone(),\n+                    annotation_type: ann_type,\n                 };\n \n                 if !ann.is_multiline() {\n@@ -233,9 +226,15 @@ impl EmitterWriter {\n                 max_depth = ann.depth;\n             }\n             add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n-            for line in ann.line_start + 1..ann.line_end {\n+            let middle = min(ann.line_start + 4, ann.line_end);\n+            for line in ann.line_start + 1..middle {\n                 add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n             }\n+            if middle < ann.line_end - 1 {\n+                for line in ann.line_end - 1..ann.line_end {\n+                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                }\n+            }\n             add_annotation_to_file(&mut output, file, ann.line_end, ann.as_end());\n         }\n         for file_vec in output.iter_mut() {\n@@ -249,16 +248,11 @@ impl EmitterWriter {\n                           file: Rc<FileMap>,\n                           line: &Line,\n                           width_offset: usize,\n-                          multiline_depth: usize) {\n+                          code_offset: usize) -> Vec<(usize, Style)> {\n         let source_string = file.get_line(line.line_index - 1)\n             .unwrap_or(\"\");\n \n         let line_offset = buffer.num_lines();\n-        let code_offset = if multiline_depth == 0 {\n-            width_offset\n-        } else {\n-            width_offset + multiline_depth + 1\n-        };\n \n         // First create the source line we will highlight.\n         buffer.puts(line_offset, code_offset, &source_string, Style::Quotation);\n@@ -286,7 +280,7 @@ impl EmitterWriter {\n         //      previous borrow of `vec` occurs here\n         //\n         // For this reason, we group the lines into \"highlight lines\"\n-        // and \"annotations lines\", where the highlight lines have the `~`.\n+        // and \"annotations lines\", where the highlight lines have the `^`.\n \n         // Sort the annotations by (start, end col)\n         let mut annotations = line.annotations.clone();\n@@ -410,25 +404,9 @@ impl EmitterWriter {\n         // If there are no annotations or the only annotations on this line are\n         // MultilineLine, then there's only code being shown, stop processing.\n         if line.annotations.is_empty() || line.annotations.iter()\n-            .filter(|a| {\n-                // Set the multiline annotation vertical lines to the left of\n-                // the code in this line.\n-                if let AnnotationType::MultilineLine(depth) = a.annotation_type {\n-                    buffer.putc(line_offset,\n-                                width_offset + depth - 1,\n-                                '|',\n-                                if a.is_primary {\n-                                    Style::UnderlinePrimary\n-                                } else {\n-                                    Style::UnderlineSecondary\n-                                });\n-                    false\n-                } else {\n-                    true\n-                }\n-            }).collect::<Vec<_>>().len() == 0\n+            .filter(|a| !a.is_line()).collect::<Vec<_>>().len() == 0\n         {\n-            return;\n+            return vec![];\n         }\n \n         // Write the colunmn separator.\n@@ -483,16 +461,15 @@ impl EmitterWriter {\n             }\n         }\n \n-        // Write the vertical lines for multiline spans and for labels that are\n-        // on a different line as the underline.\n+        // Write the vertical lines for labels that are on a different line as the underline.\n         //\n         // After this we will have:\n         //\n         // 2 |   fn foo() {\n         //   |  __________\n         //   | |    |\n         //   | |\n-        // 3 | |\n+        // 3 |\n         // 4 | | }\n         //   | |_\n         for &(pos, annotation) in &annotations_position {\n@@ -528,16 +505,6 @@ impl EmitterWriter {\n                                     style);\n                     }\n                 }\n-                AnnotationType::MultilineLine(depth) => {\n-                    // the first line will have already be filled when we checked\n-                    // wether there were any annotations for this line.\n-                    for p in line_offset + 1..line_offset + line_len + 2 {\n-                        buffer.putc(p,\n-                                    width_offset + depth - 1,\n-                                    '|',\n-                                    style);\n-                    }\n-                }\n                 _ => (),\n             }\n         }\n@@ -548,11 +515,11 @@ impl EmitterWriter {\n         //\n         // 2 |   fn foo() {\n         //   |  __________ starting here...\n-        //   | |    |\n-        //   | |    something about `foo`\n-        // 3 | |\n-        // 4 | | }\n-        //   | |_  ...ending here: test\n+        //   |      |\n+        //   |      something about `foo`\n+        // 3 |\n+        // 4 |   }\n+        //   |  _  ...ending here: test\n         for &(pos, annotation) in &annotations_position {\n             let style = if annotation.is_primary {\n                 Style::LabelPrimary\n@@ -591,11 +558,11 @@ impl EmitterWriter {\n         //\n         // 2 |   fn foo() {\n         //   |  ____-_____^ starting here...\n-        //   | |    |\n-        //   | |    something about `foo`\n-        // 3 | |\n-        // 4 | | }\n-        //   | |_^  ...ending here: test\n+        //   |      |\n+        //   |      something about `foo`\n+        // 3 |\n+        // 4 |   }\n+        //   |  _^  ...ending here: test\n         for &(_, annotation) in &annotations_position {\n             let (underline, style) = if annotation.is_primary {\n                 ('^', Style::UnderlinePrimary)\n@@ -609,6 +576,20 @@ impl EmitterWriter {\n                             style);\n             }\n         }\n+        annotations_position.iter().filter_map(|&(_, annotation)| {\n+            match annotation.annotation_type {\n+                AnnotationType::MultilineStart(p) | AnnotationType::MultilineEnd(p) => {\n+                    let style = if annotation.is_primary {\n+                        Style::LabelPrimary\n+                    } else {\n+                        Style::LabelSecondary\n+                    };\n+                    Some((p, style))\n+                },\n+                _ => None\n+            }\n+\n+        }).collect::<Vec<_>>()\n     }\n \n     fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n@@ -902,22 +883,64 @@ impl EmitterWriter {\n             let buffer_msg_line_offset = buffer.num_lines();\n             draw_col_separator_no_space(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n \n+            // Contains the vertical lines' positions for active multiline annotations\n+            let mut multilines = HashMap::new();\n+\n             // Next, output the annotate source for this file\n             for line_idx in 0..annotated_file.lines.len() {\n-                self.render_source_line(&mut buffer,\n-                                        annotated_file.file.clone(),\n-                                        &annotated_file.lines[line_idx],\n-                                        3 + max_line_num_len,\n-                                        annotated_file.multiline_depth);\n+                let previous_buffer_line = buffer.num_lines();\n+\n+                let width_offset = 3 + max_line_num_len;\n+                let code_offset = if annotated_file.multiline_depth == 0 {\n+                    width_offset\n+                } else {\n+                    width_offset + annotated_file.multiline_depth + 1\n+                };\n+\n+                let depths = self.render_source_line(&mut buffer,\n+                                                     annotated_file.file.clone(),\n+                                                     &annotated_file.lines[line_idx],\n+                                                     width_offset,\n+                                                     code_offset);\n \n+                let mut to_add = HashMap::new();\n+\n+                for (depth, style) in depths {\n+                    if multilines.get(&depth).is_some() {\n+                        multilines.remove(&depth);\n+                    } else {\n+                        to_add.insert(depth, style);\n+                    }\n+                }\n+\n+                // Set the multiline annotation vertical lines to the left of\n+                // the code in this line.\n+                for (depth, style) in &multilines {\n+                    for line in previous_buffer_line..buffer.num_lines() {\n+                        draw_multiline_line(&mut buffer,\n+                                            line,\n+                                            width_offset,\n+                                            *depth,\n+                                            *style);\n+                    }\n+                }\n                 // check to see if we need to print out or elide lines that come between\n-                // this annotated line and the next one\n+                // this annotated line and the next one.\n                 if line_idx < (annotated_file.lines.len() - 1) {\n                     let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n                                          annotated_file.lines[line_idx].line_index;\n                     if line_idx_delta > 2 {\n                         let last_buffer_line_num = buffer.num_lines();\n                         buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n+\n+                        // Set the multiline annotation vertical lines on `...` bridging line.\n+                        for (depth, style) in &multilines {\n+                            draw_multiline_line(&mut buffer,\n+                                                last_buffer_line_num,\n+                                                width_offset,\n+                                                *depth,\n+                                                *style);\n+                        }\n                     } else if line_idx_delta == 2 {\n                         let unannotated_line = annotated_file.file\n                             .get_line(annotated_file.lines[line_idx].line_index)\n@@ -932,11 +955,21 @@ impl EmitterWriter {\n                                     Style::LineNumber);\n                         draw_col_separator(&mut buffer, last_buffer_line_num, 1 + max_line_num_len);\n                         buffer.puts(last_buffer_line_num,\n-                                    3 + max_line_num_len,\n+                                    code_offset,\n                                     &unannotated_line,\n                                     Style::Quotation);\n+\n+                        for (depth, style) in &multilines {\n+                            draw_multiline_line(&mut buffer,\n+                                                last_buffer_line_num,\n+                                                width_offset,\n+                                                *depth,\n+                                                *style);\n+                        }\n                     }\n                 }\n+\n+                multilines.extend(&to_add);\n             }\n         }\n \n@@ -1085,6 +1118,15 @@ fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"= \", Style::LineNumber);\n }\n \n+fn draw_multiline_line(buffer: &mut StyledBuffer,\n+                       line: usize,\n+                       offset: usize,\n+                       depth: usize,\n+                       style: Style)\n+{\n+    buffer.putc(line, offset + depth - 1, '|', style);\n+}\n+\n fn num_overlap(a_start: usize, a_end: usize, b_start: usize, b_end:usize, inclusive: bool) -> bool {\n     let extra = if inclusive {\n         1"}, {"sha": "9aa4682e1afcbfc2f8239803c64eaa0a6bb409d5", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "patch": "@@ -97,9 +97,6 @@ pub enum AnnotationType {\n     /// Annotation under a single line of code\n     Singleline,\n \n-    /// Annotation under the first character of a multiline span\n-    Minimized,\n-\n     /// Annotation enclosing the first and last character of a multiline span\n     Multiline(MultilineAnnotation),\n \n@@ -118,6 +115,9 @@ pub enum AnnotationType {\n     /// Annotation marking the last character of a fully shown multiline span\n     MultilineEnd(usize),\n     /// Line at the left enclosing the lines of a fully shown multiline span\n+    // Just a placeholder for the drawing algorithm, to know that it shouldn't skip the first 4\n+    // and last 2 lines of code. The actual line is drawn in `emit_message_default` and not in\n+    // `draw_multiline_line`.\n     MultilineLine(usize),\n }\n \n@@ -144,13 +144,6 @@ pub struct Annotation {\n }\n \n impl Annotation {\n-    pub fn is_minimized(&self) -> bool {\n-        match self.annotation_type {\n-            AnnotationType::Minimized => true,\n-            _ => false,\n-        }\n-    }\n-\n     /// Wether this annotation is a vertical line placeholder.\n     pub fn is_line(&self) -> bool {\n         if let AnnotationType::MultilineLine(_) = self.annotation_type {"}, {"sha": "a74f59b004bb76116ef75f4789f9bb4df58dcfca", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "patch": "@@ -932,3 +932,137 @@ error: foo\n \n \"#);\n }\n+\n+#[test]\n+fn long_snippet() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+  X1 Y1 Z1\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+  X2 Y2 Z2\n+  X3 Y3 Z3\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X1\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Z1\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Z3\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+  --> test.rs:3:6\n+   |\n+3  |      X0 Y0 Z0\n+   |   ______^ starting here...\n+4  |  |   X1 Y1 Z1\n+   |  |____^____- starting here...\n+   | ||____|\n+   | |     ...ending here: `X` is a good letter\n+5  | |  1\n+6  | |  2\n+7  | |  3\n+...  |\n+15 | |    X2 Y2 Z2\n+16 | |    X3 Y3 Z3\n+   | |___________- ...ending here: `Y` is a good letter too\n+\n+\"#);\n+}\n+\n+#[test]\n+fn long_snippet_multiple_spans() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+1\n+2\n+3\n+  X1 Y1 Z1\n+4\n+5\n+6\n+  X2 Y2 Z2\n+7\n+8\n+9\n+10\n+  X3 Y3 Z3\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Y3\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Z1\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Z2\",\n+                count: 1,\n+            },\n+            label: \"`Z` is a good letter too\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+  --> test.rs:3:6\n+   |\n+3  |      X0 Y0 Z0\n+   |   ______^ starting here...\n+4  |  | 1\n+5  |  | 2\n+6  |  | 3\n+7  |  |   X1 Y1 Z1\n+   |  |_________- starting here...\n+8  | || 4\n+9  | || 5\n+10 | || 6\n+11 | ||   X2 Y2 Z2\n+   | ||__________- ...ending here: `Z` is a good letter too\n+...   |\n+15 |  | 10\n+16 |  |   X3 Y3 Z3\n+   |  |_______^ ...ending here: `Y` is a good letter\n+\n+\"#);\n+}\n+"}, {"sha": "367af12bb6b1c2f122e667b001a41cacac78d00f", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "patch": "@@ -24,8 +24,7 @@ error[E0046]: not all trait items implemented, missing: `bar`\n 23 | |     //~^ ERROR E0046\n 24 | |     //~| NOTE missing `bar` in implementation\n 25 | |     const bar: u64 = 1;\n-26 | |     //~^ ERROR E0323\n-27 | |     //~| NOTE does not match trait\n+...  |\n 28 | |     const MY_CONST: u32 = 1;\n 29 | | }\n    | |_^ ...ending here: missing `bar` in implementation\n@@ -50,8 +49,7 @@ error[E0046]: not all trait items implemented, missing: `MY_CONST`\n 34 | |     //~^ ERROR E0046\n 35 | |     //~| NOTE missing `MY_CONST` in implementation\n 36 | |     fn bar(&self) {}\n-37 | |     fn MY_CONST() {}\n-38 | |     //~^ ERROR E0324\n+...  |\n 39 | |     //~| NOTE does not match trait\n 40 | | }\n    | |_^ ...ending here: missing `MY_CONST` in implementation\n@@ -76,8 +74,7 @@ error[E0046]: not all trait items implemented, missing: `bar`\n 45 | |     //~^ ERROR E0046\n 46 | |     //~| NOTE missing `bar` in implementation\n 47 | |     type bar = u64;\n-48 | |     //~^ ERROR E0325\n-49 | |     //~| NOTE does not match trait\n+...  |\n 50 | |     const MY_CONST: u32 = 1;\n 51 | | }\n    | |_^ ...ending here: missing `bar` in implementation"}, {"sha": "701576ff6f475bf59e4eeb74eed2a637b7043968", "filename": "src/test/ui/span/issue-23729.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr?ref=ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "patch": "@@ -1,8 +1,15 @@\n error[E0046]: not all trait items implemented, missing: `Item`\n   --> $DIR/issue-23729.rs:20:9\n    |\n-20 |         impl Iterator for Recurrence {\n-   |         ^ missing `Item` in implementation\n+20 |           impl Iterator for Recurrence {\n+   |  _________^ starting here...\n+21 | |             //~^ ERROR E0046\n+22 | |             //~| NOTE missing `Item` in implementation\n+23 | |             //~| NOTE `Item` from trait: `type Item;`\n+...  |\n+36 | |             }\n+37 | |         }\n+   | |_________^ ...ending here: missing `Item` in implementation\n    |\n    = note: `Item` from trait: `type Item;`\n "}, {"sha": "457fed34ff1ad9807d41d62889090436273f9472", "filename": "src/test/ui/span/issue-23827.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad36c2f5528d617db66c244d8bcbfc4b36da0ca0/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr?ref=ad36c2f5528d617db66c244d8bcbfc4b36da0ca0", "patch": "@@ -6,8 +6,7 @@ error[E0046]: not all trait items implemented, missing: `Output`\n 37 | |     //~^ ERROR E0046\n 38 | |     //~| NOTE missing `Output` in implementation\n 39 | |     //~| NOTE `Output` from trait: `type Output;`\n-40 | |     extern \"rust-call\" fn call_once(self, (comp,): (C,)) -> Prototype {\n-41 | |         Fn::call(&self, (comp,))\n+...  |\n 42 | |     }\n 43 | | }\n    | |_^ ...ending here: missing `Output` in implementation"}]}