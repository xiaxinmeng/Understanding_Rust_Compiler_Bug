{"sha": "30ddeefcf09023b5924844bd3a2ac7573c60faf8", "node_id": "C_kwDOAAsO6NoAKDMwZGRlZWZjZjA5MDIzYjU5MjQ4NDRiZDNhMmFjNzU3M2M2MGZhZjg", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-01-19T10:19:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-19T10:19:34Z"}, "message": "Rollup merge of #105977 - Swatinem:async-mir-context, r=oli-obk\n\nTransform async `ResumeTy` in generator transform\n\n- Eliminates all the `get_context` calls that async lowering created.\n- Replace all `Local` `ResumeTy` types with `&mut Context<'_>`.\n\nThe `Local`s that have their types replaced are:\n- The `resume` argument itself.\n- The argument to `get_context`.\n- The yielded value of a `yield`.\n\nThe `ResumeTy` hides a `&mut Context<'_>` behind an unsafe raw pointer, and the `get_context` function is being used to convert that back to a `&mut Context<'_>`.\n\nIdeally the async lowering would not use the `ResumeTy`/`get_context` indirection, but rather directly use `&mut Context<'_>`, however that would currently lead to higher-kinded lifetime errors.\nSee <https://github.com/rust-lang/rust/issues/105501>.\n\nThe async lowering step and the type / lifetime inference / checking are still using the `ResumeTy` indirection for the time being, and that indirection is removed here. After this transform, the generator body only knows about `&mut Context<'_>`.\n\n---\n\nFixes https://github.com/bjorn3/rustc_codegen_cranelift/issues/1330 CC `@bjorn3`\n\nr? `@compiler-errors`", "tree": {"sha": "a5d1bc8838c77308c70e0d98a9e0a26fe4c60c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5d1bc8838c77308c70e0d98a9e0a26fe4c60c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30ddeefcf09023b5924844bd3a2ac7573c60faf8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjyRk2CRBK7hj4Ov3rIwAAZ1wIABl99TrJFs4lTR4DfsSXxt7O\nQiq8vjyWaN2Qu0KRVOQhz7zMTPi1NkO50du7+/52fdNmNUWrd2d/XBGUPbjZiu1K\nNz/hT0Q+/n4Y38ZvTrBZRJZ+J2QeySHd5xDCqfUgSxrZ5YSKfjlCIQNTJrt36zMP\nKX3HeOQaoALJ4KmDd7zjV3kHfF51TgH4xMz3BW/i9LWDpiUKHICHWXnJOhn7TMKj\nNtYHlx4rXskEe/e6Hcfb9z9LXxFp5DLZUZu236Gv2Rp4+Tvz0PFkXRuQj8izPgUp\n3GMoIqvc3dJU6bgOlnORL9sTd/QfUkp4K2FC4U75+rdQD+DEC48H1oRTT4S2DOw=\n=DeBJ\n-----END PGP SIGNATURE-----\n", "payload": "tree a5d1bc8838c77308c70e0d98a9e0a26fe4c60c1b\nparent 65d2f2a5f9c323c88d1068e8e90d0b47a20d491c\nparent 96931a787abaac7d720fc415780037fc63bee98d\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1674123574 +0100\ncommitter GitHub <noreply@github.com> 1674123574 +0100\n\nRollup merge of #105977 - Swatinem:async-mir-context, r=oli-obk\n\nTransform async `ResumeTy` in generator transform\n\n- Eliminates all the `get_context` calls that async lowering created.\n- Replace all `Local` `ResumeTy` types with `&mut Context<'_>`.\n\nThe `Local`s that have their types replaced are:\n- The `resume` argument itself.\n- The argument to `get_context`.\n- The yielded value of a `yield`.\n\nThe `ResumeTy` hides a `&mut Context<'_>` behind an unsafe raw pointer, and the `get_context` function is being used to convert that back to a `&mut Context<'_>`.\n\nIdeally the async lowering would not use the `ResumeTy`/`get_context` indirection, but rather directly use `&mut Context<'_>`, however that would currently lead to higher-kinded lifetime errors.\nSee <https://github.com/rust-lang/rust/issues/105501>.\n\nThe async lowering step and the type / lifetime inference / checking are still using the `ResumeTy` indirection for the time being, and that indirection is removed here. After this transform, the generator body only knows about `&mut Context<'_>`.\n\n---\n\nFixes https://github.com/bjorn3/rustc_codegen_cranelift/issues/1330 CC `@bjorn3`\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30ddeefcf09023b5924844bd3a2ac7573c60faf8", "html_url": "https://github.com/rust-lang/rust/commit/30ddeefcf09023b5924844bd3a2ac7573c60faf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30ddeefcf09023b5924844bd3a2ac7573c60faf8/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d2f2a5f9c323c88d1068e8e90d0b47a20d491c", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d2f2a5f9c323c88d1068e8e90d0b47a20d491c", "html_url": "https://github.com/rust-lang/rust/commit/65d2f2a5f9c323c88d1068e8e90d0b47a20d491c"}, {"sha": "96931a787abaac7d720fc415780037fc63bee98d", "url": "https://api.github.com/repos/rust-lang/rust/commits/96931a787abaac7d720fc415780037fc63bee98d", "html_url": "https://github.com/rust-lang/rust/commit/96931a787abaac7d720fc415780037fc63bee98d"}], "stats": {"total": 563, "additions": 549, "deletions": 14}, "files": [{"sha": "54fa5702fbca4b49298e49472722991f023a9751", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -291,6 +291,7 @@ language_item_table! {\n     IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n     GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n+    Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n     FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;"}, {"sha": "ce04d8d21f4cdf2e4255d13faccc98f781d61681", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -1952,6 +1952,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(GeneratorWitness(types))\n     }\n \n+    /// Creates a `&mut Context<'_>` [`Ty`] with erased lifetimes.\n+    pub fn mk_task_context(self) -> Ty<'tcx> {\n+        let context_did = self.require_lang_item(LangItem::Context, None);\n+        let context_adt_ref = self.adt_def(context_did);\n+        let context_substs = self.intern_substs(&[self.lifetimes.re_erased.into()]);\n+        let context_ty = self.mk_adt(context_adt_ref, context_substs);\n+        self.mk_mut_ref(self.lifetimes.re_erased, context_ty)\n+    }\n+\n     #[inline]\n     pub fn mk_ty_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_ty_infer(TyVar(v))"}, {"sha": "39c61a34afcbdab70fa189af8a82527e35993f7e", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 111, "deletions": 7, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -460,6 +460,104 @@ fn replace_local<'tcx>(\n     new_local\n }\n \n+/// Transforms the `body` of the generator applying the following transforms:\n+///\n+/// - Eliminates all the `get_context` calls that async lowering created.\n+/// - Replace all `Local` `ResumeTy` types with `&mut Context<'_>` (`context_mut_ref`).\n+///\n+/// The `Local`s that have their types replaced are:\n+/// - The `resume` argument itself.\n+/// - The argument to `get_context`.\n+/// - The yielded value of a `yield`.\n+///\n+/// The `ResumeTy` hides a `&mut Context<'_>` behind an unsafe raw pointer, and the\n+/// `get_context` function is being used to convert that back to a `&mut Context<'_>`.\n+///\n+/// Ideally the async lowering would not use the `ResumeTy`/`get_context` indirection,\n+/// but rather directly use `&mut Context<'_>`, however that would currently\n+/// lead to higher-kinded lifetime errors.\n+/// See <https://github.com/rust-lang/rust/issues/105501>.\n+///\n+/// The async lowering step and the type / lifetime inference / checking are\n+/// still using the `ResumeTy` indirection for the time being, and that indirection\n+/// is removed here. After this transform, the generator body only knows about `&mut Context<'_>`.\n+fn transform_async_context<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let context_mut_ref = tcx.mk_task_context();\n+\n+    // replace the type of the `resume` argument\n+    replace_resume_ty_local(tcx, body, Local::new(2), context_mut_ref);\n+\n+    let get_context_def_id = tcx.require_lang_item(LangItem::GetContext, None);\n+\n+    for bb in BasicBlock::new(0)..body.basic_blocks.next_index() {\n+        let bb_data = &body[bb];\n+        if bb_data.is_cleanup {\n+            continue;\n+        }\n+\n+        match &bb_data.terminator().kind {\n+            TerminatorKind::Call { func, .. } => {\n+                let func_ty = func.ty(body, tcx);\n+                if let ty::FnDef(def_id, _) = *func_ty.kind() {\n+                    if def_id == get_context_def_id {\n+                        let local = eliminate_get_context_call(&mut body[bb]);\n+                        replace_resume_ty_local(tcx, body, local, context_mut_ref);\n+                    }\n+                } else {\n+                    continue;\n+                }\n+            }\n+            TerminatorKind::Yield { resume_arg, .. } => {\n+                replace_resume_ty_local(tcx, body, resume_arg.local, context_mut_ref);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn eliminate_get_context_call<'tcx>(bb_data: &mut BasicBlockData<'tcx>) -> Local {\n+    let terminator = bb_data.terminator.take().unwrap();\n+    if let TerminatorKind::Call { mut args, destination, target, .. } = terminator.kind {\n+        let arg = args.pop().unwrap();\n+        let local = arg.place().unwrap().local;\n+\n+        let arg = Rvalue::Use(arg);\n+        let assign = Statement {\n+            source_info: terminator.source_info,\n+            kind: StatementKind::Assign(Box::new((destination, arg))),\n+        };\n+        bb_data.statements.push(assign);\n+        bb_data.terminator = Some(Terminator {\n+            source_info: terminator.source_info,\n+            kind: TerminatorKind::Goto { target: target.unwrap() },\n+        });\n+        local\n+    } else {\n+        bug!();\n+    }\n+}\n+\n+#[cfg_attr(not(debug_assertions), allow(unused))]\n+fn replace_resume_ty_local<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    local: Local,\n+    context_mut_ref: Ty<'tcx>,\n+) {\n+    let local_ty = std::mem::replace(&mut body.local_decls[local].ty, context_mut_ref);\n+    // We have to replace the `ResumeTy` that is used for type and borrow checking\n+    // with `&mut Context<'_>` in MIR.\n+    #[cfg(debug_assertions)]\n+    {\n+        if let ty::Adt(resume_ty_adt, _) = local_ty.kind() {\n+            let expected_adt = tcx.adt_def(tcx.require_lang_item(LangItem::ResumeTy, None));\n+            assert_eq!(*resume_ty_adt, expected_adt);\n+        } else {\n+            panic!(\"expected `ResumeTy`, found `{:?}`\", local_ty);\n+        };\n+    }\n+}\n+\n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n     saved_locals: GeneratorSavedLocals,\n@@ -1283,13 +1381,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             }\n         };\n \n-        let is_async_kind = body.generator_kind().unwrap() != GeneratorKind::Gen;\n+        let is_async_kind = matches!(body.generator_kind(), Some(GeneratorKind::Async(_)));\n         let (state_adt_ref, state_substs) = if is_async_kind {\n             // Compute Poll<return_ty>\n-            let state_did = tcx.require_lang_item(LangItem::Poll, None);\n-            let state_adt_ref = tcx.adt_def(state_did);\n-            let state_substs = tcx.intern_substs(&[body.return_ty().into()]);\n-            (state_adt_ref, state_substs)\n+            let poll_did = tcx.require_lang_item(LangItem::Poll, None);\n+            let poll_adt_ref = tcx.adt_def(poll_did);\n+            let poll_substs = tcx.intern_substs(&[body.return_ty().into()]);\n+            (poll_adt_ref, poll_substs)\n         } else {\n             // Compute GeneratorState<yield_ty, return_ty>\n             let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n@@ -1303,13 +1401,19 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n         let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx);\n \n+        // Replace all occurrences of `ResumeTy` with `&mut Context<'_>` within async bodies.\n+        if is_async_kind {\n+            transform_async_context(tcx, body);\n+        }\n+\n         // We also replace the resume argument and insert an `Assign`.\n         // This is needed because the resume argument `_2` might be live across a `yield`, in which\n         // case there is no `Assign` to it that the transform can turn into a store to the generator\n         // state. After the yield the slot in the generator state would then be uninitialized.\n         let resume_local = Local::new(2);\n-        let new_resume_local =\n-            replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx);\n+        let resume_ty =\n+            if is_async_kind { tcx.mk_task_context() } else { body.local_decls[resume_local].ty };\n+        let new_resume_local = replace_local(resume_local, resume_ty, body, tcx);\n \n         // When first entering the generator, move the resume argument into its new local.\n         let source_info = SourceInfo::outermost(body.span);"}, {"sha": "7597b8d126a9ceb55375ecdb2f9f523cd756e093", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -164,6 +164,7 @@ symbols! {\n         Capture,\n         Center,\n         Clone,\n+        Context,\n         Continue,\n         Copy,\n         Count,"}, {"sha": "91a505a72fae7a6be74b31e2b2ff0909af29b877", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -108,21 +108,41 @@ fn fn_sig_for_fn_abi<'tcx>(\n             // `Generator::resume(...) -> GeneratorState` function in case we\n             // have an ordinary generator, or the `Future::poll(...) -> Poll`\n             // function in case this is a special generator backing an async construct.\n-            let ret_ty = if tcx.generator_is_async(did) {\n-                let state_did = tcx.require_lang_item(LangItem::Poll, None);\n-                let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs = tcx.intern_substs(&[sig.return_ty.into()]);\n-                tcx.mk_adt(state_adt_ref, state_substs)\n+            let (resume_ty, ret_ty) = if tcx.generator_is_async(did) {\n+                // The signature should be `Future::poll(_, &mut Context<'_>) -> Poll<Output>`\n+                let poll_did = tcx.require_lang_item(LangItem::Poll, None);\n+                let poll_adt_ref = tcx.adt_def(poll_did);\n+                let poll_substs = tcx.intern_substs(&[sig.return_ty.into()]);\n+                let ret_ty = tcx.mk_adt(poll_adt_ref, poll_substs);\n+\n+                // We have to replace the `ResumeTy` that is used for type and borrow checking\n+                // with `&mut Context<'_>` which is used in codegen.\n+                #[cfg(debug_assertions)]\n+                {\n+                    if let ty::Adt(resume_ty_adt, _) = sig.resume_ty.kind() {\n+                        let expected_adt =\n+                            tcx.adt_def(tcx.require_lang_item(LangItem::ResumeTy, None));\n+                        assert_eq!(*resume_ty_adt, expected_adt);\n+                    } else {\n+                        panic!(\"expected `ResumeTy`, found `{:?}`\", sig.resume_ty);\n+                    };\n+                }\n+                let context_mut_ref = tcx.mk_task_context();\n+\n+                (context_mut_ref, ret_ty)\n             } else {\n+                // The signature should be `Generator::resume(_, Resume) -> GeneratorState<Yield, Return>`\n                 let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n                 let state_adt_ref = tcx.adt_def(state_did);\n                 let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                tcx.mk_adt(state_adt_ref, state_substs)\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                (sig.resume_ty, ret_ty)\n             };\n \n             ty::Binder::bind_with_vars(\n                 tcx.mk_fn_sig(\n-                    [env_ty, sig.resume_ty].iter(),\n+                    [env_ty, resume_ty].iter(),\n                     &ret_ty,\n                     false,\n                     hir::Unsafety::Normal,"}, {"sha": "c4fb362094664196a354070a1a8a246062734959", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -112,6 +112,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n+// FIXME(swatinem): This fn is currently needed to work around shortcomings\n+// in type and lifetime inference.\n+// See the comment at the bottom of `LoweringContext::make_async_expr` and\n+// <https://github.com/rust-lang/rust/issues/104826>.\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]"}, {"sha": "89adfccd90135233ef2ac66b533571bbbc3eeae5", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -174,6 +174,7 @@ impl RawWakerVTable {\n /// Currently, `Context` only serves to provide access to a [`&Waker`](Waker)\n /// which can be used to wake the current task.\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"Context\")]\n pub struct Context<'a> {\n     waker: &'a Waker,\n     // Ensure we future-proof against variance changes by forcing"}, {"sha": "2a7f90fe9476a4513c6bbe2478399b7022f0aa75", "filename": "tests/mir-opt/building/async_await.a-{closure#0}.generator_resume.0.mir", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/tests%2Fmir-opt%2Fbuilding%2Fasync_await.a-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/tests%2Fmir-opt%2Fbuilding%2Fasync_await.a-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fasync_await.a-%7Bclosure%230%7D.generator_resume.0.mir?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -0,0 +1,41 @@\n+// MIR for `a::{closure#0}` 0 generator_resume\n+/* generator_layout = GeneratorLayout {\n+    field_tys: {},\n+    variant_fields: {\n+        Unresumed(0): [],\n+        Returned (1): [],\n+        Panicked (2): [],\n+    },\n+    storage_conflicts: BitMatrix(0x0) {},\n+} */\n+\n+fn a::{closure#0}(_1: Pin<&mut [async fn body@$DIR/async_await.rs:11:14: 11:16]>, _2: &mut Context<'_>) -> Poll<()> {\n+    debug _task_context => _4;           // in scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    let mut _0: std::task::Poll<()>;     // return place in scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    let mut _3: ();                      // in scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    let mut _4: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    let mut _5: u32;                     // in scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+\n+    bb0: {\n+        _5 = discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:11:14: 11:16]))); // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+        switchInt(move _5) -> [0: bb1, 1: bb2, otherwise: bb3]; // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    }\n+\n+    bb1: {\n+        _4 = move _2;                    // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+        _3 = const ();                   // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+        Deinit(_0);                      // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n+        ((_0 as Ready).0: ()) = move _3; // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n+        discriminant(_0) = 0;            // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n+        discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:11:14: 11:16]))) = 1; // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n+        return;                          // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n+    }\n+\n+    bb2: {\n+        assert(const false, \"`async fn` resumed after completion\") -> bb2; // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    }\n+\n+    bb3: {\n+        unreachable;                     // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n+    }\n+}"}, {"sha": "05edc4797d4e552cd7f1aa3a6c03587f20e0ee20", "filename": "tests/mir-opt/building/async_await.b-{closure#0}.generator_resume.0.mir", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -0,0 +1,337 @@\n+// MIR for `b::{closure#0}` 0 generator_resume\n+/* generator_layout = GeneratorLayout {\n+    field_tys: {\n+        _0: impl std::future::Future<Output = ()>,\n+        _1: impl std::future::Future<Output = ()>,\n+    },\n+    variant_fields: {\n+        Unresumed(0): [],\n+        Returned (1): [],\n+        Panicked (2): [],\n+        Suspend0 (3): [_0],\n+        Suspend1 (4): [_1],\n+    },\n+    storage_conflicts: BitMatrix(2x2) {\n+        (_0, _0),\n+        (_1, _1),\n+    },\n+} */\n+\n+fn b::{closure#0}(_1: Pin<&mut [async fn body@$DIR/async_await.rs:14:18: 17:2]>, _2: &mut Context<'_>) -> Poll<()> {\n+    debug _task_context => _38;          // in scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    let mut _0: std::task::Poll<()>;     // return place in scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    let _3: ();                          // in scope 0 at $DIR/async_await.rs:+1:5: +1:14\n+    let mut _4: impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _5: impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+1:5: +1:8\n+    let mut _6: impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _7: ();                      // in scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    let _8: ();                          // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _9: std::task::Poll<()>;     // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _10: std::pin::Pin<&mut impl std::future::Future<Output = ()>>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _11: &mut impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _12: &mut impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _13: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+1:5: +1:14\n+    let mut _14: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+1:5: +1:14\n+    let mut _15: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _16: isize;                  // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _18: !;                      // in scope 0 at $DIR/async_await.rs:+1:5: +1:14\n+    let mut _19: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _20: ();                     // in scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+    let mut _21: impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _22: impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+2:5: +2:8\n+    let mut _23: impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let _24: ();                         // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _25: std::task::Poll<()>;    // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _26: std::pin::Pin<&mut impl std::future::Future<Output = ()>>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _27: &mut impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _28: &mut impl std::future::Future<Output = ()>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _29: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+2:5: +2:14\n+    let mut _30: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+2:5: +2:14\n+    let mut _31: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _32: isize;                  // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _34: !;                      // in scope 0 at $DIR/async_await.rs:+2:5: +2:14\n+    let mut _35: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _36: ();                     // in scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+    let mut _37: ();                     // in scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    let mut _38: &mut std::task::Context<'_>; // in scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    let mut _39: u32;                    // in scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    scope 1 {\n+        debug __awaitee => (((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2])) as variant#3).0: impl std::future::Future<Output = ()>); // in scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        let _17: ();                     // in scope 1 at $DIR/async_await.rs:+1:5: +1:14\n+        scope 2 {\n+        }\n+        scope 3 {\n+            debug result => _17;         // in scope 3 at $DIR/async_await.rs:+1:5: +1:14\n+        }\n+    }\n+    scope 4 {\n+        debug __awaitee => (((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2])) as variant#4).0: impl std::future::Future<Output = ()>); // in scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        let _33: ();                     // in scope 4 at $DIR/async_await.rs:+2:5: +2:14\n+        scope 5 {\n+        }\n+        scope 6 {\n+            debug result => _33;         // in scope 6 at $DIR/async_await.rs:+2:5: +2:14\n+        }\n+    }\n+\n+    bb0: {\n+        _39 = discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))); // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        switchInt(move _39) -> [0: bb1, 1: bb29, 3: bb27, 4: bb28, otherwise: bb30]; // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    }\n+\n+    bb1: {\n+        _38 = move _2;                   // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        StorageLive(_3);                 // scope 0 at $DIR/async_await.rs:+1:5: +1:14\n+        StorageLive(_4);                 // scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageLive(_5);                 // scope 0 at $DIR/async_await.rs:+1:5: +1:8\n+        _5 = a() -> bb2;                 // scope 0 at $DIR/async_await.rs:+1:5: +1:8\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:15:5: 15:6\n+                                         // + literal: Const { ty: fn() -> impl Future<Output = ()> {a}, val: Value(<ZST>) }\n+    }\n+\n+    bb2: {\n+        _4 = <impl Future<Output = ()> as IntoFuture>::into_future(move _5) -> bb3; // scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:15:8: 15:14\n+                                         // + literal: Const { ty: fn(impl Future<Output = ()>) -> <impl Future<Output = ()> as IntoFuture>::IntoFuture {<impl Future<Output = ()> as IntoFuture>::into_future}, val: Value(<ZST>) }\n+    }\n+\n+    bb3: {\n+        StorageDead(_5);                 // scope 0 at $DIR/async_await.rs:+1:13: +1:14\n+        nop;                             // scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+        (((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2])) as variant#3).0: impl std::future::Future<Output = ()>) = move _4; // scope 0 at $DIR/async_await.rs:+1:8: +1:14\n+        goto -> bb4;                     // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+    }\n+\n+    bb4: {\n+        StorageLive(_8);                 // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageLive(_9);                 // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageLive(_10);                // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageLive(_11);                // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageLive(_12);                // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        _12 = &mut (((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2])) as variant#3).0: impl std::future::Future<Output = ()>); // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        _11 = &mut (*_12);               // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        _10 = Pin::<&mut impl Future<Output = ()>>::new_unchecked(move _11) -> bb5; // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:15:8: 15:14\n+                                         // + literal: Const { ty: unsafe fn(&mut impl Future<Output = ()>) -> Pin<&mut impl Future<Output = ()>> {Pin::<&mut impl Future<Output = ()>>::new_unchecked}, val: Value(<ZST>) }\n+    }\n+\n+    bb5: {\n+        StorageDead(_11);                // scope 2 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageLive(_13);                // scope 2 at $DIR/async_await.rs:+1:5: +1:14\n+        StorageLive(_14);                // scope 2 at $DIR/async_await.rs:+1:5: +1:14\n+        StorageLive(_15);                // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        _15 = _38;                       // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+        _14 = move _15;                  // scope 2 at $DIR/async_await.rs:+1:5: +1:14\n+        goto -> bb6;                     // scope 2 at $DIR/async_await.rs:+1:5: +1:14\n+    }\n+\n+    bb6: {\n+        _13 = &mut (*_14);               // scope 2 at $DIR/async_await.rs:+1:5: +1:14\n+        StorageDead(_15);                // scope 2 at $DIR/async_await.rs:+1:13: +1:14\n+        _9 = <impl Future<Output = ()> as Future>::poll(move _10, move _13) -> bb7; // scope 2 at $DIR/async_await.rs:+1:8: +1:14\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:15:8: 15:14\n+                                         // + literal: Const { ty: for<'a, 'b, 'c> fn(Pin<&'a mut impl Future<Output = ()>>, &'b mut Context<'c>) -> Poll<<impl Future<Output = ()> as Future>::Output> {<impl Future<Output = ()> as Future>::poll}, val: Value(<ZST>) }\n+    }\n+\n+    bb7: {\n+        StorageDead(_13);                // scope 2 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_10);                // scope 2 at $DIR/async_await.rs:+1:13: +1:14\n+        _16 = discriminant(_9);          // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        switchInt(move _16) -> [0: bb10, 1: bb8, otherwise: bb9]; // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+    }\n+\n+    bb8: {\n+        _8 = const ();                   // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageDead(_14);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_12);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_9);                 // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_8);                 // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageLive(_19);                // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageLive(_20);                // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        _20 = ();                        // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        Deinit(_0);                      // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        discriminant(_0) = 1;            // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))) = 3; // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        return;                          // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+    }\n+\n+    bb9: {\n+        unreachable;                     // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+    }\n+\n+    bb10: {\n+        StorageLive(_17);                // scope 1 at $DIR/async_await.rs:+1:5: +1:14\n+        _17 = ((_9 as Ready).0: ());     // scope 1 at $DIR/async_await.rs:+1:5: +1:14\n+        _3 = _17;                        // scope 3 at $DIR/async_await.rs:+1:5: +1:14\n+        StorageDead(_17);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_14);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_12);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_9);                 // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        StorageDead(_8);                 // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        goto -> bb12;                    // scope 0 at $DIR/async_await.rs:+1:13: +1:14\n+    }\n+\n+    bb11: {\n+        StorageDead(_20);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        _38 = move _19;                  // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        StorageDead(_19);                // scope 1 at $DIR/async_await.rs:+1:13: +1:14\n+        _7 = const ();                   // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        goto -> bb4;                     // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+    }\n+\n+    bb12: {\n+        nop;                             // scope 0 at $DIR/async_await.rs:+1:13: +1:14\n+        goto -> bb13;                    // scope 0 at $DIR/async_await.rs:+1:14: +1:15\n+    }\n+\n+    bb13: {\n+        StorageDead(_4);                 // scope 0 at $DIR/async_await.rs:+1:14: +1:15\n+        StorageDead(_3);                 // scope 0 at $DIR/async_await.rs:+1:14: +1:15\n+        StorageLive(_21);                // scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageLive(_22);                // scope 0 at $DIR/async_await.rs:+2:5: +2:8\n+        _22 = a() -> bb14;               // scope 0 at $DIR/async_await.rs:+2:5: +2:8\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:16:5: 16:6\n+                                         // + literal: Const { ty: fn() -> impl Future<Output = ()> {a}, val: Value(<ZST>) }\n+    }\n+\n+    bb14: {\n+        _21 = <impl Future<Output = ()> as IntoFuture>::into_future(move _22) -> bb15; // scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:16:8: 16:14\n+                                         // + literal: Const { ty: fn(impl Future<Output = ()>) -> <impl Future<Output = ()> as IntoFuture>::IntoFuture {<impl Future<Output = ()> as IntoFuture>::into_future}, val: Value(<ZST>) }\n+    }\n+\n+    bb15: {\n+        StorageDead(_22);                // scope 0 at $DIR/async_await.rs:+2:13: +2:14\n+        nop;                             // scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+        (((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2])) as variant#4).0: impl std::future::Future<Output = ()>) = move _21; // scope 0 at $DIR/async_await.rs:+2:8: +2:14\n+        goto -> bb16;                    // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+    }\n+\n+    bb16: {\n+        StorageLive(_24);                // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageLive(_25);                // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageLive(_26);                // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageLive(_27);                // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageLive(_28);                // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        _28 = &mut (((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2])) as variant#4).0: impl std::future::Future<Output = ()>); // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        _27 = &mut (*_28);               // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        _26 = Pin::<&mut impl Future<Output = ()>>::new_unchecked(move _27) -> bb17; // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:16:8: 16:14\n+                                         // + literal: Const { ty: unsafe fn(&mut impl Future<Output = ()>) -> Pin<&mut impl Future<Output = ()>> {Pin::<&mut impl Future<Output = ()>>::new_unchecked}, val: Value(<ZST>) }\n+    }\n+\n+    bb17: {\n+        StorageDead(_27);                // scope 5 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageLive(_29);                // scope 5 at $DIR/async_await.rs:+2:5: +2:14\n+        StorageLive(_30);                // scope 5 at $DIR/async_await.rs:+2:5: +2:14\n+        StorageLive(_31);                // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        _31 = _38;                       // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+        _30 = move _31;                  // scope 5 at $DIR/async_await.rs:+2:5: +2:14\n+        goto -> bb18;                    // scope 5 at $DIR/async_await.rs:+2:5: +2:14\n+    }\n+\n+    bb18: {\n+        _29 = &mut (*_30);               // scope 5 at $DIR/async_await.rs:+2:5: +2:14\n+        StorageDead(_31);                // scope 5 at $DIR/async_await.rs:+2:13: +2:14\n+        _25 = <impl Future<Output = ()> as Future>::poll(move _26, move _29) -> bb19; // scope 5 at $DIR/async_await.rs:+2:8: +2:14\n+                                         // mir::Constant\n+                                         // + span: $DIR/async_await.rs:16:8: 16:14\n+                                         // + literal: Const { ty: for<'a, 'b, 'c> fn(Pin<&'a mut impl Future<Output = ()>>, &'b mut Context<'c>) -> Poll<<impl Future<Output = ()> as Future>::Output> {<impl Future<Output = ()> as Future>::poll}, val: Value(<ZST>) }\n+    }\n+\n+    bb19: {\n+        StorageDead(_29);                // scope 5 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_26);                // scope 5 at $DIR/async_await.rs:+2:13: +2:14\n+        _32 = discriminant(_25);         // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        switchInt(move _32) -> [0: bb22, 1: bb20, otherwise: bb21]; // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+    }\n+\n+    bb20: {\n+        _24 = const ();                  // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageDead(_30);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_28);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_25);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_24);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageLive(_35);                // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageLive(_36);                // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        _36 = ();                        // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        Deinit(_0);                      // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        discriminant(_0) = 1;            // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))) = 4; // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        return;                          // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+    }\n+\n+    bb21: {\n+        unreachable;                     // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+    }\n+\n+    bb22: {\n+        StorageLive(_33);                // scope 4 at $DIR/async_await.rs:+2:5: +2:14\n+        _33 = ((_25 as Ready).0: ());    // scope 4 at $DIR/async_await.rs:+2:5: +2:14\n+        _37 = _33;                       // scope 6 at $DIR/async_await.rs:+2:5: +2:14\n+        StorageDead(_33);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_30);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_28);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_25);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        StorageDead(_24);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        goto -> bb24;                    // scope 0 at $DIR/async_await.rs:+2:13: +2:14\n+    }\n+\n+    bb23: {\n+        StorageDead(_36);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        _38 = move _35;                  // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        StorageDead(_35);                // scope 4 at $DIR/async_await.rs:+2:13: +2:14\n+        _7 = const ();                   // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        goto -> bb16;                    // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+    }\n+\n+    bb24: {\n+        nop;                             // scope 0 at $DIR/async_await.rs:+2:13: +2:14\n+        goto -> bb25;                    // scope 0 at $DIR/async_await.rs:+3:1: +3:2\n+    }\n+\n+    bb25: {\n+        StorageDead(_21);                // scope 0 at $DIR/async_await.rs:+3:1: +3:2\n+        goto -> bb26;                    // scope 0 at $DIR/async_await.rs:+3:1: +3:2\n+    }\n+\n+    bb26: {\n+        Deinit(_0);                      // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n+        ((_0 as Ready).0: ()) = move _37; // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n+        discriminant(_0) = 0;            // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n+        discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))) = 1; // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n+        return;                          // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n+    }\n+\n+    bb27: {\n+        StorageLive(_3);                 // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        StorageLive(_4);                 // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        StorageLive(_19);                // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        StorageLive(_20);                // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        _19 = move _2;                   // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        goto -> bb11;                    // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    }\n+\n+    bb28: {\n+        StorageLive(_21);                // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        StorageLive(_35);                // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        StorageLive(_36);                // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        _35 = move _2;                   // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+        goto -> bb23;                    // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    }\n+\n+    bb29: {\n+        assert(const false, \"`async fn` resumed after completion\") -> bb29; // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    }\n+\n+    bb30: {\n+        unreachable;                     // scope 0 at $DIR/async_await.rs:+0:18: +3:2\n+    }\n+}"}, {"sha": "0b991e3b8f8cc7ebb8d46161cd49839cc1f3db8b", "filename": "tests/mir-opt/building/async_await.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/30ddeefcf09023b5924844bd3a2ac7573c60faf8/tests%2Fmir-opt%2Fbuilding%2Fasync_await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ddeefcf09023b5924844bd3a2ac7573c60faf8/tests%2Fmir-opt%2Fbuilding%2Fasync_await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fasync_await.rs?ref=30ddeefcf09023b5924844bd3a2ac7573c60faf8", "patch": "@@ -0,0 +1,17 @@\n+// This test makes sure that the generator MIR pass eliminates all calls to\n+// `get_context`, and that the MIR argument type for an async fn and all locals\n+// related to `yield` are `&mut Context`, and its return type is `Poll`.\n+\n+// edition:2018\n+// compile-flags: -C panic=abort\n+\n+#![crate_type = \"lib\"]\n+\n+// EMIT_MIR async_await.a-{closure#0}.generator_resume.0.mir\n+async fn a() {}\n+\n+// EMIT_MIR async_await.b-{closure#0}.generator_resume.0.mir\n+pub async fn b() {\n+    a().await;\n+    a().await\n+}"}]}