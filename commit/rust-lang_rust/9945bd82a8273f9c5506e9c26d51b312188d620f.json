{"sha": "9945bd82a8273f9c5506e9c26d51b312188d620f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NDViZDgyYTgyNzNmOWM1NTA2ZTljMjZkNTFiMzEyMTg4ZDYyMGY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-03T16:19:49Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-03T16:19:49Z"}, "message": "Add better error messages for HashMapLint", "tree": {"sha": "e1f2ba99d13c44e558ed7eefc697a55c2529fc53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1f2ba99d13c44e558ed7eefc697a55c2529fc53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9945bd82a8273f9c5506e9c26d51b312188d620f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9945bd82a8273f9c5506e9c26d51b312188d620f", "html_url": "https://github.com/rust-lang/rust/commit/9945bd82a8273f9c5506e9c26d51b312188d620f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9945bd82a8273f9c5506e9c26d51b312188d620f/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0bb71e6a23d45b4e367007da1099df9db424b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0bb71e6a23d45b4e367007da1099df9db424b8d", "html_url": "https://github.com/rust-lang/rust/commit/d0bb71e6a23d45b4e367007da1099df9db424b8d"}], "stats": {"total": 61, "additions": 49, "deletions": 12}, "files": [{"sha": "095a00e3777bb702a3de99701c7b903594587280", "filename": "src/hashmap.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9945bd82a8273f9c5506e9c26d51b312188d620f/src%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9945bd82a8273f9c5506e9c26d51b312188d620f/src%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhashmap.rs?ref=9945bd82a8273f9c5506e9c26d51b312188d620f", "patch": "@@ -14,7 +14,14 @@ use utils::HASHMAP_PATH;\n /// if !m.contains_key(k) { m.insert(k.clone(), v); }\n /// ```\n ///\n-/// **Example:** `if !m.contains_key(&k) { m.insert(k, v) }`\n+/// **Example:**\n+/// ```rust\n+/// if !m.contains_key(&k) { m.insert(k, v) }\n+/// ```\n+/// can be rewritten as:\n+/// ```rust\n+/// m.entry(k).or_insert(v);\n+/// ```\n declare_lint! {\n     pub HASHMAP_ENTRY,\n     Warn,\n@@ -49,13 +56,15 @@ impl LateLintPass for HashMapLint {\n                 let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n \n                 if match_type(cx, obj_ty, &HASHMAP_PATH) {\n+                    let sole_expr = if then.expr.is_some() { 1 } else { 0 } + then.stmts.len() == 1;\n+\n                     if let Some(ref then) = then.expr {\n-                        check_for_insert(cx, expr.span, map, key, then);\n+                        check_for_insert(cx, expr.span, map, key, then, sole_expr);\n                     }\n \n                     for stmt in &then.stmts {\n                         if let StmtSemi(ref stmt, _) = stmt.node {\n-                            check_for_insert(cx, expr.span, map, key, stmt);\n+                            check_for_insert(cx, expr.span, map, key, stmt, sole_expr);\n                         }\n                     }\n                 }\n@@ -64,7 +73,7 @@ impl LateLintPass for HashMapLint {\n     }\n }\n \n-fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr: &Expr) {\n+fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr: &Expr, sole_expr: bool) {\n     if_let_chain! {\n         [\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n@@ -73,11 +82,21 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n             get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n             is_exp_equal(cx, key, &params[1])\n         ], {\n-            span_help_and_lint(cx, HASHMAP_ENTRY, span,\n-                               \"usage of `contains_key` followed by `insert` on `HashMap`\",\n-                               &format!(\"Consider using `{}.entry({})`\",\n-                                        snippet(cx, map.span, \"..\"),\n-                                        snippet(cx, params[1].span, \"..\")));\n+            if sole_expr {\n+                span_help_and_lint(cx, HASHMAP_ENTRY, span,\n+                                   \"usage of `contains_key` followed by `insert` on `HashMap`\",\n+                                   &format!(\"Consider using `{}.entry({}).or_insert({})`\",\n+                                            snippet(cx, map.span, \"..\"),\n+                                            snippet(cx, params[1].span, \"..\"),\n+                                            snippet(cx, params[2].span, \"..\"))); \n+            }\n+            else {\n+                span_help_and_lint(cx, HASHMAP_ENTRY, span,\n+                                   \"usage of `contains_key` followed by `insert` on `HashMap`\",\n+                                   &format!(\"Consider using `{}.entry({})`\",\n+                                            snippet(cx, map.span, \"..\"),\n+                                            snippet(cx, params[1].span, \"..\")));\n+            }\n         }\n     }\n }"}, {"sha": "a53566a794e8932fc493373f6f1dd60a196b7202", "filename": "tests/compile-fail/hashmap.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9945bd82a8273f9c5506e9c26d51b312188d620f/tests%2Fcompile-fail%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9945bd82a8273f9c5506e9c26d51b312188d620f/tests%2Fcompile-fail%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fhashmap.rs?ref=9945bd82a8273f9c5506e9c26d51b312188d620f", "patch": "@@ -7,12 +7,30 @@\n use std::collections::HashMap;\n use std::hash::Hash;\n \n-fn insert_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) { m.insert(k, v); } //~ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { m.insert(k, v); }\n+    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n+    //~^^HELP: Consider using `m.entry(k).or_insert(v)`\n+}\n+\n+fn insert_if_absent1<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { foo(); m.insert(k, v); }\n+    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n+    //~^^HELP: Consider using `m.entry(k)`\n }\n \n fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) { m.insert(k, v) } else { None }; //~ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n+    if !m.contains_key(&k) { m.insert(k, v) } else { None };\n+    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n+    //~^^HELP: Consider using `m.entry(k).or_insert(v)`\n+}\n+\n+fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n+    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n+    //~^^HELP: Consider using `m.entry(k)`\n }\n \n fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {"}]}