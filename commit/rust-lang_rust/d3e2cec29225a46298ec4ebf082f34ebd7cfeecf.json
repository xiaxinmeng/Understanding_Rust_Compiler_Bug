{"sha": "d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZTJjZWMyOTIyNWE0NjI5OGVjNGViZjA4MmYzNGViZDdjZmVlY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-26T04:42:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-26T04:42:34Z"}, "message": "Auto merge of #61872 - matthewjasper:refactor-mir-drop-gen, r=nikomatsakis\n\nClean up MIR drop generation\n\n* Don't assign twice to the destination of a `while` loop containing a `break` expression\n* Use `as_temp` to evaluate statement expression\n* Avoid consecutive `StorageLive`s for the condition of a `while` loop\n* Unify `return`, `break` and `continue` handling, and move it to `scopes.rs`\n* Make some of the `scopes.rs` internals private\n* Don't use `Place`s that are always `Local`s in MIR drop generation\n\nCloses #42371\nCloses #61579\nCloses #61731\nCloses #61834\nCloses #61910\nCloses #62115", "tree": {"sha": "e89a27ae84c6a99867e0dcb1e46df2649d7e95f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e89a27ae84c6a99867e0dcb1e46df2649d7e95f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "html_url": "https://github.com/rust-lang/rust/commit/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd4bda4d5fe7eb24a7209a6c0c968a54869d3b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd4bda4d5fe7eb24a7209a6c0c968a54869d3b7", "html_url": "https://github.com/rust-lang/rust/commit/bdd4bda4d5fe7eb24a7209a6c0c968a54869d3b7"}, {"sha": "3131427784b2c9f906a50b290f7d3cc215d0c0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3131427784b2c9f906a50b290f7d3cc215d0c0e8", "html_url": "https://github.com/rust-lang/rust/commit/3131427784b2c9f906a50b290f7d3cc215d0c0e8"}], "stats": {"total": 1004, "additions": 536, "deletions": 468}, "files": [{"sha": "7ea08b15b443d71e3027052bc5429a988d8dcf18", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let source_info = this.source_info(span);\n         for stmt in stmts {\n-            let Stmt { kind, opt_destruction_scope, span: stmt_span } = this.hir.mirror(stmt);\n+            let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             let si = (scope, source_info);\n                             this.in_scope(si, LintLevel::Inherited, |this| {\n                                 let expr = this.hir.mirror(expr);\n-                                this.stmt_expr(block, expr, Some(stmt_span))\n+                                this.stmt_expr(block, expr, Some(scope))\n                             })\n                         }));\n                 }"}, {"sha": "17e7b1acc68f06e30bcddfe12cfb3359cf9eda09", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.schedule_drop_storage_and_value(\n                         expr_span,\n                         scope,\n-                        &Place::from(result),\n+                        result,\n                         value.ty,\n                     );\n                 }\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.schedule_drop_storage_and_value(\n                 upvar_span,\n                 temp_lifetime,\n-                &Place::from(temp),\n+                temp,\n                 upvar_ty,\n             );\n         }"}, {"sha": "1fe6be8bbc82eee739a1da45f3d6d7004e850b11", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.schedule_drop(\n                     expr_span,\n                     temp_lifetime,\n-                    temp_place,\n+                    temp,\n                     expr_ty,\n                     DropKind::Storage,\n                 );\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.schedule_drop(\n                 expr_span,\n                 temp_lifetime,\n-                temp_place,\n+                temp,\n                 expr_ty,\n                 DropKind::Value,\n             );"}, {"sha": "0a2ea78bfd7abfe1a5aa898001299a67393993fc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -179,20 +179,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // conduct the test, if necessary\n                         let body_block;\n                         if let Some(cond_expr) = opt_cond_expr {\n-                            let loop_block_end;\n-                            let cond = unpack!(\n-                                loop_block_end = this.as_local_operand(loop_block, cond_expr)\n-                            );\n-                            body_block = this.cfg.start_new_block();\n-                            let term =\n-                                TerminatorKind::if_(this.hir.tcx(), cond, body_block, exit_block);\n-                            this.cfg.terminate(loop_block_end, source_info, term);\n+                            let cond_expr = this.hir.mirror(cond_expr);\n+                            let (true_block, false_block)\n+                                = this.test_bool(loop_block, cond_expr, source_info);\n+                            body_block = true_block;\n \n                             // if the test is false, there's no `break` to assign `destination`, so\n-                            // we have to do it; this overwrites any `break`-assigned value but it's\n-                            // always `()` anyway\n-                            this.cfg\n-                                .push_assign_unit(exit_block, source_info, destination);\n+                            // we have to do it\n+                            this.cfg.push_assign_unit(false_block, source_info, destination);\n+                            this.cfg.terminate(\n+                                false_block,\n+                                source_info,\n+                                TerminatorKind::Goto { target: exit_block },\n+                            );\n                         } else {\n                             body_block = this.cfg.start_new_block();\n                             let diverge_cleanup = this.diverge_cleanup();"}, {"sha": "cf3d8778da19366db21d46aa1323fd709ec2e555", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 39, "deletions": 106, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -1,21 +1,21 @@\n-use crate::build::scope::BreakableScope;\n+use crate::build::scope::BreakableTarget;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Builds a block of MIR statements to evaluate the HAIR `expr`.\n     /// If the original expression was an AST statement,\n     /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n     /// span of that statement (including its semicolon, if any).\n-    /// Diagnostics use this span (which may be larger than that of\n-    /// `expr`) to identify when statement temporaries are dropped.\n-    pub fn stmt_expr(&mut self,\n-                     mut block: BasicBlock,\n-                     expr: Expr<'tcx>,\n-                     opt_stmt_span: Option<StatementSpan>)\n-                     -> BlockAnd<()>\n-    {\n+    /// The scope is used if a statement temporary must be dropped.\n+    pub fn stmt_expr(\n+        &mut self,\n+        mut block: BasicBlock,\n+        expr: Expr<'tcx>,\n+        statement_scope: Option<region::Scope>,\n+    ) -> BlockAnd<()> {\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr.span);\n@@ -30,7 +30,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let value = this.hir.mirror(value);\n                 this.in_scope((region_scope, source_info), lint_level, |this| {\n-                    this.stmt_expr(block, value, opt_stmt_span)\n+                    this.stmt_expr(block, value, statement_scope)\n                 })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n@@ -98,70 +98,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                let BreakableScope {\n-                    continue_block,\n-                    region_scope,\n-                    ..\n-                } = *this.find_breakable_scope(expr_span, label);\n-                let continue_block = continue_block\n-                    .expect(\"Attempted to continue in non-continuable breakable block\");\n-                this.exit_scope(\n-                    expr_span,\n-                    (region_scope, source_info),\n-                    block,\n-                    continue_block,\n-                );\n-                this.cfg.start_new_block().unit()\n+                this.break_scope(block, None, BreakableTarget::Continue(label), source_info)\n             }\n             ExprKind::Break { label, value } => {\n-                let (break_block, region_scope, destination) = {\n-                    let BreakableScope {\n-                        break_block,\n-                        region_scope,\n-                        ref break_destination,\n-                        ..\n-                    } = *this.find_breakable_scope(expr_span, label);\n-                    (break_block, region_scope, break_destination.clone())\n-                };\n-                if let Some(value) = value {\n-                    debug!(\"stmt_expr Break val block_context.push(SubExpr) : {:?}\", expr2);\n-                    this.block_context.push(BlockFrame::SubExpr);\n-                    unpack!(block = this.into(&destination, block, value));\n-                    this.block_context.pop();\n-                } else {\n-                    this.cfg.push_assign_unit(block, source_info, &destination)\n-                }\n-                this.exit_scope(expr_span, (region_scope, source_info), block, break_block);\n-                this.cfg.start_new_block().unit()\n+                this.break_scope(block, value, BreakableTarget::Break(label), source_info)\n             }\n             ExprKind::Return { value } => {\n-                block = match value {\n-                    Some(value) => {\n-                        debug!(\"stmt_expr Return val block_context.push(SubExpr) : {:?}\", expr2);\n-                        this.block_context.push(BlockFrame::SubExpr);\n-                        let result = unpack!(\n-                            this.into(\n-                                &Place::RETURN_PLACE,\n-                                block,\n-                                value\n-                            )\n-                        );\n-                        this.block_context.pop();\n-                        result\n-                    }\n-                    None => {\n-                        this.cfg.push_assign_unit(\n-                            block,\n-                            source_info,\n-                            &Place::RETURN_PLACE,\n-                        );\n-                        block\n-                    }\n-                };\n-                let region_scope = this.region_scope_of_return_scope();\n-                let return_block = this.return_block();\n-                this.exit_scope(expr_span, (region_scope, source_info), block, return_block);\n-                this.cfg.start_new_block().unit()\n+                this.break_scope(block, value, BreakableTarget::Return, source_info)\n             }\n             ExprKind::InlineAsm {\n                 asm,\n@@ -199,7 +142,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             _ => {\n-                let expr_ty = expr.ty;\n+                assert!(\n+                    statement_scope.is_some(),\n+                    \"Should not be calling `stmt_expr` on a general expression \\\n+                     without a statement scope\",\n+                );\n \n                 // Issue #54382: When creating temp for the value of\n                 // expression like:\n@@ -208,48 +155,34 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //\n                 // it is usually better to focus on `the_value` rather\n                 // than the entirety of block(s) surrounding it.\n-                let mut temp_span = expr_span;\n-                let mut temp_in_tail_of_block = false;\n-                if let ExprKind::Block { body } = expr.kind {\n-                    if let Some(tail_expr) = &body.expr {\n-                        let mut expr = tail_expr;\n-                        while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.node {\n-                            if let Some(subtail_expr) = &subblock.expr {\n-                                expr = subtail_expr\n-                            } else {\n-                                break;\n+                let adjusted_span = (|| {\n+                    if let ExprKind::Block { body } = expr.kind {\n+                        if let Some(tail_expr) = &body.expr {\n+                            let mut expr = tail_expr;\n+                            while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.node {\n+                                if let Some(subtail_expr) = &subblock.expr {\n+                                    expr = subtail_expr\n+                                } else {\n+                                    break;\n+                                }\n                             }\n-                        }\n-                        temp_span = expr.span;\n-                        temp_in_tail_of_block = true;\n-                    }\n-                }\n-\n-                let temp = {\n-                    let mut local_decl = LocalDecl::new_temp(expr.ty.clone(), temp_span);\n-                    if temp_in_tail_of_block {\n-                        if this.block_context.currently_ignores_tail_results() {\n-                            local_decl = local_decl.block_tail(BlockTailInfo {\n+                            this.block_context.push(BlockFrame::TailExpr {\n                                 tail_result_is_ignored: true\n                             });\n+                            return Some(expr.span);\n                         }\n                     }\n-                    let temp = this.local_decls.push(local_decl);\n-                    let place = Place::from(temp);\n-                    debug!(\"created temp {:?} for expr {:?} in block_context: {:?}\",\n-                           temp, expr, this.block_context);\n-                    place\n-                };\n-                unpack!(block = this.into(&temp, block, expr));\n+                    None\n+                })();\n \n-                // Attribute drops of the statement's temps to the\n-                // semicolon at the statement's end.\n-                let drop_point = this.hir.tcx().sess.source_map().end_point(match opt_stmt_span {\n-                    None => expr_span,\n-                    Some(StatementSpan(span)) => span,\n-                });\n+                let temp = unpack!(block =\n+                    this.as_temp(block, statement_scope, expr, Mutability::Not));\n+\n+                if let Some(span) = adjusted_span {\n+                    this.local_decls[temp].source_info.span = span;\n+                    this.block_context.pop();\n+                }\n \n-                unpack!(block = this.build_drop(block, drop_point, temp, expr_ty));\n                 block.unit()\n             }\n         }"}, {"sha": "f831f5105a4686d368ff694b8c34d3b399a07ac0", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 52, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -531,11 +531,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 kind: StatementKind::StorageLive(local_id),\n             },\n         );\n-        let place = Place::from(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n-        place\n+        self.schedule_drop(span, region_scope, local_id, var_ty, DropKind::Storage);\n+        Place::Base(PlaceBase::Local(local_id))\n     }\n \n     pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n@@ -545,7 +544,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.schedule_drop(\n             span,\n             region_scope,\n-            &Place::from(local_id),\n+            local_id,\n             var_ty,\n             DropKind::Value,\n         );\n@@ -1490,15 +1489,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             };\n             let source_info = self.source_info(guard.span);\n             let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n-            let cond = unpack!(block = self.as_local_operand(block, guard));\n+            let (post_guard_block, otherwise_post_guard_block)\n+                = self.test_bool(block, guard, source_info);\n             let guard_frame = self.guard_context.pop().unwrap();\n             debug!(\n                 \"Exiting guard building context with locals: {:?}\",\n                 guard_frame\n             );\n \n             for &(_, temp) in fake_borrows {\n-                self.cfg.push(block, Statement {\n+                self.cfg.push(post_guard_block, Statement {\n                     source_info: guard_end,\n                     kind: StatementKind::FakeRead(\n                         FakeReadCause::ForMatchGuard,\n@@ -1507,6 +1507,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n             }\n \n+            self.exit_scope(\n+                source_info.span,\n+                region_scope,\n+                otherwise_post_guard_block,\n+                candidate.otherwise_block.unwrap(),\n+            );\n+\n             // We want to ensure that the matched candidates are bound\n             // after we have confirmed this candidate *and* any\n             // associated guard; Binding them on `block` is too soon,\n@@ -1533,41 +1540,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // ```\n             //\n             // and that is clearly not correct.\n-            let post_guard_block = self.cfg.start_new_block();\n-            let otherwise_post_guard_block = self.cfg.start_new_block();\n-            self.cfg.terminate(\n-                block,\n-                source_info,\n-                TerminatorKind::if_(\n-                    self.hir.tcx(),\n-                    cond.clone(),\n-                    post_guard_block,\n-                    otherwise_post_guard_block,\n-                ),\n-            );\n-\n-            self.exit_scope(\n-                source_info.span,\n-                region_scope,\n-                otherwise_post_guard_block,\n-                candidate.otherwise_block.unwrap(),\n-            );\n-\n-            if let Operand::Copy(cond_place) | Operand::Move(cond_place) = cond {\n-                if let Place::Base(PlaceBase::Local(cond_temp)) = cond_place {\n-                    // We will call `clear_top_scope` if there's another guard. So\n-                    // we have to drop this variable now or it will be \"storage\n-                    // leaked\".\n-                    self.pop_variable(\n-                        post_guard_block,\n-                        region_scope.0,\n-                        cond_temp\n-                    );\n-                } else {\n-                    bug!(\"Expected as_local_operand to produce a temporary\");\n-                }\n-            }\n-\n             let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n                 if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n             });\n@@ -1577,7 +1549,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n                     let place = Place::from(local_id);\n                 self.cfg.push(\n-                    block,\n+                    post_guard_block,\n                     Statement {\n                         source_info: guard_end,\n                         kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),\n@@ -1652,11 +1624,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // denotes *R.\n             let ref_for_guard =\n                 self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n-            // Question: Why schedule drops if bindings are all\n-            // shared-&'s?\n-            // Answer: Because schedule_drop_for_binding also emits\n-            // StorageDead's for those locals.\n-            self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, binding.source.clone());\n@@ -1670,11 +1637,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         binding.span,\n                         OutsideGuard,\n                     );\n-                    self.schedule_drop_for_binding(\n-                        binding.var_id,\n-                        binding.span,\n-                        OutsideGuard,\n-                    );\n \n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source.clone());\n                     self.cfg"}, {"sha": "ad970de466cfdf16baba62ffdbe2645ec9d9ad91", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -251,7 +251,7 @@ struct Builder<'a, 'tcx> {\n \n     /// The current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details.\n-    scopes: Vec<scope::Scope<'tcx>>,\n+    scopes: scope::Scopes<'tcx>,\n \n     /// The block-context: each time we build the code within an hair::Block,\n     /// we push a frame here tracking whether we are building a statement or\n@@ -274,10 +274,6 @@ struct Builder<'a, 'tcx> {\n     /// The number of `push_unsafe_block` levels in scope.\n     push_unsafe_count: usize,\n \n-    /// The current set of breakables; see the `scope` module for more\n-    /// details.\n-    breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n-\n     /// The vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later.\n     source_scopes: IndexVec<SourceScope, SourceScopeData>,\n@@ -714,15 +710,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             fn_span: span,\n             arg_count,\n             is_generator,\n-            scopes: vec![],\n+            scopes: Default::default(),\n             block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),\n             source_scope: OUTERMOST_SOURCE_SCOPE,\n             source_scope_local_data: IndexVec::new(),\n             guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n-            breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(\n                 LocalDecl::new_return_place(return_ty, return_span),\n                 1,\n@@ -814,7 +809,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n                 pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n-                argument_scope, &place, ty, DropKind::Value,\n+                argument_scope, local, ty, DropKind::Value,\n             );\n \n             if let Some(pattern) = pattern {\n@@ -865,7 +860,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::RETURN_PLACE, block, body)\n+        // `return_block` is called when we evaluate a `return` expression, so\n+        // we just use `START_BLOCK` here.\n+        self.in_breakable_scope(None, START_BLOCK, Place::RETURN_PLACE, |this| {\n+            this.into(&Place::RETURN_PLACE, block, body)\n+        })\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "1b5fa1c9770f168d37de3a4e2fb6885075b69e83", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 304, "deletions": 245, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -82,8 +82,8 @@ should go to.\n \n */\n \n-use crate::build::{BlockAnd, BlockAndExtension, Builder, CFG};\n-use crate::hair::LintLevel;\n+use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n+use crate::hair::{Expr, ExprRef, LintLevel};\n use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n@@ -94,7 +94,7 @@ use std::collections::hash_map::Entry;\n use std::mem;\n \n #[derive(Debug)]\n-pub struct Scope<'tcx> {\n+struct Scope {\n     /// The source scope this scope was created in.\n     source_scope: SourceScope,\n \n@@ -121,7 +121,7 @@ pub struct Scope<'tcx> {\n     /// out empty but grows as variables are declared during the\n     /// building process. This is a stack, so we always drop from the\n     /// end of the vector (top of the stack) first.\n-    drops: Vec<DropData<'tcx>>,\n+    drops: Vec<DropData>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, region::Scope), BasicBlock>,\n@@ -133,13 +133,20 @@ pub struct Scope<'tcx> {\n     cached_unwind: CachedBlock,\n }\n \n+#[derive(Debug, Default)]\n+pub struct Scopes<'tcx> {\n+    scopes: Vec<Scope>,\n+    /// The current set of breakable scopes. See module comment for more details.\n+    breakable_scopes: Vec<BreakableScope<'tcx>>,\n+}\n+\n #[derive(Debug)]\n-struct DropData<'tcx> {\n+struct DropData {\n     /// span where drop obligation was incurred (typically where place was declared)\n     span: Span,\n \n-    /// place to drop\n-    location: Place<'tcx>,\n+    /// local to drop\n+    local: Local,\n \n     /// Whether this is a value Drop or a StorageDead.\n     kind: DropKind,\n@@ -172,17 +179,25 @@ pub(crate) enum DropKind {\n }\n \n #[derive(Clone, Debug)]\n-pub struct BreakableScope<'tcx> {\n+struct BreakableScope<'tcx> {\n     /// Region scope of the loop\n-    pub region_scope: region::Scope,\n+    region_scope: region::Scope,\n     /// Where the body of the loop begins. `None` if block\n-    pub continue_block: Option<BasicBlock>,\n+    continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n     /// from, or by having its condition to become false)\n-    pub break_block: BasicBlock,\n+    break_block: BasicBlock,\n     /// The destination of the loop/block expression itself (i.e., where to put the result of a\n     /// `break` expression)\n-    pub break_destination: Place<'tcx>,\n+    break_destination: Place<'tcx>,\n+}\n+\n+/// The target of an expression that breaks out of a scope\n+#[derive(Clone, Copy, Debug)]\n+pub enum BreakableTarget {\n+    Continue(region::Scope),\n+    Break(region::Scope),\n+    Return,\n }\n \n impl CachedBlock {\n@@ -208,16 +223,7 @@ impl CachedBlock {\n     }\n }\n \n-impl DropKind {\n-    fn may_panic(&self) -> bool {\n-        match *self {\n-            DropKind::Value => true,\n-            DropKind::Storage => false\n-        }\n-    }\n-}\n-\n-impl<'tcx> Scope<'tcx> {\n+impl Scope {\n     /// Invalidates all the cached blocks in the scope.\n     ///\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n@@ -257,30 +263,128 @@ impl<'tcx> Scope<'tcx> {\n     }\n }\n \n+impl<'tcx> Scopes<'tcx> {\n+    fn len(&self) -> usize {\n+        self.scopes.len()\n+    }\n+\n+    fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo), vis_scope: SourceScope) {\n+        debug!(\"push_scope({:?})\", region_scope);\n+        self.scopes.push(Scope {\n+            source_scope: vis_scope,\n+            region_scope: region_scope.0,\n+            region_scope_span: region_scope.1.span,\n+            needs_cleanup: false,\n+            drops: vec![],\n+            cached_generator_drop: None,\n+            cached_exits: Default::default(),\n+            cached_unwind: CachedBlock::default(),\n+        });\n+    }\n+\n+    fn pop_scope(\n+        &mut self,\n+        region_scope: (region::Scope, SourceInfo),\n+    ) -> (Scope, Option<BasicBlock>) {\n+        let scope = self.scopes.pop().unwrap();\n+        assert_eq!(scope.region_scope, region_scope.0);\n+        let unwind_to = self.scopes.last()\n+            .and_then(|next_scope| next_scope.cached_unwind.get(false));\n+        (scope, unwind_to)\n+    }\n+\n+    fn may_panic(&self, scope_count: usize) -> bool {\n+        let len = self.len();\n+        self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup)\n+    }\n+\n+    /// Finds the breakable scope for a given label. This is used for\n+    /// resolving `return`, `break` and `continue`.\n+    fn find_breakable_scope(\n+        &self,\n+        span: Span,\n+        target: BreakableTarget,\n+    ) -> (BasicBlock, region::Scope, Option<Place<'tcx>>) {\n+        let get_scope = |scope: region::Scope| {\n+            // find the loop-scope by its `region::Scope`.\n+            self.breakable_scopes.iter()\n+                .rfind(|breakable_scope| breakable_scope.region_scope == scope)\n+                .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n+        };\n+        match target {\n+            BreakableTarget::Return => {\n+                let scope = &self.breakable_scopes[0];\n+                if scope.break_destination != Place::RETURN_PLACE {\n+                    span_bug!(span, \"`return` in item with no return scope\");\n+                }\n+                (scope.break_block, scope.region_scope, Some(scope.break_destination.clone()))\n+            }\n+            BreakableTarget::Break(scope) => {\n+                let scope = get_scope(scope);\n+                (scope.break_block, scope.region_scope, Some(scope.break_destination.clone()))\n+            }\n+            BreakableTarget::Continue(scope) => {\n+                let scope = get_scope(scope);\n+                let continue_block = scope.continue_block\n+                    .unwrap_or_else(|| span_bug!(span, \"missing `continue` block\"));\n+                (continue_block, scope.region_scope, None)\n+            }\n+        }\n+    }\n+\n+    fn num_scopes_to(&self, region_scope: (region::Scope, SourceInfo), span: Span) -> usize {\n+        let scope_count = 1 + self.scopes.iter().rev()\n+            .position(|scope| scope.region_scope == region_scope.0)\n+            .unwrap_or_else(|| {\n+                span_bug!(span, \"region_scope {:?} does not enclose\", region_scope)\n+            });\n+        let len = self.len();\n+        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n+        scope_count\n+    }\n+\n+    fn iter_mut(&mut self) -> impl DoubleEndedIterator<Item=&mut Scope> + '_ {\n+        self.scopes.iter_mut().rev()\n+    }\n+\n+    fn top_scopes(&mut self, count: usize) -> impl DoubleEndedIterator<Item=&mut Scope> + '_ {\n+        let len = self.len();\n+        self.scopes[len - count..].iter_mut()\n+    }\n+\n+    /// Returns the topmost active scope, which is known to be alive until\n+    /// the next scope expression.\n+    fn topmost(&self) -> region::Scope {\n+        self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n+    }\n+\n+    fn source_info(&self, index: usize, span: Span) -> SourceInfo {\n+        self.scopes[self.len() - index].source_info(span)\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n-    /// Start a breakable scope, which tracks where `continue` and `break`\n-    /// should branch to. See module comment for more details.\n-    ///\n-    /// Returns the might_break attribute of the BreakableScope used.\n+    //  Start a breakable scope, which tracks where `continue`, `break` and\n+    //  `return` should branch to.\n     pub fn in_breakable_scope<F, R>(&mut self,\n                                     loop_block: Option<BasicBlock>,\n                                     break_block: BasicBlock,\n                                     break_destination: Place<'tcx>,\n                                     f: F) -> R\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> R\n     {\n-        let region_scope = self.topmost_scope();\n+        let region_scope = self.scopes.topmost();\n         let scope = BreakableScope {\n             region_scope,\n             continue_block: loop_block,\n             break_block,\n             break_destination,\n         };\n-        self.breakable_scopes.push(scope);\n+        self.scopes.breakable_scopes.push(scope);\n         let res = f(self);\n-        let breakable_scope = self.breakable_scopes.pop().unwrap();\n+        let breakable_scope = self.scopes.breakable_scopes.pop().unwrap();\n         assert!(breakable_scope.region_scope == region_scope);\n         res\n     }\n@@ -350,18 +454,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n     pub fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n-        debug!(\"push_scope({:?})\", region_scope);\n-        let vis_scope = self.source_scope;\n-        self.scopes.push(Scope {\n-            source_scope: vis_scope,\n-            region_scope: region_scope.0,\n-            region_scope_span: region_scope.1.span,\n-            needs_cleanup: false,\n-            drops: vec![],\n-            cached_generator_drop: None,\n-            cached_exits: Default::default(),\n-            cached_unwind: CachedBlock::default(),\n-        });\n+        self.scopes.push_scope(region_scope, self.source_scope);\n     }\n \n     /// Pops a scope, which should have region scope `region_scope`,\n@@ -374,17 +467,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"pop_scope({:?}, {:?})\", region_scope, block);\n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic =\n-            self.scopes.last().unwrap().drops.iter().any(|s| s.kind.may_panic());\n-        if may_panic {\n+        if self.scopes.may_panic(1) {\n             self.diverge_cleanup();\n         }\n-        let scope = self.scopes.pop().unwrap();\n-        assert_eq!(scope.region_scope, region_scope.0);\n-\n-        let unwind_to = self.scopes.last().and_then(|next_scope| {\n-            next_scope.cached_unwind.get(false)\n-        }).unwrap_or_else(|| self.resume_block());\n+        let (scope, unwind_to) = self.scopes.pop_scope(region_scope);\n+        let unwind_to = unwind_to.unwrap_or_else(|| self.resume_block());\n \n         unpack!(block = build_scope_drops(\n             &mut self.cfg,\n@@ -399,6 +486,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block.unit()\n     }\n \n+    pub fn break_scope(\n+        &mut self,\n+        mut block: BasicBlock,\n+        value: Option<ExprRef<'tcx>>,\n+        scope: BreakableTarget,\n+        source_info: SourceInfo,\n+    ) -> BlockAnd<()> {\n+        let (mut target_block, region_scope, destination)\n+            = self.scopes.find_breakable_scope(source_info.span, scope);\n+        if let BreakableTarget::Return = scope {\n+            // We call this now, rather than when we start lowering the\n+            // function so that the return block doesn't precede the entire\n+            // rest of the CFG. Some passes and LLVM prefer blocks to be in\n+            // approximately CFG order.\n+            target_block = self.return_block();\n+        }\n+        if let Some(destination) = destination {\n+            if let Some(value) = value {\n+                debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n+                self.block_context.push(BlockFrame::SubExpr);\n+                unpack!(block = self.into(&destination, block, value));\n+                self.block_context.pop();\n+            } else {\n+                self.cfg.push_assign_unit(block, source_info, &destination)\n+            }\n+        } else {\n+            assert!(value.is_none(), \"`return` and `break` should have a destination\");\n+        }\n+        self.exit_scope(source_info.span, (region_scope, source_info), block, target_block);\n+        self.cfg.start_new_block().unit()\n+    }\n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n     /// and including `region_scope`. This will insert whatever drops are\n@@ -410,22 +528,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                       target: BasicBlock) {\n         debug!(\"exit_scope(region_scope={:?}, block={:?}, target={:?})\",\n                region_scope, block, target);\n-        let scope_count = 1 + self.scopes.iter().rev()\n-            .position(|scope| scope.region_scope == region_scope.0)\n-            .unwrap_or_else(|| {\n-                span_bug!(span, \"region_scope {:?} does not enclose\", region_scope)\n-            });\n-        let len = self.scopes.len();\n-        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n+        let scope_count = self.scopes.num_scopes_to(region_scope, span);\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic = self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup);\n+        let may_panic = self.scopes.may_panic(scope_count);\n         if may_panic {\n             self.diverge_cleanup();\n         }\n \n-        let mut scopes = self.scopes[(len - scope_count - 1)..].iter_mut().rev();\n+        let mut scopes = self.scopes.top_scopes(scope_count + 1).rev();\n         let mut scope = scopes.next().unwrap();\n         for next_scope in scopes {\n             if scope.drops.is_empty() {\n@@ -466,9 +578,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             scope = next_scope;\n         }\n \n-        let scope = &self.scopes[len - scope_count];\n-        self.cfg.terminate(block, scope.source_info(span),\n-                           TerminatorKind::Goto { target });\n+        let source_info = self.scopes.source_info(scope_count, span);\n+        self.cfg.terminate(block, source_info, TerminatorKind::Goto { target });\n     }\n \n     /// Creates a path that performs all required cleanup for dropping a generator.\n@@ -479,9 +590,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Fill in the cache for unwinds\n         self.diverge_cleanup_gen(true);\n \n-        let src_info = self.scopes[0].source_info(self.fn_span);\n+        let src_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n         let resume_block = self.resume_block();\n-        let mut scopes = self.scopes.iter_mut().rev().peekable();\n+        let mut scopes = self.scopes.iter_mut().peekable();\n         let mut block = self.cfg.start_new_block();\n         let result = block;\n \n@@ -547,22 +658,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scope\n     }\n \n-    // Finding scopes\n-    // ==============\n-    /// Finds the breakable scope for a given label. This is used for\n-    /// resolving `break` and `continue`.\n-    pub fn find_breakable_scope(&self,\n-                                span: Span,\n-                                label: region::Scope)\n-                                -> &BreakableScope<'tcx> {\n-        // find the loop-scope with the correct id\n-        self.breakable_scopes.iter()\n-            .rev()\n-            .filter(|breakable_scope| breakable_scope.region_scope == label)\n-            .next()\n-            .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n-    }\n-\n     /// Given a span and the current source scope, make a SourceInfo.\n     pub fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo {\n@@ -571,25 +666,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns the `region::Scope` of the scope which should be exited by a\n-    /// return.\n-    pub fn region_scope_of_return_scope(&self) -> region::Scope {\n-        // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n-        // We want `scopes[1]`, which is the `ParameterScope`.\n-        assert!(self.scopes.len() >= 2);\n-        assert!(match self.scopes[1].region_scope.data {\n-            region::ScopeData::Arguments => true,\n-            _ => false,\n-        });\n-        self.scopes[1].region_scope\n-    }\n-\n-    /// Returns the topmost active scope, which is known to be alive until\n-    /// the next scope expression.\n-    pub fn topmost_scope(&self) -> region::Scope {\n-        self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n-    }\n-\n+    // Finding scopes\n+    // ==============\n     /// Returns the scope that we should use as the lifetime of an\n     /// operand. Basically, an operand must live until it is consumed.\n     /// This is similar to, but not quite the same as, the temporary\n@@ -620,33 +698,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 None,\n             hir::BodyOwnerKind::Closure |\n             hir::BodyOwnerKind::Fn =>\n-                Some(self.topmost_scope()),\n+                Some(self.scopes.topmost()),\n         }\n     }\n \n     // Schedule an abort block - this is used for some ABIs that cannot unwind\n     pub fn schedule_abort(&mut self) -> BasicBlock {\n-        self.scopes[0].needs_cleanup = true;\n+        let source_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n         let abortblk = self.cfg.start_new_cleanup_block();\n-        let source_info = self.scopes[0].source_info(self.fn_span);\n         self.cfg.terminate(abortblk, source_info, TerminatorKind::Abort);\n         self.cached_resume_block = Some(abortblk);\n         abortblk\n     }\n \n+    // Scheduling drops\n+    // ================\n     pub fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n-        place: &Place<'tcx>,\n+        local: Local,\n         place_ty: Ty<'tcx>,\n     ) {\n-        self.schedule_drop(span, region_scope, place, place_ty, DropKind::Storage);\n-        self.schedule_drop(span, region_scope, place, place_ty, DropKind::Value);\n+        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Value);\n     }\n \n-    // Scheduling drops\n-    // ================\n     /// Indicates that `place` should be dropped on exit from\n     /// `region_scope`.\n     ///\n@@ -656,30 +733,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n-        place: &Place<'tcx>,\n+        local: Local,\n         place_ty: Ty<'tcx>,\n         drop_kind: DropKind,\n     ) {\n         let needs_drop = self.hir.needs_drop(place_ty);\n         match drop_kind {\n             DropKind::Value => if !needs_drop { return },\n             DropKind::Storage => {\n-                match *place {\n-                    Place::Base(PlaceBase::Local(index)) => if index.index() <= self.arg_count {\n-                        span_bug!(\n-                            span, \"`schedule_drop` called with index {} and arg_count {}\",\n-                            index.index(),\n-                            self.arg_count,\n-                        )\n-                    },\n-                    _ => span_bug!(\n-                        span, \"`schedule_drop` called with non-`Local` place {:?}\", place\n-                    ),\n+                if local.index() <= self.arg_count {\n+                    span_bug!(\n+                        span, \"`schedule_drop` called with local {:?} and arg_count {}\",\n+                        local,\n+                        self.arg_count,\n+                    )\n                 }\n             }\n         }\n \n-        for scope in self.scopes.iter_mut().rev() {\n+        for scope in self.scopes.iter_mut() {\n             let this_scope = scope.region_scope == region_scope;\n             // When building drops, we try to cache chains of drops in such a way so these drops\n             // could be reused by the drops which would branch into the cached (already built)\n@@ -740,18 +812,84 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 scope.drops.push(DropData {\n                     span: scope_end,\n-                    location: place.clone(),\n+                    local,\n                     kind: drop_kind,\n                     cached_block: CachedBlock::default(),\n                 });\n                 return;\n             }\n         }\n-        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, place);\n+        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n     // Other\n     // =====\n+    /// Branch based on a boolean condition.\n+    ///\n+    /// This is a special case because the temporary for the condition needs to\n+    /// be dropped on both the true and the false arm.\n+    pub fn test_bool(\n+        &mut self,\n+        mut block: BasicBlock,\n+        condition: Expr<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> (BasicBlock, BasicBlock) {\n+        let cond = unpack!(block = self.as_local_operand(block, condition));\n+        let true_block = self.cfg.start_new_block();\n+        let false_block = self.cfg.start_new_block();\n+        let term = TerminatorKind::if_(\n+            self.hir.tcx(),\n+            cond.clone(),\n+            true_block,\n+            false_block,\n+        );\n+        self.cfg.terminate(block, source_info, term);\n+\n+        match cond {\n+            // Don't try to drop a constant\n+            Operand::Constant(_) => (),\n+            // If constants and statics, we don't generate StorageLive for this\n+            // temporary, so don't try to generate StorageDead for it either.\n+            _ if self.local_scope().is_none() => (),\n+            Operand::Copy(Place::Base(PlaceBase::Local(cond_temp)))\n+            | Operand::Move(Place::Base(PlaceBase::Local(cond_temp))) => {\n+                // Manually drop the condition on both branches.\n+                let top_scope = self.scopes.scopes.last_mut().unwrap();\n+                let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+                match top_drop_data.kind {\n+                    DropKind::Value { .. } => {\n+                        bug!(\"Drop scheduled on top of condition variable\")\n+                    }\n+                    DropKind::Storage => {\n+                        let source_info = top_scope.source_info(top_drop_data.span);\n+                        let local = top_drop_data.local;\n+                        assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n+                        self.cfg.push(\n+                            true_block,\n+                            Statement {\n+                                source_info,\n+                                kind: StatementKind::StorageDead(local)\n+                            },\n+                        );\n+                        self.cfg.push(\n+                            false_block,\n+                            Statement {\n+                                source_info,\n+                                kind: StatementKind::StorageDead(local)\n+                            },\n+                        );\n+                    }\n+                }\n+\n+                top_scope.invalidate_cache(true, self.is_generator, true);\n+            }\n+            _ => bug!(\"Expected as_local_operand to produce a temporary\"),\n+        }\n+\n+        (true_block, false_block)\n+    }\n+\n     /// Creates a path that performs all required cleanup for unwinding.\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n@@ -790,42 +928,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Find the last cached block\n         debug!(\"diverge_cleanup_gen(self.scopes = {:?})\", self.scopes);\n-        let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n-            .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n-            (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n-        } else {\n-            (self.resume_block(), 0)\n-        };\n+        let cached_cleanup = self.scopes.iter_mut().enumerate()\n+            .find_map(|(idx, ref scope)| {\n+                let cached_block = scope.cached_unwind.get(generator_drop)?;\n+                Some((cached_block, idx))\n+            });\n+        let (mut target, first_uncached) = cached_cleanup\n+            .unwrap_or_else(|| (self.resume_block(), self.scopes.len()));\n \n-        for scope in self.scopes[first_uncached..].iter_mut() {\n+        for scope in self.scopes.top_scopes(first_uncached) {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n                                          scope, target, generator_drop, self.is_generator);\n         }\n \n         target\n     }\n \n-    /// Utility function for *non*-scope code to build their own drops\n-    pub fn build_drop(&mut self,\n-                      block: BasicBlock,\n-                      span: Span,\n-                      location: Place<'tcx>,\n-                      ty: Ty<'tcx>) -> BlockAnd<()> {\n-        if !self.hir.needs_drop(ty) {\n-            return block.unit();\n-        }\n-        let source_info = self.source_info(span);\n-        let next_target = self.cfg.start_new_block();\n-        let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block, source_info,\n-                           TerminatorKind::Drop {\n-                               location,\n-                               target: next_target,\n-                               unwind: Some(diverge_target),\n-                           });\n-        next_target.unit()\n-    }\n-\n     /// Utility function for *non*-scope code to build their own drops\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n@@ -877,73 +995,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    pub fn clear_top_scope(&mut self, region_scope: region::Scope) {\n-        let top_scope = self.scopes.last_mut().unwrap();\n+    pub(crate) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+        let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n         top_scope.invalidate_cache(false, self.is_generator, true);\n     }\n-\n-    /// Drops the single variable provided\n-    ///\n-    /// * The scope must be the top scope.\n-    /// * The variable must be in that scope.\n-    /// * The variable must be at the top of that scope: it's the next thing\n-    ///   scheduled to drop.\n-    /// * The drop must be of `DropKind::Storage`.\n-    ///\n-    /// This is used for the boolean holding the result of the match guard. We\n-    /// do this because:\n-    ///\n-    /// * The boolean is different for each pattern\n-    /// * There is only one exit for the arm scope\n-    /// * The guard expression scope is too short, it ends just before the\n-    ///   boolean is tested.\n-    pub fn pop_variable(\n-        &mut self,\n-        block: BasicBlock,\n-        region_scope: region::Scope,\n-        variable: Local,\n-    ) {\n-        let top_scope = self.scopes.last_mut().unwrap();\n-\n-        assert_eq!(top_scope.region_scope, region_scope);\n-\n-        let top_drop_data = top_scope.drops.pop().unwrap();\n-\n-        match top_drop_data.kind {\n-            DropKind::Value { .. } => {\n-                bug!(\"Should not be calling pop_top_variable on non-copy type!\")\n-            }\n-            DropKind::Storage => {\n-                // Drop the storage for both value and storage drops.\n-                // Only temps and vars need their storage dead.\n-                match top_drop_data.location {\n-                    Place::Base(PlaceBase::Local(index)) => {\n-                        let source_info = top_scope.source_info(top_drop_data.span);\n-                        assert_eq!(index, variable);\n-                        self.cfg.push(block, Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(index)\n-                        });\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-        }\n-\n-        top_scope.invalidate_cache(true, self.is_generator, true);\n-    }\n-\n }\n \n /// Builds drops for pop_scope and exit_scope.\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n     is_generator: bool,\n-    scope: &Scope<'tcx>,\n+    scope: &Scope,\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n@@ -973,39 +1039,35 @@ fn build_scope_drops<'tcx>(\n     for drop_idx in (0..scope.drops.len()).rev() {\n         let drop_data = &scope.drops[drop_idx];\n         let source_info = scope.source_info(drop_data.span);\n+        let local = drop_data.local;\n         match drop_data.kind {\n             DropKind::Value => {\n                 let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n                     .unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n-                    location: drop_data.location.clone(),\n+                    location: local.into(),\n                     target: next,\n                     unwind: Some(unwind_to)\n                 });\n                 block = next;\n             }\n             DropKind::Storage => {\n-                // Drop the storage for both value and storage drops.\n                 // Only temps and vars need their storage dead.\n-                match drop_data.location {\n-                    Place::Base(PlaceBase::Local(index)) if index.index() > arg_count => {\n-                        cfg.push(block, Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(index)\n-                        });\n-                    }\n-                    _ => unreachable!(),\n-                }\n+                assert!(local.index() > arg_count);\n+                cfg.push(block, Statement {\n+                    source_info,\n+                    kind: StatementKind::StorageDead(local)\n+                });\n             }\n         }\n     }\n     block.unit()\n }\n \n-fn get_unwind_to<'tcx>(\n-    scope: &Scope<'tcx>,\n+fn get_unwind_to(\n+    scope: &Scope,\n     is_generator: bool,\n     unwind_from: usize,\n     generator_drop: bool,\n@@ -1031,7 +1093,7 @@ fn get_unwind_to<'tcx>(\n \n fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              span: Span,\n-                             scope: &mut Scope<'tcx>,\n+                             scope: &mut Scope,\n                              mut target: BasicBlock,\n                              generator_drop: bool,\n                              is_generator: bool)\n@@ -1075,26 +1137,20 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         // this is not what clang does.\n         match drop_data.kind {\n             DropKind::Storage if is_generator => {\n-                // Only temps and vars need their storage dead.\n-                match drop_data.location {\n-                    Place::Base(PlaceBase::Local(index)) => {\n-                        storage_deads.push(Statement {\n-                            source_info: source_info(drop_data.span),\n-                            kind: StatementKind::StorageDead(index)\n-                        });\n-                        if !target_built_by_us {\n-                            // We cannot add statements to an existing block, so we create a new\n-                            // block for our StorageDead statements.\n-                            let block = cfg.start_new_cleanup_block();\n-                            let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n-                            cfg.terminate(block, source_info,\n-                                          TerminatorKind::Goto { target: target });\n-                            target = block;\n-                            target_built_by_us = true;\n-                        }\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                storage_deads.push(Statement {\n+                    source_info: source_info(drop_data.span),\n+                    kind: StatementKind::StorageDead(drop_data.local)\n+                });\n+                if !target_built_by_us {\n+                    // We cannot add statements to an existing block, so we create a new\n+                    // block for our StorageDead statements.\n+                    let block = cfg.start_new_cleanup_block();\n+                    let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n+                    cfg.terminate(block, source_info,\n+                                    TerminatorKind::Goto { target: target });\n+                    target = block;\n+                    target_built_by_us = true;\n+                }\n                 *drop_data.cached_block.ref_mut(generator_drop) = Some(target);\n             }\n             DropKind::Storage => {}\n@@ -1107,12 +1163,15 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                 } else {\n                     push_storage_deads(cfg, target, &mut storage_deads);\n                     let block = cfg.start_new_cleanup_block();\n-                    cfg.terminate(block, source_info(drop_data.span),\n-                                  TerminatorKind::Drop {\n-                                      location: drop_data.location.clone(),\n-                                      target,\n-                                      unwind: None\n-                                  });\n+                    cfg.terminate(\n+                        block,\n+                        source_info(drop_data.span),\n+                        TerminatorKind::Drop {\n+                            location: drop_data.local.into(),\n+                            target,\n+                            unwind: None\n+                        },\n+                    );\n                     *cached_block = Some(block);\n                     target_built_by_us = true;\n                     block"}, {"sha": "9a73842d2f02ad66a994448c4085732a6158b4b5", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -49,7 +49,6 @@ fn mirror_stmts<'a, 'tcx>(\n     for (index, stmt) in stmts.iter().enumerate() {\n         let hir_id = stmt.hir_id;\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        let stmt_span = StatementSpan(cx.tcx.hir().span(hir_id));\n         match stmt.node {\n             hir::StmtKind::Expr(ref expr) |\n             hir::StmtKind::Semi(ref expr) => {\n@@ -62,7 +61,6 @@ fn mirror_stmts<'a, 'tcx>(\n                         expr: expr.to_ref(),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n-                    span: stmt_span,\n                 })))\n             }\n             hir::StmtKind::Item(..) => {\n@@ -107,7 +105,6 @@ fn mirror_stmts<'a, 'tcx>(\n                         lint_level: LintLevel::Explicit(local.hir_id),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n-                    span: stmt_span,\n                 })));\n             }\n         }"}, {"sha": "5431a31c4bb2a95968baf59f13732ae782aa6293", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -55,14 +55,10 @@ pub enum StmtRef<'tcx> {\n     Mirror(Box<Stmt<'tcx>>),\n }\n \n-#[derive(Clone, Debug)]\n-pub struct StatementSpan(pub Span);\n-\n #[derive(Clone, Debug)]\n pub struct Stmt<'tcx> {\n     pub kind: StmtKind<'tcx>,\n     pub opt_destruction_scope: Option<region::Scope>,\n-    pub span: StatementSpan,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "d9fa3d3d4736d3d2702ef0ee2c956df4a7836e1b", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -24,7 +24,7 @@ impl Drop for S {\n //     let mut _0: ();\n //     let _1: std::boxed::Box<S>;\n //     let mut _2: std::boxed::Box<S>;\n-//     let mut _3: ();\n+//     let _3: ();\n //     let mut _4: std::boxed::Box<S>;\n //     scope 1 {\n //     }\n@@ -50,6 +50,7 @@ impl Drop for S {\n //\n //     bb4: {\n //         StorageDead(_2);\n+//         StorageLive(_3);\n //         StorageLive(_4);\n //         _4 = move _1;\n //         _3 = const std::mem::drop::<std::boxed::Box<S>>(move _4) -> [return: bb5, unwind: bb7];\n@@ -69,6 +70,7 @@ impl Drop for S {\n //\n //     bb8: {\n //         StorageDead(_4);\n+//         StorageDead(_3);\n //         _0 = ();\n //         drop(_1) -> bb9;\n //     }"}, {"sha": "5e5fed12fb5f3d67e8b778378f64b81b133e3ad7", "filename": "src/test/mir-opt/copy_propagation_arg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -61,12 +61,14 @@ fn main() {\n // END rustc.foo.CopyPropagation.after.mir\n // START rustc.bar.CopyPropagation.before.mir\n // bb0: {\n+//     StorageLive(_2);\n //     StorageLive(_3);\n //     _3 = _1;\n //     _2 = const dummy(move _3) -> bb1;\n // }\n // bb1: {\n //     StorageDead(_3);\n+//     StorageDead(_2);\n //     _1 = const 5u8;\n //     ...\n //     return;"}, {"sha": "f97e1ba6c89d4ab029998d122113747ebfde3204", "filename": "src/test/mir-opt/generator-drop-cleanup.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -18,6 +18,7 @@ fn main() {\n // }\n // bb1: {\n //     StorageDead(_3);\n+//     StorageDead(_2);\n //     goto -> bb5;\n // }\n // bb2: {\n@@ -36,6 +37,7 @@ fn main() {\n //     goto -> bb3;\n // }\n // bb7: {\n+//     StorageLive(_2);\n //     StorageLive(_3);\n //     goto -> bb1;\n // }"}, {"sha": "bcdb93754271681ee504804e9de1fe66c55402ef", "filename": "src/test/mir-opt/generator-storage-dead-unwind.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -54,6 +54,7 @@ fn main() {\n // }\n // bb2: {\n //     ...\n+//     StorageLive(_6);\n //     StorageLive(_7);\n //     _7 = move _2;\n //     _6 = const take::<Foo>(move _7) -> [return: bb9, unwind: bb8];\n@@ -81,23 +82,28 @@ fn main() {\n // }\n // bb8 (cleanup): {\n //     StorageDead(_7);\n+//     StorageDead(_6);\n //     goto -> bb7;\n // }\n // bb9: {\n //     StorageDead(_7);\n+//     StorageDead(_6);\n+//     StorageLive(_8);\n //     StorageLive(_9);\n //     _9 = move _3;\n //     _8 = const take::<Bar>(move _9) -> [return: bb10, unwind: bb11];\n // }\n // bb10: {\n //     StorageDead(_9);\n+//     StorageDead(_8);\n //     ...\n //     StorageDead(_3);\n //     StorageDead(_2);\n //     drop(_1) -> [return: bb12, unwind: bb1];\n // }\n // bb11 (cleanup): {\n //     StorageDead(_9);\n+//     StorageDead(_8);\n //     goto -> bb7;\n // }\n // bb12: {"}, {"sha": "d980cc891dc40c740d9aa1e6b241aa9183767194", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -25,6 +25,7 @@ fn main() {\n //         falseUnwind -> [real: bb3, cleanup: bb1];\n //     }\n //     bb3: {\n+//         StorageLive(_3);\n //         StorageLive(_4);\n //         _4 = _1;\n //         FakeRead(ForMatchedPlace, _4);\n@@ -34,13 +35,15 @@ fn main() {\n //     bb5: {\n //         _3 = ();\n //         StorageDead(_4);\n+//         StorageDead(_3);\n //         _1 = const true;\n //         _2 = ();\n //         goto -> bb2;\n //     }\n //     bb6: {\n //         _0 = ();\n //         StorageDead(_4);\n+//         StorageDead(_3);\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "e73390f52b5d552fc3287e923a0f52ac9a117c52", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -42,7 +42,7 @@ impl S {\n // START rustc.test.ElaborateDrops.after.mir\n //    let mut _0: ();\n //    let _1: S;\n-//    let mut _3: ();\n+//    let _3: ();\n //    let mut _4: S;\n //    let mut _5: S;\n //    let mut _6: bool;"}, {"sha": "d0dbcbd7515f838974806fde144eea1df778db63", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -21,7 +21,7 @@ fn main() {\n //     let _2: i32;\n //     let mut _3: bool;\n //     let mut _4: !;\n-//     let mut _5: ();\n+//     let _5: ();\n //     let mut _6: &i32;\n //     scope 1 {\n //     }\n@@ -73,12 +73,14 @@ fn main() {\n //     bb12: {\n //         FakeRead(ForLet, _2);\n //         StorageDead(_3);\n+//         StorageLive(_5);\n //         StorageLive(_6);\n //         _6 = &_2;\n //         _5 = const std::mem::drop::<&i32>(move _6) -> [return: bb13, unwind: bb4];\n //     }\n //     bb13: {\n //         StorageDead(_6);\n+//         StorageDead(_5);\n //         _1 = ();\n //         StorageDead(_2);\n //         goto -> bb1;"}, {"sha": "177080c04f9722e89bed7364c5435d9c25f0878d", "filename": "src/test/mir-opt/loop_test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Floop_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Floop_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -25,6 +25,7 @@ fn main() {\n //    bb3: { // Entry into the loop\n //        _1 = ();\n //        StorageDead(_2);\n+//        StorageDead(_1);\n //        goto -> bb5;\n //    }\n //    ..."}, {"sha": "18e0642eb34274fff3b22a1b59207119060dfbf5", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -103,10 +103,6 @@ fn main() {\n // bb10: {                              // `else` block - first time\n //     _9 = (*_6);\n //     StorageDead(_10);\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForGuardBinding, _6);\n-//     FakeRead(ForGuardBinding, _8);\n //     switchInt(move _9) -> [false: bb16, otherwise: bb15];\n // }\n // bb11: {                              // `return 3` - first time\n@@ -128,6 +124,10 @@ fn main() {\n // }\n // bb15: {\n //     StorageDead(_9);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n //     StorageLive(_5);\n //     _5 = (_2.1: bool);\n //     StorageLive(_7);\n@@ -159,10 +159,6 @@ fn main() {\n // bb19: {                              // `else` block - second time\n //     _12 = (*_6);\n //     StorageDead(_13);\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForGuardBinding, _6);\n-//     FakeRead(ForGuardBinding, _8);\n //     switchInt(move _12) -> [false: bb22, otherwise: bb21];\n // }\n // bb20: {\n@@ -175,6 +171,10 @@ fn main() {\n // }\n // bb21: {                              // bindings for arm 1\n //     StorageDead(_12);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n //     StorageLive(_5);\n //     _5 = (_2.0: bool);\n //     StorageLive(_7);"}, {"sha": "b275c06e05cd3d6f03699feb6c51363f433d9e32", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -71,12 +71,12 @@ fn main() {\n //      _7 = const guard() -> [return: bb7, unwind: bb1];\n //  }\n //  bb7: { // end of guard\n-//      FakeRead(ForMatchGuard, _4);\n-//      FakeRead(ForGuardBinding, _6);\n //      switchInt(move _7) -> [false: bb9, otherwise: bb8];\n //  }\n //  bb8: { // arm1\n //      StorageDead(_7);\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForGuardBinding, _6);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n@@ -138,12 +138,12 @@ fn main() {\n //      _7 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n //  bb6: { // end of guard\n-//      FakeRead(ForMatchGuard, _4);\n-//      FakeRead(ForGuardBinding, _6);\n //      switchInt(move _7) -> [false: bb8, otherwise: bb7];\n //  }\n //  bb7: {\n //      StorageDead(_7);\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForGuardBinding, _6);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n@@ -209,12 +209,12 @@ fn main() {\n //      _8 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n //  bb6: { //end of guard1\n-//      FakeRead(ForMatchGuard, _5);\n-//      FakeRead(ForGuardBinding, _7);\n //      switchInt(move _8) -> [false: bb8, otherwise: bb7];\n //  }\n //  bb7: {\n //      StorageDead(_8);\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForGuardBinding, _7);\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n@@ -245,12 +245,12 @@ fn main() {\n //  }\n //  bb11: { // end of guard2\n //      StorageDead(_13);\n-//      FakeRead(ForMatchGuard, _5);\n-//      FakeRead(ForGuardBinding, _11);\n //      switchInt(move _12) -> [false: bb13, otherwise: bb12];\n //  }\n //  bb12: { // binding4 & arm4\n //      StorageDead(_12);\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForGuardBinding, _11);\n //      StorageLive(_10);\n //      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;"}, {"sha": "1ca75b100410b51a05b1d0d6e28364bdf4e3dbd7", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -54,11 +54,11 @@ fn main() {\n //        _8 = &shallow _1;\n //        StorageLive(_9);\n //        _9 = _2;\n-//        FakeRead(ForMatchGuard, _8);\n //        switchInt(move _9) -> [false: bb11, otherwise: bb10];\n //    }\n //    bb10: {\n //        StorageDead(_9);\n+//        FakeRead(ForMatchGuard, _8);\n //        _3 = const 0i32;\n //        goto -> bb14;\n //    }\n@@ -75,6 +75,7 @@ fn main() {\n //        goto -> bb14;\n //    }\n //    bb14: {\n+//        StorageDead(_3);\n //        _0 = ();\n //        StorageDead(_2);\n //        StorageDead(_1);"}, {"sha": "8228d9740f0d3f6901ea35e9472f24d3792d6ca9", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -22,9 +22,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=1]}\n-// | '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=1]}\n-// | '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=1]}\n+// | '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n+// | '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n+// | '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _2: &'_#3r usize;"}, {"sha": "3245d38b2580bd20a03a44463524eee16b645ca9", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -38,14 +38,14 @@ fn main() {\n //     _7 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n //     StorageLive(_8);\n //     _8 = _2;\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForMatchGuard, _5);\n-//     FakeRead(ForMatchGuard, _6);\n-//     FakeRead(ForMatchGuard, _7);\n //     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n // bb5: {\n //     StorageDead(_8);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForMatchGuard, _5);\n+//     FakeRead(ForMatchGuard, _6);\n+//     FakeRead(ForMatchGuard, _7);\n //     _0 = const 0i32;\n //     goto -> bb7;\n // }\n@@ -84,14 +84,14 @@ fn main() {\n //     nop;\n //     StorageLive(_8);\n //     _8 = _2;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n //     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n // bb5: {\n //     StorageDead(_8);\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n //     _0 = const 0i32;\n //     goto -> bb7;\n // }"}, {"sha": "95570ff76a6d0a9770ca5012b19405a492a525df", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -12,6 +12,7 @@ fn main() {\n //         StorageLive(_1);\n //         _1 = const 0i32;\n //         FakeRead(ForLet, _1);\n+//         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n@@ -23,6 +24,7 @@ fn main() {\n //         _2 = ();\n //         StorageDead(_4);\n //         StorageDead(_3);\n+//         StorageDead(_2);\n //         StorageLive(_6);\n //         _6 = const 1i32;\n //         FakeRead(ForLet, _6);"}, {"sha": "a486bd49a77d00401ac550f8e16409939aaefcfa", "filename": "src/test/mir-opt/while-storage.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -0,0 +1,59 @@\n+// Test that we correctly generate StorageDead statements for while loop\n+// conditions on all branches\n+\n+fn get_bool(c: bool) -> bool {\n+    c\n+}\n+\n+fn while_loop(c: bool) {\n+    while get_bool(c) {\n+        if get_bool(c) {\n+            break;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    while_loop(false);\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.while_loop.PreCodegen.after.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     StorageLive(_3);\n+//     _3 = _1;\n+//     _2 = const get_bool(move _3) -> bb2;\n+// }\n+// bb1: {\n+//     return;\n+// }\n+// bb2: {\n+//     StorageDead(_3);\n+//     switchInt(move _2) -> [false: bb4, otherwise: bb3];\n+// }\n+// bb3: {\n+//     StorageDead(_2);\n+//     StorageLive(_4);\n+//     StorageLive(_5);\n+//     _5 = _1;\n+//     _4 = const get_bool(move _5) -> bb5;\n+// }\n+// bb4: {\n+//     StorageDead(_2);\n+//     goto -> bb1;\n+// }\n+// bb5: {\n+//     StorageDead(_5);\n+//     switchInt(_4) -> [false: bb6, otherwise: bb7];\n+// }\n+// bb6: {\n+//     StorageDead(_4);\n+//     goto -> bb0;\n+// }\n+// bb7: {\n+//     StorageDead(_4);\n+//     goto -> bb1;\n+// }\n+// END rustc.while_loop.PreCodegen.after.mir"}, {"sha": "ce4642020f0f1067b71b56928d3dffd465f21e1f", "filename": "src/test/ui/generator/issue-61442-stmt-expr-with-drop.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -0,0 +1,32 @@\n+// Test that we don't consider temporaries for statement expressions as live\n+// across yields\n+\n+// check-pass\n+// edition:2018\n+\n+#![feature(async_await, generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+async fn drop_and_await() {\n+    async {};\n+    async {}.await;\n+}\n+\n+fn drop_and_yield() {\n+    let x = || {\n+        String::new();\n+        yield;\n+    };\n+    Box::pin(x).as_mut().resume();\n+    let y = static || {\n+        String::new();\n+        yield;\n+    };\n+    Box::pin(y).as_mut().resume();\n+}\n+\n+fn main() {\n+    drop_and_await();\n+    drop_and_yield();\n+}"}, {"sha": "c803321b5087a5b00b726f77c8429b46c5044536", "filename": "src/test/ui/nll/assign-while-to-immutable.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fui%2Fnll%2Fassign-while-to-immutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf/src%2Ftest%2Fui%2Fnll%2Fassign-while-to-immutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fassign-while-to-immutable.rs?ref=d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "patch": "@@ -0,0 +1,11 @@\n+// We used to incorrectly assign to `x` twice when generating MIR for this\n+// function, preventing this from compiling.\n+\n+// check-pass\n+\n+fn main() {\n+    let x = while false {\n+        break;\n+    };\n+    let y = 'l: while break 'l {};\n+}"}]}