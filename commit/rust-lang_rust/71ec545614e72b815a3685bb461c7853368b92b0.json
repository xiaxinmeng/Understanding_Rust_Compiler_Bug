{"sha": "71ec545614e72b815a3685bb461c7853368b92b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZWM1NDU2MTRlNzJiODE1YTM2ODViYjQ2MWM3ODUzMzY4YjkyYjA=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-21T01:47:16Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-21T02:00:27Z"}, "message": "Try to do some resolution of vtables earlier, in a fairly ad-hoc way. Closes #3156.", "tree": {"sha": "cdbb8c16c4ed677c8af4554b06a87f3a5d4d15a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdbb8c16c4ed677c8af4554b06a87f3a5d4d15a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71ec545614e72b815a3685bb461c7853368b92b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71ec545614e72b815a3685bb461c7853368b92b0", "html_url": "https://github.com/rust-lang/rust/commit/71ec545614e72b815a3685bb461c7853368b92b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71ec545614e72b815a3685bb461c7853368b92b0/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd736a0f9b8f8be46c256f1de04cd1e3798762c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd736a0f9b8f8be46c256f1de04cd1e3798762c9", "html_url": "https://github.com/rust-lang/rust/commit/bd736a0f9b8f8be46c256f1de04cd1e3798762c9"}], "stats": {"total": 143, "additions": 107, "deletions": 36}, "files": [{"sha": "7f1647d03de091425661040dac48fed8c42c8339", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71ec545614e72b815a3685bb461c7853368b92b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec545614e72b815a3685bb461c7853368b92b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=71ec545614e72b815a3685bb461c7853368b92b0", "patch": "@@ -820,6 +820,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // overloaded operations\n     fn check_call_inner(\n         fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, in_fty: ty::t,\n+        callee_expr: @ast::expr,\n         args: ~[@ast::expr]) -> {fty: ty::t, bot: bool} {\n \n         let mut bot = false;\n@@ -888,9 +889,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         for [false, true]/_.each |check_blocks| {\n+            // More awful hacks: before we check the blocks, try to do\n+            // an \"opportunistic\" vtable resolution of any trait\n+            // bounds on the call.\n+            if check_blocks {\n+                vtable::early_resolve_expr(callee_expr, fcx, true);\n+            }\n+\n             for args.eachi |i, a| {\n                 let is_block = match a.node {\n-                  ast::expr_fn_block(*) => true,\n+                  ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n+                  ast::expr_do_body(*) => true,\n                   _ => false\n                 };\n                 if is_block == check_blocks {\n@@ -933,7 +942,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Call the generic checker.\n         let fty = {\n             let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, args);\n+                                     fn_ty, f, args);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -998,7 +1007,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 method_ty, args)\n+                                 method_ty, op_ex, args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some((ty::ty_fn_ret(method_ty), bot))"}, {"sha": "5f75452fa11816ca7dc0e16487cc9e3eed98c66a", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/71ec545614e72b815a3685bb461c7853368b92b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec545614e72b815a3685bb461c7853368b92b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=71ec545614e72b815a3685bb461c7853368b92b0", "patch": "@@ -2,6 +2,22 @@ import check::{fn_ctxt, impl_self_ty};\n import infer::{resolve_type, resolve_all, force_all, fixup_err_to_str};\n import ast_util::new_def_hash;\n \n+// vtable resolution looks for places where trait bounds are\n+// subsituted in and figures out which vtable is used. There is some\n+// extra complication thrown in to support early \"opportunistic\"\n+// vtable resolution. This is a hacky mechanism that is invoked while\n+// typechecking function calls (after typechecking non-closure\n+// arguments and before typechecking closure arguments) in the hope of\n+// solving for the trait parameters from the impl. (For example,\n+// determining that if a parameter bounded by BaseIter<A> is\n+// instantiated with option<int>, that A = int.)\n+//\n+// In early resolution mode, no vtables are recorded, and a number of\n+// errors are ignored. Early resolution only works if a type is\n+// *fully* resolved. (We could be less restrictive than that, but it\n+// would require much more care, and this seems to work decently in\n+// practice.)\n+\n fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         vec::any(*bs, |b| {\n@@ -14,7 +30,8 @@ fn lookup_vtables(fcx: @fn_ctxt,\n                   sp: span,\n                   bounds: @~[ty::param_bounds],\n                   substs: &ty::substs,\n-                  allow_unsafe: bool) -> vtable_res {\n+                  allow_unsafe: bool,\n+                  is_early: bool) -> vtable_res {\n     let tcx = fcx.ccx.tcx;\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n@@ -23,7 +40,7 @@ fn lookup_vtables(fcx: @fn_ctxt,\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n                 vec::push(result, lookup_vtable(fcx, sp, ty, i_ty,\n-                                                allow_unsafe));\n+                                                allow_unsafe, is_early));\n               }\n               _ => ()\n             }\n@@ -34,13 +51,15 @@ fn lookup_vtables(fcx: @fn_ctxt,\n }\n \n fn fixup_substs(fcx: @fn_ctxt, sp: span,\n-                id: ast::def_id, substs: ty::substs) -> ty::substs {\n+                id: ast::def_id, substs: ty::substs,\n+                is_early: bool) -> option<ty::substs> {\n     let tcx = fcx.ccx.tcx;\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n-    let t_f = fixup_ty(fcx, sp, t);\n-    match check ty::get(t_f).struct {\n-      ty::ty_trait(_, substs_f, _) => substs_f,\n+    do fixup_ty(fcx, sp, t, is_early).map |t_f| {\n+        match check ty::get(t_f).struct {\n+          ty::ty_trait(_, substs_f, _) => substs_f,\n+        }\n     }\n }\n \n@@ -54,7 +73,7 @@ Look up the vtable to use when treating an item of type <t>\n as if it has type <trait_ty>\n */\n fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n-                 allow_unsafe: bool)\n+                 allow_unsafe: bool, is_early: bool)\n               -> vtable_origin {\n \n     debug!{\"lookup_vtable(ty=%s, trait_ty=%s)\",\n@@ -65,7 +84,18 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n     let (trait_id, trait_substs) = match check ty::get(trait_ty).struct {\n       ty::ty_trait(did, substs, _) => (did, substs)\n     };\n-    let ty = fixup_ty(fcx, sp, ty);\n+    let ty = match fixup_ty(fcx, sp, ty, is_early) {\n+      some(ty) => ty,\n+      none => {\n+        // fixup_ty can only fail if this is early resolution\n+        assert is_early;\n+        // The type has unconstrained type variables in it, so we can't\n+        // do early resolution on it. Return some completely bogus vtable\n+        // information: we aren't storing it anyways.\n+        return vtable_param(0, 0);\n+      }\n+    };\n+\n     match ty::get(ty).struct {\n       ty::ty_param({idx: n, def_id: did}) => {\n         let mut n_bound = 0u;\n@@ -97,7 +127,7 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                did};\n \n         relate_trait_tys(fcx, sp, trait_ty, ty);\n-        if !allow_unsafe {\n+        if !allow_unsafe && !is_early {\n             for vec::each(*ty::trait_methods(tcx, did)) |m| {\n                 if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n                     tcx.sess.span_err(\n@@ -154,21 +184,30 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                         }\n \n                         // check that desired trait type unifies\n-                        debug!{\"(checking vtable) @2 relating trait ty %s to \\\n+                        debug!(\"(checking vtable) @2 relating trait ty %s to \\\n                                 of_ty %s\",\n                                fcx.infcx.ty_to_str(trait_ty),\n-                               fcx.infcx.ty_to_str(of_ty)};\n+                               fcx.infcx.ty_to_str(of_ty));\n                         let of_ty = ty::subst(tcx, &substs, of_ty);\n                         relate_trait_tys(fcx, sp, trait_ty, of_ty);\n \n-                        // recursively process the bounds\n+                        // recursively process the bounds.\n                         let trait_tps = trait_substs.tps;\n-                        let substs_f = fixup_substs(fcx, sp, trait_id,\n-                                                    substs);\n+                        // see comments around the earlier call to fixup_ty\n+                        let substs_f = match fixup_substs(fcx, sp, trait_id,\n+                                                          substs, is_early) {\n+                            some(substs) => substs,\n+                            none => {\n+                                assert is_early;\n+                                // Bail out with a bogus answer\n+                                return vtable_param(0, 0);\n+                            }\n+                        };\n+\n                         connect_trait_tps(fcx, sp, substs_f.tps,\n                                           trait_tps, im.did);\n                         let subres = lookup_vtables(fcx, sp, im_bs, &substs_f,\n-                                                    false);\n+                                                    false, is_early);\n                         vec::push(found,\n                                   vtable_static(im.did, substs_f.tps,\n                                                 subres));\n@@ -181,8 +220,10 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n           0u => { /* fallthrough */ }\n           1u => { return found[0]; }\n           _ => {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp, ~\"multiple applicable methods in scope\");\n+            if !is_early {\n+                fcx.ccx.tcx.sess.span_err(\n+                    sp, ~\"multiple applicable methods in scope\");\n+            }\n             return found[0];\n           }\n         }\n@@ -195,17 +236,21 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n         ty_to_str(tcx, ty));\n }\n \n-fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n+fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t, is_early: bool)\n+                                -> option<ty::t> {\n     let tcx = fcx.ccx.tcx;\n     match resolve_type(fcx.infcx, ty, resolve_all | force_all) {\n-      result::ok(new_type) => new_type,\n-      result::err(e) => {\n+      result::ok(new_type) => some(new_type),\n+      result::err(e) if !is_early => {\n         tcx.sess.span_fatal(\n             sp,\n             fmt!{\"cannot determine a type \\\n                   for this bounded type parameter: %s\",\n                  fixup_err_to_str(e)})\n       }\n+      result::err(e) => {\n+        none\n+      }\n     }\n }\n \n@@ -226,7 +271,7 @@ fn connect_trait_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n     }\n }\n \n-fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n+fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::expr_path(*) => {\n@@ -236,11 +281,9 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             if has_trait_bounds(*item_ty.bounds) {\n-                cx.vtable_map.insert(ex.id, lookup_vtables(fcx,\n-                                                           ex.span,\n-                                                           item_ty.bounds,\n-                                                           substs,\n-                                                           false));\n+                let vtbls = lookup_vtables(fcx, ex.span, item_ty.bounds,\n+                                           substs, false, is_early);\n+                if !is_early { cx.vtable_map.insert(ex.id, vtbls); }\n             }\n           }\n           _ => ()\n@@ -260,11 +303,9 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n                   _ => ex.callee_id\n                 };\n                 let substs = fcx.node_ty_substs(callee_id);\n-                cx.vtable_map.insert(callee_id, lookup_vtables(fcx,\n-                                                               ex.span,\n-                                                               bounds,\n-                                                               &substs,\n-                                                               false));\n+                let vtbls = lookup_vtables(fcx, ex.span, bounds,\n+                                           &substs, false, is_early);\n+                if !is_early { cx.vtable_map.insert(callee_id, vtbls); }\n             }\n           }\n           _ => ()\n@@ -280,18 +321,22 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n             passing in the source and target type\n             */\n             let vtable = lookup_vtable(fcx, ex.span, fcx.expr_ty(src),\n-                                       target_ty, true);\n+                                       target_ty, true, is_early);\n             /*\n             Map this expression to that vtable (that is: \"ex has\n             vtable <vtable>\")\n             */\n-            cx.vtable_map.insert(ex.id, @~[vtable]);\n+            if !is_early { cx.vtable_map.insert(ex.id, @~[vtable]); }\n           }\n           _ => ()\n         }\n       }\n       _ => ()\n     }\n+}\n+\n+fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n+    early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);\n }\n "}, {"sha": "b4500cb1bf0fd1b7457fbeeb8a236dfc3530f6c4", "filename": "src/test/run-pass/early-vtbl-resolution.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/71ec545614e72b815a3685bb461c7853368b92b0/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec545614e72b815a3685bb461c7853368b92b0/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs?ref=71ec545614e72b815a3685bb461c7853368b92b0", "patch": "@@ -0,0 +1,17 @@\n+\n+trait thing<A> {\n+    fn foo() -> option<A>;\n+}\n+impl<A> int: thing<A> {\n+    fn foo() -> option<A> { none }\n+}\n+fn foo_func<A, B: thing<A>>(x: B) -> option<A> { x.foo() }\n+\n+fn main() {\n+\n+    for iter::eachi(some({a: 0})) |i, a| { \n+        #debug[\"%u %d\", i, a.a];\n+    }\n+\n+    let _x: option<float> = foo_func(0);\n+}"}]}