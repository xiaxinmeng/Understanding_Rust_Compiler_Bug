{"sha": "a9eb86823049c2eff98e74fcac8ae75cc8760f33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZWI4NjgyMzA0OWMyZWZmOThlNzRmY2FjOGFlNzVjYzg3NjBmMzM=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-13T08:24:36Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-13T08:24:36Z"}, "message": "Merge pull request #7735 from blake2-ppc/dlist\n\ndlist: Use DoubleEndedIterator", "tree": {"sha": "9978d1094e7fbe49f3d4a89f6172e676cb6ad207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9978d1094e7fbe49f3d4a89f6172e676cb6ad207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9eb86823049c2eff98e74fcac8ae75cc8760f33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb86823049c2eff98e74fcac8ae75cc8760f33", "html_url": "https://github.com/rust-lang/rust/commit/a9eb86823049c2eff98e74fcac8ae75cc8760f33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb86823049c2eff98e74fcac8ae75cc8760f33/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d582eeb1ec8e77234a26475bd70bf12a933b4efa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d582eeb1ec8e77234a26475bd70bf12a933b4efa", "html_url": "https://github.com/rust-lang/rust/commit/d582eeb1ec8e77234a26475bd70bf12a933b4efa"}, {"sha": "c095a5c6cb5f749613672ab26c492fd55459b125", "url": "https://api.github.com/repos/rust-lang/rust/commits/c095a5c6cb5f749613672ab26c492fd55459b125", "html_url": "https://github.com/rust-lang/rust/commit/c095a5c6cb5f749613672ab26c492fd55459b125"}], "stats": {"total": 279, "additions": 151, "deletions": 128}, "files": [{"sha": "283a726988ba228651cf5c24e29ef8568e8a373d", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 151, "deletions": 128, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb86823049c2eff98e74fcac8ae75cc8760f33/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb86823049c2eff98e74fcac8ae75cc8760f33/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=a9eb86823049c2eff98e74fcac8ae75cc8760f33", "patch": "@@ -26,7 +26,7 @@ use std::cast;\n use std::cmp;\n use std::ptr;\n use std::util;\n-use std::iterator::FromIterator;\n+use std::iterator::{FromIterator, InvertIterator};\n \n use container::Deque;\n \n@@ -46,31 +46,18 @@ struct Node<T> {\n     priv value: T,\n }\n \n-/// DList iterator\n-pub struct ForwardIterator<'self, T> {\n-    priv list: &'self DList<T>,\n-    priv next: &'self Link<T>,\n+/// Double-ended DList iterator\n+pub struct DListIterator<'self, T> {\n+    priv head: &'self Link<T>,\n+    priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n-/// DList reverse iterator\n-pub struct ReverseIterator<'self, T> {\n-    priv list: &'self DList<T>,\n-    priv next: Rawlink<Node<T>>,\n-    priv nelem: uint,\n-}\n-\n-/// DList mutable iterator\n-pub struct MutForwardIterator<'self, T> {\n+/// Double-ended mutable DList iterator\n+pub struct MutDListIterator<'self, T> {\n     priv list: &'self mut DList<T>,\n-    priv curs: Rawlink<Node<T>>,\n-    priv nelem: uint,\n-}\n-\n-/// DList mutable reverse iterator\n-pub struct MutReverseIterator<'self, T> {\n-    priv list: &'self mut DList<T>,\n-    priv next: Rawlink<Node<T>>,\n+    priv head: Rawlink<Node<T>>,\n+    priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n@@ -79,11 +66,6 @@ pub struct ConsumeIterator<T> {\n     priv list: DList<T>\n }\n \n-/// DList reverse consuming iterator\n-pub struct ConsumeRevIterator<T> {\n-    priv list: DList<T>\n-}\n-\n /// Rawlink is a type like Option<T> but for holding a raw pointer\n impl<T> Rawlink<T> {\n     /// Like Option::None for Rawlink\n@@ -291,52 +273,68 @@ impl<T> DList<T> {\n         {\n             let mut it = self.mut_iter();\n             loop {\n-                match it.next() {\n+                match it.peek_next() {\n                     None => break,\n-                    Some(x) => if f(x, &elt) { it.insert_before(elt); return }\n+                    Some(x) => if f(x, &elt) { break }\n                 }\n+                it.next();\n             }\n+            it.insert_next(elt);\n         }\n-        self.push_back(elt);\n     }\n \n-    /// Merge, using the function `f`; take `a` if `f(a, b)` is true, else `b`.\n+    /// Merge DList `other` into this DList, using the function `f`.\n+    /// Iterate the both DList with `a` from self and `b` from `other`, and\n+    /// put `a` in the result if `f(a, b)` is true, else `b`.\n     ///\n     /// O(max(N, M))\n     pub fn merge(&mut self, mut other: DList<T>, f: &fn(&T, &T) -> bool) {\n         {\n             let mut it = self.mut_iter();\n             loop {\n-                match (it.next(), other.front()) {\n-                    (None   , _      ) => break,\n-                    (_      , None   ) => return,\n-                    (Some(x), Some(y)) => if f(x, y) { loop }\n+                let take_a = match (it.peek_next(), other.front()) {\n+                    (_   , None) => return,\n+                    (None, _   ) => break,\n+                    (Some(ref mut x), Some(y)) => f(*x, y),\n+                };\n+                if take_a {\n+                    it.next();\n+                } else {\n+                    it.insert_next(other.pop_front().unwrap());\n                 }\n-                it.insert_before(other.pop_front().unwrap());\n             }\n         }\n         self.append(other);\n     }\n \n \n     /// Provide a forward iterator\n-    pub fn iter<'a>(&'a self) -> ForwardIterator<'a, T> {\n-        ForwardIterator{nelem: self.len(), list: self, next: &self.list_head}\n+    pub fn iter<'a>(&'a self) -> DListIterator<'a, T> {\n+        DListIterator{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provide a reverse iterator\n-    pub fn rev_iter<'a>(&'a self) -> ReverseIterator<'a, T> {\n-        ReverseIterator{nelem: self.len(), list: self, next: self.list_tail}\n+    pub fn rev_iter<'a>(&'a self) -> InvertIterator<&'a T, DListIterator<'a, T>> {\n+        self.iter().invert()\n     }\n \n     /// Provide a forward iterator with mutable references\n-    pub fn mut_iter<'a>(&'a mut self) -> MutForwardIterator<'a, T> {\n-        MutForwardIterator{nelem: self.len(), list: self, curs: Rawlink::none()}\n+    pub fn mut_iter<'a>(&'a mut self) -> MutDListIterator<'a, T> {\n+        let head_raw = match self.list_head {\n+            Some(ref mut h) => Rawlink::some(*h),\n+            None => Rawlink::none(),\n+        };\n+        MutDListIterator{\n+            nelem: self.len(),\n+            head: head_raw,\n+            tail: self.list_tail,\n+            list: self\n+        }\n     }\n-\n     /// Provide a reverse iterator with mutable references\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> MutReverseIterator<'a, T> {\n-        MutReverseIterator{nelem: self.len(), list: self, next: self.list_tail}\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> InvertIterator<&'a mut T,\n+                                                MutDListIterator<'a, T>> {\n+        self.mut_iter().invert()\n     }\n \n \n@@ -346,29 +344,32 @@ impl<T> DList<T> {\n     }\n \n     /// Consume the list into an iterator yielding elements by value, in reverse\n-    pub fn consume_rev_iter(self) -> ConsumeRevIterator<T> {\n-        ConsumeRevIterator{list: self}\n+    pub fn consume_rev_iter(self) -> InvertIterator<T, ConsumeIterator<T>> {\n+        self.consume_iter().invert()\n     }\n }\n \n-/// Insert sorted in ascending order\n-///\n-/// O(N)\n impl<T: cmp::TotalOrd> DList<T> {\n-    fn insert_ordered(&mut self, elt: T) {\n+    /// Insert `elt` sorted in ascending order\n+    ///\n+    /// O(N)\n+    pub fn insert_ordered(&mut self, elt: T) {\n         self.insert_when(elt, |a, b| a.cmp(b) != cmp::Less);\n     }\n }\n \n-impl<'self, A> Iterator<&'self A> for ForwardIterator<'self, A> {\n+impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self A> {\n-        match *self.next {\n+        if self.nelem == 0 {\n+            return None;\n+        }\n+        match *self.head {\n             None => None,\n-            Some(ref next) => {\n+            Some(ref head) => {\n                 self.nelem -= 1;\n-                self.next = &next.next;\n-                Some(&next.value)\n+                self.head = &head.next;\n+                Some(&head.value)\n             }\n         }\n     }\n@@ -378,49 +379,37 @@ impl<'self, A> Iterator<&'self A> for ForwardIterator<'self, A> {\n     }\n }\n \n-// MutForwardIterator is different because it implements ListInsertion,\n-// and can modify the list during traversal, used in insert_when and merge.\n-impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'self mut A> {\n-        match self.curs.resolve() {\n-            None => {\n-                match self.list.list_head {\n-                    None => None,\n-                    Some(ref mut head) => {\n-                        self.nelem -= 1;\n-                        self.curs = Rawlink::some(*head);\n-                        Some(&mut head.value)\n-                    }\n-                }\n-            }\n-            Some(curs) => {\n-                match curs.next {\n-                    None => None,\n-                    Some(ref mut head) => {\n-                        self.nelem -= 1;\n-                        self.curs = Rawlink::some(*head);\n-                        Some(&mut head.value)\n-                    }\n-                }\n+impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n+    fn next_back(&mut self) -> Option<&'self A> {\n+        if self.nelem == 0 {\n+            return None;\n+        }\n+        match self.tail.resolve() {\n+            None => None,\n+            Some(prev) => {\n+                self.nelem -= 1;\n+                self.tail = prev.prev;\n+                Some(&prev.value)\n             }\n         }\n     }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.nelem, Some(self.nelem))\n-    }\n }\n \n-impl<'self, A> Iterator<&'self A> for ReverseIterator<'self, A> {\n+impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self A> {\n-        match self.next.resolve() {\n+    fn next(&mut self) -> Option<&'self mut A> {\n+        if self.nelem == 0 {\n+            return None;\n+        }\n+        match self.head.resolve() {\n             None => None,\n-            Some(prev) => {\n+            Some(next) => {\n                 self.nelem -= 1;\n-                self.next = prev.prev;\n-                Some(&prev.value)\n+                self.head = match next.next {\n+                    Some(ref mut node) => Rawlink::some(&mut **node),\n+                    None => Rawlink::none(),\n+                };\n+                Some(&mut next.value)\n             }\n         }\n     }\n@@ -430,37 +419,39 @@ impl<'self, A> Iterator<&'self A> for ReverseIterator<'self, A> {\n     }\n }\n \n-impl<'self, A> Iterator<&'self mut A> for MutReverseIterator<'self, A> {\n+impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self mut A> {\n-        match self.next.resolve() {\n+    fn next_back(&mut self) -> Option<&'self mut A> {\n+        if self.nelem == 0 {\n+            return None;\n+        }\n+        match self.tail.resolve() {\n             None => None,\n             Some(prev) => {\n                 self.nelem -= 1;\n-                self.next = prev.prev;\n+                self.tail = prev.prev;\n                 Some(&mut prev.value)\n             }\n         }\n     }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.nelem, Some(self.nelem))\n-    }\n }\n \n+\n /// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {\n-    /// Insert `elt` just previous to the most recently yielded element\n-    fn insert_before(&mut self, elt: A);\n+    /// Insert `elt` just after to the most recently yielded element\n+    fn insert_next(&mut self, elt: A);\n \n     /// Provide a reference to the next element, without changing the iterator\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-impl<'self, A> ListInsertion<A> for MutForwardIterator<'self, A> {\n-    fn insert_before(&mut self, elt: A) {\n-        match self.curs.resolve() {\n-            None => { self.list.push_front(elt); self.next(); }\n+impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n+    fn insert_next(&mut self, elt: A) {\n+        // Insert an element before `self.head` so that it is between the\n+        // previously yielded element and self.head.\n+        match self.head.resolve() {\n+            None => { self.list.push_back(elt); }\n             Some(node) => {\n                 let prev_node = match node.prev.resolve() {\n                     None => return self.list.push_front(elt),\n@@ -476,12 +467,9 @@ impl<'self, A> ListInsertion<A> for MutForwardIterator<'self, A> {\n     }\n \n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n-        match self.curs.resolve() {\n-            None => self.list.front_mut(),\n-            Some(curs) => match curs.next {\n-                None => None,\n-                Some(ref mut node) => Some(&mut node.value),\n-            }\n+        match self.head.resolve() {\n+            None => None,\n+            Some(head) => Some(&mut head.value),\n         }\n     }\n }\n@@ -493,11 +481,8 @@ impl<A> Iterator<A> for ConsumeIterator<A> {\n     }\n }\n \n-impl<A> Iterator<A> for ConsumeRevIterator<A> {\n-    fn next(&mut self) -> Option<A> { self.list.pop_back() }\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.list.length, Some(self.list.length))\n-    }\n+impl<A> DoubleEndedIterator<A> for ConsumeIterator<A> {\n+    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n impl<A, T: Iterator<A>> FromIterator<A, T> for DList<A> {\n@@ -687,6 +672,24 @@ mod tests {\n         assert_eq!(it.next(), None);\n     }\n \n+    #[test]\n+    fn test_iterator_double_end() {\n+        let mut n = DList::new();\n+        assert_eq!(n.iter().next(), None);\n+        n.push_front(4);\n+        n.push_front(5);\n+        n.push_front(6);\n+        let mut it = n.iter();\n+        assert_eq!(it.size_hint(), (3, Some(3)));\n+        assert_eq!(it.next().unwrap(), &6);\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert_eq!(it.next_back().unwrap(), &4);\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next_back().unwrap(), &5);\n+        assert_eq!(it.next_back(), None);\n+        assert_eq!(it.next(), None);\n+    }\n+\n     #[test]\n     fn test_rev_iter() {\n         let m = generate_test();\n@@ -715,38 +718,58 @@ mod tests {\n         let mut n = DList::new();\n         assert!(n.mut_iter().next().is_none());\n         n.push_front(4);\n+        n.push_back(5);\n         let mut it = n.mut_iter();\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert!(it.next().is_some());\n         assert!(it.next().is_some());\n         assert_eq!(it.size_hint(), (0, Some(0)));\n         assert!(it.next().is_none());\n     }\n \n+    #[test]\n+    fn test_iterator_mut_double_end() {\n+        let mut n = DList::new();\n+        assert!(n.mut_iter().next_back().is_none());\n+        n.push_front(4);\n+        n.push_front(5);\n+        n.push_front(6);\n+        let mut it = n.mut_iter();\n+        assert_eq!(it.size_hint(), (3, Some(3)));\n+        assert_eq!(*it.next().unwrap(), 6);\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert_eq!(*it.next_back().unwrap(), 4);\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(*it.next_back().unwrap(), 5);\n+        assert!(it.next_back().is_none());\n+        assert!(it.next().is_none());\n+    }\n+\n     #[test]\n     fn test_insert_prev() {\n         let mut m = list_from(&[0,2,4,6,8]);\n         let len = m.len();\n         {\n             let mut it = m.mut_iter();\n-            it.insert_before(-2);\n+            it.insert_next(-2);\n             loop {\n                 match it.next() {\n                     None => break,\n                     Some(elt) => {\n-                        it.insert_before(*elt + 1);\n+                        it.insert_next(*elt + 1);\n                         match it.peek_next() {\n                             Some(x) => assert_eq!(*x, *elt + 2),\n                             None => assert_eq!(8, *elt),\n                         }\n                     }\n                 }\n             }\n-            it.insert_before(0);\n-            it.insert_before(1);\n+            it.insert_next(0);\n+            it.insert_next(1);\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.consume_iter().collect::<~[int]>(), ~[-2,1,0,3,2,5,4,7,6,9,0,1,8]);\n+        assert_eq!(m.consume_iter().collect::<~[int]>(), ~[-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n@@ -758,7 +781,7 @@ mod tests {\n         assert_eq!(m.len(), len);\n         check_links(&m);\n         let res = m.consume_iter().collect::<~[int]>();\n-        assert_eq!(res, ~[-1, 0, 0, 1, 0, 3, 5, 6, 7, 2, 7, 7, 9]);\n+        assert_eq!(res, ~[-1, 0, 0, 0, 1, 3, 5, 6, 7, 2, 7, 7, 9]);\n     }\n \n     #[test]\n@@ -860,7 +883,7 @@ mod tests {\n     fn bench_collect_into(b: &mut test::BenchHarness) {\n         let v = &[0, ..64];\n         do b.iter {\n-            let _: DList<int> = v.iter().transform(|&x|x).collect();\n+            let _: DList<int> = v.iter().transform(|x| *x).collect();\n         }\n     }\n     #[bench]\n@@ -924,31 +947,31 @@ mod tests {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.iter().advance |_| {}\n+            assert!(m.iter().len_() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.mut_iter().advance |_| {}\n+            assert!(m.mut_iter().len_() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.rev_iter().advance |_| {}\n+            assert!(m.rev_iter().len_() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.mut_rev_iter().advance |_| {}\n+            assert!(m.mut_rev_iter().len_() == 128);\n         }\n     }\n     #[bench]"}]}