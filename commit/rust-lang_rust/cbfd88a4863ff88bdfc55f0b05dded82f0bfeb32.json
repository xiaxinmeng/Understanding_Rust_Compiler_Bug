{"sha": "cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZmQ4OGE0ODYzZmY4OGJkZmM1NWYwYjA1ZGRlZDgyZjBiZmViMzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-26T19:37:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-05T13:46:23Z"}, "message": "Update region inference for traits so that a method with\nexplicit self doesn't incorrectly cause the entire trait to\nbe tagged as being region-parameterized.\n\nFixes #5224.", "tree": {"sha": "9e4a0892e948214950be6cd4f6b5b4d1c1fea664", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e4a0892e948214950be6cd4f6b5b4d1c1fea664"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "html_url": "https://github.com/rust-lang/rust/commit/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65986ba0c0b20803dd02a5b0b71e269cbeb8336d", "url": "https://api.github.com/repos/rust-lang/rust/commits/65986ba0c0b20803dd02a5b0b71e269cbeb8336d", "html_url": "https://github.com/rust-lang/rust/commit/65986ba0c0b20803dd02a5b0b71e269cbeb8336d"}], "stats": {"total": 452, "additions": 263, "deletions": 189}, "files": [{"sha": "6eb698d34d207a5770d97833cc1fc5bb45ba55d2", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -16,7 +16,6 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n-use core::option;\n use syntax::ast::*;\n use syntax::codemap;\n use syntax::{visit, ast_util, ast_map};"}, {"sha": "51cb305ab028e4131dd7ba44cab5524d4f7ac749", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -19,7 +19,6 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n-use core::option;\n use core::uint;\n use core::vec;\n use std::sort;"}, {"sha": "98a05d9b8dfd9a13f8e18903b40fe734dd1db659", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -18,7 +18,6 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::{ty_to_str, tys_to_str};\n \n-use core::option;\n use core::str;\n use core::vec;\n use std::oldmap::HashMap;"}, {"sha": "4d874fc4ef9ca5fc63fd06ac93a827d14db8e3cd", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -416,9 +416,13 @@ pub struct DetermineRpCtxt {\n     item_id: ast::node_id,\n \n     // true when we are within an item but not within a method.\n-    // see long discussion on region_is_relevant()\n+    // see long discussion on region_is_relevant().\n     anon_implies_rp: bool,\n \n+    // true when we are not within an &self method.\n+    // see long discussion on region_is_relevant().\n+    self_implies_rp: bool,\n+\n     // encodes the context of the current type; invariant if\n     // mutable, covariant otherwise\n     ambient_variance: region_variance,\n@@ -458,14 +462,14 @@ pub fn add_variance(+ambient_variance: region_variance,\n }\n \n pub impl DetermineRpCtxt {\n-    fn add_variance(@mut self, variance: region_variance) -> region_variance {\n+    fn add_variance(&self, variance: region_variance) -> region_variance {\n         add_variance(self.ambient_variance, variance)\n     }\n \n     /// Records that item `id` is region-parameterized with the\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n-    fn add_rp(@mut self, id: ast::node_id, variance: region_variance) {\n+    fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n         assert id != 0;\n         let old_variance = self.region_paramd_items.find(&id);\n         let joined_variance = match old_variance {\n@@ -490,7 +494,7 @@ pub impl DetermineRpCtxt {\n     /// `from`.  Put another way, it indicates that the current item\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n-    fn add_dep(@mut self, from: ast::node_id) {\n+    fn add_dep(&mut self, from: ast::node_id) {\n         debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n@@ -515,42 +519,46 @@ pub impl DetermineRpCtxt {\n     }\n \n     // Determines whether a reference to a region that appears in the\n-    // AST implies that the enclosing type is region-parameterized.\n-    //\n-    // This point is subtle.  Here are four examples to make it more\n+    // AST implies that the enclosing type is region-parameterized (RP).\n+    // This point is subtle.  Here are some examples to make it more\n     // concrete.\n     //\n     // 1. impl foo for &int { ... }\n     // 2. impl foo for &self/int { ... }\n-    // 3. impl foo for bar { fn m() -> &self/int { ... } }\n-    // 4. impl foo for bar { fn m() -> &int { ... } }\n+    // 3. impl foo for bar { fn m(@self) -> &self/int { ... } }\n+    // 4. impl foo for bar { fn m(&self) -> &self/int { ... } }\n+    // 5. impl foo for bar { fn m(&self) -> &int { ... } }\n     //\n     // In case 1, the anonymous region is being referenced,\n     // but it appears in a context where the anonymous region\n-    // resolves to self, so the impl foo is region-parameterized.\n+    // resolves to self, so the impl foo is RP.\n     //\n     // In case 2, the self parameter is written explicitly.\n     //\n-    // In case 3, the method refers to self, so that implies that the\n-    // impl must be region parameterized.  (If the type bar is not\n-    // region parameterized, that is an error, because the self region\n-    // is effectively unconstrained, but that is detected elsewhere).\n+    // In case 3, the method refers to the region `self`, so that\n+    // implies that the impl must be region parameterized.  (If the\n+    // type bar is not region parameterized, that is an error, because\n+    // the self region is effectively unconstrained, but that is\n+    // detected elsewhere).\n+    //\n+    // In case 4, the method refers to the region `self`, but the\n+    // `self` region is bound by the `&self` receiver, and so this\n+    // does not require that `bar` be RP.\n     //\n-    // In case 4, the anonymous region is referenced, but it\n+    // In case 5, the anonymous region is referenced, but it\n     // bound by the method, so it does not refer to self.  This impl\n     // need not be region parameterized.\n     //\n-    // So the rules basically are: the `self` region always implies\n-    // that the enclosing type is region parameterized.  The anonymous\n-    // region also does, unless it appears within a method, in which\n-    // case it is bound.  We handle this by setting a flag\n-    // (anon_implies_rp) to true when we enter an item and setting\n-    // that flag to false when we enter a method.\n-    fn region_is_relevant(@mut self, r: @ast::region) -> bool {\n+    // Normally, & or &self implies that the enclosing item is RP.\n+    // However, within a function, & is always bound.  Within a method\n+    // with &self type, &self is also bound.  We detect those last two\n+    // cases via flags (anon_implies_rp and self_implies_rp) that are\n+    // true when the anon or self region implies RP.\n+    fn region_is_relevant(&self, r: @ast::region) -> bool {\n         match r.node {\n             ast::re_static => false,\n             ast::re_anon => self.anon_implies_rp,\n-            ast::re_self => true,\n+            ast::re_self => self.self_implies_rp,\n             ast::re_named(_) => false\n         }\n     }\n@@ -561,7 +569,7 @@ pub impl DetermineRpCtxt {\n     //\n     // If the region is explicitly specified, then we follows the\n     // normal rules.\n-    fn opt_region_is_relevant(@mut self,\n+    fn opt_region_is_relevant(&self,\n                               opt_r: Option<@ast::region>)\n                            -> bool {\n         debug!(\"opt_region_is_relevant: %? (anon_implies_rp=%b)\",\n@@ -575,16 +583,23 @@ pub impl DetermineRpCtxt {\n     fn with(@mut self,\n             item_id: ast::node_id,\n             anon_implies_rp: bool,\n+            self_implies_rp: bool,\n             f: &fn()) {\n         let old_item_id = self.item_id;\n         let old_anon_implies_rp = self.anon_implies_rp;\n+        let old_self_implies_rp = self.self_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        debug!(\"with_item_id(%d, %b)\", item_id, anon_implies_rp);\n+        self.self_implies_rp = self_implies_rp;\n+        debug!(\"with_item_id(%d, %b, %b)\",\n+               item_id,\n+               anon_implies_rp,\n+               self_implies_rp);\n         let _i = ::util::common::indenter();\n         f();\n         self.item_id = old_item_id;\n         self.anon_implies_rp = old_anon_implies_rp;\n+        self.self_implies_rp = old_self_implies_rp;\n     }\n \n     fn with_ambient_variance(@mut self, variance: region_variance, f: &fn()) {\n@@ -598,7 +613,7 @@ pub impl DetermineRpCtxt {\n pub fn determine_rp_in_item(item: @ast::item,\n                             &&cx: @mut DetermineRpCtxt,\n                             visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(item.id, true) {\n+    do cx.with(item.id, true, true) {\n         visit::visit_item(item, cx, visitor);\n     }\n }\n@@ -610,7 +625,12 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           _: ast::node_id,\n                           &&cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(cx.item_id, false) {\n+    let self_implies_rp = match fk {\n+        &visit::fk_method(_, _, m) => !m.self_ty.node.is_borrowed(),\n+        _ => true\n+    };\n+\n+    do cx.with(cx.item_id, false, self_implies_rp) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.each |a| {\n                 (visitor.visit_ty)(a.ty, cx, visitor);\n@@ -626,7 +646,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n                                  &&cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(cx.item_id, false) {\n+    do cx.with(cx.item_id, false, !ty_m.self_ty.node.is_borrowed()) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n@@ -735,7 +755,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n       ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n-        do cx.with(cx.item_id, false) {\n+        do cx.with(cx.item_id, false, true) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.each |a| {\n@@ -796,6 +816,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         worklist: ~[],\n         item_id: 0,\n         anon_implies_rp: false,\n+        self_implies_rp: true,\n         ambient_variance: rv_covariant\n     };\n "}, {"sha": "76c62919dfa0b257a6c51d1706e05aa0fa9abe21", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -69,7 +69,6 @@ use core::hash;\n use core::int;\n use core::io;\n use core::libc::{c_uint, c_ulonglong};\n-use core::option;\n use core::uint;\n use std::oldmap::HashMap;\n use std::{oldmap, time, list};"}, {"sha": "8472d956cd245301460f2db7a0131a89a8ed84b5", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -69,12 +69,11 @@ use syntax::print::pprust::path_to_str;\n use util::common::indenter;\n \n pub trait AstConv {\n-    fn tcx(@mut self) -> ty::ctxt;\n-    fn ccx(@mut self) -> @mut CrateCtxt;\n-    fn get_item_ty(@mut self, id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+    fn tcx(&self) -> ty::ctxt;\n+    fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n \n     // what type should we use when a type is omitted?\n-    fn ty_infer(@mut self, span: span) -> ty::t;\n+    fn ty_infer(&self, span: span) -> ty::t;\n }\n \n pub fn get_region_reporting_err(tcx: ty::ctxt,\n@@ -92,8 +91,8 @@ pub fn get_region_reporting_err(tcx: ty::ctxt,\n }\n \n pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         span: span,\n         a_r: @ast::region)\n      -> ty::Region {\n@@ -108,8 +107,8 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         did: ast::def_id,\n         path: @ast::path)\n      -> ty_param_substs_and_ty {\n@@ -164,8 +163,8 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n }\n \n pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         did: ast::def_id,\n         path: @ast::path,\n         path_id: ast::node_id)\n@@ -189,11 +188,11 @@ pub const NO_TPS: uint = 2;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n-    self: @mut AC, rscope: RS, &&ast_ty: @ast::Ty) -> ty::t {\n+pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n+    self: &AC, rscope: &RS, &&ast_ty: @ast::Ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC, rscope: RS, mt: ast::mt) -> ty::mt {\n+    fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + Durable>(\n+        self: &AC, rscope: &RS, mt: ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n@@ -202,8 +201,8 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle function sigils and first-class trait types.\n     fn mk_pointer<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         a_seq_ty: ast::mt,\n         vst: ty::vstore,\n         constr: fn(ty::mt) -> ty::t) -> ty::t\n@@ -316,7 +315,8 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n       }\n       ast::ty_rptr(region, mt) => {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n-        mk_pointer(self, in_anon_rscope(rscope, r), mt, ty::vstore_slice(r),\n+        let anon_rscope = in_anon_rscope(rscope, r);\n+        mk_pointer(self, &anon_rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(fields) => {\n@@ -419,8 +419,8 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n }\n \n pub fn ty_of_arg<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         a: ast::arg,\n         expected_ty: Option<ty::arg>)\n      -> ty::arg {\n@@ -467,8 +467,8 @@ pub fn ty_of_arg<AC:AstConv,RS:region_scope + Copy + Durable>(\n }\n \n pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         purity: ast::purity,\n         abi: ast::Abi,\n         decl: &ast::fn_decl)\n@@ -479,10 +479,10 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n     // that function type\n     let rb = in_binding_rscope(rscope);\n \n-    let input_tys = decl.inputs.map(|a| ty_of_arg(self, rb, *a, None));\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(self, &rb, *a, None));\n     let output_ty = match decl.output.node {\n         ast::ty_infer => self.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(self, rb, decl.output)\n+        _ => ast_ty_to_ty(self, &rb, decl.output)\n     };\n \n     ty::BareFnTy {\n@@ -493,8 +493,8 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n }\n \n pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: @mut AC,\n-        rscope: RS,\n+        self: &AC,\n+        rscope: &RS,\n         sigil: ast::Sigil,\n         purity: ast::purity,\n         onceness: ast::Onceness,\n@@ -538,14 +538,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n-        ty_of_arg(self, rb, *a, expected_arg_ty)\n+        ty_of_arg(self, &rb, *a, expected_arg_ty)\n     };\n \n     let expected_ret_ty = expected_tys.map(|e| e.output);\n     let output_ty = match decl.output.node {\n         ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n         ast::ty_infer => self.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(self, rb, decl.output)\n+        _ => ast_ty_to_ty(self, &rb, decl.output)\n     };\n \n     ty::ClosureTy {"}, {"sha": "06163d746c29ed89d4ef833eebb4f412407b7af7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -581,7 +581,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n-        let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n+        let self_ty = ccx.to_ty(&rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n             check_method(ccx, *m, self_ty, local_def(it.id));\n         }\n@@ -636,21 +636,20 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n }\n \n impl AstConv for FnCtxt {\n-    fn tcx(@mut self) -> ty::ctxt { self.ccx.tcx }\n-    fn ccx(@mut self) -> @mut CrateCtxt { self.ccx }\n+    fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n \n-    fn get_item_ty(@mut self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn ty_infer(@mut self, _span: span) -> ty::t {\n+    fn ty_infer(&self, _span: span) -> ty::t {\n         self.infcx().next_ty_var()\n     }\n }\n \n pub impl FnCtxt {\n-    fn infcx(@mut self) -> @mut infer::InferCtxt { self.inh.infcx }\n-    fn search_in_scope_regions(@mut self,\n+    fn infcx(&self) -> @mut infer::InferCtxt { self.inh.infcx }\n+    fn search_in_scope_regions(&self,\n                                br: ty::bound_region)\n                             -> Result<ty::Region, ~str> {\n         let in_scope_regions = self.in_scope_regions;\n@@ -669,25 +668,17 @@ pub impl FnCtxt {\n     }\n }\n \n-impl region_scope for @mut FnCtxt {\n-    pure fn anon_region(&self, span: span) -> Result<ty::Region, ~str> {\n-        // XXX: Unsafe to work around purity\n-        unsafe {\n-            result::Ok(self.infcx().next_region_var_nb(span))\n-        }\n+impl region_scope for FnCtxt {\n+    fn anon_region(&self, span: span) -> Result<ty::Region, ~str> {\n+        result::Ok(self.infcx().next_region_var_nb(span))\n     }\n-    pure fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        // XXX: Unsafe to work around purity\n-        unsafe {\n-            self.search_in_scope_regions(ty::br_self)\n-        }\n+    fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        self.search_in_scope_regions(ty::br_self)\n     }\n-    pure fn named_region(&self, _span: span, id: ast::ident)\n-                      -> Result<ty::Region, ~str> {\n-        // XXX: Unsafe to work around purity\n-        unsafe {\n-            self.search_in_scope_regions(ty::br_named(id))\n-        }\n+    fn named_region(&self,\n+                    _span: span,\n+                    id: ast::ident) -> Result<ty::Region, ~str> {\n+        self.search_in_scope_regions(ty::br_named(id))\n     }\n }\n \n@@ -710,7 +701,7 @@ pub impl FnCtxt {\n              pprust::expr_to_str(expr, self.tcx().sess.intr()))\n     }\n \n-    fn block_region(@mut self) -> ty::Region {\n+    fn block_region(&self) -> ty::Region {\n         ty::re_scope(self.region_lb)\n     }\n \n@@ -1076,7 +1067,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n               }, _)) => {\n             (ts.ty_params.len(),\n              region_param,\n-             vcx.ccx.to_ty(rscope::type_rscope(region_param), st))\n+             vcx.ccx.to_ty(&rscope::type_rscope(region_param), st))\n           }\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_struct(_, ref ts),"}, {"sha": "2938f25291d2c793efbb973e831e65ee18c2857d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -47,7 +47,6 @@ use util::common::{indenter, pluralize};\n use util::ppaux;\n \n use core::dvec;\n-use core::option;\n use core::vec;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n@@ -108,24 +107,24 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n     visit::visit_crate(\n         *crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_item: |a|convert(ccx, a),\n+            visit_item: |a| convert(ccx, a),\n             visit_foreign_item: |a|convert_foreign(ccx, a),\n             .. *visit::default_simple_visitor()\n         }));\n }\n \n-pub impl @mut CrateCtxt {\n-    fn to_ty<RS:region_scope + Copy + Durable>(rs: RS, ast_ty: @ast::Ty)\n-                                         -> ty::t {\n+impl CrateCtxt {\n+    fn to_ty<RS:region_scope + Copy + Durable>(\n+        &self, rs: &RS, ast_ty: @ast::Ty) -> ty::t\n+    {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n impl AstConv for CrateCtxt {\n-    fn tcx(@mut self) -> ty::ctxt { self.tcx }\n-    fn ccx(@mut self) -> @mut CrateCtxt { self }\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n \n-    fn get_item_ty(@mut self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n         if id.crate != ast::local_crate {\n             csearch::get_type(self.tcx, id)\n         } else {\n@@ -144,13 +143,13 @@ impl AstConv for CrateCtxt {\n         }\n     }\n \n-    fn ty_infer(@mut self, span: span) -> ty::t {\n+    fn ty_infer(&self, span: span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n                                ~\"found `ty_infer` in unexpected place\");\n     }\n }\n \n-pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n+pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n                               variants: &[ast::variant],\n                               generics: &ast::Generics,\n@@ -165,7 +164,7 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(rp);\n-                let input_tys = args.map(|va| ccx.to_ty(rs, va.ty));\n+                let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n                 result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n \n@@ -217,17 +216,17 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n+pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             id: ast::node_id,\n                             trait_ty: ty::t) {\n-    fn store_methods<T>(ccx: @mut CrateCtxt,\n+    fn store_methods<T>(ccx: &CrateCtxt,\n                         id: ast::node_id,\n                         stuff: ~[T],\n                         f: &fn(v: &T) -> ty::method) {\n         ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n     }\n \n-    fn make_static_method_ty(ccx: @mut CrateCtxt,\n+    fn make_static_method_ty(ccx: &CrateCtxt,\n                              am: &ast::ty_method,\n                              rp: Option<ty::region_variance>,\n                              m: ty::method,\n@@ -308,7 +307,7 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn ensure_supertraits(ccx: @mut CrateCtxt,\n+pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n@@ -492,7 +491,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n+pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    generics: &ast::Generics,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n@@ -544,11 +543,11 @@ pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n     }\n } // fn\n \n-pub fn convert_field(ccx: @mut CrateCtxt,\n+pub fn convert_field(ccx: &CrateCtxt,\n                      rp: Option<ty::region_variance>,\n                      bounds: @~[ty::param_bounds],\n                      v: @ast::struct_field) {\n-    let tt = ccx.to_ty(type_rscope(rp), v.node.ty);\n+    let tt = ccx.to_ty(&type_rscope(rp), v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n@@ -566,8 +565,8 @@ pub struct ConvertedMethod {\n     body_id: ast::node_id\n }\n \n-pub fn convert_methods(ccx: @mut CrateCtxt,\n-                       ms: ~[@ast::method],\n+pub fn convert_methods(ccx: &CrateCtxt,\n+                       ms: &[@ast::method],\n                        rp: Option<ty::region_variance>,\n                        rcvr_bounds: @~[ty::param_bounds])\n                     -> ~[ConvertedMethod] {\n@@ -593,7 +592,7 @@ pub fn convert_methods(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn ensure_no_ty_param_bounds(ccx: @mut CrateCtxt,\n+pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: span,\n                                  generics: &ast::Generics,\n                                  thing: &static/str) {\n@@ -607,7 +606,7 @@ pub fn ensure_no_ty_param_bounds(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n+pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n@@ -627,7 +626,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_impl(ref generics, trait_ref, selfty, ref ms) => {\n         let i_bounds = ty_param_bounds(ccx, generics);\n-        let selfty = ccx.to_ty(type_rscope(rp), selfty);\n+        let selfty = ccx.to_ty(&type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           ty_param_bounds_and_ty {\n@@ -636,7 +635,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n                             ty: selfty});\n \n         // XXX: Bad copy of `ms` below.\n-        let cms = convert_methods(ccx, /*bad*/copy *ms, rp, i_bounds);\n+        let cms = convert_methods(ccx, *ms, rp, i_bounds);\n         for trait_ref.each |t| {\n             check_methods_against_trait(ccx, generics, rp, selfty,\n                                         *t, /*bad*/copy cms);\n@@ -680,7 +679,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n     }\n }\n \n-pub fn convert_struct(ccx: @mut CrateCtxt,\n+pub fn convert_struct(ccx: &CrateCtxt,\n                       rp: Option<ty::region_variance>,\n                       struct_def: @ast::struct_def,\n                       generics: &ast::Generics,\n@@ -693,7 +692,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n         let t_dtor = ty::mk_bare_fn(\n             tcx,\n             astconv::ty_of_bare_fn(\n-                ccx, type_rscope(rp),\n+                ccx, &type_rscope(rp),\n                 ast::impure_fn, ast::RustAbi,\n                 &ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n@@ -738,7 +737,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn convert_foreign(ccx: @mut CrateCtxt, i: @ast::foreign_item) {\n+pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -747,28 +746,38 @@ pub fn convert_foreign(ccx: @mut CrateCtxt, i: @ast::foreign_item) {\n     ccx.tcx.tcache.insert(local_def(i.id), tpt);\n }\n \n-pub fn ty_of_method(ccx: @mut CrateCtxt,\n+pub fn ty_of_method(ccx: &CrateCtxt,\n                     m: @ast::method,\n                     rp: Option<ty::region_variance>) -> ty::method {\n+    let rscope = MethodRscope {\n+        self_ty: m.self_ty.node,\n+        region_parameterization: rp\n+    };\n+\n     ty::method {\n         ident: m.ident,\n         tps: ty_param_bounds(ccx, &m.generics),\n-        fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n+        fty: astconv::ty_of_bare_fn(ccx, &rscope, m.purity,\n                                     ast::RustAbi, &m.decl),\n         self_ty: m.self_ty.node,\n         vis: m.vis,\n         def_id: local_def(m.id)\n     }\n }\n \n-pub fn ty_of_ty_method(self: @mut CrateCtxt,\n+pub fn ty_of_ty_method(self: &CrateCtxt,\n                        m: &ast::ty_method,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n+    let rscope = MethodRscope {\n+        self_ty: m.self_ty.node,\n+        region_parameterization: rp\n+    };\n+\n     ty::method {\n         ident: m.ident,\n         tps: ty_param_bounds(self, &m.generics),\n-        fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n+        fty: astconv::ty_of_bare_fn(self, &rscope, m.purity,\n                                     ast::RustAbi, &m.decl),\n         // assume public, because this is only invoked on trait methods\n         self_ty: m.self_ty.node,\n@@ -782,7 +791,7 @@ pub fn ty_of_ty_method(self: @mut CrateCtxt,\n   it's bound to a valid trait type. Returns the def_id for the defining\n   trait. Fails if the type is a type other than an trait type.\n  */\n-pub fn instantiate_trait_ref(ccx: @mut CrateCtxt, t: @ast::trait_ref,\n+pub fn instantiate_trait_ref(ccx: &CrateCtxt, t: @ast::trait_ref,\n                              rp: Option<ty::region_variance>)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n@@ -793,7 +802,7 @@ pub fn instantiate_trait_ref(ccx: @mut CrateCtxt, t: @ast::trait_ref,\n \n     match lookup_def_tcx(ccx.tcx, t.path.span, t.ref_id) {\n       ast::def_ty(t_id) => {\n-        let tpt = astconv::ast_path_to_ty(ccx, rscope, t_id, t.path,\n+        let tpt = astconv::ast_path_to_ty(ccx, &rscope, t_id, t.path,\n                                           t.ref_id);\n         match ty::get(tpt.ty).sty {\n            ty::ty_trait(*) => {\n@@ -806,7 +815,7 @@ pub fn instantiate_trait_ref(ccx: @mut CrateCtxt, t: @ast::trait_ref,\n     }\n }\n \n-pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n+pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n                -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -817,14 +826,14 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n     let rp = tcx.region_paramd_items.find(&it.id);\n     match it.node {\n       ast::item_const(t, _) => {\n-        let typ = ccx.to_ty(empty_rscope, t);\n+        let typ = ccx.to_ty(&empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n       ast::item_fn(ref decl, purity, ref generics, _) => {\n         let bounds = ty_param_bounds(ccx, generics);\n-        let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n+        let tofd = astconv::ty_of_bare_fn(ccx, &empty_rscope, purity,\n                                           ast::RustAbi, decl);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -847,7 +856,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         let rp = tcx.region_paramd_items.find(&it.id);\n         let tpt = {\n             let ty = {\n-                let t0 = ccx.to_ty(type_rscope(rp), t);\n+                let t0 = ccx.to_ty(&type_rscope(rp), t);\n                 // Do not associate a def id with a named, parameterized type\n                 // like \"foo<X>\".  This is because otherwise ty_to_str will\n                 // print the name as merely \"foo\", as it has no way to\n@@ -906,23 +915,21 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n     }\n }\n \n-pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n+pub fn ty_of_foreign_item(ccx: &CrateCtxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n-    match /*bad*/copy it.node {\n+    match it.node {\n         ast::foreign_item_fn(ref fn_decl, _, ref generics) => {\n-            ty_of_foreign_fn_decl(\n-                ccx,\n-                fn_decl,\n-                local_def(it.id),\n-                generics\n-            )\n+            ty_of_foreign_fn_decl(ccx,\n+                                  fn_decl,\n+                                  local_def(it.id),\n+                                  generics)\n         }\n         ast::foreign_item_const(t) => {\n-            let rb = in_binding_rscope(empty_rscope);\n+            let rb = in_binding_rscope(&empty_rscope);\n             ty::ty_param_bounds_and_ty {\n                 bounds: @~[],\n                 region_param: None,\n-                ty: ast_ty_to_ty(ccx, rb, t)\n+                ty: ast_ty_to_ty(ccx, &rb, t)\n             }\n         }\n     }\n@@ -932,14 +939,14 @@ pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n // of a newtyped Ty or a region) to ty's notion of ty param bounds, which can\n // either be user-defined traits, or one of the four built-in traits (formerly\n // known as kinds): Const, Copy, Durable, and Send.\n-pub fn compute_bounds(ccx: @mut CrateCtxt,\n+pub fn compute_bounds(ccx: &CrateCtxt,\n                       ast_bounds: @OptVec<ast::TyParamBound>)\n                    -> ty::param_bounds {\n     @ast_bounds.flat_map_to_vec(|b| {\n         match b {\n             &TraitTyParamBound(b) => {\n                 let li = &ccx.tcx.lang_items;\n-                let ity = ast_ty_to_ty(ccx, empty_rscope, b);\n+                let ity = ast_ty_to_ty(ccx, &empty_rscope, b);\n                 match ty::get(ity).sty {\n                     ty::ty_trait(did, _, _) => {\n                         if did == li.owned_trait() {\n@@ -968,7 +975,7 @@ pub fn compute_bounds(ccx: @mut CrateCtxt,\n     })\n }\n \n-pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n+pub fn ty_param_bounds(ccx: &CrateCtxt,\n                        generics: &ast::Generics)\n                     -> @~[ty::param_bounds] {\n     @do generics.ty_params.map_to_vec |param| {\n@@ -983,15 +990,15 @@ pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n+pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              decl: &ast::fn_decl,\n                              def_id: ast::def_id,\n                              generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n     let bounds = ty_param_bounds(ccx, generics);\n-    let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n-    let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n+    let rb = in_binding_rscope(&empty_rscope);\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n+    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n@@ -1009,7 +1016,7 @@ pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n     return tpt;\n }\n \n-pub fn mk_generics(ccx: @mut CrateCtxt, generics: &ast::Generics)\n+pub fn mk_generics(ccx: &CrateCtxt, generics: &ast::Generics)\n     -> (@~[ty::param_bounds], ~[ty::t])\n {\n     let mut i = 0u;\n@@ -1022,7 +1029,7 @@ pub fn mk_generics(ccx: @mut CrateCtxt, generics: &ast::Generics)\n      }))\n }\n \n-pub fn mk_substs(ccx: @mut CrateCtxt,\n+pub fn mk_substs(ccx: &CrateCtxt,\n                  generics: &ast::Generics,\n                  rp: Option<ty::region_variance>)\n               -> (@~[ty::param_bounds], ty::substs)"}, {"sha": "84c68197e0ce1bdc257537a27482b4c78d52d001", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -18,41 +18,59 @@ use syntax::ast;\n use syntax::codemap::span;\n \n pub trait region_scope {\n-    pure fn anon_region(&self, span: span) -> Result<ty::Region, ~str>;\n-    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str>;\n-    pure fn named_region(&self, span: span, id: ast::ident)\n+    fn anon_region(&self, span: span) -> Result<ty::Region, ~str>;\n+    fn self_region(&self, span: span) -> Result<ty::Region, ~str>;\n+    fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str>;\n }\n \n pub enum empty_rscope { empty_rscope }\n-\n impl region_scope for empty_rscope {\n-    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        result::Ok(ty::re_static)\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        Ok(ty::re_static)\n     }\n-    pure fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+    fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n-    pure fn named_region(&self, _span: span, _id: ast::ident)\n+    fn named_region(&self, _span: span, _id: ast::ident)\n         -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n }\n \n-pub enum type_rscope = Option<ty::region_variance>;\n+pub struct MethodRscope {\n+    self_ty: ast::self_ty_,\n+    region_parameterization: Option<ty::region_variance>\n+}\n+impl region_scope for MethodRscope {\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        result::Err(~\"anonymous region types are not permitted here\")\n+    }\n+    fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        assert self.region_parameterization.is_some() ||\n+            self.self_ty.is_borrowed();\n+        result::Ok(ty::re_bound(ty::br_self))\n+    }\n+    fn named_region(&self, span: span, id: ast::ident)\n+                      -> Result<ty::Region, ~str> {\n+        do empty_rscope.named_region(span, id).chain_err |_e| {\n+            result::Err(~\"region is not in scope here\")\n+        }\n+    }\n+}\n \n+pub enum type_rscope = Option<ty::region_variance>;\n impl region_scope for type_rscope {\n-    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        match **self {\n-          Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n-          None => result::Err(~\"to use region types here, the containing \\\n-                                type must be declared with a region bound\")\n-        }\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        // if the anon or self region is used, region parameterization should\n+        // have inferred that this type is RP\n+        assert self.is_some();\n+        result::Ok(ty::re_bound(ty::br_self))\n     }\n-    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n+    fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n         self.anon_region(span)\n     }\n-    pure fn named_region(&self, span: span, id: ast::ident)\n+    fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             result::Err(~\"named regions other than `self` are not \\\n@@ -70,50 +88,55 @@ pub fn bound_self_region(rp: Option<ty::region_variance>)\n }\n \n pub struct anon_rscope { anon: ty::Region, base: @region_scope }\n-pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(self: RS,\n-                                                        r: ty::Region)\n-                                                     -> @anon_rscope {\n-    @anon_rscope {anon: r, base: @self as @region_scope}\n+pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(\n+    self: &RS,\n+    r: ty::Region) -> anon_rscope\n+{\n+    let base = @(copy *self) as @region_scope;\n+    anon_rscope {anon: r, base: base}\n }\n-\n-impl region_scope for @anon_rscope {\n-    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+impl region_scope for anon_rscope {\n+    fn anon_region(&self,\n+                   _span: span) -> Result<ty::Region, ~str>\n+    {\n         result::Ok(self.anon)\n     }\n-    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n+    fn self_region(&self,\n+                   span: span) -> Result<ty::Region, ~str>\n+    {\n         self.base.self_region(span)\n     }\n-    pure fn named_region(&self, span: span, id: ast::ident)\n-                      -> Result<ty::Region, ~str> {\n+    fn named_region(&self,\n+                    span: span,\n+                    id: ast::ident) -> Result<ty::Region, ~str>\n+    {\n         self.base.named_region(span, id)\n     }\n }\n \n pub struct binding_rscope {\n-    base: region_scope,\n-    anon_bindings: uint,\n+    base: @region_scope,\n+    anon_bindings: @mut uint,\n }\n \n-pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: RS)\n-    -> @mut binding_rscope {\n-    let base = @self as @region_scope;\n-    @mut binding_rscope { base: base, anon_bindings: 0 }\n+pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: &RS)\n+    -> binding_rscope {\n+    let base = @(copy *self) as @region_scope;\n+    binding_rscope { base: base, anon_bindings: @mut 0 }\n }\n-\n-impl region_scope for @mut binding_rscope {\n-    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        // XXX: Unsafe to work around purity\n-        unsafe {\n-            let idx = self.anon_bindings;\n-            self.anon_bindings += 1;\n-            result::Ok(ty::re_bound(ty::br_anon(idx)))\n-        }\n+impl region_scope for binding_rscope {\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        let idx = *self.anon_bindings;\n+        *self.anon_bindings += 1;\n+        result::Ok(ty::re_bound(ty::br_anon(idx)))\n     }\n-    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n+    fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    pure fn named_region(&self, span: span, id: ast::ident)\n-                      -> Result<ty::Region, ~str> {\n+    fn named_region(&self,\n+                    span: span,\n+                    id: ast::ident) -> Result<ty::Region, ~str>\n+    {\n         do self.base.named_region(span, id).chain_err |_e| {\n             result::Ok(ty::re_bound(ty::br_named(id)))\n         }"}, {"sha": "484fff1f9deb25d249eba5de4517dcac91b17ae3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -1017,6 +1017,15 @@ pub enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n+impl self_ty_ {\n+    fn is_borrowed(&self) -> bool {\n+        match *self {\n+            sty_region(_) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n pub type self_ty = spanned<self_ty_>;\n \n #[auto_encode]"}, {"sha": "735344e43be891a5e34cf910c329589c4697b3e2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -30,7 +30,6 @@ use print::pprust;\n use core::char;\n use core::dvec::DVec;\n use core::io;\n-use core::option;\n use core::str;\n use core::u64;\n use core::vec;"}, {"sha": "c8384c188310e5264f87826056253f424f080c57", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     let x: @Map<~str, ~str> = @LinearMap::new::<~str, ~str>() as\n         Map::<~str, ~str>;\n     let y: @Map<uint, ~str> = @x;\n-    //~^ ERROR mismatched types: expected `@core::container::Map/&<uint,~str>`\n+    //~^ ERROR mismatched types: expected `@core::container::Map<uint,~str>`\n }"}, {"sha": "588db79a6c5e630e047a7705319e3c0c205338d3", "filename": "src/test/run-pass/regions-parameterization-self-types-issue-5224.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Ftest%2Frun-pass%2Fregions-parameterization-self-types-issue-5224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32/src%2Ftest%2Frun-pass%2Fregions-parameterization-self-types-issue-5224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-parameterization-self-types-issue-5224.rs?ref=cbfd88a4863ff88bdfc55f0b05dded82f0bfeb32", "patch": "@@ -0,0 +1,28 @@\n+// Test how region-parameterization inference\n+// interacts with explicit self types.\n+//\n+// Issue #5224.\n+\n+trait Getter {\n+    // This trait does not need to be\n+    // region-parameterized, because 'self\n+    // is bound in the self type:\n+    fn get(&self) -> &'self int;\n+}\n+\n+struct Foo {\n+    field: int\n+}\n+\n+impl Getter for Foo {\n+    fn get(&self) -> &'self int { &self.field }\n+}\n+\n+fn get_int<G: Getter>(g: &G) -> int {\n+    *g.get()\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 22 };\n+    assert get_int(&foo) == 22;\n+}"}]}