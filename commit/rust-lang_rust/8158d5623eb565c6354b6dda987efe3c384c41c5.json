{"sha": "8158d5623eb565c6354b6dda987efe3c384c41c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNThkNTYyM2ViNTY1YzYzNTRiNmRkYTk4N2VmZTNjMzg0YzQxYzU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-16T17:07:30Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-09-09T12:58:02Z"}, "message": "BTreeMap: avoid aliasing by avoiding slices", "tree": {"sha": "fd03f54820ce3815d7a0eda741331027d25b1612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd03f54820ce3815d7a0eda741331027d25b1612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8158d5623eb565c6354b6dda987efe3c384c41c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8158d5623eb565c6354b6dda987efe3c384c41c5", "html_url": "https://github.com/rust-lang/rust/commit/8158d5623eb565c6354b6dda987efe3c384c41c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8158d5623eb565c6354b6dda987efe3c384c41c5/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7889373730343f9f7cebc5d649907a3003692280", "url": "https://api.github.com/repos/rust-lang/rust/commits/7889373730343f9f7cebc5d649907a3003692280", "html_url": "https://github.com/rust-lang/rust/commit/7889373730343f9f7cebc5d649907a3003692280"}], "stats": {"total": 371, "additions": 204, "deletions": 167}, "files": [{"sha": "674cdaaa012d9e637d87824f285a3c77a05a35f7", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=8158d5623eb565c6354b6dda987efe3c384c41c5", "patch": "@@ -2796,8 +2796,8 @@ enum UnderflowResult<'a, K, V> {\n     Stole(bool),\n }\n \n-fn handle_underfull_node<K, V>(\n-    node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n+fn handle_underfull_node<'a, K: 'a, V: 'a>(\n+    node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n     let parent = match node.ascend() {\n         Ok(parent) => parent,"}, {"sha": "af5cf7d7d875c39a6ca46795383bb0298c6f58c9", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=8158d5623eb565c6354b6dda987efe3c384c41c5", "patch": "@@ -77,7 +77,8 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n                     let min_len = if is_root { 0 } else { node::MIN_LEN };\n                     assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n \n-                    for &key in node.keys() {\n+                    for idx in 0..node.len() {\n+                        let key = *unsafe { node.key_at(idx) };\n                         checker.is_ascending(key);\n                     }\n                     leaf_length += node.len();\n@@ -120,7 +121,13 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n                 Position::Leaf(leaf) => {\n                     let depth = root_node.height();\n                     let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}{:?}\", indent, leaf.keys())\n+                    result += &format!(\"\\n{}\", indent);\n+                    for idx in 0..leaf.len() {\n+                        if idx > 0 {\n+                            result += \", \";\n+                        }\n+                        result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n+                    }\n                 }\n                 Position::Internal(_) => {}\n                 Position::InternalKV(kv) => {\n@@ -432,7 +439,6 @@ fn test_iter_mut_mutation() {\n }\n \n #[test]\n-#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_values_mut() {\n     let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n     test_all_refs(&mut 13, a.values_mut());\n@@ -455,7 +461,6 @@ fn test_values_mut_mutation() {\n }\n \n #[test]\n-#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_iter_entering_root_twice() {\n     let mut map: BTreeMap<_, _> = (0..2).map(|i| (i, i)).collect();\n     let mut it = map.iter_mut();\n@@ -471,7 +476,6 @@ fn test_iter_entering_root_twice() {\n }\n \n #[test]\n-#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_iter_descending_to_same_node_twice() {\n     let mut map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)).collect();\n     let mut it = map.iter_mut();\n@@ -515,7 +519,6 @@ fn test_iter_mixed() {\n }\n \n #[test]\n-#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_iter_min_max() {\n     let mut a = BTreeMap::new();\n     assert_eq!(a.iter().min(), None);"}, {"sha": "69f7ef57218df1edf4598eec883ff96ba9daae1f", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=8158d5623eb565c6354b6dda987efe3c384c41c5", "patch": "@@ -366,7 +366,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns references to the\n     /// key and value in between.\n-    /// The returned references might be invalidated when the updated handle is used again.\n     ///\n     /// # Safety\n     /// There must be another KV in the direction travelled.\n@@ -376,14 +375,12 @@ impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::E\n             let kv = unsafe { unwrap_unchecked(kv.ok()) };\n             (unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)\n         });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_valmut`, so we have to do this last.\n+        // Doing this last is faster, according to benchmarks.\n         kv.into_kv_valmut()\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n     /// key and value in between.\n-    /// The returned references might be invalidated when the updated handle is used again.\n     ///\n     /// # Safety\n     /// There must be another KV in the direction travelled.\n@@ -393,8 +390,7 @@ impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::E\n             let kv = unsafe { unwrap_unchecked(kv.ok()) };\n             (unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)\n         });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_valmut`, so we have to do this last.\n+        // Doing this last is faster, according to benchmarks.\n         kv.into_kv_valmut()\n     }\n }"}, {"sha": "f9de88e4c13c859210c19210703384f062ef49ab", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 187, "deletions": 150, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=8158d5623eb565c6354b6dda987efe3c384c41c5", "patch": "@@ -244,9 +244,7 @@ impl<K, V> Root<K, V> {\n             )\n         };\n         self.height -= 1;\n-        unsafe {\n-            (*self.node_as_mut().as_leaf_mut()).parent = ptr::null();\n-        }\n+        self.node_as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n             Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n@@ -298,12 +296,27 @@ unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMu\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n-    fn as_internal(&self) -> &InternalNode<K, V> {\n-        unsafe { &*(self.node.as_ptr() as *mut InternalNode<K, V>) }\n+    /// Exposes the data of an internal node for reading.\n+    ///\n+    /// Returns a raw ptr to avoid invalidating other references to this node,\n+    /// which is possible when BorrowType is marker::ValMut.\n+    fn as_internal_ptr(&self) -> *const InternalNode<K, V> {\n+        self.node.as_ptr() as *const InternalNode<K, V>\n+    }\n+}\n+\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Exposes the data of an internal node for reading,\n+    /// when we know we have exclusive access.\n+    fn as_internal(&mut self) -> &InternalNode<K, V> {\n+        unsafe { &*self.as_internal_ptr() }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Exposes the data of an internal node for writing.\n+    ///\n+    /// We don't need to return a raw ptr because we have unique access to the entire node.\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe { &mut *(self.node.as_ptr() as *mut InternalNode<K, V>) }\n     }\n@@ -316,9 +329,9 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Note that, despite being safe, calling this function can have the side effect\n     /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n-        // Crucially, we only access the `len` field here. There might be outstanding mutable references\n-        // to keys/values that we must not invalidate.\n-        unsafe { (*self.as_leaf()).len as usize }\n+        // Crucially, we only access the `len` field here. If BorrowType is marker::ValMut,\n+        // there might be outstanding mutable references to values that we must not invalidate.\n+        unsafe { (*self.as_leaf_ptr()).len as usize }\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -337,23 +350,29 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n     ///\n-    /// Returns a raw ptr to avoid invalidating other references to this node\n-    /// (such as during iteration).\n-    fn as_leaf(&self) -> *const LeafNode<K, V> {\n+    /// Returns a raw ptr to avoid invalidating other references to this node,\n+    /// which is possible when BorrowType is marker::ValMut.\n+    fn as_leaf_ptr(&self) -> *const LeafNode<K, V> {\n         // The node must be valid for at least the LeafNode portion.\n         // This is not a reference in the NodeRef type because we don't know if\n         // it should be unique or shared.\n         self.node.as_ptr()\n     }\n \n-    /// Borrows a view into the keys stored in the node.\n-    pub fn keys(&self) -> &[K] {\n-        self.reborrow().into_key_slice()\n+    /// Borrows a reference to one of the keys stored in the node.\n+    ///\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    pub unsafe fn key_at(&self, idx: usize) -> &K {\n+        unsafe { self.reborrow().into_key_at(idx) }\n     }\n \n-    /// Borrows a view into the values stored in the node.\n-    fn vals(&self) -> &[V] {\n-        self.reborrow().into_val_slice()\n+    /// Borrows a reference to one of the values stored in the node.\n+    ///\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn val_at(&self, idx: usize) -> &V {\n+        unsafe { self.reborrow().into_val_at(idx) }\n     }\n \n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n@@ -366,7 +385,9 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn ascend(\n         self,\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n-        let parent_as_leaf = unsafe { (*self.as_leaf()).parent as *const LeafNode<K, V> };\n+        // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,\n+        // there might be outstanding mutable references to values that we must not invalidate.\n+        let parent_as_leaf = unsafe { (*self.as_leaf_ptr()).parent as *const LeafNode<K, V> };\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -375,7 +396,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData,\n                 },\n-                idx: unsafe { usize::from(*(*self.as_leaf()).parent_idx.as_ptr()) },\n+                idx: unsafe { usize::from(*(*self.as_leaf_ptr()).parent_idx.as_ptr()) },\n                 _marker: PhantomData,\n             })\n         } else {\n@@ -407,6 +428,15 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n }\n \n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n+    /// Exposes the data of a leaf node for reading in an immutable tree.\n+    fn into_leaf(self) -> &'a LeafNode<K, V> {\n+        // SAFETY: we can access the entire node freely and do no need raw pointers,\n+        // because there can be no mutable references to this Immut tree.\n+        unsafe { &(*self.as_leaf_ptr()) }\n+    }\n+}\n+\n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n@@ -457,9 +487,9 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n     ///\n-    /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n-    fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n-        self.node.as_ptr()\n+    /// We don't need to return a raw ptr because we have unique access to the entire node.\n+    fn as_leaf_mut(&mut self) -> &'a mut LeafNode<K, V> {\n+        unsafe { &mut (*self.node.as_ptr()) }\n     }\n \n     fn keys_mut(&mut self) -> &mut [K] {\n@@ -478,16 +508,16 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    fn into_key_slice(self) -> &'a [K] {\n-        unsafe {\n-            slice::from_raw_parts(MaybeUninit::slice_as_ptr(&(*self.as_leaf()).keys), self.len())\n-        }\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn into_key_at(self, idx: usize) -> &'a K {\n+        unsafe { self.into_leaf().keys.get_unchecked(idx).assume_init_ref() }\n     }\n \n-    fn into_val_slice(self) -> &'a [V] {\n-        unsafe {\n-            slice::from_raw_parts(MaybeUninit::slice_as_ptr(&(*self.as_leaf()).vals), self.len())\n-        }\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn into_val_at(self, idx: usize) -> &'a V {\n+        unsafe { self.into_leaf().vals.get_unchecked(idx).assume_init_ref() }\n     }\n }\n \n@@ -502,7 +532,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: The keys of a node must always be initialized up to length.\n         unsafe {\n             slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut (*self.as_leaf_mut()).keys),\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n                 self.len(),\n             )\n         }\n@@ -512,48 +542,50 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: The values of a node must always be initialized up to length.\n         unsafe {\n             slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut (*self.as_leaf_mut()).vals),\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n                 self.len(),\n             )\n         }\n     }\n \n-    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        // We cannot use the getters here, because calling the second one\n-        // invalidates the reference returned by the first.\n-        // More precisely, it is the call to `len` that is the culprit,\n-        // because that creates a shared reference to the header, which *can*\n-        // overlap with the keys (and even the values, for ZST keys).\n-        let len = self.len();\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn into_key_mut_at(mut self, idx: usize) -> &'a mut K {\n+        debug_assert!(idx < self.len());\n+\n         let leaf = self.as_leaf_mut();\n-        // SAFETY: The keys and values of a node must always be initialized up to length.\n-        let keys = unsafe {\n-            slice::from_raw_parts_mut(MaybeUninit::slice_as_mut_ptr(&mut (*leaf).keys), len)\n-        };\n-        let vals = unsafe {\n-            slice::from_raw_parts_mut(MaybeUninit::slice_as_mut_ptr(&mut (*leaf).vals), len)\n-        };\n-        (keys, vals)\n+        unsafe { leaf.keys.get_unchecked_mut(idx).assume_init_mut() }\n+    }\n+\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn into_val_mut_at(mut self, idx: usize) -> &'a mut V {\n+        debug_assert!(idx < self.len());\n+\n+        let leaf = self.as_leaf_mut();\n+        unsafe { leaf.vals.get_unchecked_mut(idx).assume_init_mut() }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n-    /// Same as the marker::Mut method, but far more dangerous because ValMut-based iterators:\n-    /// - have front and back handles often refering to the same node, so `self` is not unique;\n-    /// - hand out mutable references to parts of these slices to the public.\n-    fn into_slices_mut(self) -> (&'a [K], &'a mut [V]) {\n-        let len = self.len();\n+impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn into_key_val_mut_at(self, idx: usize) -> (&'a K, &'a mut V) {\n+        // We only create a reference to the one element we are interested in,\n+        // to avoid aliasing with outstanding references to other elements,\n+        // in particular, those returned to the caller in earlier iterations.\n         let leaf = self.node.as_ptr();\n+        // We must coerce to unsized array pointers because of Rust issue #74679.\n+        let keys: *const [_] = unsafe { &raw const (*leaf).keys };\n+        let vals: *mut [_] = unsafe { &raw mut (*leaf).vals };\n         // SAFETY: The keys and values of a node must always be initialized up to length.\n-        let keys = unsafe { slice::from_raw_parts(MaybeUninit::slice_as_ptr(&(*leaf).keys), len) };\n-        let vals = unsafe {\n-            slice::from_raw_parts_mut(MaybeUninit::slice_as_mut_ptr(&mut (*leaf).vals), len)\n-        };\n-        (keys, vals)\n+        let key = unsafe { (&*keys.get_unchecked(idx)).assume_init_ref() };\n+        let val = unsafe { (&mut *vals.get_unchecked_mut(idx)).assume_init_mut() };\n+        (key, val)\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n@@ -563,9 +595,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-\n-            (*self.as_leaf_mut()).len += 1;\n         }\n+        self.as_leaf_mut().len += 1;\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n@@ -575,13 +606,29 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n             slice_insert(self.vals_mut(), 0, val);\n-\n-            (*self.as_leaf_mut()).len += 1;\n         }\n+        self.as_leaf_mut().len += 1;\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// # Safety\n+    /// 'first' and 'after_last' must be in range.\n+    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+        debug_assert!(first <= self.len());\n+        debug_assert!(after_last <= self.len() + 1);\n+        for i in first..after_last {\n+            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n+        }\n+    }\n+\n+    fn correct_all_childrens_parent_links(&mut self) {\n+        let len = self.len();\n+        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Adds a key/value pair and an edge to go to the right of that pair to\n     /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n@@ -595,26 +642,12 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n             self.as_internal_mut().edges.get_unchecked_mut(idx + 1).write(edge.node);\n \n-            (*self.as_leaf_mut()).len += 1;\n+            self.as_leaf_mut().len += 1;\n \n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n \n-    // Unsafe because 'first' and 'after_last' must be in range\n-    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n-        debug_assert!(first <= self.len());\n-        debug_assert!(after_last <= self.len() + 1);\n-        for i in first..after_last {\n-            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n-        }\n-    }\n-\n-    fn correct_all_childrens_parent_links(&mut self) {\n-        let len = self.len();\n-        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n-    }\n-\n     /// Adds a key/value pair and an edge to go to the left of that pair to\n     /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n@@ -632,15 +665,15 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n                 0,\n                 edge.node,\n             );\n+        }\n \n-            (*self.as_leaf_mut()).len += 1;\n+        self.as_leaf_mut().len += 1;\n \n-            self.correct_all_childrens_parent_links();\n-        }\n+        self.correct_all_childrens_parent_links();\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node and returns the pair.\n     /// If this is an internal node, also removes the edge that was to the right\n     /// of that pair and returns the orphaned node that this edge owned with its\n@@ -651,20 +684,20 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let idx = self.len() - 1;\n \n         unsafe {\n-            let key = ptr::read(self.keys().get_unchecked(idx));\n-            let val = ptr::read(self.vals().get_unchecked(idx));\n+            let key = ptr::read(self.key_at(idx));\n+            let val = ptr::read(self.val_at(idx));\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n-                ForceResult::Internal(internal) => {\n+                ForceResult::Internal(mut internal) => {\n                     let edge =\n                         ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    (*new_root.node_as_mut().as_leaf_mut()).parent = ptr::null();\n+                    new_root.node_as_mut().as_leaf_mut().parent = ptr::null();\n                     Some(new_root)\n                 }\n             };\n \n-            (*self.as_leaf_mut()).len -= 1;\n+            self.as_leaf_mut().len -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -691,7 +724,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    (*new_root.node_as_mut().as_leaf_mut()).parent = ptr::null();\n+                    new_root.node_as_mut().as_leaf_mut().parent = ptr::null();\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -701,7 +734,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n             };\n \n-            (*self.as_leaf_mut()).len -= 1;\n+            self.as_leaf_mut().len -= 1;\n \n             (key, val, edge)\n         }\n@@ -883,7 +916,7 @@ fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n     }\n }\n \n-impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n     /// Helps implementations of `insert_fit` for a particular `NodeType`,\n     /// by taking care of leaf data.\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n@@ -897,12 +930,12 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n             slice_insert(self.node.keys_mut(), self.idx, key);\n             slice_insert(self.node.vals_mut(), self.idx, val);\n \n-            (*self.node.as_leaf_mut()).len += 1;\n+            self.node.as_leaf_mut().len += 1;\n         }\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n@@ -914,7 +947,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n@@ -952,12 +985,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n         let mut child = self.descend();\n-        unsafe {\n-            (*child.as_leaf_mut()).parent = ptr;\n-            (*child.as_leaf_mut()).parent_idx.write(idx);\n-        }\n+        child.as_leaf_mut().parent = ptr;\n+        child.as_leaf_mut().parent_idx.write(idx);\n     }\n+}\n \n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n@@ -1020,7 +1053,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     }\n }\n \n-impl<'a, K: 'a, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room, and tries to\n     /// insert the split off portion into the parent node recursively, until the root is reached.\n@@ -1062,11 +1095,17 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        // We need to use raw pointers to nodes because, if BorrowType is\n+        // marker::ValMut, there might be outstanding mutable references to\n+        // values that we must not invalidate. There's no worry accessing the\n+        // height field because that value is copied. Beware that, once the\n+        // node pointer is dereferenced, we access the edges array with a\n+        // reference (Rust issue #73987) and invalidate any other references\n+        // to or inside the array, should any be around.\n+        let internal_node = self.node.as_internal_ptr();\n         NodeRef {\n             height: self.node.height - 1,\n-            node: unsafe {\n-                (&*self.node.as_internal().edges.get_unchecked(self.idx).as_ptr()).as_ptr()\n-            },\n+            node: unsafe { (&*(*internal_node).edges.get_unchecked(self.idx).as_ptr()).as_ptr() },\n             root: self.node.root,\n             _marker: PhantomData,\n         }\n@@ -1075,71 +1114,66 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        let keys = self.node.into_key_slice();\n-        let vals = self.node.into_val_slice();\n-        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n+        (unsafe { self.node.into_key_at(self.idx) }, unsafe { self.node.into_val_at(self.idx) })\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_key_mut(self) -> &'a mut K {\n-        let keys = self.node.into_key_slice_mut();\n-        unsafe { keys.get_unchecked_mut(self.idx) }\n+        unsafe { self.node.into_key_mut_at(self.idx) }\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n-        let vals = self.node.into_val_slice_mut();\n-        unsafe { vals.get_unchecked_mut(self.idx) }\n+        unsafe { self.node.into_val_mut_at(self.idx) }\n     }\n }\n \n impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {\n-        unsafe {\n-            let (keys, vals) = self.node.into_slices_mut();\n-            (keys.get_unchecked(self.idx), vals.get_unchecked_mut(self.idx))\n-        }\n+        unsafe { self.node.into_key_val_mut_at(self.idx) }\n     }\n }\n \n-impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n-        unsafe {\n-            let (keys, vals) = self.node.reborrow_mut().into_slices_mut();\n-            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n-        }\n+        // We cannot call into_key_mut_at and into_val_mut_at, because calling the second one\n+        // invalidates the reference returned by the first.\n+        let leaf = self.node.as_leaf_mut();\n+        let key = unsafe { leaf.keys.get_unchecked_mut(self.idx).assume_init_mut() };\n+        let val = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };\n+        (key, val)\n     }\n }\n \n-impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     /// Helps implementations of `split` for a particular `NodeType`,\n     /// by taking care of leaf data.\n     fn leafy_split(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V, usize) {\n         unsafe {\n-            let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n-            let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n+            let k = ptr::read(self.node.key_at(self.idx));\n+            let v = ptr::read(self.node.val_at(self.idx));\n \n             let new_len = self.node.len() - self.idx - 1;\n \n             ptr::copy_nonoverlapping(\n-                self.node.keys().as_ptr().add(self.idx + 1),\n+                self.node.key_at(self.idx + 1),\n                 new_node.keys.as_mut_ptr() as *mut K,\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.vals().as_ptr().add(self.idx + 1),\n+                self.node.val_at(self.idx + 1),\n                 new_node.vals.as_mut_ptr() as *mut V,\n                 new_len,\n             );\n \n-            (*self.node.as_leaf_mut()).len = self.idx as u16;\n+            self.node.as_leaf_mut().len = self.idx as u16;\n             new_node.len = new_len as u16;\n             (k, v, new_len)\n         }\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n     /// - The node is truncated to only contain the key/value pairs to the right of\n@@ -1165,13 +1199,25 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n-            (*self.node.as_leaf_mut()).len -= 1;\n+            self.node.as_leaf_mut().len -= 1;\n             ((k, v), self.left_edge())\n         }\n     }\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// a node to hold the combination of the nodes to the left and right of this handle along\n+    /// with the key/value pair at this handle.\n+    pub fn can_merge(&self) -> bool {\n+        (self.reborrow().left_edge().descend().len()\n+            + self.reborrow().right_edge().descend().len()\n+            + 1)\n+            <= CAPACITY\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n     /// - The node is truncated to only contain the edges and key/value pairs to the\n@@ -1185,9 +1231,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             let (k, v, new_len) = self.leafy_split(&mut new_node.data);\n             let height = self.node.height;\n+            let old_node = &*self.node.as_internal_ptr();\n \n             ptr::copy_nonoverlapping(\n-                self.node.as_internal().edges.as_ptr().add(self.idx + 1),\n+                old_node.edges.as_ptr().add(self.idx + 1),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n@@ -1202,16 +1249,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n-    /// a node to hold the combination of the nodes to the left and right of this handle along\n-    /// with the key/value pair at this handle.\n-    pub fn can_merge(&self) -> bool {\n-        (self.reborrow().left_edge().descend().len()\n-            + self.reborrow().right_edge().descend().len()\n-            + 1)\n-            <= CAPACITY\n-    }\n-\n     /// Combines the node immediately to the left of this handle, the key/value pair pointed\n     /// to by this handle, and the node immediately to the right of this handle into one new\n     /// child of the underlying node, returning an edge referencing that new child.\n@@ -1235,7 +1272,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 slice_remove(self.node.keys_mut(), self.idx),\n             );\n             ptr::copy_nonoverlapping(\n-                right_node.keys().as_ptr(),\n+                right_node.key_at(0),\n                 left_node.keys_mut().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n@@ -1244,7 +1281,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 slice_remove(self.node.vals_mut(), self.idx),\n             );\n             ptr::copy_nonoverlapping(\n-                right_node.vals().as_ptr(),\n+                right_node.val_at(0),\n                 left_node.vals_mut().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n@@ -1253,18 +1290,18 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             for i in self.idx + 1..self.node.len() {\n                 Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n             }\n-            (*self.node.as_leaf_mut()).len -= 1;\n+            self.node.as_leaf_mut().len -= 1;\n \n-            (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n+            left_node.as_leaf_mut().len += right_len as u16 + 1;\n \n             if self.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n                 let mut left_node = left_node.cast_unchecked();\n-                let right_node = right_node.cast_unchecked();\n+                let mut right_node = right_node.cast_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.reborrow().as_internal().edges.as_ptr(),\n-                    left_node.reborrow_mut().as_internal_mut().edges.as_mut_ptr().add(left_len + 1),\n+                    right_node.as_internal().edges.as_ptr(),\n+                    left_node.as_internal_mut().edges.as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n \n@@ -1352,8 +1389,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            (*left_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n-            (*right_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n+            left_node.as_leaf_mut().len -= count as u16;\n+            right_node.as_leaf_mut().len += count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1409,8 +1446,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n \n-            (*left_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n-            (*right_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n+            left_node.as_leaf_mut().len += count as u16;\n+            right_node.as_leaf_mut().len -= count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1451,7 +1488,7 @@ unsafe fn move_edges<K, V>(\n     dest_offset: usize,\n     count: usize,\n ) {\n-    let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n+    let source_ptr = source.as_internal().edges.as_ptr();\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n     unsafe {\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n@@ -1549,8 +1586,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n                 move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-                (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n-                (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n+                left_node.as_leaf_mut().len = left_new_len as u16;\n+                right_node.as_leaf_mut().len = right_new_len as u16;\n \n                 match (left_node.force(), right_node.force()) {\n                     (ForceResult::Internal(left), ForceResult::Internal(right)) => {"}, {"sha": "1526c0673c691c62c6929b6879c0a2c854708580", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=8158d5623eb565c6354b6dda987efe3c384c41c5", "patch": "@@ -68,11 +68,11 @@ where\n     K: Borrow<Q>,\n {\n     // This function is defined over all borrow types (immutable, mutable, owned).\n-    // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n+    // Using `keys_at()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n     let len = node.len();\n-    let keys = node.keys();\n-    for (i, k) in keys.iter().enumerate() {\n+    for i in 0..len {\n+        let k = unsafe { node.key_at(i) };\n         match key.cmp(k.borrow()) {\n             Ordering::Greater => {}\n             Ordering::Equal => return (i, true),"}, {"sha": "48313f9af98e6346b90dd70376f633d76c128c4a", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8158d5623eb565c6354b6dda987efe3c384c41c5/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=8158d5623eb565c6354b6dda987efe3c384c41c5", "patch": "@@ -106,6 +106,7 @@\n #![feature(libc)]\n #![feature(map_first_last)]\n #![feature(map_into_keys_values)]\n+#![feature(maybe_uninit_ref)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(new_uninit)]"}]}