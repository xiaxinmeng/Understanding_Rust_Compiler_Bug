{"sha": "a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "node_id": "C_kwDOAAsO6NoAKGE4NGE4MTE5NDNjM2YxOTg2ZWFmODJiYmVjYzMzMjAxYmM0YWU4Yzk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-16T17:42:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-16T17:42:04Z"}, "message": "Rollup merge of #95908 - compiler-errors:shallow_resolve_ty-inline, r=oli-obk\n\nInline `shallow_resolve_ty` into `ShallowResolver`\n\naddresses fixme I found in infcx", "tree": {"sha": "0e77b75edb2af95d0cddd4bac5921a33003334a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e77b75edb2af95d0cddd4bac5921a33003334a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiWv/sCRBK7hj4Ov3rIwAA1lMIABi6suPHFeI4ykPrjJ2RoIKk\nFC04ysxNdA5MEErA0vV9jRvq5KgzduwIQVi/GSL8Tl+V31eLLtdljavd+UtP24an\nspaecC+4n63bDoORukzc36miVraxCCTsSe2UIsOPFTscXJn1Y2DL+v3lxoB54jmI\nlk237GI87k4AbBL50ozeLalaedg18lleNP0mYJREmxSfO+Lsy9gCmSC70bnSB1Rq\nadaRofGL4sfCN//LGUhE+dnVYE54wXaZdC7PogcTW/ortpDSCA73BWfm6nUtEmGl\nBGks+WqaPuBSRr2M6gIamI/lo8w1tn7iN7sr/9GpYisORvgUG63LY7GKzIiRc6Q=\n=gwUf\n-----END PGP SIGNATURE-----\n", "payload": "tree 0e77b75edb2af95d0cddd4bac5921a33003334a9\nparent 1dc672a766832287f2f998a1cdde76ea74cd480d\nparent edeb826d0a6c157f389f94b8525794b52362e174\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650130924 +0200\ncommitter GitHub <noreply@github.com> 1650130924 +0200\n\nRollup merge of #95908 - compiler-errors:shallow_resolve_ty-inline, r=oli-obk\n\nInline `shallow_resolve_ty` into `ShallowResolver`\n\naddresses fixme I found in infcx\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "html_url": "https://github.com/rust-lang/rust/commit/a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a84a811943c3f1986eaf82bbecc33201bc4ae8c9/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc672a766832287f2f998a1cdde76ea74cd480d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc672a766832287f2f998a1cdde76ea74cd480d", "html_url": "https://github.com/rust-lang/rust/commit/1dc672a766832287f2f998a1cdde76ea74cd480d"}, {"sha": "edeb826d0a6c157f389f94b8525794b52362e174", "url": "https://api.github.com/repos/rust-lang/rust/commits/edeb826d0a6c157f389f94b8525794b52362e174", "html_url": "https://github.com/rust-lang/rust/commit/edeb826d0a6c157f389f94b8525794b52362e174"}], "stats": {"total": 83, "additions": 39, "deletions": 44}, "files": [{"sha": "6ec929f98950e6a64901cb84620a2f7dd41b88dd", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a84a811943c3f1986eaf82bbecc33201bc4ae8c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84a811943c3f1986eaf82bbecc33201bc4ae8c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "patch": "@@ -1659,49 +1659,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.const_eval_resolve(param_env_erased, unevaluated, span)\n     }\n \n-    /// If `typ` is a type variable of some kind, resolve it one level\n-    /// (but do not resolve types found in the result). If `typ` is\n-    /// not a type variable, just return it unmodified.\n-    // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n-    fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match *typ.kind() {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                //\n-                // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.inner`.\n-                let known = self.inner.borrow_mut().type_variables().probe(v).known();\n-                known.map_or(typ, |t| self.shallow_resolve_ty(t))\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self\n-                .inner\n-                .borrow_mut()\n-                .int_unification_table()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self\n-                .inner\n-                .borrow_mut()\n-                .float_unification_table()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:\n     ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)\n     ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)\n@@ -1831,8 +1788,46 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    /// If `ty` is a type variable of some kind, resolve it one level\n+    /// (but do not resolve types found in the result). If `typ` is\n+    /// not a type variable, just return it unmodified.\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.shallow_resolve_ty(ty)\n+        match *ty.kind() {\n+            ty::Infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifying to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n+                known.map_or(ty, |t| self.fold_ty(t))\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .int_unification_table()\n+                .probe_value(v)\n+                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+\n+            ty::Infer(ty::FloatVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .float_unification_table()\n+                .probe_value(v)\n+                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+\n+            _ => ty,\n+        }\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {"}]}