{"sha": "589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OWVlNjVmZDRlYTMxMWJlZWI0MmViZGM1ZTZhNGI2OTYwYmQzMDM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-14T17:32:41Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-14T21:53:18Z"}, "message": "Add rw_arc.downgrade() + std and cfail tests. Tons of region FIXMEs... (cf #2282, #3154)", "tree": {"sha": "c4a96d2a6e076864ab160f9469d9fd18c872c422", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4a96d2a6e076864ab160f9469d9fd18c872c422"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "html_url": "https://github.com/rust-lang/rust/commit/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1779ab4754d71859306e11d9893d071c35ce691f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1779ab4754d71859306e11d9893d071c35ce691f", "html_url": "https://github.com/rust-lang/rust/commit/1779ab4754d71859306e11d9893d071c35ce691f"}], "stats": {"total": 393, "additions": 365, "deletions": 28}, "files": [{"sha": "b7b63af0afbb8d4dad8ec2d2e2a210d8c96e5370", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -152,7 +152,7 @@ fn to_uint<T>(thing: &T) -> uint unsafe {\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-fn ref_eq<T>(thing: &T, other: &T) -> bool {\n+fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n "}, {"sha": "f945cb8ad1d8bfb60ea228d61f19c176cf056802", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -1,6 +1,7 @@\n //! Unsafe operations\n \n export reinterpret_cast, forget, bump_box_refcount, transmute;\n+export transmute_mut, transmute_immut, transmute_region, transmute_mut_region;\n \n export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n export get_shared_mutable_state, get_shared_immutable_state;\n@@ -53,6 +54,17 @@ unsafe fn transmute<L, G>(-thing: L) -> G {\n     return newthing;\n }\n \n+/// Coerce an immutable reference to be mutable.\n+unsafe fn transmute_mut<T>(+ptr: &T) -> &mut T { transmute(ptr) }\n+/// Coerce a mutable reference to be immutable.\n+unsafe fn transmute_immut<T>(+ptr: &mut T) -> &T { transmute(ptr) }\n+/// Coerce a borrowed pointer to have an arbitrary associated region.\n+unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(ptr) }\n+/// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n+unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n+    transmute(ptr)\n+}\n+\n /****************************************************************************\n  * Shared state & exclusive ARC\n  ****************************************************************************/"}, {"sha": "8ab74444f6f10c2b00607abc56c8275546e42c27", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 223, "deletions": 8, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -10,7 +10,7 @@ import sync;\n import sync::{mutex, rwlock};\n \n export arc, clone, get;\n-export condvar, mutex_arc, rw_arc;\n+export condvar, mutex_arc, rw_arc, rw_write_mode, rw_read_mode;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n struct condvar { is_mutex: bool; failed: &mut bool; cond: &sync::condvar; }\n@@ -136,10 +136,11 @@ impl<T: send> &mutex_arc<T> {\n                 &condvar { is_mutex: true, failed: &mut state.failed,\n                            cond: cond })\n             */\n-            // XXX: Working around two seeming region bugs here\n-            let fref = unsafe { unsafe::reinterpret_cast(&mut state.failed) };\n+            // FIXME(#2282) region variance\n+            let fref =\n+                unsafe { unsafe::transmute_mut_region(&mut state.failed) };\n             let cvar = condvar { is_mutex: true, failed: fref, cond: cond };\n-            blk(&mut state.data, unsafe { unsafe::reinterpret_cast(&cvar) } )\n+            blk(&mut state.data, unsafe { unsafe::transmute_region(&cvar) } )\n         }\n     }\n }\n@@ -227,10 +228,12 @@ impl<T: const send> &rw_arc<T> {\n                 &condvar { is_mutex: false, failed: &mut state.failed,\n                            cond: cond })\n             */\n-            // XXX: Working around two seeming region bugs here\n-            let fref = unsafe { unsafe::reinterpret_cast(&mut state.failed) };\n+            // FIXME(#2282): Need region variance to use the commented-out\n+            // code above instead of this casting mess\n+            let fref =\n+                unsafe { unsafe::transmute_mut_region(&mut state.failed) };\n             let cvar = condvar { is_mutex: false, failed: fref, cond: cond };\n-            blk(&mut state.data, unsafe { unsafe::reinterpret_cast(&cvar) } )\n+            blk(&mut state.data, unsafe { unsafe::transmute_region(&cvar) } )\n         }\n     }\n     /**\n@@ -249,6 +252,52 @@ impl<T: const send> &rw_arc<T> {\n             blk(&state.data)\n         }\n     }\n+\n+    /**\n+     * As write(), but with the ability to atomically 'downgrade' the lock.\n+     * See sync::rwlock.write_downgrade(). The rw_write_mode token must be\n+     * used to obtain the &mut T, and can be transformed into a rw_read_mode\n+     * token by calling downgrade(), after which a &T can be obtained instead.\n+     * ~~~\n+     * do arc.write_downgrade |write_mode| {\n+     *     do (&write_mode).write_cond |state, condvar| {\n+     *         ... exclusive access with mutable state ...\n+     *     }\n+     *     let read_mode = arc.downgrade(write_mode);\n+     *     do (&read_mode).read |state| {\n+     *         ... shared access with immutable state ...\n+     *     }\n+     * }\n+     * ~~~\n+     */\n+    fn write_downgrade<U>(blk: fn(+rw_write_mode<T>) -> U) -> U {\n+        let state = unsafe { get_shared_mutable_state(&self.x) };\n+        do borrow_rwlock(state).write_downgrade |write_mode| {\n+            check_poison(false, state.failed);\n+            // FIXME(#2282) need region variance to avoid having to cast here\n+            let (data,failed) =\n+                unsafe { (unsafe::transmute_mut_region(&mut state.data),\n+                          unsafe::transmute_mut_region(&mut state.failed)) };\n+            blk(rw_write_mode((data, write_mode, poison_on_fail(failed))))\n+        }\n+    }\n+\n+    /// To be called inside of the write_downgrade block.\n+    fn downgrade(+token: rw_write_mode<T>) -> rw_read_mode<T> {\n+        // The rwlock should assert that the token belongs to us for us.\n+        let state = unsafe { get_shared_immutable_state(&self.x) };\n+        let rw_write_mode((data, t, _poison)) = token;\n+        // Let readers in\n+        let new_token = (&state.lock).downgrade(t);\n+        // Whatever region the input reference had, it will be safe to use\n+        // the same region for the output reference. (The only 'unsafe' part\n+        // of this cast is removing the mutability.)\n+        let new_data = unsafe { unsafe::transmute_immut(data) };\n+        // Downgrade ensured the token belonged to us. Just a sanity check.\n+        assert ptr::ref_eq(&state.data, new_data);\n+        // Produce new token\n+        rw_read_mode((new_data, new_token))\n+    }\n }\n \n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n@@ -258,6 +307,58 @@ fn borrow_rwlock<T: const send>(state: &mut rw_arc_inner<T>) -> &rwlock {\n     unsafe { unsafe::reinterpret_cast(&state.lock) }\n }\n \n+// FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n+\n+/// The \"write permission\" token used for rw_arc.write_downgrade().\n+enum rw_write_mode<T: const send> =\n+    (&mut T, sync::rwlock_write_mode, poison_on_fail);\n+/// The \"read permission\" token used for rw_arc.write_downgrade().\n+enum rw_read_mode<T:const send> = (&T, sync::rwlock_read_mode);\n+\n+impl<T: const send> &rw_write_mode<T> {\n+    /// Access the pre-downgrade rw_arc in write mode.\n+    fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n+        match *self {\n+            rw_write_mode((data, ref token, _)) => {\n+                // FIXME(#2282) cast to avoid region invariance\n+                let mode = unsafe { unsafe::transmute_region(token) };\n+                do mode.write {\n+                    blk(data)\n+                }\n+            }\n+        }\n+    }\n+    /// Access the pre-downgrade rw_arc in write mode with a condvar.\n+    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n+        match *self {\n+            rw_write_mode((data, ref token, ref poison)) => {\n+                // FIXME(#2282) cast to avoid region invariance\n+                let mode = unsafe { unsafe::transmute_region(token) };\n+                do mode.write_cond |cond| {\n+                    let cvar = condvar {\n+                        is_mutex: false, failed: poison.failed,\n+                        cond: unsafe { unsafe::reinterpret_cast(cond) } };\n+                    // FIXME(#2282) region variance would avoid having to cast\n+                    blk(data, &cvar)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: const send> &rw_read_mode<T> {\n+    /// Access the post-downgrade rwlock in read mode.\n+    fn read<U>(blk: fn(x: &T) -> U) -> U {\n+        match *self {\n+            rw_read_mode((data, ref token)) => {\n+                // FIXME(#2282) cast to avoid region invariance\n+                let mode = unsafe { unsafe::transmute_region(token) };\n+                do mode.read { blk(data) }\n+            }\n+        }\n+    }\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -374,6 +475,23 @@ mod tests {\n             assert *one == 1;\n         }\n     }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_rw_arc_poison_dw() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.write_downgrade |write_mode| {\n+                // FIXME(#2282)\n+                let mode = unsafe { unsafe::transmute_region(&write_mode) };\n+                do mode.write |one| {\n+                    assert *one == 2;\n+                }\n+            }\n+        };\n+        do arc.write |one| {\n+            assert *one == 1;\n+        }\n+    }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = ~rw_arc(1);\n@@ -400,7 +518,24 @@ mod tests {\n             assert *one == 1;\n         }\n     }\n-\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rw_arc_no_poison_dr() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.write_downgrade |write_mode| {\n+                let read_mode = arc2.downgrade(write_mode);\n+                // FIXME(#2282)\n+                let mode = unsafe { unsafe::transmute_region(&read_mode) };\n+                do mode.read |one| {\n+                    assert *one == 2;\n+                }\n+            }\n+        };\n+        do arc.write |one| {\n+            assert *one == 1;\n+        }\n+    }\n     #[test]\n     fn test_rw_arc() {\n         let arc = ~rw_arc(0);\n@@ -434,4 +569,84 @@ mod tests {\n         p.recv();\n         do arc.read |num| { assert *num == 10; }\n     }\n+    #[test]\n+    fn test_rw_downgrade() {\n+        // (1) A downgrader gets in write mode and does cond.wait.\n+        // (2) A writer gets in write mode, sets state to 42, and does signal.\n+        // (3) Downgrader wakes, sets state to 31337.\n+        // (4) tells writer and all other readers to contend as it downgrades.\n+        // (5) Writer attempts to set state back to 42, while downgraded task\n+        //     and all reader tasks assert that it's 31337.\n+        let arc = ~rw_arc(0);\n+\n+        // Reader tasks\n+        let mut reader_convos = ~[];\n+        for 10.times {\n+            let ((rc1,rp1),(rc2,rp2)) = (pipes::stream(),pipes::stream());\n+            vec::push(reader_convos, (rc1,rp2));\n+            let arcn = ~arc.clone();\n+            do task::spawn {\n+                rp1.recv(); // wait for downgrader to give go-ahead\n+                do arcn.read |state| {\n+                    assert *state == 31337;\n+                    rc2.send(());\n+                }\n+            }\n+        }\n+\n+        // Writer task\n+        let arc2 = ~arc.clone();\n+        let ((wc1,wp1),(wc2,wp2)) = (pipes::stream(),pipes::stream());\n+        do task::spawn {\n+            wp1.recv();\n+            do arc2.write_cond |state, cond| {\n+                assert *state == 0;\n+                *state = 42;\n+                cond.signal();\n+            }\n+            wp1.recv();\n+            do arc2.write |state| {\n+                // This shouldn't happen until after the downgrade read\n+                // section, and all other readers, finish.\n+                assert *state == 31337;\n+                *state = 42;\n+            }\n+            wc2.send(());\n+        }\n+\n+        // Downgrader (us)\n+        do arc.write_downgrade |write_mode| {\n+            // FIXME(#2282)\n+            let mode = unsafe { unsafe::transmute_region(&write_mode) };\n+            do mode.write_cond |state, cond| {\n+                wc1.send(()); // send to another writer who will wake us up\n+                while *state == 0 {\n+                    cond.wait();\n+                }\n+                assert *state == 42;\n+                *state = 31337;\n+                // send to other readers\n+                for vec::each(reader_convos) |x| {\n+                    match x {\n+                        (rc, _) => rc.send(()),\n+                    }\n+                }\n+            }\n+            let read_mode = arc.downgrade(write_mode);\n+            // FIXME(#2282)\n+            let mode = unsafe { unsafe::transmute_region(&read_mode) };\n+            do mode.read |state| {\n+                // complete handshake with other readers\n+                for vec::each(reader_convos) |x| {\n+                    match x {\n+                        (_, rp) => rp.recv(),\n+                    }\n+                }\n+                wc1.send(()); // tell writer to try again\n+                assert *state == 31337;\n+            }\n+        }\n+\n+        wp2.recv(); // complete handshake with writer\n+    }\n }"}, {"sha": "b2dd55fdcad9d102b03796a1139161e3a0517daf", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -5,7 +5,7 @@\n  * in std.\n  */\n \n-export condvar, semaphore, mutex, rwlock;\n+export condvar, semaphore, mutex, rwlock, rwlock_write_mode, rwlock_read_mode;\n \n // FIXME (#3119) This shouldn't be a thing exported from core.\n import unsafe::{Exclusive, exclusive};\n@@ -387,16 +387,17 @@ impl &rwlock {\n      * the meantime (such as unlocking and then re-locking as a reader would\n      * do). The block takes a \"write mode token\" argument, which can be\n      * transformed into a \"read mode token\" by calling downgrade(). Example:\n-     *\n-     *     do lock.write_downgrade |write_mode| {\n-     *         do (&write_mode).write_cond |condvar| {\n-     *             ... exclusive access ...\n-     *         }\n-     *         let read_mode = lock.downgrade(write_mode);\n-     *         do (&read_mode).read {\n-     *             ... shared access ...\n-     *         }\n+     * ~~~\n+     * do lock.write_downgrade |write_mode| {\n+     *     do (&write_mode).write_cond |condvar| {\n+     *         ... exclusive access ...\n      *     }\n+     *     let read_mode = lock.downgrade(write_mode);\n+     *     do (&read_mode).read {\n+     *         ... shared access ...\n+     *     }\n+     * }\n+     * ~~~\n      */\n     fn write_downgrade<U>(blk: fn(+rwlock_write_mode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n@@ -413,6 +414,7 @@ impl &rwlock {\n         blk(rwlock_write_mode { lock: self })\n     }\n \n+    /// To be called inside of the write_downgrade block.\n     fn downgrade(+token: rwlock_write_mode) -> rwlock_read_mode {\n         if !ptr::ref_eq(self, token.lock) {\n             fail ~\"Can't downgrade() with a different rwlock's write_mode!\";\n@@ -498,16 +500,15 @@ struct rwlock_write_mode { lock: &rwlock; drop { } }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n struct rwlock_read_mode  { priv lock: &rwlock; drop { } }\n \n-// FIXME(#3145) XXX Region invariance forbids \"mode.write(blk)\"\n-impl rwlock_write_mode {\n+impl &rwlock_write_mode {\n     /// Access the pre-downgrade rwlock in write mode.\n     fn write<U>(blk: fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n     fn write_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n         blk(&condvar { sem: &self.lock.access_lock })\n     }\n }\n-impl rwlock_read_mode {\n+impl &rwlock_read_mode {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn() -> U) -> U { blk() }\n }\n@@ -777,9 +778,19 @@ mod tests {\n         match mode {\n             read => x.read(blk),\n             write => x.write(blk),\n-            downgrade => do x.write_downgrade |mode| { mode.write(blk); },\n+            downgrade =>\n+                do x.write_downgrade |mode| {\n+                    // FIXME(#2282)\n+                    let mode = unsafe { unsafe::transmute_region(&mode) };\n+                    mode.write(blk);\n+                },\n             downgrade_read =>\n-                do x.write_downgrade |mode| { x.downgrade(mode).read(blk); },\n+                do x.write_downgrade |mode| {\n+                    let mode = x.downgrade(mode);\n+                    // FIXME(#2282)\n+                    let mode = unsafe { unsafe::transmute_region(&mode) };\n+                    mode.read(blk);\n+                },\n         }\n     }\n     #[cfg(test)]\n@@ -922,7 +933,11 @@ mod tests {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n         fn lock_cond(x: &rwlock, downgrade: bool, blk: fn(c: &condvar)) {\n             if downgrade {\n-                do x.write_downgrade |mode| { mode.write_cond(blk) }\n+                do x.write_downgrade |mode| {\n+                    // FIXME(#2282)\n+                    let mode = unsafe { unsafe::transmute_region(&mode) };\n+                    mode.write_cond(blk)\n+                }\n             } else {\n                 x.write_cond(blk)\n             }\n@@ -1009,9 +1024,8 @@ mod tests {\n         do x.write_downgrade |xwrite| {\n             let mut xopt = some(xwrite);\n             do y.write_downgrade |_ywrite| {\n-                do y.downgrade(option::swap_unwrap(&mut xopt)).read {\n-                    error!(\"oops, y.downgrade(x) should have failed!\");\n-                }\n+                y.downgrade(option::swap_unwrap(&mut xopt));\n+                error!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }\n     }"}, {"sha": "d8b3fd3e8b02578ef60a6d233eb54a921219926c", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_cond |_one, cond| {\n+        y = some(cond);\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "8ba84bf85dc435f92dd54f5334befb4d2f5d1141", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(x.downgrade(write_mode));\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).read |state| { assert *state == 1; }\n+}"}, {"sha": "3584512c28e4d17285bcdae95fc5651528f46bb9", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        do (&write_mode).write_cond |_one, cond| {\n+            y = some(cond);\n+        }\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "e4ecef47476adaf59b403946451c7c5de2c1e09f", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(write_mode);\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).write |state| { assert *state == 1; }\n+}"}, {"sha": "2b76279a4abf8d34bc1a274348e10372a76492e6", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_cond |cond| {\n+        y = some(cond);\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "ac04671ee372ae6a259f5b42a9a2c3ef84d66f3b", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(x.downgrade(write_mode));\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).read { }\n+}"}, {"sha": "7f60342b9994cfdd6cf373024f9500fd7dae16b3", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        do (&write_mode).write_cond |cond| {\n+            y = some(cond);\n+        }\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "f7571d11ac8ad0f884f1778cb2f25a0e244ab7ad", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589ee65fd4ea311beeb42ebdc5e6a4b6960bd303/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=589ee65fd4ea311beeb42ebdc5e6a4b6960bd303", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(write_mode);\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).write { }\n+}"}]}