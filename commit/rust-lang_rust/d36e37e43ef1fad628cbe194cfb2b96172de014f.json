{"sha": "d36e37e43ef1fad628cbe194cfb2b96172de014f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNmUzN2U0M2VmMWZhZDYyOGNiZTE5NGNmYjJiOTYxNzJkZTAxNGY=", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2018-09-27T16:17:00Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2018-10-30T18:09:11Z"}, "message": "Add legacy debuginfo tests\n\nThe enum debuginfo patch includes a legacy mode that is used when\nbuilding against LLVM 5 and LLVM 6.  The main enum debuginfo tests\nhave been updated to rely on the new approach and a new-enough gdb.\nThis patch makes a copy of these tests so that the fallback mode will\ncontinue to be tested.\n\nNote that nil-enum.rs is not copied; it seemed not to provide enough\nvalue to bother.\n\nA new header directive is added, \"ignore-llvm-version\".  I will send a\npatch to update the rustc documentation once this lands.", "tree": {"sha": "61e7789f389b34a26d59444d9a73f2568e1b1e27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61e7789f389b34a26d59444d9a73f2568e1b1e27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d36e37e43ef1fad628cbe194cfb2b96172de014f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d36e37e43ef1fad628cbe194cfb2b96172de014f", "html_url": "https://github.com/rust-lang/rust/commit/d36e37e43ef1fad628cbe194cfb2b96172de014f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d36e37e43ef1fad628cbe194cfb2b96172de014f/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bbb62f849c6b97900751ac0f0cff0d4c9b1328a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbb62f849c6b97900751ac0f0cff0d4c9b1328a", "html_url": "https://github.com/rust-lang/rust/commit/8bbb62f849c6b97900751ac0f0cff0d4c9b1328a"}], "stats": {"total": 1019, "additions": 1019, "deletions": 0}, "files": [{"sha": "a04f7d6dd8aec2a99768ec1b346b8ec105d38b3b", "filename": "src/test/debuginfo/borrowed-enum-legacy.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print *the_a_ref\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n+// gdbr-check:$1 = borrowed_enum_legacy::ABC::TheA{x: 0, y: 8970181431921507452}\n+\n+// gdb-command:print *the_b_ref\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbr-check:$2 = borrowed_enum_legacy::ABC::TheB(0, 286331153, 286331153)\n+\n+// gdb-command:print *univariant_ref\n+// gdbg-check:$3 = {{__0 = 4820353753753434}}\n+// gdbr-check:$3 = borrowed_enum_legacy::Univariant::TheOnlyCase(4820353753753434)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print *the_a_ref\n+// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n+// lldbr-check:(borrowed_enum_legacy::ABC::TheA) *the_a_ref = TheA { borrowed_enum_legacy::ABC::TheA: 0, borrowed_enum_legacy::ABC::TheB: 8970181431921507452 }\n+// lldb-command:print *the_b_ref\n+// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n+// lldbr-check:(borrowed_enum_legacy::ABC::TheB) *the_b_ref = { = 0 = 286331153 = 286331153 }\n+// lldb-command:print *univariant_ref\n+// lldbg-check:[...]$2 = TheOnlyCase(4820353753753434)\n+// lldbr-check:(borrowed_enum_legacy::Univariant) *univariant_ref = { borrowed_enum_legacy::TheOnlyCase = { = 4820353753753434 } }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+    TheA { x: i64, y: i64 },\n+    TheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let the_a = ABC::TheA { x: 0, y: 8970181431921507452 };\n+    let the_a_ref: &ABC = &the_a;\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b = ABC::TheB (0, 286331153, 286331153);\n+    let the_b_ref: &ABC = &the_b;\n+\n+    let univariant = Univariant::TheOnlyCase(4820353753753434);\n+    let univariant_ref: &Univariant = &univariant;\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "092b31b7c30547f0f716815c01ebaa69d4fcd100", "filename": "src/test/debuginfo/generic-enum-with-different-disr-sizes-legacy.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// ignore-lldb: FIXME(#27089)\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+// gdb-command:run\n+\n+// gdb-command:print eight_bytes1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Variant1, __0 = 100}, {RUST$ENUM$DISR = Variant1, __0 = 100}}\n+// gdbr-check:$1 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(100)\n+\n+// gdb-command:print four_bytes1\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Variant1, __0 = 101}, {RUST$ENUM$DISR = Variant1, __0 = 101}}\n+// gdbr-check:$2 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(101)\n+\n+// gdb-command:print two_bytes1\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Variant1, __0 = 102}, {RUST$ENUM$DISR = Variant1, __0 = 102}}\n+// gdbr-check:$3 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(102)\n+\n+// gdb-command:print one_byte1\n+// gdbg-check:$4 = {{RUST$ENUM$DISR = Variant1, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant1, __0 = 65 'A'}}\n+// gdbr-check:$4 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(65)\n+\n+\n+// gdb-command:print eight_bytes2\n+// gdbg-check:$5 = {{RUST$ENUM$DISR = Variant2, __0 = 100}, {RUST$ENUM$DISR = Variant2, __0 = 100}}\n+// gdbr-check:$5 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(100)\n+\n+// gdb-command:print four_bytes2\n+// gdbg-check:$6 = {{RUST$ENUM$DISR = Variant2, __0 = 101}, {RUST$ENUM$DISR = Variant2, __0 = 101}}\n+// gdbr-check:$6 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(101)\n+\n+// gdb-command:print two_bytes2\n+// gdbg-check:$7 = {{RUST$ENUM$DISR = Variant2, __0 = 102}, {RUST$ENUM$DISR = Variant2, __0 = 102}}\n+// gdbr-check:$7 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(102)\n+\n+// gdb-command:print one_byte2\n+// gdbg-check:$8 = {{RUST$ENUM$DISR = Variant2, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant2, __0 = 65 'A'}}\n+// gdbr-check:$8 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(65)\n+\n+// gdb-command:continue\n+\n+// === LLDB TESTS ==================================================================================\n+// lldb-command:run\n+\n+// lldb-command:print eight_bytes1\n+// lldb-check:[...]$0 = Variant1(100)\n+// lldb-command:print four_bytes1\n+// lldb-check:[...]$1 = Variant1(101)\n+// lldb-command:print two_bytes1\n+// lldb-check:[...]$2 = Variant1(102)\n+// lldb-command:print one_byte1\n+// lldb-check:[...]$3 = Variant1('A')\n+\n+// lldb-command:print eight_bytes2\n+// lldb-check:[...]$4 = Variant2(100)\n+// lldb-command:print four_bytes2\n+// lldb-check:[...]$5 = Variant2(101)\n+// lldb-command:print two_bytes2\n+// lldb-check:[...]$6 = Variant2(102)\n+// lldb-command:print one_byte2\n+// lldb-check:[...]$7 = Variant2('A')\n+\n+// lldb-command:continue\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// This test case makes sure that we get correct type descriptions for the enum\n+// discriminant of different instantiations of the same generic enum type where,\n+// dependending on the generic type parameter(s), the discriminant has a\n+// different size in memory.\n+\n+enum Enum<T> {\n+    Variant1(T),\n+    Variant2(T)\n+}\n+\n+fn main() {\n+    // These are ordered for descending size on purpose\n+    let eight_bytes1 = Enum::Variant1(100.0f64);\n+    let four_bytes1 = Enum::Variant1(101i32);\n+    let two_bytes1 = Enum::Variant1(102i16);\n+    let one_byte1 = Enum::Variant1(65u8);\n+\n+    let eight_bytes2 = Enum::Variant2(100.0f64);\n+    let four_bytes2 = Enum::Variant2(101i32);\n+    let two_bytes2 = Enum::Variant2(102i16);\n+    let one_byte2 = Enum::Variant2(65u8);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "47c4ea77e4426a1bead13e02a06fc78d28805a25", "filename": "src/test/debuginfo/generic-struct-style-enum-legacy.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = generic_struct_style_enum_legacy::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = generic_struct_style_enum_legacy::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbr-check:$3 = generic_struct_style_enum_legacy::Regular::Case3{a: 0, b: 6438275382588823897}\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{a = -1}}\n+// gdbr-check:$4 = generic_struct_style_enum_legacy::Univariant<i32>::TheOnlyCase{a: -1}\n+\n+\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n+// substituted with something of size `xx` bits and the same alignment as an integer type of the\n+// same size.\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular<T16, T32, T64> {\n+    Case1 { a: T64, b: T16, c: T16, d: T16, e: T16},\n+    Case2 { a: T64, b: T32, c: T32},\n+    Case3 { a: T64, b: T64 }\n+}\n+\n+enum Univariant<T> {\n+    TheOnlyCase { a: T }\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1: Regular<u16, u32, i64> = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2: Regular<i16, u32, i64>  = Case2 { a: 0, b: 286331153, c: 286331153 };\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3: Regular<u16, i32, u64>  = Case3 { a: 0, b: 6438275382588823897 };\n+\n+    let univariant = TheOnlyCase { a: -1 };\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "ee28968619d8efe36ab2ad9573ed927c85551058", "filename": "src/test/debuginfo/generic-tuple-style-enum-legacy.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = generic_tuple_style_enum_legacy::Regular::Case1(0, 31868, 31868, 31868, 31868)\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = generic_tuple_style_enum_legacy::Regular::Case2(0, 286331153, 286331153)\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbr-check:$3 = generic_tuple_style_enum_legacy::Regular::Case3(0, 6438275382588823897)\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{__0 = -1}}\n+// gdbr-check:$4 = generic_tuple_style_enum_legacy::Univariant<i64>::TheOnlyCase(-1)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print case1\n+// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Regular<u16, u32, u64>::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n+\n+// lldb-command:print case2\n+// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2) case2 = Regular<i16, i32, i64>::Case2 { generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2: 286331153, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case3: 286331153 }\n+\n+// lldb-command:print case3\n+// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case3) case3 = Regular<i16, i32, i64>::Case3 { generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2: 6438275382588823897 }\n+\n+// lldb-command:print univariant\n+// lldbg-check:[...]$3 = TheOnlyCase(-1)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Univariant<i64>) univariant = { generic_tuple_style_enum_legacy::TheOnlyCase = { = -1 } }\n+\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n+// substituted with something of size `xx` bits and the same alignment as an integer type of the\n+// same size.\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular<T16, T32, T64> {\n+    Case1(T64, T16, T16, T16, T16),\n+    Case2(T64, T32, T32),\n+    Case3(T64, T64)\n+}\n+\n+enum Univariant<T64> {\n+    TheOnlyCase(T64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1: Regular<u16, u32, u64> = Case1(0_u64, 31868_u16, 31868_u16, 31868_u16, 31868_u16);\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2: Regular<i16, i32, i64> = Case2(0_i64, 286331153_i32, 286331153_i32);\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3: Regular<i16, i32, i64> = Case3(0_i64, 6438275382588823897_i64);\n+\n+    let univariant = TheOnlyCase(-1_i64);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "ac407ced52747d9624c5d525ad646e5c9a6082ed", "filename": "src/test/debuginfo/recursive-struct-legacy.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,245 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// ignore-lldb\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// gdb-command:run\n+\n+// gdb-command:print stack_unique.value\n+// gdb-check:$1 = 0\n+// gdbg-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print stack_unique.next.val.value\n+// gdb-check:$2 = 1\n+\n+// gdbg-command:print unique_unique->value\n+// gdbr-command:print unique_unique.value\n+// gdb-check:$3 = 2\n+// gdbg-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print unique_unique.next.val.value\n+// gdb-check:$4 = 3\n+\n+// gdb-command:print vec_unique[0].value\n+// gdb-check:$5 = 6.5\n+// gdbg-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print vec_unique[0].next.val.value\n+// gdb-check:$6 = 7.5\n+\n+// gdbg-command:print borrowed_unique->value\n+// gdbr-command:print borrowed_unique.value\n+// gdb-check:$7 = 8.5\n+// gdbg-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print borrowed_unique.next.val.value\n+// gdb-check:$8 = 9.5\n+\n+// LONG CYCLE\n+// gdb-command:print long_cycle1.value\n+// gdb-check:$9 = 20\n+// gdbg-command:print long_cycle1.next->value\n+// gdbr-command:print long_cycle1.next.value\n+// gdb-check:$10 = 21\n+// gdbg-command:print long_cycle1.next->next->value\n+// gdbr-command:print long_cycle1.next.next.value\n+// gdb-check:$11 = 22\n+// gdbg-command:print long_cycle1.next->next->next->value\n+// gdbr-command:print long_cycle1.next.next.next.value\n+// gdb-check:$12 = 23\n+\n+// gdb-command:print long_cycle2.value\n+// gdb-check:$13 = 24\n+// gdbg-command:print long_cycle2.next->value\n+// gdbr-command:print long_cycle2.next.value\n+// gdb-check:$14 = 25\n+// gdbg-command:print long_cycle2.next->next->value\n+// gdbr-command:print long_cycle2.next.next.value\n+// gdb-check:$15 = 26\n+\n+// gdb-command:print long_cycle3.value\n+// gdb-check:$16 = 27\n+// gdbg-command:print long_cycle3.next->value\n+// gdbr-command:print long_cycle3.next.value\n+// gdb-check:$17 = 28\n+\n+// gdb-command:print long_cycle4.value\n+// gdb-check:$18 = 29.5\n+\n+// gdbg-command:print (*****long_cycle_w_anonymous_types).value\n+// gdbr-command:print long_cycle_w_anonymous_types.value\n+// gdb-check:$19 = 30\n+\n+// gdbg-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n+// gdbr-command:print long_cycle_w_anonymous_types.next.val.value\n+// gdb-check:$20 = 31\n+\n+// gdb-command:continue\n+\n+#![allow(unused_variables)]\n+#![feature(box_syntax)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Opt::{Empty, Val};\n+\n+enum Opt<T> {\n+    Empty,\n+    Val { val: T }\n+}\n+\n+struct UniqueNode<T> {\n+    next: Opt<Box<UniqueNode<T>>>,\n+    value: T\n+}\n+\n+struct LongCycle1<T> {\n+    next: Box<LongCycle2<T>>,\n+    value: T,\n+}\n+\n+struct LongCycle2<T> {\n+    next: Box<LongCycle3<T>>,\n+    value: T,\n+}\n+\n+struct LongCycle3<T> {\n+    next: Box<LongCycle4<T>>,\n+    value: T,\n+}\n+\n+struct LongCycle4<T> {\n+    next: Option<Box<LongCycle1<T>>>,\n+    value: T,\n+}\n+\n+struct LongCycleWithAnonymousTypes {\n+    next: Opt<Box<Box<Box<Box<Box<LongCycleWithAnonymousTypes>>>>>>,\n+    value: usize,\n+}\n+\n+// This test case makes sure that recursive structs are properly described. The Node structs are\n+// generic so that we can have a new type (that newly needs to be described) for the different\n+// cases. The potential problem with recursive types is that the DI generation algorithm gets\n+// trapped in an endless loop. To make sure, we actually test this in the different cases, we have\n+// to operate on a new type each time, otherwise we would just hit the DI cache for all but the\n+// first case.\n+\n+// The different cases below (stack_*, unique_*, box_*, etc) are set up so that the type description\n+// algorithm will enter the type reference cycle that is created by a recursive definition from a\n+// different context each time.\n+\n+// The \"long cycle\" cases are constructed to span a longer, indirect recursion cycle between types.\n+// The different locals will cause the DI algorithm to enter the type reference cycle at different\n+// points.\n+\n+fn main() {\n+    let stack_unique: UniqueNode<u16> = UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 1,\n+            }\n+        },\n+        value: 0,\n+    };\n+\n+    let unique_unique: Box<UniqueNode<u32>> = box UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 3,\n+            }\n+        },\n+        value: 2,\n+    };\n+\n+    let vec_unique: [UniqueNode<f32>; 1] = [UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 7.5,\n+            }\n+        },\n+        value: 6.5,\n+    }];\n+\n+    let borrowed_unique: &UniqueNode<f64> = &UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 9.5,\n+            }\n+        },\n+        value: 8.5,\n+    };\n+\n+    // LONG CYCLE\n+    let long_cycle1: LongCycle1<u16> = LongCycle1 {\n+        next: box LongCycle2 {\n+            next: box LongCycle3 {\n+                next: box LongCycle4 {\n+                    next: None,\n+                    value: 23,\n+                },\n+                value: 22,\n+            },\n+            value: 21\n+        },\n+        value: 20\n+    };\n+\n+    let long_cycle2: LongCycle2<u32> = LongCycle2 {\n+        next: box LongCycle3 {\n+            next: box LongCycle4 {\n+                next: None,\n+                value: 26,\n+            },\n+            value: 25,\n+        },\n+        value: 24\n+    };\n+\n+    let long_cycle3: LongCycle3<u64> = LongCycle3 {\n+        next: box LongCycle4 {\n+            next: None,\n+            value: 28,\n+        },\n+        value: 27,\n+    };\n+\n+    let long_cycle4: LongCycle4<f32> = LongCycle4 {\n+        next: None,\n+        value: 29.5,\n+    };\n+\n+    // It's important that LongCycleWithAnonymousTypes is encountered only at the end of the\n+    // `box` chain.\n+    let long_cycle_w_anonymous_types = box box box box box LongCycleWithAnonymousTypes {\n+        next: Val {\n+            val: box box box box box LongCycleWithAnonymousTypes {\n+                next: Empty,\n+                value: 31,\n+            }\n+        },\n+        value: 30\n+    };\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "fd2c6fa8171296fd20cb0cc0794b8419649f3d21", "filename": "src/test/debuginfo/struct-style-enum-legacy.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = struct_style_enum_legacy::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = struct_style_enum_legacy::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbr-check:$3 = struct_style_enum_legacy::Regular::Case3{a: 0, b: 6438275382588823897}\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{a = -1}}\n+// gdbr-check:$4 = struct_style_enum_legacy::Univariant::TheOnlyCase{a: -1}\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print case1\n+// lldbg-check:[...]$0 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 }\n+// lldbr-check:(struct_style_enum_legacy::Regular::Case1) case1 = { a = 0 b = 31868 c = 31868 d = 31868 e = 31868 }\n+\n+// lldb-command:print case2\n+// lldbg-check:[...]$1 = Case2 { a: 0, b: 286331153, c: 286331153 }\n+// lldbr-check:(struct_style_enum_legacy::Regular::Case2) case2 = Case2 { struct_style_enum_legacy::Regular::Case1: 0, struct_style_enum_legacy::Regular::Case2: 286331153, struct_style_enum_legacy::Regular::Case3: 286331153 }\n+\n+// lldb-command:print case3\n+// lldbg-check:[...]$2 = Case3 { a: 0, b: 6438275382588823897 }\n+// lldbr-check:(struct_style_enum_legacy::Regular::Case3) case3 = Case3 { struct_style_enum_legacy::Regular::Case1: 0, struct_style_enum_legacy::Regular::Case2: 6438275382588823897 }\n+\n+// lldb-command:print univariant\n+// lldbg-check:[...]$3 = TheOnlyCase { a: -1 }\n+// lldbr-check:(struct_style_enum_legacy::Univariant) univariant = Univariant { struct_style_enum_legacy::TheOnlyCase: TheOnlyCase { a: -1 } }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1 { a: u64, b: u16, c: u16, d: u16, e: u16},\n+    Case2 { a: u64, b: u32, c: u32},\n+    Case3 { a: u64, b: u64 }\n+}\n+\n+enum Univariant {\n+    TheOnlyCase { a: i64 }\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2 { a: 0, b: 286331153, c: 286331153 };\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3 = Case3 { a: 0, b: 6438275382588823897 };\n+\n+    let univariant = TheOnlyCase { a: -1 };\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "e33f6db534f80b6b74653d55357349a5de53023c", "filename": "src/test/debuginfo/tuple-style-enum-legacy.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = tuple_style_enum_legacy::Regular::Case1(0, 31868, 31868, 31868, 31868)\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = tuple_style_enum_legacy::Regular::Case2(0, 286331153, 286331153)\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbr-check:$3 = tuple_style_enum_legacy::Regular::Case3(0, 6438275382588823897)\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{__0 = -1}}\n+// gdbr-check:$4 = tuple_style_enum_legacy::Univariant::TheOnlyCase(-1)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print case1\n+// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n+// lldbr-check:(tuple_style_enum_legacy::Regular::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n+\n+// lldb-command:print case2\n+// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n+// lldbr-check:(tuple_style_enum_legacy::Regular::Case2) case2 = Case2 { tuple_style_enum_legacy::Regular::Case1: 0, tuple_style_enum_legacy::Regular::Case2: 286331153, tuple_style_enum_legacy::Regular::Case3: 286331153 }\n+\n+// lldb-command:print case3\n+// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n+// lldbr-check:(tuple_style_enum_legacy::Regular::Case3) case3 = Case3 { tuple_style_enum_legacy::Regular::Case1: 0, tuple_style_enum_legacy::Regular::Case2: 6438275382588823897 }\n+\n+// lldb-command:print univariant\n+// lldbg-check:[...]$3 = TheOnlyCase(-1)\n+// lldbr-check:(tuple_style_enum_legacy::Univariant) univariant = { tuple_style_enum_legacy::TheOnlyCase = { = -1 } }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1(u64, u16, u16, u16, u16),\n+    Case2(u64, u32, u32),\n+    Case3(u64, u64)\n+}\n+\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1(0, 31868, 31868, 31868, 31868);\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2(0, 286331153, 286331153);\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3 = Case3(0, 6438275382588823897);\n+\n+    let univariant = TheOnlyCase(-1);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "91fece334b2ab7314db569cb694c98de3f807387", "filename": "src/test/debuginfo/unique-enum-legacy.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print *the_a\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n+// gdbr-check:$1 = unique_enum_legacy::ABC::TheA{x: 0, y: 8970181431921507452}\n+\n+// gdb-command:print *the_b\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbr-check:$2 = unique_enum_legacy::ABC::TheB(0, 286331153, 286331153)\n+\n+// gdb-command:print *univariant\n+// gdbg-check:$3 = {{__0 = 123234}}\n+// gdbr-check:$3 = unique_enum_legacy::Univariant::TheOnlyCase(123234)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print *the_a\n+// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n+// lldbr-check:(unique_enum_legacy::ABC::TheA) *the_a = TheA { unique_enum_legacy::ABC::TheA: 0, unique_enum_legacy::ABC::TheB: 8970181431921507452 }\n+\n+// lldb-command:print *the_b\n+// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n+// lldbr-check:(unique_enum_legacy::ABC::TheB) *the_b = { = 0 = 286331153 = 286331153 }\n+\n+// lldb-command:print *univariant\n+// lldbg-check:[...]$2 = TheOnlyCase(123234)\n+// lldbr-check:(unique_enum_legacy::Univariant) *univariant = { unique_enum_legacy::TheOnlyCase = { = 123234 } }\n+\n+#![allow(unused_variables)]\n+#![feature(box_syntax)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+    TheA { x: i64, y: i64 },\n+    TheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let the_a: Box<_> = box ABC::TheA { x: 0, y: 8970181431921507452 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b: Box<_> = box ABC::TheB (0, 286331153, 286331153);\n+\n+    let univariant: Box<_> = box Univariant::TheOnlyCase(123234);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "f12dd31c402d9e85d11b1cc542ac477136290b5d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d36e37e43ef1fad628cbe194cfb2b96172de014f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=d36e37e43ef1fad628cbe194cfb2b96172de014f", "patch": "@@ -243,6 +243,29 @@ impl EarlyProps {\n                     // Ignore if using system LLVM and actual version\n                     // is smaller the minimum required version\n                     config.system_llvm && &actual_version[..] < min_version\n+                } else if line.starts_with(\"ignore-llvm-version\") {\n+                    // Syntax is: \"ignore-llvm-version <version1> [- <version2>]\"\n+                    let range_components = line.split(' ')\n+                        .skip(1) // Skip the directive.\n+                        .map(|s| s.trim())\n+                        .filter(|word| !word.is_empty() && word != &\"-\")\n+                        .take(3) // 3 or more = invalid, so take at most 3.\n+                        .collect::<Vec<&str>>();\n+                    match range_components.len() {\n+                        1 => {\n+                            &actual_version[..] == range_components[0]\n+                        }\n+                        2 => {\n+                            let v_min = range_components[0];\n+                            let v_max = range_components[1];\n+                            if v_max < v_min {\n+                                panic!(\"Malformed LLVM version range: max < min\")\n+                            }\n+                            // Ignore if version lies inside of range.\n+                            &actual_version[..] >= v_min && &actual_version[..] <= v_max\n+                        }\n+                        _ => panic!(\"Malformed LLVM version directive\"),\n+                    }\n                 } else {\n                     false\n                 }"}]}