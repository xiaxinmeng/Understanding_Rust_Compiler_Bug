{"sha": "cd9010c77e764e9348ecd92dc4a285f6514505dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOTAxMGM3N2U3NjRlOTM0OGVjZDkyZGM0YTI4NWY2NTE0NTA1ZGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-26T20:57:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-27T20:03:57Z"}, "message": "native: Improve windows file handling\n\nThis commit splits the file implementation into file_unix and file_win32. The\ntwo implementations have diverged to the point that they share almost 0 code at\nthis point, so it's easier to maintain as separate files.\n\nThe other major change accompanied with this commit is that file::open is no\nlonger based on libc's open function on windows, but rather windows's CreateFile\nfunction. This fixes dealing with binary files on windows (test added in\nprevious commit).\n\nThis also changes the read/write functions to use ReadFile and WriteFile instead\nof libc's read/write.\n\nCloses #12406", "tree": {"sha": "2f21e810536e25d0aea7c84c5c01768ae99f46b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f21e810536e25d0aea7c84c5c01768ae99f46b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd9010c77e764e9348ecd92dc4a285f6514505dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9010c77e764e9348ecd92dc4a285f6514505dc", "html_url": "https://github.com/rust-lang/rust/commit/cd9010c77e764e9348ecd92dc4a285f6514505dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd9010c77e764e9348ecd92dc4a285f6514505dc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "843c5e6308920018defe62fd1951c8a5b45553b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/843c5e6308920018defe62fd1951c8a5b45553b1", "html_url": "https://github.com/rust-lang/rust/commit/843c5e6308920018defe62fd1951c8a5b45553b1"}], "stats": {"total": 2164, "additions": 1146, "deletions": 1018}, "files": [{"sha": "27430ddee97eb7b3e8102dd108e88594b4c6ef20", "filename": "src/libnative/io/file.rs", "status": "removed", "additions": 0, "deletions": 995, "changes": 995, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -1,995 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Blocking posix-based file I/O\n-\n-#[allow(non_camel_case_types)];\n-\n-use std::sync::arc::UnsafeArc;\n-use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n-use std::libc::{c_int, c_void};\n-use std::libc;\n-use std::mem;\n-use std::os;\n-use std::rt::rtio;\n-use std::vec;\n-\n-use io::{IoResult, retry};\n-\n-#[cfg(windows)] use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-#[cfg(windows)] use std::ptr;\n-#[cfg(windows)] use std::str;\n-\n-pub fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n-    #[cfg(windows)] static eintr: int = 0; // doesn't matter\n-    #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n-\n-    let origamt = data.len();\n-    let mut data = data.as_ptr();\n-    let mut amt = origamt;\n-    while amt > 0 {\n-        let mut ret;\n-        loop {\n-            ret = f(data, amt);\n-            if cfg!(windows) { break } // windows has no eintr\n-            // if we get an eintr, then try again\n-            if ret != -1 || os::errno() as int != eintr { break }\n-        }\n-        if ret == 0 {\n-            break\n-        } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n-        } else {\n-            return ret;\n-        }\n-    }\n-    return (origamt - amt) as i64;\n-}\n-\n-pub type fd_t = libc::c_int;\n-\n-struct Inner {\n-    fd: fd_t,\n-    close_on_drop: bool,\n-}\n-\n-pub struct FileDesc {\n-    priv inner: UnsafeArc<Inner>\n-}\n-\n-impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n-    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { inner: UnsafeArc::new(Inner {\n-            fd: fd,\n-            close_on_drop: close_on_drop\n-        }) }\n-    }\n-\n-    // FIXME(#10465) these functions should not be public, but anything in\n-    //               native::io wanting to use them is forced to have all the\n-    //               rtio traits in scope\n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        #[cfg(windows)] type rlen = libc::c_uint;\n-        #[cfg(not(windows))] type rlen = libc::size_t;\n-        let ret = retry(|| unsafe {\n-            libc::read(self.fd(),\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as rlen) as libc::c_int\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        #[cfg(windows)] type wlen = libc::c_uint;\n-        #[cfg(not(windows))] type wlen = libc::size_t;\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::write(self.fd(), buf as *libc::c_void, len as wlen) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn fd(&self) -> fd_t {\n-        // This unsafety is fine because we're just reading off the file\n-        // descriptor, no one is modifying this.\n-        unsafe { (*self.inner.get()).fd }\n-    }\n-}\n-\n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        return os_pread(self.fd(), buf.as_ptr(), buf.len(), offset);\n-\n-        #[cfg(windows)]\n-        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            unsafe {\n-                let mut overlap: libc::OVERLAPPED = mem::init();\n-                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n-                let mut bytes_read = 0;\n-                overlap.Offset = offset as libc::DWORD;\n-                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-\n-                match libc::ReadFile(handle, buf as libc::LPVOID,\n-                                   amt as libc::DWORD,\n-                                   &mut bytes_read, &mut overlap) {\n-                    0 => Err(super::last_error()),\n-                    _ => Ok(bytes_read as int)\n-                }\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            match retry(|| unsafe {\n-                libc::pread(fd, buf as *libc::c_void, amt as libc::size_t,\n-                            offset as libc::off_t) as libc::c_int\n-            }) {\n-                -1 => Err(super::last_error()),\n-                n => Ok(n as int)\n-            }\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        return os_pwrite(self.fd(), buf.as_ptr(), buf.len(), offset);\n-\n-        #[cfg(windows)]\n-        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            unsafe {\n-                let mut overlap: libc::OVERLAPPED = mem::init();\n-                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n-                overlap.Offset = offset as libc::DWORD;\n-                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-\n-                match libc::WriteFile(handle, buf as libc::LPVOID,\n-                                      amt as libc::DWORD,\n-                                      ptr::mut_null(), &mut overlap) {\n-                    0 => Err(super::last_error()),\n-                    _ => Ok(()),\n-                }\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            super::mkerr_libc(retry(|| unsafe {\n-                libc::pwrite(fd, buf as *libc::c_void, amt as libc::size_t,\n-                             offset as libc::off_t)\n-            } as c_int))\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match style {\n-            io::SeekSet => libc::FILE_BEGIN,\n-            io::SeekEnd => libc::FILE_END,\n-            io::SeekCur => libc::FILE_CURRENT,\n-        };\n-        unsafe {\n-            let handle = libc::get_osfhandle(self.fd()) as libc::HANDLE;\n-            let mut newpos = 0;\n-            match libc::SetFilePointerEx(handle, pos, &mut newpos, whence) {\n-                0 => Err(super::last_error()),\n-                _ => Ok(newpos as u64),\n-            }\n-        }\n-    }\n-    #[cfg(unix)]\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match whence {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        return os_fsync(self.fd());\n-\n-        #[cfg(windows)]\n-        fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_winbool(unsafe {\n-                let handle = libc::get_osfhandle(fd);\n-                libc::FlushFileBuffers(handle as libc::HANDLE)\n-            })\n-        }\n-        #[cfg(unix)]\n-        fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_libc(retry(|| unsafe { libc::fsync(fd) }))\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n-\n-    #[cfg(not(windows))]\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        return super::mkerr_libc(os_datasync(self.fd()));\n-\n-        #[cfg(target_os = \"macos\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fdatasync(fd) })\n-        }\n-        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fsync(fd) })\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        let orig_pos = match self.tell() { Ok(i) => i, Err(e) => return Err(e) };\n-        match self.seek(offset, io::SeekSet) {\n-            Ok(_) => {}, Err(e) => return Err(e),\n-        };\n-        let ret = unsafe {\n-            let handle = libc::get_osfhandle(self.fd()) as libc::HANDLE;\n-            match libc::SetEndOfFile(handle) {\n-                0 => Err(super::last_error()),\n-                _ => Ok(())\n-            }\n-        };\n-        let _ = self.seek(orig_pos as i64, io::SeekSet);\n-        return ret;\n-    }\n-    #[cfg(unix)]\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::ftruncate(self.fd(), offset as libc::off_t)\n-        }))\n-    }\n-}\n-\n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn clone(&self) -> ~rtio::RtioPipe {\n-        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n-    }\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            let n = unsafe { libc::close(self.fd) };\n-            if n != 0 {\n-                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n-            }\n-        }\n-    }\n-}\n-\n-pub struct CFile {\n-    priv file: *libc::FILE,\n-    priv fd: FileDesc,\n-}\n-\n-impl CFile {\n-    /// Create a `CFile` from an open `FILE` pointer.\n-    ///\n-    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n-    /// destruction.\n-    pub fn new(file: *libc::FILE) -> CFile {\n-        CFile {\n-            file: file,\n-            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n-        }\n-    }\n-\n-    pub fn flush(&mut self) -> Result<(), IoError> {\n-        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n-    }\n-}\n-\n-impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as int)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        self.flush().and_then(|()| self.fd.pread(buf, offset))\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n-    }\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match style {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        let ret = unsafe { libc::ftell(self.file) };\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.fsync())\n-    }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.fsync())\n-    }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        self.flush().and_then(|()| self.fd.truncate(offset))\n-    }\n-}\n-\n-impl Drop for CFile {\n-    fn drop(&mut self) {\n-        unsafe { let _ = libc::fclose(self.file); }\n-    }\n-}\n-\n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<FileDesc> {\n-    let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n-    };\n-    // Opening with a write permission must silently create the file.\n-    let (flags, mode) = match fa {\n-        io::Read => (flags | libc::O_RDONLY, 0),\n-        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                      libc::S_IRUSR | libc::S_IWUSR),\n-        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n-    };\n-\n-    return match os_open(path, flags, mode) {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(FileDesc::new(fd, true)),\n-    };\n-\n-    #[cfg(windows)]\n-    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        as_utf16_p(path.as_str().unwrap(), |path| {\n-            retry(|| unsafe { libc::wopen(path, flags, mode) })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) })\n-    }\n-}\n-\n-pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n-    return os_mkdir(p, mode as c_int);\n-\n-    #[cfg(windows)]\n-    fn os_mkdir(p: &CString, _mode: c_int) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            // FIXME: turn mode into something useful? #2623\n-            as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::CreateDirectoryW(buf, ptr::mut_null())\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_mkdir(p: &CString, mode: c_int) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n-        }))\n-    }\n-}\n-\n-pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n-    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n-        let root = Path::new(root);\n-\n-        dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }).map(|path| root.join(path)).collect()\n-    }\n-\n-    unsafe {\n-        #[cfg(not(windows))]\n-        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use std::libc::{dirent_t};\n-            use std::libc::{opendir, readdir, closedir};\n-            extern {\n-                fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n-            }\n-            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-\n-            let dir_ptr = p.with_ref(|buf| opendir(buf));\n-\n-            if dir_ptr as uint != 0 {\n-                let mut paths = ~[];\n-                debug!(\"os::list_dir -- opendir() SUCCESS\");\n-                let mut entry_ptr = readdir(dir_ptr);\n-                while entry_ptr as uint != 0 {\n-                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(Path::new(cstr));\n-                    entry_ptr = readdir(dir_ptr);\n-                }\n-                assert_eq!(closedir(dir_ptr), 0);\n-                Ok(paths)\n-            } else {\n-                Err(super::last_error())\n-            }\n-        }\n-\n-        #[cfg(windows)]\n-        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use std::libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use std::libc::{wcslen, free};\n-            use std::libc::funcs::extra::kernel32::{\n-                FindFirstFileW,\n-                FindNextFileW,\n-                FindClose,\n-            };\n-            use std::libc::types::os::arch::extra::HANDLE;\n-            use os::win32::{\n-                as_utf16_p\n-            };\n-            use rt::global_heap::malloc_raw;\n-\n-            #[nolink]\n-            extern {\n-                fn rust_list_dir_wfd_size() -> libc::size_t;\n-                fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n-            }\n-            let p = CString::new(p.with_ref(|p| p), false);\n-            let p = Path::new(p);\n-            let star = p.join(\"*\");\n-            as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n-                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n-                    let mut paths = ~[];\n-                    let mut more_files = 1 as libc::c_int;\n-                    while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n-                        if fp_buf as uint == 0 {\n-                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n-                        }\n-                        else {\n-                            let fp_vec = vec::from_buf(\n-                                fp_buf, wcslen(fp_buf) as uint);\n-                            let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n-                            let fp_str = str::from_utf16(fp_trimmed)\n-                                    .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n-                            paths.push(Path::new(fp_str));\n-                        }\n-                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n-                    }\n-                    assert!(FindClose(find_handle) != 0);\n-                    free(wfd_ptr as *mut c_void);\n-                    Ok(paths)\n-                } else {\n-                    Err(super::last_error())\n-                }\n-            })\n-        }\n-\n-        get_list(p).map(|paths| prune(p, paths))\n-    }\n-}\n-\n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    return os_unlink(p);\n-\n-    #[cfg(windows)]\n-    fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::DeleteFileW(buf)\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n-    }\n-}\n-\n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n-    return os_rename(old, new);\n-\n-    #[cfg(windows)]\n-    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            as_utf16_p(old.as_str().unwrap(), |old| {\n-                as_utf16_p(new.as_str().unwrap(), |new| {\n-                    libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-                })\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n-        }))\n-    }\n-}\n-\n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n-    return super::mkerr_libc(os_chmod(p, mode as c_int));\n-\n-    #[cfg(windows)]\n-    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n-                libc::wchmod(p, mode)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        retry(||unsafe { libc::chmod(p.with_ref(|p| p), mode as libc::mode_t) })\n-    }\n-}\n-\n-pub fn rmdir(p: &CString) -> IoResult<()> {\n-    return super::mkerr_libc(os_rmdir(p));\n-\n-    #[cfg(windows)]\n-    fn os_rmdir(p: &CString) -> c_int {\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n-                libc::wrmdir(p)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_rmdir(p: &CString) -> c_int {\n-        retry(|| unsafe { libc::rmdir(p.with_ref(|p| p)) })\n-    }\n-}\n-\n-pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n-    return super::mkerr_libc(os_chown(p, uid, gid));\n-\n-    // libuv has this as a no-op, so seems like this should as well?\n-    #[cfg(windows)]\n-    fn os_chown(_p: &CString, _uid: int, _gid: int) -> c_int { 0 }\n-\n-    #[cfg(unix)]\n-    fn os_chown(p: &CString, uid: int, gid: int) -> c_int {\n-        retry(|| unsafe {\n-            libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n-                        gid as libc::gid_t)\n-        })\n-    }\n-}\n-\n-pub fn readlink(p: &CString) -> IoResult<Path> {\n-    return os_readlink(p);\n-\n-    // FIXME: I have a feeling that this reads intermediate symlinks as well.\n-    #[cfg(windows)]\n-    fn os_readlink(p: &CString) -> IoResult<Path> {\n-        let handle = unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| {\n-                libc::CreateFileW(p,\n-                                  libc::GENERIC_READ,\n-                                  libc::FILE_SHARE_READ,\n-                                  ptr::mut_null(),\n-                                  libc::OPEN_EXISTING,\n-                                  libc::FILE_ATTRIBUTE_NORMAL,\n-                                  ptr::mut_null())\n-            })\n-        };\n-        if handle as int == libc::INVALID_HANDLE_VALUE as int {\n-            return Err(super::last_error())\n-        }\n-        let ret = fill_utf16_buf_and_decode(|buf, sz| {\n-            unsafe {\n-                libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n-                                                libc::VOLUME_NAME_NT)\n-            }\n-        });\n-        let ret = match ret {\n-            Some(s) => Ok(Path::new(s)),\n-            None => Err(super::last_error()),\n-        };\n-        assert!(unsafe { libc::CloseHandle(handle) } != 0);\n-        return ret;\n-\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_readlink(p: &CString) -> IoResult<Path> {\n-        let p = p.with_ref(|p| p);\n-        let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n-        if len == -1 {\n-            len = 1024; // FIXME: read PATH_MAX from C ffi?\n-        }\n-        let mut buf = vec::with_capacity::<u8>(len as uint);\n-        match retry(|| unsafe {\n-            libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n-                           len as libc::size_t) as libc::c_int\n-        }) {\n-            -1 => Err(super::last_error()),\n-            n => {\n-                assert!(n > 0);\n-                unsafe { buf.set_len(n as uint); }\n-                Ok(Path::new(buf))\n-            }\n-        }\n-    }\n-}\n-\n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    return os_symlink(src, dst);\n-\n-    #[cfg(windows)]\n-    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-            as_utf16_p(dst.as_str().unwrap(), |dst| {\n-                unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n-            }) as libc::BOOL\n-        }))\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        }))\n-    }\n-}\n-\n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    return os_link(src, dst);\n-\n-    #[cfg(windows)]\n-    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-            as_utf16_p(dst.as_str().unwrap(), |dst| {\n-                unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-            })\n-        }))\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        }))\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n-    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    io::FileStat {\n-        path: Path::new(path),\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n-        created: stat.st_ctime as u64,\n-        modified: stat.st_mtime as u64,\n-        accessed: stat.st_atime as u64,\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n-    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n-    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n-    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n-    fn flags(_stat: &libc::stat) -> u64 { 0 }\n-\n-    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n-    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n-    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n-    fn gen(_stat: &libc::stat) -> u64 { 0 }\n-\n-    io::FileStat {\n-        path: Path::new(path),\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: flags(stat),\n-            gen: gen(stat),\n-        }\n-    }\n-}\n-\n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n-    return os_stat(p);\n-\n-    #[cfg(windows)]\n-    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::uninit() };\n-        as_utf16_p(p.as_str().unwrap(), |up| {\n-            match retry(|| unsafe { libc::wstat(up, &mut stat) }) {\n-                0 => Ok(mkstat(&stat, p)),\n-                _ => Err(super::last_error()),\n-            }\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::uninit() };\n-        match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n-            0 => Ok(mkstat(&stat, p)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n-    return os_lstat(p);\n-\n-    // FIXME: windows implementation is missing\n-    #[cfg(windows)]\n-    fn os_lstat(_p: &CString) -> IoResult<io::FileStat> {\n-        Err(super::unimpl())\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_lstat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::uninit() };\n-        match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n-            0 => Ok(mkstat(&stat, p)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    return super::mkerr_libc(os_utime(p, atime, mtime));\n-\n-    #[cfg(windows)]\n-    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n-        let buf = libc::utimbuf {\n-            actime: (atime / 1000) as libc::time64_t,\n-            modtime: (mtime / 1000) as libc::time64_t,\n-        };\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n-                libc::wutime(p, &buf)\n-            }))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n-        let buf = libc::utimbuf {\n-            actime: (atime / 1000) as libc::time_t,\n-            modtime: (mtime / 1000) as libc::time_t,\n-        };\n-        retry(|| unsafe { libc::utime(p.with_ref(|p| p), &buf) })\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{CFile, FileDesc};\n-    use std::io;\n-    use std::libc;\n-    use std::os;\n-    use std::rt::rtio::RtioFileStream;\n-\n-    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n-    #[test]\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        unsafe {\n-            let os::Pipe { input, out } = os::pipe();\n-            let mut reader = FileDesc::new(input, true);\n-            let mut writer = FileDesc::new(out, true);\n-\n-            writer.inner_write(bytes!(\"test\")).unwrap();\n-            let mut buf = [0u8, ..4];\n-            match reader.inner_read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-\n-            assert!(writer.inner_read(buf).is_err());\n-            assert!(reader.inner_write(buf).is_err());\n-        }\n-    }\n-\n-    #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n-    #[test]\n-    fn test_cfile() {\n-        unsafe {\n-            let f = libc::tmpfile();\n-            assert!(!f.is_null());\n-            let mut file = CFile::new(f);\n-\n-            file.write(bytes!(\"test\")).unwrap();\n-            let mut buf = [0u8, ..4];\n-            let _ = file.seek(0, io::SeekSet).unwrap();\n-            match file.read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-        }\n-    }\n-}"}, {"sha": "4b6d1813ffa4ad598aedca6c45601004b902b9d7", "filename": "src/libnative/io/file_unix.rs", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -0,0 +1,573 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking posix-based file I/O\n+\n+use std::sync::arc::UnsafeArc;\n+use std::c_str::CString;\n+use std::io::IoError;\n+use std::io;\n+use std::libc::{c_int, c_void};\n+use std::libc;\n+use std::mem;\n+use std::rt::rtio;\n+use std::vec;\n+\n+use io::{IoResult, retry, keep_going};\n+\n+pub type fd_t = libc::c_int;\n+\n+struct Inner {\n+    fd: fd_t,\n+    close_on_drop: bool,\n+}\n+\n+pub struct FileDesc {\n+    priv inner: UnsafeArc<Inner>\n+}\n+\n+impl FileDesc {\n+    /// Create a `FileDesc` from an open C file descriptor.\n+    ///\n+    /// The `FileDesc` will take ownership of the specified file descriptor and\n+    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n+    /// it will not close the file descriptor when this `FileDesc` is dropped.\n+    ///\n+    /// Note that all I/O operations done on this object will be *blocking*, but\n+    /// they do not require the runtime to be active.\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { inner: UnsafeArc::new(Inner {\n+            fd: fd,\n+            close_on_drop: close_on_drop\n+        }) }\n+    }\n+\n+    // FIXME(#10465) these functions should not be public, but anything in\n+    //               native::io wanting to use them is forced to have all the\n+    //               rtio traits in scope\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let ret = retry(|| unsafe {\n+            libc::read(self.fd(),\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n+                       buf.len() as libc::size_t) as libc::c_int\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::write(self.fd(), buf as *libc::c_void,\n+                            len as libc::size_t) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn fd(&self) -> fd_t {\n+        // This unsafety is fine because we're just reading off the file\n+        // descriptor, no one is modifying this.\n+        unsafe { (*self.inner.get()).fd }\n+    }\n+}\n+\n+impl io::Reader for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.inner_read(buf)\n+    }\n+}\n+\n+impl io::Writer for FileDesc {\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.inner_write(buf)\n+    }\n+}\n+\n+impl rtio::RtioFileStream for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.inner_read(buf).map(|i| i as int)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        match retry(|| unsafe {\n+            libc::pread(self.fd(), buf.as_ptr() as *libc::c_void,\n+                        buf.len() as libc::size_t,\n+                        offset as libc::off_t) as libc::c_int\n+        }) {\n+            -1 => Err(super::last_error()),\n+            n => Ok(n as int)\n+        }\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe {\n+            libc::pwrite(self.fd(), buf.as_ptr() as *libc::c_void,\n+                         buf.len() as libc::size_t, offset as libc::off_t)\n+        } as c_int))\n+    }\n+    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match whence {\n+            io::SeekSet => libc::SEEK_SET,\n+            io::SeekEnd => libc::SEEK_END,\n+            io::SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        return super::mkerr_libc(os_datasync(self.fd()));\n+\n+        #[cfg(target_os = \"macos\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fdatasync(fd) })\n+        }\n+        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fsync(fd) })\n+        }\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe {\n+            libc::ftruncate(self.fd(), offset as libc::off_t)\n+        }))\n+    }\n+}\n+\n+impl rtio::RtioPipe for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    }\n+}\n+\n+impl rtio::RtioTTY for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn isatty(&self) -> bool { false }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+pub struct CFile {\n+    priv file: *libc::FILE,\n+    priv fd: FileDesc,\n+}\n+\n+impl CFile {\n+    /// Create a `CFile` from an open `FILE` pointer.\n+    ///\n+    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n+    /// destruction.\n+    pub fn new(file: *libc::FILE) -> CFile {\n+        CFile {\n+            file: file,\n+            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n+        }\n+    }\n+\n+    pub fn flush(&mut self) -> Result<(), IoError> {\n+        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n+    }\n+}\n+\n+impl rtio::RtioFileStream for CFile {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as int)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.flush().and_then(|()| self.fd.pread(buf, offset))\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n+    }\n+    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match style {\n+            io::SeekSet => libc::SEEK_SET,\n+            io::SeekEnd => libc::SEEK_END,\n+            io::SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        let ret = unsafe { libc::ftell(self.file) };\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as u64)\n+        }\n+    }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.fsync())\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.fsync())\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        self.flush().and_then(|()| self.fd.truncate(offset))\n+    }\n+}\n+\n+impl Drop for CFile {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::fclose(self.file); }\n+    }\n+}\n+\n+pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+        -> IoResult<FileDesc> {\n+    let flags = match fm {\n+        io::Open => 0,\n+        io::Append => libc::O_APPEND,\n+        io::Truncate => libc::O_TRUNC,\n+    };\n+    // Opening with a write permission must silently create the file.\n+    let (flags, mode) = match fa {\n+        io::Read => (flags | libc::O_RDONLY, 0),\n+        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                      libc::S_IRUSR | libc::S_IWUSR),\n+        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                          libc::S_IRUSR | libc::S_IWUSR),\n+    };\n+\n+    match retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) }) {\n+        -1 => Err(super::last_error()),\n+        fd => Ok(FileDesc::new(fd, true)),\n+    }\n+}\n+\n+pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n+    }))\n+}\n+\n+pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n+    use std::libc::{dirent_t};\n+    use std::libc::{opendir, readdir, closedir};\n+\n+    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = Path::new(root);\n+\n+        dirs.move_iter().filter(|path| {\n+            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+        }).map(|path| root.join(path)).collect()\n+    }\n+\n+    extern {\n+        fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n+    }\n+\n+    debug!(\"os::list_dir -- BEFORE OPENDIR\");\n+\n+    let dir_ptr = p.with_ref(|buf| unsafe { opendir(buf) });\n+\n+    if dir_ptr as uint != 0 {\n+        let mut paths = ~[];\n+        debug!(\"os::list_dir -- opendir() SUCCESS\");\n+        let mut entry_ptr = unsafe { readdir(dir_ptr) };\n+        while entry_ptr as uint != 0 {\n+            let cstr = unsafe {\n+                CString::new(rust_list_dir_val(entry_ptr), false)\n+            };\n+            paths.push(Path::new(cstr));\n+            entry_ptr = unsafe { readdir(dir_ptr) };\n+        }\n+        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n+        Ok(prune(p, paths))\n+    } else {\n+        Err(super::last_error())\n+    }\n+}\n+\n+pub fn unlink(p: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n+}\n+\n+pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n+    }))\n+}\n+\n+pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::chmod(p.with_ref(|p| p), mode as libc::mode_t)\n+    }))\n+}\n+\n+pub fn rmdir(p: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::rmdir(p.with_ref(|p| p))\n+    }))\n+}\n+\n+pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n+                    gid as libc::gid_t)\n+    }))\n+}\n+\n+pub fn readlink(p: &CString) -> IoResult<Path> {\n+    let p = p.with_ref(|p| p);\n+    let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n+    if len == -1 {\n+        len = 1024; // FIXME: read PATH_MAX from C ffi?\n+    }\n+    let mut buf = vec::with_capacity::<u8>(len as uint);\n+    match retry(|| unsafe {\n+        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n+                       len as libc::size_t) as libc::c_int\n+    }) {\n+        -1 => Err(super::last_error()),\n+        n => {\n+            assert!(n > 0);\n+            unsafe { buf.set_len(n as uint); }\n+            Ok(Path::new(buf))\n+        }\n+    }\n+}\n+\n+pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n+    }))\n+}\n+\n+pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n+    }))\n+}\n+\n+fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n+    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n+\n+    // FileStat times are in milliseconds\n+    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n+\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+\n+    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n+    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n+    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n+    fn flags(_stat: &libc::stat) -> u64 { 0 }\n+\n+    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n+    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n+    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n+    fn gen(_stat: &libc::stat) -> u64 { 0 }\n+\n+    io::FileStat {\n+        path: Path::new(path),\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n+        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n+        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n+        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: flags(stat),\n+            gen: gen(stat),\n+        }\n+    }\n+}\n+\n+pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+    let mut stat: libc::stat = unsafe { mem::uninit() };\n+    match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n+        0 => Ok(mkstat(&stat, p)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n+    let mut stat: libc::stat = unsafe { mem::uninit() };\n+    match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n+        0 => Ok(mkstat(&stat, p)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+    let buf = libc::utimbuf {\n+        actime: (atime / 1000) as libc::time_t,\n+        modtime: (mtime / 1000) as libc::time_t,\n+    };\n+    super::mkerr_libc(retry(|| unsafe {\n+        libc::utime(p.with_ref(|p| p), &buf)\n+    }))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{CFile, FileDesc};\n+    use std::io;\n+    use std::libc;\n+    use std::os;\n+    use std::rt::rtio::RtioFileStream;\n+\n+    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n+    #[test]\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        unsafe {\n+            let os::Pipe { input, out } = os::pipe();\n+            let mut reader = FileDesc::new(input, true);\n+            let mut writer = FileDesc::new(out, true);\n+\n+            writer.inner_write(bytes!(\"test\")).unwrap();\n+            let mut buf = [0u8, ..4];\n+            match reader.inner_read(buf) {\n+                Ok(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail!(\"invalid read: {:?}\", r)\n+            }\n+\n+            assert!(writer.inner_read(buf).is_err());\n+            assert!(reader.inner_write(buf).is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cfile() {\n+        unsafe {\n+            let f = libc::tmpfile();\n+            assert!(!f.is_null());\n+            let mut file = CFile::new(f);\n+\n+            file.write(bytes!(\"test\")).unwrap();\n+            let mut buf = [0u8, ..4];\n+            let _ = file.seek(0, io::SeekSet).unwrap();\n+            match file.read(buf) {\n+                Ok(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail!(\"invalid read: {:?}\", r)\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "9fe57536da3137b3e9545a2111e7d99060185f49", "filename": "src/libnative/io/file_win32.rs", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -0,0 +1,516 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking win32-based file I/O\n+\n+use std::c_str::CString;\n+use std::cast;\n+use std::io::IoError;\n+use std::io;\n+use std::libc::{c_int, c_void};\n+use std::libc;\n+use std::mem;\n+use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+use std::ptr;\n+use std::rt::rtio;\n+use std::str;\n+use std::sync::arc::UnsafeArc;\n+use std::vec;\n+\n+use io::IoResult;\n+\n+pub type fd_t = libc::c_int;\n+\n+struct Inner {\n+    fd: fd_t,\n+    close_on_drop: bool,\n+}\n+\n+pub struct FileDesc {\n+    priv inner: UnsafeArc<Inner>\n+}\n+\n+impl FileDesc {\n+    /// Create a `FileDesc` from an open C file descriptor.\n+    ///\n+    /// The `FileDesc` will take ownership of the specified file descriptor and\n+    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n+    /// it will not close the file descriptor when this `FileDesc` is dropped.\n+    ///\n+    /// Note that all I/O operations done on this object will be *blocking*, but\n+    /// they do not require the runtime to be active.\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { inner: UnsafeArc::new(Inner {\n+            fd: fd,\n+            close_on_drop: close_on_drop\n+        }) }\n+    }\n+\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let mut read = 0;\n+        let ret = unsafe {\n+            libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD, &mut read,\n+                           ptr::mut_null())\n+        };\n+        if ret != 0 {\n+            Ok(read as uint)\n+        } else {\n+            Err(super::last_error())\n+        }\n+    }\n+    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let mut cur = buf.as_ptr();\n+        let mut remaining = buf.len();\n+        while remaining > 0 {\n+            let mut amt = 0;\n+            let ret = unsafe {\n+                libc::WriteFile(self.handle(), cur as libc::LPVOID,\n+                                remaining as libc::DWORD, &mut amt,\n+                                ptr::mut_null())\n+            };\n+            if ret != 0 {\n+                remaining -= amt as uint;\n+                cur = unsafe { cur.offset(amt as int) };\n+            } else {\n+                return Err(super::last_error())\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn fd(&self) -> fd_t {\n+        // This unsafety is fine because we're just reading off the file\n+        // descriptor, no one is modifying this.\n+        unsafe { (*self.inner.get()).fd }\n+    }\n+\n+    pub fn handle(&self) -> libc::HANDLE {\n+        unsafe { libc::get_osfhandle(self.fd()) as libc::HANDLE }\n+    }\n+}\n+\n+impl io::Reader for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.inner_read(buf)\n+    }\n+}\n+\n+impl io::Writer for FileDesc {\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.inner_write(buf)\n+    }\n+}\n+\n+impl rtio::RtioFileStream for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.inner_read(buf).map(|i| i as int)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        let mut read = 0;\n+        let mut overlap: libc::OVERLAPPED = unsafe { mem::init() };\n+        overlap.Offset = offset as libc::DWORD;\n+        overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n+        let ret = unsafe {\n+            libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD, &mut read,\n+                           &mut overlap)\n+        };\n+        if ret != 0 {\n+            Ok(read as int)\n+        } else {\n+            Err(super::last_error())\n+        }\n+    }\n+    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> Result<(), IoError> {\n+        let mut cur = buf.as_ptr();\n+        let mut remaining = buf.len();\n+        let mut overlap: libc::OVERLAPPED = unsafe { mem::init() };\n+        while remaining > 0 {\n+            overlap.Offset = offset as libc::DWORD;\n+            overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n+            let mut amt = 0;\n+            let ret = unsafe {\n+                libc::WriteFile(self.handle(), cur as libc::LPVOID,\n+                                remaining as libc::DWORD, &mut amt,\n+                                &mut overlap)\n+            };\n+            if ret != 0 {\n+                remaining -= amt as uint;\n+                cur = unsafe { cur.offset(amt as int) };\n+                offset += amt as u64;\n+            } else {\n+                return Err(super::last_error())\n+            }\n+        }\n+        Ok(())\n+    }\n+    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match style {\n+            io::SeekSet => libc::FILE_BEGIN,\n+            io::SeekEnd => libc::FILE_END,\n+            io::SeekCur => libc::FILE_CURRENT,\n+        };\n+        unsafe {\n+            let mut newpos = 0;\n+            match libc::SetFilePointerEx(self.handle(), pos, &mut newpos,\n+                                         whence) {\n+                0 => Err(super::last_error()),\n+                _ => Ok(newpos as u64),\n+            }\n+        }\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        // This transmute is fine because our seek implementation doesn't\n+        // actually use the mutable self at all.\n+        unsafe { cast::transmute_mut(self).seek(0, io::SeekCur) }\n+    }\n+\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        super::mkerr_winbool(unsafe {\n+            libc::FlushFileBuffers(self.handle())\n+        })\n+    }\n+\n+    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n+\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        let orig_pos = try!(self.tell());\n+        let _ = try!(self.seek(offset, io::SeekSet));\n+        let ret = unsafe {\n+            match libc::SetEndOfFile(self.handle()) {\n+                0 => Err(super::last_error()),\n+                _ => Ok(())\n+            }\n+        };\n+        let _ = self.seek(orig_pos as i64, io::SeekSet);\n+        return ret;\n+    }\n+}\n+\n+impl rtio::RtioPipe for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    }\n+}\n+\n+impl rtio::RtioTTY for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn isatty(&self) -> bool { false }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+        -> IoResult<FileDesc> {\n+    // Flags passed to open_osfhandle\n+    let flags = match fm {\n+        io::Open => 0,\n+        io::Append => libc::O_APPEND,\n+        io::Truncate => libc::O_TRUNC,\n+    };\n+    let flags = match fa {\n+        io::Read => flags | libc::O_RDONLY,\n+        io::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n+        io::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n+    };\n+\n+    let mut dwDesiredAccess = match fa {\n+        io::Read => libc::FILE_GENERIC_READ,\n+        io::Write => libc::FILE_GENERIC_WRITE,\n+        io::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n+    };\n+\n+    // libuv has a good comment about this, but the basic idea is what we try to\n+    // emulate unix semantics by enabling all sharing by allowing things such as\n+    // deleting a file while it's still open.\n+    let dwShareMode = libc::FILE_SHARE_READ | libc::FILE_SHARE_WRITE |\n+                      libc::FILE_SHARE_DELETE;\n+\n+    let dwCreationDisposition = match (fm, fa) {\n+        (io::Truncate, io::Read) => libc::TRUNCATE_EXISTING,\n+        (io::Truncate, _) => libc::CREATE_ALWAYS,\n+        (io::Open, io::Read) => libc::OPEN_EXISTING,\n+        (io::Open, _) => libc::CREATE_NEW,\n+        (io::Append, io::Read) => {\n+            dwDesiredAccess |= libc::FILE_APPEND_DATA;\n+            libc::OPEN_EXISTING\n+        }\n+        (io::Append, _) => {\n+            dwDesiredAccess &= !libc::FILE_WRITE_DATA;\n+            dwDesiredAccess |= libc::FILE_APPEND_DATA;\n+            libc::OPEN_ALWAYS\n+        }\n+    };\n+\n+    let mut dwFlagsAndAttributes = libc::FILE_ATTRIBUTE_NORMAL;\n+    // Compat with unix, this allows opening directories (see libuv)\n+    dwFlagsAndAttributes |= libc::FILE_FLAG_BACKUP_SEMANTICS;\n+\n+    let handle = as_utf16_p(path.as_str().unwrap(), |buf| unsafe {\n+        libc::CreateFileW(buf,\n+                          dwDesiredAccess,\n+                          dwShareMode,\n+                          ptr::mut_null(),\n+                          dwCreationDisposition,\n+                          dwFlagsAndAttributes,\n+                          ptr::mut_null())\n+    });\n+    if handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+        Err(super::last_error())\n+    } else {\n+        let fd = unsafe {\n+            libc::open_osfhandle(handle as libc::intptr_t, flags)\n+        };\n+        if fd < 0 {\n+            let _ = unsafe { libc::CloseHandle(handle) };\n+            Err(super::last_error())\n+        } else {\n+            Ok(FileDesc::new(fd, true))\n+        }\n+    }\n+}\n+\n+pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_winbool(unsafe {\n+        // FIXME: turn mode into something useful? #2623\n+        as_utf16_p(p.as_str().unwrap(), |buf| {\n+            libc::CreateDirectoryW(buf, ptr::mut_null())\n+        })\n+    })\n+}\n+\n+pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n+    use rt::global_heap::malloc_raw;\n+\n+    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = Path::new(root);\n+\n+        dirs.move_iter().filter(|path| {\n+            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+        }).map(|path| root.join(path)).collect()\n+    }\n+\n+    #[nolink]\n+    extern {\n+        fn rust_list_dir_wfd_size() -> libc::size_t;\n+        fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+    }\n+    let star = Path::new(unsafe {\n+        CString::new(p.with_ref(|p| p), false)\n+    }).join(\"*\");\n+    as_utf16_p(star.as_str().unwrap(), |path_ptr| unsafe {\n+        let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n+        let find_handle = libc::FindFirstFileW(path_ptr, wfd_ptr as libc::HANDLE);\n+        if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n+            let mut paths = ~[];\n+            let mut more_files = 1 as libc::c_int;\n+            while more_files != 0 {\n+                let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n+                if fp_buf as uint == 0 {\n+                    fail!(\"os::list_dir() failure: got null ptr from wfd\");\n+                } else {\n+                    let fp_vec = vec::from_buf(fp_buf,\n+                                               libc::wcslen(fp_buf) as uint);\n+                    let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n+                    let fp_str = str::from_utf16(fp_trimmed)\n+                            .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n+                    paths.push(Path::new(fp_str));\n+                }\n+                more_files = libc::FindNextFileW(find_handle,\n+                                                 wfd_ptr as libc::HANDLE);\n+            }\n+            assert!(libc::FindClose(find_handle) != 0);\n+            libc::free(wfd_ptr as *mut c_void);\n+            Ok(prune(p, paths))\n+        } else {\n+            Err(super::last_error())\n+        }\n+    })\n+}\n+\n+pub fn unlink(p: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(unsafe {\n+        as_utf16_p(p.as_str().unwrap(), |buf| {\n+            libc::DeleteFileW(buf)\n+        })\n+    })\n+}\n+\n+pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(unsafe {\n+        as_utf16_p(old.as_str().unwrap(), |old| {\n+            as_utf16_p(new.as_str().unwrap(), |new| {\n+                libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n+            })\n+        })\n+    })\n+}\n+\n+pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+        libc::wchmod(p, mode as libc::c_int)\n+    }))\n+}\n+\n+pub fn rmdir(p: &CString) -> IoResult<()> {\n+    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+        libc::wrmdir(p)\n+    }))\n+}\n+\n+pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n+    // libuv has this as a no-op, so seems like this should as well?\n+    Ok(())\n+}\n+\n+pub fn readlink(p: &CString) -> IoResult<Path> {\n+    // FIXME: I have a feeling that this reads intermediate symlinks as well.\n+    let handle = unsafe {\n+        as_utf16_p(p.as_str().unwrap(), |p| {\n+            libc::CreateFileW(p,\n+                              libc::GENERIC_READ,\n+                              libc::FILE_SHARE_READ,\n+                              ptr::mut_null(),\n+                              libc::OPEN_EXISTING,\n+                              libc::FILE_ATTRIBUTE_NORMAL,\n+                              ptr::mut_null())\n+        })\n+    };\n+    if handle as int == libc::INVALID_HANDLE_VALUE as int {\n+        return Err(super::last_error())\n+    }\n+    // Specify (sz - 1) because the documentation states that it's the size\n+    // without the null pointer\n+    let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n+        libc::GetFinalPathNameByHandleW(handle,\n+                                        buf as *u16,\n+                                        sz - 1,\n+                                        libc::VOLUME_NAME_DOS)\n+    });\n+    let ret = match ret {\n+        Some(s) => Ok(Path::new(s)),\n+        None => Err(super::last_error()),\n+    };\n+    assert!(unsafe { libc::CloseHandle(handle) } != 0);\n+    return ret;\n+}\n+\n+pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+        as_utf16_p(dst.as_str().unwrap(), |dst| {\n+            unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n+        }) as libc::BOOL\n+    }))\n+}\n+\n+pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+        as_utf16_p(dst.as_str().unwrap(), |dst| {\n+            unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n+        })\n+    }))\n+}\n+\n+fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n+    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+\n+    io::FileStat {\n+        path: Path::new(path),\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n+        created: stat.st_ctime as u64,\n+        modified: stat.st_mtime as u64,\n+        accessed: stat.st_atime as u64,\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: 0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        }\n+    }\n+}\n+\n+pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+    let mut stat: libc::stat = unsafe { mem::uninit() };\n+    as_utf16_p(p.as_str().unwrap(), |up| {\n+        match unsafe { libc::wstat(up, &mut stat) } {\n+            0 => Ok(mkstat(&stat, p)),\n+            _ => Err(super::last_error()),\n+        }\n+    })\n+}\n+\n+pub fn lstat(_p: &CString) -> IoResult<io::FileStat> {\n+    // FIXME: implementation is missing\n+    Err(super::unimpl())\n+}\n+\n+pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+    let buf = libc::utimbuf {\n+        actime: (atime / 1000) as libc::time64_t,\n+        modtime: (mtime / 1000) as libc::time64_t,\n+    };\n+    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+        libc::wutime(p, &buf)\n+    }))\n+}"}, {"sha": "ca3a0ccc5a29306d17b1ecb46b12805b821f0d19", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -42,10 +42,16 @@ pub use self::process::Process;\n \n // Native I/O implementations\n pub mod addrinfo;\n-pub mod file;\n pub mod net;\n pub mod process;\n \n+#[cfg(unix)]\n+#[path = \"file_unix.rs\"]\n+pub mod file;\n+#[cfg(windows)]\n+#[path = \"file_win32.rs\"]\n+pub mod file;\n+\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"android\")]\n@@ -97,7 +103,7 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n             libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n             libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n             libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-            libc::ERROR_BROKEN_PIPE => (io::BrokenPipe, \"the pipe has ended\"),\n+            libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n \n             x => {\n                 debug!(\"ignoring {}: {}\", x, os::last_os_error());\n@@ -185,6 +191,24 @@ fn retry(f: || -> libc::c_int) -> libc::c_int {\n     }\n }\n \n+fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n+    let origamt = data.len();\n+    let mut data = data.as_ptr();\n+    let mut amt = origamt;\n+    while amt > 0 {\n+        let ret = retry(|| f(data, amt) as libc::c_int);\n+        if ret == 0 {\n+            break\n+        } else if ret != -1 {\n+            amt -= ret as uint;\n+            data = unsafe { data.offset(ret as int) };\n+        } else {\n+            return ret as i64;\n+        }\n+    }\n+    return (origamt - amt) as i64;\n+}\n+\n /// Implementation of rt::rtio's IoFactory trait to generate handles to the\n /// native I/O functionality.\n pub struct IoFactory {"}, {"sha": "7445e4c09926171c7b90d4c67b61db062bd62fc0", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(non_camel_case_types)];\n-\n use std::cast;\n use std::io::net::ip;\n use std::io;\n@@ -18,8 +16,7 @@ use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n \n-use super::{IoResult, retry};\n-use super::file::keep_going;\n+use super::{IoResult, retry, keep_going};\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -323,16 +320,14 @@ impl rtio::RtioTcpStream for TcpStream {\n         }\n     }\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::send(self.fd(),\n-                           buf as *mut libc::c_void,\n-                           len as wrlen,\n-                           0) as i64\n-            }\n+        let ret = keep_going(buf, |buf, len| unsafe {\n+            libc::send(self.fd(),\n+                       buf as *mut libc::c_void,\n+                       len as wrlen,\n+                       0) as i64\n         });\n         if ret < 0 {\n-            Err(last_error())\n+            Err(super::last_error())\n         } else {\n             Ok(())\n         }"}, {"sha": "9e81dc02cc5969bea57255aebe96b8a5924d9513", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -17,8 +17,8 @@ use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n use std::intrinsics;\n \n-use super::{IoResult, retry};\n-use super::file::{keep_going, fd_t};\n+use super::{IoResult, retry, keep_going};\n+use super::file::fd_t;\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {"}, {"sha": "7669d4a658fad3db5e936597b14895c2f05178a7", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -20,8 +20,6 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-#[allow(non_camel_case_types)];\n-\n use std::cast;\n use std::rt;\n use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n@@ -100,7 +98,6 @@ mod imp {\n \n     use io::file::FileDesc;\n \n-    #[allow(non_camel_case_types)]\n     pub type signal = libc::c_int;\n \n     pub fn new() -> (signal, signal) {"}, {"sha": "0784b5ee048450961541bed71e62499397ec191b", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -46,8 +46,6 @@\n //!\n //! Note that all time units in this file are in *milliseconds*.\n \n-#[allow(non_camel_case_types)];\n-\n use std::comm::Data;\n use std::libc;\n use std::mem;"}, {"sha": "7feeaa4768c9aff71e8094f3957efd973d0e7eed", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -28,8 +28,6 @@\n //!\n //! As with timer_other, all units in this file are in units of millseconds.\n \n-#[allow(non_camel_case_types)];\n-\n use std::comm::Data;\n use std::libc;\n use std::ptr;"}, {"sha": "238e4c23b452e70cbafa692d6e3fe5d39b2701de", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -49,6 +49,7 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[deny(unused_result, unused_must_use)];\n+#[allow(non_camel_case_types)];\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "6b692112f5ff5c7896f7d04734e58a14798652b4", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9010c77e764e9348ecd92dc4a285f6514505dc/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=cd9010c77e764e9348ecd92dc4a285f6514505dc", "patch": "@@ -1745,6 +1745,10 @@ pub mod consts {\n             pub static OPEN_EXISTING: DWORD = 3;\n             pub static TRUNCATE_EXISTING: DWORD = 5;\n \n+            pub static FILE_APPEND_DATA: DWORD = 0x00000004;\n+            pub static FILE_READ_DATA: DWORD = 0x00000001;\n+            pub static FILE_WRITE_DATA: DWORD = 0x00000002;\n+\n             pub static FILE_ATTRIBUTE_ARCHIVE: DWORD = 0x20;\n             pub static FILE_ATTRIBUTE_COMPRESSED: DWORD = 0x800;\n             pub static FILE_ATTRIBUTE_DEVICE: DWORD = 0x40;\n@@ -1791,6 +1795,18 @@ pub mod consts {\n             pub static FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n             pub static FILE_READ_ATTRIBUTES: DWORD = 0x00000080;\n \n+            pub static STANDARD_RIGHTS_READ: DWORD = 0x20000;\n+            pub static STANDARD_RIGHTS_WRITE: DWORD = 0x20000;\n+            pub static FILE_WRITE_EA: DWORD = 0x00000010;\n+            pub static FILE_READ_EA: DWORD = 0x00000008;\n+            pub static FILE_GENERIC_READ: DWORD =\n+                STANDARD_RIGHTS_READ | FILE_READ_DATA |\n+                FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE;\n+            pub static FILE_GENERIC_WRITE: DWORD =\n+                STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA |\n+                FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA |\n+                SYNCHRONIZE;\n+\n             pub static FILE_BEGIN: DWORD = 0;\n             pub static FILE_CURRENT: DWORD = 1;\n             pub static FILE_END: DWORD = 2;\n@@ -4231,6 +4247,7 @@ pub mod funcs {\n \n         pub mod msvcrt {\n             use libc::types::os::arch::c95::{c_int, c_long};\n+            use libc::types::os::arch::c99::intptr_t;\n \n             #[nolink]\n             extern {\n@@ -4239,6 +4256,10 @@ pub mod funcs {\n \n                 #[link_name = \"_get_osfhandle\"]\n                 pub fn get_osfhandle(fd: c_int) -> c_long;\n+\n+                #[link_name = \"_open_osfhandle\"]\n+                pub fn open_osfhandle(osfhandle: intptr_t,\n+                                      flags: c_int) -> c_int;\n             }\n         }\n     }"}]}