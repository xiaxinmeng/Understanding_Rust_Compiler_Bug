{"sha": "2ac91a382d48c0c50f3c105da086fb59883e3897", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYzkxYTM4MmQ0OGMwYzUwZjNjMTA1ZGEwODZmYjU5ODgzZTM4OTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-27T23:04:40Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-27T23:04:40Z"}, "message": "Rollup merge of #21686 - richo:python-fixes, r=alexcrichton\n\nWhile waiting on some builds I started cleaning up the various python bits and pieces.\n\nI'm going to keep poking, want to ping me before the next rollup?", "tree": {"sha": "5a0f09ad6b19f06640a8b5aeb7034b900328b776", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a0f09ad6b19f06640a8b5aeb7034b900328b776"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ac91a382d48c0c50f3c105da086fb59883e3897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac91a382d48c0c50f3c105da086fb59883e3897", "html_url": "https://github.com/rust-lang/rust/commit/2ac91a382d48c0c50f3c105da086fb59883e3897", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ac91a382d48c0c50f3c105da086fb59883e3897/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b0271f89272ae66912d6b805d67a54baadb50b", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b0271f89272ae66912d6b805d67a54baadb50b", "html_url": "https://github.com/rust-lang/rust/commit/28b0271f89272ae66912d6b805d67a54baadb50b"}, {"sha": "7cabb2124e9771a0791cba44078ccc8541523935", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cabb2124e9771a0791cba44078ccc8541523935", "html_url": "https://github.com/rust-lang/rust/commit/7cabb2124e9771a0791cba44078ccc8541523935"}], "stats": {"total": 1632, "additions": 868, "deletions": 764}, "files": [{"sha": "917e1970a36c068928d1ca6695b5be099c210ec5", "filename": "src/etc/check-summary.py", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fcheck-summary.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fcheck-summary.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-summary.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -15,6 +15,7 @@\n \n if __name__ == '__main__':\n     summaries = []\n+\n     def summarise(fname):\n         summary = {}\n         with open(fname) as fd:\n@@ -27,12 +28,14 @@ def summarise(fname):\n                 # track bench runs\n                 if splitline[1] == 'ns/iter':\n                     status = 'bench'\n-                if not summary.has_key(status):\n+                if status not in summary:\n                     summary[status] = []\n                 summary[status].append(test)\n             summaries.append((fname, summary))\n+\n     def count(t):\n         return sum(map(lambda (f, s): len(s.get(t, [])), summaries))\n+\n     logfiles = sys.argv[1:]\n     for files in map(glob.glob, logfiles):\n         map(summarise, files)\n@@ -41,8 +44,9 @@ def count(t):\n     ignored = count('ignored')\n     measured = count('bench')\n     print \"summary of %d test runs: %d passed; %d failed; %d ignored; %d measured\" % \\\n-            (len(logfiles), ok, failed, ignored, measured)\n+          (len(logfiles), ok, failed, ignored, measured)\n     print \"\"\n+\n     if failed > 0:\n         print \"failed tests:\"\n         for f, s in summaries:"}, {"sha": "c940359abc118d8e0ef570c82fec5ccbab1572f7", "filename": "src/etc/errorck.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -11,7 +11,9 @@\n # Digs error codes out of files named 'diagnostics.rs' across\n # the tree, and ensures thare are no duplicates.\n \n-import sys, os, re\n+import sys\n+import os\n+import re\n \n src_dir = sys.argv[1]\n errcode_map = {}"}, {"sha": "a12c3298cb35b93b057ed019f97ea208d4665f9d", "filename": "src/etc/extract_grammar.py", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fextract_grammar.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fextract_grammar.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract_grammar.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -14,11 +14,11 @@\n \n import fileinput\n \n-collections = { \"gram\": [],\n-                \"keyword\": [],\n-                \"reserved\": [],\n-                \"binop\": [],\n-                \"unop\": [] }\n+collections = {\"gram\": [],\n+               \"keyword\": [],\n+               \"reserved\": [],\n+               \"binop\": [],\n+               \"unop\": []}\n \n \n in_coll = False\n@@ -47,66 +47,66 @@\n # Define operator symbol-names here\n \n tokens = [\"non_star\", \"non_slash\", \"non_eol\",\n-          \"non_single_quote\", \"non_double_quote\", \"ident\" ]\n+          \"non_single_quote\", \"non_double_quote\", \"ident\"]\n \n symnames = {\n-\".\": \"dot\",\n-\"+\": \"plus\",\n-\"-\": \"minus\",\n-\"/\": \"slash\",\n-\"*\": \"star\",\n-\"%\": \"percent\",\n-\n-\"~\": \"tilde\",\n-\"@\": \"at\",\n-\n-\"!\": \"not\",\n-\"&\": \"and\",\n-\"|\": \"or\",\n-\"^\": \"xor\",\n-\n-\"<<\": \"lsl\",\n-\">>\": \"lsr\",\n-\">>>\": \"asr\",\n-\n-\"&&\": \"andand\",\n-\"||\": \"oror\",\n-\n-\"<\" : \"lt\",\n-\"<=\" : \"le\",\n-\"==\" : \"eqeq\",\n-\">=\" : \"ge\",\n-\">\" : \"gt\",\n-\n-\"=\": \"eq\",\n-\n-\"+=\": \"plusequal\",\n-\"-=\": \"minusequal\",\n-\"/=\": \"divequal\",\n-\"*=\": \"starequal\",\n-\"%=\": \"percentequal\",\n-\n-\"&=\": \"andequal\",\n-\"|=\": \"orequal\",\n-\"^=\": \"xorequal\",\n-\n-\">>=\": \"lsrequal\",\n-\">>>=\": \"asrequal\",\n-\"<<=\": \"lslequal\",\n-\n-\"::\": \"coloncolon\",\n-\n-\"->\": \"rightarrow\",\n-\"<-\": \"leftarrow\",\n-\"<->\": \"swaparrow\",\n-\n-\"//\": \"linecomment\",\n-\"/*\": \"openblockcomment\",\n-\"*/\": \"closeblockcomment\",\n-\"macro_rules\": \"macro_rules\",\n-\"=>\" : \"eg\",\n-\"..\" : \"dotdot\",\n-\",\"  : \"comma\"\n+    \".\": \"dot\",\n+    \"+\": \"plus\",\n+    \"-\": \"minus\",\n+    \"/\": \"slash\",\n+    \"*\": \"star\",\n+    \"%\": \"percent\",\n+\n+    \"~\": \"tilde\",\n+    \"@\": \"at\",\n+\n+    \"!\": \"not\",\n+    \"&\": \"and\",\n+    \"|\": \"or\",\n+    \"^\": \"xor\",\n+\n+    \"<<\": \"lsl\",\n+    \">>\": \"lsr\",\n+    \">>>\": \"asr\",\n+\n+    \"&&\": \"andand\",\n+    \"||\": \"oror\",\n+\n+    \"<\": \"lt\",\n+    \"<=\": \"le\",\n+    \"==\": \"eqeq\",\n+    \">=\": \"ge\",\n+    \">\": \"gt\",\n+\n+    \"=\": \"eq\",\n+\n+    \"+=\": \"plusequal\",\n+    \"-=\": \"minusequal\",\n+    \"/=\": \"divequal\",\n+    \"*=\": \"starequal\",\n+    \"%=\": \"percentequal\",\n+\n+    \"&=\": \"andequal\",\n+    \"|=\": \"orequal\",\n+    \"^=\": \"xorequal\",\n+\n+    \">>=\": \"lsrequal\",\n+    \">>>=\": \"asrequal\",\n+    \"<<=\": \"lslequal\",\n+\n+    \"::\": \"coloncolon\",\n+\n+    \"->\": \"rightarrow\",\n+    \"<-\": \"leftarrow\",\n+    \"<->\": \"swaparrow\",\n+\n+    \"//\": \"linecomment\",\n+    \"/*\": \"openblockcomment\",\n+    \"*/\": \"closeblockcomment\",\n+    \"macro_rules\": \"macro_rules\",\n+    \"=>\": \"eg\",\n+    \"..\": \"dotdot\",\n+    \",\": \"comma\"\n }\n \n lines = []\n@@ -126,8 +126,8 @@\n                                         + word)\n                 if word not in tokens:\n                     if (word in collections[\"keyword\"] or\n-                        word in collections[\"reserved\"]):\n-                       tokens.append(word)\n+                            word in collections[\"reserved\"]):\n+                        tokens.append(word)\n                     else:\n                         raise Exception(\"unknown keyword/reserved word: \"\n                                         + word)\n@@ -149,8 +149,8 @@\n print(\"%start parser, token;\")\n print(\"%%token %s ;\" % (\"\\n\\t, \".join(tokens)))\n for coll in [\"keyword\", \"reserved\"]:\n-    print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join(collections[coll])));\n+    print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join(collections[coll])))\n for coll in [\"binop\", \"unop\"]:\n     print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join([symnames[x]\n-                                              for x in collections[coll]])));\n-print(\"\\n\".join(lines));\n+                                              for x in collections[coll]])))\n+print(\"\\n\".join(lines))"}, {"sha": "c5587bb10d1dacf3840b35dc5350055e1b61cbec", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 188, "deletions": 176, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -14,181 +14,189 @@\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n \n+\n def register_printers(objfile):\n-  \"Registers Rust pretty printers for the given objfile\"\n-  objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+    \"Registers Rust pretty printers for the given objfile\"\n+    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+\n \n def rust_pretty_printer_lookup_function(val):\n-  \"Returns the correct Rust pretty printer for the given value if there is one\"\n-  type_code = val.type.code\n-\n-  if type_code == gdb.TYPE_CODE_STRUCT:\n-    struct_kind = classify_struct(val.type)\n-\n-    if struct_kind == STRUCT_KIND_STR_SLICE:\n-      return RustStringSlicePrinter(val)\n-\n-    if struct_kind == STRUCT_KIND_TUPLE:\n-      return RustTuplePrinter(val)\n-\n-    if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n-      return RustTupleStructPrinter(val, False)\n-\n-    if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n-      return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n-\n-    if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n-      return RustTupleStructPrinter(val, True)\n-\n-    if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n-      return RustStructPrinter(val, True)\n-\n-    return RustStructPrinter(val, False)\n-\n-  # Enum handling\n-  if type_code == gdb.TYPE_CODE_UNION:\n-    enum_members = list(val.type.fields())\n-    enum_member_count = len(enum_members)\n-\n-    if enum_member_count == 0:\n-      return RustStructPrinter(val, False)\n-\n-    if enum_member_count == 1:\n-      first_variant_name = enum_members[0].name\n-      if first_variant_name == None:\n-        # This is a singleton enum\n-        return rust_pretty_printer_lookup_function(val[enum_members[0]])\n-      else:\n-        assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n-        # This is a space-optimized enum.\n-        # This means this enum has only two states, and Rust uses one of the\n-        # fields somewhere in the struct to determine which of the two states\n-        # it's in. The location of the field is encoded in the name as something\n-        # like RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n-        last_separator_index = first_variant_name.rfind(\"$\")\n-        start_index = len(\"RUST$ENCODED$ENUM$\")\n-        disr_field_indices = first_variant_name[start_index :\n-                                              last_separator_index].split(\"$\")\n-        disr_field_indices = [int(index) for index in disr_field_indices]\n-\n-        sole_variant_val = val[enum_members[0]]\n-        discriminant = sole_variant_val\n-        for disr_field_index in disr_field_indices:\n-          disr_field = get_field_at_index(discriminant, disr_field_index)\n-          discriminant = discriminant[disr_field]\n-\n-        # If the discriminant field is a fat pointer we have to consider the\n-        # first word as the true discriminant\n-        if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n-          discriminant = discriminant[get_field_at_index(discriminant, 0)]\n-\n-        if discriminant == 0:\n-          null_variant_name = first_variant_name[last_separator_index + 1:]\n-          return IdentityPrinter(null_variant_name)\n-\n-        return rust_pretty_printer_lookup_function(sole_variant_val)\n-\n-    # This is a regular enum, extract the discriminant\n-    discriminant_name, discriminant_val = extract_discriminant_value(val)\n-    return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n-\n-  # No pretty printer has been found\n-  return None\n+    \"Returns the correct Rust pretty printer for the given value if there is one\"\n+    type_code = val.type.code\n+\n+    if type_code == gdb.TYPE_CODE_STRUCT:\n+        struct_kind = classify_struct(val.type)\n+\n+        if struct_kind == STRUCT_KIND_STR_SLICE:\n+            return RustStringSlicePrinter(val)\n+\n+        if struct_kind == STRUCT_KIND_TUPLE:\n+            return RustTuplePrinter(val)\n+\n+        if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n+            return RustTupleStructPrinter(val, False)\n+\n+        if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n+            return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n+\n+        if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n+            return RustTupleStructPrinter(val, True)\n+\n+        if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n+            return RustStructPrinter(val, True)\n+\n+        return RustStructPrinter(val, False)\n+\n+    # Enum handling\n+    if type_code == gdb.TYPE_CODE_UNION:\n+        enum_members = list(val.type.fields())\n+        enum_member_count = len(enum_members)\n+\n+        if enum_member_count == 0:\n+            return RustStructPrinter(val, False)\n+\n+        if enum_member_count == 1:\n+            first_variant_name = enum_members[0].name\n+            if first_variant_name is None:\n+                # This is a singleton enum\n+                return rust_pretty_printer_lookup_function(val[enum_members[0]])\n+            else:\n+                assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n+                # This is a space-optimized enum.\n+                # This means this enum has only two states, and Rust uses one\n+                # of the fields somewhere in the struct to determine which of\n+                # the two states it's in. The location of the field is encoded\n+                # in the name as something like\n+                # RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n+                last_separator_index = first_variant_name.rfind(\"$\")\n+                start_index = len(\"RUST$ENCODED$ENUM$\")\n+                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n+                disr_field_indices = [int(index) for index in disr_field_indices]\n+\n+                sole_variant_val = val[enum_members[0]]\n+                discriminant = sole_variant_val\n+                for disr_field_index in disr_field_indices:\n+                    disr_field = get_field_at_index(discriminant, disr_field_index)\n+                    discriminant = discriminant[disr_field]\n+\n+                # If the discriminant field is a fat pointer we have to consider the\n+                # first word as the true discriminant\n+                if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n+                    discriminant = discriminant[get_field_at_index(discriminant, 0)]\n+\n+                if discriminant == 0:\n+                    null_variant_name = first_variant_name[last_separator_index + 1:]\n+                    return IdentityPrinter(null_variant_name)\n+\n+                return rust_pretty_printer_lookup_function(sole_variant_val)\n+\n+        # This is a regular enum, extract the discriminant\n+        discriminant_name, discriminant_val = extract_discriminant_value(val)\n+        return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n+\n+    # No pretty printer has been found\n+    return None\n \n #=------------------------------------------------------------------------------\n # Pretty Printer Classes\n #=------------------------------------------------------------------------------\n \n+\n class RustStructPrinter:\n-  def __init__(self, val, hide_first_field):\n-    self.val = val\n-    self.hide_first_field = hide_first_field\n-\n-  def to_string(self):\n-    return self.val.type.tag\n-\n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      field_name = field.name\n-      # Normally the field name is used as a key to access the field value,\n-      # because that's also supported in older versions of GDB...\n-      field_key = field_name\n-      if field_name == None:\n-        field_name = \"\"\n-        # ... but for fields without a name (as in tuples), we have to fall back\n-        # to the newer method of using the field object directly as key. In\n-        # older versions of GDB, this will just fail.\n-        field_key = field\n-      name_value_tuple = ( field_name, self.val[field_key] )\n-      cs.append( name_value_tuple )\n-\n-    if self.hide_first_field:\n-      cs = cs[1:]\n-\n-    return cs\n+    def __init__(self, val, hide_first_field):\n+        self.val = val\n+        self.hide_first_field = hide_first_field\n+\n+    def to_string(self):\n+        return self.val.type.tag\n+\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            field_name = field.name\n+            # Normally the field name is used as a key to access the field\n+            # value, because that's also supported in older versions of GDB...\n+            field_key = field_name\n+            if field_name is None:\n+                field_name = \"\"\n+                # ... but for fields without a name (as in tuples), we have to\n+                # fall back to the newer method of using the field object\n+                # directly as key. In older versions of GDB, this will just\n+                # fail.\n+                field_key = field\n+            name_value_tuple = (field_name, self.val[field_key])\n+            cs.append(name_value_tuple)\n+\n+        if self.hide_first_field:\n+            cs = cs[1:]\n+\n+        return cs\n+\n \n class RustTuplePrinter:\n-  def __init__(self, val):\n-    self.val = val\n+    def __init__(self, val):\n+        self.val = val\n \n-  def to_string(self):\n-    return None\n+    def to_string(self):\n+        return None\n+\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            cs.append((\"\", self.val[field]))\n \n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      cs.append( (\"\", self.val[field]) )\n+        return cs\n \n-    return cs\n+    def display_hint(self):\n+        return \"array\"\n \n-  def display_hint(self):\n-    return \"array\"\n \n class RustTupleStructPrinter:\n-  def __init__(self, val, hide_first_field):\n-    self.val = val\n-    self.hide_first_field = hide_first_field\n+    def __init__(self, val, hide_first_field):\n+        self.val = val\n+        self.hide_first_field = hide_first_field\n \n-  def to_string(self):\n-    return self.val.type.tag\n+    def to_string(self):\n+        return self.val.type.tag\n \n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      cs.append( (\"\", self.val[field]) )\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            cs.append((\"\", self.val[field]))\n \n-    if self.hide_first_field:\n-      cs = cs[1:]\n+        if self.hide_first_field:\n+            cs = cs[1:]\n \n-    return cs\n+        return cs\n+\n+    def display_hint(self):\n+        return \"array\"\n \n-  def display_hint(self):\n-    return \"array\"\n \n class RustStringSlicePrinter:\n-  def __init__(self, val):\n-    self.val = val\n+    def __init__(self, val):\n+        self.val = val\n+\n+    def to_string(self):\n+        slice_byte_len = self.val[\"length\"]\n+        return '\"%s\"' % self.val[\"data_ptr\"].string(encoding=\"utf-8\", length=slice_byte_len)\n \n-  def to_string(self):\n-    slice_byte_len = self.val[\"length\"]\n-    return '\"%s\"' % self.val[\"data_ptr\"].string(encoding = \"utf-8\",\n-                                                length = slice_byte_len)\n \n class RustCStyleEnumPrinter:\n-  def __init__(self, val):\n-    assert val.type.code == gdb.TYPE_CODE_ENUM\n-    self.val = val\n+    def __init__(self, val):\n+        assert val.type.code == gdb.TYPE_CODE_ENUM\n+        self.val = val\n+\n+    def to_string(self):\n+        return str(self.val)\n \n-  def to_string(self):\n-    return str(self.val)\n \n class IdentityPrinter:\n-  def __init__(self, string):\n-    self.string = string\n+    def __init__(self, string):\n+        self.string = string\n \n-  def to_string(self):\n-    return self.string\n+    def to_string(self):\n+        return self.string\n \n STRUCT_KIND_REGULAR_STRUCT  = 0\n STRUCT_KIND_TUPLE_STRUCT    = 1\n@@ -198,47 +206,51 @@ def to_string(self):\n STRUCT_KIND_CSTYLE_VARIANT  = 5\n STRUCT_KIND_STR_SLICE       = 6\n \n+\n def classify_struct(type):\n-  if type.tag == \"&str\":\n-    return STRUCT_KIND_STR_SLICE\n+    if type.tag == \"&str\":\n+        return STRUCT_KIND_STR_SLICE\n \n-  fields = list(type.fields())\n-  field_count = len(fields)\n+    fields = list(type.fields())\n+    field_count = len(fields)\n \n-  if field_count == 0:\n-    return STRUCT_KIND_REGULAR_STRUCT\n+    if field_count == 0:\n+        return STRUCT_KIND_REGULAR_STRUCT\n+\n+    if fields[0].name == \"RUST$ENUM$DISR\":\n+        if field_count == 1:\n+            return STRUCT_KIND_CSTYLE_VARIANT\n+        elif fields[1].name is None:\n+            return STRUCT_KIND_TUPLE_VARIANT\n+        else:\n+            return STRUCT_KIND_STRUCT_VARIANT\n \n-  if fields[0].name == \"RUST$ENUM$DISR\":\n-    if field_count == 1:\n-      return STRUCT_KIND_CSTYLE_VARIANT\n-    elif fields[1].name == None:\n-      return STRUCT_KIND_TUPLE_VARIANT\n-    else:\n-      return STRUCT_KIND_STRUCT_VARIANT\n+    if fields[0].name is None:\n+        if type.tag.startswith(\"(\"):\n+            return STRUCT_KIND_TUPLE\n+        else:\n+            return STRUCT_KIND_TUPLE_STRUCT\n \n-  if fields[0].name == None:\n-    if type.tag.startswith(\"(\"):\n-      return STRUCT_KIND_TUPLE\n-    else:\n-      return STRUCT_KIND_TUPLE_STRUCT\n+    return STRUCT_KIND_REGULAR_STRUCT\n \n-  return STRUCT_KIND_REGULAR_STRUCT\n \n def extract_discriminant_value(enum_val):\n-  assert enum_val.type.code == gdb.TYPE_CODE_UNION\n-  for variant_descriptor in enum_val.type.fields():\n-    variant_val = enum_val[variant_descriptor]\n-    for field in variant_val.type.fields():\n-      return (field.name, int(variant_val[field]))\n+    assert enum_val.type.code == gdb.TYPE_CODE_UNION\n+    for variant_descriptor in enum_val.type.fields():\n+        variant_val = enum_val[variant_descriptor]\n+        for field in variant_val.type.fields():\n+            return (field.name, int(variant_val[field]))\n+\n \n def first_field(val):\n-  for field in val.type.fields():\n-    return field\n+    for field in val.type.fields():\n+        return field\n+\n \n def get_field_at_index(val, index):\n-  i = 0\n-  for field in val.type.fields():\n-    if i == index:\n-      return field\n-    i += 1\n-  return None\n+    i = 0\n+    for field in val.type.fields():\n+        if i == index:\n+            return field\n+        i += 1\n+    return None"}, {"sha": "937c231a473e9916bfb31fe7954c7eb927a2b4ce", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -56,4 +56,4 @@\n         f.write(template % (datetime.datetime.now().year, kw, kw))\n \n     # mark file read-only\n-    os.chmod(test_file, stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH)\n+    os.chmod(test_file, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)"}, {"sha": "26246bd2c32a33b159355658be7ff87d64b7f5bf", "filename": "src/etc/get-snapshot.py", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fget-snapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fget-snapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fget-snapshot.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -10,36 +10,40 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import os, tarfile, re, shutil, sys\n+import os\n+import tarfile\n+import shutil\n+import sys\n from snapshot import *\n \n+\n def unpack_snapshot(triple, dl_path):\n-  print(\"opening snapshot \" + dl_path)\n-  tar = tarfile.open(dl_path)\n-  kernel = get_kernel(triple)\n-\n-  stagep = os.path.join(triple, \"stage0\")\n-\n-  # Remove files from prior unpackings, since snapshot rustc may not\n-  # be able to disambiguate between multiple candidate libraries.\n-  # (Leave dirs in place since extracting step still needs them.)\n-  for root, _, files in os.walk(stagep):\n-    for f in files:\n-      print(\"removing \" + os.path.join(root, f))\n-      os.unlink(os.path.join(root, f))\n-\n-  for p in tar.getnames():\n-    name = p.replace(\"rust-stage0/\", \"\", 1);\n-\n-    fp = os.path.join(stagep, name)\n-    print(\"extracting \" + p)\n-    tar.extract(p, download_unpack_base)\n-    tp = os.path.join(download_unpack_base, p)\n-    if os.path.isdir(tp) and os.path.exists(fp):\n-        continue\n-    shutil.move(tp, fp)\n-  tar.close()\n-  shutil.rmtree(download_unpack_base)\n+    print(\"opening snapshot \" + dl_path)\n+    tar = tarfile.open(dl_path)\n+    kernel = get_kernel(triple)\n+\n+    stagep = os.path.join(triple, \"stage0\")\n+\n+    # Remove files from prior unpackings, since snapshot rustc may not\n+    # be able to disambiguate between multiple candidate libraries.\n+    # (Leave dirs in place since extracting step still needs them.)\n+    for root, _, files in os.walk(stagep):\n+        for f in files:\n+            print(\"removing \" + os.path.join(root, f))\n+            os.unlink(os.path.join(root, f))\n+\n+    for p in tar.getnames():\n+        name = p.replace(\"rust-stage0/\", \"\", 1)\n+\n+        fp = os.path.join(stagep, name)\n+        print(\"extracting \" + p)\n+        tar.extract(p, download_unpack_base)\n+        tp = os.path.join(download_unpack_base, p)\n+        if os.path.isdir(tp) and os.path.exists(fp):\n+            continue\n+        shutil.move(tp, fp)\n+    tar.close()\n+    shutil.rmtree(download_unpack_base)\n \n \n # Main\n@@ -48,23 +52,27 @@ def unpack_snapshot(triple, dl_path):\n # The first is the O/S triple.\n # The second is an optional path to the snapshot to use.\n \n-triple = sys.argv[1]\n-if len(sys.argv) == 3:\n-  dl_path = sys.argv[2]\n-else:\n-  snap = determine_curr_snapshot(triple)\n-  dl = os.path.join(download_dir_base, snap)\n-  url = download_url_base + \"/\" + snap\n-  print(\"determined most recent snapshot: \" + snap)\n+def main(argv):\n+    triple = argv[1]\n+    if len(argv) == 3:\n+        dl_path = argv[2]\n+    else:\n+        snap = determine_curr_snapshot(triple)\n+        dl = os.path.join(download_dir_base, snap)\n+        url = download_url_base + \"/\" + snap\n+        print(\"determined most recent snapshot: \" + snap)\n+\n+        if (not os.path.exists(dl)):\n+            get_url_to_file(url, dl)\n \n-  if (not os.path.exists(dl)):\n-    get_url_to_file(url, dl)\n+        if (snap_filename_hash_part(snap) == hash_file(dl)):\n+            print(\"got download with ok hash\")\n+        else:\n+            raise Exception(\"bad hash on download\")\n \n-  if (snap_filename_hash_part(snap) == hash_file(dl)):\n-    print(\"got download with ok hash\")\n-  else:\n-    raise Exception(\"bad hash on download\")\n+        dl_path = os.path.join(download_dir_base, snap)\n \n-  dl_path = os.path.join(download_dir_base, snap)\n+    unpack_snapshot(triple, dl_path)\n \n-unpack_snapshot(triple, dl_path)\n+if __name__ == '__main__':\n+    main(sys.argv)"}, {"sha": "22792ff76355149b4ee8eb006fba37618b094caf", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -118,40 +118,54 @@\n VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n                      'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'])\n \n-# simplified HTML parser.\n-# this is possible because we are dealing with very regular HTML from rustdoc;\n-# we only have to deal with i) void elements and ii) empty attributes.\n+\n class CustomHTMLParser(HTMLParser):\n+    \"\"\"simplified HTML parser.\n+\n+    this is possible because we are dealing with very regular HTML from\n+    rustdoc; we only have to deal with i) void elements and ii) empty\n+    attributes.\"\"\"\n     def __init__(self, target=None):\n         HTMLParser.__init__(self)\n         self.__builder = target or ET.TreeBuilder()\n+\n     def handle_starttag(self, tag, attrs):\n         attrs = dict((k, v or '') for k, v in attrs)\n         self.__builder.start(tag, attrs)\n-        if tag in VOID_ELEMENTS: self.__builder.end(tag)\n+        if tag in VOID_ELEMENTS:\n+            self.__builder.end(tag)\n+\n     def handle_endtag(self, tag):\n         self.__builder.end(tag)\n+\n     def handle_startendtag(self, tag, attrs):\n         attrs = dict((k, v or '') for k, v in attrs)\n         self.__builder.start(tag, attrs)\n         self.__builder.end(tag)\n+\n     def handle_data(self, data):\n         self.__builder.data(data)\n+\n     def handle_entityref(self, name):\n         self.__builder.data(entitydefs[name])\n+\n     def handle_charref(self, name):\n         code = int(name[1:], 16) if name.startswith(('x', 'X')) else int(name, 10)\n         self.__builder.data(unichr(code).encode('utf-8'))\n+\n     def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n Command = namedtuple('Command', 'negated cmd args lineno')\n \n-# returns a generator out of the file object, which\n-# - removes `\\\\` then `\\n` then a shared prefix with the previous line then optional whitespace;\n-# - keeps a line number (starting from 0) of the first line being concatenated.\n+\n def concat_multi_lines(f):\n+    \"\"\"returns a generator out of the file object, which\n+    - removes `\\\\` then `\\n` then a shared prefix with the previous line then\n+      optional whitespace;\n+    - keeps a line number (starting from 0) of the first line being\n+      concatenated.\"\"\"\n     lastline = None # set to the last line when the last line has a backslash\n     firstlineno = None\n     catenated = ''\n@@ -162,7 +176,8 @@ def concat_multi_lines(f):\n         if lastline is not None:\n             maxprefix = 0\n             for i in xrange(min(len(line), len(lastline))):\n-                if line[i] != lastline[i]: break\n+                if line[i] != lastline[i]:\n+                    break\n                 maxprefix += 1\n             line = line[maxprefix:].lstrip()\n \n@@ -184,11 +199,14 @@ def concat_multi_lines(f):\n     (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n     (?P<args>.*)$\n ''', re.X)\n+\n+\n def get_commands(template):\n     with open(template, 'rUb') as f:\n         for lineno, line in concat_multi_lines(f):\n             m = LINE_PATTERN.search(line)\n-            if not m: continue\n+            if not m:\n+                continue\n \n             negated = (m.group('negated') == '!')\n             cmd = m.group('cmd')\n@@ -198,17 +216,22 @@ def get_commands(template):\n             args = shlex.split(args)\n             yield Command(negated=negated, cmd=cmd, args=args, lineno=lineno+1)\n \n+\n def _flatten(node, acc):\n-    if node.text: acc.append(node.text)\n+    if node.text:\n+        acc.append(node.text)\n     for e in node:\n         _flatten(e, acc)\n-        if e.tail: acc.append(e.tail)\n+        if e.tail:\n+            acc.append(e.tail)\n+\n \n def flatten(node):\n     acc = []\n     _flatten(node, acc)\n     return ''.join(acc)\n \n+\n def normalize_xpath(path):\n     if path.startswith('//'):\n         return '.' + path # avoid warnings\n@@ -218,6 +241,7 @@ def normalize_xpath(path):\n         raise RuntimeError('Non-absolute XPath is not supported due to \\\n                             the implementation issue.')\n \n+\n class CachedFiles(object):\n     def __init__(self, root):\n         self.root = root\n@@ -267,6 +291,7 @@ def get_tree(self, path):\n                 self.trees[path] = tree\n                 return self.trees[path]\n \n+\n def check_string(data, pat, regexp):\n     if not pat:\n         return True # special case a presence testing\n@@ -277,6 +302,7 @@ def check_string(data, pat, regexp):\n         pat = ' '.join(pat.split())\n         return pat in data\n \n+\n def check_tree_attr(tree, path, attr, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n@@ -287,9 +313,11 @@ def check_tree_attr(tree, path, attr, pat, regexp):\n             continue\n         else:\n             ret = check_string(value, pat, regexp)\n-            if ret: break\n+            if ret:\n+                break\n     return ret\n \n+\n def check_tree_text(tree, path, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n@@ -300,9 +328,11 @@ def check_tree_text(tree, path, pat, regexp):\n             continue\n         else:\n             ret = check_string(value, pat, regexp)\n-            if ret: break\n+            if ret:\n+                break\n     return ret\n \n+\n def check(target, commands):\n     cache = CachedFiles(target)\n     for c in commands:\n@@ -323,7 +353,8 @@ def check(target, commands):\n                     ret = check_tree_attr(cache.get_tree(c.args[0]), pat, attr, c.args[2], regexp)\n                 else: # normalized text\n                     pat = c.args[1]\n-                    if pat.endswith('/text()'): pat = pat[:-7]\n+                    if pat.endswith('/text()'):\n+                        pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n                 raise RuntimeError('Invalid number of @{} arguments \\\n@@ -348,4 +379,3 @@ def check(target, commands):\n         raise SystemExit(1)\n     else:\n         check(sys.argv[1], get_commands(sys.argv[2]))\n-"}, {"sha": "6c93bf23f900fc2db196172243ea5711c9206e65", "filename": "src/etc/latest-unix-snaps.py", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Flatest-unix-snaps.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Flatest-unix-snaps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flatest-unix-snaps.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -10,7 +10,8 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import os, tarfile, hashlib, re, shutil, sys\n+import os\n+import re\n from snapshot import *\n \n f = open(snapshotfile)\n@@ -26,7 +27,8 @@\n for line in f.readlines():\n     i += 1\n     parsed = parse_line(i, line)\n-    if (not parsed): continue\n+    if not parsed:\n+        continue\n \n     if parsed[\"type\"] == \"snapshot\":\n         if (len(newestSet) == 0 or parsed[\"date\"] > newestSet[\"date\"]):\n@@ -37,16 +39,16 @@\n         else:\n             addingMode = False\n \n-    elif addingMode == True and parsed[\"type\"] == \"file\":\n+    elif addingMode is True and parsed[\"type\"] == \"file\":\n         tux = re.compile(\"linux\", re.IGNORECASE)\n-        if (tux.match(parsed[\"platform\"]) != None):\n-           ff = {}\n-           ff[\"platform\"] = parsed[\"platform\"]\n-           ff[\"hash\"] = parsed[\"hash\"]\n-           newestSet[\"files\"] += [ff]\n+        if (tux.match(parsed[\"platform\"]) is not None):\n+            ff = {}\n+            ff[\"platform\"] = parsed[\"platform\"]\n+            ff[\"hash\"] = parsed[\"hash\"]\n+            newestSet[\"files\"] += [ff]\n \n \n-def download_new_file (date, rev, platform, hsh):\n+def download_new_file(date, rev, platform, hsh):\n         snap = full_snapshot_name(date, rev, platform, hsh)\n         dl = os.path.join(download_dir_base, snap)\n         url = download_url_base + \"/\" + snap\n@@ -59,5 +61,5 @@ def download_new_file (date, rev, platform, hsh):\n             raise Exception(\"bad hash on download\")\n \n for ff in newestSet[\"files\"]:\n-   download_new_file (newestSet[\"date\"], newestSet[\"rev\"],\n+    download_new_file(newestSet[\"date\"], newestSet[\"rev\"],\n                       ff[\"platform\"], ff[\"hash\"])"}, {"sha": "b1506285b3ac1a9e47fc44b7a794d11183fb9d50", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 112, "deletions": 106, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -30,36 +30,35 @@\n import threading\n import thread\n import re\n-import atexit\n import time\n \n # Set this to True for additional output\n DEBUG_OUTPUT = False\n \n+\n def print_debug(s):\n-  \"Print something if DEBUG_OUTPUT is True\"\n-  global DEBUG_OUTPUT\n-  if DEBUG_OUTPUT:\n-    print(\"DEBUG: \" + str(s))\n+    \"Print something if DEBUG_OUTPUT is True\"\n+    global DEBUG_OUTPUT\n+    if DEBUG_OUTPUT:\n+        print(\"DEBUG: \" + str(s))\n \n \n def normalize_whitespace(s):\n-  \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n-  return re.sub(\"\\s+\", \" \", s)\n+    \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n+    return re.sub(\"\\s+\", \" \", s)\n \n \n-# This callback is registered with every breakpoint and makes sure that the frame containing the\n-# breakpoint location is selected\n def breakpoint_callback(frame, bp_loc, dict):\n-  \"Called whenever a breakpoint is hit\"\n-  print(\"Hit breakpoint \" + str(bp_loc))\n+    \"\"\"This callback is registered with every breakpoint and makes sure that the\n+    frame containing the breakpoint location is selected\"\"\"\n+    print(\"Hit breakpoint \" + str(bp_loc))\n \n-  # Select the frame and the thread containing it\n-  frame.thread.process.SetSelectedThread(frame.thread)\n-  frame.thread.SetSelectedFrame(frame.idx)\n+    # Select the frame and the thread containing it\n+    frame.thread.process.SetSelectedThread(frame.thread)\n+    frame.thread.SetSelectedFrame(frame.idx)\n \n-  # Returning True means that we actually want to stop at this breakpoint\n-  return True\n+    # Returning True means that we actually want to stop at this breakpoint\n+    return True\n \n \n # This is a list of breakpoints that are not registered with the breakpoint callback. The list is\n@@ -70,91 +69,99 @@ def breakpoint_callback(frame, bp_loc, dict):\n # used to avoid hooking callbacks into breakpoints more than once\n registered_breakpoints = set()\n \n+\n def execute_command(command_interpreter, command):\n-  \"Executes a single CLI command\"\n-  global new_breakpoints\n-  global registered_breakpoints\n-\n-  res = lldb.SBCommandReturnObject()\n-  print(command)\n-  command_interpreter.HandleCommand(command, res)\n-\n-  if res.Succeeded():\n-      if res.HasResult():\n-          print(normalize_whitespace(res.GetOutput()), end = '\\n')\n-\n-      # If the command introduced any breakpoints, make sure to register them with the breakpoint\n-      # callback\n-      while len(new_breakpoints) > 0:\n-        res.Clear()\n-        breakpoint_id = new_breakpoints.pop()\n-\n-        if breakpoint_id in registered_breakpoints:\n-          print_debug(\"breakpoint with id %s is already registered. Ignoring.\" % str(breakpoint_id))\n-        else:\n-          print_debug(\"registering breakpoint callback, id = \" + str(breakpoint_id))\n-          callback_command = \"breakpoint command add -F breakpoint_callback \" + str(breakpoint_id)\n-          command_interpreter.HandleCommand(callback_command, res)\n-          if res.Succeeded():\n-            print_debug(\"successfully registered breakpoint callback, id = \" + str(breakpoint_id))\n-            registered_breakpoints.add(breakpoint_id)\n-          else:\n-            print(\"Error while trying to register breakpoint callback, id = \" + str(breakpoint_id))\n-  else:\n-      print(res.GetError())\n+    \"Executes a single CLI command\"\n+    global new_breakpoints\n+    global registered_breakpoints\n+\n+    res = lldb.SBCommandReturnObject()\n+    print(command)\n+    command_interpreter.HandleCommand(command, res)\n+\n+    if res.Succeeded():\n+        if res.HasResult():\n+            print(normalize_whitespace(res.GetOutput()), end='\\n')\n+\n+        # If the command introduced any breakpoints, make sure to register\n+        # them with the breakpoint\n+        # callback\n+        while len(new_breakpoints) > 0:\n+            res.Clear()\n+            breakpoint_id = new_breakpoints.pop()\n+\n+            if breakpoint_id in registered_breakpoints:\n+                print_debug(\"breakpoint with id %s is already registered. Ignoring.\" %\n+                            str(breakpoint_id))\n+            else:\n+                print_debug(\"registering breakpoint callback, id = \" + str(breakpoint_id))\n+                callback_command = (\"breakpoint command add -F breakpoint_callback \" +\n+                                    str(breakpoint_id))\n+                command_interpreter.HandleCommand(callback_command, res)\n+                if res.Succeeded():\n+                    print_debug(\"successfully registered breakpoint callback, id = \" +\n+                                str(breakpoint_id))\n+                    registered_breakpoints.add(breakpoint_id)\n+                else:\n+                    print(\"Error while trying to register breakpoint callback, id = \" +\n+                          str(breakpoint_id))\n+    else:\n+        print(res.GetError())\n \n \n def start_breakpoint_listener(target):\n-  \"Listens for breakpoints being added and adds new ones to the callback registration list\"\n-  listener = lldb.SBListener(\"breakpoint listener\")\n-\n-  def listen():\n-    event = lldb.SBEvent()\n-    try:\n-      while True:\n-        if listener.WaitForEvent(120, event):\n-          if lldb.SBBreakpoint.EventIsBreakpointEvent(event) and \\\n-             lldb.SBBreakpoint.GetBreakpointEventTypeFromEvent(event) == \\\n-             lldb.eBreakpointEventTypeAdded:\n-            global new_breakpoints\n-            breakpoint = lldb.SBBreakpoint.GetBreakpointFromEvent(event)\n-            print_debug(\"breakpoint added, id = \" + str(breakpoint.id))\n-            new_breakpoints.append(breakpoint.id)\n-    except:\n-      print_debug(\"breakpoint listener shutting down\")\n-\n-  # Start the listener and let it run as a daemon\n-  listener_thread = threading.Thread(target = listen)\n-  listener_thread.daemon = True\n-  listener_thread.start()\n-\n-  # Register the listener with the target\n-  target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n+    \"\"\"Listens for breakpoints being added and adds new ones to the callback\n+    registration list\"\"\"\n+    listener = lldb.SBListener(\"breakpoint listener\")\n+\n+    def listen():\n+        event = lldb.SBEvent()\n+        try:\n+            while True:\n+                if listener.WaitForEvent(120, event):\n+                    if lldb.SBBreakpoint.EventIsBreakpointEvent(event) and \\\n+                            lldb.SBBreakpoint.GetBreakpointEventTypeFromEvent(event) == \\\n+                            lldb.eBreakpointEventTypeAdded:\n+                        global new_breakpoints\n+                        breakpoint = lldb.SBBreakpoint.GetBreakpointFromEvent(event)\n+                        print_debug(\"breakpoint added, id = \" + str(breakpoint.id))\n+                        new_breakpoints.append(breakpoint.id)\n+        except:\n+            print_debug(\"breakpoint listener shutting down\")\n+\n+    # Start the listener and let it run as a daemon\n+    listener_thread = threading.Thread(target=listen)\n+    listener_thread.daemon = True\n+    listener_thread.start()\n+\n+    # Register the listener with the target\n+    target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n \n \n def start_watchdog():\n-  \"Starts a watchdog thread that will terminate the process after a certain period of time\"\n-  watchdog_start_time = time.clock()\n-  watchdog_max_time = watchdog_start_time + 30\n-\n-  def watchdog():\n-    while time.clock() < watchdog_max_time:\n-      time.sleep(1)\n-    print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n-    thread.interrupt_main()\n-\n-  # Start the listener and let it run as a daemon\n-  watchdog_thread = threading.Thread(target = watchdog)\n-  watchdog_thread.daemon = True\n-  watchdog_thread.start()\n+    \"\"\"Starts a watchdog thread that will terminate the process after a certain\n+    period of time\"\"\"\n+    watchdog_start_time = time.clock()\n+    watchdog_max_time = watchdog_start_time + 30\n+\n+    def watchdog():\n+        while time.clock() < watchdog_max_time:\n+            time.sleep(1)\n+        print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n+        thread.interrupt_main()\n+\n+    # Start the listener and let it run as a daemon\n+    watchdog_thread = threading.Thread(target=watchdog)\n+    watchdog_thread.daemon = True\n+    watchdog_thread.start()\n \n ####################################################################################################\n # ~main\n ####################################################################################################\n \n if len(sys.argv) != 3:\n-  print(\"usage: python lldb_batchmode.py target-path script-path\")\n-  sys.exit(1)\n+    print(\"usage: python lldb_batchmode.py target-path script-path\")\n+    sys.exit(1)\n \n target_path = sys.argv[1]\n script_path = sys.argv[2]\n@@ -181,9 +188,9 @@ def watchdog():\n target = debugger.CreateTarget(target_path, None, None, True, target_error)\n \n if not target:\n-  print(\"Could not create debugging target '\" + target_path + \"': \" + str(target_error) +\n-        \". Aborting.\", file=sys.stderr)\n-  sys.exit(1)\n+    print(\"Could not create debugging target '\" + target_path + \"': \" +\n+          str(target_error) + \". Aborting.\", file=sys.stderr)\n+    sys.exit(1)\n \n \n # Register the breakpoint callback for every breakpoint\n@@ -192,22 +199,21 @@ def watchdog():\n command_interpreter = debugger.GetCommandInterpreter()\n \n try:\n-  script_file = open(script_path, 'r')\n+    script_file = open(script_path, 'r')\n \n-  for line in script_file:\n-    command = line.strip()\n-    if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n-      # Before starting to run the program, let the thread sleep a bit, so all\n-      # breakpoint added events can be processed\n-      time.sleep(0.5)\n-    if command != '':\n-      execute_command(command_interpreter, command)\n+    for line in script_file:\n+        command = line.strip()\n+        if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n+            # Before starting to run the program, let the thread sleep a bit, so all\n+            # breakpoint added events can be processed\n+            time.sleep(0.5)\n+        if command != '':\n+            execute_command(command_interpreter, command)\n \n except IOError as e:\n-  print(\"Could not read debugging script '%s'.\" % script_path, file = sys.stderr)\n-  print(e, file = sys.stderr)\n-  print(\"Aborting.\", file = sys.stderr)\n-  sys.exit(1)\n+    print(\"Could not read debugging script '%s'.\" % script_path, file=sys.stderr)\n+    print(e, file=sys.stderr)\n+    print(\"Aborting.\", file=sys.stderr)\n+    sys.exit(1)\n finally:\n-  script_file.close()\n-\n+    script_file.close()"}, {"sha": "42c83b6a42ed6f6df6ad7ec765fa5eb5e809b897", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 171, "deletions": 169, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -10,186 +10,189 @@\n \n import lldb\n \n+\n def print_val(val, internal_dict):\n-  '''Prints the given value with Rust syntax'''\n-  type_class = val.GetType().GetTypeClass()\n+    '''Prints the given value with Rust syntax'''\n+    type_class = val.GetType().GetTypeClass()\n \n-  if type_class == lldb.eTypeClassStruct:\n-    return print_struct_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassStruct:\n+        return print_struct_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassUnion:\n-    return print_enum_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassUnion:\n+        return print_enum_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassPointer:\n-    return print_pointer_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassPointer:\n+        return print_pointer_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassArray:\n-    return print_fixed_size_vec_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassArray:\n+        return print_fixed_size_vec_val(val, internal_dict)\n \n-  return val.GetValue()\n+    return val.GetValue()\n \n \n #=--------------------------------------------------------------------------------------------------\n # Type-Specialized Printing Functions\n #=--------------------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict):\n-  '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+    '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+\n+    if is_vec_slice(val):\n+        return print_vec_slice_val(val, internal_dict)\n+    else:\n+        return print_struct_val_starting_from(0, val, internal_dict)\n \n-  if is_vec_slice(val):\n-    return print_vec_slice_val(val, internal_dict)\n-  else:\n-    return print_struct_val_starting_from(0, val, internal_dict)\n \n def print_vec_slice_val(val, internal_dict):\n-  length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n+    length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n \n-  data_ptr_val = val.GetChildAtIndex(0)\n-  data_ptr_type = data_ptr_val.GetType()\n-  assert data_ptr_type.IsPointerType()\n+    data_ptr_val = val.GetChildAtIndex(0)\n+    data_ptr_type = data_ptr_val.GetType()\n+    assert data_ptr_type.IsPointerType()\n \n-  element_type = data_ptr_type.GetPointeeType()\n-  element_type_size = element_type.GetByteSize()\n+    element_type = data_ptr_type.GetPointeeType()\n+    element_type_size = element_type.GetByteSize()\n \n-  start_address = data_ptr_val.GetValueAsUnsigned()\n+    start_address = data_ptr_val.GetValueAsUnsigned()\n \n-  def render_element(i):\n-    address = start_address + i * element_type_size\n-    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type)\n-    return print_val(element_val, internal_dict)\n+    def render_element(i):\n+        address = start_address + i * element_type_size\n+        element_val = val.CreateValueFromAddress(val.GetName() +\n+                                                 (\"[%s]\" % i), address, element_type)\n+        return print_val(element_val, internal_dict)\n \n-  return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n+    return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n \n-def print_struct_val_starting_from(field_start_index, val, internal_dict):\n-  '''\n-  Prints a struct, tuple, or tuple struct value with Rust syntax.\n-  Ignores any fields before field_start_index.\n-  '''\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n-\n-  t = val.GetType()\n-  type_name = extract_type_name(t.GetName())\n-  num_children = val.num_children\n-\n-  if (num_children - field_start_index) == 0:\n-    # The only field of this struct is the enum discriminant\n-    return type_name\n-\n-  has_field_names = type_has_field_names(t)\n-\n-  if has_field_names:\n-    template = \"%(type_name)s {\\n%(body)s\\n}\"\n-    separator = \", \\n\"\n-  else:\n-    template = \"%(type_name)s(%(body)s)\"\n-    separator = \", \"\n-\n-  if type_name.startswith(\"(\"):\n-    # this is a tuple, so don't print the type name\n-    type_name = \"\"\n-\n-  def render_child(child_index):\n-    this = \"\"\n-    if has_field_names:\n-      field_name = t.GetFieldAtIndex(child_index).GetName()\n-      this += field_name + \": \"\n \n-    field_val = val.GetChildAtIndex(child_index)\n-    return this + print_val(field_val, internal_dict)\n+def print_struct_val_starting_from(field_start_index, val, internal_dict):\n+    '''\n+    Prints a struct, tuple, or tuple struct value with Rust syntax.\n+    Ignores any fields before field_start_index.\n+    '''\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n \n-  body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+    t = val.GetType()\n+    type_name = extract_type_name(t.GetName())\n+    num_children = val.num_children\n \n-  return template % {\"type_name\": type_name,\n-                     \"body\": body}\n+    if (num_children - field_start_index) == 0:\n+        # The only field of this struct is the enum discriminant\n+        return type_name\n \n+    has_field_names = type_has_field_names(t)\n \n-def print_enum_val(val, internal_dict):\n-  '''Prints an enum value with Rust syntax'''\n-\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n-\n-  if val.num_children == 1:\n-    # This is either an enum with just one variant, or it is an Option-like enum\n-    # where the discriminant is encoded in a non-nullable pointer field. We find\n-    # out which one it is by looking at the member name of the sole union\n-    # variant. If it starts with \"RUST$ENCODED$ENUM$\" then we have an\n-    # Option-like enum.\n-    first_variant_name = val.GetChildAtIndex(0).GetName()\n-    if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n-\n-      # This is an Option-like enum. The position of the discriminator field is\n-      # encoded in the name which has the format:\n-      #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n-      last_separator_index = first_variant_name.rfind(\"$\")\n-      if last_separator_index == -1:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-      start_index = len(\"RUST$ENCODED$ENUM$\")\n-\n-      # Extract indices of the discriminator field\n-      try:\n-        disr_field_indices = first_variant_name[start_index :\n-                                              last_separator_index].split(\"$\")\n-        disr_field_indices = [int(index) for index in disr_field_indices]\n-      except:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-      # Read the discriminant\n-      disr_val = val.GetChildAtIndex(0)\n-      for index in disr_field_indices:\n-        disr_val = disr_val.GetChildAtIndex(index)\n-\n-      # If the discriminant field is a fat pointer we have to consider the\n-      # first word as the true discriminant\n-      if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n-        disr_val = disr_val.GetChildAtIndex(0)\n-\n-      if disr_val.GetValueAsUnsigned() == 0:\n-        # Null case: Print the name of the null-variant\n-        null_variant_name = first_variant_name[last_separator_index + 1:]\n-        return null_variant_name\n-      else:\n-        # Non-null case: Interpret the data as a value of the non-null variant type\n-        return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+    if has_field_names:\n+        template = \"%(type_name)s {\\n%(body)s\\n}\"\n+        separator = \", \\n\"\n     else:\n-      # This is just a regular uni-variant enum without discriminator field\n-      return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+        template = \"%(type_name)s(%(body)s)\"\n+        separator = \", \"\n+\n+    if type_name.startswith(\"(\"):\n+        # this is a tuple, so don't print the type name\n+        type_name = \"\"\n \n-  # If we are here, this is a regular enum with more than one variant\n-  disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n-  disr_type = disr_val.GetType()\n+    def render_child(child_index):\n+        this = \"\"\n+        if has_field_names:\n+            field_name = t.GetFieldAtIndex(child_index).GetName()\n+            this += field_name + \": \"\n \n-  if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n-    return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+        field_val = val.GetChildAtIndex(child_index)\n+        return this + print_val(field_val, internal_dict)\n \n-  variant_index = disr_val.GetValueAsUnsigned()\n-  return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n+    body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+\n+    return template % {\"type_name\": type_name,\n+                       \"body\": body}\n+\n+\n+def print_enum_val(val, internal_dict):\n+    '''Prints an enum value with Rust syntax'''\n+\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n+\n+    if val.num_children == 1:\n+        # This is either an enum with just one variant, or it is an Option-like\n+        # enum where the discriminant is encoded in a non-nullable pointer\n+        # field. We find out which one it is by looking at the member name of\n+        # the sole union variant. If it starts with \"RUST$ENCODED$ENUM$\" then\n+        # we have an Option-like enum.\n+        first_variant_name = val.GetChildAtIndex(0).GetName()\n+        if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n+\n+            # This is an Option-like enum. The position of the discriminator field is\n+            # encoded in the name which has the format:\n+            #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n+            last_separator_index = first_variant_name.rfind(\"$\")\n+            if last_separator_index == -1:\n+                return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+            start_index = len(\"RUST$ENCODED$ENUM$\")\n+\n+            # Extract indices of the discriminator field\n+            try:\n+                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n+                disr_field_indices = [int(index) for index in disr_field_indices]\n+            except:\n+                return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+            # Read the discriminant\n+            disr_val = val.GetChildAtIndex(0)\n+            for index in disr_field_indices:\n+                disr_val = disr_val.GetChildAtIndex(index)\n+\n+            # If the discriminant field is a fat pointer we have to consider the\n+            # first word as the true discriminant\n+            if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n+                disr_val = disr_val.GetChildAtIndex(0)\n+\n+            if disr_val.GetValueAsUnsigned() == 0:\n+                # Null case: Print the name of the null-variant\n+                null_variant_name = first_variant_name[last_separator_index + 1:]\n+                return null_variant_name\n+            else:\n+                # Non-null case: Interpret the data as a value of the non-null variant type\n+                return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+        else:\n+            # This is just a regular uni-variant enum without discriminator field\n+            return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+\n+    # If we are here, this is a regular enum with more than one variant\n+    disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n+    disr_type = disr_val.GetType()\n+\n+    if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n+        return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+\n+    variant_index = disr_val.GetValueAsUnsigned()\n+    return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n \n \n def print_pointer_val(val, internal_dict):\n-  '''Prints a pointer value with Rust syntax'''\n-  assert val.GetType().IsPointerType()\n-  sigil = \"&\"\n-  type_name = extract_type_name(val.GetType().GetName())\n-  if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n-    sigil = type_name[0:1]\n+    '''Prints a pointer value with Rust syntax'''\n+    assert val.GetType().IsPointerType()\n+    sigil = \"&\"\n+    type_name = extract_type_name(val.GetType().GetName())\n+    if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n+        sigil = type_name[0:1]\n \n-  return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n+    return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n \n \n def print_fixed_size_vec_val(val, internal_dict):\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n \n-  output = \"[\"\n+    output = \"[\"\n \n-  for i in range(val.num_children):\n-    output += print_val(val.GetChildAtIndex(i), internal_dict)\n-    if i != val.num_children - 1:\n-      output += \", \"\n+    for i in range(val.num_children):\n+        output += print_val(val.GetChildAtIndex(i), internal_dict)\n+        if i != val.num_children - 1:\n+            output += \", \"\n \n-  output += \"]\"\n-  return output\n+    output += \"]\"\n+    return output\n \n \n #=--------------------------------------------------------------------------------------------------\n@@ -198,46 +201,45 @@ def print_fixed_size_vec_val(val, internal_dict):\n \n unqualified_type_markers = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n+\n def extract_type_name(qualified_type_name):\n-  '''Extracts the type name from a fully qualified path'''\n-  if qualified_type_name[0] in unqualified_type_markers:\n-    return qualified_type_name\n+    '''Extracts the type name from a fully qualified path'''\n+    if qualified_type_name[0] in unqualified_type_markers:\n+        return qualified_type_name\n \n-  end_of_search = qualified_type_name.find(\"<\")\n-  if end_of_search < 0:\n-    end_of_search = len(qualified_type_name)\n+    end_of_search = qualified_type_name.find(\"<\")\n+    if end_of_search < 0:\n+        end_of_search = len(qualified_type_name)\n \n-  index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n-  if index < 0:\n-    return qualified_type_name\n-  else:\n-    return qualified_type_name[index + 2:]\n+    index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n+    if index < 0:\n+        return qualified_type_name\n+    else:\n+        return qualified_type_name[index + 2:]\n \n \n def type_has_field_names(ty):\n-  '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n-  # This may also be an enum variant where the first field doesn't have a name but the rest has\n-  if ty.GetNumberOfFields() > 1:\n-    return ty.GetFieldAtIndex(1).GetName() != None\n-  else:\n-    return ty.GetFieldAtIndex(0).GetName() != None\n+    '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n+    # This may also be an enum variant where the first field doesn't have a name but the rest has\n+    if ty.GetNumberOfFields() > 1:\n+        return ty.GetFieldAtIndex(1).GetName() is not None\n+    else:\n+        return ty.GetFieldAtIndex(0).GetName() is not None\n \n \n def is_vec_slice(val):\n-  ty = val.GetType()\n-  if ty.GetTypeClass() != lldb.eTypeClassStruct:\n-    return False\n-\n-  if ty.GetNumberOfFields() != 2:\n-    return False\n+    ty = val.GetType()\n+    if ty.GetTypeClass() != lldb.eTypeClassStruct:\n+        return False\n \n-  if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n-    return False\n+    if ty.GetNumberOfFields() != 2:\n+        return False\n \n-  if ty.GetFieldAtIndex(1).GetName() != \"length\":\n-    return False\n+    if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n+        return False\n \n-  type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n-  return type_name.startswith(\"&[\") and type_name.endswith(\"]\")\n+    if ty.GetFieldAtIndex(1).GetName() != \"length\":\n+        return False\n \n-# vi: sw=2:ts=2\n+    type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n+    return type_name.startswith(\"&[\") and type_name.endswith(\"]\")"}, {"sha": "13d051350248871d19e2f0268685af5050e6cb1e", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -14,7 +14,11 @@\n #     argv[3] = target triple\n # The first two correspond to the two installable components defined in the setup script.\n \n-import sys, os, shutil, subprocess\n+import sys\n+import os\n+import shutil\n+import subprocess\n+\n \n def find_files(files, path):\n     found = []\n@@ -28,6 +32,7 @@ def find_files(files, path):\n             raise Exception(\"Could not find '%s' in %s\" % (fname, path))\n     return found\n \n+\n def make_win_dist(rust_root, gcc_root, target_triple):\n     # Ask gcc where it keeps its stuff\n     gcc_out = subprocess.check_output([\"gcc.exe\", \"-print-search-dirs\"])\n@@ -114,5 +119,5 @@ def make_win_dist(rust_root, gcc_root, target_triple):\n     for src in target_libs:\n         shutil.copy(src, target_lib_dir)\n \n-if __name__==\"__main__\":\n+if __name__ == \"__main__\":\n     make_win_dist(sys.argv[1], sys.argv[2], sys.argv[3])"}, {"sha": "f500de5e15d00c623784a62c8662c3ca0c2ab982", "filename": "src/etc/maketest.py", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmaketest.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmaketest.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmaketest.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -12,13 +12,14 @@\n import os\n import sys\n \n-# msys1/msys2 automatically converts `/abs/path1:/abs/path2` into\n-# `c:\\real\\abs\\path1;c:\\real\\abs\\path2` (semicolons) if shell thinks\n-# the value is list of paths.\n-# (if there is only one path, it becomes `c:/real/abs/path`.)\n-# this causes great confusion and error: shell and Makefile doesn't like\n-# windows paths so it is really error-prone. revert it for peace.\n+\n def normalize_path(v):\n+    \"\"\"msys1/msys2 automatically converts `/abs/path1:/abs/path2` into\n+    `c:\\real\\abs\\path1;c:\\real\\abs\\path2` (semicolons) if shell thinks\n+    the value is list of paths.\n+    (if there is only one path, it becomes `c:/real/abs/path`.)\n+    this causes great confusion and error: shell and Makefile doesn't like\n+    windows paths so it is really error-prone. revert it for peace.\"\"\"\n     v = v.replace('\\\\', '/')\n     # c:/path -> /c/path\n     if ':/' in v:\n@@ -31,6 +32,7 @@ def putenv(name, value):\n         value = normalize_path(value)\n     os.putenv(name, value)\n \n+\n def convert_path_spec(name, value):\n     if os.name == 'nt' and name != 'PATH':\n         value = \":\".join(normalize_path(v) for v in value.split(\";\"))\n@@ -42,14 +44,14 @@ def convert_path_spec(name, value):\n putenv('CC', sys.argv[5])\n putenv('RUSTDOC', os.path.abspath(sys.argv[6]))\n filt = sys.argv[7]\n-putenv('LD_LIB_PATH_ENVVAR', sys.argv[8]);\n-putenv('HOST_RPATH_DIR', os.path.abspath(sys.argv[9]));\n-putenv('TARGET_RPATH_DIR', os.path.abspath(sys.argv[10]));\n+putenv('LD_LIB_PATH_ENVVAR', sys.argv[8])\n+putenv('HOST_RPATH_DIR', os.path.abspath(sys.argv[9]))\n+putenv('TARGET_RPATH_DIR', os.path.abspath(sys.argv[10]))\n putenv('RUST_BUILD_STAGE', sys.argv[11])\n putenv('S', os.path.abspath(sys.argv[12]))\n putenv('PYTHON', sys.executable)\n \n-if not filt in sys.argv[1]:\n+if filt not in sys.argv[1]:\n     sys.exit(0)\n print('maketest: ' + os.path.basename(os.path.dirname(sys.argv[1])))\n \n@@ -63,19 +65,19 @@ def convert_path_spec(name, value):\n     path = path[:-1]\n \n proc = subprocess.Popen([make, '-C', path],\n-                        stdout = subprocess.PIPE,\n-                        stderr = subprocess.PIPE)\n+                        stdout=subprocess.PIPE,\n+                        stderr=subprocess.PIPE)\n out, err = proc.communicate()\n i = proc.wait()\n \n if i != 0:\n-\n-    print '----- ' + sys.argv[1] + \"\"\" --------------------\n+    print \"\"\"\\\n+----- %s --------------------\n ------ stdout ---------------------------------------------\n-\"\"\" + out + \"\"\"\n+%s\n ------ stderr ---------------------------------------------\n-\"\"\" + err + \"\"\"\n+%s\n ------        ---------------------------------------------\n-\"\"\"\n-    sys.exit(i)\n+\"\"\" % (sys.argv[1], out, err)\n \n+    sys.exit(i)"}, {"sha": "cd77f882140fef67446d2798c3927fb9b8148bb5", "filename": "src/etc/mirror-all-snapshots.py", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmirror-all-snapshots.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmirror-all-snapshots.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmirror-all-snapshots.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -10,7 +10,7 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import os, tarfile, hashlib, re, shutil\n+import os\n from snapshot import *\n \n f = open(snapshotfile)\n@@ -23,13 +23,14 @@\n for line in f.readlines():\n     i += 1\n     parsed = parse_line(i, line)\n-    if (not parsed): continue\n+    if not parsed:\n+        continue\n \n     if parsed[\"type\"] == \"snapshot\":\n         date = parsed[\"date\"]\n         rev = parsed[\"rev\"]\n \n-    elif rev != None and parsed[\"type\"] == \"file\":\n+    elif rev is not None and parsed[\"type\"] == \"file\":\n         platform = parsed[\"platform\"]\n         hsh = parsed[\"hash\"]\n         snap = full_snapshot_name(date, rev, platform, hsh)"}, {"sha": "a4234159cb81c9ee624df8b7e4b10aab01aa0788", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -11,8 +11,6 @@\n import os\n import sys\n import subprocess\n-import itertools\n-from os import path\n \n f = open(sys.argv[1], 'wb')\n \n@@ -35,6 +33,7 @@\n //          take a look at src/etc/mklldeps.py if you're interested\n \"\"\")\n \n+\n def run(args):\n     proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n     out, err = proc.communicate()"}, {"sha": "698c3a551e2a0736fd7d6550557e033fb0ab9a3a", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 153, "deletions": 132, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -8,79 +8,90 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import re, os, sys, glob, tarfile, shutil, subprocess, tempfile, distutils.spawn\n+import re\n+import os\n+import sys\n+import glob\n+import tarfile\n+import shutil\n+import subprocess\n+import distutils.spawn\n \n try:\n-  import hashlib\n-  sha_func = hashlib.sha1\n+    import hashlib\n+    sha_func = hashlib.sha1\n except ImportError:\n-  import sha\n-  sha_func = sha.new\n+    import sha\n+    sha_func = sha.new\n+\n \n def scrub(b):\n-  if sys.version_info >= (3,) and type(b) == bytes:\n-    return b.decode('ascii')\n-  else:\n-    return b\n+    if sys.version_info >= (3,) and type(b) == bytes:\n+        return b.decode('ascii')\n+    else:\n+        return b\n \n src_dir = scrub(os.getenv(\"CFG_SRC_DIR\"))\n if not src_dir:\n-  raise Exception(\"missing env var CFG_SRC_DIR\")\n+    raise Exception(\"missing env var CFG_SRC_DIR\")\n \n snapshotfile = os.path.join(src_dir, \"src\", \"snapshots.txt\")\n download_url_base = \"https://static.rust-lang.org/stage0-snapshots\"\n download_dir_base = \"dl\"\n download_unpack_base = os.path.join(download_dir_base, \"unpack\")\n \n snapshot_files = {\n-    \"linux\": [\"bin/rustc\"],\n-    \"macos\": [\"bin/rustc\"],\n-    \"winnt\": [\"bin/rustc.exe\"],\n-    \"freebsd\": [\"bin/rustc\"],\n-    \"dragonfly\": [\"bin/rustc\"],\n-    }\n-\n-winnt_runtime_deps_32 = [\"libgcc_s_dw2-1.dll\",\n-                         \"libstdc++-6.dll\"]\n-winnt_runtime_deps_64 = [\"libgcc_s_seh-1.dll\",\n-                         \"libstdc++-6.dll\"]\n+        \"linux\": [\"bin/rustc\"],\n+        \"macos\": [\"bin/rustc\"],\n+        \"winnt\": [\"bin/rustc.exe\"],\n+        \"freebsd\": [\"bin/rustc\"],\n+        \"dragonfly\": [\"bin/rustc\"],\n+        }\n+\n+winnt_runtime_deps_32 = [\"libgcc_s_dw2-1.dll\", \"libstdc++-6.dll\"]\n+winnt_runtime_deps_64 = [\"libgcc_s_seh-1.dll\", \"libstdc++-6.dll\"]\n+\n \n def parse_line(n, line):\n-  global snapshotfile\n+    global snapshotfile\n \n-  if re.match(r\"\\s*$\", line): return None\n+    if re.match(r\"\\s*$\", line):\n+        return None\n \n-  if re.match(r\"^T\\s*$\", line): return None\n+    if re.match(r\"^T\\s*$\", line):\n+        return None\n \n-  match = re.match(r\"\\s+([\\w_-]+) ([a-fA-F\\d]{40})\\s*$\", line)\n-  if match:\n-    return { \"type\": \"file\",\n-             \"platform\": match.group(1),\n-             \"hash\": match.group(2).lower() }\n+    match = re.match(r\"\\s+([\\w_-]+) ([a-fA-F\\d]{40})\\s*$\", line)\n+    if match:\n+        return {\"type\": \"file\",\n+                \"platform\": match.group(1),\n+                \"hash\": match.group(2).lower()}\n \n-  match = re.match(r\"([ST]) (\\d{4}-\\d{2}-\\d{2}) ([a-fA-F\\d]+)\\s*$\", line);\n-  if (not match):\n-    raise Exception(\"%s:%d:E syntax error: \" % (snapshotfile, n))\n-  return {\"type\": \"snapshot\",\n-          \"date\": match.group(2),\n-          \"rev\": match.group(3)}\n+    match = re.match(r\"([ST]) (\\d{4}-\\d{2}-\\d{2}) ([a-fA-F\\d]+)\\s*$\", line)\n+    if not match:\n+        raise Exception(\"%s:%d:E syntax error: \" % (snapshotfile, n))\n+    return {\"type\": \"snapshot\",\n+            \"date\": match.group(2),\n+            \"rev\": match.group(3)}\n \n \n def partial_snapshot_name(date, rev, platform):\n-  return (\"rust-stage0-%s-%s-%s.tar.bz2\"\n-          % (date, rev, platform))\n+    return (\"rust-stage0-%s-%s-%s.tar.bz2\" %\n+            (date, rev, platform))\n+\n \n def full_snapshot_name(date, rev, platform, hsh):\n-  return (\"rust-stage0-%s-%s-%s-%s.tar.bz2\"\n-          % (date, rev, platform, hsh))\n+    return (\"rust-stage0-%s-%s-%s-%s.tar.bz2\" %\n+            (date, rev, platform, hsh))\n \n \n def get_kernel(triple):\n     t = triple.split('-')\n     if len(t) == 2:\n-      os_name = t[1]\n+        os_name = t[1]\n     else:\n-      os_name = t[2]\n+        os_name = t[2]\n+\n     if os_name == \"windows\":\n         return \"winnt\"\n     if os_name == \"darwin\":\n@@ -91,19 +102,20 @@ def get_kernel(triple):\n         return \"dragonfly\"\n     return \"linux\"\n \n+\n def get_cpu(triple):\n     arch = triple.split('-')[0]\n     if arch == \"i686\":\n-      return \"i386\"\n+        return \"i386\"\n     return arch\n \n+\n def get_platform(triple):\n-  return \"%s-%s\" % (get_kernel(triple), get_cpu(triple))\n+    return \"%s-%s\" % (get_kernel(triple), get_cpu(triple))\n \n \n def cmd_out(cmdline):\n-    p = subprocess.Popen(cmdline,\n-                         stdout=subprocess.PIPE)\n+    p = subprocess.Popen(cmdline, stdout=subprocess.PIPE)\n     return scrub(p.communicate()[0].strip())\n \n \n@@ -124,7 +136,8 @@ def local_rev_short_sha():\n def local_rev_committer_date():\n     return local_rev_info(\"ci\")\n \n-def get_url_to_file(u,f):\n+\n+def get_url_to_file(u, f):\n     # no security issue, just to stop partial download leaving a stale file\n     tmpf = f + '.tmp'\n \n@@ -137,40 +150,44 @@ def get_url_to_file(u,f):\n     if returncode != 0:\n         try:\n             os.unlink(tmpf)\n-        except OSError as e:\n+        except OSError:\n             pass\n         raise Exception(\"failed to fetch url\")\n     os.rename(tmpf, f)\n \n+\n def snap_filename_hash_part(snap):\n-  match = re.match(r\".*([a-fA-F\\d]{40}).tar.bz2$\", snap)\n-  if not match:\n-    raise Exception(\"unable to find hash in filename: \" + snap)\n-  return match.group(1)\n+    match = re.match(r\".*([a-fA-F\\d]{40}).tar.bz2$\", snap)\n+    if not match:\n+        raise Exception(\"unable to find hash in filename: \" + snap)\n+    return match.group(1)\n+\n \n def hash_file(x):\n     h = sha_func()\n     h.update(open(x, \"rb\").read())\n     return scrub(h.hexdigest())\n \n-# Returns a list of paths of Rust's system runtime dependencies\n+\n def get_winnt_runtime_deps(platform):\n+    \"\"\"Returns a list of paths of Rust's system runtime dependencies\"\"\"\n     if platform == \"winnt-x86_64\":\n-      deps = winnt_runtime_deps_64\n+        deps = winnt_runtime_deps_64\n     else:\n-      deps = winnt_runtime_deps_32\n+        deps = winnt_runtime_deps_32\n     runtime_deps = []\n     path_dirs = os.environ[\"PATH\"].split(os.pathsep)\n     for name in deps:\n-      for dir in path_dirs:\n-        filepath = os.path.join(dir, name)\n-        if os.path.isfile(filepath):\n-          runtime_deps.append(filepath)\n-          break\n-      else:\n-        raise Exception(\"Could not find runtime dependency: %s\" % name)\n+        for dir in path_dirs:\n+            filepath = os.path.join(dir, name)\n+            if os.path.isfile(filepath):\n+                runtime_deps.append(filepath)\n+                break\n+        else:\n+            raise Exception(\"Could not find runtime dependency: %s\" % name)\n     return runtime_deps\n \n+\n def make_snapshot(stage, triple):\n     kernel = get_kernel(triple)\n     platform = get_platform(triple)\n@@ -180,31 +197,31 @@ def make_snapshot(stage, triple):\n     file0 = partial_snapshot_name(date, rev, platform)\n \n     def in_tar_name(fn):\n-      cs = re.split(r\"[\\\\/]\", fn)\n-      if len(cs) >= 2:\n-        return os.sep.join(cs[-2:])\n+        cs = re.split(r\"[\\\\/]\", fn)\n+        if len(cs) >= 2:\n+            return os.sep.join(cs[-2:])\n \n     tar = tarfile.open(file0, \"w:bz2\")\n \n     for name in snapshot_files[kernel]:\n-      dir = stage\n-      if stage == \"stage1\" and re.match(r\"^lib/(lib)?std.*\", name):\n-        dir = \"stage0\"\n-      fn_glob = os.path.join(triple, dir, name)\n-      matches = glob.glob(fn_glob)\n-      if not matches:\n-        raise Exception(\"Not found file with name like \" + fn_glob)\n-      if len(matches) == 1:\n-        tar.add(matches[0], \"rust-stage0/\" + in_tar_name(matches[0]))\n-      else:\n-        raise Exception(\"Found stale files: \\n  %s\\n\"\n-                        \"Please make a clean build.\" % \"\\n  \".join(matches))\n-\n-    if kernel==\"winnt\":\n-      for path in get_winnt_runtime_deps(platform):\n-        tar.add(path, \"rust-stage0/bin/\" + os.path.basename(path))\n-      tar.add(os.path.join(os.path.dirname(__file__), \"third-party\"),\n-              \"rust-stage0/bin/third-party\")\n+        dir = stage\n+        if stage == \"stage1\" and re.match(r\"^lib/(lib)?std.*\", name):\n+            dir = \"stage0\"\n+        fn_glob = os.path.join(triple, dir, name)\n+        matches = glob.glob(fn_glob)\n+        if not matches:\n+            raise Exception(\"Not found file with name like \" + fn_glob)\n+        if len(matches) == 1:\n+            tar.add(matches[0], \"rust-stage0/\" + in_tar_name(matches[0]))\n+        else:\n+            raise Exception(\"Found stale files: \\n  %s\\n\"\n+                            \"Please make a clean build.\" % \"\\n  \".join(matches))\n+\n+    if kernel == \"winnt\":\n+        for path in get_winnt_runtime_deps(platform):\n+            tar.add(path, \"rust-stage0/bin/\" + os.path.basename(path))\n+        tar.add(os.path.join(os.path.dirname(__file__), \"third-party\"),\n+                \"rust-stage0/bin/third-party\")\n \n     tar.close()\n \n@@ -215,60 +232,64 @@ def in_tar_name(fn):\n \n     return file1\n \n+\n def curr_snapshot_rev():\n-  i = 0\n-  found_snap = False\n-  date = None\n-  rev = None\n+    i = 0\n+    found_snap = False\n+    date = None\n+    rev = None\n+\n+    f = open(snapshotfile)\n+    for line in f.readlines():\n+        i += 1\n+        parsed = parse_line(i, line)\n+        if not parsed:\n+            continue\n \n-  f = open(snapshotfile)\n-  for line in f.readlines():\n-    i += 1\n-    parsed = parse_line(i, line)\n-    if (not parsed): continue\n+        if parsed[\"type\"] == \"snapshot\":\n+            date = parsed[\"date\"]\n+            rev = parsed[\"rev\"]\n+            found_snap = True\n+            break\n \n-    if parsed[\"type\"] == \"snapshot\":\n-      date = parsed[\"date\"]\n-      rev = parsed[\"rev\"]\n-      found_snap = True\n-      break\n+    if not found_snap:\n+        raise Exception(\"no snapshot entries in file\")\n \n-  if not found_snap:\n-    raise Exception(\"no snapshot entries in file\")\n+    return (date, rev)\n \n-  return (date, rev)\n \n def determine_curr_snapshot(triple):\n-  i = 0\n-  platform = get_platform(triple)\n-\n-  found_file = False\n-  found_snap = False\n-  hsh = None\n-  date = None\n-  rev = None\n-\n-  f = open(snapshotfile)\n-  for line in f.readlines():\n-    i += 1\n-    parsed = parse_line(i, line)\n-    if (not parsed): continue\n-\n-    if found_snap and parsed[\"type\"] == \"file\":\n-      if parsed[\"platform\"] == platform:\n-        hsh = parsed[\"hash\"]\n-        found_file = True\n-        break;\n-    elif parsed[\"type\"] == \"snapshot\":\n-      date = parsed[\"date\"]\n-      rev = parsed[\"rev\"]\n-      found_snap = True\n-\n-  if not found_snap:\n-    raise Exception(\"no snapshot entries in file\")\n-\n-  if not found_file:\n-    raise Exception(\"no snapshot file found for platform %s, rev %s\" %\n-                    (platform, rev))\n-\n-  return full_snapshot_name(date, rev, platform, hsh)\n+    i = 0\n+    platform = get_platform(triple)\n+\n+    found_file = False\n+    found_snap = False\n+    hsh = None\n+    date = None\n+    rev = None\n+\n+    f = open(snapshotfile)\n+    for line in f.readlines():\n+        i += 1\n+        parsed = parse_line(i, line)\n+        if not parsed:\n+            continue\n+\n+        if found_snap and parsed[\"type\"] == \"file\":\n+            if parsed[\"platform\"] == platform:\n+                hsh = parsed[\"hash\"]\n+                found_file = True\n+                break\n+        elif parsed[\"type\"] == \"snapshot\":\n+            date = parsed[\"date\"]\n+            rev = parsed[\"rev\"]\n+            found_snap = True\n+\n+    if not found_snap:\n+        raise Exception(\"no snapshot entries in file\")\n+\n+    if not found_file:\n+        raise Exception(\"no snapshot file found for platform %s, rev %s\" %\n+                        (platform, rev))\n+\n+    return full_snapshot_name(date, rev, platform, hsh)"}, {"sha": "62870f3ed4787c722e6f0d1f565222079cdbcc19", "filename": "src/etc/sugarise-doc-comments.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -17,7 +17,10 @@\n # it sugarises all .rs/.rc files underneath the working directory\n #\n \n-import sys, os, fnmatch, re\n+import sys\n+import os\n+import fnmatch\n+import re\n \n \n DOC_PATTERN = '^(?P<indent>[\\\\t ]*)#\\\\[(\\\\s*)doc(\\\\s*)=' + \\\n@@ -85,7 +88,6 @@ def sugarise_file(path):\n     if s != ns:\n         open(path, 'w').write(ns)\n \n-\n for (dirpath, dirnames, filenames) in os.walk('.'):\n     for name in fnmatch.filter(filenames, '*.r[sc]'):\n         sugarise_file(os.path.join(dirpath, name))"}, {"sha": "f5172feb5b60f1cb288973ae9459597cebaeea02", "filename": "src/etc/tidy.py", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/2ac91a382d48c0c50f3c105da086fb59883e3897/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=2ac91a382d48c0c50f3c105da086fb59883e3897", "patch": "@@ -8,37 +8,45 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import sys, fileinput, subprocess, re, os\n+import sys\n+import fileinput\n+import subprocess\n+import re\n+import os\n from licenseck import *\n import snapshot\n \n-err=0\n-cols=100\n-cr_flag=\"ignore-tidy-cr\"\n-tab_flag=\"ignore-tidy-tab\"\n-linelength_flag=\"ignore-tidy-linelength\"\n+err = 0\n+cols = 100\n+cr_flag = \"ignore-tidy-cr\"\n+tab_flag = \"ignore-tidy-tab\"\n+linelength_flag = \"ignore-tidy-linelength\"\n \n # Be careful to support Python 2.4, 2.6, and 3.x here!\n-config_proc=subprocess.Popen([ \"git\", \"config\", \"core.autocrlf\" ],\n-                             stdout=subprocess.PIPE)\n-result=config_proc.communicate()[0]\n+config_proc = subprocess.Popen([\"git\", \"config\", \"core.autocrlf\"],\n+                               stdout=subprocess.PIPE)\n+result = config_proc.communicate()[0]\n+\n+true = \"true\".encode('utf8')\n+autocrlf = result.strip() == true if result is not None else False\n \n-true=\"true\".encode('utf8')\n-autocrlf=result.strip() == true if result is not None else False\n \n def report_error_name_no(name, no, s):\n     global err\n     print(\"%s:%d: %s\" % (name, no, s))\n-    err=1\n+    err = 1\n+\n \n def report_err(s):\n     report_error_name_no(fileinput.filename(), fileinput.filelineno(), s)\n \n+\n def report_warn(s):\n     print(\"%s:%d: %s\" % (fileinput.filename(),\n                          fileinput.filelineno(),\n                          s))\n \n+\n def do_license_check(name, contents):\n     if not check_license(name, contents):\n         report_error_name_no(name, 1, \"incorrect license\")\n@@ -81,13 +89,13 @@ def do_license_check(name, contents):\n                 date, rev = snapshot.curr_snapshot_rev()\n                 if not hsh.startswith(rev):\n                     report_err(\"snapshot out of date (\" + date\n-                      + \"): \" + line)\n+                               + \"): \" + line)\n             else:\n                 if \"SNAP\" in line:\n                     report_warn(\"unmatched SNAP line: \" + line)\n \n         if check_tab and ('\\t' in line and\n-            \"Makefile\" not in fileinput.filename()):\n+                          \"Makefile\" not in fileinput.filename()):\n             report_err(\"tab character\")\n         if check_cr and not autocrlf and '\\r' in line:\n             report_err(\"CR character\")"}]}