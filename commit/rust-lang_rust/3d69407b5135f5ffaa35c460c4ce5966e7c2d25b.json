{"sha": "3d69407b5135f5ffaa35c460c4ce5966e7c2d25b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNjk0MDdiNTEzNWY1ZmZhYTM1YzQ2MGM0Y2U1OTY2ZTdjMmQyNWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-26T22:44:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-26T22:44:29Z"}, "message": "Fix numerous non-linearities and O(sizeof(crate)) issues in typestate system's dataflow algorithm. No longer substantial in profile.", "tree": {"sha": "ddf07b26f563abbda3786b6d38dcdda137d94f39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddf07b26f563abbda3786b6d38dcdda137d94f39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b", "html_url": "https://github.com/rust-lang/rust/commit/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b97b4e79db70ca4ed6b9026c87858e97e92cc67", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b97b4e79db70ca4ed6b9026c87858e97e92cc67", "html_url": "https://github.com/rust-lang/rust/commit/4b97b4e79db70ca4ed6b9026c87858e97e92cc67"}], "stats": {"total": 466, "additions": 340, "deletions": 126}, "files": [{"sha": "ff10a300431ad32a6bbd7de6e5abc153b825a118", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=3d69407b5135f5ffaa35c460c4ce5966e7c2d25b", "patch": "@@ -100,6 +100,7 @@ type ctxt =\n       ctxt_all_stmts: (node_id,Ast.stmt) Hashtbl.t;\n       ctxt_item_files: (node_id,filename) Hashtbl.t;\n       ctxt_all_lvals: (node_id,Ast.lval) Hashtbl.t;\n+      ctxt_call_lval_params: (node_id,Ast.ty array) Hashtbl.t;\n \n       (* definition id --> definition *)\n       ctxt_all_defns: (node_id,defn) Hashtbl.t;\n@@ -110,6 +111,10 @@ type ctxt =\n       ctxt_required_items: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n       ctxt_required_syms: (node_id, string) Hashtbl.t;\n \n+      (* Typestate-y stuff. *)\n+      ctxt_stmt_is_init: (node_id,unit) Hashtbl.t;\n+      ctxt_post_stmt_slot_drops: (node_id,node_id list) Hashtbl.t;\n+\n       (* Layout-y stuff. *)\n       ctxt_slot_aliased: (node_id,unit) Hashtbl.t;\n       ctxt_slot_is_obj_state: (node_id,unit) Hashtbl.t;\n@@ -121,17 +126,6 @@ type ctxt =\n       ctxt_stmt_loop_depths: (node_id,int) Hashtbl.t;\n       ctxt_slot_loop_depths: (node_id,int) Hashtbl.t;\n \n-      (* Typestate-y stuff. *)\n-      ctxt_constrs: (constr_id,constr_key) Hashtbl.t;\n-      ctxt_constr_ids: (constr_key,constr_id) Hashtbl.t;\n-      ctxt_preconditions: (node_id,Bits.t) Hashtbl.t;\n-      ctxt_postconditions: (node_id,Bits.t) Hashtbl.t;\n-      ctxt_prestates: (node_id,Bits.t) Hashtbl.t;\n-      ctxt_poststates: (node_id,Bits.t) Hashtbl.t;\n-      ctxt_call_lval_params: (node_id,Ast.ty array) Hashtbl.t;\n-      ctxt_stmt_is_init: (node_id,unit) Hashtbl.t;\n-      ctxt_post_stmt_slot_drops: (node_id,node_id list) Hashtbl.t;\n-\n       (* Translation-y stuff. *)\n       ctxt_fn_fixups: (node_id,fixup) Hashtbl.t;\n       ctxt_block_fixups: (node_id,fixup) Hashtbl.t;\n@@ -192,19 +186,13 @@ let new_ctxt sess abi crate =\n     ctxt_item_files = crate.Ast.crate_files;\n     ctxt_all_lvals = Hashtbl.create 0;\n     ctxt_all_defns = Hashtbl.create 0;\n+    ctxt_call_lval_params = Hashtbl.create 0;\n     ctxt_lval_to_referent = Hashtbl.create 0;\n     ctxt_required_items = crate.Ast.crate_required;\n     ctxt_required_syms = crate.Ast.crate_required_syms;\n \n-    ctxt_constrs = Hashtbl.create 0;\n-    ctxt_constr_ids = Hashtbl.create 0;\n-    ctxt_preconditions = Hashtbl.create 0;\n-    ctxt_postconditions = Hashtbl.create 0;\n-    ctxt_prestates = Hashtbl.create 0;\n-    ctxt_poststates = Hashtbl.create 0;\n     ctxt_stmt_is_init = Hashtbl.create 0;\n     ctxt_post_stmt_slot_drops = Hashtbl.create 0;\n-    ctxt_call_lval_params = Hashtbl.create 0;\n \n     ctxt_slot_aliased = Hashtbl.create 0;\n     ctxt_slot_is_obj_state = Hashtbl.create 0;"}, {"sha": "86d6b9a745e2992095103f0e13b6cdbf1fec0915", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 334, "deletions": 108, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/3d69407b5135f5ffaa35c460c4ce5966e7c2d25b/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=3d69407b5135f5ffaa35c460c4ce5966e7c2d25b", "patch": "@@ -13,6 +13,96 @@ let iflog cx thunk =\n   else ()\n ;;\n \n+type node_graph = (node_id, (node_id list)) Hashtbl.t;;\n+type sibling_map = (node_id, node_id) Hashtbl.t;;\n+\n+type typestate_tables =\n+    { ts_constrs: (constr_id,constr_key) Hashtbl.t;\n+      ts_constr_ids: (constr_key,constr_id) Hashtbl.t;\n+      ts_preconditions: (node_id,Bits.t) Hashtbl.t;\n+      ts_postconditions: (node_id,Bits.t) Hashtbl.t;\n+      ts_prestates: (node_id,Bits.t) Hashtbl.t;\n+      ts_poststates: (node_id,Bits.t) Hashtbl.t;\n+      ts_graph: node_graph;\n+      ts_siblings: sibling_map;\n+      ts_stmts: Ast.stmt Stack.t;\n+      ts_maxid: int ref;\n+    }\n+;;\n+\n+let new_tables _ =\n+  { ts_constrs = Hashtbl.create 0;\n+    ts_constr_ids = Hashtbl.create 0;\n+    ts_preconditions = Hashtbl.create 0;\n+    ts_postconditions = Hashtbl.create 0;\n+    ts_poststates = Hashtbl.create 0;\n+    ts_prestates = Hashtbl.create 0;\n+    ts_graph = Hashtbl.create 0;\n+    ts_siblings = Hashtbl.create 0;\n+    ts_stmts = Stack.create ();\n+    ts_maxid = ref 0 }\n+;;\n+\n+type item_tables = (node_id, typestate_tables) Hashtbl.t\n+;;\n+\n+let get_tables (all_tables:item_tables) (n:node_id) : typestate_tables =\n+  htab_search_or_add all_tables n new_tables\n+;;\n+\n+let tables_managing_visitor\n+    (all_tables:item_tables)\n+    (tables_stack:typestate_tables Stack.t)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+\n+  let enter id =\n+    Stack.push (get_tables all_tables id) tables_stack\n+  in\n+\n+  let leave _ =\n+    ignore (Stack.pop tables_stack)\n+  in\n+\n+  let visit_mod_item_pre n p i =\n+    enter i.id;\n+    inner.Walk.visit_mod_item_pre n p i\n+  in\n+\n+  let visit_mod_item_post n p i =\n+    inner.Walk.visit_mod_item_post n p i;\n+    leave()\n+  in\n+\n+  let visit_obj_fn_pre obj ident fn =\n+    enter fn.id;\n+    inner.Walk.visit_obj_fn_pre obj ident fn\n+  in\n+\n+  let visit_obj_fn_post obj ident fn =\n+    inner.Walk.visit_obj_fn_post obj ident fn;\n+    leave()\n+  in\n+\n+  let visit_obj_drop_pre obj b =\n+    enter b.id;\n+    inner.Walk.visit_obj_drop_pre obj b\n+  in\n+\n+  let visit_obj_drop_post obj b =\n+    inner.Walk.visit_obj_drop_post obj b;\n+    leave()\n+  in\n+    { inner with\n+        Walk.visit_mod_item_pre = visit_mod_item_pre;\n+        Walk.visit_mod_item_post = visit_mod_item_post;\n+        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n+        Walk.visit_obj_fn_post = visit_obj_fn_post;\n+        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n+        Walk.visit_obj_drop_post = visit_obj_drop_post; }\n+;;\n+\n+\n let name_base_to_slot_key (nb:Ast.name_base) : Ast.slot_key =\n   match nb with\n       Ast.BASE_ident ident -> Ast.KEY_ident ident\n@@ -153,11 +243,13 @@ let fn_keys fn resolver =\n \n let constr_id_assigning_visitor\n     (cx:ctxt)\n+    (tables_stack:typestate_tables Stack.t)\n     (scopes:(scope list) ref)\n-    (idref:int ref)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n+  let tables _ = Stack.top tables_stack in\n+\n   let resolve_constr_to_key\n       (formal_base:node_id)\n       (constr:Ast.constr)\n@@ -166,17 +258,19 @@ let constr_id_assigning_visitor\n   in\n \n   let note_constr_key key =\n-    if not (Hashtbl.mem cx.ctxt_constr_ids key)\n-    then\n-      begin\n-        let cid = Constr (!idref) in\n-          iflog cx\n-            (fun _ -> log cx \"assigning constr id #%d to constr %s\"\n-               (!idref) (fmt_constr_key cx key));\n-          incr idref;\n-          htab_put cx.ctxt_constrs cid key;\n-          htab_put cx.ctxt_constr_ids key cid;\n-      end\n+    let ts = tables () in\n+    let idref = ts.ts_maxid in\n+      if not (Hashtbl.mem ts.ts_constr_ids key)\n+      then\n+        begin\n+          let cid = Constr (!idref) in\n+            iflog cx\n+              (fun _ -> log cx \"assigning constr id #%d to constr %s\"\n+                 (!idref) (fmt_constr_key cx key));\n+            incr idref;\n+            htab_put ts.ts_constrs cid key;\n+            htab_put ts.ts_constr_ids key cid;\n+        end\n   in\n \n   let note_keys = Array.iter note_constr_key in\n@@ -198,6 +292,24 @@ let constr_id_assigning_visitor\n     inner.Walk.visit_mod_item_pre n p i\n   in\n \n+  let visit_obj_fn_pre obj ident fn =\n+    let (obj_input_keys, obj_init_keys) =\n+      obj_keys obj.node (resolve_constr_to_key obj.id)\n+    in\n+      note_keys obj_input_keys;\n+      note_keys obj_init_keys;\n+      inner.Walk.visit_obj_fn_pre obj ident fn\n+  in\n+\n+  let visit_obj_drop_pre obj b =\n+    let (obj_input_keys, obj_init_keys) =\n+      obj_keys obj.node (resolve_constr_to_key obj.id)\n+    in\n+      note_keys obj_input_keys;\n+      note_keys obj_init_keys;\n+      inner.Walk.visit_obj_drop_pre obj b\n+  in\n+\n   let visit_constr_pre formal_base c =\n     let key = determine_constr_key cx (!scopes) formal_base c in\n       note_constr_key key;\n@@ -242,33 +354,42 @@ let constr_id_assigning_visitor\n   in\n     { inner with\n         Walk.visit_mod_item_pre = visit_mod_item_pre;\n+        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n+        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n         Walk.visit_slot_identified_pre = visit_slot_identified_pre;\n         Walk.visit_stmt_pre = visit_stmt_pre;\n         Walk.visit_constr_pre = visit_constr_pre }\n ;;\n \n let bitmap_assigning_visitor\n     (cx:ctxt)\n-    (idref:int ref)\n+    (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n+\n+  let tables _ = Stack.top tables_stack in\n+\n   let visit_stmt_pre s =\n-    iflog cx (fun _ -> log cx \"building %d-entry bitmap for node %d\"\n-                (!idref) (int_of_node s.id));\n-    htab_put cx.ctxt_preconditions s.id (Bits.create (!idref) false);\n-    htab_put cx.ctxt_postconditions s.id (Bits.create (!idref) false);\n-    htab_put cx.ctxt_prestates s.id (Bits.create (!idref) false);\n-    htab_put cx.ctxt_poststates s.id (Bits.create (!idref) false);\n-    inner.Walk.visit_stmt_pre s\n+    let ts = tables () in\n+    let idref = ts.ts_maxid in\n+      iflog cx (fun _ -> log cx \"building %d-entry bitmap for node %d\"\n+                  (!idref) (int_of_node s.id));\n+      htab_put ts.ts_preconditions s.id (Bits.create (!idref) false);\n+      htab_put ts.ts_postconditions s.id (Bits.create (!idref) false);\n+      htab_put ts.ts_prestates s.id (Bits.create (!idref) false);\n+      htab_put ts.ts_poststates s.id (Bits.create (!idref) false);\n+      inner.Walk.visit_stmt_pre s\n   in\n   let visit_block_pre b =\n-    iflog cx (fun _ -> log cx \"building %d-entry bitmap for node %d\"\n-                (!idref) (int_of_node b.id));\n-    htab_put cx.ctxt_preconditions b.id (Bits.create (!idref) false);\n-    htab_put cx.ctxt_postconditions b.id (Bits.create (!idref) false);\n-    htab_put cx.ctxt_prestates b.id (Bits.create (!idref) false);\n-    htab_put cx.ctxt_poststates b.id (Bits.create (!idref) false);\n-    inner.Walk.visit_block_pre b\n+    let ts = tables () in\n+    let idref = ts.ts_maxid in\n+      iflog cx (fun _ -> log cx \"building %d-entry bitmap for node %d\"\n+                  (!idref) (int_of_node b.id));\n+      htab_put ts.ts_preconditions b.id (Bits.create (!idref) false);\n+      htab_put ts.ts_postconditions b.id (Bits.create (!idref) false);\n+      htab_put ts.ts_prestates b.id (Bits.create (!idref) false);\n+      htab_put ts.ts_poststates b.id (Bits.create (!idref) false);\n+      inner.Walk.visit_block_pre b\n   in\n     { inner with\n         Walk.visit_stmt_pre = visit_stmt_pre;\n@@ -277,30 +398,36 @@ let bitmap_assigning_visitor\n \n let condition_assigning_visitor\n     (cx:ctxt)\n+    (tables_stack:typestate_tables Stack.t)\n     (scopes:(scope list) ref)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n+  let tables _ = Stack.top tables_stack in\n+\n   let raise_bits (bitv:Bits.t) (keys:constr_key array) : unit =\n-    Array.iter\n-      (fun key ->\n-         let cid = Hashtbl.find cx.ctxt_constr_ids key in\n-         let i = int_of_constr cid in\n-           iflog cx (fun _ -> log cx \"setting bit %d, constraint %s\"\n-                       i (fmt_constr_key cx key));\n-           Bits.set bitv (int_of_constr cid) true)\n-      keys\n+    let ts = tables () in\n+      Array.iter\n+        (fun key ->\n+           let cid = Hashtbl.find ts.ts_constr_ids key in\n+           let i = int_of_constr cid in\n+             iflog cx (fun _ -> log cx \"setting bit %d, constraint %s\"\n+                         i (fmt_constr_key cx key));\n+             Bits.set bitv (int_of_constr cid) true)\n+        keys\n   in\n \n   let slot_inits ss = Array.map (fun s -> Constr_init s) ss in\n \n   let raise_postcondition (id:node_id) (keys:constr_key array) : unit =\n-    let bitv = Hashtbl.find cx.ctxt_postconditions id in\n+    let ts = tables () in\n+    let bitv = Hashtbl.find ts.ts_postconditions id in\n       raise_bits bitv keys\n   in\n \n   let raise_precondition (id:node_id) (keys:constr_key array) : unit =\n-    let bitv = Hashtbl.find cx.ctxt_preconditions id in\n+    let ts = tables () in\n+    let bitv = Hashtbl.find ts.ts_preconditions id in\n       raise_bits bitv keys\n   in\n \n@@ -602,18 +729,19 @@ let show_node cx graph s i =\n          s (int_of_node i) (lset_fmt (Hashtbl.find graph i)))\n ;;\n \n-type node_graph = (node_id, (node_id list)) Hashtbl.t;;\n-type sibling_map = (node_id, node_id) Hashtbl.t;;\n-\n let graph_sequence_building_visitor\n     (cx:ctxt)\n-    (graph:node_graph)\n-    (sibs:sibling_map)\n+    (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n+  let tables _ = Stack.top tables_stack in\n+\n   (* Flow each stmt to its sequence-successor. *)\n   let visit_stmts stmts =\n+    let ts = tables () in\n+    let graph = ts.ts_graph in\n+    let sibs = ts.ts_siblings in\n     let len = Array.length stmts in\n       for i = 0 to len - 2\n       do\n@@ -680,27 +808,36 @@ let last_id_or_block_id (block:Ast.block) : node_id =\n \n let graph_general_block_structure_building_visitor\n     (cx:ctxt)\n-    (graph:node_graph)\n-    (sibs:sibling_map)\n+    (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n-  let stmts = Stack.create () in\n+  let tables _ = Stack.top tables_stack in\n \n   let visit_stmt_pre s =\n-    Stack.push s stmts;\n-    inner.Walk.visit_stmt_pre s\n+    let ts = tables () in\n+    let stmts = ts.ts_stmts in\n+      Stack.push s stmts;\n+      inner.Walk.visit_stmt_pre s\n   in\n \n   let visit_stmt_post s =\n-    inner.Walk.visit_stmt_post s;\n-    ignore (Stack.pop stmts)\n+    let ts = tables () in\n+    let stmts = ts.ts_stmts in\n+      inner.Walk.visit_stmt_post s;\n+      ignore (Stack.pop stmts)\n   in\n \n-  let show_node = show_node cx graph in\n+  let show_node =\n+    fun n id -> show_node cx (tables()).ts_graph n id\n+  in\n \n   let visit_block_pre b =\n     begin\n+      let ts = tables () in\n+      let graph = ts.ts_graph in\n+      let sibs = ts.ts_siblings in\n+      let stmts = ts.ts_stmts in\n       let len = Array.length b.node in\n       let _ = htab_put graph b.id\n         (if len > 0 then [b.node.(0).id] else [])\n@@ -748,15 +885,19 @@ let graph_general_block_structure_building_visitor\n \n let graph_special_block_structure_building_visitor\n     (cx:ctxt)\n-    (graph:(node_id, (node_id list)) Hashtbl.t)\n+    (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n+  let tables _ = Stack.top tables_stack in\n+\n   let visit_stmt_pre s =\n     begin\n       match s.node with\n \n-        | Ast.STMT_if sif ->\n+          Ast.STMT_if sif ->\n+            let ts = tables () in\n+            let graph = ts.ts_graph in\n             let cond_id = s.id in\n             let then_id = sif.Ast.if_then.id in\n             let then_end_id = last_id_or_block_id sif.Ast.if_then in\n@@ -799,6 +940,8 @@ let graph_special_block_structure_building_visitor\n             (* There are a bunch of rewirings to do on 'while' nodes. *)\n \n             begin\n+              let ts = tables () in\n+              let graph = ts.ts_graph in\n               let dsts = Hashtbl.find graph s.id in\n               let body = sw.Ast.while_body in\n               let succ_stmts =\n@@ -837,6 +980,8 @@ let graph_special_block_structure_building_visitor\n             end\n \n         | Ast.STMT_alt_tag at ->\n+            let ts = tables () in\n+            let graph = ts.ts_graph in\n             let dsts = Hashtbl.find graph s.id in\n             let arm_blocks =\n               let arm_block_id { node = (_, block) } = block.id in\n@@ -865,49 +1010,73 @@ let find_roots\n     roots\n ;;\n \n-let run_dataflow cx idref graph : unit =\n+let run_dataflow (cx:ctxt) (ts:typestate_tables) : unit =\n+  let graph = ts.ts_graph in\n+  let idref = ts.ts_maxid in\n   let roots = find_roots graph in\n   let nodes = Queue.create () in\n+\n   let progress = ref true in\n+  let iter = ref 0 in\n+  let total = ref 0 in\n+  let written = Hashtbl.create 0 in\n+  let scheduled = Hashtbl.create 0 in\n+  let next_nodes = Queue.create () in\n+  let schedule n =\n+    if Hashtbl.mem scheduled n\n+    then ()\n+    else\n+      begin\n+        Queue.push n next_nodes;\n+        Hashtbl.add scheduled n ()\n+      end\n+  in\n+\n   let fmt_constr_bitv bitv =\n     String.concat \", \"\n       (List.map\n          (fun i ->\n             fmt_constr_key cx\n-              (Hashtbl.find cx.ctxt_constrs (Constr i)))\n+              (Hashtbl.find ts.ts_constrs (Constr i)))\n          (Bits.to_list bitv))\n   in\n+\n   let set_bits dst src =\n     if Bits.copy dst src\n     then (progress := true;\n           iflog cx (fun _ -> log cx \"made progress setting bits\"))\n   in\n-  let intersect_bits dst src =\n+\n+  let intersect_bits node dst src =\n     if Bits.intersect dst src\n     then (progress := true;\n+          schedule node;\n           iflog cx (fun _ -> log cx\n                       \"made progress intersecting bits\"))\n   in\n-  let iter = ref 0 in\n-  let written = Hashtbl.create 0 in\n+\n   let tmp_diff = (Bits.create (!idref) false) in\n   let tmp_poststate = (Bits.create (!idref) false) in\n-    Hashtbl.iter (fun n _ -> Queue.push n nodes) roots;\n+    Hashtbl.iter (fun n _ -> schedule n) roots;\n     while !progress do\n       incr iter;\n       progress := false;\n+      Queue.clear nodes;\n+      Queue.transfer next_nodes nodes;\n+      Hashtbl.clear scheduled;\n       iflog cx (fun _ ->\n                   log cx \"\";\n                   log cx \"--------------------\";\n                   log cx \"dataflow pass %d\" (!iter));\n       Queue.iter\n         begin\n           fun node ->\n-            let prestate = Hashtbl.find cx.ctxt_prestates node in\n-            let precond = Hashtbl.find cx.ctxt_preconditions node in\n-            let postcond = Hashtbl.find cx.ctxt_postconditions node in\n-            let poststate = Hashtbl.find cx.ctxt_poststates node in\n+            let prestate = Hashtbl.find ts.ts_prestates node in\n+            let precond = Hashtbl.find ts.ts_preconditions node in\n+            let postcond = Hashtbl.find ts.ts_postconditions node in\n+            let poststate = Hashtbl.find ts.ts_poststates node in\n \n+              incr total;\n               Bits.clear tmp_poststate;\n               ignore (Bits.union tmp_poststate prestate);\n               ignore (Bits.union tmp_poststate precond);\n@@ -944,42 +1113,81 @@ let run_dataflow cx idref graph : unit =\n                 iflog cx (fun _ -> log cx\n                             \"out-edges for %d: %s\" i (lset_fmt successors));\n                 List.iter\n-                begin\n-                  fun succ ->\n-                    let succ_prestates =\n-                      Hashtbl.find cx.ctxt_prestates succ\n-                    in\n-                      if Hashtbl.mem written succ\n-                      then\n-                        begin\n-                          intersect_bits succ_prestates poststate;\n-                          Hashtbl.replace written succ ()\n-                        end\n-                      else\n-                        begin\n-                          progress := true;\n-                          Queue.push succ nodes;\n-                          set_bits succ_prestates poststate\n-                      end\n-                end\n-                successors\n+                  begin\n+                    fun succ ->\n+                      let succ_prestates =\n+                        Hashtbl.find ts.ts_prestates succ\n+                      in\n+                        if Hashtbl.mem written succ\n+                        then\n+                          intersect_bits succ succ_prestates poststate\n+                        else\n+                          begin\n+                            progress := true;\n+                            schedule succ;\n+                            set_bits succ_prestates poststate\n+                          end\n+                  end\n+                  successors\n         end\n         nodes\n     done\n ;;\n \n+let dataflow_visitor\n+    (cx:ctxt)\n+    (tables_stack:typestate_tables Stack.t)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+\n+  let tables _ = Stack.top tables_stack in\n+\n+  let visit_mod_item_pre n p i =\n+    run_dataflow cx (tables());\n+    inner.Walk.visit_mod_item_pre n p i\n+  in\n+\n+  let visit_obj_fn_pre obj ident fn =\n+    run_dataflow cx (tables());\n+    inner.Walk.visit_obj_fn_pre obj ident fn\n+  in\n+\n+  let visit_obj_drop_pre obj b =\n+    run_dataflow cx (tables());\n+    inner.Walk.visit_obj_drop_pre obj b\n+  in\n+\n+  let visit_block_pre b =\n+    if Hashtbl.mem cx.ctxt_block_is_loop_body b.id\n+    then run_dataflow cx (tables());\n+    inner.Walk.visit_block_pre b\n+  in\n+\n+    { inner with\n+        Walk.visit_mod_item_pre = visit_mod_item_pre;\n+        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n+        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n+        Walk.visit_block_pre = visit_block_pre }\n+;;\n+\n+\n let typestate_verify_visitor\n     (cx:ctxt)\n+    (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n+\n+  let tables _ = Stack.top tables_stack in\n+\n   let visit_stmt_pre s =\n-    let prestate = Hashtbl.find cx.ctxt_prestates s.id in\n-    let precond = Hashtbl.find cx.ctxt_preconditions s.id in\n+    let ts = tables () in\n+    let prestate = Hashtbl.find ts.ts_prestates s.id in\n+    let precond = Hashtbl.find ts.ts_preconditions s.id in\n       List.iter\n         (fun i ->\n            if not (Bits.get prestate i)\n            then\n-             let ckey = Hashtbl.find cx.ctxt_constrs (Constr i) in\n+             let ckey = Hashtbl.find ts.ts_constrs (Constr i) in\n              let constr_str = fmt_constr_key cx ckey in\n                err (Some s.id)\n                  \"Unsatisfied precondition constraint %s at stmt %d: %s\"\n@@ -996,6 +1204,7 @@ let typestate_verify_visitor\n \n let lifecycle_visitor\n     (cx:ctxt)\n+    (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n@@ -1007,6 +1216,8 @@ let lifecycle_visitor\n    * used later on in translation.\n    *)\n \n+  let tables _ = Stack.top tables_stack in\n+\n   let (live_block_slots:(node_id, unit) Hashtbl.t) = Hashtbl.create 0 in\n   let (block_slots:(node_id Stack.t) Stack.t) = Stack.create () in\n \n@@ -1101,12 +1312,13 @@ let lifecycle_visitor\n           | Ast.STMT_new_port lv_dst\n           | Ast.STMT_new_chan (lv_dst, _)\n           | Ast.STMT_new_box (lv_dst, _, _) ->\n-              let prestate = Hashtbl.find cx.ctxt_prestates s.id in\n-              let poststate = Hashtbl.find cx.ctxt_poststates s.id in\n+              let ts = tables () in\n+              let prestate = Hashtbl.find ts.ts_prestates s.id in\n+              let poststate = Hashtbl.find ts.ts_poststates s.id in\n               let dst_slots = lval_slots cx lv_dst in\n               let is_initializing slot =\n                 let cid =\n-                  Hashtbl.find cx.ctxt_constr_ids (Constr_init slot)\n+                  Hashtbl.find ts.ts_constr_ids (Constr_init slot)\n                 in\n                 let i = int_of_constr cid in\n                   (not (Bits.get prestate i)) && (Bits.get poststate i)\n@@ -1184,44 +1396,58 @@ let process_crate\n     : unit =\n   let path = Stack.create () in\n   let (scopes:(scope list) ref) = ref [] in\n-  let constr_id = ref 0 in\n-  let (graph:(node_id, (node_id list)) Hashtbl.t) = Hashtbl.create 0 in\n-  let sibs = Hashtbl.create 0 in\n+  let (tables_stack:typestate_tables Stack.t) = Stack.create () in\n+  let (all_tables:item_tables) = Hashtbl.create 0 in\n+  let table_managed = tables_managing_visitor all_tables tables_stack in\n   let setup_passes =\n     [|\n-      (scope_stack_managing_visitor scopes\n-         (constr_id_assigning_visitor cx scopes constr_id\n+      (table_managed\n+         (scope_stack_managing_visitor scopes\n+            (constr_id_assigning_visitor cx tables_stack scopes\n+               Walk.empty_visitor)));\n+      (table_managed\n+         (bitmap_assigning_visitor cx tables_stack\n+            Walk.empty_visitor));\n+      (table_managed\n+         (scope_stack_managing_visitor scopes\n+            (condition_assigning_visitor cx tables_stack scopes\n+               Walk.empty_visitor)));\n+      (table_managed\n+         (graph_sequence_building_visitor cx tables_stack\n             Walk.empty_visitor));\n-      (bitmap_assigning_visitor cx constr_id\n-         Walk.empty_visitor);\n-      (scope_stack_managing_visitor scopes\n-         (condition_assigning_visitor cx scopes\n+      (table_managed\n+         (graph_general_block_structure_building_visitor cx tables_stack\n             Walk.empty_visitor));\n-      (graph_sequence_building_visitor cx graph sibs\n-         Walk.empty_visitor);\n-      (graph_general_block_structure_building_visitor cx graph sibs\n-         Walk.empty_visitor);\n-      (graph_special_block_structure_building_visitor cx graph\n-         Walk.empty_visitor);\n+      (table_managed\n+         (graph_special_block_structure_building_visitor cx tables_stack\n+            Walk.empty_visitor));\n+    |]\n+  in\n+  let dataflow_passes =\n+    [|\n+      (table_managed\n+         (dataflow_visitor cx tables_stack\n+            Walk.empty_visitor))\n     |]\n   in\n   let verify_passes =\n     [|\n-      (scope_stack_managing_visitor scopes\n-         (typestate_verify_visitor cx\n+      (table_managed\n+         (typestate_verify_visitor cx tables_stack\n             Walk.empty_visitor))\n     |]\n   in\n   let aux_passes =\n     [|\n-      (lifecycle_visitor cx\n-         Walk.empty_visitor)\n+      (table_managed\n+         (lifecycle_visitor cx tables_stack\n+            Walk.empty_visitor))\n     |]\n   in\n   let log_flag = cx.ctxt_sess.Session.sess_log_typestate in\n     run_passes cx \"typestate setup\" path setup_passes log_flag log crate;\n-    Session.time_inner \"typestate dataflow\" cx.ctxt_sess\n-      (fun _ -> run_dataflow cx constr_id graph);\n+    run_passes cx\n+      \"typestate dataflow\" path dataflow_passes log_flag log crate;\n     run_passes cx \"typestate verify\" path verify_passes log_flag log crate;\n     run_passes cx \"typestate aux\" path aux_passes log_flag log crate\n ;;"}]}