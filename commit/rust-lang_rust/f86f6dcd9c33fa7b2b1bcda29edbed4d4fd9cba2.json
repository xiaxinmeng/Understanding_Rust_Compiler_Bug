{"sha": "f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NmY2ZGNkOWMzM2ZhN2IyYjFiY2RhMjllZGJlZDRkNGZkOWNiYTI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-01-01T06:40:51Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-01-01T06:51:54Z"}, "message": "Format some macros 2.0 macro defs\n\ncc #1539", "tree": {"sha": "754fb492376669522d18910981cdcdadbc66ac42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/754fb492376669522d18910981cdcdadbc66ac42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "html_url": "https://github.com/rust-lang/rust/commit/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47d9ccd6a1f072a19b53270b2cf09c2367138774", "url": "https://api.github.com/repos/rust-lang/rust/commits/47d9ccd6a1f072a19b53270b2cf09c2367138774", "html_url": "https://github.com/rust-lang/rust/commit/47d9ccd6a1f072a19b53270b2cf09c2367138774"}], "stats": {"total": 451, "additions": 437, "deletions": 14}, "files": [{"sha": "fb0cdf6aaf22580219a7098259b7bc82662d40d0", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "patch": "@@ -684,6 +684,7 @@ create_config! {\n             \"Enables unstable features. Only available on nightly channel\";\n     disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n     skip_children: bool, false, false, \"Don't reformat out of line modules\";\n+    hide_parse_errors: bool, false, false, \"Hide errors from the parser\";\n     error_on_line_overflow: bool, true, false, \"Error if unable to get all lines within max_width\";\n     error_on_unformatted: bool, false, false,\n         \"Error if unable to get comments or string literals within max_width, \\"}, {"sha": "111345a24b6cf9ef2c1d307b7b33b1b53e91df45", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(rustc_private)]\n+#![feature(type_ascription)]\n \n #[macro_use]\n extern crate derive_new;\n@@ -597,8 +598,16 @@ pub fn format_input<T: Write>(\n     }\n     let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n \n-    let tty_handler =\n-        Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(codemap.clone()));\n+    let tty_handler = if config.hide_parse_errors() {\n+        let silent_emitter = Box::new(EmitterWriter::new(\n+            Box::new(Vec::new()),\n+            Some(codemap.clone()),\n+            false,\n+        ));\n+        Handler::with_emitter(true, false, silent_emitter)\n+    } else {\n+        Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(codemap.clone()))\n+    };\n     let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n \n     let main_file = match input {"}, {"sha": "d642b31ef42be7fb000c13b89ac31cc59363a690", "filename": "src/macros.rs", "status": "modified", "additions": 412, "deletions": 5, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "patch": "@@ -19,21 +19,23 @@\n // List-like invocations with parentheses will be formatted as function calls,\n // and those with brackets will be formatted as array literals.\n \n+use std::collections::HashMap;\n use syntax::ast;\n-use syntax::codemap::BytePos;\n+use syntax::codemap::{BytePos, Span};\n use syntax::parse::new_parser_from_tts;\n use syntax::parse::parser::Parser;\n-use syntax::parse::token::Token;\n+use syntax::parse::token::{BinOpToken, DelimToken, Token};\n+use syntax::print::pprust;\n use syntax::symbol;\n-use syntax::tokenstream::TokenStream;\n+use syntax::tokenstream::{Cursor, ThinTokenStream, TokenStream, TokenTree};\n use syntax::util::ThinVec;\n \n use codemap::SpanUtils;\n-use comment::{contains_comment, FindUncommented};\n+use comment::{contains_comment, remove_trailing_white_spaces, FindUncommented};\n use expr::{rewrite_array, rewrite_call_inner};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n-use utils::mk_sp;\n+use utils::{format_visibility, mk_sp};\n \n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n \n@@ -278,6 +280,306 @@ pub fn rewrite_macro(\n     }\n }\n \n+pub fn rewrite_macro_def(\n+    context: &RewriteContext,\n+    indent: Indent,\n+    def: &ast::MacroDef,\n+    ident: ast::Ident,\n+    vis: &ast::Visibility,\n+    span: Span,\n+) -> Option<String> {\n+    let snippet = Some(remove_trailing_white_spaces(context.snippet(span)));\n+\n+    if def.legacy {\n+        return snippet;\n+    }\n+\n+    let mut parser = MacroParser::new(def.stream().into_trees());\n+    let mut parsed_def = match parser.parse() {\n+        Some(def) => def,\n+        None => return snippet,\n+    };\n+\n+    // Only attempt to format function-like macros.\n+    if parsed_def.branches.len() != 1 || parsed_def.branches[0].args_paren_kind != DelimToken::Paren\n+    {\n+        // FIXME(#1539): implement for non-sugared macros.\n+        return snippet;\n+    }\n+\n+    let branch = parsed_def.branches.remove(0);\n+    let args_str = format_macro_args(branch.args)?;\n+\n+    // The macro body is the most interesting part. It might end up as various\n+    // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n+    // parsed as regular Rust code (and note that these can be escaped using\n+    // `$$`). We'll try and format like an AST node, but we'll substitute\n+    // variables for new names with the same length first.\n+\n+    let body_sp = match branch.body {\n+        Some(sp) => sp,\n+        None => {\n+            // FIXME: should check the single-line empty function option\n+            return Some(format!(\n+                \"{}macro {}({}) {{}}\\n\",\n+                format_visibility(vis),\n+                ident,\n+                args_str,\n+            ));\n+        }\n+    };\n+    let old_body = context.snippet(body_sp);\n+    let (body_str, substs) = replace_names(old_body);\n+\n+    // We'll hack the indent below, take this into account when formatting,\n+    let mut config = context.config.clone();\n+    let new_width = config.max_width() - indent.block_indent(&config).width();\n+    config.set().max_width(new_width);\n+    config.set().hide_parse_errors(true);\n+\n+    // First try to format as items, then as statements.\n+    let new_body = match ::format_snippet(&body_str, &config) {\n+        Some(new_body) => new_body,\n+        None => match ::format_code_block(&body_str, &config) {\n+            Some(new_body) => new_body,\n+            None => return snippet,\n+        },\n+    };\n+\n+    // Indent the body since it is in a block.\n+    let indent_str = indent.block_indent(&config).to_string(&config);\n+    let mut new_body = new_body\n+        .lines()\n+        .map(|l| format!(\"{}{}\", indent_str, l))\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+\n+    // Undo our replacement of macro variables.\n+    // FIXME: this could be *much* more efficient.\n+    for (old, new) in substs.iter() {\n+        if old_body.find(new).is_some() {\n+            debug!(\n+                \"rewrite_macro_def: bailing matching variable: `{}` in `{}`\",\n+                new, ident\n+            );\n+            return snippet;\n+        }\n+        new_body = new_body.replace(new, old);\n+    }\n+\n+    let result = format!(\n+        \"{}macro {}({}) {{\\n{}\\n{}}}\",\n+        format_visibility(vis),\n+        ident,\n+        args_str,\n+        new_body,\n+        indent.to_string(&context.config),\n+    );\n+\n+    Some(result)\n+}\n+\n+// Replaces `$foo` with `zfoo`. We must check for name overlap to ensure we\n+// aren't causing problems.\n+// This should also work for escaped `$` variables, where we leave earlier `$`s.\n+fn replace_names(input: &str) -> (String, HashMap<String, String>) {\n+    // Each substitution will require five or six extra bytes.\n+    let mut result = String::with_capacity(input.len() + 64);\n+    let mut substs = HashMap::new();\n+    let mut dollar_count = 0;\n+    let mut cur_name = String::new();\n+\n+    for c in input.chars() {\n+        if c == '$' {\n+            dollar_count += 1;\n+        } else if dollar_count == 0 {\n+            result.push(c);\n+        } else if !c.is_alphanumeric() && !cur_name.is_empty() {\n+            // Terminates a name following one or more dollars.\n+            let mut new_name = String::new();\n+            let mut old_name = String::new();\n+            old_name.push('$');\n+            for _ in 0..(dollar_count - 1) {\n+                new_name.push('$');\n+                old_name.push('$');\n+            }\n+            new_name.push('z');\n+            new_name.push_str(&cur_name);\n+            old_name.push_str(&cur_name);\n+\n+            result.push_str(&new_name);\n+            substs.insert(old_name, new_name);\n+\n+            result.push(c);\n+\n+            dollar_count = 0;\n+            cur_name = String::new();\n+        } else if c.is_alphanumeric() {\n+            cur_name.push(c);\n+        }\n+    }\n+\n+    // FIXME: duplicate code\n+    if !cur_name.is_empty() {\n+        let mut new_name = String::new();\n+        let mut old_name = String::new();\n+        old_name.push('$');\n+        for _ in 0..(dollar_count - 1) {\n+            new_name.push('$');\n+            old_name.push('$');\n+        }\n+        new_name.push('z');\n+        new_name.push_str(&cur_name);\n+        old_name.push_str(&cur_name);\n+\n+        result.push_str(&new_name);\n+        substs.insert(old_name, new_name);\n+    }\n+\n+    debug!(\"replace_names `{}` {:?}\", result, substs);\n+\n+    (result, substs)\n+}\n+\n+// This is a bit sketchy. The token rules probably need tweaking, but it works\n+// for some common cases. I hope the basic logic is sufficient. Note that the\n+// meaning of some tokens is a bit different here from usual Rust, e.g., `*`\n+// and `(`/`)` have special meaning.\n+//\n+// We always try and format on one line.\n+fn format_macro_args(toks: ThinTokenStream) -> Option<String> {\n+    let mut result = String::with_capacity(128);\n+    let mut insert_space = SpaceState::Never;\n+\n+    for tok in (toks.into(): TokenStream).trees() {\n+        match tok {\n+            TokenTree::Token(_, t) => {\n+                if !result.is_empty() && force_space_before(&t) {\n+                    insert_space = SpaceState::Always;\n+                }\n+                if force_no_space_before(&t) {\n+                    insert_space = SpaceState::Never;\n+                }\n+                match (insert_space, ident_like(&t)) {\n+                    (SpaceState::Always, _)\n+                    | (SpaceState::Punctuation, false)\n+                    | (SpaceState::Ident, true) => {\n+                        result.push(' ');\n+                    }\n+                    _ => {}\n+                }\n+                result.push_str(&pprust::token_to_string(&t));\n+                insert_space = next_space(&t);\n+            }\n+            TokenTree::Delimited(_, d) => {\n+                let formatted = format_macro_args(d.tts)?;\n+                match insert_space {\n+                    SpaceState::Always => {\n+                        result.push(' ');\n+                    }\n+                    _ => {}\n+                }\n+                match d.delim {\n+                    DelimToken::Paren => {\n+                        result.push_str(&format!(\"({})\", formatted));\n+                        insert_space = SpaceState::Always;\n+                    }\n+                    DelimToken::Bracket => {\n+                        result.push_str(&format!(\"[{}]\", formatted));\n+                        insert_space = SpaceState::Always;\n+                    }\n+                    DelimToken::Brace => {\n+                        result.push_str(&format!(\" {{ {} }}\", formatted));\n+                        insert_space = SpaceState::Always;\n+                    }\n+                    DelimToken::NoDelim => {\n+                        result.push_str(&format!(\"{}\", formatted));\n+                        insert_space = SpaceState::Always;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    Some(result)\n+}\n+\n+// We should insert a space if the next token is a:\n+#[derive(Copy, Clone)]\n+enum SpaceState {\n+    Never,\n+    Punctuation,\n+    Ident, // Or ident/literal-like thing.\n+    Always,\n+}\n+\n+fn force_space_before(tok: &Token) -> bool {\n+    match *tok {\n+        Token::Eq\n+        | Token::Lt\n+        | Token::Le\n+        | Token::EqEq\n+        | Token::Ne\n+        | Token::Ge\n+        | Token::Gt\n+        | Token::AndAnd\n+        | Token::OrOr\n+        | Token::Not\n+        | Token::Tilde\n+        | Token::BinOpEq(_)\n+        | Token::At\n+        | Token::RArrow\n+        | Token::LArrow\n+        | Token::FatArrow\n+        | Token::Pound\n+        | Token::Dollar => true,\n+        Token::BinOp(bot) => bot != BinOpToken::Star,\n+        _ => false,\n+    }\n+}\n+\n+fn force_no_space_before(tok: &Token) -> bool {\n+    match *tok {\n+        Token::Semi | Token::Comma | Token::Dot => true,\n+        Token::BinOp(bot) => bot == BinOpToken::Star,\n+        _ => false,\n+    }\n+}\n+fn ident_like(tok: &Token) -> bool {\n+    match *tok {\n+        Token::Ident(_) | Token::Literal(..) | Token::Lifetime(_) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn next_space(tok: &Token) -> SpaceState {\n+    match *tok {\n+        Token::Not\n+        | Token::Tilde\n+        | Token::At\n+        | Token::Comma\n+        | Token::Dot\n+        | Token::DotDot\n+        | Token::DotDotDot\n+        | Token::DotDotEq\n+        | Token::DotEq\n+        | Token::Question\n+        | Token::Underscore\n+        | Token::BinOp(_) => SpaceState::Punctuation,\n+\n+        Token::ModSep\n+        | Token::Pound\n+        | Token::Dollar\n+        | Token::OpenDelim(_)\n+        | Token::CloseDelim(_)\n+        | Token::Whitespace => SpaceState::Never,\n+\n+        Token::Literal(..) | Token::Ident(_) | Token::Lifetime(_) => SpaceState::Ident,\n+\n+        _ => SpaceState::Always,\n+    }\n+}\n+\n /// Tries to convert a macro use into a short hand try expression. Returns None\n /// when the macro is not an instance of try! (or parsing the inner expression\n /// failed).\n@@ -393,3 +695,108 @@ fn get_prefix_space_width(context: &RewriteContext, s: &str) -> usize {\n fn is_empty_line(s: &str) -> bool {\n     s.is_empty() || s.chars().all(char::is_whitespace)\n }\n+\n+// A very simple parser that just parses a macros 2.0 definition into its branches.\n+// Currently we do not attempt to parse any further than that.\n+#[derive(new)]\n+struct MacroParser {\n+    toks: Cursor,\n+}\n+\n+impl MacroParser {\n+    // (`(` ... `)` `=>` `{` ... `}`)*\n+    fn parse(&mut self) -> Option<Macro> {\n+        let mut branches = vec![];\n+        while self.toks.look_ahead(1).is_some() {\n+            branches.push(self.parse_branch()?);\n+        }\n+\n+        Some(Macro { branches })\n+    }\n+\n+    // `(` ... `)` `=>` `{` ... `}`\n+    fn parse_branch(&mut self) -> Option<MacroBranch> {\n+        let (args_paren_kind, args) = match self.toks.next()? {\n+            TokenTree::Token(..) => return None,\n+            TokenTree::Delimited(_, ref d) => (d.delim, d.tts.clone().into()),\n+        };\n+        match self.toks.next()? {\n+            TokenTree::Token(_, Token::FatArrow) => {}\n+            _ => return None,\n+        }\n+        let body = match self.toks.next()? {\n+            TokenTree::Token(..) => return None,\n+            TokenTree::Delimited(_, ref d) => inner_span(d.tts.clone().into()),\n+        };\n+        Some(MacroBranch {\n+            args,\n+            args_paren_kind,\n+            body,\n+        })\n+    }\n+}\n+\n+fn inner_span(ts: TokenStream) -> Option<Span> {\n+    let mut cursor = ts.trees();\n+    let first = match cursor.next() {\n+        Some(t) => t.span(),\n+        None => return None,\n+    };\n+\n+    let last = match cursor.last() {\n+        Some(t) => t.span(),\n+        None => return Some(first),\n+    };\n+\n+    Some(first.to(last))\n+}\n+\n+// A parsed macros 2.0 macro definition.\n+struct Macro {\n+    branches: Vec<MacroBranch>,\n+}\n+\n+// FIXME: it would be more efficient to use references to the token streams\n+// rather than clone them, if we can make the borrowing work out.\n+struct MacroBranch {\n+    args: ThinTokenStream,\n+    args_paren_kind: DelimToken,\n+    body: Option<Span>,\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use syntax::parse::{parse_stream_from_source_str, ParseSess};\n+    use syntax::codemap::{FileName, FilePathMapping};\n+\n+    fn format_macro_args_str(s: &str) -> String {\n+        let input = parse_stream_from_source_str(\n+            FileName::Custom(\"stdin\".to_owned()),\n+            s.to_owned(),\n+            &ParseSess::new(FilePathMapping::empty()),\n+            None,\n+        );\n+        format_macro_args(input.into()).unwrap()\n+    }\n+\n+    #[test]\n+    fn test_format_macro_args() {\n+        assert_eq!(format_macro_args_str(\"\"), \"\".to_owned());\n+        assert_eq!(format_macro_args_str(\"$ x : ident\"), \"$x: ident\".to_owned());\n+        assert_eq!(\n+            format_macro_args_str(\"$ m1 : ident , $ m2 : ident , $ x : ident\"),\n+            \"$m1: ident, $m2: ident, $x: ident\".to_owned()\n+        );\n+        assert_eq!(\n+            format_macro_args_str(\"$($beginning:ident),*;$middle:ident;$($end:ident),*\"),\n+            \"$($beginning: ident),*; $middle: ident; $($end: ident),*\".to_owned()\n+        );\n+        assert_eq!(\n+            format_macro_args_str(\n+                \"$ name : ident ( $ ( $ dol : tt $ var : ident ) * ) $ ( $ body : tt ) *\"\n+            ),\n+            \"$name: ident($($dol: tt $var: ident)*) $($body: tt)*\".to_owned()\n+        );\n+    }\n+}"}, {"sha": "3e454876307ca86510d55eea42123afe52201e82", "filename": "src/visitor.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=f86f6dcd9c33fa7b2b1bcda29edbed4d4fd9cba2", "patch": "@@ -16,16 +16,16 @@ use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n \n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{combine_strs_with_missing_comments, contains_comment, remove_trailing_white_spaces,\n-              CodeCharKind, CommentCodeSlices, FindUncommented};\n+use comment::{combine_strs_with_missing_comments, contains_comment, CodeCharKind,\n+              CommentCodeSlices, FindUncommented};\n use comment::rewrite_comment;\n use config::{BraceStyle, Config};\n use expr::rewrite_literal;\n use items::{format_impl, format_trait, format_trait_alias, rewrite_associated_impl_type,\n             rewrite_associated_type, rewrite_type_alias, FnSig, StaticParts, StructParts};\n use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorPlace,\n             SeparatorTactic};\n-use macros::{rewrite_macro, MacroPosition};\n+use macros::{rewrite_macro, rewrite_macro_def, MacroPosition};\n use regex::Regex;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n@@ -439,10 +439,16 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 let snippet = Some(self.snippet(item.span).to_owned());\n                 self.push_rewrite(item.span, snippet);\n             }\n-            ast::ItemKind::MacroDef(..) => {\n-                // FIXME(#1539): macros 2.0\n-                let mac_snippet = Some(remove_trailing_white_spaces(self.snippet(item.span)));\n-                self.push_rewrite(item.span, mac_snippet);\n+            ast::ItemKind::MacroDef(ref def) => {\n+                let rewrite = rewrite_macro_def(\n+                    &self.get_context(),\n+                    self.block_indent,\n+                    def,\n+                    item.ident,\n+                    &item.vis,\n+                    item.span,\n+                );\n+                self.push_rewrite(item.span, rewrite);\n             }\n         }\n     }"}]}