{"sha": "cac3e5a93556acd714963274162c0d599af697ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYzNlNWE5MzU1NmFjZDcxNDk2MzI3NDE2MmMwZDU5OWFmNjk3Y2U=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-10-23T03:02:37Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-10-23T03:07:50Z"}, "message": "Run rustfmt on metadata folder - (1/2)", "tree": {"sha": "ceea7e871ee9580bc00d1f858ecd1f981b9bdda1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceea7e871ee9580bc00d1f858ecd1f981b9bdda1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cac3e5a93556acd714963274162c0d599af697ce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYDCmkAAoJEAkcWPS/w2VxrzYP/jQjI+lkbTFRNj17S202hhij\nzfUp50IWBILHRuxfvLV0kaRND+jZD8jkQGC5NRZk2IT0Y1QmABgG+as7R9C8xzme\nplKYSrOVWdBp33KJenF1uSSKHgkRxRQErNgyH2FgqAk+T1n5Qq+CaKQHuQZb3H+J\nxK+vkEmzozOsWrUVX3cuNbFtWDx6OcL0wMMZWiXpYWkV3RfW2r3HH4f7B+F2VPpk\nstxqKfFRVwA/o6LxKcp6rctBQQDXCHE1pXjN/om0t1p/oYZxg4whpB8z93/MXlP5\nLCSC0eRbQk5n9VTllrBQrr+Soow0v56J5QpoX5EO3VgpNfWs2WaabpgA6wBKoGid\nxn3OKN8rDvT72UTt2VxJPL+K549t7kiesK/iTpyguuBSHWBv8K9Zw0HMt58ZRnmv\nQrNzT3KEGV+UrWrFNRZCz9OKlmWfN2S2HgX622Cr9xpfHmlihc7Jcq/DOeW2SyEi\nwoQQggNHT1TidsX3tsLamA2vCRf4iQ7wFwbfPoJXbOWIm592prhDYP1uwJUS9eUd\nnD9vmNSzWrYWM3Lc3MNjNHNiMENXkWCthhj7EWSA67ozJaB/bsS6a3rPw4/Gaxee\nASrGMcGqoK0+vV4miyb6Bg8Cnqin+iSz7zlkI18trpJlsE3WRtUvl0ZTcGiHCxbI\no6QWpiTftimM5AxjwwKw\n=KFMJ\n-----END PGP SIGNATURE-----", "payload": "tree ceea7e871ee9580bc00d1f858ecd1f981b9bdda1\nparent 4845adde360c306624faa3305ea95f95cd11e2b4\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1477191757 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1477192070 +0530\n\nRun rustfmt on metadata folder - (1/2)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cac3e5a93556acd714963274162c0d599af697ce", "html_url": "https://github.com/rust-lang/rust/commit/cac3e5a93556acd714963274162c0d599af697ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cac3e5a93556acd714963274162c0d599af697ce/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4845adde360c306624faa3305ea95f95cd11e2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4845adde360c306624faa3305ea95f95cd11e2b4", "html_url": "https://github.com/rust-lang/rust/commit/4845adde360c306624faa3305ea95f95cd11e2b4"}], "stats": {"total": 597, "additions": 336, "deletions": 261}, "files": [{"sha": "f001f8513197894608907d2031976a41271173e3", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cac3e5a93556acd714963274162c0d599af697ce/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac3e5a93556acd714963274162c0d599af697ce/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=cac3e5a93556acd714963274162c0d599af697ce", "patch": "@@ -30,7 +30,7 @@ use rustc_serialize::Encodable;\n pub struct Ast<'tcx> {\n     id_range: IdRange,\n     item: Lazy<InlinedItem>,\n-    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>\n+    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -39,7 +39,7 @@ enum TableEntry<'tcx> {\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n     Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n-    ConstQualif(ConstQualif)\n+    ConstQualif(ConstQualif),\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         match ii {\n             InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n             InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),\n-            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii)\n+            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii),\n         }\n \n         let ii_pos = self.position();\n@@ -58,27 +58,27 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tables_count = {\n             let mut visitor = SideTableEncodingIdVisitor {\n                 ecx: self,\n-                count: 0\n+                count: 0,\n             };\n             match ii {\n                 InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n                 InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii),\n             }\n             visitor.count\n         };\n \n         self.lazy(&Ast {\n             id_range: id_visitor.result(),\n             item: Lazy::with_position(ii_pos),\n-            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count)\n+            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n         })\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n+struct SideTableEncodingIdVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    count: usize\n+    count: usize,\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n@@ -114,10 +114,11 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n \n     let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n     let start = tcx.sess.reserve_node_ids(cnt);\n-    let id_ranges = [ast.id_range, IdRange {\n-        min: start,\n-        max: ast::NodeId::new(start.as_usize() + cnt)\n-    }];\n+    let id_ranges = [ast.id_range,\n+                     IdRange {\n+                         min: start,\n+                         max: ast::NodeId::new(start.as_usize() + cnt),\n+                     }];\n \n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n     let ii = ast_map::map_decoded_item(&tcx.map,\n@@ -129,7 +130,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n     let item_node_id = match ii {\n         &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n     };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n     tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));"}, {"sha": "f0952fd145d597f9922f84f982785166a70d894d", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cac3e5a93556acd714963274162c0d599af697ce/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac3e5a93556acd714963274162c0d599af697ce/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=cac3e5a93556acd714963274162c0d599af697ce", "patch": "@@ -54,7 +54,7 @@ pub struct ImportedFileMap {\n     /// The end of this FileMap within the codemap of its original crate\n     pub original_end_pos: syntax_pos::BytePos,\n     /// The imported FileMap's representation within the local codemap\n-    pub translated_filemap: Rc<syntax_pos::FileMap>\n+    pub translated_filemap: Rc<syntax_pos::FileMap>,\n }\n \n pub struct CrateMetadata {\n@@ -141,21 +141,23 @@ impl CStore {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(CrateNum, &Rc<CrateMetadata>),\n+    pub fn iter_crate_data<I>(&self, mut i: I)\n+        where I: FnMut(CrateNum, &Rc<CrateMetadata>)\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n         }\n     }\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n-    pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>),\n+    pub fn iter_crate_data_origins<I>(&self, mut i: I)\n+        where I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>)\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n-            origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n+            origin.as_ref().map(|cs| {\n+                assert!(k == cs.cnum);\n+            });\n             i(k, &v, origin);\n         }\n     }\n@@ -167,10 +169,12 @@ impl CStore {\n         }\n     }\n \n-    pub fn opt_used_crate_source(&self, cnum: CrateNum)\n-                                 -> Option<CrateSource> {\n-        self.used_crate_sources.borrow_mut()\n-            .iter().find(|source| source.cnum == cnum).cloned()\n+    pub fn opt_used_crate_source(&self, cnum: CrateNum) -> Option<CrateSource> {\n+        self.used_crate_sources\n+            .borrow_mut()\n+            .iter()\n+            .find(|source| source.cnum == cnum)\n+            .cloned()\n     }\n \n     pub fn reset(&self) {\n@@ -182,19 +186,17 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n-    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum>\n-    {\n+    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n         ordering.reverse();\n         ordering\n     }\n \n-    pub fn push_dependencies_in_postorder(&self,\n-                                          ordering: &mut Vec<CrateNum>,\n-                                          krate: CrateNum)\n-    {\n-        if ordering.contains(&krate) { return }\n+    pub fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n+        if ordering.contains(&krate) {\n+            return;\n+        }\n \n         let data = self.get_crate_data(krate);\n         for &dep in data.cnum_map.borrow().iter() {\n@@ -215,20 +217,25 @@ impl CStore {\n     // In order to get this left-to-right dependency ordering, we perform a\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n-    pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n+    pub fn do_get_used_crates(&self,\n+                              prefer: LinkagePreference)\n                               -> Vec<(CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n-        let mut libs = self.used_crate_sources.borrow()\n+        let mut libs = self.used_crate_sources\n+            .borrow()\n             .iter()\n-            .map(|src| (src.cnum, match prefer {\n-                LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n-                LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n-            }))\n+            .map(|src| {\n+                (src.cnum,\n+                 match prefer {\n+                     LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n+                     LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n+                 })\n+            })\n             .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {\n             let a = ordering.iter().position(|x| *x == a);\n@@ -243,9 +250,7 @@ impl CStore {\n         self.used_libraries.borrow_mut().push((lib, kind));\n     }\n \n-    pub fn get_used_libraries<'a>(&'a self)\n-                              -> &'a RefCell<Vec<(String,\n-                                                  NativeLibraryKind)>> {\n+    pub fn get_used_libraries<'a>(&'a self) -> &'a RefCell<Vec<(String, NativeLibraryKind)>> {\n         &self.used_libraries\n     }\n \n@@ -255,13 +260,11 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String> > {\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String>> {\n         &self.used_link_args\n     }\n \n-    pub fn add_extern_mod_stmt_cnum(&self,\n-                                    emod_id: ast::NodeId,\n-                                    cnum: CrateNum) {\n+    pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n@@ -273,8 +276,7 @@ impl CStore {\n         self.statically_included_foreign_items.borrow().contains(&id)\n     }\n \n-    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n-    {\n+    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n \n@@ -288,14 +290,20 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn name(&self) -> &str { &self.root.name }\n-    pub fn hash(&self) -> Svh { self.root.hash }\n-    pub fn disambiguator(&self) -> &str { &self.root.disambiguator }\n+    pub fn name(&self) -> &str {\n+        &self.root.name\n+    }\n+    pub fn hash(&self) -> Svh {\n+        self.root.hash\n+    }\n+    pub fn disambiguator(&self) -> &str {\n+        &self.root.disambiguator\n+    }\n \n     pub fn is_staged_api(&self) -> bool {\n-        self.get_item_attrs(CRATE_DEF_INDEX).iter().any(|attr| {\n-            attr.name() == \"stable\" || attr.name() == \"unstable\"\n-        })\n+        self.get_item_attrs(CRATE_DEF_INDEX)\n+            .iter()\n+            .any(|attr| attr.name() == \"stable\" || attr.name() == \"unstable\")\n     }\n \n     pub fn is_allocator(&self) -> bool {"}, {"sha": "18b5c0fde1f4c1a829751817946a4e4706002cd5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 276, "deletions": 210, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/cac3e5a93556acd714963274162c0d599af697ce/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac3e5a93556acd714963274162c0d599af697ce/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cac3e5a93556acd714963274162c0d599af697ce", "patch": "@@ -56,19 +56,23 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n \n-    lazy_state: LazyState\n+    lazy_state: LazyState,\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n-    fn cdata(self) -> Option<&'a CrateMetadata> { None }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        None\n+    }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+        None\n+    }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let id_range = IdRange {\n             min: NodeId::from_u32(u32::MIN),\n-            max: NodeId::from_u32(u32::MAX)\n+            max: NodeId::from_u32(u32::MAX),\n         };\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n@@ -77,7 +81,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             from_id_range: id_range,\n             to_id_range: id_range,\n             last_filemap_index: 0,\n-            lazy_state: LazyState::NoNode\n+            lazy_state: LazyState::NoNode,\n         }\n     }\n }\n@@ -92,21 +96,37 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n-    fn raw_bytes(self) -> &'a [u8] { self.blob.raw_bytes() }\n-    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self) }\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.blob.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self)\n+    }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n-    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n-    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.0.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self.0)\n+    }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+        Some(self.1)\n+    }\n }\n \n // HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n-    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n-    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.0.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self.0)\n+    }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+        Some(self.1)\n+    }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let mut dcx = (self.0, self.1).decoder(pos);\n@@ -125,12 +145,10 @@ impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n }\n \n impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item=T> + 'a {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item = T> + 'a {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.len).map(move |_| {\n-            T::decode(&mut dcx).unwrap()\n-        })\n+        (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n }\n \n@@ -153,20 +171,15 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         r\n     }\n \n-    fn read_lazy_distance(&mut self, min_size: usize)\n-                          -> Result<usize, <Self as Decoder>::Error> {\n+    fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n-            LazyState::NoNode => {\n-                bug!(\"read_lazy_distance: outside of a metadata node\")\n-            }\n+            LazyState::NoNode => bug!(\"read_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n-            LazyState::Previous(last_min_end) => {\n-                last_min_end + distance\n-            }\n+            LazyState::Previous(last_min_end) => last_min_end + distance,\n         };\n         self.lazy_state = LazyState::Previous(position + min_size);\n         Ok(position)\n@@ -239,13 +252,15 @@ impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n         // meaningful result\n         if !self.from_id_range.contains(NodeId::from_u32(id)) {\n             bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n-                 id, self.from_id_range, self.to_id_range);\n+                 id,\n+                 self.from_id_range,\n+                 self.to_id_range);\n         }\n \n         // Use wrapping arithmetic because otherwise it introduces control flow.\n         // Maybe we should just have the control flow? -- aatch\n         Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n-                              .wrapping_add(self.to_id_range.min.as_u32())))\n+            .wrapping_add(self.to_id_range.min.as_u32())))\n     }\n }\n \n@@ -290,10 +305,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             // originate from the same filemap.\n             let last_filemap = &imported_filemaps[self.last_filemap_index];\n \n-            if lo >= last_filemap.original_start_pos &&\n-            lo <= last_filemap.original_end_pos &&\n-            hi >= last_filemap.original_start_pos &&\n-            hi <= last_filemap.original_end_pos {\n+            if lo >= last_filemap.original_start_pos && lo <= last_filemap.original_end_pos &&\n+               hi >= last_filemap.original_start_pos &&\n+               hi <= last_filemap.original_end_pos {\n                 last_filemap\n             } else {\n                 let mut a = 0;\n@@ -313,10 +327,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             }\n         };\n \n-        let lo = (lo - filemap.original_start_pos) +\n-                  filemap.translated_filemap.start_pos;\n-        let hi = (hi - filemap.original_start_pos) +\n-                  filemap.translated_filemap.start_pos;\n+        let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n+        let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n \n         Ok(syntax_pos::mk_sp(lo, hi))\n     }\n@@ -336,7 +348,7 @@ impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n             assert!(pos >= SHORTHAND_OFFSET);\n             let key = ty::CReaderCacheKey {\n                 cnum: self.cdata().cnum,\n-                pos: pos - SHORTHAND_OFFSET\n+                pos: pos - SHORTHAND_OFFSET,\n             };\n             if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n                 return Ok(ty);\n@@ -357,17 +369,18 @@ impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext\n         Ok(ty::GenericPredicates {\n             parent: Decodable::decode(self)?,\n             predicates: (0..self.read_usize()?).map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n-                    let pos = self.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let pos = pos - SHORTHAND_OFFSET;\n-\n-                    self.with_position(pos, ty::Predicate::decode)\n-                } else {\n-                    ty::Predicate::decode(self)\n-                }\n-            }).collect::<Result<Vec<_>, _>>()?\n+                    // Handle shorthands first, if we have an usize > 0x80.\n+                    if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+                        let pos = self.read_usize()?;\n+                        assert!(pos >= SHORTHAND_OFFSET);\n+                        let pos = pos - SHORTHAND_OFFSET;\n+\n+                        self.with_position(pos, ty::Predicate::decode)\n+                    } else {\n+                        ty::Predicate::decode(self)\n+                    }\n+                })\n+                .collect::<Result<Vec<_>, _>>()?,\n         })\n     }\n }\n@@ -411,8 +424,7 @@ impl<'a, 'tcx> MetadataBlob {\n     pub fn get_root(&self) -> CrateRoot {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n-        let pos = (((slice[offset + 0] as u32) << 24) |\n-                   ((slice[offset + 1] as u32) << 16) |\n+        let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n         Lazy::with_position(pos).decode(self)\n@@ -421,9 +433,9 @@ impl<'a, 'tcx> MetadataBlob {\n     /// Go through each item in the metadata and create a map from that\n     /// item's def-key to the item's DefIndex.\n     pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n-        index.iter_enumerated(self.raw_bytes()).map(|(index, item)| {\n-            (item.decode(self).def_key.decode(self), index)\n-        }).collect()\n+        index.iter_enumerated(self.raw_bytes())\n+            .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n+            .collect()\n     }\n \n     pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n@@ -440,7 +452,7 @@ impl<'a, 'tcx> MetadataBlob {\n impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            EntryKind::Const  => Def::Const(did),\n+            EntryKind::Const => Def::Const(did),\n             EntryKind::AssociatedConst(_) => Def::AssociatedConst(did),\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n@@ -462,9 +474,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::DefaultImpl(_) |\n             EntryKind::Field |\n-            EntryKind::Closure (_) => {\n-                return None\n-            }\n+            EntryKind::Closure(_) => return None,\n         })\n     }\n }\n@@ -476,23 +486,29 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n         match self.maybe_entry(item_id) {\n-            None => bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n-                         item_id,\n-                         self.name,\n-                         self.cnum),\n-            Some(d) => d.decode(self)\n+            None => {\n+                bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n+                     item_id,\n+                     self.name,\n+                     self.cnum)\n+            }\n+            Some(d) => d.decode(self),\n         }\n     }\n \n     fn local_def_id(&self, index: DefIndex) -> DefId {\n         DefId {\n             krate: self.cnum,\n-            index: index\n+            index: index,\n         }\n     }\n \n     fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n-        item.def_key.decode(self).disambiguated_data.data.get_opt_name()\n+        item.def_key\n+            .decode(self)\n+            .disambiguated_data\n+            .data\n+            .get_opt_name()\n             .expect(\"no name in item_name\")\n     }\n \n@@ -502,55 +518,66 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n-                         tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx> {\n+                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                         -> ty::TraitDef<'tcx> {\n         let data = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self),\n-            _ => bug!()\n+            _ => bug!(),\n         };\n \n-        ty::TraitDef::new(data.unsafety, data.paren_sugar,\n+        ty::TraitDef::new(data.unsafety,\n+                          data.paren_sugar,\n                           tcx.lookup_generics(self.local_def_id(item_id)),\n                           data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }\n \n-    fn get_variant(&self, item: &Entry<'tcx>, index: DefIndex)\n+    fn get_variant(&self,\n+                   item: &Entry<'tcx>,\n+                   index: DefIndex)\n                    -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data) |\n             EntryKind::Union(data) => data.decode(self),\n-            _ => bug!()\n+            _ => bug!(),\n         };\n \n-        let fields = item.children.decode(self).map(|index| {\n-            let f = self.entry(index);\n-            ty::FieldDefData::new(self.local_def_id(index),\n-                                  self.item_name(&f),\n-                                  f.visibility)\n-        }).collect();\n+        let fields = item.children\n+            .decode(self)\n+            .map(|index| {\n+                let f = self.entry(index);\n+                ty::FieldDefData::new(self.local_def_id(index), self.item_name(&f), f.visibility)\n+            })\n+            .collect();\n \n         (ty::VariantDefData {\n-            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(item),\n-            fields: fields,\n-            disr_val: ConstInt::Infer(data.disr),\n-            ctor_kind: data.ctor_kind,\n-        }, data.struct_ctor)\n-    }\n-\n-    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+             name: self.item_name(item),\n+             fields: fields,\n+             disr_val: ConstInt::Infer(data.disr),\n+             ctor_kind: data.ctor_kind,\n+         },\n+         data.struct_ctor)\n+    }\n+\n+    pub fn get_adt_def(&self,\n+                       item_id: DefIndex,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                        -> ty::AdtDefMaster<'tcx> {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n         let variants = if let EntryKind::Enum = item.kind {\n-            item.children.decode(self).map(|index| {\n-                let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n-                assert_eq!(struct_ctor, None);\n-                variant\n-            }).collect()\n-        } else{\n+            item.children\n+                .decode(self)\n+                .map(|index| {\n+                    let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n+                    assert_eq!(struct_ctor, None);\n+                    variant\n+                })\n+                .collect()\n+        } else {\n             let (variant, struct_ctor) = self.get_variant(&item, item_id);\n             ctor_index = struct_ctor;\n             vec![variant]\n@@ -559,7 +586,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Enum => ty::AdtKind::Enum,\n             EntryKind::Struct(_) => ty::AdtKind::Struct,\n             EntryKind::Union(_) => ty::AdtKind::Union,\n-            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did)\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n         let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -572,33 +599,41 @@ impl<'a, 'tcx> CrateMetadata {\n         // to support recursive structures\n         for variant in &adt.variants {\n             for field in &variant.fields {\n-                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+                debug!(\"evaluating the type of {:?}::{:?}\",\n+                       variant.name,\n+                       field.name);\n                 let ty = self.get_type(field.did.index, tcx);\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                       variant.name, field.name, ty);\n+                       variant.name,\n+                       field.name,\n+                       ty);\n             }\n         }\n \n         adt\n     }\n \n-    pub fn get_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_predicates(&self,\n+                          item_id: DefIndex,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_super_predicates(&self,\n+                                item_id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> ty::GenericPredicates<'tcx> {\n         match self.entry(item_id).kind {\n-            EntryKind::Trait(data) => {\n-                data.decode(self).super_predicates.decode((self, tcx))\n-            }\n-            _ => bug!()\n+            EntryKind::Trait(data) => data.decode(self).super_predicates.decode((self, tcx)),\n+            _ => bug!(),\n         }\n     }\n \n-    pub fn get_generics(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_generics(&self,\n+                        item_id: DefIndex,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                         -> ty::Generics<'tcx> {\n         self.entry(item_id).generics.unwrap().decode((self, tcx))\n     }\n@@ -622,7 +657,7 @@ impl<'a, 'tcx> CrateMetadata {\n     fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n         match self.entry(id).kind {\n             EntryKind::Impl(data) => data.decode(self),\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n@@ -634,7 +669,8 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_custom_coerce_unsized_kind(&self, id: DefIndex)\n+    pub fn get_custom_coerce_unsized_kind(&self,\n+                                          id: DefIndex)\n                                           -> Option<ty::adjustment::CustomCoerceUnsized> {\n         self.get_impl_data(id).coerce_unsized_kind\n     }\n@@ -674,37 +710,47 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(&self.entry(child_index))\n+                                    name: self.item_name(&self.entry(child_index)),\n                                 });\n                             }\n                         }\n                         continue;\n                     }\n-                    EntryKind::Impl(_) | EntryKind::DefaultImpl(_) => continue,\n+                    EntryKind::Impl(_) |\n+                    EntryKind::DefaultImpl(_) => continue,\n \n                     _ => {}\n                 }\n \n                 let def_key = child.def_key.decode(self);\n-                if let (Some(def), Some(name)) = (self.get_def(child_index),\n-                                                  def_key.disambiguated_data.data.get_opt_name()) {\n-                    callback(def::Export { def: def, name: name });\n+                if let (Some(def), Some(name)) =\n+                    (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n+                    callback(def::Export {\n+                        def: def,\n+                        name: name,\n+                    });\n                     // For non-reexport structs and variants add their constructors to children.\n                     // Reexport lists automatically contain constructors when necessary.\n                     match def {\n                         Def::Struct(..) => {\n                             if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n                                 let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n-                                callback(def::Export { def: ctor_def, name: name });\n+                                callback(def::Export {\n+                                    def: ctor_def,\n+                                    name: name,\n+                                });\n                             }\n                         }\n                         Def::Variant(def_id) => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             let ctor_kind = self.get_ctor_kind(child_index);\n                             let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-                            callback(def::Export { def: ctor_def, name: name });\n+                            callback(def::Export {\n+                                def: ctor_def,\n+                                name: name,\n+                            });\n                         }\n                         _ => {}\n                     }\n@@ -719,7 +765,9 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_ast(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+    pub fn maybe_get_item_ast(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: DefIndex)\n                               -> Option<&'tcx InlinedItem> {\n         debug!(\"Looking up item: {:?}\", id);\n         let item_doc = self.entry(id);\n@@ -737,12 +785,16 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_item_mir(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+    pub fn maybe_get_item_mir(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: DefIndex)\n                               -> Option<Mir<'tcx>> {\n         self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n     }\n \n-    pub fn get_impl_or_trait_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_impl_or_trait_item(&self,\n+                                  id: DefIndex,\n+                                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                   -> Option<ty::ImplOrTraitItem<'tcx>> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n@@ -769,9 +821,11 @@ impl<'a, 'tcx> CrateMetadata {\n                 let ity = item.ty.unwrap().decode((self, tcx));\n                 let fty = match ity.sty {\n                     ty::TyFnDef(.., fty) => fty,\n-                    _ => bug!(\n-                        \"the type {:?} of the method {:?} is not a function?\",\n-                        ity, name)\n+                    _ => {\n+                        bug!(\"the type {:?} of the method {:?} is not a function?\",\n+                             ity,\n+                             name)\n+                    }\n                 };\n \n                 let data = data.decode(self);\n@@ -799,7 +853,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     container: container.with_def_id(parent),\n                 }))\n             }\n-            _ => return None\n+            _ => return None,\n         })\n     }\n \n@@ -821,7 +875,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Struct(data) => {\n                 data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n             }\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -838,35 +892,45 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        self.entry(id).children.decode(self).map(|index| {\n-            self.item_name(&self.entry(index))\n-        }).collect()\n+        self.entry(id)\n+            .children\n+            .decode(self)\n+            .map(|index| self.item_name(&self.entry(index)))\n+            .collect()\n     }\n \n     fn get_attributes(&self, item: &Entry<'tcx>) -> Vec<ast::Attribute> {\n-        item.attributes.decode(self).map(|mut attr| {\n-            // Need new unique IDs: old thread-local IDs won't map to new threads.\n-            attr.node.id = attr::mk_attr_id();\n-            attr\n-        }).collect()\n+        item.attributes\n+            .decode(self)\n+            .map(|mut attr| {\n+                // Need new unique IDs: old thread-local IDs won't map to new threads.\n+                attr.node.id = attr::mk_attr_id();\n+                attr\n+            })\n+            .collect()\n     }\n \n     // Translate a DefId from the current compilation environment to a DefId\n     // for an external crate.\n     fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n         for (local, &global) in self.cnum_map.borrow().iter_enumerated() {\n             if global == did.krate {\n-                return Some(DefId { krate: local, index: did.index });\n+                return Some(DefId {\n+                    krate: local,\n+                    index: did.index,\n+                });\n             }\n         }\n \n         None\n     }\n \n     pub fn get_inherent_implementations_for_type(&self, id: DefIndex) -> Vec<DefId> {\n-        self.entry(id).inherent_impls.decode(self).map(|index| {\n-            self.local_def_id(index)\n-        }).collect()\n+        self.entry(id)\n+            .inherent_impls\n+            .decode(self)\n+            .map(|index| self.local_def_id(index))\n+            .collect()\n     }\n \n     pub fn get_implementations_for_trait(&self, filter: Option<DefId>, result: &mut Vec<DefId>) {\n@@ -875,7 +939,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n             Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n             Some(None) => return,\n-            None => None\n+            None => None,\n         };\n \n         // FIXME(eddyb) Make this O(1) instead of O(n).\n@@ -884,9 +948,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 continue;\n             }\n \n-            result.extend(trait_impls.impls.decode(self).map(|index| {\n-                self.local_def_id(index)\n-            }));\n+            result.extend(trait_impls.impls.decode(self).map(|index| self.local_def_id(index)));\n \n             if filter.is_some() {\n                 break;\n@@ -898,7 +960,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n                 EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n-                _ => None\n+                _ => None,\n             }\n         })\n     }\n@@ -909,10 +971,15 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n-        self.root.dylib_dependency_formats.decode(self).enumerate().flat_map(|(i, link)| {\n-            let cnum = CrateNum::new(i + 1);\n-            link.map(|link| (self.cnum_map.borrow()[cnum], link))\n-        }).collect()\n+        self.root\n+            .dylib_dependency_formats\n+            .decode(self)\n+            .enumerate()\n+            .flat_map(|(i, link)| {\n+                let cnum = CrateNum::new(i + 1);\n+                link.map(|link| (self.cnum_map.borrow()[cnum], link))\n+            })\n+            .collect()\n     }\n \n     pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n@@ -924,7 +991,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n-            _ => LazySeq::empty()\n+            _ => LazySeq::empty(),\n         };\n         arg_names.decode(self).collect()\n     }\n@@ -937,7 +1004,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let constness = match self.entry(id).kind {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n-            _ => hir::Constness::NotConst\n+            _ => hir::Constness::NotConst,\n         };\n         constness == hir::Constness::Const\n     }\n@@ -953,16 +1020,14 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic => true,\n \n-            EntryKind::Fn(_) | EntryKind::ForeignFn(_) => {\n-                self.get_generics(id, tcx).types.is_empty()\n-            }\n+            EntryKind::Fn(_) |\n+            EntryKind::ForeignFn(_) => self.get_generics(id, tcx).types.is_empty(),\n \n             _ => false,\n         };\n \n         if applicable {\n-            attr::contains_extern_indicator(tcx.sess.diagnostic(),\n-                                            &self.get_attributes(&item))\n+            attr::contains_extern_indicator(tcx.sess.diagnostic(), &self.get_attributes(&item))\n         } else {\n             false\n         }\n@@ -973,36 +1038,38 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n             EntryKind::ForeignFn(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n         match self.entry(trait_id).kind {\n             EntryKind::Trait(data) => data.decode(self).has_default_impl,\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n-        match self.entry(impl_id).kind  {\n+        match self.entry(impl_id).kind {\n             EntryKind::DefaultImpl(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn closure_kind(&self, closure_id: DefIndex) -> ty::ClosureKind {\n         match self.entry(closure_id).kind {\n             EntryKind::Closure(data) => data.decode(self).kind,\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n-    pub fn closure_ty(&self, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn closure_ty(&self,\n+                      closure_id: DefIndex,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                       -> ty::ClosureTy<'tcx> {\n         match self.entry(closure_id).kind {\n             EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n@@ -1045,7 +1112,8 @@ impl<'a, 'tcx> CrateMetadata {\n     /// file they represent, just information about length, line breaks, and\n     /// multibyte characters. This information is enough to generate valid debuginfo\n     /// for items inlined from other crates.\n-    pub fn imported_filemaps(&'a self, local_codemap: &codemap::CodeMap)\n+    pub fn imported_filemaps(&'a self,\n+                             local_codemap: &codemap::CodeMap)\n                              -> Ref<'a, Vec<cstore::ImportedFileMap>> {\n         {\n             let filemaps = self.codemap_import_info.borrow();\n@@ -1057,67 +1125,66 @@ impl<'a, 'tcx> CrateMetadata {\n         let external_codemap = self.root.codemap.decode(self);\n \n         let imported_filemaps = external_codemap.map(|filemap_to_import| {\n-            // Try to find an existing FileMap that can be reused for the filemap to\n-            // be imported. A FileMap is reusable if it is exactly the same, just\n-            // positioned at a different offset within the codemap.\n-            let reusable_filemap = {\n-                local_codemap.files\n-                             .borrow()\n-                             .iter()\n-                             .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n-                             .map(|rc| rc.clone())\n-            };\n+                // Try to find an existing FileMap that can be reused for the filemap to\n+                // be imported. A FileMap is reusable if it is exactly the same, just\n+                // positioned at a different offset within the codemap.\n+                let reusable_filemap = {\n+                    local_codemap.files\n+                        .borrow()\n+                        .iter()\n+                        .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n+                        .map(|rc| rc.clone())\n+                };\n \n-            match reusable_filemap {\n-                Some(fm) => {\n-                    cstore::ImportedFileMap {\n-                        original_start_pos: filemap_to_import.start_pos,\n-                        original_end_pos: filemap_to_import.end_pos,\n-                        translated_filemap: fm\n-                    }\n-                }\n-                None => {\n-                    // We can't reuse an existing FileMap, so allocate a new one\n-                    // containing the information we need.\n-                    let syntax_pos::FileMap {\n-                        name,\n-                        abs_path,\n-                        start_pos,\n-                        end_pos,\n-                        lines,\n-                        multibyte_chars,\n-                        ..\n-                    } = filemap_to_import;\n-\n-                    let source_length = (end_pos - start_pos).to_usize();\n-\n-                    // Translate line-start positions and multibyte character\n-                    // position into frame of reference local to file.\n-                    // `CodeMap::new_imported_filemap()` will then translate those\n-                    // coordinates to their new global frame of reference when the\n-                    // offset of the FileMap is known.\n-                    let mut lines = lines.into_inner();\n-                    for pos in &mut lines {\n-                        *pos = *pos - start_pos;\n-                    }\n-                    let mut multibyte_chars = multibyte_chars.into_inner();\n-                    for mbc in &mut multibyte_chars {\n-                        mbc.pos = mbc.pos - start_pos;\n+                match reusable_filemap {\n+                    Some(fm) => {\n+                        cstore::ImportedFileMap {\n+                            original_start_pos: filemap_to_import.start_pos,\n+                            original_end_pos: filemap_to_import.end_pos,\n+                            translated_filemap: fm,\n+                        }\n                     }\n+                    None => {\n+                        // We can't reuse an existing FileMap, so allocate a new one\n+                        // containing the information we need.\n+                        let syntax_pos::FileMap { name,\n+                                                  abs_path,\n+                                                  start_pos,\n+                                                  end_pos,\n+                                                  lines,\n+                                                  multibyte_chars,\n+                                                  .. } = filemap_to_import;\n+\n+                        let source_length = (end_pos - start_pos).to_usize();\n+\n+                        // Translate line-start positions and multibyte character\n+                        // position into frame of reference local to file.\n+                        // `CodeMap::new_imported_filemap()` will then translate those\n+                        // coordinates to their new global frame of reference when the\n+                        // offset of the FileMap is known.\n+                        let mut lines = lines.into_inner();\n+                        for pos in &mut lines {\n+                            *pos = *pos - start_pos;\n+                        }\n+                        let mut multibyte_chars = multibyte_chars.into_inner();\n+                        for mbc in &mut multibyte_chars {\n+                            mbc.pos = mbc.pos - start_pos;\n+                        }\n \n-                    let local_version = local_codemap.new_imported_filemap(name,\n-                                                                           abs_path,\n-                                                                           source_length,\n-                                                                           lines,\n-                                                                           multibyte_chars);\n-                    cstore::ImportedFileMap {\n-                        original_start_pos: start_pos,\n-                        original_end_pos: end_pos,\n-                        translated_filemap: local_version\n+                        let local_version = local_codemap.new_imported_filemap(name,\n+                                                                               abs_path,\n+                                                                               source_length,\n+                                                                               lines,\n+                                                                               multibyte_chars);\n+                        cstore::ImportedFileMap {\n+                            original_start_pos: start_pos,\n+                            original_end_pos: end_pos,\n+                            translated_filemap: local_version,\n+                        }\n                     }\n                 }\n-            }\n-        }).collect();\n+            })\n+            .collect();\n \n         // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n         *self.codemap_import_info.borrow_mut() = imported_filemaps;\n@@ -1151,8 +1218,7 @@ fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMa\n     }\n \n     for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n-        if (mb1.bytes != mb2.bytes) ||\n-            ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n+        if (mb1.bytes != mb2.bytes) || ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n             return false;\n         }\n     }"}]}