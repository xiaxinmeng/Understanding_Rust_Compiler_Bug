{"sha": "caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYWViOTI4ODJhMDgyYmYxYWM4YjdkNzRjMDljYTAyOTVjMmVkMTA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-23T19:56:38Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-23T19:56:38Z"}, "message": "Cleanup intra_doc_link parsing", "tree": {"sha": "e01edb95326d04eb7e6d525a6c0c7c986eba670e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e01edb95326d04eb7e6d525a6c0c7c986eba670e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "html_url": "https://github.com/rust-lang/rust/commit/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "html_url": "https://github.com/rust-lang/rust/commit/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a"}], "stats": {"total": 133, "additions": 51, "deletions": 82}, "files": [{"sha": "0cee741acffc29b22f85cb9cefd3f2e615281080", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 51, "deletions": 82, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "patch": "@@ -114,7 +114,7 @@ pub(crate) fn extract_definitions_from_markdown(\n     for (event, range) in doc.into_offset_iter() {\n         if let Event::Start(Tag::Link(_, target, title)) = event {\n             let link = if target.is_empty() { title } else { target };\n-            let (link, ns) = parse_link(&link);\n+            let (link, ns) = parse_intra_doc_link(&link);\n             res.push((range, link.to_string(), ns));\n         }\n     }\n@@ -276,26 +276,8 @@ fn rewrite_intra_doc_link(\n     title: &str,\n ) -> Option<(String, String)> {\n     let link = if target.is_empty() { title } else { target };\n-    let (link, ns) = parse_link(link);\n-    let resolved = match def {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Module(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Function(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Adt(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Variant(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Const(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Static(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Trait(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::BuiltinType(_) => return None,\n-        },\n-        Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n-        Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n-        Definition::SelfType(_)\n-        | Definition::Local(_)\n-        | Definition::GenericParam(_)\n-        | Definition::Label(_) => return None,\n-    }?;\n+    let (link, ns) = parse_intra_doc_link(link);\n+    let resolved = resolve_doc_path_for_def(db, def, link, ns)?;\n     let krate = resolved.module(db)?.krate();\n     let canonical_path = resolved.canonical_path(db)?;\n     let mut new_url = get_doc_url(db, &krate)?\n@@ -307,24 +289,23 @@ fn rewrite_intra_doc_link(\n         .ok()?;\n \n     if let ModuleDef::Trait(t) = resolved {\n-        let items = t.items(db);\n-        if let Some(field_or_assoc_item) = items.iter().find_map(|assoc_item| {\n+        if let Some(assoc_item) = t.items(db).into_iter().find_map(|assoc_item| {\n             if let Some(name) = assoc_item.name(db) {\n                 if *link == format!(\"{}::{}\", canonical_path, name) {\n-                    return Some(FieldOrAssocItem::AssocItem(*assoc_item));\n+                    return Some(assoc_item);\n                 }\n             }\n             None\n         }) {\n-            if let Some(fragment) = get_symbol_fragment(db, &field_or_assoc_item) {\n+            if let Some(fragment) =\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(assoc_item))\n+            {\n                 new_url = new_url.join(&fragment).ok()?;\n             }\n         };\n     }\n \n-    let new_target = new_url.into_string();\n-    let new_title = strip_prefixes_suffixes(title);\n-    Some((new_target, new_title.to_string()))\n+    Some((new_url.into_string(), strip_prefixes_suffixes(title).to_string()))\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n@@ -401,73 +382,61 @@ fn map_links<'e>(\n     })\n }\n \n-fn parse_link(s: &str) -> (&str, Option<hir::Namespace>) {\n-    let path = strip_prefixes_suffixes(s);\n-    let ns = ns_from_intra_spec(s);\n-    (path, ns)\n-}\n-\n-/// Strip prefixes, suffixes, and inline code marks from the given string.\n-fn strip_prefixes_suffixes(mut s: &str) -> &str {\n-    s = s.trim_matches('`');\n-\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .for_each(|(prefixes, suffixes)| {\n-        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n-        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n-    });\n-    s.trim_start_matches('@').trim()\n-}\n-\n-static TYPES: ([&str; 7], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n-static VALUES: ([&str; 8], [&str; 1]) =\n+const TYPES: ([&str; 9], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n+const VALUES: ([&str; 8], [&str; 1]) =\n     ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n+const MACROS: ([&str; 2], [&str; 1]) = ([\"macro\", \"derive\"], [\"!\"]);\n \n /// Extract the specified namespace from an intra-doc-link if one exists.\n ///\n /// # Examples\n ///\n-/// * `struct MyStruct` -> `Namespace::Types`\n-/// * `panic!` -> `Namespace::Macros`\n-/// * `fn@from_intra_spec` -> `Namespace::Values`\n-fn ns_from_intra_spec(s: &str) -> Option<hir::Namespace> {\n+/// * `struct MyStruct` -> (\"MyStruct\", `Namespace::Types`)\n+/// * `panic!` -> (\"panic\", `Namespace::Macros`)\n+/// * `fn@from_intra_spec` -> (\"from_intra_spec\", `Namespace::Values`)\n+fn parse_intra_doc_link(s: &str) -> (&str, Option<hir::Namespace>) {\n+    let s = s.trim_matches('`');\n+\n     [\n         (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n         (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n         (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n     ]\n     .iter()\n-    .filter(|(_ns, (prefixes, suffixes))| {\n-        prefixes\n-            .clone()\n-            .map(|prefix| {\n-                s.starts_with(*prefix)\n-                    && s.chars()\n-                        .nth(prefix.len() + 1)\n-                        .map(|c| c == '@' || c == ' ')\n-                        .unwrap_or(false)\n-            })\n-            .any(|cond| cond)\n-            || suffixes\n-                .clone()\n-                .map(|suffix| {\n-                    s.starts_with(*suffix)\n-                        && s.chars()\n-                            .nth(suffix.len() + 1)\n-                            .map(|c| c == '@' || c == ' ')\n-                            .unwrap_or(false)\n-                })\n-                .any(|cond| cond)\n+    .cloned()\n+    .find_map(|(ns, (mut prefixes, mut suffixes))| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some((&s[prefix.len() + 1..], ns))\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix).zip(Some(ns)))\n+        }\n+    })\n+    .map_or((s, None), |(s, ns)| (s, Some(ns)))\n+}\n+\n+fn strip_prefixes_suffixes(s: &str) -> &str {\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .cloned()\n+    .find_map(|(mut prefixes, mut suffixes)| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some(&s[prefix.len() + 1..])\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix))\n+        }\n     })\n-    .map(|(ns, (_, _))| *ns)\n-    .next()\n+    .unwrap_or(s)\n }\n \n /// Get the root URL for the documentation of a crate."}]}