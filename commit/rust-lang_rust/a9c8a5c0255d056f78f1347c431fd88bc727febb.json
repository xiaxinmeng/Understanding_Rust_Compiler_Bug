{"sha": "a9c8a5c0255d056f78f1347c431fd88bc727febb", "node_id": "C_kwDOAAsO6NoAKGE5YzhhNWMwMjU1ZDA1NmY3OGYxMzQ3YzQzMWZkODhiYzcyN2ZlYmI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-01T16:26:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-01T18:35:02Z"}, "message": "ast: Optimize list and value extraction primitives for attributes\n\nIt's not necessary to convert the whole attribute into a meta item to extract something specific", "tree": {"sha": "7da1965fcf37eba9cdbba514ac50e9cf3ef40394", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da1965fcf37eba9cdbba514ac50e9cf3ef40394"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c8a5c0255d056f78f1347c431fd88bc727febb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c8a5c0255d056f78f1347c431fd88bc727febb", "html_url": "https://github.com/rust-lang/rust/commit/a9c8a5c0255d056f78f1347c431fd88bc727febb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c8a5c0255d056f78f1347c431fd88bc727febb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d96b59307b1702fffe871bfc2d0145d070881e", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d96b59307b1702fffe871bfc2d0145d070881e", "html_url": "https://github.com/rust-lang/rust/commit/11d96b59307b1702fffe871bfc2d0145d070881e"}], "stats": {"total": 166, "additions": 90, "deletions": 76}, "files": [{"sha": "f2258fecfeafc6645a4b78cdd142470f6328eeb2", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=a9c8a5c0255d056f78f1347c431fd88bc727febb", "patch": "@@ -1826,6 +1826,13 @@ pub enum LitKind {\n }\n \n impl LitKind {\n+    pub fn str(&self) -> Option<Symbol> {\n+        match *self {\n+            LitKind::Str(s, _) => Some(s),\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns `true` if this literal is a string.\n     pub fn is_str(&self) -> bool {\n         matches!(self, LitKind::Str(..))"}, {"sha": "cd60506dd80795b1e9314ec6aeaec8f668267526", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=a9c8a5c0255d056f78f1347c431fd88bc727febb", "patch": "@@ -140,17 +140,14 @@ impl Attribute {\n \n     pub fn value_str(&self) -> Option<Symbol> {\n         match &self.kind {\n-            AttrKind::Normal(normal) => normal.item.meta_kind().and_then(|kind| kind.value_str()),\n+            AttrKind::Normal(normal) => normal.item.value_str(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n         match &self.kind {\n-            AttrKind::Normal(normal) => match normal.item.meta_kind() {\n-                Some(MetaItemKind::List(list)) => Some(list),\n-                _ => None,\n-            },\n+            AttrKind::Normal(normal) => normal.item.meta_item_list(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n@@ -216,6 +213,20 @@ impl MetaItem {\n     }\n }\n \n+impl AttrArgsEq {\n+    fn value_str(&self) -> Option<Symbol> {\n+        match self {\n+            AttrArgsEq::Ast(expr) => match expr.kind {\n+                ExprKind::Lit(token_lit) => {\n+                    LitKind::from_token_lit(token_lit).ok().and_then(|lit| lit.str())\n+                }\n+                _ => None,\n+            },\n+            AttrArgsEq::Hir(lit) => lit.kind.str(),\n+        }\n+    }\n+}\n+\n impl AttrItem {\n     pub fn span(&self) -> Span {\n         self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n@@ -228,6 +239,22 @@ impl AttrItem {\n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n         MetaItemKind::from_attr_args(&self.args)\n     }\n+\n+    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+        match &self.args {\n+            AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n+                MetaItemKind::list_from_tokens(args.tokens.clone())\n+            }\n+            AttrArgs::Delimited(_) | AttrArgs::Eq(..) | AttrArgs::Empty => None,\n+        }\n+    }\n+\n+    fn value_str(&self) -> Option<Symbol> {\n+        match &self.args {\n+            AttrArgs::Eq(_, args) => args.value_str(),\n+            AttrArgs::Delimited(_) | AttrArgs::Empty => None,\n+        }\n+    }\n }\n \n impl Attribute {\n@@ -247,13 +274,11 @@ impl Attribute {\n     /// * `#[doc = \"doc\"]` returns `Some((\"doc\", CommentKind::Line))`.\n     /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str_and_comment_kind(&self) -> Option<(Symbol, CommentKind)> {\n-        match self.kind {\n-            AttrKind::DocComment(kind, data) => Some((data, kind)),\n-            AttrKind::Normal(ref normal) if normal.item.path == sym::doc => normal\n-                .item\n-                .meta_kind()\n-                .and_then(|kind| kind.value_str())\n-                .map(|data| (data, CommentKind::Line)),\n+        match &self.kind {\n+            AttrKind::DocComment(kind, data) => Some((*data, *kind)),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n+                normal.item.value_str().map(|s| (s, CommentKind::Line))\n+            }\n             _ => None,\n         }\n     }\n@@ -265,9 +290,7 @@ impl Attribute {\n     pub fn doc_str(&self) -> Option<Symbol> {\n         match &self.kind {\n             AttrKind::DocComment(.., data) => Some(*data),\n-            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n-                normal.item.meta_kind().and_then(|kind| kind.value_str())\n-            }\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => normal.item.value_str(),\n             _ => None,\n         }\n     }\n@@ -508,15 +531,12 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self {\n-            MetaItemKind::NameValue(v) => match v.kind {\n-                LitKind::Str(s, _) => Some(s),\n-                _ => None,\n-            },\n+            MetaItemKind::NameValue(v) => v.kind.str(),\n             _ => None,\n         }\n     }\n \n-    fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n+    fn list_from_tokens(tokens: TokenStream) -> Option<Vec<NestedMetaItem>> {\n         let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n         while tokens.peek().is_some() {\n@@ -527,7 +547,7 @@ impl MetaItemKind {\n                 _ => return None,\n             }\n         }\n-        Some(MetaItemKind::List(result))\n+        Some(result)\n     }\n \n     fn name_value_from_tokens(\n@@ -551,7 +571,7 @@ impl MetaItemKind {\n                 dspan: _,\n                 delim: MacDelimiter::Parenthesis,\n                 tokens,\n-            }) => MetaItemKind::list_from_tokens(tokens.clone()),\n+            }) => MetaItemKind::list_from_tokens(tokens.clone()).map(MetaItemKind::List),\n             AttrArgs::Delimited(..) => None,\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n                 ExprKind::Lit(token_lit) => {\n@@ -573,7 +593,7 @@ impl MetaItemKind {\n             Some(TokenTree::Delimited(_, Delimiter::Parenthesis, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();\n                 tokens.next();\n-                MetaItemKind::list_from_tokens(inner_tokens)\n+                MetaItemKind::list_from_tokens(inner_tokens).map(MetaItemKind::List)\n             }\n             Some(TokenTree::Delimited(..)) => None,\n             Some(TokenTree::Token(Token { kind: token::Eq, .. }, _)) => {"}, {"sha": "3ebbb2cbdfb8e239b0eeb7d20e806ab2ff1154ec", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=a9c8a5c0255d056f78f1347c431fd88bc727febb", "patch": "@@ -319,74 +319,62 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                 }\n             }\n         } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n-                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n-                    [NestedMetaItem::MetaItem(set)] => {\n-                        let segments =\n-                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                        match segments.as_slice() {\n-                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                                if !tcx.sess.target.has_thumb_interworking {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0779,\n-                                        \"target does not support `#[instruction_set]`\"\n-                                    )\n-                                    .emit();\n-                                    None\n-                                } else if segments[1] == sym::a32 {\n-                                    Some(InstructionSetAttr::ArmA32)\n-                                } else if segments[1] == sym::t32 {\n-                                    Some(InstructionSetAttr::ArmT32)\n-                                } else {\n-                                    unreachable!()\n-                                }\n-                            }\n-                            _ => {\n+            codegen_fn_attrs.instruction_set = attr.meta_item_list().and_then(|l| match &l[..] {\n+                [NestedMetaItem::MetaItem(set)] => {\n+                    let segments =\n+                        set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                    match segments.as_slice() {\n+                        [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                            if !tcx.sess.target.has_thumb_interworking {\n                                 struct_span_err!(\n                                     tcx.sess.diagnostic(),\n                                     attr.span,\n                                     E0779,\n-                                    \"invalid instruction set specified\",\n+                                    \"target does not support `#[instruction_set]`\"\n                                 )\n                                 .emit();\n                                 None\n+                            } else if segments[1] == sym::a32 {\n+                                Some(InstructionSetAttr::ArmA32)\n+                            } else if segments[1] == sym::t32 {\n+                                Some(InstructionSetAttr::ArmT32)\n+                            } else {\n+                                unreachable!()\n                             }\n                         }\n+                        _ => {\n+                            struct_span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0779,\n+                                \"invalid instruction set specified\",\n+                            )\n+                            .emit();\n+                            None\n+                        }\n                     }\n-                    [] => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0778,\n-                            \"`#[instruction_set]` requires an argument\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                    _ => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0779,\n-                            \"cannot specify more than one instruction set\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                },\n-                _ => {\n+                }\n+                [] => {\n                     struct_span_err!(\n                         tcx.sess.diagnostic(),\n                         attr.span,\n                         E0778,\n-                        \"must specify an instruction set\"\n+                        \"`#[instruction_set]` requires an argument\"\n                     )\n                     .emit();\n                     None\n                 }\n-            };\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0779,\n+                        \"cannot specify more than one instruction set\"\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            })\n         } else if attr.has_name(sym::repr) {\n             codegen_fn_attrs.alignment = match attr.meta_item_list() {\n                 Some(items) => match items.as_slice() {"}, {"sha": "f4da1aaec11301ff44e303f7e8c316f01dcf3478", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c8a5c0255d056f78f1347c431fd88bc727febb/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=a9c8a5c0255d056f78f1347c431fd88bc727febb", "patch": "@@ -4,7 +4,7 @@\n //! but are not declared in one single location (unlike lang features), which means we need to\n //! collect them instead.\n \n-use rustc_ast::{Attribute, MetaItemKind};\n+use rustc_ast::Attribute;\n use rustc_attr::{rust_version_symbol, VERSION_PLACEHOLDER};\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n@@ -42,8 +42,7 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n         // Find a stability attribute: one of #[stable(\u2026)], #[unstable(\u2026)],\n         // #[rustc_const_stable(\u2026)], #[rustc_const_unstable(\u2026)] or #[rustc_default_body_unstable].\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.has_name(**stab_attr)) {\n-            let meta_kind = attr.meta_kind();\n-            if let Some(MetaItemKind::List(ref metas)) = meta_kind {\n+            if let Some(metas) = attr.meta_item_list() {\n                 let mut feature = None;\n                 let mut since = None;\n                 for meta in metas {"}]}