{"sha": "45bf1ed1a1123122ded05ae2eedaf0f190e52726", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YmYxZWQxYTExMjMxMjJkZWQwNWFlMmVlZGFmMGYxOTBlNTI3MjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-25T17:07:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-14T22:13:10Z"}, "message": "rustc: Allow changing the default allocator\n\nThis commit is an implementation of [RFC 1183][rfc] which allows swapping out\nthe default allocator on nightly Rust. No new stable surface area should be\nadded as a part of this commit.\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/1183\n\nTwo new attributes have been added to the compiler:\n\n* `#![needs_allocator]` - this is used by liballoc (and likely only liballoc) to\n  indicate that it requires an allocator crate to be in scope.\n* `#![allocator]` - this is a indicator that the crate is an allocator which can\n  satisfy the `needs_allocator` attribute above.\n\nThe ABI of the allocator crate is defined to be a set of symbols that implement\nthe standard Rust allocation/deallocation functions. The symbols are not\ncurrently checked for exhaustiveness or typechecked. There are also a number of\nrestrictions on these crates:\n\n* An allocator crate cannot transitively depend on a crate that is flagged as\n  needing an allocator (e.g. allocator crates can't depend on liballoc).\n* There can only be one explicitly linked allocator in a final image.\n* If no allocator is explicitly requested one will be injected on behalf of the\n  compiler. Binaries and Rust dylibs will use jemalloc by default where\n  available and staticlibs/other dylibs will use the system allocator by\n  default.\n\nTwo allocators are provided by the distribution by default, `alloc_system` and\n`alloc_jemalloc` which operate as advertised.\n\nCloses #27389", "tree": {"sha": "5065451271cbd7ea8b58d751f079072b72b4ad9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5065451271cbd7ea8b58d751f079072b72b4ad9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45bf1ed1a1123122ded05ae2eedaf0f190e52726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45bf1ed1a1123122ded05ae2eedaf0f190e52726", "html_url": "https://github.com/rust-lang/rust/commit/45bf1ed1a1123122ded05ae2eedaf0f190e52726", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45bf1ed1a1123122ded05ae2eedaf0f190e52726/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "html_url": "https://github.com/rust-lang/rust/commit/e7261f3ab60e0d1e6c808004ecd25c88e04f3683"}], "stats": {"total": 1934, "additions": 1287, "deletions": 647}, "files": [{"sha": "af2a663b61ded8d9962d48d394a78907bf423e4b", "filename": "mk/crates.mk", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -52,23 +52,23 @@\n TARGET_CRATES := libc std flate arena term \\\n                  serialize getopts collections test rand \\\n                  log graphviz core rbml alloc \\\n-                 rustc_unicode rustc_bitflags\n+                 rustc_unicode rustc_bitflags \\\n+\t\t alloc_system\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n-CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n DEPS_core :=\n DEPS_libc := core\n DEPS_rustc_unicode := core\n-DEPS_alloc := core libc native:jemalloc\n+DEPS_alloc := core libc alloc_system\n DEPS_std := core libc rand alloc collections rustc_unicode \\\n \tnative:rust_builtin native:backtrace \\\n-\trustc_bitflags\n+\talloc_system\n DEPS_graphviz := std\n-DEPS_syntax := std term serialize log fmt_macros arena libc\n+DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_resolve log syntax serialize rustc_llvm \\\n \t\t     rustc_trans rustc_privacy rustc_lint\n@@ -82,7 +82,7 @@ DEPS_rustc_privacy := rustc log syntax\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\n-DEPS_rustc_llvm := native:rustllvm libc std\n+DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n@@ -102,6 +102,7 @@ DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n DEPS_rand := core\n DEPS_log := std\n DEPS_fmt_macros = std\n+DEPS_alloc_system := core libc\n \n TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc\n@@ -121,14 +122,26 @@ ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1\n ONLY_RLIB_rustc_unicode := 1\n ONLY_RLIB_rustc_bitflags := 1\n+ONLY_RLIB_alloc_system := 1\n \n # Documented-by-default crates\n DOC_CRATES := std alloc collections core libc rustc_unicode\n \n+ifeq ($(CFG_DISABLE_JEMALLOC),)\n+TARGET_CRATES += alloc_jemalloc\n+DEPS_std += alloc_jemalloc\n+DEPS_alloc_jemalloc := core libc native:jemalloc\n+ONLY_RLIB_alloc_jemalloc := 1\n+else\n+RUSTFLAGS_rustc_back := --cfg disable_jemalloc\n+endif\n+\n ################################################################################\n # You should not need to edit below this line\n ################################################################################\n \n+CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n+\n # This macro creates some simple definitions for each crate being built, just\n # some munging of all of the parameters above.\n #"}, {"sha": "75051f9184fd25c8c29cacd347afcf61265dcc75", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -184,8 +184,6 @@ $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \t\tEXTRA_CFLAGS=\"-g1 -ffunction-sections -fdata-sections\"\n \t$$(Q)$$(MAKE) -C \"$$(JEMALLOC_BUILD_DIR_$(1))\" build_lib_static\n \n-ifeq ($$(CFG_DISABLE_JEMALLOC),)\n-RUSTFLAGS_alloc := --cfg jemalloc\n ifeq ($(1),$$(CFG_BUILD))\n ifneq ($$(CFG_JEMALLOC_ROOT),)\n $$(JEMALLOC_LIB_$(1)): $$(CFG_JEMALLOC_ROOT)/libjemalloc_pic.a\n@@ -199,10 +197,6 @@ else\n $$(JEMALLOC_LIB_$(1)): $$(JEMALLOC_LOCAL_$(1))\n \t$$(Q)cp $$< $$@\n endif\n-else\n-$$(JEMALLOC_LIB_$(1)): $$(MKFILE_DEPS)\n-\t$$(Q)touch $$@\n-endif\n \n ################################################################################\n # compiler-rt"}, {"sha": "e0984cfe86f077084f49b5c011df10d4c311afd1", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -22,7 +22,8 @@ $(eval $(call RUST_CRATE,coretest))\n DEPS_collectionstest :=\n $(eval $(call RUST_CRATE,collectionstest))\n \n-TEST_TARGET_CRATES = $(filter-out core rustc_unicode,$(TARGET_CRATES)) \\\n+TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system \\\n+\t\t     \t\t  alloc_jemalloc,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve \\"}, {"sha": "fad8308f0f48885de8c08b85bea8fc6a11693b9f", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 19, "deletions": 371, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -16,6 +16,18 @@\n \n use core::{isize, usize};\n \n+#[allow(improper_ctypes)]\n+extern {\n+    #[allocator]\n+    fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n+    fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n+    fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,\n+                         align: usize) -> *mut u8;\n+    fn __rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                               align: usize) -> usize;\n+    fn __rust_usable_size(size: usize, align: usize) -> usize;\n+}\n+\n #[inline(always)]\n fn check_size_and_alignment(size: usize, align: usize) {\n     debug_assert!(size != 0);\n@@ -35,7 +47,7 @@ fn check_size_and_alignment(size: usize, align: usize) {\n #[inline]\n pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n     check_size_and_alignment(size, align);\n-    imp::allocate(size, align)\n+    __rust_allocate(size, align)\n }\n \n /// Resize the allocation referenced by `ptr` to `size` bytes.\n@@ -55,7 +67,7 @@ pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n #[inline]\n pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n     check_size_and_alignment(size, align);\n-    imp::reallocate(ptr, old_size, size, align)\n+    __rust_reallocate(ptr, old_size, size, align)\n }\n \n /// Resize the allocation referenced by `ptr` to `size` bytes.\n@@ -74,7 +86,7 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usiz\n pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n                                  align: usize) -> usize {\n     check_size_and_alignment(size, align);\n-    imp::reallocate_inplace(ptr, old_size, size, align)\n+    __rust_reallocate_inplace(ptr, old_size, size, align)\n }\n \n /// Deallocates the memory referenced by `ptr`.\n@@ -86,28 +98,20 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-    imp::deallocate(ptr, old_size, align)\n+    __rust_deallocate(ptr, old_size, align)\n }\n \n /// Returns the usable size of an allocation created with the specified the\n /// `size` and `align`.\n #[inline]\n pub fn usable_size(size: usize, align: usize) -> usize {\n-    imp::usable_size(size, align)\n-}\n-\n-/// Prints implementation-defined allocator statistics.\n-///\n-/// These statistics may be inconsistent if other threads use the allocator\n-/// during the call.\n-pub fn stats_print() {\n-    imp::stats_print();\n+    unsafe { __rust_usable_size(size, align) }\n }\n \n /// An arbitrary non-null address to represent zero-size allocations.\n ///\n-/// This preserves the non-null invariant for types like `Box<T>`. The address may overlap with\n-/// non-zero-size memory allocations.\n+/// This preserves the non-null invariant for types like `Box<T>`. The address\n+/// may overlap with non-zero-size memory allocations.\n pub const EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n@@ -131,362 +135,6 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);\n }\n \n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values. In practice, the alignment is a\n-// constant at the call site and the branch will be optimized out.\n-#[cfg(all(not(feature = \"external_funcs\"),\n-          not(feature = \"external_crate\"),\n-          any(target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\")))]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(not(feature = \"external_funcs\"),\n-          not(feature = \"external_crate\"),\n-          any(target_arch = \"x86\",\n-              target_arch = \"x86_64\",\n-              target_arch = \"aarch64\")))]\n-const MIN_ALIGN: usize = 16;\n-\n-#[cfg(feature = \"external_funcs\")]\n-mod imp {\n-    #[allow(improper_ctypes)]\n-    extern {\n-        fn rust_allocate(size: usize, align: usize) -> *mut u8;\n-        fn rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n-        fn rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n-        fn rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n-                                   align: usize) -> usize;\n-        fn rust_usable_size(size: usize, align: usize) -> usize;\n-        fn rust_stats_print();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        rust_allocate(size, align)\n-    }\n-\n-    #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-        rust_deallocate(ptr, old_size, align)\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n-        rust_reallocate(ptr, old_size, size, align)\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n-                                     align: usize) -> usize {\n-        rust_reallocate_inplace(ptr, old_size, size, align)\n-    }\n-\n-    #[inline]\n-    pub fn usable_size(size: usize, align: usize) -> usize {\n-        unsafe { rust_usable_size(size, align) }\n-    }\n-\n-    #[inline]\n-    pub fn stats_print() {\n-        unsafe { rust_stats_print() }\n-    }\n-}\n-\n-#[cfg(feature = \"external_crate\")]\n-mod imp {\n-    extern crate external;\n-    pub use self::external::{allocate, deallocate, reallocate_inplace, reallocate};\n-    pub use self::external::{usable_size, stats_print};\n-}\n-\n-#[cfg(all(not(feature = \"external_funcs\"),\n-          not(feature = \"external_crate\"),\n-          jemalloc))]\n-mod imp {\n-    use core::option::Option;\n-    use core::option::Option::None;\n-    use core::ptr::{null_mut, null};\n-    use libc::{c_char, c_int, c_void, size_t};\n-    use super::MIN_ALIGN;\n-\n-    #[link(name = \"jemalloc\", kind = \"static\")]\n-    #[cfg(not(test))]\n-    extern {}\n-\n-    extern {\n-        #[allocator]\n-        fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-        fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-        fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-        fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n-        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void,\n-                                                                *const c_char)>,\n-                                 cbopaque: *mut c_void,\n-                                 opts: *const c_char);\n-    }\n-\n-    // -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n-    #[cfg(all(not(windows),\n-              not(target_os = \"android\"),\n-              not(target_env = \"musl\")))]\n-    #[link(name = \"pthread\")]\n-    extern {}\n-\n-    // MALLOCX_ALIGN(a) macro\n-    #[inline(always)]\n-    fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }\n-\n-    #[inline(always)]\n-    fn align_to_flags(align: usize) -> c_int {\n-        if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        let flags = align_to_flags(align);\n-        je_mallocx(size as size_t, flags) as *mut u8\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n-        let flags = align_to_flags(align);\n-        je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: usize, size: usize,\n-                                     align: usize) -> usize {\n-        let flags = align_to_flags(align);\n-        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize\n-    }\n-\n-    #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-        let flags = align_to_flags(align);\n-        je_sdallocx(ptr as *mut c_void, old_size as size_t, flags)\n-    }\n-\n-    #[inline]\n-    pub fn usable_size(size: usize, align: usize) -> usize {\n-        let flags = align_to_flags(align);\n-        unsafe { je_nallocx(size as size_t, flags) as usize }\n-    }\n-\n-    pub fn stats_print() {\n-        unsafe {\n-            je_malloc_stats_print(None, null_mut(), null())\n-        }\n-    }\n-}\n-\n-#[cfg(all(not(feature = \"external_funcs\"),\n-          not(feature = \"external_crate\"),\n-          not(jemalloc),\n-          unix))]\n-mod imp {\n-    use core::cmp;\n-    use core::ptr;\n-    use libc;\n-    use super::MIN_ALIGN;\n-\n-    extern {\n-        fn posix_memalign(memptr: *mut *mut libc::c_void,\n-                          align: libc::size_t,\n-                          size: libc::size_t) -> libc::c_int;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            libc::malloc(size as libc::size_t) as *mut u8\n-        } else {\n-            let mut out = ptr::null_mut();\n-            let ret = posix_memalign(&mut out,\n-                                     align as libc::size_t,\n-                                     size as libc::size_t);\n-            if ret != 0 {\n-                ptr::null_mut()\n-            } else {\n-                out as *mut u8\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n-        } else {\n-            let new_ptr = allocate(size, align);\n-            ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n-            deallocate(ptr, old_size, align);\n-            new_ptr\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n-                                     _align: usize) -> usize {\n-        old_size\n-    }\n-\n-    #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n-        libc::free(ptr as *mut libc::c_void)\n-    }\n-\n-    #[inline]\n-    pub fn usable_size(size: usize, _align: usize) -> usize {\n-        size\n-    }\n-\n-    pub fn stats_print() {}\n-}\n-\n-#[cfg(all(not(feature = \"external_funcs\"),\n-          not(feature = \"external_crate\"),\n-          not(jemalloc),\n-          windows))]\n-mod imp {\n-    use core::mem::size_of;\n-    use libc::{BOOL, DWORD, HANDLE, LPVOID, SIZE_T, INVALID_HANDLE_VALUE};\n-    use libc::{WriteFile};\n-    use super::MIN_ALIGN;\n-\n-    extern \"system\" {\n-        fn GetProcessHeap() -> HANDLE;\n-        fn GetStdHandle(nStdHandle: DWORD) -> HANDLE;\n-        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n-        fn HeapSummary(hHeap: HANDLE, dwFlags: DWORD, lpSummary: LPHEAP_SUMMARY) -> BOOL;\n-    }\n-\n-    #[repr(C)] #[allow(non_snake_case)]\n-    struct HEAP_SUMMARY {\n-        cb: DWORD,\n-        cbAllocated: SIZE_T,\n-        cbCommitted: SIZE_T,\n-        cbReserved: SIZE_T,\n-        cbMaxReserve: SIZE_T,\n-    }\n-    #[allow(non_camel_case_types)]\n-    type LPHEAP_SUMMARY = *mut HEAP_SUMMARY;\n-\n-    #[repr(C)]\n-    struct Header(*mut u8);\n-\n-    const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n-    const STD_OUTPUT_HANDLE: DWORD = -11i32 as u32;\n-\n-    #[inline]\n-    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n-    }\n-\n-    #[inline]\n-    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-        let aligned = ptr.offset((align - (ptr as usize & (align - 1))) as isize);\n-        *get_header(aligned) = Header(ptr);\n-        aligned\n-    }\n-\n-    #[inline]\n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), 0, size as SIZE_T) as *mut u8\n-        } else {\n-            let ptr = HeapAlloc(GetProcessHeap(), 0, (size + align) as SIZE_T) as *mut u8;\n-            if ptr.is_null() { return ptr }\n-            align_ptr(ptr, align)\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8\n-        } else {\n-            let header = get_header(ptr);\n-            let new = HeapReAlloc(GetProcessHeap(), 0, header.0 as LPVOID,\n-                                  (size + align) as SIZE_T) as *mut u8;\n-            if new.is_null() { return new }\n-            align_ptr(new, align)\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n-                                     align: usize) -> usize {\n-        if align <= MIN_ALIGN {\n-            let new = HeapReAlloc(GetProcessHeap(), HEAP_REALLOC_IN_PLACE_ONLY, ptr as LPVOID,\n-                                  size as SIZE_T) as *mut u8;\n-            if new.is_null() { old_size } else { size }\n-        } else {\n-            old_size\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n-        if align <= MIN_ALIGN {\n-            let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-            debug_assert!(err != 0);\n-        } else {\n-            let header = get_header(ptr);\n-            let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-            debug_assert!(err != 0);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn usable_size(size: usize, _align: usize) -> usize {\n-        size\n-    }\n-\n-    pub fn stats_print() {\n-        use core::fmt::{Error, Result, Write};\n-        use core::ptr::null_mut;\n-        use core::raw::Repr;\n-        use core::result::Result::{Ok, Err};\n-        struct Console(HANDLE);\n-        impl Write for Console {\n-            fn write_str(&mut self, s: &str) -> Result {\n-                let repr = s.repr();\n-                let mut written = 0;\n-                let err = unsafe { WriteFile(self.0, repr.data as LPVOID, repr.len as DWORD,\n-                                             &mut written, null_mut()) };\n-                if written as usize != repr.len { return Err(Error) }\n-                if err == 0 { return Err(Error) }\n-                Ok(())\n-            }\n-        }\n-        let mut hs = HEAP_SUMMARY {\n-            cb: size_of::<HEAP_SUMMARY>() as DWORD,\n-            cbAllocated: 0,\n-            cbCommitted: 0,\n-            cbReserved: 0,\n-            cbMaxReserve: 0,\n-        };\n-        let err = unsafe { HeapSummary(GetProcessHeap(), 0, &mut hs) };\n-        assert!(err != 0);\n-        let handle = unsafe { GetStdHandle(STD_OUTPUT_HANDLE) };\n-        if handle.is_null() || handle == INVALID_HANDLE_VALUE { panic!(\"Failed to open stdout\") }\n-        let mut out = Console(handle);\n-        writeln!(&mut out, \"Allocated: {}\", hs.cbAllocated).unwrap();\n-        writeln!(&mut out, \"Committed: {}\", hs.cbCommitted).unwrap();\n-        writeln!(&mut out, \"Reserved: {}\", hs.cbReserved).unwrap();\n-        writeln!(&mut out, \"MaxReserve: {}\", hs.cbMaxReserve).unwrap();\n-    }\n-\n-    #[test]\n-    fn alignment_header_size() {\n-        assert!(size_of::<Header>() <= MIN_ALIGN);\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "ca86850f5df6ebfb67f06dae9e5aad0131e27bcb", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -61,6 +61,7 @@\n #![crate_name = \"alloc\"]\n #![crate_type = \"rlib\"]\n #![staged_api]\n+#![allow(unused_attributes)]\n #![unstable(feature = \"alloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\")]\n@@ -69,6 +70,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject))]\n #![no_std]\n+#![cfg_attr(not(stage0), needs_allocator)]\n \n #![feature(allocator)]\n #![feature(box_syntax)]\n@@ -92,13 +94,13 @@\n #![feature(unsize)]\n #![feature(core_slice_ext)]\n #![feature(core_str_ext)]\n+#![cfg_attr(stage0, feature(alloc_system))]\n+#![cfg_attr(not(stage0), feature(needs_allocator))]\n \n #![cfg_attr(test, feature(test, rustc_private, box_raw))]\n-#![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n-            feature(libc))]\n \n-#[cfg(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")))]\n-extern crate libc;\n+#[cfg(stage0)]\n+extern crate alloc_system;\n \n // Allow testing this library\n "}, {"sha": "2a30f88df49ac871a7a7f35ed6fbe7ee3366e338", "filename": "src/liballoc_jemalloc/lib.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"alloc_jemalloc\"]\n+#![crate_type = \"rlib\"]\n+#![staged_api]\n+#![no_std]\n+#![cfg_attr(not(stage0), allocator)]\n+#![unstable(feature = \"alloc_jemalloc\",\n+            reason = \"this library is unlikely to be stabilized in its current \\\n+                      form or name\")]\n+#![feature(allocator)]\n+#![feature(libc)]\n+#![feature(no_std)]\n+#![feature(staged_api)]\n+\n+extern crate libc;\n+\n+use libc::{c_int, c_void, size_t};\n+\n+#[link(name = \"jemalloc\", kind = \"static\")]\n+extern {\n+    fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+    fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n+    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n+                  flags: c_int) -> size_t;\n+    fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n+    fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n+}\n+\n+// -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n+#[cfg(all(not(windows),\n+          not(target_os = \"android\"),\n+          not(target_env = \"musl\")))]\n+#[link(name = \"pthread\")]\n+extern {}\n+\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values. In practice, the alignment is a\n+// constant at the call site and the branch will be optimized out.\n+#[cfg(all(any(target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\",\n+              target_arch = \"powerpc\")))]\n+const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"aarch64\")))]\n+const MIN_ALIGN: usize = 16;\n+\n+// MALLOCX_ALIGN(a) macro\n+fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }\n+\n+fn align_to_flags(align: usize) -> c_int {\n+    if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+    let flags = align_to_flags(align);\n+    unsafe { je_mallocx(size as size_t, flags) as *mut u8 }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n+                                align: usize) -> *mut u8 {\n+    let flags = align_to_flags(align);\n+    unsafe { je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate_inplace(ptr: *mut u8, _old_size: usize,\n+                                        size: usize, align: usize) -> usize {\n+    let flags = align_to_flags(align);\n+    unsafe { je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+    let flags = align_to_flags(align);\n+    unsafe { je_sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_usable_size(size: usize, align: usize) -> usize {\n+    let flags = align_to_flags(align);\n+    unsafe { je_nallocx(size as size_t, flags) as usize }\n+}"}, {"sha": "0687ced7da1eba120dcd35b51c25c17d4eec1c0b", "filename": "src/liballoc_system/lib.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"alloc_system\"]\n+#![crate_type = \"rlib\"]\n+#![staged_api]\n+#![no_std]\n+#![cfg_attr(not(stage0), allocator)]\n+#![unstable(feature = \"alloc_system\",\n+            reason = \"this library is unlikely to be stabilized in its current \\\n+                      form or name\")]\n+#![feature(allocator)]\n+#![feature(libc)]\n+#![feature(no_std)]\n+#![feature(staged_api)]\n+\n+extern crate libc;\n+\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values. In practice, the alignment is a\n+// constant at the call site and the branch will be optimized out.\n+#[cfg(all(any(target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\",\n+              target_arch = \"powerpc\")))]\n+const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"aarch64\")))]\n+const MIN_ALIGN: usize = 16;\n+\n+#[no_mangle]\n+pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+    unsafe { imp::allocate(size, align) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+    unsafe { imp::deallocate(ptr, old_size, align) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,\n+                                align: usize) -> *mut u8 {\n+    unsafe { imp::reallocate(ptr, old_size, size, align) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate_inplace(ptr: *mut u8, old_size: usize,\n+                                        size: usize, align: usize) -> usize {\n+    unsafe { imp::reallocate_inplace(ptr, old_size, size, align) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_usable_size(size: usize, align: usize) -> usize {\n+    imp::usable_size(size, align)\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use core::cmp;\n+    use core::ptr;\n+    use libc;\n+    use MIN_ALIGN;\n+\n+    extern {\n+        // Apparently android doesn't have posix_memalign\n+        #[cfg(target_os = \"android\")]\n+        fn memalign(align: libc::size_t, size: libc::size_t) -> *mut libc::c_void;\n+\n+        #[cfg(not(target_os = \"android\"))]\n+        fn posix_memalign(memptr: *mut *mut libc::c_void,\n+                          align: libc::size_t,\n+                          size: libc::size_t) -> libc::c_int;\n+    }\n+\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::malloc(size as libc::size_t) as *mut u8\n+        } else {\n+            #[cfg(target_os = \"android\")]\n+            unsafe fn more_aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+                memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n+            }\n+            #[cfg(not(target_os = \"android\"))]\n+            unsafe fn more_aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+                let mut out = ptr::null_mut();\n+                let ret = posix_memalign(&mut out,\n+                                         align as libc::size_t,\n+                                         size as libc::size_t);\n+                if ret != 0 {\n+                    ptr::null_mut()\n+                } else {\n+                    out as *mut u8\n+                }\n+            }\n+            more_aligned_malloc(size, align)\n+        }\n+    }\n+\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize,\n+                             align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n+        } else {\n+            let new_ptr = allocate(size, align);\n+            ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n+            deallocate(ptr, old_size, align);\n+            new_ptr\n+        }\n+    }\n+\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n+                                     _align: usize) -> usize {\n+        old_size\n+    }\n+\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n+        size\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use libc::{BOOL, DWORD, HANDLE, LPVOID, SIZE_T};\n+    use MIN_ALIGN;\n+\n+    extern \"system\" {\n+        fn GetProcessHeap() -> HANDLE;\n+        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID,\n+                       dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+    }\n+\n+    #[repr(C)]\n+    struct Header(*mut u8);\n+\n+    const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n+\n+    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+        &mut *(ptr as *mut Header).offset(-1)\n+    }\n+\n+    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+        let aligned = ptr.offset((align - (ptr as usize & (align - 1))) as isize);\n+        *get_header(aligned) = Header(ptr);\n+        aligned\n+    }\n+\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), 0, size as SIZE_T) as *mut u8\n+        } else {\n+            let ptr = HeapAlloc(GetProcessHeap(), 0,\n+                                (size + align) as SIZE_T) as *mut u8;\n+            if ptr.is_null() { return ptr }\n+            align_ptr(ptr, align)\n+        }\n+    }\n+\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n+                             align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8\n+        } else {\n+            let header = get_header(ptr);\n+            let new = HeapReAlloc(GetProcessHeap(), 0, header.0 as LPVOID,\n+                                  (size + align) as SIZE_T) as *mut u8;\n+            if new.is_null() { return new }\n+            align_ptr(new, align)\n+        }\n+    }\n+\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                     align: usize) -> usize {\n+        if align <= MIN_ALIGN {\n+            let new = HeapReAlloc(GetProcessHeap(), HEAP_REALLOC_IN_PLACE_ONLY,\n+                                  ptr as LPVOID, size as SIZE_T) as *mut u8;\n+            if new.is_null() { old_size } else { size }\n+        } else {\n+            old_size\n+        }\n+    }\n+\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n+        if align <= MIN_ALIGN {\n+            let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+            debug_assert!(err != 0);\n+        } else {\n+            let header = get_header(ptr);\n+            let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+            debug_assert!(err != 0);\n+        }\n+    }\n+\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n+        size\n+    }\n+}"}, {"sha": "3e0cf30fe942f1a0c7d7f052d0c798138db5283d", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -78,12 +78,13 @@ pub const tag_crate_crate_name: usize = 0x104; // top-level only\n \n pub const tag_crate_dep_crate_name: usize = 0x36;\n pub const tag_crate_dep_hash: usize = 0x37;\n+pub const tag_crate_dep_explicitly_linked: usize = 0x38; // top-level only\n \n-pub const tag_mod_impl: usize = 0x38;\n+pub const tag_mod_impl: usize = 0x39;\n \n-pub const tag_item_trait_item: usize = 0x39;\n+pub const tag_item_trait_item: usize = 0x3a;\n \n-pub const tag_item_trait_ref: usize = 0x3a;\n+pub const tag_item_trait_ref: usize = 0x3b;\n \n // discriminator value for variants\n pub const tag_disr_val: usize = 0x3c;"}, {"sha": "c34b2ea58dcc880187a2b715a00b9b72b5b24232", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 151, "deletions": 20, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -22,7 +22,7 @@ use metadata::loader;\n use metadata::loader::CratePaths;\n use util::nodemap::FnvHashMap;\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::fs;\n@@ -59,15 +59,16 @@ impl<'a, 'b, 'v> visit::Visitor<'v> for LocalCrateReader<'a, 'b> {\n }\n \n fn dump_crates(cstore: &CStore) {\n-    debug!(\"resolved crates:\");\n+    info!(\"resolved crates:\");\n     cstore.iter_crate_data_origins(|_, data, opt_source| {\n-        debug!(\"  name: {}\", data.name());\n-        debug!(\"  cnum: {}\", data.cnum);\n-        debug!(\"  hash: {}\", data.hash());\n+        info!(\"  name: {}\", data.name());\n+        info!(\"  cnum: {}\", data.cnum);\n+        info!(\"  hash: {}\", data.hash());\n+        info!(\"  reqd: {}\", data.explicitly_linked.get());\n         opt_source.map(|cs| {\n             let CrateSource { dylib, rlib, cnum: _ } = cs;\n-            dylib.map(|dl| debug!(\"  dylib: {}\", dl.0.display()));\n-            rlib.map(|rl|  debug!(\"   rlib: {}\", rl.0.display()));\n+            dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n+            rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n         });\n     })\n }\n@@ -241,7 +242,8 @@ impl<'a> CrateReader<'a> {\n                       ident: &str,\n                       name: &str,\n                       span: Span,\n-                      lib: loader::Library)\n+                      lib: loader::Library,\n+                      explicitly_linked: bool)\n                       -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                           cstore::CrateSource) {\n         // Claim this crate number and cache it\n@@ -266,15 +268,16 @@ impl<'a> CrateReader<'a> {\n         let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), span);\n         let staged_api = self.is_staged_api(metadata.as_slice());\n \n-        let cmeta = Rc::new( cstore::crate_metadata {\n+        let cmeta = Rc::new(cstore::crate_metadata {\n             name: name.to_string(),\n             local_path: RefCell::new(SmallVector::zero()),\n             data: metadata,\n-            cnum_map: cnum_map,\n+            cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n             span: span,\n-            staged_api: staged_api\n+            staged_api: staged_api,\n+            explicitly_linked: Cell::new(explicitly_linked),\n         });\n \n         let source = cstore::CrateSource {\n@@ -305,7 +308,8 @@ impl<'a> CrateReader<'a> {\n                      name: &str,\n                      hash: Option<&Svh>,\n                      span: Span,\n-                     kind: PathKind)\n+                     kind: PathKind,\n+                     explicitly_linked: bool)\n                          -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                              cstore::CrateSource) {\n         match self.existing_match(name, hash, kind) {\n@@ -326,11 +330,16 @@ impl<'a> CrateReader<'a> {\n                     should_match_name: true,\n                 };\n                 let library = load_ctxt.load_library_crate();\n-                self.register_crate(root, ident, name, span, library)\n+                self.register_crate(root, ident, name, span, library,\n+                                    explicitly_linked)\n+            }\n+            Some(cnum) => {\n+                let data = self.sess.cstore.get_crate_data(cnum);\n+                if explicitly_linked && !data.explicitly_linked.get() {\n+                    data.explicitly_linked.set(explicitly_linked);\n+                }\n+                (cnum, data, self.sess.cstore.get_used_crate_source(cnum).unwrap())\n             }\n-            Some(cnum) => (cnum,\n-                           self.sess.cstore.get_crate_data(cnum),\n-                           self.sess.cstore.get_used_crate_source(cnum).unwrap())\n         }\n     }\n \n@@ -349,7 +358,8 @@ impl<'a> CrateReader<'a> {\n                                                    &dep.name,\n                                                    Some(&dep.hash),\n                                                    span,\n-                                                   PathKind::Dependency);\n+                                                   PathKind::Dependency,\n+                                                   dep.explicitly_linked);\n             (dep.cnum, local_cnum)\n         }).collect()\n     }\n@@ -399,7 +409,8 @@ impl<'a> CrateReader<'a> {\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n             let (_, cmd, _) = self.register_crate(&None, &info.ident,\n-                                &info.name, span, library);\n+                                                  &info.name, span, library,\n+                                                  true);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata\n@@ -507,6 +518,124 @@ impl<'a> CrateReader<'a> {\n             }\n         }\n     }\n+\n+    fn inject_allocator_crate(&mut self) {\n+        // Make sure that we actually need an allocator, if none of our\n+        // dependencies need one then we definitely don't!\n+        //\n+        // Also, if one of our dependencies has an explicit allocator, then we\n+        // also bail out as we don't need to implicitly inject one.\n+        let mut needs_allocator = false;\n+        let mut found_required_allocator = false;\n+        self.sess.cstore.iter_crate_data(|cnum, data| {\n+            needs_allocator = needs_allocator || data.needs_allocator();\n+            if data.is_allocator() {\n+                debug!(\"{} required by rlib and is an allocator\", data.name());\n+                self.inject_allocator_dependency(cnum);\n+                found_required_allocator = found_required_allocator ||\n+                    data.explicitly_linked.get();\n+            }\n+        });\n+        if !needs_allocator || found_required_allocator { return }\n+\n+        // At this point we've determined that we need an allocator and no\n+        // previous allocator has been activated. We look through our outputs of\n+        // crate types to see what kind of allocator types we may need.\n+        //\n+        // The main special output type here is that rlibs do **not** need an\n+        // allocator linked in (they're just object files), only final products\n+        // (exes, dylibs, staticlibs) need allocators.\n+        let mut need_lib_alloc = false;\n+        let mut need_exe_alloc = false;\n+        for ct in self.sess.crate_types.borrow().iter() {\n+            match *ct {\n+                config::CrateTypeExecutable => need_exe_alloc = true,\n+                config::CrateTypeDylib |\n+                config::CrateTypeStaticlib => need_lib_alloc = true,\n+                config::CrateTypeRlib => {}\n+            }\n+        }\n+        if !need_lib_alloc && !need_exe_alloc { return }\n+\n+        // The default allocator crate comes from the custom target spec, and we\n+        // choose between the standard library allocator or exe allocator. This\n+        // distinction exists because the default allocator for binaries (where\n+        // the world is Rust) is different than library (where the world is\n+        // likely *not* Rust).\n+        //\n+        // If a library is being produced, but we're also flagged with `-C\n+        // prefer-dynamic`, then we interpret this as a *Rust* dynamic library\n+        // is being produced so we use the exe allocator instead.\n+        //\n+        // What this boils down to is:\n+        //\n+        // * Binaries use jemalloc\n+        // * Staticlibs and Rust dylibs use system malloc\n+        // * Rust dylibs used as dependencies to rust use jemalloc\n+        let name = if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n+            &self.sess.target.target.options.lib_allocation_crate\n+        } else {\n+            &self.sess.target.target.options.exe_allocation_crate\n+        };\n+        let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n+                                                 codemap::DUMMY_SP,\n+                                                 PathKind::Crate, false);\n+\n+        // To ensure that the `-Z allocation-crate=foo` option isn't abused, and\n+        // to ensure that the allocator is indeed an allocator, we verify that\n+        // the crate loaded here is indeed tagged #![allocator].\n+        if !data.is_allocator() {\n+            self.sess.err(&format!(\"the allocator crate `{}` is not tagged \\\n+                                    with #![allocator]\", data.name()));\n+        }\n+\n+        self.sess.injected_allocator.set(Some(cnum));\n+        self.inject_allocator_dependency(cnum);\n+    }\n+\n+    fn inject_allocator_dependency(&self, allocator: ast::CrateNum) {\n+        // Before we inject any dependencies, make sure we don't inject a\n+        // circular dependency by validating that this allocator crate doesn't\n+        // transitively depend on any `#![needs_allocator]` crates.\n+        validate(self, allocator, allocator);\n+\n+        // All crates tagged with `needs_allocator` do not explicitly depend on\n+        // the allocator selected for this compile, but in order for this\n+        // compilation to be successfully linked we need to inject a dependency\n+        // (to order the crates on the command line correctly).\n+        //\n+        // Here we inject a dependency from all crates with #![needs_allocator]\n+        // to the crate tagged with #![allocator] for this compilation unit.\n+        self.sess.cstore.iter_crate_data(|cnum, data| {\n+            if !data.needs_allocator() {\n+                return\n+            }\n+\n+            info!(\"injecting a dep from {} to {}\", cnum, allocator);\n+            let mut cnum_map = data.cnum_map.borrow_mut();\n+            let remote_cnum = cnum_map.len() + 1;\n+            let prev = cnum_map.insert(remote_cnum as ast::CrateNum, allocator);\n+            assert!(prev.is_none());\n+        });\n+\n+        fn validate(me: &CrateReader, krate: ast::CrateNum,\n+                    allocator: ast::CrateNum) {\n+            let data = me.sess.cstore.get_crate_data(krate);\n+            if data.needs_allocator() {\n+                let krate_name = data.name();\n+                let data = me.sess.cstore.get_crate_data(allocator);\n+                let alloc_name = data.name();\n+                me.sess.err(&format!(\"the allocator crate `{}` cannot depend \\\n+                                      on a crate that needs an allocator, but \\\n+                                      it depends on `{}`\", alloc_name,\n+                                      krate_name));\n+            }\n+\n+            for (_, &dep) in data.cnum_map.borrow().iter() {\n+                validate(me, dep, allocator);\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'b> LocalCrateReader<'a, 'b> {\n@@ -524,8 +653,9 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     pub fn read_crates(&mut self, krate: &ast::Crate) {\n         self.process_crate(krate);\n         visit::walk_crate(self, krate);\n+        self.creader.inject_allocator_crate();\n \n-        if log_enabled!(log::DEBUG) {\n+        if log_enabled!(log::INFO) {\n             dump_crates(&self.sess.cstore);\n         }\n \n@@ -558,7 +688,8 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                                                               &info.name,\n                                                               None,\n                                                               i.span,\n-                                                              PathKind::Crate);\n+                                                              PathKind::Crate,\n+                                                              true);\n                         self.ast_map.with_path(i.id, |path| {\n                             cmeta.update_local_path(path)\n                         });"}, {"sha": "9179a0a1871c74d526f71df8acb3a940ad029f89", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -22,11 +22,12 @@ use metadata::{creader, decoder, loader};\n use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n-use std::cell::{RefCell, Ref};\n+use std::cell::{RefCell, Ref, Cell};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::ast;\n+use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::parse::token::IdentInterner;\n@@ -59,11 +60,17 @@ pub struct crate_metadata {\n     pub name: String,\n     pub local_path: RefCell<SmallVector<ast_map::PathElem>>,\n     pub data: MetadataBlob,\n-    pub cnum_map: cnum_map,\n+    pub cnum_map: RefCell<cnum_map>,\n     pub cnum: ast::CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub span: codemap::Span,\n-    pub staged_api: bool\n+    pub staged_api: bool,\n+\n+    /// Flag if this crate is required by an rlib version of this crate, or in\n+    /// other words whether it was explicitly linked to. An example of a crate\n+    /// where this is false is when an allocator crate is injected into the\n+    /// dependency list, and therefore isn't actually needed to link an rlib.\n+    pub explicitly_linked: Cell<bool>,\n }\n \n #[derive(Copy, Debug, PartialEq, Clone)]\n@@ -132,10 +139,10 @@ impl CStore {\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &crate_metadata),\n+        I: FnMut(ast::CrateNum, &Rc<crate_metadata>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n-            i(k, &**v);\n+            i(k, v);\n         }\n     }\n \n@@ -188,14 +195,15 @@ impl CStore {\n                  ordering: &mut Vec<ast::CrateNum>) {\n             if ordering.contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in &meta.cnum_map {\n+            for (_, &dep) in meta.cnum_map.borrow().iter() {\n                 visit(cstore, dep, ordering);\n             }\n             ordering.push(cnum);\n         };\n         for (&num, _) in self.metas.borrow().iter() {\n             visit(self, num, &mut ordering);\n         }\n+        info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n         let mut libs = self.used_crate_sources.borrow()\n             .iter()\n@@ -271,8 +279,10 @@ impl crate_metadata {\n             filemaps\n         }\n     }\n+\n     pub fn with_local_path<T, F>(&self, f: F) -> T\n-    where F: Fn(&[ast_map::PathElem]) -> T {\n+        where F: Fn(&[ast_map::PathElem]) -> T\n+    {\n         let cpath = self.local_path.borrow();\n         if cpath.is_empty() {\n             let name = ast_map::PathMod(token::intern(&self.name));\n@@ -281,6 +291,7 @@ impl crate_metadata {\n             f(cpath.as_slice())\n         }\n     }\n+\n     pub fn update_local_path<'a, 'b>(&self, candidate: ast_map::PathElems<'a, 'b>) {\n         let mut cpath = self.local_path.borrow_mut();\n         let cap = cpath.len();\n@@ -295,6 +306,16 @@ impl crate_metadata {\n             },\n         }\n     }\n+\n+    pub fn is_allocator(&self) -> bool {\n+        let attrs = decoder::get_crate_attributes(self.data());\n+        attr::contains_name(&attrs, \"allocator\")\n+    }\n+\n+    pub fn needs_allocator(&self) -> bool {\n+        let attrs = decoder::get_crate_attributes(self.data());\n+        attr::contains_name(&attrs, \"needs_allocator\")\n+    }\n }\n \n impl MetadataBlob {"}, {"sha": "fdd45251711d2d14f593b59bc97fdd59820ea515", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -1174,6 +1174,7 @@ pub struct CrateDep {\n     pub cnum: ast::CrateNum,\n     pub name: String,\n     pub hash: Svh,\n+    pub explicitly_linked: bool,\n }\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n@@ -1188,10 +1189,13 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n         let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash));\n+        let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n+        let explicitly_linked = reader::doc_as_u8(doc) != 0;\n         CrateDep {\n             cnum: crate_num as u32 + 1,\n             name: name,\n             hash: hash,\n+            explicitly_linked: explicitly_linked,\n         }\n     }).collect()\n }\n@@ -1252,7 +1256,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.get(&did.krate) {\n+    match cdata.cnum_map.borrow().get(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n                 krate: n,\n@@ -1270,7 +1274,7 @@ fn reverse_translate_def_id(cdata: Cmd, did: ast::DefId) -> Option<ast::DefId> {\n         return Some(ast::DefId { krate: ast::LOCAL_CRATE, node: did.node });\n     }\n \n-    for (&local, &global) in &cdata.cnum_map {\n+    for (&local, &global) in cdata.cnum_map.borrow().iter() {\n         if global == did.krate {\n             return Some(ast::DefId { krate: local, node: did.node });\n         }\n@@ -1385,7 +1389,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();\n-        let cnum = match cdata.cnum_map.get(&cnum) {\n+        let cnum = match cdata.cnum_map.borrow().get(&cnum) {\n             Some(&n) => n,\n             None => panic!(\"didn't find a crate in the cnum_map\")\n         };"}, {"sha": "cc723d94f74d174f10528f5ad2d7b27bb9e316e9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -23,15 +23,17 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::def;\n-use middle::ty::{self, Ty};\n+use middle::dependency_format::Linkage;\n use middle::stability;\n+use middle::ty::{self, Ty};\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n use std::hash::{Hash, Hasher, SipHasher};\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n+use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{self, DefId, NodeId};\n use syntax::ast_util::*;\n@@ -1751,25 +1753,21 @@ fn encode_polarity(rbml_w: &mut Encoder, polarity: ast::ImplPolarity) {\n }\n \n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n-    fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n+    fn get_ordered_deps(cstore: &cstore::CStore)\n+                        -> Vec<(ast::CrateNum, Rc<cstore::crate_metadata>)> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n-        cstore.iter_crate_data(|key, val| {\n-            let dep = decoder::CrateDep {\n-                cnum: key,\n-                name: decoder::get_crate_name(val.data()),\n-                hash: decoder::get_crate_hash(val.data()),\n-            };\n-            deps.push(dep);\n+        cstore.iter_crate_data(|cnum, val| {\n+            deps.push((cnum, val.clone()));\n         });\n \n         // Sort by cnum\n-        deps.sort_by(|kv1, kv2| kv1.cnum.cmp(&kv2.cnum));\n+        deps.sort_by(|kv1, kv2| kv1.0.cmp(&kv2.0));\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for n in &deps {\n-            assert_eq!(n.cnum, expected_cnum);\n+        for &(n, _) in &deps {\n+            assert_eq!(n, expected_cnum);\n             expected_cnum += 1;\n         }\n \n@@ -1781,8 +1779,8 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     rbml_w.start_tag(tag_crate_deps);\n-    for dep in &get_ordered_deps(cstore) {\n-        encode_crate_dep(rbml_w, dep);\n+    for (_cnum, dep) in get_ordered_deps(cstore) {\n+        encode_crate_dep(rbml_w, &dep);\n     }\n     rbml_w.end_tag();\n }\n@@ -1985,10 +1983,13 @@ fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n }\n \n fn encode_crate_dep(rbml_w: &mut Encoder,\n-                    dep: &decoder::CrateDep) {\n+                    dep: &cstore::crate_metadata) {\n     rbml_w.start_tag(tag_crate_dep);\n-    rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name);\n-    rbml_w.wr_tagged_str(tag_crate_dep_hash, dep.hash.as_str());\n+    rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n+    let hash = decoder::get_crate_hash(dep.data());\n+    rbml_w.wr_tagged_str(tag_crate_dep_hash, hash.as_str());\n+    rbml_w.wr_tagged_u8(tag_crate_dep_explicitly_linked,\n+                        dep.explicitly_linked.get() as u8);\n     rbml_w.end_tag();\n }\n \n@@ -2006,13 +2007,16 @@ fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n \n fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n     let tag = tag_dylib_dependency_formats;\n-    match ecx.tcx.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n+    match ecx.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n-                slot.map(|kind| (format!(\"{}:{}\", i + 1, match kind {\n-                    cstore::RequireDynamic => \"d\",\n-                    cstore::RequireStatic => \"s\",\n-                })).to_string())\n+                let kind = match *slot {\n+                    Linkage::NotLinked |\n+                    Linkage::IncludedFromDylib => return None,\n+                    Linkage::Dynamic => \"d\",\n+                    Linkage::Static => \"s\",\n+                };\n+                Some(format!(\"{}:{}\", i + 1, kind))\n             }).collect::<Vec<String>>();\n             rbml_w.wr_tagged_str(tag, &s.join(\",\"));\n         }"}, {"sha": "125e9285b52b5fca5fcf1b2a8384ffa97eba2f7f", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 125, "deletions": 34, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -67,7 +67,6 @@ use session;\n use session::config;\n use metadata::cstore;\n use metadata::csearch;\n-use middle::ty;\n use util::nodemap::FnvHashMap;\n \n /// A list of dependencies for a certain crate type.\n@@ -76,19 +75,29 @@ use util::nodemap::FnvHashMap;\n /// The value is None if the crate does not need to be linked (it was found\n /// statically in another dylib), or Some(kind) if it needs to be linked as\n /// `kind` (either static or dynamic).\n-pub type DependencyList = Vec<Option<cstore::LinkagePreference>>;\n+pub type DependencyList = Vec<Linkage>;\n \n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n \n-pub fn calculate(tcx: &ty::ctxt) {\n-    let mut fmts = tcx.dependency_formats.borrow_mut();\n-    for &ty in tcx.sess.crate_types.borrow().iter() {\n-        fmts.insert(ty, calculate_type(&tcx.sess, ty));\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Linkage {\n+    NotLinked,\n+    IncludedFromDylib,\n+    Static,\n+    Dynamic,\n+}\n+\n+pub fn calculate(sess: &session::Session) {\n+    let mut fmts = sess.dependency_formats.borrow_mut();\n+    for &ty in sess.crate_types.borrow().iter() {\n+        let linkage = calculate_type(sess, ty);\n+        verify_ok(sess, &linkage);\n+        fmts.insert(ty, linkage);\n     }\n-    tcx.sess.abort_if_errors();\n+    sess.abort_if_errors();\n }\n \n fn calculate_type(sess: &session::Session,\n@@ -145,59 +154,72 @@ fn calculate_type(sess: &session::Session,\n     sess.cstore.iter_crate_data(|cnum, data| {\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         if src.dylib.is_some() {\n-            debug!(\"adding dylib: {}\", data.name);\n+            info!(\"adding dylib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n             for &(depnum, style) in &deps {\n-                debug!(\"adding {:?}: {}\", style,\n-                       sess.cstore.get_crate_data(depnum).name.clone());\n+                info!(\"adding {:?}: {}\", style,\n+                      sess.cstore.get_crate_data(depnum).name.clone());\n                 add_library(sess, depnum, style, &mut formats);\n             }\n         }\n     });\n \n     // Collect what we've got so far in the return vector.\n     let mut ret = (1..sess.cstore.next_crate_num()).map(|i| {\n-        match formats.get(&i).cloned() {\n-            v @ Some(cstore::RequireDynamic) => v,\n-            _ => None,\n+        match formats.get(&i) {\n+            Some(&cstore::RequireDynamic) => Linkage::Dynamic,\n+            Some(&cstore::RequireStatic) => Linkage::IncludedFromDylib,\n+            None => Linkage::NotLinked,\n         }\n     }).collect::<Vec<_>>();\n \n     // Run through the dependency list again, and add any missing libraries as\n     // static libraries.\n+    //\n+    // If the crate hasn't been included yet and it's not actually required\n+    // (e.g. it's an allocator) then we skip it here as well.\n     sess.cstore.iter_crate_data(|cnum, data| {\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n-        if src.dylib.is_none() && !formats.contains_key(&cnum) {\n+        if src.dylib.is_none() &&\n+           !formats.contains_key(&cnum) &&\n+           data.explicitly_linked.get() {\n             assert!(src.rlib.is_some());\n-            debug!(\"adding staticlib: {}\", data.name);\n+            info!(\"adding staticlib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n-            ret[cnum as usize - 1] = Some(cstore::RequireStatic);\n+            ret[cnum as usize - 1] = Linkage::Static;\n         }\n     });\n \n+    // We've gotten this far because we're emitting some form of a final\n+    // artifact which means that we're going to need an allocator of some form.\n+    // No allocator may have been required or linked so far, so activate one\n+    // here if one isn't set.\n+    activate_allocator(sess, &mut ret);\n+\n     // When dylib B links to dylib A, then when using B we must also link to A.\n     // It could be the case, however, that the rlib for A is present (hence we\n     // found metadata), but the dylib for A has since been removed.\n     //\n     // For situations like this, we perform one last pass over the dependencies,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = cnum as ast::CrateNum;\n-        let src = sess.cstore.get_used_crate_source(cnum + 1).unwrap();\n+        let cnum = (cnum + 1) as ast::CrateNum;\n+        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         match *kind {\n-            None => continue,\n-            Some(cstore::RequireStatic) if src.rlib.is_some() => continue,\n-            Some(cstore::RequireDynamic) if src.dylib.is_some() => continue,\n-            Some(kind) => {\n-                let data = sess.cstore.get_crate_data(cnum + 1);\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static if src.rlib.is_some() => continue,\n+            Linkage::Dynamic if src.dylib.is_some() => continue,\n+            kind => {\n+                let kind = match kind {\n+                    Linkage::Static => \"rlib\",\n+                    _ => \"dylib\",\n+                };\n+                let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n-                                 data.name,\n-                                 match kind {\n-                                     cstore::RequireStatic => \"rlib\",\n-                                     cstore::RequireDynamic => \"dylib\",\n-                                 }));\n+                                 data.name, kind));\n             }\n         }\n     }\n@@ -221,8 +243,7 @@ fn add_library(sess: &session::Session,\n             if link2 != link || link == cstore::RequireStatic {\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                  shows up once\",\n-                                 data.name));\n+                                   shows up once\", data.name));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }\n@@ -233,9 +254,79 @@ fn add_library(sess: &session::Session,\n \n fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    if crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n-        Some(crates.into_iter().map(|_| Some(cstore::RequireStatic)).collect())\n-    } else {\n-        None\n+    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n+        return None\n+    }\n+\n+    // All crates are available in an rlib format, so we're just going to link\n+    // everything in explicitly so long as it's actually required.\n+    let mut ret = (1..sess.cstore.next_crate_num()).map(|cnum| {\n+        if sess.cstore.get_crate_data(cnum).explicitly_linked.get() {\n+            Linkage::Static\n+        } else {\n+            Linkage::NotLinked\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Our allocator may not have been activated as it's not flagged with\n+    // explicitly_linked, so flag it here if necessary.\n+    activate_allocator(sess, &mut ret);\n+\n+    Some(ret)\n+}\n+\n+// Given a list of how to link upstream dependencies so far, ensure that an\n+// allocator is activated. This will not do anything if one was transitively\n+// included already (e.g. via a dylib or explicitly so).\n+//\n+// If an allocator was not found then we're guaranteed the metadata::creader\n+// module has injected an allocator dependency (not listed as a required\n+// dependency) in the session's `injected_allocator` field. If this field is not\n+// set then this compilation doesn't actually need an allocator and we can also\n+// skip this step entirely.\n+fn activate_allocator(sess: &session::Session, list: &mut DependencyList) {\n+    let mut allocator_found = false;\n+    for (i, slot) in list.iter().enumerate() {\n+        let cnum = (i + 1) as ast::CrateNum;\n+        if !sess.cstore.get_crate_data(cnum).is_allocator() {\n+            continue\n+        }\n+        if let Linkage::NotLinked = *slot {\n+            continue\n+        }\n+        allocator_found = true;\n+    }\n+    if !allocator_found {\n+        if let Some(injected_allocator) = sess.injected_allocator.get() {\n+            let idx = injected_allocator as usize - 1;\n+            assert_eq!(list[idx], Linkage::NotLinked);\n+            list[idx] = Linkage::Static;\n+        }\n+    }\n+}\n+\n+// After the linkage for a crate has been determined we need to verify that\n+// there's only going to be one allocator in the output.\n+fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n+    if list.len() == 0 {\n+        return\n+    }\n+    let mut allocator = None;\n+    for (i, linkage) in list.iter().enumerate() {\n+        let cnum = (i + 1) as ast::CrateNum;\n+        let data = sess.cstore.get_crate_data(cnum);\n+        if !data.is_allocator() {\n+            continue\n+        }\n+        if let Linkage::NotLinked = *linkage {\n+            continue\n+        }\n+        if let Some(prev_alloc) = allocator {\n+            let prev = sess.cstore.get_crate_data(prev_alloc);\n+            sess.err(&format!(\"cannot link together two \\\n+                               allocators: {} and {}\",\n+                              prev.name(), data.name()));\n+        }\n+        allocator = Some(cnum);\n     }\n }"}, {"sha": "fefd78560455ccc57663a4d358a3bdbe39519d19", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -47,7 +47,6 @@ use middle::check_const;\n use middle::const_eval::{self, ConstVal, ErrKind};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, DefMap, ExportMap};\n-use middle::dependency_format;\n use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -840,8 +839,6 @@ pub struct ctxt<'tcx> {\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_fns: RefCell<DefIdMap<ast::NodeId>>,\n \n-    pub dependency_formats: RefCell<dependency_format::Dependencies>,\n-\n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n@@ -3837,7 +3834,6 @@ impl<'tcx> ctxt<'tcx> {\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_variants: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n-            dependency_formats: RefCell::new(FnvHashMap()),\n             node_lint_levels: RefCell::new(FnvHashMap()),\n             transmute_restrictions: RefCell::new(Vec::new()),\n             stability: RefCell::new(stability),"}, {"sha": "18982215f588f056416ba3bc15391ab755094e8f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -11,8 +11,9 @@\n use lint;\n use metadata::cstore::CStore;\n use metadata::filesearch;\n+use middle::dependency_format;\n use session::search_paths::PathKind;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, FnvHashMap};\n \n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n@@ -57,6 +58,7 @@ pub struct Session {\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n+    pub dependency_formats: RefCell<dependency_format::Dependencies>,\n     pub crate_metadata: RefCell<Vec<String>>,\n     pub features: RefCell<feature_gate::Features>,\n \n@@ -68,7 +70,11 @@ pub struct Session {\n \n     pub can_print_warnings: bool,\n \n-    next_node_id: Cell<ast::NodeId>\n+    /// The metadata::creader module may inject an allocator dependency if it\n+    /// didn't already find one, and this tracks what was injected.\n+    pub injected_allocator: Cell<Option<ast::CrateNum>>,\n+\n+    next_node_id: Cell<ast::NodeId>,\n }\n \n impl Session {\n@@ -447,12 +453,14 @@ pub fn build_session_(sopts: config::Options,\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n+        dependency_formats: RefCell::new(FnvHashMap()),\n         crate_metadata: RefCell::new(Vec::new()),\n         delayed_span_bug: RefCell::new(None),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         can_print_warnings: can_print_warnings,\n-        next_node_id: Cell::new(1)\n+        next_node_id: Cell::new(1),\n+        injected_allocator: Cell::new(None),\n     };\n \n     sess"}, {"sha": "2314368177cb73f601e96bbbb9f486041ed56546", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -32,11 +32,11 @@ pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n #[derive(Clone, Copy, Debug)]\n pub struct ErrorReported;\n \n-pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n-    F: FnOnce(U) -> T,\n+pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n+    F: FnOnce() -> T,\n {\n     thread_local!(static DEPTH: Cell<usize> = Cell::new(0));\n-    if !do_it { return f(u); }\n+    if !do_it { return f(); }\n \n     let old = DEPTH.with(|slot| {\n         let r = slot.get();\n@@ -49,7 +49,7 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n         let ref mut rvp = rv;\n \n         Duration::span(move || {\n-            *rvp = Some(f(u))\n+            *rvp = Some(f())\n         })\n     };\n     let rv = rv.unwrap();"}, {"sha": "0c4e28d97000834e05c50657fe9817b33cbf82b6", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         dll_suffix: \".dylib\".to_string(),\n         archive_format: \"bsd\".to_string(),\n         pre_link_args: Vec::new(),\n+        exe_allocation_crate: super::best_allocator(),\n         .. Default::default()\n     }\n }"}, {"sha": "96680dc37596551dfa273331ac7f0303e398fa3c", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -20,6 +20,7 @@ pub fn opts() -> TargetOptions {\n         has_rpath: true,\n         position_independent_executables: true,\n         archive_format: \"gnu\".to_string(),\n+        exe_allocation_crate: super::best_allocator(),\n \n         .. Default::default()\n     }"}, {"sha": "736035c5389d75a3b48b70a243cf21d724a41908", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -29,6 +29,7 @@ pub fn opts() -> TargetOptions {\n         ),\n         position_independent_executables: true,\n         archive_format: \"bsd\".to_string(),\n+        exe_allocation_crate: super::best_allocator(),\n         .. Default::default()\n     }\n }"}, {"sha": "a5807d2787fdd726ebf4b5fda601c93696e614a9", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -18,6 +18,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         has_rpath: true,\n         archive_format: \"gnu\".to_string(),\n+        exe_allocation_crate: super::best_allocator(),\n \n         .. Default::default()\n     }"}, {"sha": "d6b50a955b6829ddc6d54dc14c548dd4d72946dd", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -29,6 +29,7 @@ pub fn opts() -> TargetOptions {\n         ],\n         position_independent_executables: true,\n         archive_format: \"gnu\".to_string(),\n+        exe_allocation_crate: super::best_allocator(),\n         .. Default::default()\n     }\n }"}, {"sha": "d9cfdaacc905957532d7fa7e4ead7b46648556aa", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -173,6 +173,10 @@ pub struct TargetOptions {\n     /// defined in libgcc.  If this option is enabled, the target must provide\n     /// `eh_unwind_resume` lang item.\n     pub custom_unwind_resume: bool,\n+\n+    /// Default crate for allocation symbols to link against\n+    pub lib_allocation_crate: String,\n+    pub exe_allocation_crate: String,\n }\n \n impl Default for TargetOptions {\n@@ -211,6 +215,8 @@ impl Default for TargetOptions {\n             post_link_objects: Vec::new(),\n             archive_format: String::new(),\n             custom_unwind_resume: false,\n+            lib_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n         }\n     }\n }\n@@ -424,3 +430,11 @@ impl Target {\n         Err(format!(\"Could not find specification for target {:?}\", target))\n     }\n }\n+\n+fn best_allocator() -> String {\n+    if cfg!(disable_jemalloc) {\n+        \"alloc_system\".to_string()\n+    } else {\n+        \"alloc_jemalloc\".to_string()\n+    }\n+}"}, {"sha": "3b02111d93444fbd4cdf34e739890494438da72e", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -27,6 +27,7 @@ pub fn opts() -> TargetOptions {\n         ),\n         position_independent_executables: true,\n         archive_format: \"gnu\".to_string(),\n+        exe_allocation_crate: super::best_allocator(),\n         .. Default::default()\n     }\n }"}, {"sha": "fedae51e0e894cfe46af30a26b271c34658895d1", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -60,6 +60,7 @@ pub fn opts() -> TargetOptions {\n             // Always enable DEP (NX bit) when it is available\n             \"-Wl,--nxcompat\".to_string(),\n         ),\n+        exe_allocation_crate: super::best_allocator(),\n \n         .. Default::default()\n     }"}, {"sha": "fe9ac32ee8fb5251483ef3f8a55d1f98ec2455aa", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -60,6 +60,7 @@ pub fn opts() -> TargetOptions {\n             \"/NXCOMPAT\".to_string(),\n         ],\n         archive_format: \"gnu\".to_string(),\n+        exe_allocation_crate: super::best_allocator(),\n \n         .. Default::default()\n     }"}, {"sha": "263a8e14807027dd3743bc196389d7af0ce84375", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -356,7 +356,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     syntax::ext::mtwt::reset_tables();\n     token::reset_ident_interner();\n \n-    let krate = time(sess.time_passes(), \"parsing\", (), |_| {\n+    let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n                 parse::parse_crate_from_file(&(*file), cfg.clone(), &sess.parse_sess)\n@@ -406,19 +406,19 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     //\n     // baz! should not use this definition unless foo is enabled.\n \n-    krate = time(time_passes, \"configuration 1\", krate, |krate|\n+    krate = time(time_passes, \"configuration 1\", move ||\n                  syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n \n     *sess.crate_types.borrow_mut() =\n         collect_crate_types(sess, &krate.attrs);\n     *sess.crate_metadata.borrow_mut() =\n         collect_crate_metadata(sess, &krate.attrs);\n \n-    time(time_passes, \"recursion limit\", (), |_| {\n+    time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n-    time(time_passes, \"gated macro checking\", (), |_| {\n+    time(time_passes, \"gated macro checking\", || {\n         let features =\n             syntax::feature_gate::check_crate_macros(sess.codemap(),\n                                                      &sess.parse_sess.span_diagnostic,\n@@ -430,20 +430,20 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     });\n \n \n-    krate = time(time_passes, \"crate injection\", krate, |krate|\n+    krate = time(time_passes, \"crate injection\", ||\n                  syntax::std_inject::maybe_inject_crates_ref(krate,\n                                                              sess.opts.alt_std_name.clone()));\n \n-    let macros = time(time_passes, \"macro loading\", (), |_|\n+    let macros = time(time_passes, \"macro loading\", ||\n         metadata::macro_import::read_macro_defs(sess, &krate));\n \n     let mut addl_plugins = Some(addl_plugins);\n-    let registrars = time(time_passes, \"plugin loading\", (), |_|\n+    let registrars = time(time_passes, \"plugin loading\", ||\n         plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n     let mut registry = Registry::new(sess, &krate);\n \n-    time(time_passes, \"plugin registration\", registrars, |registrars| {\n+    time(time_passes, \"plugin registration\", || {\n         if sess.features.borrow().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                 diagnostics::plugin::expand_diagnostic_used);\n@@ -486,45 +486,43 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // Abort if there are errors from lint processing or a plugin registrar.\n     sess.abort_if_errors();\n \n-    krate = time(time_passes, \"expansion\", (krate, macros, syntax_exts),\n-        |(krate, macros, syntax_exts)| {\n-            // Windows dlls do not have rpaths, so they don't know how to find their\n-            // dependencies. It's up to us to tell the system where to find all the\n-            // dependent dlls. Note that this uses cfg!(windows) as opposed to\n-            // targ_cfg because syntax extensions are always loaded for the host\n-            // compiler, not for the target.\n-            let mut _old_path = OsString::new();\n-            if cfg!(windows) {\n-                _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n-                let mut new_path = sess.host_filesearch(PathKind::All)\n-                                       .get_dylib_search_paths();\n-                new_path.extend(env::split_paths(&_old_path));\n-                env::set_var(\"PATH\", &env::join_paths(new_path).unwrap());\n-            }\n-            let features = sess.features.borrow();\n-            let cfg = syntax::ext::expand::ExpansionConfig {\n-                crate_name: crate_name.to_string(),\n-                features: Some(&features),\n-                recursion_limit: sess.recursion_limit.get(),\n-                trace_mac: sess.opts.debugging_opts.trace_macros,\n-            };\n-            let ret = syntax::ext::expand::expand_crate(&sess.parse_sess,\n-                                              cfg,\n-                                              macros,\n-                                              syntax_exts,\n-                                              krate);\n-            if cfg!(windows) {\n-                env::set_var(\"PATH\", &_old_path);\n-            }\n-            ret\n+    krate = time(time_passes, \"expansion\", || {\n+        // Windows dlls do not have rpaths, so they don't know how to find their\n+        // dependencies. It's up to us to tell the system where to find all the\n+        // dependent dlls. Note that this uses cfg!(windows) as opposed to\n+        // targ_cfg because syntax extensions are always loaded for the host\n+        // compiler, not for the target.\n+        let mut _old_path = OsString::new();\n+        if cfg!(windows) {\n+            _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n+            let mut new_path = sess.host_filesearch(PathKind::All)\n+                                   .get_dylib_search_paths();\n+            new_path.extend(env::split_paths(&_old_path));\n+            env::set_var(\"PATH\", &env::join_paths(new_path).unwrap());\n         }\n-    );\n+        let features = sess.features.borrow();\n+        let cfg = syntax::ext::expand::ExpansionConfig {\n+            crate_name: crate_name.to_string(),\n+            features: Some(&features),\n+            recursion_limit: sess.recursion_limit.get(),\n+            trace_mac: sess.opts.debugging_opts.trace_macros,\n+        };\n+        let ret = syntax::ext::expand::expand_crate(&sess.parse_sess,\n+                                          cfg,\n+                                          macros,\n+                                          syntax_exts,\n+                                          krate);\n+        if cfg!(windows) {\n+            env::set_var(\"PATH\", &_old_path);\n+        }\n+        ret\n+    });\n \n     // Needs to go *after* expansion to be able to check the results\n     // of macro expansion.  This runs before #[cfg] to try to catch as\n     // much as possible (e.g. help the programmer avoid platform\n     // specific differences)\n-    time(time_passes, \"complete gated feature checking 1\", (), |_| {\n+    time(time_passes, \"complete gated feature checking 1\", || {\n         let features =\n             syntax::feature_gate::check_crate(sess.codemap(),\n                                               &sess.parse_sess.span_diagnostic,\n@@ -537,25 +535,25 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // JBC: make CFG processing part of expansion to avoid this problem:\n \n     // strip again, in case expansion added anything with a #[cfg].\n-    krate = time(time_passes, \"configuration 2\", krate, |krate|\n+    krate = time(time_passes, \"configuration 2\", ||\n                  syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n \n-    krate = time(time_passes, \"maybe building test harness\", krate, |krate|\n+    krate = time(time_passes, \"maybe building test harness\", ||\n                  syntax::test::modify_for_testing(&sess.parse_sess,\n                                                   &sess.opts.cfg,\n                                                   krate,\n                                                   sess.diagnostic()));\n \n-    krate = time(time_passes, \"prelude injection\", krate, |krate|\n+    krate = time(time_passes, \"prelude injection\", ||\n                  syntax::std_inject::maybe_inject_prelude(&sess.parse_sess, krate));\n \n-    time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n-         syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));\n+    time(time_passes, \"checking that all macro invocations are gone\", ||\n+         syntax::ext::expand::check_for_macros(&sess.parse_sess, &krate));\n \n     // One final feature gating of the true AST that gets compiled\n     // later, to make sure we've got everything (e.g. configuration\n     // can insert new attributes via `cfg_attr`)\n-    time(time_passes, \"complete gated feature checking 2\", (), |_| {\n+    time(time_passes, \"complete gated feature checking 2\", || {\n         let features =\n             syntax::feature_gate::check_crate(sess.codemap(),\n                                               &sess.parse_sess.span_diagnostic,\n@@ -582,7 +580,7 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n         }\n     }\n \n-    let map = time(sess.time_passes(), \"assigning node ids and indexing ast\", forest, |forest|\n+    let map = time(sess.time_passes(), \"assigning node ids and indexing ast\", move ||\n                    ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n \n     if sess.opts.debugging_opts.ast_json {\n@@ -608,10 +606,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n-    time(time_passes, \"external crate/lib resolution\", (), |_|\n+    time(time_passes, \"external crate/lib resolution\", ||\n          LocalCrateReader::new(&sess, &ast_map).read_crates(krate));\n \n-    let lang_items = time(time_passes, \"language item collection\", (), |_|\n+    let lang_items = time(time_passes, \"language item collection\", ||\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n     let resolve::CrateMap {\n@@ -622,30 +620,30 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         external_exports,\n         glob_map,\n     } =\n-        time(time_passes, \"resolution\", (),\n-             |_| resolve::resolve_crate(&sess, &ast_map, make_glob_map));\n+        time(time_passes, \"resolution\",\n+             || resolve::resolve_crate(&sess, &ast_map, make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     syntax::ext::mtwt::clear_tables();\n \n-    let named_region_map = time(time_passes, \"lifetime resolution\", (),\n-                                |_| middle::resolve_lifetime::krate(&sess, krate, &def_map));\n+    let named_region_map = time(time_passes, \"lifetime resolution\",\n+                                || middle::resolve_lifetime::krate(&sess, krate, &def_map));\n \n-    time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(&sess, &ast_map));\n+    time(time_passes, \"looking for entry point\",\n+         || middle::entry::find_entry_point(&sess, &ast_map));\n \n     sess.plugin_registrar_fn.set(\n-        time(time_passes, \"looking for plugin registrar\", (), |_|\n+        time(time_passes, \"looking for plugin registrar\", ||\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n-    let region_map = time(time_passes, \"region resolution\", (), |_|\n+    let region_map = time(time_passes, \"region resolution\", ||\n                           middle::region::resolve_crate(&sess, krate));\n \n-    time(time_passes, \"loop checking\", (), |_|\n+    time(time_passes, \"loop checking\", ||\n          middle::check_loop::check_crate(&sess, krate));\n \n-    time(time_passes, \"static item recursion checking\", (), |_|\n+    time(time_passes, \"static item recursion checking\", ||\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n     ty::ctxt::create_and_enter(sess,\n@@ -662,33 +660,33 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         // passes are timed inside typeck\n         typeck::check_crate(tcx, trait_map);\n \n-        time(time_passes, \"const checking\", (), |_|\n+        time(time_passes, \"const checking\", ||\n             middle::check_const::check_crate(tcx));\n \n         let (exported_items, public_items) =\n-                time(time_passes, \"privacy checking\", (), |_|\n+                time(time_passes, \"privacy checking\", ||\n                     rustc_privacy::check_crate(tcx, &export_map, external_exports));\n \n         // Do not move this check past lint\n-        time(time_passes, \"stability index\", (), |_|\n+        time(time_passes, \"stability index\", ||\n             tcx.stability.borrow_mut().build(tcx, krate, &public_items));\n \n-        time(time_passes, \"intrinsic checking\", (), |_|\n+        time(time_passes, \"intrinsic checking\", ||\n             middle::intrinsicck::check_crate(tcx));\n \n-        time(time_passes, \"effect checking\", (), |_|\n+        time(time_passes, \"effect checking\", ||\n             middle::effect::check_crate(tcx));\n \n-        time(time_passes, \"match checking\", (), |_|\n+        time(time_passes, \"match checking\", ||\n             middle::check_match::check_crate(tcx));\n \n-        time(time_passes, \"liveness checking\", (), |_|\n+        time(time_passes, \"liveness checking\", ||\n             middle::liveness::check_crate(tcx));\n \n-        time(time_passes, \"borrow checking\", (), |_|\n+        time(time_passes, \"borrow checking\", ||\n             borrowck::check_crate(tcx));\n \n-        time(time_passes, \"rvalue checking\", (), |_|\n+        time(time_passes, \"rvalue checking\", ||\n             middle::check_rvalues::check_crate(tcx, krate));\n \n         // Avoid overwhelming user with errors if type checking failed.\n@@ -699,24 +697,24 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         tcx.sess.abort_if_errors();\n \n         let reachable_map =\n-            time(time_passes, \"reachability checking\", (), |_|\n+            time(time_passes, \"reachability checking\", ||\n                 reachable::find_reachable(tcx, &exported_items));\n \n-        time(time_passes, \"death checking\", (), |_| {\n+        time(time_passes, \"death checking\", || {\n             middle::dead::check_crate(tcx,\n                                       &exported_items,\n                                       &reachable_map)\n         });\n \n         let ref lib_features_used =\n-            time(time_passes, \"stability checking\", (), |_|\n+            time(time_passes, \"stability checking\", ||\n                 stability::check_unstable_api_usage(tcx));\n \n-        time(time_passes, \"unused lib feature checking\", (), |_|\n+        time(time_passes, \"unused lib feature checking\", ||\n             stability::check_unused_or_stable_features(\n                 &tcx.sess, lib_features_used));\n \n-        time(time_passes, \"lint checking\", (), |_|\n+        time(time_passes, \"lint checking\", ||\n             lint::check_crate(tcx, &exported_items));\n \n         // The above three passes generate errors w/o aborting\n@@ -739,11 +737,11 @@ pub fn phase_4_translate_to_llvm(tcx: &ty::ctxt, analysis: ty::CrateAnalysis)\n                                  -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n-    time(time_passes, \"resolving dependency formats\", (), |_|\n-         dependency_format::calculate(tcx));\n+    time(time_passes, \"resolving dependency formats\", ||\n+         dependency_format::calculate(&tcx.sess));\n \n     // Option dance to work around the lack of stack once closures.\n-    time(time_passes, \"translation\", analysis, |analysis|\n+    time(time_passes, \"translation\", move ||\n          trans::trans_crate(tcx, analysis))\n }\n \n@@ -755,7 +753,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n     if sess.opts.cg.no_integrated_as {\n         let output_type = config::OutputTypeAssembly;\n \n-        time(sess.time_passes(), \"LLVM passes\", (), |_|\n+        time(sess.time_passes(), \"LLVM passes\", ||\n             write::run_passes(sess, trans, &[output_type], outputs));\n \n         write::run_assembler(sess, outputs);\n@@ -765,7 +763,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n             fs::remove_file(&outputs.temp_path(config::OutputTypeAssembly)).unwrap();\n         }\n     } else {\n-        time(sess.time_passes(), \"LLVM passes\", (), |_|\n+        time(sess.time_passes(), \"LLVM passes\", ||\n             write::run_passes(sess,\n                               trans,\n                               &sess.opts.output_types,\n@@ -780,7 +778,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    time(sess.time_passes(), \"linking\", (), |_|\n+    time(sess.time_passes(), \"linking\", ||\n          link::link_binary(sess,\n                            trans,\n                            outputs,"}, {"sha": "5bb013c5f966239cdb844b93d1c64de265253cb7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -383,10 +383,10 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         if sess.opts.debugging_opts.save_analysis {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(),\n-                     \"save analysis\", (),\n-                     |_| save::process_crate(state.tcx.unwrap(),\n-                                             state.analysis.unwrap(),\n-                                             state.out_dir));\n+                     \"save analysis\",\n+                     || save::process_crate(state.tcx.unwrap(),\n+                                            state.analysis.unwrap(),\n+                                            state.out_dir));\n             };\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }"}, {"sha": "91c0edb901f697b2f479718ae4fb1515cc6d839d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 50, "deletions": 34, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -23,6 +23,7 @@ use metadata::common::LinkMeta;\n use metadata::filesearch::FileDoesntMatch;\n use metadata::loader::METADATA_FILENAME;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n+use middle::dependency_format::Linkage;\n use middle::ty::{self, Ty};\n use rustc::ast_map::{PathElem, PathElems, PathName};\n use trans::{CrateContext, CrateTranslation, gensym_name};\n@@ -493,6 +494,31 @@ pub fn filename_for_input(sess: &Session,\n     }\n }\n \n+pub fn each_linked_rlib(sess: &Session,\n+                        f: &mut FnMut(ast::CrateNum, &Path)) {\n+    let crates = sess.cstore.get_used_crates(cstore::RequireStatic).into_iter();\n+    let fmts = sess.dependency_formats.borrow();\n+    let fmts = fmts.get(&config::CrateTypeExecutable).or_else(|| {\n+        fmts.get(&config::CrateTypeStaticlib)\n+    }).unwrap_or_else(|| {\n+        sess.bug(\"could not find formats for rlibs\")\n+    });\n+    for (cnum, path) in crates {\n+        match fmts[cnum as usize - 1] {\n+            Linkage::NotLinked | Linkage::IncludedFromDylib => continue,\n+            _ => {}\n+        }\n+        let name = sess.cstore.get_crate_data(cnum).name.clone();\n+        let path = match path {\n+            Some(p) => p,\n+            None => {\n+                sess.fatal(&format!(\"could not find rlib for: `{}`\", name));\n+            }\n+        };\n+        f(cnum, &path);\n+    }\n+}\n+\n fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: config::CrateType,\n@@ -524,11 +550,11 @@ fn link_binary_output(sess: &Session,\n             link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n         }\n         config::CrateTypeExecutable => {\n-            link_natively(sess, trans, false, &objects, &out_filename, outputs,\n+            link_natively(sess, false, &objects, &out_filename, trans, outputs,\n                           tmpdir.path());\n         }\n         config::CrateTypeDylib => {\n-            link_natively(sess, trans, true, &objects, &out_filename, outputs,\n+            link_natively(sess, true, &objects, &out_filename, trans, outputs,\n                           tmpdir.path());\n         }\n     }\n@@ -763,23 +789,15 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n         ab.add_native_library(\"compiler-rt\").unwrap();\n     }\n \n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     let mut all_native_libs = vec![];\n \n-    for &(cnum, ref path) in &crates {\n-        let ref name = sess.cstore.get_crate_data(cnum).name;\n-        let p = match *path {\n-            Some(ref p) => p.clone(), None => {\n-                sess.err(&format!(\"could not find rlib for: `{}`\",\n-                                 name));\n-                continue\n-            }\n-        };\n-        ab.add_rlib(&p, &name[..], sess.lto()).unwrap();\n+    each_linked_rlib(sess, &mut |cnum, path| {\n+        let name = sess.cstore.get_crate_data(cnum).name();\n+        ab.add_rlib(path, &name, sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs);\n-    }\n+    });\n \n     ab.update_symbols();\n     ab.build();\n@@ -805,8 +823,9 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n //\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n-fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n+fn link_natively(sess: &Session, dylib: bool,\n                  objects: &[PathBuf], out_filename: &Path,\n+                 trans: &CrateTranslation,\n                  outputs: &OutputFilenames,\n                  tmpdir: &Path) {\n     info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, objects,\n@@ -829,7 +848,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n         };\n         link_args(&mut *linker, sess, dylib, tmpdir,\n-                  trans, objects, out_filename, outputs);\n+                  objects, out_filename, trans, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n         }\n@@ -848,7 +867,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // Invoke the system linker\n     info!(\"{:?}\", &cmd);\n-    let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n+    let prog = time(sess.time_passes(), \"running linker\", || cmd.output());\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n@@ -884,9 +903,9 @@ fn link_args(cmd: &mut Linker,\n              sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n-             trans: &CrateTranslation,\n              objects: &[PathBuf],\n              out_filename: &Path,\n+             trans: &CrateTranslation,\n              outputs: &OutputFilenames) {\n \n     // The default library location, we need this to find the runtime.\n@@ -980,7 +999,7 @@ fn link_args(cmd: &mut Linker,\n     // this kind of behavior is pretty platform specific and generally not\n     // recommended anyway, so I don't think we're shooting ourself in the foot\n     // much with that.\n-    add_upstream_rust_crates(cmd, sess, dylib, tmpdir, trans);\n+    add_upstream_rust_crates(cmd, sess, dylib, tmpdir);\n     add_local_native_libraries(cmd, sess);\n     add_upstream_native_libraries(cmd, sess);\n \n@@ -1086,8 +1105,7 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n-                            dylib: bool, tmpdir: &Path,\n-                            trans: &CrateTranslation) {\n+                            dylib: bool, tmpdir: &Path) {\n     // All of the heavy lifting has previously been accomplished by the\n     // dependency_format module of the compiler. This is just crawling the\n     // output of that module, adding crates as necessary.\n@@ -1096,10 +1114,11 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n \n+    let formats = sess.dependency_formats.borrow();\n     let data = if dylib {\n-        trans.crate_formats.get(&config::CrateTypeDylib).unwrap()\n+        formats.get(&config::CrateTypeDylib).unwrap()\n     } else {\n-        trans.crate_formats.get(&config::CrateTypeExecutable).unwrap()\n+        formats.get(&config::CrateTypeExecutable).unwrap()\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n@@ -1110,20 +1129,17 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let kind = match data[cnum as usize - 1] {\n-            Some(t) => t,\n-            None => continue\n-        };\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match kind {\n-            cstore::RequireDynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n-            }\n-            cstore::RequireStatic => {\n+        match data[cnum as usize - 1] {\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static => {\n                 add_static_crate(cmd, sess, tmpdir, dylib, &src.rlib.unwrap().0)\n             }\n+            Linkage::Dynamic => {\n+                add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n+            }\n         }\n-\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -1174,7 +1190,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time(sess.time_passes(), &format!(\"altering {}.rlib\", name), (), |()| {\n+        time(sess.time_passes(), &format!(\"altering {}.rlib\", name), || {\n             let cfg = archive_config(sess, &dst, Some(cratepath));\n             let mut archive = ArchiveBuilder::new(cfg);\n             archive.remove_file(METADATA_FILENAME);"}, {"sha": "a4333dc10d6378a5f92bd9cce88bf939e4266e08", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -17,7 +17,7 @@ use std::process::Command;\n \n use back::archive;\n use metadata::csearch;\n-use metadata::cstore;\n+use middle::dependency_format::Linkage;\n use session::Session;\n use session::config::DebugInfoLevel::{NoDebugInfo, LimitedDebugInfo, FullDebugInfo};\n use session::config::CrateTypeDylib;\n@@ -347,9 +347,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n             // dynamic library. For all statically linked libraries we take all\n             // their reachable symbols and emit them as well.\n             let cstore = &sess.cstore;\n-            let symbols = trans.crate_formats[&CrateTypeDylib].iter();\n+            let formats = sess.dependency_formats.borrow();\n+            let symbols = formats[&CrateTypeDylib].iter();\n             let symbols = symbols.enumerate().filter_map(|(i, f)| {\n-                if let Some(cstore::RequireStatic) = *f {\n+                if *f == Linkage::Static {\n                     Some((i + 1) as ast::CrateNum)\n                 } else {\n                     None"}, {"sha": "00439c1fd5878ae46cb5829dc0929b24bbbeb406", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -14,7 +14,6 @@ use rustc::session::{self, config};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n-use rustc::metadata::cstore;\n use rustc::util::common::time;\n use back::write::{ModuleConfig, with_llvm_pmb};\n \n@@ -46,17 +45,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, path) in crates {\n-        let name = sess.cstore.get_crate_data(cnum).name.clone();\n-        let path = match path {\n-            Some(p) => p,\n-            None => {\n-                sess.fatal(&format!(\"could not find rlib for: `{}`\",\n-                                   name));\n-            }\n-        };\n-\n+    link::each_linked_rlib(sess, &mut |_, path| {\n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n             child.name().map(|name| (name, child))\n@@ -65,7 +54,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let bc_encoded = data.data();\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n-                time(sess.time_passes(), &format!(\"decode {}\", name), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}\", name), || {\n                     // Read the version\n                     let version = extract_bytecode_format_version(bc_encoded);\n \n@@ -89,9 +78,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     }\n                 })\n             } else {\n-                time(sess.time_passes(), &format!(\"decode {}\", name), (), |_| {\n-                // the object must be in the old, pre-versioning format, so simply\n-                // inflate everything and let LLVM decide if it can make sense of it\n+                time(sess.time_passes(), &format!(\"decode {}\", name), || {\n+                    // the object must be in the old, pre-versioning format, so\n+                    // simply inflate everything and let LLVM decide if it can\n+                    // make sense of it\n                     match flate::inflate_bytes(bc_encoded) {\n                         Ok(bc) => bc,\n                         Err(_) => {\n@@ -104,8 +94,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n             let ptr = bc_decoded.as_ptr();\n             debug!(\"linking {}\", name);\n-            time(sess.time_passes(), &format!(\"ll link {}\", name), (),\n-                 |()| unsafe {\n+            time(sess.time_passes(), &format!(\"ll link {}\", name), || unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n@@ -115,7 +104,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                 }\n             });\n         }\n-    }\n+    });\n \n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<CString> = reachable.iter().map(|s| {\n@@ -154,7 +143,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n         llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n-        time(sess.time_passes(), \"LTO passes\", (), |()|\n+        time(sess.time_passes(), \"LTO passes\", ||\n              llvm::LLVMRunPassManager(pm, llmod));\n \n         llvm::LLVMDisposePassManager(pm);"}, {"sha": "d75f2fcf126a941084612637d6237ba555b1d8f0", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -484,9 +484,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         cgcx.handler.abort_if_errors();\n \n         // Finally, run the actual optimization passes\n-        time(config.time_passes, \"llvm function passes\", (), |()|\n+        time(config.time_passes, \"llvm function passes\", ||\n              llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-        time(config.time_passes, \"llvm module passes\", (), |()|\n+        time(config.time_passes, \"llvm module passes\", ||\n              llvm::LLVMRunPassManager(mpm, llmod));\n \n         // Deallocate managers that we're now done with\n@@ -495,7 +495,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         match cgcx.lto_ctxt {\n             Some((sess, reachable)) if sess.lto() =>  {\n-                time(sess.time_passes(), \"all lto passes\", (), |()|\n+                time(sess.time_passes(), \"all lto passes\", ||\n                      lto::run(sess, llmod, tm, reachable, &config));\n \n                 if config.emit_lto_bc {\n@@ -536,7 +536,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n-    time(config.time_passes, \"codegen passes\", (), |()| {\n+    time(config.time_passes, \"codegen passes\", || {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n             let out = output_names.with_extension(&ext);"}, {"sha": "1b4e14d7ad79feccd1ff92dfd5e5635b085ea1c0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -2822,7 +2822,6 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         llcx: shared_ccx.metadata_llcx(),\n         llmod: shared_ccx.metadata_llmod(),\n     };\n-    let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n     CrateTranslation {\n@@ -2831,7 +2830,6 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable_symbols,\n-        crate_formats: formats,\n         no_builtins: no_builtins,\n     }\n }"}, {"sha": "04854501312bf36046ceece5adf7c63c5cc10267", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -10,7 +10,6 @@\n \n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n-use middle::dependency_format;\n \n pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n@@ -74,6 +73,5 @@ pub struct CrateTranslation {\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n-    pub crate_formats: dependency_format::Dependencies,\n     pub no_builtins: bool,\n }"}, {"sha": "1eff224219e5fd34f93c9ec023449b5a11414a7f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -332,34 +332,34 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n         tcx: tcx\n     };\n \n-    time(time_passes, \"type collecting\", (), |_|\n+    time(time_passes, \"type collecting\", ||\n          collect::collect_item_types(tcx));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n-    time(time_passes, \"variance inference\", (), |_|\n+    time(time_passes, \"variance inference\", ||\n          variance::infer_variance(tcx));\n \n-    time(time_passes, \"coherence checking\", (), |_|\n+    time(time_passes, \"coherence checking\", ||\n         coherence::check_coherence(&ccx));\n \n-    time(time_passes, \"wf checking (old)\", (), |_|\n+    time(time_passes, \"wf checking (old)\", ||\n         check::check_wf_old(&ccx));\n \n-    time(time_passes, \"item-types checking\", (), |_|\n+    time(time_passes, \"item-types checking\", ||\n         check::check_item_types(&ccx));\n \n-    time(time_passes, \"item-bodies checking\", (), |_|\n+    time(time_passes, \"item-bodies checking\", ||\n         check::check_item_bodies(&ccx));\n \n-    time(time_passes, \"drop-impl checking\", (), |_|\n+    time(time_passes, \"drop-impl checking\", ||\n         check::check_drop_impls(&ccx));\n \n     // Do this last so that if there are errors in the old code, they\n     // get reported, and we don't get extra warnings.\n-    time(time_passes, \"wf checking (new)\", (), |_|\n+    time(time_passes, \"wf checking (new)\", ||\n         check::check_wf_new(&ccx));\n \n     check_for_entry_fn(&ccx);"}, {"sha": "3dcb157233d603d42a4cecbc2bd292df46f54d93", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -275,8 +275,6 @@ extern crate alloc;\n extern crate rustc_unicode;\n extern crate libc;\n \n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n-\n // Make std testable by not duplicating lang items and other globals. See #2912\n #[cfg(test)] extern crate std as realstd;\n "}, {"sha": "694a1a43f593d9940f5f2334034bb7adf967eb4f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -85,6 +85,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"on_unimplemented\", \"1.0.0\", Active),\n     (\"simd_ffi\", \"1.0.0\", Active),\n     (\"allocator\", \"1.0.0\", Active),\n+    (\"needs_allocator\", \"1.4.0\", Active),\n     (\"linked_from\", \"1.3.0\", Active),\n \n     (\"if_let\", \"1.0.0\", Accepted),\n@@ -253,6 +254,9 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n                                       is an experimental feature\")),\n     (\"allocator\", Gated(\"allocator\",\n                         \"the `#[allocator]` attribute is an experimental feature\")),\n+    (\"needs_allocator\", Gated(\"needs_allocator\", \"the `#[needs_allocator]` \\\n+                                                  attribute is an experimental \\\n+                                                  feature\")),\n     (\"rustc_variance\", Gated(\"rustc_attrs\",\n                              \"the `#[rustc_variance]` attribute \\\n                               is an experimental feature\")),"}, {"sha": "0194fb1dddad986c3e4546266114f83c5bf6755d", "filename": "src/test/auxiliary/allocator-dummy.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator-dummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator-dummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fallocator-dummy.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(allocator, no_std, core, core_intrinsics, libc)]\n+#![allocator]\n+#![crate_type = \"rlib\"]\n+#![no_std]\n+\n+extern crate libc;\n+\n+pub static mut HITS: usize = 0;\n+\n+#[no_mangle]\n+pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+    unsafe {\n+        HITS += 1;\n+        libc::malloc(size as libc::size_t) as *mut u8\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+    unsafe {\n+        HITS += 1;\n+        libc::free(ptr as *mut _)\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,\n+                                align: usize) -> *mut u8 {\n+    unsafe {\n+        libc::realloc(ptr as *mut _, size as libc::size_t) as *mut u8\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate_inplace(ptr: *mut u8, old_size: usize,\n+                                        size: usize, align: usize) -> usize {\n+    unsafe { core::intrinsics::abort() }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_usable_size(size: usize, align: usize) -> usize {\n+    unsafe { core::intrinsics::abort() }\n+}"}, {"sha": "568b247ecdbf326a0a14a3c287b26c18adfb3064", "filename": "src/test/auxiliary/allocator-dylib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator-dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator-dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fallocator-dylib.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"dylib\"]\n+\n+pub fn foo() {}"}, {"sha": "0d76c0e5eb8d14088c8044ca390cf8ae19a1a5fa", "filename": "src/test/auxiliary/allocator-dylib2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator-dylib2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator-dylib2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fallocator-dylib2.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn foo() {}\n+"}, {"sha": "4e9cef643484c691e4ef620cdb15ff982433bb44", "filename": "src/test/auxiliary/allocator1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fallocator1.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(allocator, no_std, core)]\n+#![allocator]\n+#![crate_type = \"rlib\"]\n+#![no_std]"}, {"sha": "4e9cef643484c691e4ef620cdb15ff982433bb44", "filename": "src/test/auxiliary/allocator2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fallocator2.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(allocator, no_std, core)]\n+#![allocator]\n+#![crate_type = \"rlib\"]\n+#![no_std]"}, {"sha": "1ee21bc7ddb3595f904ce21b28abd9aff6729e9f", "filename": "src/test/auxiliary/allocator3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fallocator3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fallocator3.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(no_std, allocator)]\n+#![no_std]\n+#![allocator]\n+#![crate_type = \"rlib\"]\n+\n+extern crate needs_allocator;\n+"}, {"sha": "c09b153d921daf0990d3b609ac1b7ee0cc830cd3", "filename": "src/test/auxiliary/needs_allocator.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fneeds_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fauxiliary%2Fneeds_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fneeds_allocator.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(no_std, needs_allocator)]\n+#![no_std]\n+#![needs_allocator]\n+#![crate_type = \"rlib\"]"}, {"sha": "7f420ff735a3ef4d86739353f18030d879c39a3e", "filename": "src/test/compile-fail/allocator-depends-on-needs-allocators.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Fallocator-depends-on-needs-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Fallocator-depends-on-needs-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-depends-on-needs-allocators.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: `allocator3` cannot depend on a crate that needs an allocator\n+// aux-build:needs_allocator.rs\n+// aux-build:allocator3.rs\n+\n+// The needs_allocator crate is a dependency of the allocator crate allocator3,\n+// which is not allowed\n+\n+extern crate allocator3;\n+\n+fn main() {\n+}"}, {"sha": "8fad2af42b9a24945f666b1e731394ab21e57337", "filename": "src/test/compile-fail/allocator-dylib-is-system.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-msvc everything is the system allocator on msvc\n+// aux-build:allocator-dylib.rs\n+// no-prefer-dynamic\n+// error-pattern: cannot link together two allocators\n+\n+// Verify that the allocator for statically linked dynamic libraries is the\n+// system allocator. Do this by linking in jemalloc and making sure that we get\n+// an error.\n+\n+#![feature(alloc_jemalloc)]\n+\n+extern crate allocator_dylib;\n+extern crate alloc_jemalloc;\n+\n+fn main() {\n+    allocator_dylib::foo();\n+}"}, {"sha": "224d9379ee1580ea9fb943aa57bac6aef0a09f1a", "filename": "src/test/compile-fail/allocator-rust-dylib-is-jemalloc.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-msvc everything is the system allocator on msvc\n+// aux-build:allocator-dylib2.rs\n+// error-pattern: cannot link together two allocators\n+\n+// Ensure that rust dynamic libraries use jemalloc as their allocator, verifying\n+// by linking in the system allocator here and ensuring that we get a complaint.\n+\n+#![feature(alloc_system)]\n+\n+extern crate allocator_dylib2;\n+extern crate alloc_system;\n+\n+fn main() {\n+    allocator_dylib2::foo();\n+}\n+"}, {"sha": "6490216d0126fe453d9805341be1ba2d71032d8f", "filename": "src/test/compile-fail/feature-gate-allocator.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allocator.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allocator] //~ ERROR: experimental feature\n+\n+fn main() {}"}, {"sha": "1809564f5de1e826f1ac0386c95a9129ab77f5f6", "filename": "src/test/compile-fail/feature-gate-needs-allocator.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ffeature-gate-needs-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ffeature-gate-needs-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-needs-allocator.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![needs_allocator] //~ ERROR the `#[needs_allocator]` attribute is\n+\n+fn main() {}\n+"}, {"sha": "d6fcbcb513ae3d83656487d7888822d6706fb787", "filename": "src/test/compile-fail/two-allocators-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-2.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot link together two allocators: allocator1 and allocator2\n+// aux-build:allocator1.rs\n+// aux-build:allocator2.rs\n+\n+// Make sure we can't link together two explicit allocators.\n+\n+extern crate allocator1;\n+extern crate allocator2;\n+\n+fn main() {}\n+"}, {"sha": "70c9dfcafae753eb8a3899af48f90037ce56300e", "filename": "src/test/compile-fail/two-allocators-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-3.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:allocator1.rs\n+// error-pattern: cannot link together two allocators\n+\n+// We're linking std dynamically (via -C prefer-dynamic for this test) which\n+// has an allocator and then we're also linking in a new allocator (allocator1)\n+// and this should be an error\n+\n+extern crate allocator1;\n+\n+fn main() {\n+}"}, {"sha": "a34f77de2455b456bb1688673a125816356f0e51", "filename": "src/test/compile-fail/two-allocators.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ftwo-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Fcompile-fail%2Ftwo-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-allocators.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot link together two allocators\n+\n+// aux-build:allocator1.rs\n+// aux-build:allocator2.rs\n+\n+extern crate allocator1;\n+extern crate allocator2;\n+\n+fn main() {}"}, {"sha": "1bca39de6635d75e8987818cb53d34d033cc6c39", "filename": "src/test/run-pass/allocator-default.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-default.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(alloc_jemalloc, alloc_system)]\n+\n+#[cfg(not(target_env = \"msvc\"))]\n+extern crate alloc_jemalloc;\n+#[cfg(target_env = \"msvc\")]\n+extern crate alloc_system;\n+\n+fn main() {\n+    println!(\"{:?}\", Box::new(3));\n+}"}, {"sha": "77fa64ec3db07fb96b4a8a40e2024fa9ffe75df6", "filename": "src/test/run-pass/allocator-jemalloc.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-jemalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-jemalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-jemalloc.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+// ignore-msvc no jemalloc on msvc\n+\n+#![feature(alloc_jemalloc)]\n+\n+extern crate alloc_jemalloc;\n+\n+fn main() {\n+    println!(\"{:?}\", Box::new(3));\n+}"}, {"sha": "993ea414914fbdf32c7217cedc664ffc4a77993f", "filename": "src/test/run-pass/allocator-override.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-override.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+// aux-build:allocator-dummy.rs\n+\n+extern crate allocator_dummy;\n+\n+fn main() {\n+    unsafe {\n+        let before = allocator_dummy::HITS;\n+        let b = Box::new(3);\n+        assert_eq!(allocator_dummy::HITS - before, 1);\n+        drop(b);\n+        assert_eq!(allocator_dummy::HITS - before, 2);\n+    }\n+}"}, {"sha": "4585003d5793b7a85f0953824404fbb340b17e79", "filename": "src/test/run-pass/allocator-system.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bf1ed1a1123122ded05ae2eedaf0f190e52726/src%2Ftest%2Frun-pass%2Fallocator-system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-system.rs?ref=45bf1ed1a1123122ded05ae2eedaf0f190e52726", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(alloc_system)]\n+\n+extern crate alloc_system;\n+\n+fn main() {\n+    println!(\"{:?}\", Box::new(3));\n+}"}]}