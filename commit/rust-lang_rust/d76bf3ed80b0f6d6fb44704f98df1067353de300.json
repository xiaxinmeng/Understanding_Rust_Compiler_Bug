{"sha": "d76bf3ed80b0f6d6fb44704f98df1067353de300", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NmJmM2VkODBiMGY2ZDZmYjQ0NzA0Zjk4ZGYxMDY3MzUzZGUzMDA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-07T22:24:01Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-07T22:41:35Z"}, "message": "Strip unconfigured nodes in the `InvocationCollector` fold.", "tree": {"sha": "a785aa274d0341fedce7c62f0b50275c75af6840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a785aa274d0341fedce7c62f0b50275c75af6840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d76bf3ed80b0f6d6fb44704f98df1067353de300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d76bf3ed80b0f6d6fb44704f98df1067353de300", "html_url": "https://github.com/rust-lang/rust/commit/d76bf3ed80b0f6d6fb44704f98df1067353de300", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d76bf3ed80b0f6d6fb44704f98df1067353de300/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "html_url": "https://github.com/rust-lang/rust/commit/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc"}], "stats": {"total": 86, "additions": 67, "deletions": 19}, "files": [{"sha": "3f5b294cc0443803e658dc724010718516d07681", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d76bf3ed80b0f6d6fb44704f98df1067353de300/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d76bf3ed80b0f6d6fb44704f98df1067353de300/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=d76bf3ed80b0f6d6fb44704f98df1067353de300", "patch": "@@ -70,7 +70,7 @@ macro_rules! configure {\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+    pub fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         let node = self.process_cfg_attrs(node);\n         if self.in_cfg(node.attrs()) { Some(node) } else { None }\n     }\n@@ -166,7 +166,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+    pub fn configure_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n             items: foreign_mod.items.into_iter().filter_map(|item| self.configure(item)).collect(),\n@@ -187,7 +187,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+    pub fn configure_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n         match item {\n             ast::ItemKind::Struct(def, generics) => {\n                 ast::ItemKind::Struct(self.configure_variant_data(def), generics)\n@@ -217,7 +217,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_expr_kind(&mut self, expr_kind: ast::ExprKind) -> ast::ExprKind {\n+    pub fn configure_expr_kind(&mut self, expr_kind: ast::ExprKind) -> ast::ExprKind {\n         if let ast::ExprKind::Match(m, arms) = expr_kind {\n             let arms = arms.into_iter().filter_map(|a| self.configure(a)).collect();\n             ast::ExprKind::Match(m, arms)\n@@ -226,7 +226,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.visit_stmt_or_expr_attrs(expr.attrs());\n \n         // If an expr is valid to cfg away it will have been removed by the\n@@ -244,7 +244,7 @@ impl<'a> StripUnconfigured<'a> {\n         self.process_cfg_attrs(expr)\n     }\n \n-    fn configure_stmt(&mut self, stmt: ast::Stmt) -> Option<ast::Stmt> {\n+    pub fn configure_stmt(&mut self, stmt: ast::Stmt) -> Option<ast::Stmt> {\n         self.visit_stmt_or_expr_attrs(stmt.attrs());\n         self.configure(stmt)\n     }"}, {"sha": "68aca3ee32f93ae5d035500b5a73353f97909c55", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d76bf3ed80b0f6d6fb44704f98df1067353de300/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d76bf3ed80b0f6d6fb44704f98df1067353de300/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d76bf3ed80b0f6d6fb44704f98df1067353de300", "patch": "@@ -208,14 +208,23 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n-        let expansion = expansion.fold_with(&mut StripUnconfigured {\n-            config: &self.cx.cfg,\n-            should_test: self.cx.ecfg.should_test,\n-            sess: self.cx.parse_sess,\n-            features: self.cx.ecfg.features,\n-        });\n-        let mut collector = InvocationCollector { cx: self.cx, invocations: Vec::new() };\n-        (expansion.fold_with(&mut collector), collector.invocations)\n+        let crate_config = mem::replace(&mut self.cx.cfg, Vec::new());\n+        let result = {\n+            let mut collector = InvocationCollector {\n+                cfg: StripUnconfigured {\n+                    config: &crate_config,\n+                    should_test: self.cx.ecfg.should_test,\n+                    sess: self.cx.parse_sess,\n+                    features: self.cx.ecfg.features,\n+                },\n+                cx: self.cx,\n+                invocations: Vec::new(),\n+            };\n+            (expansion.fold_with(&mut collector), collector.invocations)\n+        };\n+\n+        self.cx.cfg = crate_config;\n+        result\n     }\n \n     fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n@@ -403,9 +412,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n struct InvocationCollector<'a, 'b: 'a> {\n     cx: &'a mut ExtCtxt<'b>,\n+    cfg: StripUnconfigured<'a>,\n     invocations: Vec<Invocation>,\n }\n \n+macro_rules! fully_configure {\n+    ($this:ident, $node:ident, $noop_fold:ident) => {\n+        match $noop_fold($node, &mut $this.cfg).pop() {\n+            Some(node) => node,\n+            None => return SmallVector::zero(),\n+        }\n+    }\n+}\n+\n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n         let mark = Mark::fresh();\n@@ -475,11 +494,17 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         }\n         false\n     }\n+\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n+    }\n }\n \n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let expr = expr.unwrap();\n+        let mut expr = self.cfg.configure_expr(expr).unwrap();\n+        expr.node = self.cfg.configure_expr_kind(expr.node);\n+\n         if let ast::ExprKind::Mac(mac) = expr.node {\n             self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr).make_expr()\n         } else {\n@@ -488,7 +513,9 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let expr = expr.unwrap();\n+        let mut expr = configure!(self, expr).unwrap();\n+        expr.node = self.cfg.configure_expr_kind(expr.node);\n+\n         if let ast::ExprKind::Mac(mac) = expr.node {\n             self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr)\n                 .make_opt_expr()\n@@ -511,6 +538,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        let stmt = match self.cfg.configure_stmt(stmt) {\n+            Some(stmt) => stmt,\n+            None => return SmallVector::zero(),\n+        };\n+\n         let (mac, style, attrs) = match stmt.node {\n             StmtKind::Mac(mac) => mac.unwrap(),\n             _ => return noop_fold_stmt(stmt, self),\n@@ -540,9 +572,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        let item = configure!(self, item);\n+\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n-            let item = Annotatable::Item(item);\n+            let item = Annotatable::Item(fully_configure!(self, item, noop_fold_item));\n             return self.collect_attr(attr, item, ExpansionKind::Items).make_items();\n         }\n \n@@ -610,9 +644,12 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n+        let item = configure!(self, item);\n+\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n-            let item = Annotatable::TraitItem(P(item));\n+            let item =\n+                Annotatable::TraitItem(P(fully_configure!(self, item, noop_fold_trait_item)));\n             return self.collect_attr(attr, item, ExpansionKind::TraitItems).make_trait_items()\n         }\n \n@@ -626,9 +663,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n+        let item = configure!(self, item);\n+\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n-            let item = Annotatable::ImplItem(P(item));\n+            let item = Annotatable::ImplItem(P(fully_configure!(self, item, noop_fold_impl_item)));\n             return self.collect_attr(attr, item, ExpansionKind::ImplItems).make_impl_items();\n         }\n \n@@ -653,6 +692,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             _ => unreachable!(),\n         }\n     }\n+\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+        noop_fold_foreign_mod(self.cfg.configure_foreign_mod(foreign_mod), self)\n+    }\n+\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n+    }\n }\n \n pub struct ExpansionConfig<'feat> {"}, {"sha": "4a2c9aff2d2b4e98d0648b98272bdb731dec4164", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d76bf3ed80b0f6d6fb44704f98df1067353de300/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d76bf3ed80b0f6d6fb44704f98df1067353de300/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d76bf3ed80b0f6d6fb44704f98df1067353de300", "patch": "@@ -104,6 +104,7 @@ pub mod abi;\n pub mod ast;\n pub mod attr;\n pub mod codemap;\n+#[macro_use]\n pub mod config;\n pub mod entry;\n pub mod feature_gate;"}]}