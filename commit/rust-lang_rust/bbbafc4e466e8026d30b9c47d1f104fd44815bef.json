{"sha": "bbbafc4e466e8026d30b9c47d1f104fd44815bef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYmFmYzRlNDY2ZTgwMjZkMzBiOWM0N2QxZjEwNGZkNDQ4MTViZWY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-02T01:43:10Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-02T01:43:10Z"}, "message": "syntax: remove some dead code.", "tree": {"sha": "e37ad68d02fa45e356aae6c442da10edfd7bbcff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e37ad68d02fa45e356aae6c442da10edfd7bbcff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbbafc4e466e8026d30b9c47d1f104fd44815bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbbafc4e466e8026d30b9c47d1f104fd44815bef", "html_url": "https://github.com/rust-lang/rust/commit/bbbafc4e466e8026d30b9c47d1f104fd44815bef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbbafc4e466e8026d30b9c47d1f104fd44815bef/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe4e7478c5b89994795292db2cea2f944c0f1013", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4e7478c5b89994795292db2cea2f944c0f1013", "html_url": "https://github.com/rust-lang/rust/commit/fe4e7478c5b89994795292db2cea2f944c0f1013"}], "stats": {"total": 73, "additions": 0, "deletions": 73}, "files": [{"sha": "a717535358b2322873297686a30eaa98b348973d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bbbafc4e466e8026d30b9c47d1f104fd44815bef/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbafc4e466e8026d30b9c47d1f104fd44815bef/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bbbafc4e466e8026d30b9c47d1f104fd44815bef", "patch": "@@ -185,79 +185,6 @@ pub fn add_new_extension(cx: @ExtCtxt,\n       _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n-    // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ExtCtxt,\n-                         sp: Span,\n-                         name: Ident,\n-                         arg: &[ast::token_tree],\n-                         lhses: &[@named_match],\n-                         rhses: &[@named_match])\n-                         -> MacResult {\n-        if cx.trace_macros() {\n-            println!(\"{}! \\\\{ {} \\\\}\",\n-                      cx.str_of(name),\n-                      print::pprust::tt_to_str(\n-                          &ast::tt_delim(@mut arg.to_owned()),\n-                          get_ident_interner()));\n-        }\n-\n-        // Which arm's failure should we report? (the one furthest along)\n-        let mut best_fail_spot = dummy_sp();\n-        let mut best_fail_msg = ~\"internal error: ran no matchers\";\n-\n-        let s_d = cx.parse_sess().span_diagnostic;\n-\n-        for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n-            match *lhs {\n-              @matched_nonterminal(nt_matchers(ref mtcs)) => {\n-                // `none` is because we're not interpolating\n-                let arg_rdr = new_tt_reader(\n-                    s_d,\n-                    None,\n-                    arg.to_owned()\n-                ) as @mut reader;\n-                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n-                  success(named_matches) => {\n-                    let rhs = match rhses[i] {\n-                        // okay, what's your transcriber?\n-                        @matched_nonterminal(nt_tt(@ref tt)) => {\n-                            match (*tt) {\n-                                // cut off delimiters; don't parse 'em\n-                                tt_delim(ref tts) => {\n-                                    (*tts).slice(1u,(*tts).len()-1u).to_owned()\n-                                }\n-                                _ => cx.span_fatal(\n-                                    sp, \"macro rhs must be delimited\")\n-                            }\n-                        },\n-                        _ => cx.span_bug(sp, \"bad thing in rhs\")\n-                    };\n-                    // rhs has holes ( `$id` and `$(...)` that need filled)\n-                    let trncbr = new_tt_reader(s_d, Some(named_matches),\n-                                               rhs);\n-                    let p = @Parser(cx.parse_sess(),\n-                                    cx.cfg(),\n-                                    trncbr as @mut reader);\n-\n-                    // Let the context choose how to interpret the result.\n-                    // Weird, but useful for X-macros.\n-                    return MRAny(@ParserAnyMacro {\n-                        parser: p\n-                    } as @AnyMacro);\n-                  }\n-                  failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n-                    best_fail_spot = sp;\n-                    best_fail_msg = (*msg).clone();\n-                  },\n-                  error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n-                }\n-              }\n-              _ => cx.bug(\"non-matcher found in parsed lhses\")\n-            }\n-        }\n-        cx.span_fatal(best_fail_spot, best_fail_msg);\n-    }\n-\n     let exp = @MacroRulesSyntaxExpanderTTFun {\n         name: name,\n         lhses: lhses,"}]}