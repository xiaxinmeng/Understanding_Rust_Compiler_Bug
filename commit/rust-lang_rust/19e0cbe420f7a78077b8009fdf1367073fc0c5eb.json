{"sha": "19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZTBjYmU0MjBmN2E3ODA3N2I4MDA5ZmRmMTM2NzA3M2ZjMGM1ZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-23T07:26:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-23T07:26:33Z"}, "message": "auto merge of #11682 : thestinger/rust/vector, r=brson\n\nThis is just an initial implementation and does not yet fully replace `~[T]`. A generic initialization syntax for containers is missing, and the slice functionality needs to be reworked to make auto-slicing unnecessary.\r\n\r\nTraits for supporting indexing properly are also required. This also needs to be fixed to make ring buffers as easy to use as vectors.\r\n\r\nThe tests and documentation for `~[T]` can be ported over to this type when it is removed. I don't really expect DST to happen for vectors as having both `~[T]` and `Vec<T>` is overcomplicated and changing the slice representation to 3 words is not at all appealing. Unlike with traits, it's possible (and easy) to implement `RcSlice<T>` and `GcSlice<T>` without compiler help.", "tree": {"sha": "10232b5958cac95aa3a437791661333f8e1818c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10232b5958cac95aa3a437791661333f8e1818c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "html_url": "https://github.com/rust-lang/rust/commit/19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52ba3b6414fe91cf92222581cb24e06894267c49", "url": "https://api.github.com/repos/rust-lang/rust/commits/52ba3b6414fe91cf92222581cb24e06894267c49", "html_url": "https://github.com/rust-lang/rust/commit/52ba3b6414fe91cf92222581cb24e06894267c49"}, {"sha": "b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "html_url": "https://github.com/rust-lang/rust/commit/b2ec71fc277ca590bb8bd26d3f7762d6406860e5"}], "stats": {"total": 368, "additions": 300, "deletions": 68}, "files": [{"sha": "217eab527582ef020f97e251c173eb392bb81edd", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -230,7 +230,7 @@ impl<T: Send> Drop for Unique<T> {\n             // We need to move the object out of the box, so that\n             // the destructor is called (at the end of this scope.)\n             ptr::replace_ptr(self.ptr, x);\n-            free(self.ptr as *c_void)\n+            free(self.ptr as *mut c_void)\n         }\n     }\n }"}, {"sha": "35a6ccaa7083cb119f08c96304738cbbfe5b503c", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -172,7 +172,7 @@ mod tests {\n             let mem = malloc_raw(n);\n \n             CVec::new_with_dtor(mem as *mut u8, n,\n-                proc() { libc::free(mem as *c_void); })\n+                proc() { libc::free(mem as *mut c_void); })\n         }\n     }\n "}, {"sha": "faceb17af476792b5c5e2a124690aea0390e5059", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -53,7 +53,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n         assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                              outsz as uint);\n-        libc::free(res);\n+        libc::free(res as *mut c_void);\n         out\n     }\n }\n@@ -76,7 +76,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n         assert!(res as int != 0);\n         let out = vec::raw::from_buf_raw(res as *u8,\n                                          outsz as uint);\n-        libc::free(res);\n+        libc::free(res as *mut c_void);\n         out\n     }\n }"}, {"sha": "af06533d44bd1cb1844fa3809e405657be4acc14", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -548,13 +548,13 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n             let p = Path::new(p);\n             let star = p.join(\"*\");\n             as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint) as *c_void;\n+                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n                 let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n                 if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n                     let mut paths = ~[];\n                     let mut more_files = 1 as libc::c_int;\n                     while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n+                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n                         if fp_buf as uint == 0 {\n                             fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                         }\n@@ -567,7 +567,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n                     FindClose(find_handle);\n-                    free(wfd_ptr);\n+                    free(wfd_ptr as *mut c_void);\n                     Ok(paths)\n                 } else {\n                     Err(super::last_error())"}, {"sha": "3693b00951bcc84bacdfea7f51fe9b91c4d0fc0f", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -1836,7 +1836,7 @@ impl TypeNames {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n-            free(s as *c_void);\n+            free(s as *mut c_void);\n             ret\n         }\n     }\n@@ -1850,7 +1850,7 @@ impl TypeNames {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);\n-            free(s as *c_void);\n+            free(s as *mut c_void);\n             ret\n         }\n     }"}, {"sha": "0a6e23e995640d443f1fc0d59f1e4f3812680b65", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -373,7 +373,7 @@ pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n }\n \n pub unsafe fn free_handle(v: *c_void) {\n-    free(v)\n+    free(v as *mut c_void)\n }\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n@@ -383,7 +383,7 @@ pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n }\n \n pub unsafe fn free_req(v: *c_void) {\n-    free(v)\n+    free(v as *mut c_void)\n }\n \n #[test]"}, {"sha": "22e93e5819442bbadd7786b3cef9e91c8f0c2889", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -183,7 +183,7 @@ impl Drop for CString {\n     fn drop(&mut self) {\n         if self.owns_buffer_ {\n             unsafe {\n-                libc::free(self.buf as *libc::c_void)\n+                libc::free(self.buf as *mut libc::c_void)\n             }\n         }\n     }\n@@ -459,7 +459,7 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n+        unsafe { libc::free(c_str.unwrap() as *mut libc::c_void) }\n     }\n \n     #[test]"}, {"sha": "13a03d3252514d378c6d3cdb76b0909fc48d8565", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -66,8 +66,9 @@ use rand::Rng;\n use rand;\n use uint;\n use util::replace;\n-use vec::{ImmutableVector, MutableVector, OwnedVector};\n-use vec;\n+use vec::{ImmutableVector, MutableVector, OwnedVector, Items, MutItems};\n+use vec_ng;\n+use vec_ng::Vec;\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -90,7 +91,7 @@ pub struct HashMap<K,V> {\n     priv k1: u64,\n     priv resize_at: uint,\n     priv size: uint,\n-    priv buckets: ~[Option<Bucket<K, V>>],\n+    priv buckets: Vec<Option<Bucket<K, V>>>\n }\n \n // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n@@ -151,7 +152,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                              -> SearchResult {\n         let mut ret = TableFull;\n         self.bucket_sequence(hash, |i| {\n-            match self.buckets[i] {\n+            match self.buckets.as_slice()[i] {\n                 Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n                     ret = FoundEntry(i); false\n                 },\n@@ -169,7 +170,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                                -> SearchResult {\n         let mut ret = TableFull;\n         self.bucket_sequence(hash, |i| {\n-            match self.buckets[i] {\n+            match self.buckets.as_slice()[i] {\n                 Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n                     ret = FoundEntry(i); false\n                 },\n@@ -194,7 +195,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         self.resize_at = resize_at(new_capacity);\n \n         let old_buckets = replace(&mut self.buckets,\n-                                  vec::from_fn(new_capacity, |_| None));\n+                                  Vec::from_fn(new_capacity, |_| None));\n \n         self.size = 0;\n         for bucket in old_buckets.move_iter() {\n@@ -213,15 +214,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n     #[inline]\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n-        match self.buckets[idx] {\n+        match self.buckets.as_slice()[idx] {\n             Some(ref bkt) => &bkt.value,\n             None => fail!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n     #[inline]\n     fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n-        match self.buckets[idx] {\n+        match self.buckets.as_mut_slice()[idx] {\n             Some(ref mut bkt) => &mut bkt.value,\n             None => unreachable!()\n         }\n@@ -234,13 +235,12 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => { fail!(\"Internal logic error\"); }\n             FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                                value: v});\n+                self.buckets.as_mut_slice()[idx] = Some(Bucket{hash: hash, key: k, value: v});\n                 self.size += 1;\n                 None\n             }\n             FoundEntry(idx) => {\n-                match self.buckets[idx] {\n+                match self.buckets.as_mut_slice()[idx] {\n                     None => { fail!(\"insert_internal: Internal logic error\") }\n                     Some(ref mut b) => {\n                         b.hash = hash;\n@@ -273,16 +273,16 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         };\n \n         let len_buckets = self.buckets.len();\n-        let bucket = self.buckets[idx].take();\n+        let bucket = self.buckets.as_mut_slice()[idx].take();\n \n         let value = bucket.map(|bucket| bucket.value);\n \n         /* re-inserting buckets may cause changes in size, so remember\n         what our new size is ahead of time before we start insertions */\n         let size = self.size - 1;\n         idx = self.next_bucket(idx, len_buckets);\n-        while self.buckets[idx].is_some() {\n-            let bucket = self.buckets[idx].take();\n+        while self.buckets.as_slice()[idx].is_some() {\n+            let bucket = self.buckets.as_mut_slice()[idx].take();\n             self.insert_opt_bucket(bucket);\n             idx = self.next_bucket(idx, len_buckets);\n         }\n@@ -300,7 +300,7 @@ impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n-        for bkt in self.buckets.mut_iter() {\n+        for bkt in self.buckets.as_mut_slice().mut_iter() {\n             *bkt = None;\n         }\n         self.size = 0;\n@@ -380,7 +380,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             k0: k0, k1: k1,\n             resize_at: resize_at(cap),\n             size: 0,\n-            buckets: vec::from_fn(cap, |_| None)\n+            buckets: Vec::from_fn(cap, |_| None)\n         }\n     }\n \n@@ -455,7 +455,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n                 let v = not_found(&k, a);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k, value: v});\n+                self.buckets.as_mut_slice()[idx] = Some(Bucket{hash: hash, key: k, value: v});\n                 self.size += 1;\n                 idx\n             }\n@@ -541,14 +541,14 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// Iterator element type is (&'a K, &'a V).\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n-        Entries { iter: self.buckets.iter() }\n+        Entries { iter: self.buckets.as_slice().iter() }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is (&'a K, &'a mut V).\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        MutEntries { iter: self.buckets.mut_iter() }\n+        MutEntries { iter: self.buckets.as_mut_slice().mut_iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n@@ -599,17 +599,17 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n /// HashMap iterator\n #[deriving(Clone)]\n pub struct Entries<'a, K, V> {\n-    priv iter: vec::Items<'a, Option<Bucket<K, V>>>,\n+    priv iter: Items<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap mutable values iterator\n pub struct MutEntries<'a, K, V> {\n-    priv iter: vec::MutItems<'a, Option<Bucket<K, V>>>,\n+    priv iter: MutItems<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap move iterator\n pub struct MoveEntries<K, V> {\n-    priv iter: vec::MoveItems<Option<Bucket<K, V>>>,\n+    priv iter: vec_ng::MoveItems<Option<Bucket<K, V>>>,\n }\n \n /// HashMap keys iterator\n@@ -623,12 +623,12 @@ pub type Values<'a, K, V> =\n /// HashSet iterator\n #[deriving(Clone)]\n pub struct SetItems<'a, K> {\n-    priv iter: vec::Items<'a, Option<Bucket<K, ()>>>,\n+    priv iter: Items<'a, Option<Bucket<K, ()>>>,\n }\n \n /// HashSet move iterator\n pub struct SetMoveItems<K> {\n-    priv iter: vec::MoveItems<Option<Bucket<K, ()>>>,\n+    priv iter: vec_ng::MoveItems<Option<Bucket<K, ()>>>,\n }\n \n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n@@ -807,7 +807,7 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems { iter: self.map.buckets.iter() }\n+        SetItems { iter: self.map.buckets.as_slice().iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out"}, {"sha": "7e53a0071bd1cc01f6ee06e61032765f80509ced", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -110,6 +110,7 @@ pub mod char;\n pub mod tuple;\n \n pub mod vec;\n+pub mod vec_ng;\n pub mod at_vec;\n pub mod str;\n "}, {"sha": "6f2d64ff668215c105c10f0ab3b074bed4b31db0", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -3225,7 +3225,7 @@ pub mod funcs {\n                 pub fn calloc(nobj: size_t, size: size_t) -> *c_void;\n                 pub fn malloc(size: size_t) -> *mut c_void;\n                 pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n-                pub fn free(p: *c_void);\n+                pub fn free(p: *mut c_void);\n                 pub fn exit(status: c_int) -> !;\n                 // Omitted: atexit.\n                 pub fn system(s: *c_char) -> c_int;"}, {"sha": "6bee8cb70f5671ac7880c7cd62eebd043e0fc0a9", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -52,7 +52,7 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     // `realloc(ptr, 0)` may allocate, but it may also return a null pointer\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n     if size == 0 {\n-        free(ptr as *c_void);\n+        free(ptr as *mut c_void);\n         mut_null()\n     } else {\n         let p = realloc(ptr as *mut c_void, size as size_t);\n@@ -107,7 +107,7 @@ pub unsafe fn exchange_free_(ptr: *u8) {\n \n #[inline]\n pub unsafe fn exchange_free(ptr: *u8) {\n-    free(ptr as *c_void);\n+    free(ptr as *mut c_void);\n }\n \n #[cfg(test)]"}, {"sha": "e740862fddfb407f3bd4277c38631a7413ab9a14", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -389,7 +389,7 @@ impl<T: Send> Buffer<T> {\n impl<T: Send> Drop for Buffer<T> {\n     fn drop(&mut self) {\n         // It is assumed that all buffers are empty on drop.\n-        unsafe { libc::free(self.storage as *libc::c_void) }\n+        unsafe { libc::free(self.storage as *mut libc::c_void) }\n     }\n }\n "}, {"sha": "69c6204cc3236a5ba6c6a2f0044866c4035b5b50", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -173,49 +173,49 @@ mod imp {\n     type pthread_condattr_t = libc::c_void;\n \n     pub unsafe fn init_lock() -> uint {\n-        let block = malloc_raw(rust_pthread_mutex_t_size() as uint) as *pthread_mutex_t;\n+        let block = malloc_raw(rust_pthread_mutex_t_size() as uint) as *mut pthread_mutex_t;\n         let n = pthread_mutex_init(block, ptr::null());\n         assert_eq!(n, 0);\n         return block as uint;\n     }\n \n     pub unsafe fn init_cond() -> uint {\n-        let block = malloc_raw(rust_pthread_cond_t_size() as uint) as *pthread_cond_t;\n+        let block = malloc_raw(rust_pthread_cond_t_size() as uint) as *mut pthread_cond_t;\n         let n = pthread_cond_init(block, ptr::null());\n         assert_eq!(n, 0);\n         return block as uint;\n     }\n \n     pub unsafe fn free_lock(h: uint) {\n-        let block = h as *libc::c_void;\n+        let block = h as *mut libc::c_void;\n         assert_eq!(pthread_mutex_destroy(block), 0);\n         libc::free(block);\n     }\n \n     pub unsafe fn free_cond(h: uint) {\n-        let block = h as *pthread_cond_t;\n+        let block = h as *mut pthread_cond_t;\n         assert_eq!(pthread_cond_destroy(block), 0);\n         libc::free(block);\n     }\n \n     pub unsafe fn lock(l: uint) {\n-        assert_eq!(pthread_mutex_lock(l as *pthread_mutex_t), 0);\n+        assert_eq!(pthread_mutex_lock(l as *mut pthread_mutex_t), 0);\n     }\n \n     pub unsafe fn trylock(l: uint) -> bool {\n-        pthread_mutex_trylock(l as *pthread_mutex_t) == 0\n+        pthread_mutex_trylock(l as *mut pthread_mutex_t) == 0\n     }\n \n     pub unsafe fn unlock(l: uint) {\n-        assert_eq!(pthread_mutex_unlock(l as *pthread_mutex_t), 0);\n+        assert_eq!(pthread_mutex_unlock(l as *mut pthread_mutex_t), 0);\n     }\n \n     pub unsafe fn wait(cond: uint, m: uint) {\n-        assert_eq!(pthread_cond_wait(cond as *pthread_cond_t, m as *pthread_mutex_t), 0);\n+        assert_eq!(pthread_cond_wait(cond as *mut pthread_cond_t, m as *mut pthread_mutex_t), 0);\n     }\n \n     pub unsafe fn signal(cond: uint) {\n-        assert_eq!(pthread_cond_signal(cond as *pthread_cond_t), 0);\n+        assert_eq!(pthread_cond_signal(cond as *mut pthread_cond_t), 0);\n     }\n \n     extern {\n@@ -224,19 +224,19 @@ mod imp {\n     }\n \n     extern {\n-        fn pthread_mutex_init(lock: *pthread_mutex_t,\n+        fn pthread_mutex_init(lock: *mut pthread_mutex_t,\n                               attr: *pthread_mutexattr_t) -> libc::c_int;\n-        fn pthread_mutex_destroy(lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_init(cond: *pthread_cond_t,\n+        fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_init(cond: *mut pthread_cond_t,\n                               attr: *pthread_condattr_t) -> libc::c_int;\n-        fn pthread_cond_destroy(cond: *pthread_cond_t) -> libc::c_int;\n-        fn pthread_mutex_lock(lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_trylock(lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_unlock(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n+        fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n \n-        fn pthread_cond_wait(cond: *pthread_cond_t,\n-                             lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_signal(cond: *pthread_cond_t) -> libc::c_int;\n+        fn pthread_cond_wait(cond: *mut pthread_cond_t,\n+                             lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;\n     }\n }\n \n@@ -263,7 +263,7 @@ mod imp {\n \n     pub unsafe fn free_lock(h: uint) {\n         DeleteCriticalSection(h as LPCRITICAL_SECTION);\n-        libc::free(h as *c_void);\n+        libc::free(h as *mut c_void);\n     }\n \n     pub unsafe fn free_cond(h: uint) {"}, {"sha": "8e8e5f6e62cc2ebfb311903d587e8f84cf38fae4", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -960,7 +960,7 @@ pub trait ImmutableVector<'a, T> {\n     fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U];\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    unsafe fn unsafe_ref(&self, index: uint) -> *T;\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n \n     /**\n      * Returns an unsafe pointer to the vector's buffer\n@@ -1149,8 +1149,8 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_ref(&self, index: uint) -> *T {\n-        self.repr().data.offset(index as int)\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n+        cast::transmute(self.repr().data.offset(index as int))\n     }\n \n     #[inline]\n@@ -2183,7 +2183,7 @@ pub trait MutableVector<'a, T> {\n     fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;\n \n     /// Returns an unsafe mutable pointer to the element in index\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T;\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n \n     /// Return an unsafe mutable pointer to the vector's buffer.\n     ///\n@@ -2361,8 +2361,8 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T {\n-        ptr::mut_offset(self.repr().data as *mut T, index as int)\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n+        cast::transmute(ptr::mut_offset(self.repr().data as *mut T, index as int))\n     }\n \n     #[inline]"}, {"sha": "e503497d95dffd9fbef41b90fbb3beb21cbb5149", "filename": "src/libstd/vec_ng.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0cbe420f7a78077b8009fdf1367073fc0c5eb/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=19e0cbe420f7a78077b8009fdf1367073fc0c5eb", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Migrate documentation over from `std::vec` when it is removed.\n+#[doc(hidden)];\n+\n+use prelude::*;\n+use container::Container;\n+use mem::size_of;\n+use cast::{forget, transmute};\n+use rt::global_heap::{malloc_raw, realloc_raw};\n+use vec::Items;\n+use unstable::raw::Slice;\n+use ptr::{offset, read_ptr};\n+use libc::{free, c_void};\n+use unstable::intrinsics::move_val_init;\n+\n+pub struct Vec<T> {\n+    priv len: uint,\n+    priv cap: uint,\n+    priv ptr: *mut T\n+}\n+\n+impl<T> Vec<T> {\n+    #[inline]\n+    pub fn new() -> Vec<T> {\n+        Vec { len: 0, cap: 0, ptr: 0 as *mut T }\n+    }\n+\n+    pub fn with_capacity(capacity: uint) -> Vec<T> {\n+        if capacity == 0 {\n+            Vec::new()\n+        } else {\n+            let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n+            let ptr = unsafe { malloc_raw(size) };\n+            Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n+        }\n+    }\n+\n+    pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n+        unsafe {\n+            let mut xs = Vec::with_capacity(length);\n+            while xs.len < length {\n+                move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len), op(xs.len));\n+                xs.len += 1;\n+            }\n+            xs\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Vec<T> {\n+    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n+        unsafe {\n+            let mut xs = Vec::with_capacity(length);\n+            while xs.len < length {\n+                move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len), value.clone());\n+                xs.len += 1;\n+            }\n+            xs\n+        }\n+    }\n+}\n+\n+impl<T> Container for Vec<T> {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.len\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        self.cap\n+    }\n+\n+    pub fn reserve_exact(&mut self, capacity: uint) {\n+        if capacity >= self.len {\n+            let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n+            self.cap = capacity;\n+            unsafe {\n+                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+            }\n+        }\n+    }\n+\n+    pub fn shrink_to_fit(&mut self) {\n+        if self.len == 0 {\n+            unsafe { free(self.ptr as *mut c_void) };\n+            self.cap = 0;\n+            self.ptr = 0 as *mut T;\n+        } else {\n+            unsafe {\n+                // Overflow check is unnecessary as the vector is already at least this large.\n+                self.ptr = realloc_raw(self.ptr as *mut u8, self.len * size_of::<T>()) as *mut T;\n+            }\n+            self.cap = self.len;\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            unsafe {\n+                self.len -= 1;\n+                Some(read_ptr(self.as_slice().unsafe_ref(self.len())))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, value: T) {\n+        if self.len == self.cap {\n+            if self.cap == 0 { self.cap += 2 }\n+            let old_size = self.cap * size_of::<T>();\n+            self.cap = self.cap * 2;\n+            let size = old_size * 2;\n+            if old_size > size { fail!(\"capacity overflow\") }\n+            unsafe {\n+                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+            }\n+        }\n+\n+        unsafe {\n+            let end = offset(self.ptr as *T, self.len as int) as *mut T;\n+            move_val_init(&mut *end, value);\n+            self.len += 1;\n+        }\n+    }\n+\n+    pub fn truncate(&mut self, len: uint) {\n+        unsafe {\n+            let mut i = len;\n+            // drop any extra elements\n+            while i < self.len {\n+                read_ptr(self.as_slice().unsafe_ref(i));\n+                i += 1;\n+            }\n+        }\n+        self.len = len;\n+    }\n+\n+    #[inline]\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        let slice = Slice { data: self.ptr as *T, len: self.len };\n+        unsafe { transmute(slice) }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        let slice = Slice { data: self.ptr as *T, len: self.len };\n+        unsafe { transmute(slice) }\n+    }\n+\n+    #[inline]\n+    pub fn move_iter(self) -> MoveItems<T> {\n+        unsafe {\n+            let iter = transmute(self.as_slice().iter());\n+            let ptr = self.ptr as *mut c_void;\n+            forget(self);\n+            MoveItems { allocation: ptr, iter: iter }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn set_len(&mut self, len: uint) {\n+        self.len = len;\n+    }\n+}\n+\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Vec<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            for x in self.as_mut_slice().iter() {\n+                read_ptr(x);\n+            }\n+            free(self.ptr as *mut c_void)\n+        }\n+    }\n+}\n+\n+pub struct MoveItems<T> {\n+    priv allocation: *mut c_void, // the block of memory allocated for the vector\n+    priv iter: Items<'static, T>\n+}\n+\n+impl<T> Iterator<T> for MoveItems<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            self.iter.next().map(|x| read_ptr(x))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        unsafe {\n+            self.iter.next_back().map(|x| read_ptr(x))\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for MoveItems<T> {\n+    fn drop(&mut self) {\n+        // destroy the remaining elements\n+        for _x in *self {}\n+        unsafe {\n+            free(self.allocation)\n+        }\n+    }\n+}"}]}