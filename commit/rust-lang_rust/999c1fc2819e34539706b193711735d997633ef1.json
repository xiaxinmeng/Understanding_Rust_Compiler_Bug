{"sha": "999c1fc2819e34539706b193711735d997633ef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OWMxZmMyODE5ZTM0NTM5NzA2YjE5MzcxMTczNWQ5OTc2MzNlZjE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-07T06:03:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-12T23:31:30Z"}, "message": "Remove the equality operation between `Symbol` and strings.\n\nAnd also the equality between `Path` and strings, because `Path` is made\nup of `Symbol`s.", "tree": {"sha": "1ad67bb2b24d9d1e85af2a05308d994ac4ba2949", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ad67bb2b24d9d1e85af2a05308d994ac4ba2949"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/999c1fc2819e34539706b193711735d997633ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/999c1fc2819e34539706b193711735d997633ef1", "html_url": "https://github.com/rust-lang/rust/commit/999c1fc2819e34539706b193711735d997633ef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/999c1fc2819e34539706b193711735d997633ef1/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb084a48e2ca663de41b316dc6ece2dceb93e24e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb084a48e2ca663de41b316dc6ece2dceb93e24e", "html_url": "https://github.com/rust-lang/rust/commit/fb084a48e2ca663de41b316dc6ece2dceb93e24e"}], "stats": {"total": 355, "additions": 182, "deletions": 173}, "files": [{"sha": "dd0d13d8f5a6aea74ae0498538285a36463d4209", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -73,7 +73,7 @@ use syntax_pos::Span;\n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a> {\n-    crate_root: Option<&'static str>,\n+    crate_root: Option<Symbol>,\n \n     /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n@@ -164,8 +164,8 @@ pub trait Resolver {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<&str>,\n-        components: &[&str],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -228,7 +228,7 @@ pub fn lower_crate(\n     dep_graph.assert_ignored();\n \n     LoweringContext {\n-        crate_root: std_inject::injected_crate_name(),\n+        crate_root: std_inject::injected_crate_name().map(Symbol::intern),\n         sess,\n         cstore,\n         resolver,\n@@ -1149,7 +1149,7 @@ impl<'a> LoweringContext<'a> {\n             ].into()),\n         );\n         let gen_future = self.expr_std_path(\n-            unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n+            unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n@@ -2548,7 +2548,7 @@ impl<'a> LoweringContext<'a> {\n \n         // ::std::future::Future<future_params>\n         let future_path =\n-            self.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n@@ -4194,7 +4194,7 @@ impl<'a> LoweringContext<'a> {\n                         |x: P<hir::Expr>| x.into_inner(),\n                     );\n                     block.expr = Some(this.wrap_in_try_constructor(\n-                        \"from_ok\", tail, unstable_span));\n+                        sym::from_ok, tail, unstable_span));\n                     hir::ExprKind::Block(P(block), None)\n                 })\n             }\n@@ -4336,7 +4336,7 @@ impl<'a> LoweringContext<'a> {\n                 self.expr_call_std_assoc_fn(\n                     id,\n                     e.span,\n-                    &[\"ops\", \"RangeInclusive\"],\n+                    &[sym::ops, sym::RangeInclusive],\n                     \"new\",\n                     hir_vec![e1, e2],\n                 )\n@@ -4345,11 +4345,11 @@ impl<'a> LoweringContext<'a> {\n                 use syntax::ast::RangeLimits::*;\n \n                 let path = match (e1, e2, lims) {\n-                    (&None, &None, HalfOpen) => \"RangeFull\",\n-                    (&Some(..), &None, HalfOpen) => \"RangeFrom\",\n-                    (&None, &Some(..), HalfOpen) => \"RangeTo\",\n-                    (&Some(..), &Some(..), HalfOpen) => \"Range\",\n-                    (&None, &Some(..), Closed) => \"RangeToInclusive\",\n+                    (&None, &None, HalfOpen) => sym::RangeFull,\n+                    (&Some(..), &None, HalfOpen) => sym::RangeFrom,\n+                    (&None, &Some(..), HalfOpen) => sym::RangeTo,\n+                    (&Some(..), &Some(..), HalfOpen) => sym::Range,\n+                    (&None, &Some(..), Closed) => sym::RangeToInclusive,\n                     (&Some(..), &Some(..), Closed) => unreachable!(),\n                     (_, &None, Closed) => self.diagnostic()\n                         .span_fatal(e.span, \"inclusive range with no end\")\n@@ -4367,7 +4367,7 @@ impl<'a> LoweringContext<'a> {\n                     .collect::<P<[hir::Field]>>();\n \n                 let is_unit = fields.is_empty();\n-                let struct_path = [\"ops\", path];\n+                let struct_path = [sym::ops, path];\n                 let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n@@ -4656,7 +4656,7 @@ impl<'a> LoweringContext<'a> {\n                 let match_expr = {\n                     let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n-                    let next_path = &[\"iter\", \"Iterator\", \"next\"];\n+                    let next_path = &[sym::iter, sym::Iterator, sym::next];\n                     let next_expr = P(self.expr_call_std_path(\n                         head_sp,\n                         next_path,\n@@ -4723,7 +4723,8 @@ impl<'a> LoweringContext<'a> {\n \n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n-                    let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n+                    let into_iter_path =\n+                        &[sym::iter, sym::IntoIterator, sym::into_iter];\n                     P(self.expr_call_std_path(\n                         head_sp,\n                         into_iter_path,\n@@ -4780,7 +4781,7 @@ impl<'a> LoweringContext<'a> {\n                     // expand <expr>\n                     let sub_expr = self.lower_expr(sub_expr);\n \n-                    let path = &[\"ops\", \"Try\", \"into_result\"];\n+                    let path = &[sym::ops, sym::Try, sym::into_result];\n                     P(self.expr_call_std_path(\n                         unstable_span,\n                         path,\n@@ -4822,12 +4823,12 @@ impl<'a> LoweringContext<'a> {\n                     let err_ident = self.str_to_ident(\"err\");\n                     let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n                     let from_expr = {\n-                        let from_path = &[\"convert\", \"From\", \"from\"];\n+                        let from_path = &[sym::convert, sym::From, sym::from];\n                         let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n                         self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n                     };\n                     let from_err_expr =\n-                        self.wrap_in_try_constructor(\"from_error\", from_expr, unstable_span);\n+                        self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n                     let thin_attrs = ThinVec::from(attrs);\n                     let catch_scope = self.catch_scopes.last().map(|x| *x);\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n@@ -5057,7 +5058,7 @@ impl<'a> LoweringContext<'a> {\n     fn expr_call_std_path(\n         &mut self,\n         span: Span,\n-        path_components: &[&str],\n+        path_components: &[Symbol],\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::Expr {\n         let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n@@ -5077,7 +5078,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         ty_path_id: hir::HirId,\n         span: Span,\n-        ty_path_components: &[&str],\n+        ty_path_components: &[Symbol],\n         assoc_fn_name: &str,\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::ExprKind {\n@@ -5119,7 +5120,7 @@ impl<'a> LoweringContext<'a> {\n     fn expr_std_path(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n@@ -5250,25 +5251,25 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"result\", \"Result\", \"Err\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"option\", \"Option\", \"Some\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"option\", \"Option\", \"None\"], hir_vec![])\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], hir_vec![])\n     }\n \n     fn pat_std_enum(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         subpats: hir::HirVec<P<hir::Pat>>,\n     ) -> P<hir::Pat> {\n         let path = self.std_path(span, components, None, true);\n@@ -5321,7 +5322,7 @@ impl<'a> LoweringContext<'a> {\n     fn std_path(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n@@ -5520,11 +5521,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn wrap_in_try_constructor(\n         &mut self,\n-        method: &'static str,\n+        method: Symbol,\n         e: hir::Expr,\n         unstable_span: Span,\n     ) -> P<hir::Expr> {\n-        let path = &[\"ops\", \"Try\", method];\n+        let path = &[sym::ops, sym::Try, method];\n         let from_err = P(self.expr_std_path(unstable_span, path, None,\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n@@ -5594,15 +5595,15 @@ impl<'a> LoweringContext<'a> {\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n                 span,\n-                &[\"pin\", \"Pin\"],\n+                &[sym::pin, sym::Pin],\n                 \"new_unchecked\",\n                 hir_vec![ref_mut_pinned],\n             );\n             let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n             let unsafe_expr = self.expr_unsafe(new_unchecked);\n             P(self.expr_call_std_path(\n                 gen_future_span,\n-                &[\"future\", \"poll_with_tls_context\"],\n+                &[sym::future, sym::poll_with_tls_context],\n                 hir_vec![unsafe_expr],\n             ))\n         };\n@@ -5616,7 +5617,7 @@ impl<'a> LoweringContext<'a> {\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum(\n                 span,\n-                &[\"task\", \"Poll\", \"Ready\"],\n+                &[sym::task, sym::Poll, sym::Ready],\n                 hir_vec![x_pat],\n             );\n             let break_x = self.with_loop_scope(loop_node_id, |this| {\n@@ -5633,7 +5634,7 @@ impl<'a> LoweringContext<'a> {\n         let pending_arm = {\n             let pending_pat = self.pat_std_enum(\n                 span,\n-                &[\"task\", \"Poll\", \"Pending\"],\n+                &[sym::task, sym::Poll, sym::Pending],\n                 hir_vec![],\n             );\n             let empty_block = P(self.expr_block_empty(span));"}, {"sha": "b8ee98551a20e758f4b025f7fc54167a87bd2309", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -1146,7 +1146,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if mod_name != &**part {\n+            if mod_name.as_str() != *part {\n                 return false;\n             }\n             cursor = self.map.get_parent_item(mod_id);\n@@ -1183,7 +1183,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: HirId, name: Name) -> bool {\n-        name == &**self.item_name && self.suffix_matches(parent_of_n)\n+        name.as_str() == *self.item_name && self.suffix_matches(parent_of_n)\n     }\n \n     fn matches_suffix(&self, hir: HirId) -> bool {"}, {"sha": "6481f9af00b86edce9a63fed39f77d88aabdd977", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                 match item.node {\n                     ast::MetaItemKind::Word => {}  // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n-                        if item.path == \"reason\" {\n+                        if item.path == sym::reason {\n                             // found reason, reslice meta list to exclude it\n                             metas = &metas[0..metas.len()-1];\n                             // FIXME (#55112): issue unused-attributes lint if we thereby\n@@ -261,7 +261,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let mut err = bad_attr(li.span());\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.node {\n-                                if item.path == \"reason\" {\n+                                if item.path == sym::reason {\n                                     err.help(\"reason in lint attribute must come last\");\n                                 }\n                             }"}, {"sha": "67db2ec2481566e512869beff6b1c6e48dee2b03", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -86,7 +86,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name == sym::main {\n                 if at_root {\n                     // This is a top-level function so can be 'main'.\n                     EntryPointType::MainNamed"}, {"sha": "8696e2af8c2bcf52edacb703c9d76f9a34c2e7c6", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                     // This additional check for stability is to make sure we\n                     // don't emit additional, irrelevant errors for malformed\n                     // attributes.\n-                    if *stab_attr != \"stable\" || since.is_some() {\n+                    if *stab_attr != sym::stable || since.is_some() {\n                         return Some((feature, since, attr.span));\n                     }\n                 }"}, {"sha": "d9a44714d7d084841266f74de8d7d6669554dec7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -686,7 +686,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n-                if feature == \"rustc_private\" && issue == 27812 {\n+                if feature == sym::rustc_private && issue == 27812 {\n                     if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n                         return EvalResult::Allow;\n                     }"}, {"sha": "75c21c738f7a07ae9e0da2de1d5ffcfa77c7d92f", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -6,7 +6,7 @@ use crate::middle::lang_items;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::PanicStrategy;\n use syntax::ast;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -46,8 +46,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == stringify!($name) {\n-            Some(Symbol::intern(stringify!($sym)))\n+        $(if name == sym::$name {\n+            Some(sym::$sym)\n         } else)* {\n             None\n         }"}, {"sha": "f61ffac15d5f92acfa78a13f4c98bf69c054f26a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -2753,6 +2753,7 @@ mod tests {\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n+        use syntax::symbol::sym;\n         syntax::with_globals(|| {\n             let matches = &match optgroups().parse(&[\"--test\".to_string(),\n                                                      \"--cfg=test\".to_string()]) {\n@@ -2763,7 +2764,7 @@ mod tests {\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n             let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n+            let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n             assert!(test_items.next().is_some());\n             assert!(test_items.next().is_none());\n         });"}, {"sha": "f05a19372918edd3e1b062d59fbefd20730af8d8", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -19,6 +19,7 @@ use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n+use syntax::symbol::sym;\n use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n@@ -1318,9 +1319,9 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n                                             gen_sig)\n         .map_bound(|(trait_ref, yield_ty, return_ty)| {\n             let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n-            let ty = if name == \"Return\" {\n+            let ty = if name == sym::Return {\n                 return_ty\n-            } else if name == \"Yield\" {\n+            } else if name == sym::Yield {\n                 yield_ty\n             } else {\n                 bug!()"}, {"sha": "6320d8a671ddbfd66f87de8060b86e9641839956", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -386,7 +386,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let subsystem = attr::first_attr_value_str_by_name(&tcx.hir().krate().attrs,\n                                                        sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n+        if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n                                      `windows` and `console` are allowed\",\n                                     subsystem));"}, {"sha": "a2ac64fa7e0c659501ed309b202d20e9326b0561", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -56,7 +56,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, name)) = attr_crate_name {\n-                if name != &**s {\n+                if name.as_str() != *s {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);"}, {"sha": "02f8eee67b15118ffed36a9b0b19f79054a286f7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -63,6 +63,7 @@ use syntax::ast;\n use syntax::source_map::FileLoader;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n pub mod pretty;\n@@ -669,7 +670,7 @@ impl RustcDefaultCalls {\n                         // through to build scripts.\n                         let value = value.as_ref().map(|s| s.as_str());\n                         let value = value.as_ref().map(|s| s.as_ref());\n-                        if name != \"target_feature\" || value != Some(\"crt-static\") {\n+                        if name != sym::target_feature || value != Some(\"crt-static\") {\n                             if !allow_unstable_cfg && gated_cfg.is_some() {\n                                 return None\n                             }"}, {"sha": "d2d0d19180783bfd5b8fc557553514bbf0fb6731", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -497,22 +497,22 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n         .filter_map(|a| {\n             if a.check_name(sym::crate_type) {\n                 match a.value_str() {\n-                    Some(ref n) if *n == \"rlib\" => Some(config::CrateType::Rlib),\n-                    Some(ref n) if *n == \"dylib\" => Some(config::CrateType::Dylib),\n-                    Some(ref n) if *n == \"cdylib\" => Some(config::CrateType::Cdylib),\n-                    Some(ref n) if *n == \"lib\" => Some(config::default_lib_output()),\n-                    Some(ref n) if *n == \"staticlib\" => Some(config::CrateType::Staticlib),\n-                    Some(ref n) if *n == \"proc-macro\" => Some(config::CrateType::ProcMacro),\n-                    Some(ref n) if *n == \"bin\" => Some(config::CrateType::Executable),\n-                    Some(ref n) => {\n+                    Some(sym::rlib) => Some(config::CrateType::Rlib),\n+                    Some(sym::dylib) => Some(config::CrateType::Dylib),\n+                    Some(sym::cdylib) => Some(config::CrateType::Cdylib),\n+                    Some(sym::lib) => Some(config::default_lib_output()),\n+                    Some(sym::staticlib) => Some(config::CrateType::Staticlib),\n+                    Some(sym::proc_dash_macro) => Some(config::CrateType::ProcMacro),\n+                    Some(sym::bin) => Some(config::CrateType::Executable),\n+                    Some(n) => {\n                         let crate_types = vec![\n-                            Symbol::intern(\"rlib\"),\n-                            Symbol::intern(\"dylib\"),\n-                            Symbol::intern(\"cdylib\"),\n-                            Symbol::intern(\"lib\"),\n-                            Symbol::intern(\"staticlib\"),\n-                            Symbol::intern(\"proc-macro\"),\n-                            Symbol::intern(\"bin\")\n+                            sym::rlib,\n+                            sym::dylib,\n+                            sym::cdylib,\n+                            sym::lib,\n+                            sym::staticlib,\n+                            sym::proc_dash_macro,\n+                            sym::bin\n                         ];\n \n                         if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {"}, {"sha": "b7b17a84aa768fb0d2cff83f122f97c59dabb849", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -837,7 +837,7 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.name == \"std\" {\n+                if data.name == sym::std {\n                     uses_std = true;\n                 }\n             });"}, {"sha": "087256a971056ba410d58fdf9fe7b357e277ae55", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -31,7 +31,7 @@ use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -432,7 +432,7 @@ impl cstore::CStore {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n-        } else if data.name == \"proc_macro\" && data.item_name(id.index) == \"quote\" {\n+        } else if data.name == sym::proc_macro && data.item_name(id.index) == \"quote\" {\n             use syntax::ext::base::SyntaxExtension;\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n "}, {"sha": "f4682465a659ae32bbaaba0dc4799ab9b6f5f3fa", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -11,7 +11,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().attrs.iter() {\n-        if attr.path == \"link_args\" {\n+        if attr.path == sym::link_args {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(&linkarg.as_str());\n             }"}, {"sha": "7d7dd1061a959db19aa1b8571db02167691c78a2", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -225,7 +225,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use rustc_target::spec::{Target, TargetTriple};\n@@ -408,7 +408,7 @@ impl<'a> Context<'a> {\n                                            self.ident,\n                                            add);\n \n-            if (self.ident == \"std\" || self.ident == \"core\")\n+            if (self.ident == sym::std || self.ident == sym::core)\n                 && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }"}, {"sha": "fee08f421549dc9811954d6af4ec85d84a282744", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                 let any_duplicate = self.libs\n                     .iter()\n                     .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| n == name);\n+                    .any(|n| n.as_str() == *name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.err(\n                         &format!(\"an empty renaming target was specified for library `{}`\",name));\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n             // can move them to the end of the list below.\n             let mut existing = self.libs.drain_filter(|lib| {\n                 if let Some(lib_name) = lib.name {\n-                    if lib_name == name as &str {\n+                    if lib_name.as_str() == *name {\n                         if let Some(k) = kind {\n                             lib.kind = k;\n                         }"}, {"sha": "c2d1d5fa65af299b242b708009a9d0f0878499c8", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -7,7 +7,7 @@ use rustc::util::nodemap::FxHashMap;\n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n use syntax::ext::hygiene;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -86,7 +86,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n-        if name == \"macro_rules\" {\n+        if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {"}, {"sha": "f70ca6f859b98b71a41ae308681d300f273079a6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -369,7 +369,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.populate_module_if_necessary(module);\n-                if injected_crate_name().map_or(false, |name| ident.name == name) {\n+                if injected_crate_name().map_or(false, |name| ident.name.as_str() == name) {\n                     self.injected_crate = Some(module);\n                 }\n "}, {"sha": "678f4c23d3e9ebf8e6ca9622df91b0d6d957774a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -1812,8 +1812,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<&str>,\n-        components: &[&str],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         is_value: bool\n     ) -> hir::Path {\n         let root = if crate_root.is_some() {\n@@ -1825,7 +1825,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Ident::from_str)\n+                    .map(Ident::with_empty_ctxt)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n "}, {"sha": "9f3e1c308f6379e9c591b7530381098459057b0a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -982,7 +982,7 @@ impl<'a> Resolver<'a> {\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n                     let mut err = self.session.struct_span_err(ident.span, &msg);\n-                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, ident.span);\n+                    self.suggest_macro_name(ident.name, kind, &mut err, ident.span);\n                     err.emit();\n                 }\n             }\n@@ -1010,11 +1010,12 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n+    fn suggest_macro_name(&mut self, name: Symbol, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(self.macro_names.iter().map(|ident| &ident.name), name, None)\n+            find_best_match_for_name(\n+                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n         } else {\n             None\n         // Then check global macros.\n@@ -1023,7 +1024,7 @@ impl<'a> Resolver<'a> {\n                                                   .filter_map(|(name, binding)| {\n                 if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n             });\n-            find_best_match_for_name(names, name, None)\n+            find_best_match_for_name(names, &name.as_str(), None)\n         // Then check modules.\n         }).or_else(|| {\n             let is_macro = |res| {\n@@ -1033,7 +1034,7 @@ impl<'a> Resolver<'a> {\n                     false\n                 }\n             };\n-            let ident = Ident::new(Symbol::intern(name), span);\n+            let ident = Ident::new(name, span);\n             self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n                 .map(|suggestion| suggestion.candidate)\n         });\n@@ -1092,7 +1093,7 @@ impl<'a> Resolver<'a> {\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n-        if ident.name == \"macro_rules\" {\n+        if ident.name == sym::macro_rules {\n             self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n "}, {"sha": "4058f0bce0f9544e1eceb207a647b102a080d932", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -496,7 +496,8 @@ impl<'a> Resolver<'a> {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n         if ns == MacroNS &&\n-           (ident.name == \"cfg\" || ident.name == \"cfg_attr\" || ident.name == \"derive\") {\n+           (ident.name == sym::cfg || ident.name == sym::cfg_attr ||\n+            ident.name == sym::derive) {\n             self.session.span_err(ident.span,\n                                   &format!(\"name `{}` is reserved in macro namespace\", ident));\n         }\n@@ -706,7 +707,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 has_errors = true;\n \n                 if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n-                    if source.name == \"self\" {\n+                    if source.name == keywords::SelfLower.name() {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n                             continue;\n@@ -1041,7 +1042,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {\n-                            if target.name == \"_\" &&\n+                            // Note that as_str() de-gensyms the Symbol\n+                            if target.name.as_str() == \"_\" &&\n                                initial_binding.is_extern_crate() && !initial_binding.is_import() {\n                                 this.record_use(ident, ns, target_binding,\n                                                 directive.module_path.is_empty());\n@@ -1392,7 +1394,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // (e.g. implicitly injected `std`) cannot be properly encoded in metadata,\n             // so they can cause name conflict errors downstream.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n-                                 !(ident.name.is_gensymed() && ident.name != \"_\");\n+                                 // Note that as_str() de-gensyms the Symbol\n+                                 !(ident.name.is_gensymed() && ident.name.as_str() != \"_\");\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "e03da2ed608be02f02d3137dd1d9af17412ac6bb", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -1197,7 +1197,7 @@ fn null_id() -> rls_data::Id {\n fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls_data::Attribute> {\n     attrs.into_iter()\n     // Only retain real attributes. Doc comments are lowered separately.\n-    .filter(|attr| attr.path != \"doc\")\n+    .filter(|attr| attr.path != sym::doc)\n     .map(|mut attr| {\n         // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n         // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "362b6f0504d99aed306f7bba354acad944a04182", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -4197,7 +4197,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n                         if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n+                            if path.segments.len() == 1 &&\n+                               path.segments[0].ident.name == sym::rust {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n                         }"}, {"sha": "ffba9403743a311fc9a45c7b8c1a6217b45bd062", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -2594,7 +2594,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n     }\n \n     codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != \"inline\" {\n+        if attr.path != sym::inline {\n             return ia;\n         }\n         match attr.meta().map(|i| i.node) {\n@@ -2634,7 +2634,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n     });\n \n     codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if attr.path != \"optimize\" {\n+        if attr.path != sym::optimize {\n             return ia;\n         }\n         let err = |sp, s| span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s);"}, {"sha": "c795b2dcd7a4385f9ba0ff2afccf292afef6869a", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -7,7 +7,7 @@ use std::mem;\n use std::fmt::{self, Write};\n use std::ops;\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, LitKind};\n use syntax::parse::ParseSess;\n use syntax::feature_gate::Features;\n@@ -186,7 +186,7 @@ impl Cfg {\n \n     fn should_use_with_in_description(&self) -> bool {\n         match *self {\n-            Cfg::Cfg(ref name, _) if name == &\"target_feature\" => true,\n+            Cfg::Cfg(name, _) if name == sym::target_feature => true,\n             _ => false,\n         }\n     }"}, {"sha": "f9a43ccfbace182f71b5e5f9dd824338d17f986a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -4383,7 +4383,7 @@ where\n \n // Start of code copied from rust-clippy\n \n-pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n     let krate = tcx.hir().krate();\n     let mut items = krate.module.item_ids.clone();\n     let mut path_it = path.iter().peekable();\n@@ -4408,7 +4408,7 @@ pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId\n     }\n }\n \n-pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n     let crates = tcx.crates();\n \n     let krate = crates"}, {"sha": "bc87086e1061a0bc1f74a575532db9e5ce476c0e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -368,9 +368,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             };\n \n             let send_trait = if crate_name == Some(\"core\".to_string()) {\n-                clean::path_to_def_local(tcx, &[\"marker\", \"Send\"])\n+                clean::path_to_def_local(tcx, &[sym::marker, sym::Send])\n             } else {\n-                clean::path_to_def(tcx, &[\"core\", \"marker\", \"Send\"])\n+                clean::path_to_def(tcx, &[sym::core, sym::marker, sym::Send])\n             };\n \n             let mut renderinfo = RenderInfo::default();"}, {"sha": "9e108e605c8bba9fc42a9f57cb2a22a519fe911d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // Try looking for methods and associated items.\n             let mut split = path_str.rsplitn(2, \"::\");\n             let item_name = if let Some(first) = split.next() {\n-                first\n+                Symbol::intern(first)\n             } else {\n                 return Err(())\n             };"}, {"sha": "d12240655e6289abf36f3ac437870eb4be5c4458", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -81,12 +81,6 @@ impl PartialEq<Symbol> for Path {\n     }\n }\n \n-impl<'a> PartialEq<&'a str> for Path {\n-    fn eq(&self, string: &&'a str) -> bool {\n-        self.segments.len() == 1 && self.segments[0].ident.name == *string\n-    }\n-}\n-\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"path({})\", pprust::path_to_string(self))"}, {"sha": "43de3f74e4a2ec2e8367e13eaf7d8cfcf9240d11", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -185,12 +185,12 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n \n     'outer: for attr in attrs_iter {\n         if ![\n-            \"rustc_deprecated\",\n-            \"rustc_const_unstable\",\n-            \"unstable\",\n-            \"stable\",\n-            \"rustc_promotable\",\n-            \"rustc_allow_const_fn_ptr\",\n+            sym::rustc_deprecated,\n+            sym::rustc_const_unstable,\n+            sym::unstable,\n+            sym::stable,\n+            sym::rustc_promotable,\n+            sym::rustc_allow_const_fn_ptr,\n         ].iter().any(|&s| attr.path == s) {\n             continue // not a stability level\n         }\n@@ -199,10 +199,10 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n \n         let meta = attr.meta();\n \n-        if attr.path == \"rustc_promotable\" {\n+        if attr.path == sym::rustc_promotable {\n             promotable = true;\n         }\n-        if attr.path == \"rustc_allow_const_fn_ptr\" {\n+        if attr.path == sym::rustc_allow_const_fn_ptr {\n             allow_const_fn_ptr = true;\n         }\n         // attributes with data\n@@ -721,7 +721,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n \n     let mut acc = Vec::new();\n     let diagnostic = &sess.span_diagnostic;\n-    if attr.path == \"repr\" {\n+    if attr.path == sym::repr {\n         if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {\n@@ -770,14 +770,14 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     };\n \n                     let mut literal_error = None;\n-                    if name == \"align\" {\n+                    if name == sym::align {\n                         recognised = true;\n                         match parse_alignment(&value.node) {\n                             Ok(literal) => acc.push(ReprAlign(literal)),\n                             Err(message) => literal_error = Some(message)\n                         };\n                     }\n-                    else if name == \"packed\" {\n+                    else if name == sym::packed {\n                         recognised = true;\n                         match parse_alignment(&value.node) {\n                             Ok(literal) => acc.push(ReprPacked(literal)),"}, {"sha": "0b6cf30bd27d248207397ef3338ae9f62e4faff9", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -19,7 +19,7 @@ pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name == sym::main {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "0a88d2f8824d3f3d34ad908dff6c9ada3a299201", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -10,7 +10,7 @@ use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::{keywords, Ident, Symbol};\n+use crate::symbol::{keywords, Ident, Symbol, sym};\n use crate::ThinVec;\n use crate::tokenstream::{self, TokenStream};\n \n@@ -871,7 +871,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut last_macro = None;\n         loop {\n             if ctxt.outer().expn_info().map_or(None, |info| {\n-                if info.format.name() == \"include\" {\n+                if info.format.name() == sym::include {\n                     // Stop going up the backtrace once include! is encountered\n                     return None;\n                 }"}, {"sha": "a24e09f127eaeef07012848accc355eb46d3951f", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -4,7 +4,7 @@ use crate::source_map::{hygiene, ExpnInfo, ExpnFormat};\n use crate::ext::base::ExtCtxt;\n use crate::ext::build::AstBuilder;\n use crate::parse::parser::PathStyle;\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, sym};\n \n use syntax_pos::Span;\n \n@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashSet;\n pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n-        if attr.path != \"derive\" {\n+        if attr.path != sym::derive {\n             return true;\n         }\n         if !attr.is_meta_item_list() {"}, {"sha": "a286fd83e3c208ff8b5d802e816f188006241e48", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n \n                     let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != \"derive\"));\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n                     let mut item_with_markers = item.clone();\n                     add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n                     let derives = derives.entry(invoc.expansion_data.mark).or_default();\n@@ -1109,15 +1109,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                        -> Option<ast::Attribute> {\n         let attr = attrs.iter()\n                         .position(|a| {\n-                            if a.path == \"derive\" {\n+                            if a.path == sym::derive {\n                                 *after_derive = true;\n                             }\n                             !attr::is_known(a) && !is_builtin_attr(a)\n                         })\n                         .map(|i| attrs.remove(i));\n         if let Some(attr) = &attr {\n             if !self.cx.ecfg.enable_custom_inner_attributes() &&\n-               attr.style == ast::AttrStyle::Inner && attr.path != \"test\" {\n+               attr.style == ast::AttrStyle::Inner && attr.path != sym::test {\n                 emit_feature_err(&self.cx.parse_sess, sym::custom_inner_attributes,\n                                  attr.span, GateIssue::Language,\n                                  \"non-builtin inner attributes are unstable\");\n@@ -1167,7 +1167,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             self.check_attribute_inner(attr, features);\n \n             // macros are expanded before any lint passes so this warning has to be hardcoded\n-            if attr.path == \"derive\" {\n+            if attr.path == sym::derive {\n                 self.cx.struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n                     .note(\"this may become a hard error in a future release\")\n                     .emit();"}, {"sha": "06651750de74198c31ce8f66ea5cd88b3ea85969", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -13,7 +13,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::Parser;\n use crate::parse::token::{self, NtTT};\n use crate::parse::token::Token::*;\n-use crate::symbol::{Symbol, sym};\n+use crate::symbol::{Symbol, keywords, sym};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use errors::FatalError;\n@@ -467,7 +467,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none() && seq.tts.iter().all(|seq_tt| {\n                     match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == \"vis\",\n+                        TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n                         TokenTree::Sequence(_, ref sub_seq) =>\n                             sub_seq.op == quoted::KleeneOp::ZeroOrMore\n                             || sub_seq.op == quoted::KleeneOp::ZeroOrOne,\n@@ -1046,7 +1046,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         FatArrow | Comma | Eq | BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == \"if\" || i.name == \"in\" => IsInFollow::Yes,\n+                        Ident(i, false) if i.name == keywords::If.name() ||\n+                                           i.name == keywords::In.name() => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n                     _ => IsInFollow::No(tokens),\n@@ -1063,10 +1064,12 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                         OpenDelim(token::DelimToken::Bracket) |\n                         Comma | FatArrow | Colon | Eq | Gt | BinOp(token::Shr) | Semi |\n                         BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == \"as\" || i.name == \"where\" => IsInFollow::Yes,\n+                        Ident(i, false) if i.name == keywords::As.name() ||\n+                                           i.name == keywords::Where.name() => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"block\" => IsInFollow::Yes,\n+                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block =>\n+                        IsInFollow::Yes,\n                     _ => IsInFollow::No(tokens),\n                 }\n             },\n@@ -1089,16 +1092,18 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         Comma => IsInFollow::Yes,\n-                        Ident(i, is_raw) if is_raw || i.name != \"priv\" => IsInFollow::Yes,\n+                        Ident(i, is_raw) if is_raw || i.name != keywords::Priv.name() =>\n+                            IsInFollow::Yes,\n                         ref tok => if tok.can_begin_type() {\n                             IsInFollow::Yes\n                         } else {\n                             IsInFollow::No(tokens)\n                         }\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"ident\"\n-                                                       || frag.name == \"ty\"\n-                                                       || frag.name == \"path\" => IsInFollow::Yes,\n+                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::ident\n+                                                       || frag.name == sym::ty\n+                                                       || frag.name == sym::path =>\n+                        IsInFollow::Yes,\n                     _ => IsInFollow::No(tokens),\n                 }\n             },"}, {"sha": "e7740f1835bc5728b84e3119bb2ea3aa45cb3e36", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -22,13 +22,13 @@ use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n use crate::parse::{token, ParseSess};\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, keywords, sym};\n use crate::tokenstream::TokenTree;\n \n use errors::{DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n-use syntax_pos::{Span, DUMMY_SP, sym};\n+use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use lazy_static::lazy_static;\n \n@@ -562,9 +562,9 @@ declare_features! (\n // Some features are known to be incomplete and using them is likely to have\n // unanticipated results, such as compiler crashes. We warn the user about these\n // to alert them.\n-const INCOMPLETE_FEATURES: &[&str] = &[\n-    \"generic_associated_types\",\n-    \"const_generics\"\n+const INCOMPLETE_FEATURES: &[Symbol] = &[\n+    sym::generic_associated_types,\n+    sym::const_generics\n ];\n \n declare_features! (\n@@ -1947,7 +1947,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.node {\n             ast::ItemKind::Const(_,_) => {\n-                if i.ident.name == \"_\" {\n+                if i.ident.name == keywords::Underscore.name() {\n                     gate_feature_post!(&self, underscore_const_names, i.span,\n                                         \"naming constants with `_` is unstable\");\n                 }\n@@ -2304,7 +2304,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         if edition <= crate_edition {\n             // The `crate_edition` implies its respective umbrella feature-gate\n             // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n-            edition_enabled_features.insert(Symbol::intern(edition.feature_name()), edition);\n+            edition_enabled_features.insert(edition.feature_name(), edition);\n         }\n     }\n \n@@ -2335,7 +2335,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             }\n \n             let name = mi.name_or_empty();\n-            if INCOMPLETE_FEATURES.iter().any(|f| name == *f) {\n+            if INCOMPLETE_FEATURES.iter().any(|f| name == f.as_str()) {\n                 span_handler.struct_span_warn(\n                     mi.span(),\n                     &format!(\n@@ -2345,7 +2345,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                 ).emit();\n             }\n \n-            if let Some(edition) = ALL_EDITIONS.iter().find(|e| name == e.feature_name()) {\n+            if let Some(edition) = ALL_EDITIONS.iter().find(|e| name == e.feature_name().as_str()) {\n                 if *edition <= crate_edition {\n                     continue;\n                 }"}, {"sha": "655baafcd2d5da34fb68303152b337efd8cfa064", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -391,6 +391,8 @@ mod tests {\n     #[test]\n     fn string_to_tts_macro () {\n         with_globals(|| {\n+            use crate::symbol::sym;\n+\n             let tts: Vec<_> =\n                 string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n             let tts: &[TokenTree] = &tts[..];\n@@ -403,8 +405,8 @@ mod tests {\n                     Some(&TokenTree::Token(_, token::Ident(name_zip, false))),\n                     Some(&TokenTree::Delimited(_, macro_delim, ref macro_tts)),\n                 )\n-                if name_macro_rules.name == \"macro_rules\"\n-                && name_zip.name == \"zip\" => {\n+                if name_macro_rules.name == sym::macro_rules\n+                && name_zip.name.as_str() == \"zip\" => {\n                     let tts = &macro_tts.trees().collect::<Vec<_>>();\n                     match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                         (\n@@ -421,7 +423,7 @@ mod tests {\n                                     Some(&TokenTree::Token(_, token::Dollar)),\n                                     Some(&TokenTree::Token(_, token::Ident(ident, false))),\n                                 )\n-                                if first_delim == token::Paren && ident.name == \"a\" => {},\n+                                if first_delim == token::Paren && ident.name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n                             let tts = &second_tts.trees().collect::<Vec<_>>();\n@@ -431,7 +433,7 @@ mod tests {\n                                     Some(&TokenTree::Token(_, token::Dollar)),\n                                     Some(&TokenTree::Token(_, token::Ident(ident, false))),\n                                 )\n-                                if second_delim == token::Paren && ident.name == \"a\" => {},\n+                                if second_delim == token::Paren && ident.name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                             }\n                         },\n@@ -584,13 +586,13 @@ mod tests {\n             let item = parse_item_from_source_str(name_1, source, &sess)\n                 .unwrap().unwrap();\n             let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n-            assert_eq!(doc, \"/// doc comment\");\n+            assert_eq!(doc.as_str(), \"/// doc comment\");\n \n             let name_2 = FileName::Custom(\"crlf_source_2\".to_string());\n             let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_2, source, &sess)\n                 .unwrap().unwrap();\n-            let docs = item.attrs.iter().filter(|a| a.path == \"doc\")\n+            let docs = item.attrs.iter().filter(|a| a.path == sym::doc)\n                         .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n             let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n             assert_eq!(&docs[..], b);\n@@ -599,7 +601,7 @@ mod tests {\n             let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_3, source, &sess).unwrap().unwrap();\n             let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n-            assert_eq!(doc, \"/** doc comment\\n *  with CRLF */\");\n+            assert_eq!(doc.as_str(), \"/** doc comment\\n *  with CRLF */\");\n         });\n     }\n "}, {"sha": "c0f3c358e98f5101d976cfcdd74469441248e8e2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -5099,7 +5099,7 @@ impl<'a> Parser<'a> {\n \n                 (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n             }\n-            token::Ident(ident, _) if ident.name == \"macro_rules\" &&\n+            token::Ident(ident, _) if ident.name == sym::macro_rules &&\n                                    self.look_ahead(1, |t| *t == token::Not) => {\n                 let prev_span = self.prev_span;\n                 self.complain_if_pub_macro(&vis.node, prev_span);"}, {"sha": "f08fdcc6fb53cd9a58b898b78a9000a9ece7532b", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -35,6 +35,9 @@ pub fn injected_crate_name() -> Option<&'static str> {\n }\n \n thread_local! {\n+    // A `Symbol` might make more sense here, but it doesn't work, probably for\n+    // reasons relating to the use of thread-local storage for the Symbol\n+    // interner.\n     static INJECTED_CRATE_NAME: Cell<Option<&'static str>> = Cell::new(None);\n }\n "}, {"sha": "21bc236d00e6b805dd62ec546460598d0c90849b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -272,7 +272,8 @@ fn generate_test_harness(sess: &ParseSess,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n         // N.B., doesn't consider the value of `--crate-name` passed on the command line.\n-        is_libtest: attr::find_crate_name(&krate.attrs).map(|s| s == \"test\").unwrap_or(false),\n+        is_libtest: attr::find_crate_name(&krate.attrs)\n+            .map(|s| s == sym::test).unwrap_or(false),\n         toplevel_reexport: None,\n         ctxt: SyntaxContext::empty().apply_mark(mark),\n         features,"}, {"sha": "b8e89c3ecf8762191b77c84cd88ca3416f98a956", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -39,7 +39,7 @@ impl State {\n     }\n }\n \n-const OPTIONS: &[&str] = &[\"volatile\", \"alignstack\", \"intel\"];\n+const OPTIONS: &[Symbol] = &[sym::volatile, sym::alignstack, sym::intel];\n \n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        sp: Span,\n@@ -233,13 +233,13 @@ fn parse_inline_asm<'a>(\n             Options => {\n                 let (option, _) = p.parse_str()?;\n \n-                if option == \"volatile\" {\n+                if option == sym::volatile {\n                     // Indicates that the inline assembly has side effects\n                     // and must not be optimized out along with its outputs.\n                     volatile = true;\n-                } else if option == \"alignstack\" {\n+                } else if option == sym::alignstack {\n                     alignstack = true;\n-                } else if option == \"intel\" {\n+                } else if option == sym::intel {\n                     dialect = AsmDialect::Intel;\n                 } else {\n                     cx.span_warn(p.prev_span, \"unrecognized option\");"}, {"sha": "c27de692d887cc050114ac6d7d4d3ec69410817c", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -6,7 +6,7 @@ use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n macro path_local($x:ident) {\n@@ -139,7 +139,7 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n     let intrinsic_allowed_via_allow_internal_unstable = cx\n         .current_expansion.mark.expn_info().unwrap()\n         .allow_internal_unstable.map_or(false, |features| features.iter().any(|&s|\n-            s == \"core_intrinsics\"\n+            s == sym::core_intrinsics\n         ));\n     if intrinsic_allowed_via_allow_internal_unstable {\n         span = span.with_ctxt(cx.backtrace());"}, {"sha": "00cd00f2837849b10cbe646f4b7fcfc28796fada", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -1,3 +1,4 @@\n+use crate::symbol::{Symbol, sym};\n use std::fmt;\n use std::str::FromStr;\n \n@@ -44,10 +45,10 @@ impl Edition {\n         }\n     }\n \n-    pub fn feature_name(&self) -> &'static str {\n+    pub fn feature_name(&self) -> Symbol {\n         match *self {\n-            Edition::Edition2015 => \"rust_2015_preview\",\n-            Edition::Edition2018 => \"rust_2018_preview\",\n+            Edition::Edition2015 => sym::rust_2015_preview,\n+            Edition::Edition2018 => sym::rust_2018_preview,\n         }\n     }\n "}, {"sha": "39859f25f97fb87b867d3abff651dc808c18d8c1", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -393,7 +393,7 @@ impl Span {\n             Some(info) => info\n                 .allow_internal_unstable\n                 .map_or(false, |features| features.iter().any(|&f|\n-                    f == feature || f == \"allow_internal_unstable_backcompat_hack\"\n+                    f == feature || f == sym::allow_internal_unstable_backcompat_hack\n                 )),\n             None => false,\n         }"}, {"sha": "ec0ce4253fa2d397cef8f1b85795267f090d7e68", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -822,12 +822,6 @@ impl Decodable for Symbol {\n     }\n }\n \n-impl<T: std::ops::Deref<Target=str>> PartialEq<T> for Symbol {\n-    fn eq(&self, other: &T) -> bool {\n-        self.as_str() == other.deref()\n-    }\n-}\n-\n // The `&'static str`s in this type actually point into the arena.\n //\n // Note that normal symbols are indexed upward from 0, and gensyms are indexed"}, {"sha": "0deb1bf091508d01c951f4d61891e7cc2c6f4a3b", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -20,7 +20,7 @@ declare_lint_pass!(Pass => [TEST_LINT]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name == \"lintme\" {\n+        if it.ident.name.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "64664377cd9435c05b6e07336d0c60c64f26e998", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999c1fc2819e34539706b193711735d997633ef1/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999c1fc2819e34539706b193711735d997633ef1/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=999c1fc2819e34539706b193711735d997633ef1", "patch": "@@ -23,10 +23,10 @@ declare_lint_pass!(Pass => [TEST_LINT, TEST_GROUP]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name == \"lintme\" {\n+        if it.ident.name.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n-        if it.ident.name == \"lintmetoo\" {\n+        if it.ident.name.as_str() == \"lintmetoo\" {\n             cx.span_lint(TEST_GROUP, it.span, \"item is named 'lintmetoo'\");\n         }\n     }"}]}