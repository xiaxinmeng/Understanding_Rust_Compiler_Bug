{"sha": "b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYzkxZGZiNmEyZTIxYzgyOTY2ZDBhMTNmOWNkM2U1MWRhOTQ2NTQ=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-23T15:21:15Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-23T15:21:15Z"}, "message": "Merge branch 'master' into redox", "tree": {"sha": "08bb76f6d05c6295b9ee7c3690b78a9ff52c7693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08bb76f6d05c6295b9ee7c3690b78a9ff52c7693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "html_url": "https://github.com/rust-lang/rust/commit/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "html_url": "https://github.com/rust-lang/rust/commit/ae2029fc62d744e252a5a077ce0dfbf2d1683d25"}, {"sha": "9fba8df2115141173ad60837f129f18e74424531", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fba8df2115141173ad60837f129f18e74424531", "html_url": "https://github.com/rust-lang/rust/commit/9fba8df2115141173ad60837f129f18e74424531"}], "stats": {"total": 8136, "additions": 5041, "deletions": 3095}, "files": [{"sha": "5311bf4b064eb8cac4c9054a9df70c8017175b1d", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/configure", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -856,7 +856,7 @@ probe_need CFG_CMAKE cmake\n if [ -n \"$CFG_ANTLR4\" ]\n then\n    CFG_ANTLR4_JAR=\"\\\"$(find /usr/ -name antlr-complete.jar 2>/dev/null | head -n 1)\\\"\"\n-   if [ \"x\" -eq \"x$CFG_ANTLR4_JAR\" ]\n+   if [ \"x\" = \"x$CFG_ANTLR4_JAR\" ]\n    then\n      CFG_ANTLR4_JAR=\"\\\"$(find ~ -name antlr-complete.jar 2>/dev/null | head -n 1)\\\"\"\n    fi"}, {"sha": "140e27d19248ce3a936d5570740b7d537e13338b", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -352,7 +352,7 @@ to it.\n Rust supports powerful local type inference in the bodies of functions but not in their item signatures. \n It's forbidden to allow reasoning about types based on the item signature alone. \n However, for ergonomic reasons, a very restricted secondary inference algorithm called \n-\u201clifetime elision\u201d does apply when judging lifetimes. Lifetime elision is concerned solely to infer \n+\u201clifetime elision\u201d does apply when judging lifetimes. Lifetime elision is concerned solely with inferring \n lifetime parameters using three easily memorizable and unambiguous rules. This means lifetime elision \n acts as a shorthand for writing an item signature, while not hiding\n away the actual types involved as full local inference would if applied to it."}, {"sha": "4fbe518396760dbd66cc32f26edf514cab2ce776", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -2474,18 +2474,19 @@ The currently implemented features of the reference compiler are:\n                               internally without imposing on callers\n                               (i.e. making them behave like function calls in\n                               terms of encapsulation).\n-* - `default_type_parameter_fallback` - Allows type parameter defaults to\n-                                        influence type inference.\n \n-* - `stmt_expr_attributes` - Allows attributes on expressions.\n+* `default_type_parameter_fallback` - Allows type parameter defaults to\n+                                      influence type inference.\n \n-* - `type_ascription` - Allows type ascription expressions `expr: Type`.\n+* `stmt_expr_attributes` - Allows attributes on expressions.\n \n-* - `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n-                             (e.g. `extern \"vectorcall\" func fn_();`)\n+* `type_ascription` - Allows type ascription expressions `expr: Type`.\n \n-* - `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n-                             (e.g. `extern \"sysv64\" func fn_();`)\n+* `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n+                     (e.g. `extern \"vectorcall\" func fn_();`)\n+\n+* `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n+                 (e.g. `extern \"sysv64\" func fn_();`)\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled"}, {"sha": "9d15f98e06709eaadf5d61d4ef235bc1e65f1b0c", "filename": "src/etc/char_private.py", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Fetc%2Fchar_private.py", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Fetc%2Fchar_private.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fchar_private.py?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,11 +11,16 @@\n # except according to those terms.\n \n # This script uses the following Unicode tables:\n-# - Categories.txt\n+# - UnicodeData.txt\n \n+\n+from collections import namedtuple\n+import csv\n import os\n import subprocess\n \n+NUM_CODEPOINTS=0x110000\n+\n def to_ranges(iter):\n     current = None\n     for i in iter:\n@@ -28,10 +33,10 @@ def to_ranges(iter):\n     if current is not None:\n         yield tuple(current)\n \n-def get_escaped(dictionary):\n-    for i in range(0x110000):\n-        if dictionary.get(i, \"Cn\") in \"Cc Cf Cs Co Cn Zl Zp Zs\".split() and i != ord(' '):\n-            yield i\n+def get_escaped(codepoints):\n+    for c in codepoints:\n+        if (c.class_ or \"Cn\") in \"Cc Cf Cs Co Cn Zl Zp Zs\".split() and c.value != ord(' '):\n+            yield c.value\n \n def get_file(f):\n     try:\n@@ -40,10 +45,41 @@ def get_file(f):\n         subprocess.run([\"curl\", \"-O\", f], check=True)\n         return open(os.path.basename(f))\n \n+Codepoint = namedtuple('Codepoint', 'value class_')\n+\n+def get_codepoints(f):\n+    r = csv.reader(f, delimiter=\";\")\n+    prev_codepoint = 0\n+    class_first = None\n+    for row in r:\n+        codepoint = int(row[0], 16)\n+        name = row[1]\n+        class_ = row[2]\n+\n+        if class_first is not None:\n+            if not name.endswith(\"Last>\"):\n+                raise ValueError(\"Missing Last after First\")\n+\n+        for c in range(prev_codepoint + 1, codepoint):\n+            yield Codepoint(c, class_first)\n+\n+        class_first = None\n+        if name.endswith(\"First>\"):\n+            class_first = class_\n+\n+        yield Codepoint(codepoint, class_)\n+        prev_codepoint = codepoint\n+\n+    if class_first != None:\n+        raise ValueError(\"Missing Last after First\")\n+\n+    for c in range(prev_codepoint + 1, NUM_CODEPOINTS):\n+        yield Codepoint(c, None)\n+\n def main():\n-    file = get_file(\"http://www.unicode.org/notes/tn36/Categories.txt\")\n+    file = get_file(\"http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\")\n \n-    dictionary = {int(line.split()[0], 16): line.split()[1] for line in file}\n+    codepoints = get_codepoints(file)\n \n     CUTOFF=0x10000\n     singletons0 = []\n@@ -52,7 +88,7 @@ def main():\n     normal1 = []\n     extra = []\n \n-    for a, b in to_ranges(get_escaped(dictionary)):\n+    for a, b in to_ranges(get_escaped(codepoints)):\n         if a > 2 * CUTOFF:\n             extra.append((a, b - a))\n         elif a == b - 1:"}, {"sha": "14a0819d381bc0033ae8a320188248021a2fd380", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -767,6 +767,7 @@ fn test_iterator() {\n         pos += 1;\n     }\n     assert_eq!(pos, v.len());\n+    assert_eq!(s.chars().count(), v.len());\n }\n \n #[test]\n@@ -814,6 +815,14 @@ fn test_iterator_clone() {\n     assert!(it.clone().zip(it).all(|(x,y)| x == y));\n }\n \n+#[test]\n+fn test_iterator_last() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let mut it = s.chars();\n+    it.next();\n+    assert_eq!(it.last(), Some('m'));\n+}\n+\n #[test]\n fn test_bytesator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -911,6 +920,14 @@ fn test_char_indices_revator() {\n     assert_eq!(pos, p.len());\n }\n \n+#[test]\n+fn test_char_indices_last() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let mut it = s.char_indices();\n+    it.next();\n+    assert_eq!(it.last(), Some((27, 'm')));\n+}\n+\n #[test]\n fn test_splitn_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "ddc473592a26026035edd0c0f15705e30f0a3dd0", "filename": "src/libcore/char_private.rs", "status": "modified", "additions": 230, "deletions": 97, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcore%2Fchar_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcore%2Fchar_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar_private.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,6 +11,8 @@\n // NOTE: The following code was generated by \"src/etc/char_private.py\",\n //       do not edit directly!\n \n+use slice::SliceExt;\n+\n fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n     for &s in singletons {\n         if x == s {\n@@ -42,7 +44,16 @@ pub fn is_printable(x: char) -> bool {\n     } else if x < 0x20000 {\n         check(lower, SINGLETONS1, NORMAL1)\n     } else {\n-        if 0x20000 <= x && x < 0x2f800 {\n+        if 0x2a6d7 <= x && x < 0x2a700 {\n+            return false;\n+        }\n+        if 0x2b735 <= x && x < 0x2b740 {\n+            return false;\n+        }\n+        if 0x2b81e <= x && x < 0x2b820 {\n+            return false;\n+        }\n+        if 0x2cea2 <= x && x < 0x2f800 {\n             return false;\n         }\n         if 0x2fa1e <= x && x < 0xe0100 {\n@@ -62,10 +73,13 @@ const SINGLETONS0: &'static [u16] = &[\n     0x38b,\n     0x38d,\n     0x3a2,\n+    0x530,\n     0x557,\n     0x558,\n     0x560,\n     0x588,\n+    0x58b,\n+    0x58c,\n     0x590,\n     0x61c,\n     0x61d,\n@@ -79,10 +93,8 @@ const SINGLETONS0: &'static [u16] = &[\n     0x83f,\n     0x85c,\n     0x85d,\n-    0x8a1,\n-    0x8ff,\n-    0x978,\n-    0x980,\n+    0x8b5,\n+    0x8e2,\n     0x984,\n     0x98d,\n     0x98e,\n@@ -154,14 +166,11 @@ const SINGLETONS0: &'static [u16] = &[\n     0xc0d,\n     0xc11,\n     0xc29,\n-    0xc34,\n     0xc45,\n     0xc49,\n     0xc57,\n     0xc64,\n     0xc65,\n-    0xc80,\n-    0xc81,\n     0xc84,\n     0xc8d,\n     0xc91,\n@@ -193,6 +202,8 @@ const SINGLETONS0: &'static [u16] = &[\n     0xdbf,\n     0xdd5,\n     0xdd7,\n+    0xdf0,\n+    0xdf1,\n     0xe83,\n     0xe85,\n     0xe86,\n@@ -245,6 +256,10 @@ const SINGLETONS0: &'static [u16] = &[\n     0x1317,\n     0x135b,\n     0x135c,\n+    0x13f6,\n+    0x13f7,\n+    0x13fe,\n+    0x13ff,\n     0x1680,\n     0x170d,\n     0x176d,\n@@ -253,13 +268,17 @@ const SINGLETONS0: &'static [u16] = &[\n     0x17df,\n     0x180e,\n     0x180f,\n+    0x191f,\n     0x196e,\n     0x196f,\n     0x1a1c,\n     0x1a1d,\n     0x1a5f,\n     0x1a7d,\n     0x1a7e,\n+    0x1aae,\n+    0x1aaf,\n+    0x1cf7,\n     0x1f16,\n     0x1f17,\n     0x1f1e,\n@@ -285,7 +304,12 @@ const SINGLETONS0: &'static [u16] = &[\n     0x2072,\n     0x2073,\n     0x208f,\n-    0x2700,\n+    0x23ff,\n+    0x2b74,\n+    0x2b75,\n+    0x2b96,\n+    0x2b97,\n+    0x2bc9,\n     0x2c2f,\n     0x2c5f,\n     0x2d26,\n@@ -306,8 +330,11 @@ const SINGLETONS0: &'static [u16] = &[\n     0x318f,\n     0x321f,\n     0x32ff,\n-    0xa78f,\n+    0xa7af,\n+    0xa8fe,\n+    0xa8ff,\n     0xa9ce,\n+    0xa9ff,\n     0xaa4e,\n     0xaa4f,\n     0xaa5a,\n@@ -317,6 +344,7 @@ const SINGLETONS0: &'static [u16] = &[\n     0xab0f,\n     0xab10,\n     0xab27,\n+    0xab2f,\n     0xabee,\n     0xabef,\n     0xfa6e,\n@@ -350,7 +378,7 @@ const SINGLETONS1: &'static [u16] = &[\n     0x3e,\n     0x4e,\n     0x4f,\n-    0x31f,\n+    0x18f,\n     0x39e,\n     0x49e,\n     0x49f,\n@@ -361,13 +389,59 @@ const SINGLETONS1: &'static [u16] = &[\n     0x83d,\n     0x83e,\n     0x856,\n+    0x8f3,\n+    0x9d0,\n+    0x9d1,\n     0xa04,\n     0xa14,\n     0xa18,\n     0xb56,\n     0xb57,\n     0x10bd,\n     0x1135,\n+    0x11ce,\n+    0x11cf,\n+    0x11e0,\n+    0x1212,\n+    0x1287,\n+    0x1289,\n+    0x128e,\n+    0x129e,\n+    0x1304,\n+    0x130d,\n+    0x130e,\n+    0x1311,\n+    0x1312,\n+    0x1329,\n+    0x1331,\n+    0x1334,\n+    0x133a,\n+    0x133b,\n+    0x1345,\n+    0x1346,\n+    0x1349,\n+    0x134a,\n+    0x134e,\n+    0x134f,\n+    0x1364,\n+    0x1365,\n+    0x145a,\n+    0x145c,\n+    0x15b6,\n+    0x15b7,\n+    0x1c09,\n+    0x1c37,\n+    0x1c90,\n+    0x1c91,\n+    0x1ca8,\n+    0x246f,\n+    0x6a5f,\n+    0x6aee,\n+    0x6aef,\n+    0x6b5a,\n+    0x6b62,\n+    0xbc9a,\n+    0xbc9b,\n     0xd127,\n     0xd128,\n     0xd455,\n@@ -395,6 +469,14 @@ const SINGLETONS1: &'static [u16] = &[\n     0xd6a7,\n     0xd7cc,\n     0xd7cd,\n+    0xdaa0,\n+    0xe007,\n+    0xe019,\n+    0xe01a,\n+    0xe022,\n+    0xe025,\n+    0xe8c5,\n+    0xe8c6,\n     0xee04,\n     0xee20,\n     0xee23,\n@@ -429,31 +511,25 @@ const SINGLETONS1: &'static [u16] = &[\n     0xeeaa,\n     0xf0af,\n     0xf0b0,\n-    0xf0bf,\n     0xf0c0,\n     0xf0d0,\n     0xf12f,\n-    0xf336,\n-    0xf3c5,\n-    0xf43f,\n-    0xf441,\n-    0xf4f8,\n-    0xf53e,\n-    0xf53f,\n+    0xf91f,\n+    0xf931,\n+    0xf932,\n+    0xf93f,\n ];\n const NORMAL0: &'static [u16] = &[\n     0x0, 0x20,\n     0x7f, 0x22,\n-    0x37f, 0x5,\n-    0x528, 0x9,\n-    0x58b, 0x4,\n+    0x380, 0x4,\n     0x5c8, 0x8,\n     0x5eb, 0x5,\n     0x5f5, 0x11,\n     0x7b2, 0xe,\n     0x7fb, 0x5,\n     0x85f, 0x41,\n-    0x8ad, 0x37,\n+    0x8be, 0x16,\n     0x9b3, 0x3,\n     0x9cf, 0x8,\n     0x9d8, 0x4,\n@@ -465,7 +541,8 @@ const NORMAL0: &'static [u16] = &[\n     0xa5f, 0x7,\n     0xa76, 0xb,\n     0xad1, 0xf,\n-    0xaf2, 0xf,\n+    0xaf2, 0x7,\n+    0xafa, 0x7,\n     0xb4e, 0x8,\n     0xb58, 0x4,\n     0xb78, 0xa,\n@@ -478,21 +555,19 @@ const NORMAL0: &'static [u16] = &[\n     0xbc3, 0x3,\n     0xbd1, 0x6,\n     0xbd8, 0xe,\n-    0xbfb, 0x6,\n+    0xbfb, 0x5,\n     0xc3a, 0x3,\n     0xc4e, 0x7,\n-    0xc5a, 0x6,\n+    0xc5b, 0x5,\n     0xc70, 0x8,\n     0xcce, 0x7,\n     0xcd7, 0x7,\n-    0xcf3, 0xf,\n-    0xd4f, 0x8,\n-    0xd58, 0x8,\n-    0xd76, 0x3,\n+    0xcf3, 0xe,\n+    0xd50, 0x4,\n     0xd97, 0x3,\n     0xdc7, 0x3,\n     0xdcb, 0x4,\n-    0xde0, 0x12,\n+    0xde0, 0x6,\n     0xdf5, 0xc,\n     0xe3b, 0x4,\n     0xe5c, 0x25,\n@@ -503,9 +578,8 @@ const NORMAL0: &'static [u16] = &[\n     0x10c8, 0x5,\n     0x137d, 0x3,\n     0x139a, 0x6,\n-    0x13f5, 0xb,\n     0x169d, 0x3,\n-    0x16f1, 0xf,\n+    0x16f9, 0x7,\n     0x1715, 0xb,\n     0x1737, 0x9,\n     0x1754, 0xc,\n@@ -516,7 +590,6 @@ const NORMAL0: &'static [u16] = &[\n     0x1878, 0x8,\n     0x18ab, 0x5,\n     0x18f6, 0xa,\n-    0x191d, 0x3,\n     0x192c, 0x4,\n     0x193c, 0x4,\n     0x1941, 0x3,\n@@ -526,67 +599,63 @@ const NORMAL0: &'static [u16] = &[\n     0x19db, 0x3,\n     0x1a8a, 0x6,\n     0x1a9a, 0x6,\n-    0x1aae, 0x52,\n+    0x1abf, 0x41,\n     0x1b4c, 0x4,\n     0x1b7d, 0x3,\n     0x1bf4, 0x8,\n     0x1c38, 0x3,\n     0x1c4a, 0x3,\n-    0x1c80, 0x40,\n+    0x1c89, 0x37,\n     0x1cc8, 0x8,\n-    0x1cf7, 0x9,\n-    0x1de7, 0x15,\n+    0x1cfa, 0x6,\n+    0x1df6, 0x5,\n     0x1fff, 0x11,\n     0x2028, 0x8,\n     0x205f, 0x11,\n     0x209d, 0x3,\n-    0x20ba, 0x16,\n+    0x20bf, 0x11,\n     0x20f1, 0xf,\n-    0x218a, 0x6,\n-    0x23f4, 0xc,\n+    0x218c, 0x4,\n     0x2427, 0x19,\n     0x244b, 0x15,\n-    0x2b4d, 0x3,\n-    0x2b5a, 0xa6,\n+    0x2bba, 0x3,\n+    0x2bd2, 0x1a,\n+    0x2bf0, 0x10,\n     0x2cf4, 0x5,\n     0x2d28, 0x5,\n     0x2d68, 0x7,\n     0x2d71, 0xe,\n     0x2d97, 0x9,\n-    0x2e3c, 0x44,\n+    0x2e45, 0x3b,\n     0x2ef4, 0xc,\n     0x2fd6, 0x1a,\n     0x2ffc, 0x5,\n     0x3100, 0x5,\n     0x312e, 0x3,\n     0x31bb, 0x5,\n     0x31e4, 0xc,\n-    0x3400, 0x19c0,\n-    0x4e00, 0x5200,\n+    0x4db6, 0xa,\n+    0x9fd6, 0x2a,\n     0xa48d, 0x3,\n     0xa4c7, 0x9,\n     0xa62c, 0x14,\n-    0xa698, 0x7,\n     0xa6f8, 0x8,\n-    0xa794, 0xc,\n-    0xa7ab, 0x4d,\n+    0xa7b8, 0x3f,\n     0xa82c, 0x4,\n     0xa83a, 0x6,\n     0xa878, 0x8,\n-    0xa8c5, 0x9,\n+    0xa8c6, 0x8,\n     0xa8da, 0x6,\n-    0xa8fc, 0x4,\n     0xa954, 0xb,\n     0xa97d, 0x3,\n     0xa9da, 0x4,\n-    0xa9e0, 0x20,\n     0xaa37, 0x9,\n-    0xaa7c, 0x4,\n     0xaac3, 0x18,\n     0xaaf7, 0xa,\n     0xab17, 0x9,\n-    0xab2f, 0x91,\n-    0xabfa, 0x2bb6,\n+    0xab66, 0xa,\n+    0xabfa, 0x6,\n+    0xd7a4, 0xc,\n     0xd7c7, 0x4,\n     0xd7fc, 0x2104,\n     0xfada, 0x26,\n@@ -596,7 +665,6 @@ const NORMAL0: &'static [u16] = &[\n     0xfd40, 0x10,\n     0xfdc8, 0x28,\n     0xfe1a, 0x6,\n-    0xfe27, 0x9,\n     0xfe6c, 0x4,\n     0xfefd, 0x4,\n     0xffbf, 0x3,\n@@ -608,86 +676,151 @@ const NORMAL1: &'static [u16] = &[\n     0xfb, 0x5,\n     0x103, 0x4,\n     0x134, 0x3,\n-    0x18b, 0x5,\n-    0x19c, 0x34,\n+    0x19c, 0x4,\n+    0x1a1, 0x2f,\n     0x1fe, 0x82,\n     0x29d, 0x3,\n-    0x2d1, 0x2f,\n+    0x2d1, 0xf,\n+    0x2fc, 0x4,\n     0x324, 0xc,\n-    0x34b, 0x35,\n+    0x34b, 0x5,\n+    0x37b, 0x5,\n     0x3c4, 0x4,\n     0x3d6, 0x2a,\n-    0x4aa, 0x356,\n+    0x4aa, 0x6,\n+    0x4d4, 0x4,\n+    0x4fc, 0x4,\n+    0x528, 0x8,\n+    0x564, 0xb,\n+    0x570, 0x90,\n+    0x737, 0x9,\n+    0x756, 0xa,\n+    0x768, 0x98,\n     0x839, 0x3,\n-    0x860, 0xa0,\n+    0x89f, 0x8,\n+    0x8b0, 0x30,\n+    0x8f6, 0x5,\n     0x91c, 0x3,\n     0x93a, 0x5,\n     0x940, 0x40,\n-    0x9b8, 0x6,\n-    0x9c0, 0x40,\n+    0x9b8, 0x4,\n     0xa07, 0x5,\n     0xa34, 0x4,\n     0xa3b, 0x4,\n     0xa48, 0x8,\n     0xa59, 0x7,\n-    0xa80, 0x80,\n+    0xaa0, 0x20,\n+    0xae7, 0x4,\n+    0xaf7, 0x9,\n     0xb36, 0x3,\n     0xb73, 0x5,\n-    0xb80, 0x80,\n-    0xc49, 0x217,\n+    0xb92, 0x7,\n+    0xb9d, 0xc,\n+    0xbb0, 0x50,\n+    0xc49, 0x37,\n+    0xcb3, 0xd,\n+    0xcf3, 0x7,\n+    0xd00, 0x160,\n     0xe7f, 0x181,\n     0x104e, 0x4,\n-    0x1070, 0x10,\n+    0x1070, 0xf,\n     0x10c2, 0xe,\n     0x10e9, 0x7,\n     0x10fa, 0x6,\n-    0x1144, 0x3c,\n-    0x11c9, 0x7,\n-    0x11da, 0x4a6,\n+    0x1144, 0xc,\n+    0x1177, 0x9,\n+    0x11f5, 0xb,\n+    0x123f, 0x41,\n+    0x12aa, 0x6,\n+    0x12eb, 0x5,\n+    0x12fa, 0x6,\n+    0x1351, 0x6,\n+    0x1358, 0x5,\n+    0x136d, 0x3,\n+    0x1375, 0x8b,\n+    0x145e, 0x22,\n+    0x14c8, 0x8,\n+    0x14da, 0xa6,\n+    0x15de, 0x22,\n+    0x1645, 0xb,\n+    0x165a, 0x6,\n+    0x166d, 0x13,\n     0x16b8, 0x8,\n-    0x16ca, 0x936,\n-    0x236f, 0x91,\n-    0x2463, 0xd,\n-    0x2474, 0xb8c,\n-    0x342f, 0x33d1,\n-    0x6a39, 0x4c7,\n+    0x16ca, 0x36,\n+    0x171a, 0x3,\n+    0x172c, 0x4,\n+    0x1740, 0x160,\n+    0x18f3, 0xc,\n+    0x1900, 0x1c0,\n+    0x1af9, 0x107,\n+    0x1c46, 0xa,\n+    0x1c6d, 0x3,\n+    0x1cb7, 0x349,\n+    0x239a, 0x66,\n+    0x2475, 0xb,\n+    0x2544, 0xabc,\n+    0x342f, 0xfd1,\n+    0x4647, 0x21b9,\n+    0x6a39, 0x7,\n+    0x6a6a, 0x4,\n+    0x6a70, 0x60,\n+    0x6af6, 0xa,\n+    0x6b46, 0xa,\n+    0x6b78, 0x5,\n+    0x6b90, 0x370,\n     0x6f45, 0xb,\n     0x6f7f, 0x10,\n-    0x6fa0, 0x4060,\n-    0xb002, 0x1ffe,\n+    0x6fa0, 0x40,\n+    0x6fe1, 0x1f,\n+    0x87ed, 0x13,\n+    0x8af3, 0x250d,\n+    0xb002, 0xbfe,\n+    0xbc6b, 0x5,\n+    0xbc7d, 0x3,\n+    0xbc89, 0x7,\n+    0xbca0, 0x1360,\n     0xd0f6, 0xa,\n     0xd173, 0x8,\n-    0xd1de, 0x22,\n+    0xd1e9, 0x17,\n     0xd246, 0xba,\n     0xd357, 0x9,\n     0xd372, 0x8e,\n     0xd547, 0x3,\n-    0xd800, 0x1600,\n+    0xda8c, 0xf,\n+    0xdab0, 0x550,\n+    0xe02b, 0x7d5,\n+    0xe8d7, 0x29,\n+    0xe94b, 0x5,\n+    0xe95a, 0x4,\n+    0xe960, 0x4a0,\n     0xee3c, 0x6,\n     0xee43, 0x4,\n     0xee9c, 0x5,\n     0xeebc, 0x34,\n     0xeef2, 0x10e,\n     0xf02c, 0x4,\n     0xf094, 0xc,\n-    0xf0e0, 0x20,\n-    0xf10b, 0x5,\n+    0xf0f6, 0xa,\n+    0xf10d, 0x3,\n     0xf16c, 0x4,\n-    0xf19b, 0x4b,\n+    0xf1ad, 0x39,\n     0xf203, 0xd,\n-    0xf23b, 0x5,\n+    0xf23c, 0x4,\n     0xf249, 0x7,\n     0xf252, 0xae,\n-    0xf321, 0xf,\n-    0xf37d, 0x3,\n-    0xf394, 0xc,\n-    0xf3cb, 0x15,\n-    0xf3f1, 0xf,\n-    0xf4fd, 0x3,\n-    0xf544, 0xc,\n-    0xf568, 0x93,\n-    0xf641, 0x4,\n-    0xf650, 0x30,\n-    0xf6c6, 0x3a,\n-    0xf774, 0x88c,\n+    0xf6d3, 0xd,\n+    0xf6ed, 0x3,\n+    0xf6f7, 0x9,\n+    0xf774, 0xc,\n+    0xf7d5, 0x2b,\n+    0xf80c, 0x4,\n+    0xf848, 0x8,\n+    0xf85a, 0x6,\n+    0xf888, 0x8,\n+    0xf8ae, 0x62,\n+    0xf928, 0x8,\n+    0xf94c, 0x4,\n+    0xf95f, 0x21,\n+    0xf992, 0x2e,\n+    0xf9c1, 0x63f,\n ];"}, {"sha": "02a2e370547e9f147e038e871d4e619be0d14189", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1273,54 +1273,68 @@ unsafe impl<I> TrustedLen for Enumerate<I>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Peekable<I: Iterator> {\n     iter: I,\n-    peeked: Option<I::Item>,\n+    /// Remember a peeked value, even if it was None.\n+    peeked: Option<Option<I::Item>>,\n }\n \n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator> Iterator for Peekable<I> {\n     type Item = I::Item;\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked {\n-            Some(_) => self.peeked.take(),\n+        match self.peeked.take() {\n+            Some(v) => v,\n             None => self.iter.next(),\n         }\n     }\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn count(self) -> usize {\n-        (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked {\n-            Some(_) if n == 0 => self.peeked.take(),\n-            Some(_) => {\n-                self.peeked = None;\n-                self.iter.nth(n-1)\n-            },\n-            None => self.iter.nth(n)\n+        match self.peeked.take() {\n+            // the .take() below is just to avoid \"move into pattern guard\"\n+            Some(ref mut v) if n == 0 => v.take(),\n+            Some(None) => None,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n         }\n     }\n \n     #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        self.iter.last().or(self.peeked)\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n         let (lo, hi) = self.iter.size_hint();\n-        if self.peeked.is_some() {\n-            let lo = lo.saturating_add(1);\n-            let hi = hi.and_then(|x| x.checked_add(1));\n-            (lo, hi)\n-        } else {\n-            (lo, hi)\n-        }\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        (lo, hi)\n     }\n }\n \n@@ -1372,9 +1386,13 @@ impl<I: Iterator> Peekable<I> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&mut self) -> Option<&I::Item> {\n         if self.peeked.is_none() {\n-            self.peeked = self.iter.next();\n+            self.peeked = Some(self.iter.next());\n+        }\n+        match self.peeked {\n+            Some(Some(ref value)) => Some(value),\n+            Some(None) => None,\n+            _ => unreachable!(),\n         }\n-        self.peeked.as_ref()\n     }\n }\n "}, {"sha": "b4cd52e59f658079a1be9f6e0ef86090b0a8c2a9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -424,6 +424,17 @@ impl<'a> Iterator for Chars<'a> {\n         })\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        // length in `char` is equal to the number of non-continuation bytes\n+        let bytes_len = self.iter.len();\n+        let mut cont_bytes = 0;\n+        for &byte in self.iter {\n+            cont_bytes += utf8_is_cont_byte(byte) as usize;\n+        }\n+        bytes_len - cont_bytes\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.iter.len();\n@@ -432,6 +443,12 @@ impl<'a> Iterator for Chars<'a> {\n         // `isize::MAX` (that's well below `usize::MAX`).\n         ((len + 3) / 4, Some(len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -501,10 +518,21 @@ impl<'a> Iterator for CharIndices<'a> {\n         }\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(usize, char)> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b4088ffbf89a952980558adde182ef1f6b6d8609", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -162,6 +162,8 @@ fn test_escape_debug() {\n     assert_eq!(s, \"~\");\n     let s = string('\u00e9');\n     assert_eq!(s, \"\u00e9\");\n+    let s = string('\u6587');\n+    assert_eq!(s, \"\u6587\");\n     let s = string('\\x00');\n     assert_eq!(s, \"\\\\u{0}\");\n     let s = string('\\x1f');"}, {"sha": "274539dfa6699ff2ae4be624b0d717fbdf769fd5", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -274,6 +274,74 @@ fn test_iterator_peekable_last() {\n     let mut it = ys.iter().peekable();\n     assert_eq!(it.peek(), Some(&&0));\n     assert_eq!(it.last(), Some(&0));\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.next(), Some(&0));\n+    assert_eq!(it.peek(), None);\n+    assert_eq!(it.last(), None);\n+}\n+\n+/// This is an iterator that follows the Iterator contract,\n+/// but it is not fused. After having returned None once, it will start\n+/// producing elements if .next() is called again.\n+pub struct CycleIter<'a, T: 'a> {\n+    index: usize,\n+    data: &'a [T],\n+}\n+\n+pub fn cycle<T>(data: &[T]) -> CycleIter<T> {\n+    CycleIter {\n+        index: 0,\n+        data: data,\n+    }\n+}\n+\n+impl<'a, T> Iterator for CycleIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let elt = self.data.get(self.index);\n+        self.index += 1;\n+        self.index %= 1 + self.data.len();\n+        elt\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_1() {\n+    // Check that the loop using .peek() terminates\n+    let data = [1, 2, 3];\n+    let mut iter = cycle(&data).peekable();\n+\n+    let mut n = 0;\n+    while let Some(_) = iter.next() {\n+        let is_the_last = iter.peek().is_none();\n+        assert_eq!(is_the_last, n == data.len() - 1);\n+        n += 1;\n+        if n > data.len() { break; }\n+    }\n+    assert_eq!(n, data.len());\n+}\n+\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_2() {\n+    let data = [0];\n+    let mut iter = cycle(&data).peekable();\n+    iter.next();\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.last(), None);\n+}\n+\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_3() {\n+    let data = [0];\n+    let mut iter = cycle(&data).peekable();\n+    iter.peek();\n+    assert_eq!(iter.nth(0), Some(&0));\n+\n+    let mut iter = cycle(&data).peekable();\n+    iter.next();\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.nth(0), None);\n }\n \n #[test]"}, {"sha": "08c2cd0a7326f27534db3fa5fe5d2c9e08700482", "filename": "src/libcoretest/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,7 +11,6 @@\n use std::prelude::v1::*;\n use std::{i16, f64};\n use super::super::*;\n-use core::num::flt2dec::*;\n use core::num::bignum::Big32x40 as Big;\n use core::num::flt2dec::strategy::dragon::*;\n "}, {"sha": "311bd252353c770b4b7d7fab1a529f5f72908495", "filename": "src/libcoretest/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -10,7 +10,6 @@\n \n use std::{i16, f64};\n use super::super::*;\n-use core::num::flt2dec::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n #[test]"}, {"sha": "1ae906e0aa4e013016661fda77517168ec7903d1", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -34,8 +34,9 @@ use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::proc_macro_shim::build_block_emitter;\n-use syntax::parse::token::{self, Token, gensym_ident, str_to_ident};\n+use syntax::parse::token::{self, Token};\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n // ____________________________________________________________________________________________\n@@ -124,7 +125,7 @@ fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindi\n                     } // produce an error or something first\n                     let exp = vec![exp.unwrap().to_owned()];\n                     debug!(\"RHS: {:?}\", exp.clone());\n-                    let new_id = gensym_ident(\"tmp\");\n+                    let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"tmp\"));\n                     debug!(\"RHS TS: {:?}\", TokenStream::from_tts(exp.clone()));\n                     debug!(\"RHS TS TT: {:?}\", TokenStream::from_tts(exp.clone()).to_vec());\n                     bindings.push((new_id, TokenStream::from_tts(exp)));\n@@ -179,7 +180,7 @@ fn unravel_concats(tss: Vec<TokenStream>) -> TokenStream {\n     };\n \n     while let Some(ts) = pushes.pop() {\n-        output = build_fn_call(str_to_ident(\"concat\"),\n+        output = build_fn_call(Ident::from_str(\"concat\"),\n                                concat(concat(ts,\n                                              from_tokens(vec![Token::Comma])),\n                                       output));\n@@ -209,18 +210,19 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n             // FIXME handle sequence repetition tokens\n             QTT::QDL(qdl) => {\n                 debug!(\"  QDL: {:?} \", qdl.tts);\n-                let new_id = gensym_ident(\"qdl_tmp\");\n+                let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"qdl_tmp\"));\n                 let mut cct_rec = convert_complex_tts(cx, qdl.tts);\n                 bindings.append(&mut cct_rec.0);\n                 bindings.push((new_id, cct_rec.1));\n \n                 let sep = build_delim_tok(qdl.delim);\n \n-                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro_tokens\"),\n-                                               str_to_ident(\"build\"),\n-                                               str_to_ident(\"build_delimited\")],\n-                                          concat(from_tokens(vec![Token::Ident(new_id)]),\n-                                                 concat(lex(\",\"), sep))));\n+                pushes.push(build_mod_call(\n+                    vec![Ident::from_str(\"proc_macro_tokens\"),\n+                         Ident::from_str(\"build\"),\n+                         Ident::from_str(\"build_delimited\")],\n+                    concat(from_tokens(vec![Token::Ident(new_id)]), concat(lex(\",\"), sep)),\n+                ));\n             }\n             QTT::QIdent(t) => {\n                 pushes.push(TokenStream::from_tts(vec![t]));\n@@ -250,13 +252,13 @@ fn unravel(binds: Bindings) -> TokenStream {\n \n /// Checks if the Ident is `unquote`.\n fn is_unquote(id: Ident) -> bool {\n-    let qq = str_to_ident(\"unquote\");\n+    let qq = Ident::from_str(\"unquote\");\n     id.name == qq.name  // We disregard context; unquote is _reserved_\n }\n \n /// Checks if the Ident is `quote`.\n fn is_qquote(id: Ident) -> bool {\n-    let qq = str_to_ident(\"qquote\");\n+    let qq = Ident::from_str(\"qquote\");\n     id.name == qq.name  // We disregard context; qquote is _reserved_\n }\n \n@@ -266,7 +268,8 @@ mod int_build {\n \n     use syntax::ast::{self, Ident};\n     use syntax::codemap::{DUMMY_SP};\n-    use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+    use syntax::parse::token::{self, Token, Lit};\n+    use syntax::symbol::keywords;\n     use syntax::tokenstream::{TokenTree, TokenStream};\n \n     // ____________________________________________________________________________________________\n@@ -277,19 +280,19 @@ mod int_build {\n                build_paren_delimited(build_vec(build_token_tt(t))))\n     }\n \n-    pub fn emit_lit(l: token::Lit, n: Option<ast::Name>) -> TokenStream {\n+    pub fn emit_lit(l: Lit, n: Option<ast::Name>) -> TokenStream {\n         let suf = match n {\n-            Some(n) => format!(\"Some(ast::Name({}))\", n.0),\n+            Some(n) => format!(\"Some(ast::Name({}))\", n.as_u32()),\n             None => \"None\".to_string(),\n         };\n \n         let lit = match l {\n-            token::Lit::Byte(n) => format!(\"Lit::Byte(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Char(n) => format!(\"Lit::Char(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Integer(n) => format!(\"Lit::Integer(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Float(n) => format!(\"Lit::Float(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Str_(n) => format!(\"Lit::Str_(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::ByteStr(n) => format!(\"Lit::ByteStr(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Byte(n) => format!(\"Lit::Byte(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Char(n) => format!(\"Lit::Char(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Float(n) => format!(\"Lit::Float(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Str_(n) => format!(\"Lit::Str_(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Integer(n) => format!(\"Lit::Integer(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::ByteStr(n) => format!(\"Lit::ByteStr(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n             _ => panic!(\"Unsupported literal\"),\n         };\n \n@@ -388,9 +391,10 @@ mod int_build {\n             Token::Underscore => lex(\"_\"),\n             Token::Literal(lit, sfx) => emit_lit(lit, sfx),\n             // fix ident expansion information... somehow\n-            Token::Ident(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\", ident.name)),\n-            Token::Lifetime(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\",\n-                                                   ident.name)),\n+            Token::Ident(ident) =>\n+                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n+            Token::Lifetime(ident) =>\n+                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n             _ => panic!(\"Unhandled case!\"),\n         }\n     }\n@@ -408,7 +412,7 @@ mod int_build {\n \n     /// Takes `input` and returns `vec![input]`.\n     pub fn build_vec(ts: TokenStream) -> TokenStream {\n-        build_mac_call(str_to_ident(\"vec\"), ts)\n+        build_mac_call(Ident::from_str(\"vec\"), ts)\n         // tts.clone().to_owned()\n     }\n "}, {"sha": "d39aba0aa7787a26854decbcca1675dbee84b9f3", "filename": "src/libproc_macro_tokens/build.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -13,7 +13,8 @@ extern crate syntax_pos;\n \n use syntax::ast::Ident;\n use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+use syntax::parse::token::{self, Token};\n+use syntax::symbol::keywords;\n use syntax::tokenstream::{self, TokenTree, TokenStream};\n use std::rc::Rc;\n \n@@ -43,13 +44,13 @@ pub fn ident_eq(tident: &TokenTree, id: Ident) -> bool {\n \n /// Convert a `&str` into a Token.\n pub fn str_to_token_ident(s: &str) -> Token {\n-    Token::Ident(str_to_ident(s))\n+    Token::Ident(Ident::from_str(s))\n }\n \n /// Converts a keyword (from `syntax::parse::token::keywords`) into a Token that\n /// corresponds to it.\n pub fn keyword_to_token_ident(kw: keywords::Keyword) -> Token {\n-    Token::Ident(str_to_ident(&kw.name().as_str()[..]))\n+    Token::Ident(Ident::from_str(&kw.name().as_str()[..]))\n }\n \n // ____________________________________________________________________________________________"}, {"sha": "c399623462b5d732368fe2fab0ac64b762521ee2", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            hir::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -282,9 +282,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprBreak(label) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n+                let v = self.opt_expr(opt_expr, pred);\n                 let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n-                let b = self.add_ast_node(expr.id, &[pred]);\n+                let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n@@ -299,15 +300,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprArray(ref elems) => {\n-                self.straightline(expr, pred, elems.iter().map(|e| &**e))\n+                self.straightline(expr, pred, elems.iter().map(|e| &*e))\n             }\n \n             hir::ExprCall(ref func, ref args) => {\n-                self.call(expr, pred, &func, args.iter().map(|e| &**e))\n+                self.call(expr, pred, &func, args.iter().map(|e| &*e))\n             }\n \n             hir::ExprMethodCall(.., ref args) => {\n-                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &**e))\n+                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &*e))\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n@@ -320,7 +321,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprTup(ref exprs) => {\n-                self.straightline(expr, pred, exprs.iter().map(|e| &**e))\n+                self.straightline(expr, pred, exprs.iter().map(|e| &*e))\n             }\n \n             hir::ExprStruct(_, ref fields, ref base) => {\n@@ -353,8 +354,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n-                let post_outputs = self.exprs(outputs.iter().map(|e| &**e), pred);\n-                let post_inputs = self.exprs(inputs.iter().map(|e| &**e), post_outputs);\n+                let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n+                let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n                 self.add_ast_node(expr.id, &[post_inputs])\n             }\n "}, {"sha": "abc35634d15f456e21372a311f77bff177392a6e", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -64,7 +64,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 None => continue,\n             };\n \n-            let (message, label) = match &*name {\n+            let (message, label) = match &*name.as_str() {\n                 \"C\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Struct &&\n@@ -120,7 +120,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        let name: &str = &attr.name();\n+        let name: &str = &attr.name().as_str();\n         match name {\n             \"inline\" => self.check_inline(attr, target),\n             \"repr\" => self.check_repr(attr, target),"}, {"sha": "7dd88e36dd1f55ca7fe93d2092f2f893e801fe8c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -882,7 +882,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(block);\n             walk_opt_sp_name(visitor, opt_sp_name);\n         }\n-        ExprLoop(ref block, ref opt_sp_name) => {\n+        ExprLoop(ref block, ref opt_sp_name, _) => {\n             visitor.visit_block(block);\n             walk_opt_sp_name(visitor, opt_sp_name);\n         }\n@@ -923,7 +923,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(ref opt_sp_name) | ExprAgain(ref opt_sp_name) => {\n+        ExprBreak(ref opt_sp_name, ref opt_expr) => {\n+            walk_opt_sp_name(visitor, opt_sp_name);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprAgain(ref opt_sp_name) => {\n             walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprRet(ref optional_expression) => {"}, {"sha": "5af7c18e1a1078f4c9cc14849f59b0691d8b01ba", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 159, "deletions": 150, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -53,8 +53,8 @@ use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned};\n-use syntax::parse::token;\n use syntax::std_inject;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n@@ -149,7 +149,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n-        token::gensym(s)\n+        Symbol::gensym(s)\n     }\n \n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n@@ -210,8 +210,8 @@ impl<'a> LoweringContext<'a> {\n         hir::Arm {\n             attrs: self.lower_attrs(&arm.attrs),\n             pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n-            guard: arm.guard.as_ref().map(|ref x| self.lower_expr(x)),\n-            body: self.lower_expr(&arm.body),\n+            guard: arm.guard.as_ref().map(|ref x| P(self.lower_expr(x))),\n+            body: P(self.lower_expr(&arm.body)),\n         }\n     }\n \n@@ -262,10 +262,10 @@ impl<'a> LoweringContext<'a> {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n                 }\n                 TyKind::Array(ref ty, ref e) => {\n-                    hir::TyArray(self.lower_ty(ty), self.lower_expr(e))\n+                    hir::TyArray(self.lower_ty(ty), P(self.lower_expr(e)))\n                 }\n                 TyKind::Typeof(ref expr) => {\n-                    hir::TyTypeof(self.lower_expr(expr))\n+                    hir::TyTypeof(P(self.lower_expr(expr)))\n                 }\n                 TyKind::PolyTraitRef(ref bounds) => {\n                     hir::TyPolyTraitRef(self.lower_bounds(bounds))\n@@ -292,7 +292,7 @@ impl<'a> LoweringContext<'a> {\n                 name: v.node.name.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_expr(e)),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| P(self.lower_expr(e))),\n             },\n             span: v.span,\n         }\n@@ -350,7 +350,7 @@ impl<'a> LoweringContext<'a> {\n             id: l.id,\n             ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n             pat: self.lower_pat(&l.pat),\n-            init: l.init.as_ref().map(|e| self.lower_expr(e)),\n+            init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n         })\n@@ -400,8 +400,8 @@ impl<'a> LoweringContext<'a> {\n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n         // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n         // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-        if name == token::keywords::SelfType.name() {\n-            name = token::gensym(\"Self\");\n+        if name == keywords::SelfType.name() {\n+            name = Symbol::gensym(\"Self\");\n         }\n \n         hir::TyParam {\n@@ -540,7 +540,7 @@ impl<'a> LoweringContext<'a> {\n         hir::StructField {\n             span: f.span,\n             id: f.id,\n-            name: f.ident.map(|ident| ident.name).unwrap_or(token::intern(&index.to_string())),\n+            name: f.ident.map(|ident| ident.name).unwrap_or(Symbol::intern(&index.to_string())),\n             vis: self.lower_visibility(&f.vis),\n             ty: self.lower_ty(&f.ty),\n             attrs: self.lower_attrs(&f.attrs),\n@@ -550,7 +550,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n             name: respan(f.ident.span, f.ident.node.name),\n-            expr: self.lower_expr(&f.expr),\n+            expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n         }\n@@ -599,10 +599,10 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Static(ref t, m, ref e) => {\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                self.lower_expr(e))\n+                                P(self.lower_expr(e)))\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                hir::ItemConst(self.lower_ty(t), self.lower_expr(e))\n+                hir::ItemConst(self.lower_ty(t), P(self.lower_expr(e)))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n@@ -611,7 +611,7 @@ impl<'a> LoweringContext<'a> {\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            self.expr_block(body, ThinVec::new()))\n+                            P(self.expr_block(body, ThinVec::new())))\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -672,13 +672,13 @@ impl<'a> LoweringContext<'a> {\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n                         hir::ConstTraitItem(this.lower_ty(ty),\n-                                            default.as_ref().map(|x| this.lower_expr(x)))\n+                                            default.as_ref().map(|x| P(this.lower_expr(x))))\n                     }\n                     TraitItemKind::Method(ref sig, ref body) => {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n                                              body.as_ref().map(|x| {\n                             let body = this.lower_block(x);\n-                            this.expr_block(body, ThinVec::new())\n+                            P(this.expr_block(body, ThinVec::new()))\n                         }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n@@ -702,12 +702,12 @@ impl<'a> LoweringContext<'a> {\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n-                        hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n+                        hir::ImplItemKind::Const(this.lower_ty(ty), P(this.lower_expr(expr)))\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  this.expr_block(body, ThinVec::new()))\n+                                                  P(this.expr_block(body, ThinVec::new())))\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -885,7 +885,7 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     })\n                 }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+                PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n                     hir::PatKind::TupleStruct(self.lower_path(path),\n                                         pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n@@ -920,7 +920,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n                 }\n                 PatKind::Range(ref e1, ref e2) => {\n-                    hir::PatKind::Range(self.lower_expr(e1), self.lower_expr(e2))\n+                    hir::PatKind::Range(P(self.lower_expr(e1)), P(self.lower_expr(e2)))\n                 }\n                 PatKind::Slice(ref before, ref slice, ref after) => {\n                     hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n@@ -933,8 +933,8 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_expr(&mut self, e: &Expr) -> P<hir::Expr> {\n-        P(hir::Expr {\n+    fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n+        hir::Expr {\n             id: e.id,\n             node: match e.node {\n                 // Issue #22181:\n@@ -954,7 +954,7 @@ impl<'a> LoweringContext<'a> {\n                 //\n                 // But for now there are type-inference issues doing that.\n                 ExprKind::Box(ref e) => {\n-                    hir::ExprBox(self.lower_expr(e))\n+                    hir::ExprBox(P(self.lower_expr(e)))\n                 }\n \n                 // Desugar ExprBox: `in (PLACE) EXPR`\n@@ -968,8 +968,8 @@ impl<'a> LoweringContext<'a> {\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n-                    let placer_expr = self.lower_expr(placer);\n-                    let value_expr = self.lower_expr(value_expr);\n+                    let placer_expr = P(self.lower_expr(placer));\n+                    let value_expr = P(self.lower_expr(value_expr));\n \n                     let placer_ident = self.str_to_ident(\"placer\");\n                     let place_ident = self.str_to_ident(\"place\");\n@@ -983,7 +983,7 @@ impl<'a> LoweringContext<'a> {\n                     let make_call = |this: &mut LoweringContext, p, args| {\n                         let path = this.std_path(e.span, p);\n                         let path = this.expr_path(path, ThinVec::new());\n-                        this.expr_call(e.span, path, args)\n+                        P(this.expr_call(e.span, path, args))\n                     };\n \n                     let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n@@ -996,11 +996,11 @@ impl<'a> LoweringContext<'a> {\n \n                     // let placer = <placer_expr> ;\n                     let (s1, placer_binding) = {\n-                        let placer_expr = self.signal_block_expr(hir_vec![],\n-                                                                 placer_expr,\n-                                                                 e.span,\n-                                                                 hir::PopUnstableBlock,\n-                                                                 ThinVec::new());\n+                        let placer_expr = P(self.signal_block_expr(hir_vec![],\n+                                                                   placer_expr,\n+                                                                   e.span,\n+                                                                   hir::PopUnstableBlock,\n+                                                                   ThinVec::new()));\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n@@ -1013,19 +1013,19 @@ impl<'a> LoweringContext<'a> {\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let (s3, p_ptr_binding) = {\n-                        let agent = self.expr_ident(e.span, place_ident, place_binding);\n+                        let agent = P(self.expr_ident(e.span, place_ident, place_binding));\n                         let args = hir_vec![self.expr_mut_addr_of(e.span, agent)];\n                         let call = make_call(self, &place_pointer, args);\n                         mk_stmt_let(self, p_ptr_ident, call)\n                     };\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n-                        let value_expr = self.signal_block_expr(hir_vec![],\n-                                                                value_expr,\n-                                                                e.span,\n-                                                                hir::PopUnstableBlock,\n-                                                                ThinVec::new());\n+                        let value_expr = P(self.signal_block_expr(hir_vec![],\n+                                                                  value_expr,\n+                                                                  e.span,\n+                                                                  hir::PopUnstableBlock,\n+                                                                  ThinVec::new()));\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n@@ -1047,11 +1047,11 @@ impl<'a> LoweringContext<'a> {\n \n                         let place = self.expr_ident(e.span, place_ident, place_binding);\n                         let call = make_call(self, &inplace_finalize, hir_vec![place]);\n-                        self.signal_block_expr(hir_vec![call_move_val_init],\n-                                               call,\n-                                               e.span,\n-                                               hir::PushUnsafeBlock(hir::CompilerGenerated),\n-                                               ThinVec::new())\n+                        P(self.signal_block_expr(hir_vec![call_move_val_init],\n+                                                 call,\n+                                                 e.span,\n+                                                 hir::PushUnsafeBlock(hir::CompilerGenerated),\n+                                                 ThinVec::new()))\n                     };\n \n                     return self.signal_block_expr(hir_vec![s1, s2, s3],\n@@ -1065,15 +1065,15 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprArray(exprs.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::Repeat(ref expr, ref count) => {\n-                    let expr = self.lower_expr(expr);\n-                    let count = self.lower_expr(count);\n+                    let expr = P(self.lower_expr(expr));\n+                    let count = P(self.lower_expr(count));\n                     hir::ExprRepeat(expr, count)\n                 }\n                 ExprKind::Tup(ref elts) => {\n                     hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::Call(ref f, ref args) => {\n-                    let f = self.lower_expr(f);\n+                    let f = P(self.lower_expr(f));\n                     hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::MethodCall(i, ref tps, ref args) => {\n@@ -1083,27 +1083,27 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                     let binop = self.lower_binop(binop);\n-                    let lhs = self.lower_expr(lhs);\n-                    let rhs = self.lower_expr(rhs);\n+                    let lhs = P(self.lower_expr(lhs));\n+                    let rhs = P(self.lower_expr(rhs));\n                     hir::ExprBinary(binop, lhs, rhs)\n                 }\n                 ExprKind::Unary(op, ref ohs) => {\n                     let op = self.lower_unop(op);\n-                    let ohs = self.lower_expr(ohs);\n+                    let ohs = P(self.lower_expr(ohs));\n                     hir::ExprUnary(op, ohs)\n                 }\n                 ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n                 ExprKind::Cast(ref expr, ref ty) => {\n-                    let expr = self.lower_expr(expr);\n+                    let expr = P(self.lower_expr(expr));\n                     hir::ExprCast(expr, self.lower_ty(ty))\n                 }\n                 ExprKind::Type(ref expr, ref ty) => {\n-                    let expr = self.lower_expr(expr);\n+                    let expr = P(self.lower_expr(expr));\n                     hir::ExprType(expr, self.lower_ty(ty))\n                 }\n                 ExprKind::AddrOf(m, ref ohs) => {\n                     let m = self.lower_mutability(m);\n-                    let ohs = self.lower_expr(ohs);\n+                    let ohs = P(self.lower_expr(ohs));\n                     hir::ExprAddrOf(m, ohs)\n                 }\n                 // More complicated than you might expect because the else branch\n@@ -1114,7 +1114,7 @@ impl<'a> LoweringContext<'a> {\n                             ExprKind::IfLet(..) => {\n                                 // wrap the if-let expr in a block\n                                 let span = els.span;\n-                                let els = self.lower_expr(els);\n+                                let els = P(self.lower_expr(els));\n                                 let id = self.next_id();\n                                 let blk = P(hir::Block {\n                                     stmts: hir_vec![],\n@@ -1123,57 +1123,59 @@ impl<'a> LoweringContext<'a> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                self.expr_block(blk, ThinVec::new())\n+                                P(self.expr_block(blk, ThinVec::new()))\n                             }\n-                            _ => self.lower_expr(els),\n+                            _ => P(self.lower_expr(els)),\n                         }\n                     });\n \n-                    hir::ExprIf(self.lower_expr(cond), self.lower_block(blk), else_opt)\n+                    hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk), else_opt)\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(self.lower_expr(cond), self.lower_block(body),\n+                    hir::ExprWhile(P(self.lower_expr(cond)), self.lower_block(body),\n                                    self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body), self.lower_opt_sp_ident(opt_ident))\n+                    hir::ExprLoop(self.lower_block(body),\n+                                  self.lower_opt_sp_ident(opt_ident),\n+                                  hir::LoopSource::Loop)\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n-                    hir::ExprMatch(self.lower_expr(expr),\n+                    hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                     self.with_parent_def(e.id, |this| {\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.lower_expr(body),\n+                                         P(this.lower_expr(body)),\n                                          fn_decl_span)\n                     })\n                 }\n                 ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk)),\n                 ExprKind::Assign(ref el, ref er) => {\n-                    hir::ExprAssign(self.lower_expr(el), self.lower_expr(er))\n+                    hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n                 }\n                 ExprKind::AssignOp(op, ref el, ref er) => {\n                     hir::ExprAssignOp(self.lower_binop(op),\n-                                      self.lower_expr(el),\n-                                      self.lower_expr(er))\n+                                      P(self.lower_expr(el)),\n+                                      P(self.lower_expr(er)))\n                 }\n                 ExprKind::Field(ref el, ident) => {\n-                    hir::ExprField(self.lower_expr(el), respan(ident.span, ident.node.name))\n+                    hir::ExprField(P(self.lower_expr(el)), respan(ident.span, ident.node.name))\n                 }\n                 ExprKind::TupField(ref el, ident) => {\n-                    hir::ExprTupField(self.lower_expr(el), ident)\n+                    hir::ExprTupField(P(self.lower_expr(el)), ident)\n                 }\n                 ExprKind::Index(ref el, ref er) => {\n-                    hir::ExprIndex(self.lower_expr(el), self.lower_expr(er))\n+                    hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n                 }\n                 ExprKind::Range(ref e1, ref e2, lims) => {\n                     fn make_struct(this: &mut LoweringContext,\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n-                                   fields: &[(&str, &P<Expr>)]) -> P<hir::Expr> {\n+                                   fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n                         let struct_path = this.std_path(ast_expr.span,\n                                                         &iter::once(&\"ops\").chain(path)\n                                                                            .map(|s| *s)\n@@ -1183,13 +1185,13 @@ impl<'a> LoweringContext<'a> {\n                             this.expr_path(struct_path, ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n-                                let expr = this.lower_expr(&e);\n-                                let signal_block = this.signal_block_expr(hir_vec![],\n-                                                                          expr,\n-                                                                          e.span,\n-                                                                          hir::PopUnstableBlock,\n-                                                                          ThinVec::new());\n-                                this.field(token::intern(s), signal_block, ast_expr.span)\n+                                let expr = P(this.lower_expr(&e));\n+                                let signal_block = P(this.signal_block_expr(hir_vec![],\n+                                                                            expr,\n+                                                                            e.span,\n+                                                                            hir::PopUnstableBlock,\n+                                                                            ThinVec::new()));\n+                                this.field(Symbol::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n@@ -1242,9 +1244,12 @@ impl<'a> LoweringContext<'a> {\n                     });\n                     hir::ExprPath(hir_qself, self.lower_path(path))\n                 }\n-                ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Break(opt_ident, ref opt_expr) => {\n+                    hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n+                                   opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n+                }\n                 ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n-                ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n+                ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n                         inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n@@ -1272,20 +1277,19 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                     hir::ExprStruct(P(self.lower_path(path)),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n-                                    maybe_expr.as_ref().map(|x| self.lower_expr(x)))\n+                                    maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n                 ExprKind::Paren(ref ex) => {\n-                    return self.lower_expr(ex).map(|mut ex| {\n-                        // include parens in span, but only if it is a super-span.\n-                        if e.span.contains(ex.span) {\n-                            ex.span = e.span;\n-                        }\n-                        // merge attributes into the inner expression.\n-                        let mut attrs = e.attrs.clone();\n-                        attrs.extend::<Vec<_>>(ex.attrs.into());\n-                        ex.attrs = attrs;\n-                        ex\n-                    });\n+                    let mut ex = self.lower_expr(ex);\n+                    // include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = e.span;\n+                    }\n+                    // merge attributes into the inner expression.\n+                    let mut attrs = e.attrs.clone();\n+                    attrs.extend::<Vec<_>>(ex.attrs.into());\n+                    ex.attrs = attrs;\n+                    return ex;\n                 }\n \n                 // Desugar ExprIfLet\n@@ -1302,13 +1306,13 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, ThinVec::new());\n+                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                    let mut else_opt = else_opt.as_ref().map(|e| self.lower_expr(e));\n+                    let mut else_opt = else_opt.as_ref().map(|e| P(self.lower_expr(e)));\n                     let else_if_arms = {\n                         let mut arms = vec![];\n                         loop {\n@@ -1322,7 +1326,7 @@ impl<'a> LoweringContext<'a> {\n                                                 attrs: hir_vec![],\n                                                 pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: self.expr_block(then, ThinVec::new()),\n+                                                body: P(self.expr_block(then, ThinVec::new())),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1362,7 +1366,7 @@ impl<'a> LoweringContext<'a> {\n                     arms.extend(else_if_arms);\n                     arms.push(else_arm);\n \n-                    let sub_expr = self.lower_expr(sub_expr);\n+                    let sub_expr = P(self.lower_expr(sub_expr));\n                     // add attributes to the outer returned expr node\n                     return self.expr(e.span,\n                                      hir::ExprMatch(sub_expr,\n@@ -1388,7 +1392,7 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, ThinVec::new());\n+                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n@@ -1402,19 +1406,20 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match <sub_expr> { ... }`\n                     let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = self.lower_expr(sub_expr);\n+                    let sub_expr = P(self.lower_expr(sub_expr));\n                     let match_expr = self.expr(e.span,\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n                                                               hir::MatchSource::WhileLetDesugar),\n                                                ThinVec::new());\n \n                     // `[opt_ident]: loop { ... }`\n-                    let loop_block = self.block_expr(match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n+                    let loop_block = P(self.block_expr(P(match_expr)));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                                                  hir::LoopSource::WhileLet);\n                     // add attributes to the outer returned expr node\n                     let attrs = e.attrs.clone();\n-                    return P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs });\n+                    return hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs };\n                 }\n \n                 // Desugar ExprForLoop\n@@ -1471,20 +1476,23 @@ impl<'a> LoweringContext<'a> {\n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n                         let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n-                        let iter = self.expr_ident(e.span, iter, iter_pat.id);\n+                        let iter = P(self.expr_ident(e.span, iter, iter_pat.id));\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n                         let next_path = self.expr_path(next_path, ThinVec::new());\n-                        let next_expr = self.expr_call(e.span, next_path, hir_vec![ref_mut_iter]);\n+                        let next_expr = P(self.expr_call(e.span, next_path,\n+                                          hir_vec![ref_mut_iter]));\n                         let arms = hir_vec![pat_arm, break_arm];\n \n-                        self.expr(e.span,\n-                                  hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                                  ThinVec::new())\n+                        P(self.expr(e.span,\n+                                    hir::ExprMatch(next_expr, arms,\n+                                                   hir::MatchSource::ForLoopDesugar),\n+                                    ThinVec::new()))\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n-                    let loop_block = self.block_expr(match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n+                    let loop_block = P(self.block_expr(match_expr));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                                                  hir::LoopSource::ForLoop);\n                     let loop_expr = P(hir::Expr {\n                         id: e.id,\n                         node: loop_expr,\n@@ -1501,22 +1509,22 @@ impl<'a> LoweringContext<'a> {\n                                                            &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n                         let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n-                        self.expr_call(e.span, into_iter, hir_vec![head])\n+                        P(self.expr_call(e.span, into_iter, hir_vec![head]))\n                     };\n \n-                    let match_expr = self.expr_match(e.span,\n-                                                     into_iter_expr,\n-                                                     hir_vec![iter_arm],\n-                                                     hir::MatchSource::ForLoopDesugar);\n+                    let match_expr = P(self.expr_match(e.span,\n+                                                       into_iter_expr,\n+                                                       hir_vec![iter_arm],\n+                                                       hir::MatchSource::ForLoopDesugar));\n \n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = self.str_to_ident(\"_result\");\n                     let (let_stmt, let_stmt_binding) =\n                         self.stmt_let(e.span, false, result_ident, match_expr);\n \n-                    let result = self.expr_ident(e.span, result_ident, let_stmt_binding);\n-                    let block = self.block_all(e.span, hir_vec![let_stmt], Some(result));\n+                    let result = P(self.expr_ident(e.span, result_ident, let_stmt_binding));\n+                    let block = P(self.block_all(e.span, hir_vec![let_stmt], Some(result)));\n                     // add the attributes to the outer returned expr node\n                     return self.expr_block(block, e.attrs.clone());\n                 }\n@@ -1536,7 +1544,7 @@ impl<'a> LoweringContext<'a> {\n                     // { Carrier::translate( { <expr> } ) }\n                     let discr = {\n                         // expand <expr>\n-                        let sub_expr = self.lower_expr(sub_expr);\n+                        let sub_expr = P(self.lower_expr(sub_expr));\n                         let sub_expr = self.signal_block_expr(hir_vec![],\n                                                               sub_expr,\n                                                               e.span,\n@@ -1545,20 +1553,20 @@ impl<'a> LoweringContext<'a> {\n \n                         let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n                         let path = self.expr_path(path, ThinVec::new());\n-                        let call = self.expr_call(e.span, path, hir_vec![sub_expr]);\n+                        let call = P(self.expr_call(e.span, path, hir_vec![sub_expr]));\n \n-                        self.signal_block_expr(hir_vec![],\n-                                               call,\n-                                               e.span,\n-                                               hir::PushUnstableBlock,\n-                                               ThinVec::new())\n+                        P(self.signal_block_expr(hir_vec![],\n+                                                 call,\n+                                                 e.span,\n+                                                 hir::PushUnstableBlock,\n+                                                 ThinVec::new()))\n                     };\n \n                     // Ok(val) => val\n                     let ok_arm = {\n                         let val_ident = self.str_to_ident(\"val\");\n                         let val_pat = self.pat_ident(e.span, val_ident);\n-                        let val_expr = self.expr_ident(e.span, val_ident, val_pat.id);\n+                        let val_expr = P(self.expr_ident(e.span, val_ident, val_pat.id));\n                         let ok_pat = self.pat_ok(e.span, val_pat);\n \n                         self.arm(hir_vec![ok_pat], val_expr)\n@@ -1578,15 +1586,16 @@ impl<'a> LoweringContext<'a> {\n                         let from_err_expr = {\n                             let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n                             let from_err = self.expr_path(path, ThinVec::new());\n-                            self.expr_call(e.span, from_err, hir_vec![from_expr])\n+                            P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n-                        let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(from_err_expr)),\n-                                                                     ThinVec::new());\n+                        let ret_expr = P(self.expr(e.span,\n+                                                   hir::Expr_::ExprRet(Some(from_err_expr)),\n+                                                                       ThinVec::new()));\n                         let ret_stmt = self.stmt_expr(ret_expr);\n-                        let block = self.signal_block_stmt(ret_stmt, e.span,\n-                                                           hir::PushUnstableBlock, ThinVec::new());\n+                        let block = P(self.signal_block_stmt(ret_stmt, e.span,\n+                                                             hir::PushUnstableBlock,\n+                                                             ThinVec::new()));\n \n                         let err_pat = self.pat_err(e.span, err_local);\n                         self.arm(hir_vec![err_pat], block)\n@@ -1600,7 +1609,7 @@ impl<'a> LoweringContext<'a> {\n             },\n             span: e.span,\n             attrs: e.attrs.clone(),\n-        })\n+        }\n     }\n \n     fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n@@ -1621,13 +1630,13 @@ impl<'a> LoweringContext<'a> {\n             },\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n-                    node: hir::StmtExpr(self.lower_expr(e), s.id),\n+                    node: hir::StmtExpr(P(self.lower_expr(e)), s.id),\n                     span: s.span,\n                 }\n             }\n             StmtKind::Semi(ref e) => {\n                 Spanned {\n-                    node: hir::StmtSemi(self.lower_expr(e), s.id),\n+                    node: hir::StmtSemi(P(self.lower_expr(e)), s.id),\n                     span: s.span,\n                 }\n             }\n@@ -1721,15 +1730,15 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        self.expr(span, hir::ExprBreak(None), attrs)\n+        P(self.expr(span, hir::ExprBreak(None, None), attrs))\n     }\n \n-    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<P<hir::Expr>>)\n-                 -> P<hir::Expr> {\n+    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<hir::Expr>)\n+                 -> hir::Expr {\n         self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> P<hir::Expr> {\n+    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n         let expr = self.expr(span, expr_path, ThinVec::new());\n \n@@ -1742,13 +1751,13 @@ impl<'a> LoweringContext<'a> {\n         expr\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n         self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n     fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n-        let expr = self.expr(path.span, hir::ExprPath(None, path), attrs);\n+        let expr = P(self.expr(path.span, hir::ExprPath(None, path), attrs));\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n@@ -1758,16 +1767,16 @@ impl<'a> LoweringContext<'a> {\n                   arg: P<hir::Expr>,\n                   arms: hir::HirVec<hir::Arm>,\n                   source: hir::MatchSource)\n-                  -> P<hir::Expr> {\n+                  -> hir::Expr {\n         self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n         self.expr(b.span, hir::ExprBlock(b), attrs)\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>) -> P<hir::Expr> {\n-        self.expr(sp, hir::ExprTup(exprs), ThinVec::new())\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> P<hir::Expr> {\n+        P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n     }\n \n     fn expr_struct(&mut self,\n@@ -1777,18 +1786,18 @@ impl<'a> LoweringContext<'a> {\n                    e: Option<P<hir::Expr>>,\n                    attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs);\n+        let expr = P(self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs));\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        P(hir::Expr {\n+    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        hir::Expr {\n             id: self.next_id(),\n             node: node,\n             span: span,\n             attrs: attrs,\n-        })\n+        }\n     }\n \n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n@@ -1820,19 +1829,19 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn block_expr(&mut self, expr: P<hir::Expr>) -> P<hir::Block> {\n+    fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n \n     fn block_all(&mut self, span: Span, stmts: hir::HirVec<hir::Stmt>, expr: Option<P<hir::Expr>>)\n-                 -> P<hir::Block> {\n-        P(hir::Block {\n+                 -> hir::Block {\n+        hir::Block {\n             stmts: stmts,\n             expr: expr,\n             id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span: span,\n-        })\n+        }\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n@@ -1953,9 +1962,9 @@ impl<'a> LoweringContext<'a> {\n     fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n         let mut v = Vec::new();\n         if let Some(s) = self.crate_root {\n-            v.push(token::intern(s));\n+            v.push(Symbol::intern(s));\n         }\n-        v.extend(components.iter().map(|s| token::intern(s)));\n+        v.extend(components.iter().map(|s| Symbol::intern(s)));\n         return v;\n     }\n \n@@ -1972,7 +1981,7 @@ impl<'a> LoweringContext<'a> {\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n-                         -> P<hir::Expr> {\n+                         -> hir::Expr {\n         let id = self.next_id();\n         let block = P(hir::Block {\n             rules: rule,\n@@ -1989,7 +1998,7 @@ impl<'a> LoweringContext<'a> {\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n-                         -> P<hir::Expr> {\n+                         -> hir::Expr {\n         let id = self.next_id();\n         let block = P(hir::Block {\n             rules: rule,"}, {"sha": "89217e83ca22eeaf3be3dd317a4c64553cb3f40d", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -9,9 +9,7 @@\n // except according to those terms.\n \n use super::*;\n-use super::MapEntry::*;\n \n-use hir::*;\n use hir::intravisit::Visitor;\n use hir::def_id::DefId;\n use middle::cstore::InlinedItem;"}, {"sha": "7486d954c480233fde7058411c821c964a26a25f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::*;\n+use hir::map::definitions::*;\n \n use hir;\n use hir::intravisit;\n@@ -19,7 +19,7 @@ use middle::cstore::InlinedItem;\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n@@ -169,7 +169,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n-                                    .unwrap_or_else(|| token::intern(&index.to_string()));\n+                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                                 this.create_def(field.id, DefPathData::Field(name.as_str()));\n                             }\n \n@@ -188,7 +188,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name.as_str())\n-                            .unwrap_or(token::intern(&index.to_string()).as_str());\n+                            .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n                         this.create_def(field.id, DefPathData::Field(name));\n                     }\n                 }"}, {"sha": "83d3627d8e61643e4b3b4f88ea56d40ef1fe0f8f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,7 +14,7 @@ use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n use syntax::ast;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n@@ -115,9 +115,9 @@ impl DefPath {\n     pub fn to_string(&self, tcx: TyCtxt) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n-        s.push_str(&tcx.original_crate_name(self.krate));\n+        s.push_str(&tcx.original_crate_name(self.krate).as_str());\n         s.push_str(\"/\");\n-        s.push_str(&tcx.crate_disambiguator(self.krate));\n+        s.push_str(&tcx.crate_disambiguator(self.krate).as_str());\n \n         for component in &self.data {\n             write!(s,\n@@ -137,8 +137,8 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.original_crate_name(self.krate).hash(state);\n-        tcx.crate_disambiguator(self.krate).hash(state);\n+        tcx.original_crate_name(self.krate).as_str().hash(state);\n+        tcx.crate_disambiguator(self.krate).as_str().hash(state);\n         self.data.hash(state);\n     }\n }\n@@ -328,7 +328,7 @@ impl DefPathData {\n             LifetimeDef(ref name) |\n             EnumVariant(ref name) |\n             Binding(ref name) |\n-            Field(ref name) => Some(token::intern(name)),\n+            Field(ref name) => Some(Symbol::intern(name)),\n \n             Impl |\n             CrateRoot |\n@@ -343,7 +343,7 @@ impl DefPathData {\n \n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n-        match *self {\n+        let s = match *self {\n             TypeNs(ref name) |\n             ValueNs(ref name) |\n             Module(ref name) |\n@@ -353,43 +353,24 @@ impl DefPathData {\n             EnumVariant(ref name) |\n             Binding(ref name) |\n             Field(ref name) => {\n-                name.clone()\n-            }\n-\n-            Impl => {\n-                InternedString::new(\"{{impl}}\")\n+                return name.clone();\n             }\n \n             // note that this does not show up in user printouts\n-            CrateRoot => {\n-                InternedString::new(\"{{root}}\")\n-            }\n+            CrateRoot => \"{{root}}\",\n \n             // note that this does not show up in user printouts\n-            InlinedRoot(_) => {\n-                InternedString::new(\"{{inlined-root}}\")\n-            }\n-\n-            Misc => {\n-                InternedString::new(\"{{?}}\")\n-            }\n-\n-            ClosureExpr => {\n-                InternedString::new(\"{{closure}}\")\n-            }\n-\n-            StructCtor => {\n-                InternedString::new(\"{{constructor}}\")\n-            }\n-\n-            Initializer => {\n-                InternedString::new(\"{{initializer}}\")\n-            }\n+            InlinedRoot(_) => \"{{inlined-root}}\",\n+\n+            Impl => \"{{impl}}\",\n+            Misc => \"{{?}}\",\n+            ClosureExpr => \"{{closure}}\",\n+            StructCtor => \"{{constructor}}\",\n+            Initializer => \"{{initializer}}\",\n+            ImplTrait => \"{{impl-Trait}}\",\n+        };\n \n-            ImplTrait => {\n-                InternedString::new(\"{{impl-Trait}}\")\n-            }\n-        }\n+        Symbol::intern(s).as_str()\n     }\n \n     pub fn to_string(&self) -> String {"}, {"sha": "a90577b34261c4e7c8338052aac83f4823511dda", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if &part[..] != mod_name.as_str() {\n+            if mod_name != &**part {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -803,8 +803,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == &self.item_name[..] &&\n-            self.suffix_matches(parent_of_n)\n+        name == &**self.item_name && self.suffix_matches(parent_of_n)\n     }\n }\n "}, {"sha": "31648765224254796ca75be5e292b5035ac9470b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -40,8 +40,8 @@ use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenTree;\n use syntax::util::ThinVec;\n \n@@ -867,12 +867,12 @@ pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprArray(HirVec<P<Expr>>),\n+    ExprArray(HirVec<Expr>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself (usually an `ExprPath`),\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, HirVec<P<Expr>>),\n+    ExprCall(P<Expr>, HirVec<Expr>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `Spanned<Name>` is the identifier for the method name.\n@@ -885,9 +885,9 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<Expr>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(HirVec<P<Expr>>),\n+    ExprTup(HirVec<Expr>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n@@ -908,7 +908,7 @@ pub enum Expr_ {\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Spanned<Name>>),\n+    ExprLoop(P<Block>, Option<Spanned<Name>>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n@@ -944,14 +944,14 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Spanned<Name>>),\n+    ExprBreak(Option<Spanned<Name>>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n     ExprAgain(Option<Spanned<Name>>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    ExprInlineAsm(P<InlineAsm>, HirVec<P<Expr>>, HirVec<P<Expr>>),\n+    ExprInlineAsm(P<InlineAsm>, HirVec<Expr>, HirVec<Expr>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n@@ -1002,6 +1002,18 @@ pub enum MatchSource {\n     TryDesugar,\n }\n \n+/// The loop type that yielded an ExprLoop\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LoopSource {\n+    /// A `loop { .. }` loop\n+    Loop,\n+    /// A `while let _ = _ { .. }` loop\n+    WhileLet,\n+    /// A `for _ in _ { .. }` loop\n+    ForLoop,\n+}\n+\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -1163,18 +1175,18 @@ pub enum Ty_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n-    pub constraint: InternedString,\n+    pub constraint: Symbol,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n-    pub asm: InternedString,\n+    pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n     pub outputs: HirVec<InlineAsmOutput>,\n-    pub inputs: HirVec<InternedString>,\n-    pub clobbers: HirVec<InternedString>,\n+    pub inputs: HirVec<Symbol>,\n+    pub clobbers: HirVec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,"}, {"sha": "c109e84bf6186a65ee7b224d962e5d3b982b6a31", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -13,13 +13,14 @@ pub use self::AnnNode::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::token::{self, keywords, BinOpToken};\n+use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, BytePos};\n use errors;\n \n@@ -451,7 +452,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n@@ -1199,7 +1200,7 @@ impl<'a> State<'a> {\n     }\n \n \n-    fn print_call_post(&mut self, args: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_call_post(&mut self, args: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n         self.commasep_exprs(Inconsistent, args)?;\n         self.pclose()\n@@ -1217,10 +1218,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_vec(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         word(&mut self.s, \"[\")?;\n-        self.commasep_exprs(Inconsistent, &exprs[..])?;\n+        self.commasep_exprs(Inconsistent, exprs)?;\n         word(&mut self.s, \"]\")?;\n         self.end()\n     }\n@@ -1273,24 +1274,24 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_tup(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n-        self.commasep_exprs(Inconsistent, &exprs[..])?;\n+        self.commasep_exprs(Inconsistent, exprs)?;\n         if exprs.len() == 1 {\n             word(&mut self.s, \",\")?;\n         }\n         self.pclose()\n     }\n \n-    fn print_expr_call(&mut self, func: &hir::Expr, args: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n         self.print_expr_maybe_paren(func)?;\n         self.print_call_post(args)\n     }\n \n     fn print_expr_method_call(&mut self,\n                               name: Spanned<ast::Name>,\n                               tys: &[P<hir::Ty>],\n-                              args: &[P<hir::Expr>])\n+                              args: &[hir::Expr])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n@@ -1339,7 +1340,7 @@ impl<'a> State<'a> {\n                 self.print_expr(expr)?;\n             }\n             hir::ExprArray(ref exprs) => {\n-                self.print_expr_vec(&exprs[..])?;\n+                self.print_expr_vec(exprs)?;\n             }\n             hir::ExprRepeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, &count)?;\n@@ -1348,13 +1349,13 @@ impl<'a> State<'a> {\n                 self.print_expr_struct(path, &fields[..], wth)?;\n             }\n             hir::ExprTup(ref exprs) => {\n-                self.print_expr_tup(&exprs[..])?;\n+                self.print_expr_tup(exprs)?;\n             }\n             hir::ExprCall(ref func, ref args) => {\n-                self.print_expr_call(&func, &args[..])?;\n+                self.print_expr_call(&func, args)?;\n             }\n             hir::ExprMethodCall(name, ref tys, ref args) => {\n-                self.print_expr_method_call(name, &tys[..], &args[..])?;\n+                self.print_expr_method_call(name, &tys[..], args)?;\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n                 self.print_expr_binary(op, &lhs, &rhs)?;\n@@ -1392,7 +1393,7 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_sp_name) => {\n+            hir::ExprLoop(ref blk, opt_sp_name, _) => {\n                 if let Some(sp_name) = opt_sp_name {\n                     self.print_name(sp_name.node)?;\n                     self.word_space(\":\")?;\n@@ -1470,13 +1471,17 @@ impl<'a> State<'a> {\n             hir::ExprPath(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n             }\n-            hir::ExprBreak(opt_name) => {\n+            hir::ExprBreak(opt_name, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n                 if let Some(name) = opt_name {\n                     self.print_name(name.node)?;\n                     space(&mut self.s)?;\n                 }\n+                if let Some(ref expr) = *opt_expr {\n+                    self.print_expr(expr)?;\n+                    space(&mut self.s)?;\n+                }\n             }\n             hir::ExprAgain(opt_name) => {\n                 word(&mut self.s, \"continue\")?;\n@@ -1499,19 +1504,19 @@ impl<'a> State<'a> {\n             hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n                 word(&mut self.s, \"asm!\")?;\n                 self.popen()?;\n-                self.print_string(&a.asm, a.asm_str_style)?;\n+                self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n \n                 let mut out_idx = 0;\n                 self.commasep(Inconsistent, &a.outputs, |s, out| {\n-                    let mut ch = out.constraint.chars();\n+                    let constraint = out.constraint.as_str();\n+                    let mut ch = constraint.chars();\n                     match ch.next() {\n                         Some('=') if out.is_rw => {\n                             s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked)?\n                         }\n-                        _ => s.print_string(&out.constraint,\n-                                            ast::StrStyle::Cooked)?,\n+                        _ => s.print_string(&constraint, ast::StrStyle::Cooked)?,\n                     }\n                     s.popen()?;\n                     s.print_expr(&outputs[out_idx])?;\n@@ -1524,7 +1529,7 @@ impl<'a> State<'a> {\n \n                 let mut in_idx = 0;\n                 self.commasep(Inconsistent, &a.inputs, |s, co| {\n-                    s.print_string(&co, ast::StrStyle::Cooked)?;\n+                    s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     s.popen()?;\n                     s.print_expr(&inputs[in_idx])?;\n                     s.pclose()?;\n@@ -1535,7 +1540,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, co| {\n-                    s.print_string(&co, ast::StrStyle::Cooked)?;\n+                    s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     Ok(())\n                 })?;\n "}, {"sha": "8db09d0b73d32485d1e2ba0f48f56e26f4a48a4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -91,8 +91,8 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -1219,7 +1219,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::intern(&names[0]);\n+            let name = Symbol::intern(&names[0]);\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1931,7 +1931,7 @@ impl LifeGiver {\n             let mut s = String::from(\"'\");\n             s.push_str(&num_to_string(self.counter.get()));\n             if !self.taken.contains(&s) {\n-                lifetime = name_to_dummy_lifetime(token::intern(&s[..]));\n+                lifetime = name_to_dummy_lifetime(Symbol::intern(&s));\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "0942ce79a6b49787e209d8f1ac348c13d22f9649", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -33,6 +33,7 @@\n #![feature(core_intrinsics)]\n #![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(enumset)]\n+#![cfg_attr(stage0, feature(item_like_imports))]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(quote)]"}, {"sha": "96aee04b6b7ab826f172d3d390378e52992b9d82", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -157,7 +157,7 @@ declare_lint! {\n \n declare_lint! {\n     pub HR_LIFETIME_IN_ASSOC_TYPE,\n-    Warn,\n+    Deny,\n     \"binding for associated type references higher-ranked lifetime \\\n      that does not appear in the trait input types\"\n }\n@@ -204,6 +204,13 @@ declare_lint! {\n     \"detects extra requirements in impls that were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub LEGACY_DIRECTORY_OWNERSHIP,\n+    Warn,\n+    \"non-inline, non-`#[path]` modules (e.g. `mod foo;`) were erroneously allowed in some files \\\n+     not named `mod.rs`\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -242,7 +249,8 @@ impl LintPass for HardwiredLints {\n             LIFETIME_UNDERSCORE,\n             SAFE_EXTERN_STATICS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n-            EXTRA_REQUIREMENT_IN_IMPL\n+            EXTRA_REQUIREMENT_IN_IMPL,\n+            LEGACY_DIRECTORY_OWNERSHIP\n         )\n     }\n }"}, {"sha": "4a082944010b2838fb73d12cc26d84f9d7bea0eb", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -40,7 +40,6 @@ use std::default::Default as StdDefault;\n use std::mem;\n use std::fmt;\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax_pos::{MultiSpan, Span};\n use errors::{self, Diagnostic, DiagnosticBuilder};\n@@ -384,8 +383,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess.\n // See also the hir version just below.\n-pub fn gather_attrs(attrs: &[ast::Attribute])\n-                    -> Vec<Result<(InternedString, Level, Span), Span>> {\n+pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n     for attr in attrs {\n         let r = gather_attr(attr);\n@@ -394,18 +392,17 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n     out\n }\n \n-pub fn gather_attr(attr: &ast::Attribute)\n-                   -> Vec<Result<(InternedString, Level, Span), Span>> {\n+pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n \n-    let level = match Level::from_str(&attr.name()) {\n+    let level = match Level::from_str(&attr.name().as_str()) {\n         None => return out,\n         Some(lvl) => lvl,\n     };\n \n     attr::mark_used(attr);\n \n-    let meta = &attr.node.value;\n+    let meta = &attr.value;\n     let metas = if let Some(metas) = meta.meta_item_list() {\n         metas\n     } else {\n@@ -414,9 +411,7 @@ pub fn gather_attr(attr: &ast::Attribute)\n     };\n \n     for li in metas {\n-        out.push(li.word().map_or(Err(li.span), |word| {\n-            Ok((word.name().clone(), level, word.span))\n-        }));\n+        out.push(li.word().map_or(Err(li.span), |word| Ok((word.name(), level, word.span))));\n     }\n \n     out\n@@ -629,10 +624,10 @@ pub trait LintContext: Sized {\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name, &self.sess(), Some(span)) {\n+                    match self.lints().find_lint(&lint_name.as_str(), &self.sess(), Some(span)) {\n                         Ok(lint_id) => vec![(lint_id, level, span)],\n                         Err(FindLintError::NotFound) => {\n-                            match self.lints().lint_groups.get(&lint_name[..]) {\n+                            match self.lints().lint_groups.get(&*lint_name.as_str()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -1193,8 +1188,7 @@ fn check_lint_name_attribute(cx: &LateContext, attr: &ast::Attribute) {\n                 continue;\n             }\n             Ok((lint_name, _, span)) => {\n-                match check_lint_name(&cx.lints,\n-                                      &lint_name[..]) {\n+                match check_lint_name(&cx.lints, &lint_name.as_str()) {\n                     CheckLintNameResult::Ok => (),\n                     CheckLintNameResult::Warning(ref msg) => {\n                         cx.span_lint(builtin::RENAMED_AND_REMOVED_LINTS,"}, {"sha": "9677082a43a3c2d03dcef9faa383e804abc54c8b", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n use hir::def_id::DefId;"}, {"sha": "a7f28dd6d58c4009711d14d1cefdafc1b47761ef", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -39,7 +39,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n@@ -52,16 +52,17 @@ pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub crate_hash: Svh,\n }\n \n-// Where a crate came from on the local filesystem. One of these two options\n+// Where a crate came from on the local filesystem. One of these three options\n // must be non-None.\n #[derive(PartialEq, Clone, Debug)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n+    pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n@@ -76,6 +77,30 @@ pub enum DepKind {\n     Explicit,\n }\n \n+#[derive(PartialEq, Clone, Debug)]\n+pub enum LibSource {\n+    Some(PathBuf),\n+    MetadataOnly,\n+    None,\n+}\n+\n+impl LibSource {\n+    pub fn is_some(&self) -> bool {\n+        if let LibSource::Some(_) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn option(&self) -> Option<PathBuf> {\n+        match *self {\n+            LibSource::Some(ref p) => Some(p.clone()),\n+            LibSource::MetadataOnly | LibSource::None => None,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n@@ -92,8 +117,8 @@ pub enum NativeLibraryKind {\n #[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n-    pub name: String,\n-    pub cfg: Option<P<ast::MetaItem>>,\n+    pub name: Symbol,\n+    pub cfg: Option<ast::MetaItem>,\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -205,11 +230,11 @@ pub trait CrateStore<'tcx> {\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n@@ -244,7 +269,7 @@ pub trait CrateStore<'tcx> {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -375,13 +400,13 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"panic_strategy\")\n     }\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol {\n         bug!(\"original_crate_name\")\n     }\n     fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n     fn crate_disambiguator(&self, cnum: CrateNum)\n-                           -> InternedString { bug!(\"crate_disambiguator\") }\n+                           -> Symbol { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n@@ -427,7 +452,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }"}, {"sha": "f47eab013c2b216a4789e40e54d1031c10132340", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -309,8 +309,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n     for attr in lint::gather_attrs(attrs) {\n         match attr {\n-            Ok((ref name, lint::Allow, _))\n-                if &name[..] == dead_code => return true,\n+            Ok((name, lint::Allow, _)) if name == &*dead_code => return true,\n             _ => (),\n         }\n     }\n@@ -499,8 +498,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                       span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str) {\n-        let name = name.as_str();\n-        if !name.starts_with(\"_\") {\n+        if !name.as_str().starts_with(\"_\") {\n             self.tcx\n                 .sess\n                 .add_lint(lint::builtin::DEAD_CODE,"}, {"sha": "ee7f13f9e6e2266ddfafe6e0aa8b4dc629e6b560", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -114,7 +114,7 @@ fn calculate_type(sess: &session::Session,\n \n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n-        config::CrateTypeRlib => return Vec::new(),\n+        config::CrateTypeRlib | config::CrateTypeMetadata => return Vec::new(),\n \n         // Staticlibs and cdylibs must have all static dependencies. If any fail\n         // to be found, we generate some nice pretty errors.\n@@ -192,7 +192,7 @@ fn calculate_type(sess: &session::Session,\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n            sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n-            assert!(src.rlib.is_some());\n+            assert!(src.rlib.is_some() || src.rmeta.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n             ret[cnum.as_usize() - 1] = Linkage::Static;"}, {"sha": "65aedae347a8d0cd4538f6d824f1c7d495448e35", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -92,7 +92,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.name.as_str() == \"main\" {\n+            } else if item.name == \"main\" {\n                 if at_root {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "594ed408d8cd48efed2a73c9c87873d96f384e4c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n+    fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n         for expr in exprs {\n             self.consume_expr(&expr);\n         }\n@@ -472,11 +472,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(inputs);\n             }\n \n-            hir::ExprBreak(..) |\n             hir::ExprAgain(..) |\n             hir::ExprLit(..) => {}\n \n-            hir::ExprLoop(ref blk, _) => {\n+            hir::ExprLoop(ref blk, _, _) => {\n                 self.walk_block(&blk);\n             }\n \n@@ -514,7 +513,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprRet(ref opt_expr) => {\n+            hir::ExprBreak(_, ref opt_expr) | hir::ExprRet(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&expr);\n                 }"}, {"sha": "80cf64865abea7043ded3f20e2c5575c52a85d49", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n+        intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>, id: ast::NodeId) {"}, {"sha": "5af9a2f02742effbe3d4a5663a4fd177b654a7ed", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -30,7 +30,7 @@ use middle::weak_lang_items;\n use util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir;\n \n@@ -152,15 +152,15 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n-            let item_index = self.item_refs.get(&value[..]).cloned();\n+            let item_index = self.item_refs.get(&*value.as_str()).cloned();\n \n             if let Some(item_index) = item_index {\n                 self.collect_item(item_index, self.ast_map.local_def_id(item.id))\n             } else {\n                 let span = self.ast_map.span(item.id);\n                 span_err!(self.session, span, E0522,\n                           \"definition of an unknown language item: `{}`.\",\n-                          &value[..]);\n+                          value);\n             }\n         }\n     }\n@@ -243,12 +243,10 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n }\n \n-pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     for attribute in attrs {\n         match attribute.value_str() {\n-            Some(ref value) if attribute.check_name(\"lang\") => {\n-                return Some(value.clone());\n-            }\n+            Some(value) if attribute.check_name(\"lang\") => return Some(value),\n             _ => {}\n         }\n     }"}, {"sha": "4b1787ba593cbcae173ec7b63239e4293e3c2983", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -123,8 +123,7 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::parse::token::keywords;\n-use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use hir::Expr;\n@@ -491,7 +490,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n       hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n       hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n-      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(_) |\n+      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n       hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n@@ -902,7 +901,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.define_bindings_in_pat(&local.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[P<Expr>], succ: LiveNode)\n+    fn propagate_through_exprs(&mut self, exprs: &[Expr], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n             self.propagate_through_expr(&expr, succ)\n@@ -991,7 +990,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          hir::ExprLoop(ref blk, _) => {\n+          hir::ExprLoop(ref blk, _, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n           }\n \n@@ -1036,15 +1035,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(opt_label) => {\n+          hir::ExprBreak(opt_label, ref opt_expr) => {\n               // Find which label this break jumps to\n               let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n               match self.break_ln.get(&sc) {\n-                  Some(&b) => b,\n+                  Some(&b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n                   None => span_bug!(expr.span, \"break to unknown label\")\n               }\n           }\n@@ -1058,7 +1057,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n               match self.cont_ln.get(&sc) {\n                   Some(&b) => b,\n-                  None => span_bug!(expr.span, \"loop to unknown label\")\n+                  None => span_bug!(expr.span, \"continue to unknown label\")\n               }\n           }\n \n@@ -1087,7 +1086,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           hir::ExprArray(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[..], succ)\n+            self.propagate_through_exprs(exprs, succ)\n           }\n \n           hir::ExprRepeat(ref element, ref count) => {\n@@ -1111,7 +1110,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(&args[..], succ);\n+            let succ = self.propagate_through_exprs(args, succ);\n             self.propagate_through_expr(&f, succ)\n           }\n \n@@ -1124,11 +1123,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(&args[..], succ)\n+            self.propagate_through_exprs(args, succ)\n           }\n \n           hir::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[..], succ)\n+            self.propagate_through_exprs(exprs, succ)\n           }\n \n           hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {"}, {"sha": "35e0e494771ba131a46b6a488beb2b7a5147e823", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n-            *ty == config::CrateTypeProcMacro\n+            *ty == config::CrateTypeProcMacro || *ty == config::CrateTypeMetadata\n         });\n         ReachableContext {\n             tcx: tcx,"}, {"sha": "7f89461a3f4b6823718ec24788f9f06381747f6d", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -25,7 +25,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n         }\n \n         if let Some(s) = attr.value_str() {\n-            if let Some(n) = s.parse().ok() {\n+            if let Some(n) = s.as_str().parse().ok() {\n                 sess.recursion_limit.set(n);\n                 return;\n             }"}, {"sha": "0dbde2d21caf5607bd145920a88874abe85407f3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -805,7 +805,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n                 terminating(then.id);\n             }\n \n-            hir::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _, _) => {\n                 terminating(body.id);\n             }\n "}, {"sha": "41da5562e23fa4f488bda5112ba63367fa810284", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -27,7 +27,7 @@ use middle::region;\n use ty;\n use std::mem::replace;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use util::nodemap::NodeMap;\n \n@@ -462,7 +462,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n             hir::ExprWhile(.., Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some((label.node, label.span)),\n+            hir::ExprLoop(_, Some(label), _) => Some((label.node, label.span)),\n             _ => None,\n         }\n     }"}, {"sha": "86a89eff3a476a9cd5c54a8432250738ba642a2d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -21,7 +21,7 @@ use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n@@ -36,7 +36,6 @@ use hir::pat_util::EnumerateAndAdjustIterator;\n \n use std::mem::replace;\n use std::cmp::Ordering;\n-use std::ops::Deref;\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Copy, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n@@ -151,10 +150,11 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n \n                 // Check if deprecated_since < stable_since. If it is,\n                 // this is *almost surely* an accident.\n-                if let (&Some(attr::RustcDeprecation {since: ref dep_since, ..}),\n-                        &attr::Stable {since: ref stab_since}) = (&stab.rustc_depr, &stab.level) {\n+                if let (&Some(attr::RustcDeprecation {since: dep_since, ..}),\n+                        &attr::Stable {since: stab_since}) = (&stab.rustc_depr, &stab.level) {\n                     // Explicit version of iter::order::lt to handle parse errors properly\n-                    for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n+                    for (dep_v, stab_v) in\n+                            dep_since.as_str().split(\".\").zip(stab_since.as_str().split(\".\")) {\n                         if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n                             match dep_v.cmp(&stab_v) {\n                                 Ordering::Less => {\n@@ -356,7 +356,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FxHashMap<InternedString, attr::StabilityLevel> {\n+                                          -> FxHashMap<Symbol, attr::StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -376,8 +376,8 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FxHashSet<InternedString>,\n-    used_features: FxHashMap<InternedString, attr::StabilityLevel>,\n+    active_features: FxHashSet<Symbol>,\n+    used_features: FxHashMap<Symbol, attr::StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -407,10 +407,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 if !self.active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                               &feature, &r),\n+                                               &feature.as_str(), &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n-                    emit_feature_err(&self.tcx.sess.parse_sess, &feature, span,\n+                    emit_feature_err(&self.tcx.sess.parse_sess, &feature.as_str(), span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n@@ -735,18 +735,18 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FxHashMap<InternedString,\n+                                       lib_features_used: &FxHashMap<Symbol,\n                                                                      attr::StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n-    let mut remaining_lib_features: FxHashMap<InternedString, Span>\n+    let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n \n     fn format_stable_since_msg(version: &str) -> String {\n         format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n     }\n \n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n-        let version = find_lang_feature_accepted_version(stable_lang_feature.deref())\n+        let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n         sess.add_lint(lint::builtin::STABLE_FEATURES,\n                       ast::CRATE_NODE_ID,\n@@ -761,7 +761,7 @@ pub fn check_unused_or_stable_features(sess: &Session,\n                     sess.add_lint(lint::builtin::STABLE_FEATURES,\n                                   ast::CRATE_NODE_ID,\n                                   span,\n-                                  format_stable_since_msg(version.deref()));\n+                                  format_stable_since_msg(&version.as_str()));\n                 }\n             }\n             None => ( /* used but undeclared, handled during the previous ast visit */ )"}, {"sha": "30690c099194f644308b86cff6153a9a8f7a311e", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,7 +16,7 @@ use middle::lang_items;\n \n use rustc_back::PanicStrategy;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use hir::intravisit::Visitor;\n use hir::intravisit;\n@@ -55,10 +55,10 @@ pub fn check_crate(krate: &hir::Crate,\n     verify(sess, items);\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     lang_items::extract(attrs).and_then(|name| {\n-        $(if &name[..] == stringify!($name) {\n-            Some(InternedString::new(stringify!($sym)))\n+        $(if name == stringify!($name) {\n+            Some(Symbol::intern(stringify!($sym)))\n         } else)* {\n             None\n         }\n@@ -75,7 +75,8 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n             config::CrateTypeCdylib |\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib => true,\n-            config::CrateTypeRlib => false,\n+            config::CrateTypeRlib |\n+            config::CrateTypeMetadata => false,\n         }\n     });\n     if !needs_check {\n@@ -126,7 +127,7 @@ impl<'a> Context<'a> {\n impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some(lang_item) = lang_items::extract(&i.attrs) {\n-            self.register(&lang_item, i.span);\n+            self.register(&lang_item.as_str(), i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "f3677b8081953a2013543967cdf246b8247356e9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -25,9 +25,8 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::attr;\n use syntax::parse;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax::feature_gate::UnstableFeatures;\n \n use errors::{ColorConfig, FatalError, Handler};\n@@ -41,6 +40,7 @@ use std::collections::btree_map::Values as BTreeMapValuesIter;\n use std::fmt;\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n+use std::collections::HashSet;\n use std::iter::FromIterator;\n use std::path::PathBuf;\n \n@@ -78,18 +78,6 @@ pub enum OutputType {\n     DepInfo,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum ErrorOutputType {\n-    HumanReadable(ColorConfig),\n-    Json,\n-}\n-\n-impl Default for ErrorOutputType {\n-    fn default() -> ErrorOutputType {\n-        ErrorOutputType::HumanReadable(ColorConfig::Auto)\n-    }\n-}\n-\n impl OutputType {\n     fn is_compatible_with_codegen_units_and_single_output_file(&self) -> bool {\n         match *self {\n@@ -125,6 +113,18 @@ impl OutputType {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum ErrorOutputType {\n+    HumanReadable(ColorConfig),\n+    Json,\n+}\n+\n+impl Default for ErrorOutputType {\n+    fn default() -> ErrorOutputType {\n+        ErrorOutputType::HumanReadable(ColorConfig::Auto)\n+    }\n+}\n+\n // Use tree-based collections to cheaply get a deterministic Hash implementation.\n // DO NOT switch BTreeMap out for an unsorted container type! That would break\n // dependency tracking for commandline arguments.\n@@ -483,6 +483,7 @@ pub enum CrateType {\n     CrateTypeStaticlib,\n     CrateTypeCdylib,\n     CrateTypeProcMacro,\n+    CrateTypeMetadata,\n }\n \n #[derive(Clone, Hash)]\n@@ -927,8 +928,6 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n-    use syntax::parse::token::intern_and_get_ident as intern;\n-\n     let end = &sess.target.target.target_endian;\n     let arch = &sess.target.target.arch;\n     let wordsz = &sess.target.target.target_pointer_width;\n@@ -938,55 +937,46 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let max_atomic_width = sess.target.target.max_atomic_width();\n \n     let fam = if let Some(ref fam) = sess.target.target.options.target_family {\n-        intern(fam)\n+        Symbol::intern(fam)\n     } else if sess.target.target.options.is_like_windows {\n-        InternedString::new(\"windows\")\n+        Symbol::intern(\"windows\")\n     } else {\n-        InternedString::new(\"unix\")\n+        Symbol::intern(\"unix\")\n     };\n \n-    let mk = attr::mk_name_value_item_str;\n-    let mut ret = vec![ // Target bindings.\n-        mk(InternedString::new(\"target_os\"), intern(os)),\n-        mk(InternedString::new(\"target_family\"), fam.clone()),\n-        mk(InternedString::new(\"target_arch\"), intern(arch)),\n-        mk(InternedString::new(\"target_endian\"), intern(end)),\n-        mk(InternedString::new(\"target_pointer_width\"), intern(wordsz)),\n-        mk(InternedString::new(\"target_env\"), intern(env)),\n-        mk(InternedString::new(\"target_vendor\"), intern(vendor)),\n-    ];\n-    match &fam[..] {\n-        \"windows\" | \"unix\" => ret.push(attr::mk_word_item(fam)),\n-        _ => (),\n+    let mut ret = HashSet::new();\n+    // Target bindings.\n+    ret.insert((Symbol::intern(\"target_os\"), Some(Symbol::intern(os))));\n+    ret.insert((Symbol::intern(\"target_family\"), Some(fam)));\n+    ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n+    ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n+    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n+    ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n+    ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n+    if fam == \"windows\" || fam == \"unix\" {\n+        ret.insert((fam, None));\n     }\n     if sess.target.target.options.has_elf_tls {\n-        ret.push(attr::mk_word_item(InternedString::new(\"target_thread_local\")));\n+        ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(&s)));\n+            ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(&s))));\n             if &s == wordsz {\n-                ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(\"ptr\")));\n+                ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(\"ptr\"))));\n             }\n         }\n     }\n     if sess.opts.debug_assertions {\n-        ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n+        ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }\n     if sess.opts.crate_types.contains(&CrateTypeProcMacro) {\n-        ret.push(attr::mk_word_item(InternedString::new(\"proc_macro\")));\n+        ret.insert((Symbol::intern(\"proc_macro\"), None));\n     }\n     return ret;\n }\n \n-pub fn append_configuration(cfg: &mut ast::CrateConfig,\n-                            name: InternedString) {\n-    if !cfg.iter().any(|mi| mi.name() == name) {\n-        cfg.push(attr::mk_word_item(name))\n-    }\n-}\n-\n pub fn build_configuration(sess: &Session,\n                            mut user_cfg: ast::CrateConfig)\n                            -> ast::CrateConfig {\n@@ -995,11 +985,10 @@ pub fn build_configuration(sess: &Session,\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n-        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n+        user_cfg.insert((Symbol::intern(\"test\"), None));\n     }\n-    let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.extend_from_slice(&default_cfg[..]);\n-    v\n+    user_cfg.extend(default_cfg.iter().cloned());\n+    user_cfg\n }\n \n pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n@@ -1159,7 +1148,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              assumed.\", \"[KIND=]NAME\"),\n         opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n-                   \"[bin|lib|rlib|dylib|cdylib|staticlib]\"),\n+                   \"[bin|lib|rlib|dylib|cdylib|staticlib|metadata]\"),\n         opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n         opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\\n@@ -1245,11 +1234,14 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n         let meta_item = panictry!(parser.parse_meta_item());\n \n         if !parser.reader.is_eof() {\n-            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\",\n-                                                             s))\n+            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\", s))\n+        } else if meta_item.is_meta_item_list() {\n+            let msg =\n+                format!(\"invalid predicate in --cfg command line argument: `{}`\", meta_item.name());\n+            early_error(ErrorOutputType::default(), &msg)\n         }\n \n-        meta_item\n+        (meta_item.name(), meta_item.value_str())\n     }).collect::<ast::CrateConfig>()\n }\n \n@@ -1548,6 +1540,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n                 \"cdylib\"    => CrateTypeCdylib,\n                 \"bin\"       => CrateTypeExecutable,\n                 \"proc-macro\" => CrateTypeProcMacro,\n+                \"metadata\"  => CrateTypeMetadata,\n                 _ => {\n                     return Err(format!(\"unknown crate type: `{}`\",\n                                        part));\n@@ -1632,6 +1625,7 @@ impl fmt::Display for CrateType {\n             CrateTypeStaticlib => \"staticlib\".fmt(f),\n             CrateTypeCdylib => \"cdylib\".fmt(f),\n             CrateTypeProcMacro => \"proc-macro\".fmt(f),\n+            CrateTypeMetadata => \"metadata\".fmt(f),\n         }\n     }\n }\n@@ -1773,9 +1767,7 @@ mod tests {\n     use std::rc::Rc;\n     use super::{OutputType, OutputTypes, Externs};\n     use rustc_back::PanicStrategy;\n-    use syntax::{ast, attr};\n-    use syntax::parse::token::InternedString;\n-    use syntax::codemap::dummy_spanned;\n+    use syntax::symbol::Symbol;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n@@ -1804,9 +1796,7 @@ mod tests {\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        assert!(attr::contains(&cfg, &dummy_spanned(ast::MetaItemKind::Word({\n-            InternedString::new(\"test\")\n-        }))));\n+        assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1827,7 +1817,7 @@ mod tests {\n         let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n+        let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n     }"}, {"sha": "9577a25b3f83099769a13165d522c3915c287a55", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -28,7 +28,7 @@ use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{Span, MultiSpan};\n@@ -89,7 +89,7 @@ pub struct Session {\n     // forms a unique global identifier for the crate. It is used to allow\n     // multiple crates with the same name to coexist. See the\n     // trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: RefCell<token::InternedString>,\n+    pub crate_disambiguator: RefCell<Symbol>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -129,8 +129,8 @@ pub struct PerfStats {\n }\n \n impl Session {\n-    pub fn local_crate_disambiguator(&self) -> token::InternedString {\n-        self.crate_disambiguator.borrow().clone()\n+    pub fn local_crate_disambiguator(&self) -> Symbol {\n+        *self.crate_disambiguator.borrow()\n     }\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n@@ -610,7 +610,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),\n-        crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n+        crate_disambiguator: RefCell::new(Symbol::intern(\"\")),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(NodeId::new(1)),"}, {"sha": "21009711cb18ae61a17cf486142d75a5d6b609f8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -246,12 +246,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n                 let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n-                if let Some(ref istring) = item.value_str() {\n+                if let Some(istring) = item.value_str() {\n+                    let istring = &*istring.as_str();\n                     let generic_map = def.generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n                     }).collect::<FxHashMap<String, String>>();\n-                    let parser = Parser::new(&istring);\n+                    let parser = Parser::new(istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {\n                         match p {"}, {"sha": "76bead99343a7f01daa0b586ce348c2fcdcd7483", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -26,8 +26,8 @@ use super::util;\n use hir::def_id::DefId;\n use infer::InferOk;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use syntax::parse::token;\n use syntax::ast;\n+use syntax::symbol::Symbol;\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -1245,7 +1245,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n         projection_ty: ty::ProjectionTy {\n             trait_ref: trait_ref,\n-            item_name: token::intern(FN_OUTPUT_NAME),\n+            item_name: Symbol::intern(FN_OUTPUT_NAME),\n         },\n         ty: ret_type\n     });"}, {"sha": "20855c46b68002453844f0b2169ba979b4d242cf", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -49,7 +49,7 @@ use std::rc::Rc;\n use std::iter;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n \n use hir;\n \n@@ -561,7 +561,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n-    pub crate_name: token::InternedString,\n+    pub crate_name: Symbol,\n \n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n@@ -574,7 +574,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map from function to the `#[derive]` mode that it's defining. Only used\n     /// by `proc-macro` crates.\n-    pub derive_macros: RefCell<NodeMap<token::InternedString>>,\n+    pub derive_macros: RefCell<NodeMap<Symbol>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -588,23 +588,23 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n-            self.crate_name.clone()\n+            self.crate_name\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn original_crate_name(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn original_crate_name(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.original_crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -835,7 +835,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n-            crate_name: token::intern_and_get_ident(crate_name),\n+            crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),"}, {"sha": "b93a8698f603c1196a130ca4e1041b55ea1c7afd", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -12,7 +12,7 @@ use hir::map::DefPathData;\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use std::cell::Cell;\n \n@@ -94,14 +94,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(extern_crate_def_id) = opt_extern_crate {\n                         self.push_item_path(buffer, extern_crate_def_id);\n                     } else {\n-                        buffer.push(&self.crate_name(cnum));\n+                        buffer.push(&self.crate_name(cnum).as_str());\n                     }\n                 }\n             }\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                buffer.push(&self.original_crate_name(cnum));\n+                buffer.push(&self.original_crate_name(cnum).as_str());\n             }\n         }\n     }\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return true;\n                     }\n                     None => {\n-                        buffer.push(&self.crate_name(cur_def.krate));\n+                        buffer.push(&self.crate_name(cur_def.krate).as_str());\n                         cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n                         return true;\n                     }\n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             cur_path.push(self.sess.cstore.def_key(cur_def)\n                               .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n-                token::intern(\"<unnamed>\")));\n+                Symbol::intern(\"<unnamed>\")));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n                 None => return false,"}, {"sha": "e94e93158c47a2de9d3f2b8e464fdb10a1c78e82", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -44,7 +44,7 @@ use std::vec::IntoIter;\n use std::mem;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n@@ -2344,7 +2344,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else if id.index == CRATE_DEF_INDEX {\n-            token::intern(&self.sess.cstore.original_crate_name(id.krate))\n+            self.sess.cstore.original_crate_name(id.krate)\n         } else {\n             let def_key = self.sess.cstore.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n@@ -2747,7 +2747,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, InternedString> {\n+    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))"}, {"sha": "81896ecfb53411446b42aa2bc17e7b5ab70f4f76", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::{keywords, InternedString};\n+use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n "}, {"sha": "e01856b2a476265b161671e78b5760d249e545ae", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,10 +19,6 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n-use hir;\n-use hir::intravisit;\n-use hir::intravisit::Visitor;\n-\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -186,57 +182,6 @@ pub fn indenter() -> Indenter {\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n \n-struct LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> bool {\n-    p: P,\n-    flag: bool,\n-}\n-\n-impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> bool {\n-    fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.flag |= (self.p)(&e.node);\n-        match e.node {\n-          // Skip inner loops, since a break in the inner loop isn't a\n-          // break inside the outer loop\n-          hir::ExprLoop(..) | hir::ExprWhile(..) => {}\n-          _ => intravisit::walk_expr(self, e)\n-        }\n-    }\n-}\n-\n-// Takes a predicate p, returns true iff p is true for any subexpressions\n-// of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr_) -> bool {\n-    let mut v = LoopQueryVisitor {\n-        p: p,\n-        flag: false,\n-    };\n-    intravisit::walk_block(&mut v, b);\n-    return v.flag;\n-}\n-\n-struct BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n-    p: P,\n-    flag: bool,\n-}\n-\n-impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n-    fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.flag |= (self.p)(e);\n-        intravisit::walk_expr(self, e)\n-    }\n-}\n-\n-// Takes a predicate p, returns true iff p is true for any subexpressions\n-// of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -> bool {\n-    let mut v = BlockQueryVisitor {\n-        p: p,\n-        flag: false,\n-    };\n-    intravisit::walk_block(&mut v, &b);\n-    return v.flag;\n-}\n-\n pub trait MemoizationMap {\n     type Key: Clone;\n     type Value: Clone;"}, {"sha": "d04825d560444facbc47d19960a4fb9b0b26f306", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -25,8 +25,8 @@ use std::fmt;\n use std::usize;\n \n use syntax::abi::Abi;\n-use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n+use syntax::symbol::Symbol;\n use hir;\n \n pub fn verbose() -> bool {\n@@ -284,7 +284,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrAnon(_) |\n             ty::BrFresh(_) |\n             ty::BrEnv => {\n-                let name = token::intern(\"'r\");\n+                let name = Symbol::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n                 ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID),\n                             name,"}, {"sha": "916d17dcc91deff5b598dd9d7f5f7dab7a3c915b", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -169,7 +169,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 {\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        if name.as_str() == \"rustc_peek\" {\n+                        if name == \"rustc_peek\" {\n                             return Some((args, source_info.span));\n                         }\n                     }"}, {"sha": "9035c2ab3c236e05cf85fb26813a69dab174bbee", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,7 +11,6 @@\n use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n-use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n@@ -35,7 +34,7 @@ use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n use self::gather_moves::{MoveData, MovePathIndex, LookupResult};\n \n-fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n+fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n     for attr in attrs {\n         if attr.check_name(\"rustc_mir\") {\n             let items = attr.meta_item_list();"}, {"sha": "b594fe9853a43ac35a2b5bf8ca247300fd18fdde", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -297,7 +297,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => bug!()\n             };\n             let pats = args.iter()\n-                           .map(|expr| const_expr_to_pat(tcx, &**expr, pat_id, span))\n+                           .map(|expr| const_expr_to_pat(tcx, &*expr, pat_id, span))\n                            .collect::<Result<_, _>>()?;\n             PatKind::TupleStruct(path, pats, None)\n         }\n@@ -1221,7 +1221,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n-        LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n+        LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n@@ -1249,15 +1249,15 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n             infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n-        LitKind::Float(ref n, fty) => {\n-            parse_float(n, Some(fty)).map(Float)\n+        LitKind::Float(n, fty) => {\n+            parse_float(&n.as_str(), Some(fty)).map(Float)\n         }\n-        LitKind::FloatUnsuffixed(ref n) => {\n+        LitKind::FloatUnsuffixed(n) => {\n             let fty_hint = match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyFloat(fty)) => Some(fty),\n                 _ => None\n             };\n-            parse_float(n, fty_hint).map(Float)\n+            parse_float(&n.as_str(), fty_hint).map(Float)\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),"}, {"sha": "e2d3a4f453749aafb0822d4224f20f8d3b759b33", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -344,7 +344,7 @@ impl<'tcx, K, V> UnificationTable<K>\n     }\n \n     pub fn probe(&mut self, a_id: K) -> Option<V> {\n-        self.get(a_id).value.clone()\n+        self.get(a_id).value\n     }\n \n     pub fn unsolved_variables(&mut self) -> Vec<K> {"}, {"sha": "5cbb8f93fc9d40433f0c322c111de97c21b18bc2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -53,7 +53,8 @@ use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n-use syntax::parse::{self, PResult, token};\n+use syntax::parse::{self, PResult};\n+use syntax::symbol::Symbol;\n use syntax::util::node_count::NodeCounter;\n use syntax;\n use syntax_ext;\n@@ -210,9 +211,6 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            // Discard interned strings as they are no longer required.\n-            token::clear_ident_interner();\n-\n             Ok((outputs, trans))\n         })??\n     };\n@@ -563,8 +561,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     *sess.features.borrow_mut() = features;\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n-    *sess.crate_disambiguator.borrow_mut() =\n-        token::intern(&compute_crate_disambiguator(sess)).as_str();\n+    *sess.crate_disambiguator.borrow_mut() = Symbol::intern(&compute_crate_disambiguator(sess));\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -858,7 +855,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"loop checking\",\n-         || loops::check_crate(sess, &hir_map));\n+         || loops::check_crate(sess, &resolutions.def_map, &hir_map));\n \n     time(time_passes,\n               \"static item recursion checking\",\n@@ -1107,7 +1104,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(),\n          \"linking\",\n-         || link::link_binary(sess, trans, outputs, &trans.link.crate_name));\n+         || link::link_binary(sess, trans, outputs, &trans.link.crate_name.as_str()));\n }\n \n fn escape_dep_filename(filename: &str) -> String {\n@@ -1185,6 +1182,9 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                          Some(ref n) if *n == \"rlib\" => {\n                              Some(config::CrateTypeRlib)\n                          }\n+                         Some(ref n) if *n == \"metadata\" => {\n+                             Some(config::CrateTypeMetadata)\n+                         }\n                          Some(ref n) if *n == \"dylib\" => {\n                              Some(config::CrateTypeDylib)\n                          }\n@@ -1358,11 +1358,3 @@ pub fn build_output_filenames(input: &Input,\n         }\n     }\n }\n-\n-// For use by the `rusti` project (https://github.com/murarth/rusti).\n-pub fn reset_thread_local_state() {\n-    // These may be left in an incoherent state after a previous compile.\n-    syntax::ext::hygiene::reset_hygiene_data();\n-    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n-    token::reset_ident_interner();\n-}"}, {"sha": "a0863e0d29422b7dbbf214e0f3372f3f8f1053d9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 20, "deletions": 45, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -95,12 +95,11 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-use syntax::{ast, json};\n+use syntax::ast;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n-use syntax_pos::MultiSpan;\n-use errors::emitter::Emitter;\n+use syntax_pos::{DUMMY_SP, MultiSpan};\n \n #[cfg(test)]\n pub mod test;\n@@ -374,37 +373,11 @@ fn handle_explain(code: &str,\n     }\n }\n \n-fn check_cfg(cfg: &ast::CrateConfig,\n-             output: ErrorOutputType) {\n-    let emitter: Box<Emitter> = match output {\n-        config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::EmitterWriter::stderr(color_config, None))\n-        }\n-        config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n-    };\n-    let handler = errors::Handler::with_emitter(true, false, emitter);\n-\n-    let mut saw_invalid_predicate = false;\n-    for item in cfg.iter() {\n-        if item.is_meta_item_list() {\n-            saw_invalid_predicate = true;\n-            handler.emit(&MultiSpan::new(),\n-                         &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n-                                  item.name()),\n-                            errors::Level::Fatal);\n-        }\n-    }\n-\n-    if saw_invalid_predicate {\n-        panic!(errors::FatalError);\n-    }\n-}\n-\n impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       _: &config::Options,\n-                      cfg: &ast::CrateConfig,\n+                      _: &ast::CrateConfig,\n                       descriptions: &errors::registry::Registry,\n                       output: ErrorOutputType)\n                       -> Compilation {\n@@ -413,7 +386,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             return Compilation::Stop;\n         }\n \n-        check_cfg(cfg, output);\n         Compilation::Continue\n     }\n \n@@ -640,24 +612,27 @@ impl RustcDefaultCalls {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    for cfg in &sess.parse_sess.config {\n-                        if !allow_unstable_cfg && GatedCfg::gate(cfg).is_some() {\n+                    let mut cfgs = Vec::new();\n+                    for &(name, ref value) in sess.parse_sess.config.iter() {\n+                        let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n+                            name: name,\n+                            node: ast::MetaItemKind::Word,\n+                            span: DUMMY_SP,\n+                        });\n+                        if !allow_unstable_cfg && gated_cfg.is_some() {\n                             continue;\n                         }\n \n-                        if cfg.is_word() {\n-                            println!(\"{}\", cfg.name());\n-                        } else if let Some(s) = cfg.value_str() {\n-                            println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n-                        } else if cfg.is_meta_item_list() {\n-                            // Right now there are not and should not be any\n-                            // MetaItemKind::List items in the configuration returned by\n-                            // `build_configuration`.\n-                            panic!(\"Found an unexpected list in cfg attribute '{}'!\", cfg.name())\n+                        cfgs.push(if let &Some(ref value) = value {\n+                            format!(\"{}=\\\"{}\\\"\", name, value)\n                         } else {\n-                            // There also shouldn't be literals.\n-                            panic!(\"Found an unexpected literal in cfg attribute '{}'!\", cfg.name())\n-                        }\n+                            format!(\"{}\", name)\n+                        });\n+                    }\n+\n+                    cfgs.sort();\n+                    for cfg in cfgs {\n+                        println!(\"{}\", cfg);\n                     }\n                 }\n                 PrintRequest::TargetCPUs => {"}, {"sha": "6c99c9d71b81585da2090b0be656b88873703bf5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -450,15 +450,15 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n+            pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n                 pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}{:?}\", nm, ctxt))\n+                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n             }\n-            pprust::NodeName(&ast::Name(nm)) => {\n+            pprust::NodeName(&name) => {\n                 pp::space(&mut s.s)?;\n-                s.synth_comment(nm.to_string())\n+                s.synth_comment(name.as_u32().to_string())\n             }\n             _ => Ok(()),\n         }"}, {"sha": "876323d599e857bc3f30f867b3c07b36a84daab3", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::{ast, attr};\n+use syntax::ast;\n use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token::intern_and_get_ident as intern;\n+use syntax::symbol::Symbol;\n use libc::c_char;\n \n // WARNING: the features must be known to LLVM or the feature\n@@ -41,11 +40,11 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n         _ => &[],\n     };\n \n-    let tf = InternedString::new(\"target_feature\");\n+    let tf = Symbol::intern(\"target_feature\");\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n+            cfg.insert((tf, Some(Symbol::intern(&feat[..feat.len() - 1]))));\n         }\n     }\n \n@@ -74,6 +73,6 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     }\n \n     if crt_static {\n-        cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(\"crt-static\")));\n+        cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n     }\n }"}, {"sha": "a4f0e2903847765b197d0685564fda2bc83b9919", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -34,8 +34,8 @@ use syntax::codemap::CodeMap;\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n-use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::Symbol;\n \n use rustc::hir;\n \n@@ -288,11 +288,11 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(index, Symbol::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n-        let name = token::intern(name);\n+        let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,"}, {"sha": "87e6b2befdc3281fcbbb9359c11bf499d4eaccfd", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -57,7 +57,6 @@ use std::env;\n use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use {ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n \n@@ -97,7 +96,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n type Sources = Vec<(Span, DefId, DepNode<DefId>)>;\n-type Targets = Vec<(Span, InternedString, ast::NodeId, DepNode<DefId>)>;\n+type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode<DefId>)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -106,7 +105,7 @@ struct IfThisChanged<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n-    fn argument(&self, attr: &ast::Attribute) -> Option<InternedString> {\n+    fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n@@ -127,8 +126,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::Hir(def_id),\n-                    Some(ref n) => {\n-                        match DepNode::from_label_string(&n[..], def_id) {\n+                    Some(n) => {\n+                        match DepNode::from_label_string(&n.as_str(), def_id) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -142,8 +141,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n             } else if attr.check_name(ATTR_THEN_THIS_WOULD_NEED) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    Some(ref n) => {\n-                        match DepNode::from_label_string(&n[..], def_id) {\n+                    Some(n) => {\n+                        match DepNode::from_label_string(&n.as_str(), def_id) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -159,7 +158,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     }\n                 };\n                 self.then_this_would_need.push((attr.span,\n-                                                dep_node_interned.clone().unwrap(),\n+                                                dep_node_interned.unwrap(),\n                                                 node_id,\n                                                 dep_node));\n             }"}, {"sha": "250ef061e5109305f9ff50ed1dde0db074685a43", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -172,8 +172,8 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n \n         let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n-        crate_disambiguator.len().hash(&mut crate_state);\n-        crate_disambiguator.hash(&mut crate_state);\n+        crate_disambiguator.as_str().len().hash(&mut crate_state);\n+        crate_disambiguator.as_str().hash(&mut crate_state);\n \n         // add each item (in some deterministic order) to the overall\n         // crate hash."}, {"sha": "fd0856393fc1b3b9c8b39bbe0d9a5e5cd73f3568", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,6 +18,7 @@ use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n@@ -169,8 +170,8 @@ enum SawAbiComponent<'a> {\n \n     // FIXME (#14132): should we include (some function of)\n     // ident.ctxt as well?\n-    SawIdent(token::InternedString),\n-    SawStructDef(token::InternedString),\n+    SawIdent(InternedString),\n+    SawStructDef(InternedString),\n \n     SawLifetime,\n     SawLifetimeDef(usize),\n@@ -232,11 +233,11 @@ enum SawAbiComponent<'a> {\n #[derive(Hash)]\n enum SawExprComponent<'a> {\n \n-    SawExprLoop(Option<token::InternedString>),\n-    SawExprField(token::InternedString),\n+    SawExprLoop(Option<InternedString>),\n+    SawExprField(InternedString),\n     SawExprTupField(usize),\n-    SawExprBreak(Option<token::InternedString>),\n-    SawExprAgain(Option<token::InternedString>),\n+    SawExprBreak(Option<InternedString>),\n+    SawExprAgain(Option<InternedString>),\n \n     SawExprBox,\n     SawExprArray,\n@@ -246,6 +247,8 @@ enum SawExprComponent<'a> {\n     SawExprBinary(hir::BinOp_),\n     SawExprUnary(hir::UnOp),\n     SawExprLit(ast::LitKind),\n+    SawExprLitStr(InternedString, ast::StrStyle),\n+    SawExprLitFloat(InternedString, Option<ast::FloatTy>),\n     SawExprCast,\n     SawExprType,\n     SawExprIf,\n@@ -314,12 +317,12 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprUnary(op, _)         => {\n             (SawExprUnary(op), unop_can_panic_at_runtime(op))\n         }\n-        ExprLit(ref lit)         => (SawExprLit(lit.node.clone()), false),\n+        ExprLit(ref lit)         => (saw_lit(lit), false),\n         ExprCast(..)             => (SawExprCast, false),\n         ExprType(..)             => (SawExprType, false),\n         ExprIf(..)               => (SawExprIf, false),\n         ExprWhile(..)            => (SawExprWhile, false),\n-        ExprLoop(_, id)          => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n+        ExprLoop(_, id, _)       => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n         ExprMatch(..)            => (SawExprMatch, false),\n         ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n         ExprBlock(..)            => (SawExprBlock, false),\n@@ -332,7 +335,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprIndex(..)            => (SawExprIndex, true),\n         ExprPath(ref qself, _)   => (SawExprPath(qself.as_ref().map(|q| q.position)), false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(id)            => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n+        ExprBreak(id, _)         => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n         ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n@@ -341,6 +344,15 @@ fn saw_expr<'a>(node: &'a Expr_,\n     }\n }\n \n+fn saw_lit(lit: &ast::Lit) -> SawExprComponent<'static> {\n+    match lit.node {\n+        ast::LitKind::Str(s, style) => SawExprLitStr(s.as_str(), style),\n+        ast::LitKind::Float(s, ty) => SawExprLitFloat(s.as_str(), Some(ty)),\n+        ast::LitKind::FloatUnsuffixed(s) => SawExprLitFloat(s.as_str(), None),\n+        ref node @ _ => SawExprLit(node.clone()),\n+    }\n+}\n+\n #[derive(Hash)]\n enum SawItemComponent {\n     SawItemExternCrate,\n@@ -874,22 +886,16 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n \n         // ignoring span information, it doesn't matter here\n         self.hash_discriminant(&meta_item.node);\n+        meta_item.name.as_str().len().hash(self.st);\n+        meta_item.name.as_str().hash(self.st);\n+\n         match meta_item.node {\n-            ast::MetaItemKind::Word(ref s) => {\n-                s.len().hash(self.st);\n-                s.hash(self.st);\n-            }\n-            ast::MetaItemKind::NameValue(ref s, ref lit) => {\n-                s.len().hash(self.st);\n-                s.hash(self.st);\n-                lit.node.hash(self.st);\n-            }\n-            ast::MetaItemKind::List(ref s, ref items) => {\n-                s.len().hash(self.st);\n-                s.hash(self.st);\n+            ast::MetaItemKind::Word => {}\n+            ast::MetaItemKind::NameValue(ref lit) => saw_lit(lit).hash(self.st),\n+            ast::MetaItemKind::List(ref items) => {\n                 // Sort subitems so the hash does not depend on their order\n                 let indices = self.indices_sorted_by(&items, |p| {\n-                    (p.name(), fnv::hash(&p.literal().map(|i| &i.node)))\n+                    (p.name().map(Symbol::as_str), fnv::hash(&p.literal().map(saw_lit)))\n                 });\n                 items.len().hash(self.st);\n                 for (index, &item_index) in indices.iter().enumerate() {\n@@ -901,7 +907,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n                             self.hash_meta_item(meta_item);\n                         }\n                         ast::NestedMetaItemKind::Literal(ref lit) => {\n-                            lit.node.hash(self.st);\n+                            saw_lit(lit).hash(self.st);\n                         }\n                     }\n                 }\n@@ -914,11 +920,11 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n \n         for i in indices {\n-            let attr = &attributes[i].node;\n+            let attr = &attributes[i];\n             if !attr.is_sugared_doc &&\n-               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name()) {\n+               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name().as_str()) {\n                 SawAttribute(attr.style).hash(self.st);\n-                self.hash_meta_item(&*attr.value);\n+                self.hash_meta_item(&attr.value);\n             }\n         }\n     }"}, {"sha": "546feb212243aca2c3d629ae8a7e89345356481d", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -84,8 +84,8 @@ impl DefIdDirectory {\n             assert_eq!(old_info.krate, krate);\n             let old_name: &str = &old_info.name;\n             let old_disambiguator: &str = &old_info.disambiguator;\n-            let new_name: &str = &tcx.crate_name(krate);\n-            let new_disambiguator: &str = &tcx.crate_disambiguator(krate);\n+            let new_name: &str = &tcx.crate_name(krate).as_str();\n+            let new_disambiguator: &str = &tcx.crate_disambiguator(krate).as_str();\n             old_name == new_name && old_disambiguator == new_disambiguator\n         }\n     }\n@@ -99,8 +99,8 @@ impl DefIdDirectory {\n         let new_krates: HashMap<_, _> =\n             once(LOCAL_CRATE)\n             .chain(tcx.sess.cstore.crates())\n-            .map(|krate| (make_key(&tcx.crate_name(krate),\n-                                   &tcx.crate_disambiguator(krate)), krate))\n+            .map(|krate| (make_key(&tcx.crate_name(krate).as_str(),\n+                                   &tcx.crate_disambiguator(krate).as_str()), krate))\n             .collect();\n \n         let ids = self.paths.iter()"}, {"sha": "85c35bf79ce81347a4273e82b83200d94fc301b9", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -48,7 +48,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n use ich::Fingerprint;\n@@ -88,12 +87,11 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-\n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, item);\n-                match DepNode::from_label_string(&value[..], def_id) {\n+                match DepNode::from_label_string(&value.as_str(), def_id) {\n                     Ok(def_id) => return def_id,\n                     Err(()) => {\n                         self.tcx.sess.span_fatal(\n@@ -276,13 +274,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n         if item.check_name(CFG) {\n             let value = expect_associated_value(tcx, item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n-            for cfg in &config[..] {\n-                if cfg.check_name(&value[..]) {\n-                    debug!(\"check_config: matched {:?}\", cfg);\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return config.contains(&(value, None));\n         }\n     }\n \n@@ -291,7 +283,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n         &format!(\"no cfg attribute\"));\n }\n \n-fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> InternedString {\n+fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n         value\n     } else {"}, {"sha": "26181dbaf50ff243b0501514c03abe059f4d5570", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -604,7 +604,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n }\n \n fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n-    crate_path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum))\n+    crate_path(tcx.sess, &tcx.crate_name(cnum).as_str(), &tcx.crate_disambiguator(cnum).as_str())\n }\n \n /// Finds the session directory containing the correct metadata hashes file for"}, {"sha": "4440cb41dc5f20051a8a4c883d4d41a1185f6bfc", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -81,19 +81,12 @@ impl NonCamelCaseTypes {\n                 .concat()\n         }\n \n-        let s = name.as_str();\n-\n         if !is_camel_case(name) {\n-            let c = to_camel_case(&s);\n+            let c = to_camel_case(&name.as_str());\n             let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\",\n-                        sort,\n-                        s)\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, name)\n             } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                        sort,\n-                        s,\n-                        c)\n+                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, name, c)\n             };\n             cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n@@ -241,8 +234,8 @@ impl LateLintPass for NonSnakeCase {\n             .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n             self.check_snake_case(cx, \"crate\", name, None);\n-        } else if let Some((attr, ref name)) = attr_crate_name {\n-            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n+        } else if let Some((attr, name)) = attr_crate_name {\n+            self.check_snake_case(cx, \"crate\", &name.as_str(), Some(attr.span));\n         }\n     }\n \n@@ -326,21 +319,19 @@ pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n-        let s = name.as_str();\n-\n-        if s.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n-            if uc != &s[..] {\n+        if name.as_str().chars().any(|c| c.is_lowercase()) {\n+            let uc = NonSnakeCase::to_snake_case(&name.as_str()).to_uppercase();\n+            if name != &*uc {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS,\n                              span,\n                              &format!(\"{} `{}` should have an upper case name such as `{}`\",\n                                       sort,\n-                                      s,\n+                                      name,\n                                       uc));\n             } else {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS,\n                              span,\n-                             &format!(\"{} `{}` should have an upper case name\", sort, s));\n+                             &format!(\"{} `{}` should have an upper case name\", sort, name));\n             }\n         }\n     }"}, {"sha": "0b2ae58852300806d9ec81392a42a0d183c27d53", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -45,6 +45,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n@@ -633,20 +634,20 @@ impl Deprecated {\n             stability: &Option<&attr::Stability>,\n             deprecation: &Option<stability::DeprecationEntry>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{ref reason, ..}), ..})\n+        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{reason, ..}), ..})\n                 = *stability {\n-            output(cx, DEPRECATED, span, Some(&reason))\n+            output(cx, DEPRECATED, span, Some(reason))\n         } else if let Some(ref depr_entry) = *deprecation {\n             if let Some(parent_depr) = cx.tcx.lookup_deprecation_entry(self.parent_def(cx)) {\n                 if parent_depr.same_origin(depr_entry) {\n                     return;\n                 }\n             }\n \n-            output(cx, DEPRECATED, span, depr_entry.attr.note.as_ref().map(|x| &**x))\n+            output(cx, DEPRECATED, span, depr_entry.attr.note)\n         }\n \n-        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<&str>) {\n+        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<Symbol>) {\n             let msg = if let Some(note) = note {\n                 format!(\"use of deprecated item: {}\", note)\n             } else {\n@@ -772,9 +773,9 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = &*attr.name();\n+        let name = attr.name();\n         for &&(n, _, ref g) in &self.depr_attrs {\n-            if n == name {\n+            if name == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n                                              ref name,\n                                              ref reason,\n@@ -1228,7 +1229,7 @@ impl LateLintPass for MutableTransmutes {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false,\n             }\n-            cx.tcx.item_name(def_id).as_str() == \"transmute\"\n+            cx.tcx.item_name(def_id) == \"transmute\"\n         }\n     }\n }"}, {"sha": "1a3ea5db871ebedc1363cba4e1f9550f9623fcbc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -232,6 +232,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(EXTRA_REQUIREMENT_IN_IMPL),\n             reference: \"issue #37166 <https://github.com/rust-lang/rust/issues/37166>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n+            reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "8aa5e9e0a9460afb18d08531d44fc44577a0f1f7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -219,9 +219,9 @@ impl LateLintPass for TypeLimits {\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n-                            ast::LitKind::Float(ref v, _) |\n-                            ast::LitKind::FloatUnsuffixed(ref v) => {\n-                                match v.parse() {\n+                            ast::LitKind::Float(v, _) |\n+                            ast::LitKind::FloatUnsuffixed(v) => {\n+                                match v.as_str().parse() {\n                                     Ok(f) => f,\n                                     Err(_) => return,\n                                 }"}, {"sha": "fa452017f0cf1d7fecbdb7a1ddbdc6fcf4ae3e97", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -20,7 +20,7 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -48,7 +48,7 @@ impl UnusedMut {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(name.0 as usize) {\n+                        match mutables.entry(name) {\n                             Vacant(entry) => {\n                                 entry.insert(vec![id]);\n                             }\n@@ -162,7 +162,7 @@ impl LateLintPass for UnusedResults {\n                     // check for #[must_use=\"...\"]\n                     if let Some(s) = attr.value_str() {\n                         msg.push_str(\": \");\n-                        msg.push_str(&s);\n+                        msg.push_str(&s.as_str());\n                     }\n                     cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n                     return true;\n@@ -274,10 +274,10 @@ impl LateLintPass for UnusedAttributes {\n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| &*attr.name() == x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| attr.name() == &**x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n-                let msg = match attr.node.style {\n+                let msg = match attr.style {\n                     ast::AttrStyle::Outer => {\n                         \"crate-level attribute should be an inner attribute: add an exclamation \\\n                          mark: #![foo]\""}, {"sha": "470e8d1fd4578d75eb2bb86274f4674713abfba0", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -395,9 +395,6 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Attribute_opaque {}\n-pub type AttributeRef = *mut Attribute_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -770,8 +767,6 @@ extern \"C\" {\n                         Name: *const c_char)\n                         -> ValueRef;\n \n-    pub fn LLVMRustCreateAttribute(C: ContextRef, kind: Attribute, val: u64) -> AttributeRef;\n-\n     // Operations on functions\n     pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n     pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n@@ -790,12 +785,12 @@ extern \"C\" {\n     pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n     pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n     pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: AttributeRef);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: Attribute);\n     pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n                                               index: c_uint,\n                                               Name: *const c_char,\n                                               Value: *const c_char);\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: AttributeRef);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n     pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n@@ -806,8 +801,6 @@ extern \"C\" {\n     pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n     pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n     pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMAddAttribute(Arg: ValueRef, attr: AttributeRef);\n-    pub fn LLVMRemoveAttribute(Arg: ValueRef, attr: AttributeRef);\n     pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n     // Operations on basic blocks\n@@ -851,7 +844,7 @@ extern \"C\" {\n     pub fn LLVMAddInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n     pub fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n     pub fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint, align: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: AttributeRef);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: Attribute);\n     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n \n     // Operations on call instructions (only)"}, {"sha": "c4ec418f224b579c00fad7ab0d755d06def05f57", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -176,20 +176,16 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n }\n \n impl Attribute {\n-    fn as_object(&self, value: ValueRef) -> AttributeRef {\n-        unsafe { LLVMRustCreateAttribute(LLVMRustGetValueContext(value), *self, 0) }\n-    }\n-\n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.as_object(llfn)) }\n+        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n     }\n \n     pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.as_object(callsite)) }\n+        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n     }\n \n     pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.as_object(llfn)) }\n+        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n     }\n \n     pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {"}, {"sha": "27c00481bfd3adad17006212acada0650b339915", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -37,13 +37,14 @@ use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::parse::token::{InternedString, intern};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n+    pub rmeta: Option<(PathBuf, PathKind)>,\n     pub metadata: MetadataBlob,\n }\n \n@@ -52,7 +53,7 @@ pub struct CrateLoader<'a> {\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n     foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n-    local_crate_name: String,\n+    local_crate_name: Symbol,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -62,16 +63,17 @@ fn dump_crates(cstore: &CStore) {\n         info!(\"  cnum: {}\", data.cnum);\n         info!(\"  hash: {}\", data.hash());\n         info!(\"  reqd: {:?}\", data.dep_kind.get());\n-        let CrateSource { dylib, rlib } = data.source.clone();\n+        let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n         dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n         rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n-    })\n+        rmeta.map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n+    });\n }\n \n #[derive(Debug)]\n struct ExternCrateInfo {\n-    ident: String,\n-    name: String,\n+    ident: Symbol,\n+    name: Symbol,\n     id: ast::NodeId,\n     dep_kind: DepKind,\n }\n@@ -80,7 +82,7 @@ fn register_native_lib(sess: &Session,\n                        cstore: &CStore,\n                        span: Option<Span>,\n                        lib: NativeLibrary) {\n-    if lib.name.is_empty() {\n+    if lib.name.as_str().is_empty() {\n         match span {\n             Some(span) => {\n                 struct_span_err!(sess, span, E0454,\n@@ -147,7 +149,7 @@ impl<'a> CrateLoader<'a> {\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FxHashMap(),\n-            local_crate_name: local_crate_name.to_owned(),\n+            local_crate_name: Symbol::intern(local_crate_name),\n         }\n     }\n \n@@ -160,12 +162,12 @@ impl<'a> CrateLoader<'a> {\n                     Some(name) => {\n                         validate_crate_name(Some(self.sess), &name.as_str(),\n                                             Some(i.span));\n-                        name.to_string()\n+                        name\n                     }\n-                    None => i.ident.to_string(),\n+                    None => i.ident.name,\n                 };\n                 Some(ExternCrateInfo {\n-                    ident: i.ident.to_string(),\n+                    ident: i.ident.name,\n                     name: name,\n                     id: i.id,\n                     dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n@@ -179,7 +181,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n+    fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n@@ -201,7 +203,7 @@ impl<'a> CrateLoader<'a> {\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n             let source = self.cstore.used_crate_source(cnum);\n-            if let Some(locs) = self.sess.opts.externs.get(name) {\n+            if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n@@ -233,7 +235,7 @@ impl<'a> CrateLoader<'a> {\n                                   root: &CrateRoot) {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name &&\n-           self.sess.local_crate_disambiguator() == &root.disambiguator[..] {\n+           self.sess.local_crate_disambiguator() == root.disambiguator {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n@@ -258,8 +260,8 @@ impl<'a> CrateLoader<'a> {\n \n     fn register_crate(&mut self,\n                       root: &Option<CratePaths>,\n-                      ident: &str,\n-                      name: &str,\n+                      ident: Symbol,\n+                      name: Symbol,\n                       span: Span,\n                       lib: Library,\n                       dep_kind: DepKind)\n@@ -278,19 +280,20 @@ impl<'a> CrateLoader<'a> {\n                 ident: ident.to_string(),\n                 dylib: lib.dylib.clone().map(|p| p.0),\n                 rlib:  lib.rlib.clone().map(|p| p.0),\n+                rmeta: lib.rmeta.clone().map(|p| p.0),\n             })\n         } else {\n             None\n         };\n         // Maintain a reference to the top most crate.\n         let root = if root.is_some() { root } else { &crate_paths };\n \n-        let Library { dylib, rlib, metadata } = lib;\n+        let Library { dylib, rlib, rmeta, metadata } = lib;\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n-            name: name.to_string(),\n+            name: name,\n             extern_crate: Cell::new(None),\n             key_map: metadata.load_key_map(crate_root.index),\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n@@ -305,6 +308,7 @@ impl<'a> CrateLoader<'a> {\n             source: cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n+                rmeta: rmeta,\n             },\n         });\n \n@@ -314,8 +318,8 @@ impl<'a> CrateLoader<'a> {\n \n     fn resolve_crate(&mut self,\n                      root: &Option<CratePaths>,\n-                     ident: &str,\n-                     name: &str,\n+                     ident: Symbol,\n+                     name: Symbol,\n                      hash: Option<&Svh>,\n                      span: Span,\n                      path_kind: PathKind,\n@@ -366,6 +370,9 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             LoadResult::Previous(cnum) => {\n                 let data = self.cstore.get_crate_data(cnum);\n+                if data.root.macro_derive_registrar.is_some() {\n+                    dep_kind = DepKind::MacrosOnly;\n+                }\n                 data.dep_kind.set(cmp::max(data.dep_kind.get(), dep_kind));\n                 (cnum, data)\n             }\n@@ -456,13 +463,12 @@ impl<'a> CrateLoader<'a> {\n         let deps = crate_root.crate_deps.decode(metadata);\n         let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-            let dep_name = &dep.name.as_str();\n             let dep_kind = match dep_kind {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n             let (local_cnum, ..) = self.resolve_crate(\n-                root, dep_name, dep_name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+                root, dep.name, dep.name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n             );\n             (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n@@ -482,13 +488,11 @@ impl<'a> CrateLoader<'a> {\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n-        let ident = info.ident.clone();\n-        let name = info.name.clone();\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n             span: span,\n-            ident: &ident[..],\n-            crate_name: &name[..],\n+            ident: info.ident,\n+            crate_name: info.name,\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n@@ -582,11 +586,11 @@ impl<'a> CrateLoader<'a> {\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n-                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let attrs = attributes.iter().cloned().map(Symbol::intern).collect();\n                 let derive = SyntaxExtension::CustomDerive(\n                     Box::new(CustomDerive::new(expand, attrs))\n                 );\n-                self.0.push((intern(trait_name), Rc::new(derive)));\n+                self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }\n         }\n \n@@ -604,8 +608,8 @@ impl<'a> CrateLoader<'a> {\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n                                  -> Option<(PathBuf, Svh, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n-             name: name.to_string(),\n-             ident: name.to_string(),\n+             name: Symbol::intern(name),\n+             ident: Symbol::intern(name),\n              id: ast::DUMMY_NODE_ID,\n              dep_kind: DepKind::MacrosOnly,\n         });\n@@ -642,7 +646,7 @@ impl<'a> CrateLoader<'a> {\n         let libs = self.cstore.get_used_libraries();\n         for (foreign_lib, list) in self.foreign_item_map.iter() {\n             let is_static = libs.borrow().iter().any(|lib| {\n-                *foreign_lib == lib.name && lib.kind == cstore::NativeStatic\n+                lib.name == &**foreign_lib && lib.kind == cstore::NativeStatic\n             });\n             if is_static {\n                 for id in list {\n@@ -705,8 +709,8 @@ impl<'a> CrateLoader<'a> {\n         // in terms of everyone has a compatible panic runtime format, that's\n         // performed later as part of the `dependency_format` module.\n         let name = match desired_strategy {\n-            PanicStrategy::Unwind => \"panic_unwind\",\n-            PanicStrategy::Abort => \"panic_abort\",\n+            PanicStrategy::Unwind => Symbol::intern(\"panic_unwind\"),\n+            PanicStrategy::Abort => Symbol::intern(\"panic_abort\"),\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n@@ -767,7 +771,8 @@ impl<'a> CrateLoader<'a> {\n                 config::CrateTypeProcMacro |\n                 config::CrateTypeCdylib |\n                 config::CrateTypeStaticlib => need_lib_alloc = true,\n-                config::CrateTypeRlib => {}\n+                config::CrateTypeRlib |\n+                config::CrateTypeMetadata => {}\n             }\n         }\n         if !need_lib_alloc && !need_exe_alloc { return }\n@@ -788,9 +793,9 @@ impl<'a> CrateLoader<'a> {\n         // * Staticlibs and Rust dylibs use system malloc\n         // * Rust dylibs used as dependencies to rust use jemalloc\n         let name = if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n-            &self.sess.target.target.options.lib_allocation_crate\n+            Symbol::intern(&self.sess.target.target.options.lib_allocation_crate)\n         } else {\n-            &self.sess.target.target.options.exe_allocation_crate\n+            Symbol::intern(&self.sess.target.target.options.exe_allocation_crate)\n         };\n         let dep_kind = DepKind::Implicit;\n         let (cnum, data) =\n@@ -852,8 +857,8 @@ impl<'a> CrateLoader<'a> {\n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n         for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            if let Some(ref linkarg) = attr.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+            if let Some(linkarg) = attr.value_str() {\n+                self.cstore.add_used_link_args(&linkarg.as_str());\n             }\n         }\n     }\n@@ -866,7 +871,7 @@ impl<'a> CrateLoader<'a> {\n         // First, add all of the custom #[link_args] attributes\n         for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n             if let Some(linkarg) = m.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+                self.cstore.add_used_link_args(&linkarg.as_str());\n             }\n         }\n \n@@ -878,7 +883,7 @@ impl<'a> CrateLoader<'a> {\n             };\n             let kind = items.iter().find(|k| {\n                 k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str());\n+            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n             let kind = match kind.as_ref().map(|s| &s[..]) {\n                 Some(\"static\") => cstore::NativeStatic,\n                 Some(\"dylib\") => cstore::NativeUnknown,\n@@ -900,7 +905,7 @@ impl<'a> CrateLoader<'a> {\n                     struct_span_err!(self.sess, m.span, E0459,\n                                      \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n                         .span_label(m.span, &format!(\"missing `name` argument\")).emit();\n-                    InternedString::new(\"foo\")\n+                    Symbol::intern(\"foo\")\n                 }\n             };\n             let cfg = items.iter().find(|k| {\n@@ -910,7 +915,7 @@ impl<'a> CrateLoader<'a> {\n                 list[0].meta_item().unwrap().clone()\n             });\n             let lib = NativeLibrary {\n-                name: n.to_string(),\n+                name: n,\n                 kind: kind,\n                 cfg: cfg,\n             };\n@@ -941,7 +946,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         for &(ref name, kind) in &self.sess.opts.libs {\n             let lib = NativeLibrary {\n-                name: name.clone(),\n+                name: Symbol::intern(name),\n                 kind: kind,\n                 cfg: None,\n             };\n@@ -959,7 +964,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         let info = self.extract_crate_info(item).unwrap();\n         let (cnum, ..) = self.resolve_crate(\n-            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n+            &None, info.ident, info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n \n         let def_id = definitions.opt_local_def_id(item.id).unwrap();"}, {"sha": "7c1834c1576a8f1f5e8d5318a5c92121652e960b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -25,15 +25,15 @@ use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n-pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n+pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -44,6 +44,7 @@ pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n pub enum MetadataBlob {\n     Inflated(Bytes),\n     Archive(locator::ArchiveMetadata),\n+    Raw(Vec<u8>),\n }\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n@@ -58,7 +59,7 @@ pub struct ImportedFileMap {\n }\n \n pub struct CrateMetadata {\n-    pub name: String,\n+    pub name: Symbol,\n \n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n@@ -185,7 +186,7 @@ impl CStore {\n     // positions.\n     pub fn do_get_used_crates(&self,\n                               prefer: LinkagePreference)\n-                              -> Vec<(CrateNum, Option<PathBuf>)> {\n+                              -> Vec<(CrateNum, LibSource)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n@@ -201,6 +202,16 @@ impl CStore {\n                     LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n                     LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n                 };\n+                let path = match path {\n+                    Some(p) => LibSource::Some(p),\n+                    None => {\n+                        if data.source.rmeta.is_some() {\n+                            LibSource::MetadataOnly\n+                        } else {\n+                            LibSource::None\n+                        }\n+                    }\n+                };\n                 Some((cnum, path))\n             })\n             .collect::<Vec<_>>();\n@@ -213,7 +224,7 @@ impl CStore {\n     }\n \n     pub fn add_used_library(&self, lib: NativeLibrary) {\n-        assert!(!lib.name.is_empty());\n+        assert!(!lib.name.as_str().is_empty());\n         self.used_libraries.borrow_mut().push(lib);\n     }\n \n@@ -249,14 +260,14 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn name(&self) -> &str {\n-        &self.root.name\n+    pub fn name(&self) -> Symbol {\n+        self.root.name\n     }\n     pub fn hash(&self) -> Svh {\n         self.root.hash\n     }\n-    pub fn disambiguator(&self) -> &str {\n-        &self.root.disambiguator\n+    pub fn disambiguator(&self) -> Symbol {\n+        self.root.disambiguator\n     }\n \n     pub fn is_staged_api(&self) -> bool {"}, {"sha": "ead933384b96d9b4e18bbfbe807270c406e83c02", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -13,7 +13,7 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n@@ -28,10 +28,10 @@ use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n-use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::{token, new_parser_from_source_str};\n+use syntax::parse::new_parser_from_source_str;\n+use syntax::symbol::Symbol;\n use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n@@ -262,14 +262,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n+        self.get_crate_data(cnum).name\n     }\n \n-    fn original_crate_name(&self, cnum: CrateNum) -> token::InternedString\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n+        self.get_crate_data(cnum).name()\n     }\n \n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n@@ -282,9 +282,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_hash(cnum)\n     }\n \n-    fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n+        self.get_crate_data(cnum).disambiguator()\n     }\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n@@ -544,7 +544,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         locator::meta_section_name(target)\n     }\n \n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)\n     }"}, {"sha": "8a187bb97969a385145c1e098a26e60c8ea28b01", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -88,8 +88,9 @@ pub trait Metadata<'a, 'tcx>: Copy {\n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     fn raw_bytes(self) -> &'a [u8] {\n         match *self {\n-            MetadataBlob::Inflated(ref vec) => &vec[..],\n+            MetadataBlob::Inflated(ref vec) => vec,\n             MetadataBlob::Archive(ref ar) => ar.as_slice(),\n+            MetadataBlob::Raw(ref vec) => vec,\n         }\n     }\n }\n@@ -934,7 +935,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode(self)\n             .map(|mut attr| {\n                 // Need new unique IDs: old thread-local IDs won't map to new threads.\n-                attr.node.id = attr::mk_attr_id();\n+                attr.id = attr::mk_attr_id();\n                 attr\n             })\n             .collect()"}, {"sha": "2f4b0d5c87b0dc6fb1df552a8df4200897d804d6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -34,7 +34,7 @@ use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n-use syntax;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n@@ -600,7 +600,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n                 path1.node\n             } else {\n-                syntax::parse::token::intern(\"\")\n+                Symbol::intern(\"\")\n             }\n         }))\n     }\n@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let deps = get_ordered_deps(self.cstore);\n         self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n             CrateDep {\n-                name: syntax::parse::token::intern(dep.name()),\n+                name: dep.name(),\n                 hash: dep.hash(),\n                 kind: dep.dep_kind.get(),\n             }\n@@ -1279,10 +1279,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let root = self.lazy(&CrateRoot {\n             rustc_version: rustc_version(),\n-            name: link_meta.crate_name.clone(),\n+            name: link_meta.crate_name,\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n-            disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n+            disambiguator: tcx.sess.local_crate_disambiguator(),\n             panic_strategy: tcx.sess.panic_strategy(),\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn"}, {"sha": "be9284baa74cbabe6f37d9c7e3b9e36b1894fe7e", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -53,6 +53,13 @@\n //! is a platform-defined dynamic library. Each library has a metadata somewhere\n //! inside of it.\n //!\n+//! A third kind of dependency is an rmeta file. These are metadata files and do\n+//! not contain any code, etc. To a first approximation, these are treated in the\n+//! same way as rlibs. Where there is both an rlib and an rmeta file, the rlib\n+//! gets priority (even if the rmeta file is newer). An rmeta file is only\n+//! useful for checking a downstream crate, attempting to link one will cause an\n+//! error.\n+//!\n //! When translating a crate name to a crate on the filesystem, we all of a\n //! sudden need to take into account both rlibs and dylibs! Linkage later on may\n //! use either one of these files, as each has their pros/cons. The job of crate\n@@ -227,13 +234,14 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use errors::DiagnosticBuilder;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n \n use std::cmp;\n use std::fmt;\n-use std::fs;\n-use std::io;\n+use std::fs::{self, File};\n+use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n use std::ptr;\n use std::slice;\n@@ -249,8 +257,8 @@ pub struct CrateMismatch {\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n-    pub ident: &'a str,\n-    pub crate_name: &'a str,\n+    pub ident: Symbol,\n+    pub crate_name: Symbol,\n     pub hash: Option<&'a Svh>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n@@ -275,33 +283,31 @@ pub struct CratePaths {\n     pub ident: String,\n     pub dylib: Option<PathBuf>,\n     pub rlib: Option<PathBuf>,\n+    pub rmeta: Option<PathBuf>,\n }\n \n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n+    Rmeta,\n     Dylib,\n }\n \n impl fmt::Display for CrateFlavor {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             CrateFlavor::Rlib => \"rlib\",\n+            CrateFlavor::Rmeta => \"rmeta\",\n             CrateFlavor::Dylib => \"dylib\",\n         })\n     }\n }\n \n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n-        match (&self.dylib, &self.rlib) {\n-            (&None, &None) => vec![],\n-            (&Some(ref p), &None) |\n-            (&None, &Some(ref p)) => vec![p.clone()],\n-            (&Some(ref p1), &Some(ref p2)) => vec![p1.clone(), p2.clone()],\n-        }\n+        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).cloned().collect()\n     }\n }\n \n@@ -422,7 +428,7 @@ impl<'a> Context<'a> {\n         // must be loaded via -L plus some filtering.\n         if self.hash.is_none() {\n             self.should_match_name = false;\n-            if let Some(s) = self.sess.opts.externs.get(self.crate_name) {\n+            if let Some(s) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n                 return self.find_commandline_library(s.iter());\n             }\n             self.should_match_name = true;\n@@ -457,32 +463,35 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], true)\n-            } else if file.starts_with(&dylib_prefix) &&\n-                                         file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], false)\n-            } else {\n-                if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n-                    staticlibs.push(CrateMismatch {\n-                        path: path.to_path_buf(),\n-                        got: \"static\".to_string(),\n-                    });\n-                }\n-                return FileDoesntMatch;\n-            };\n+            let (hash, found_kind) =\n+                if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n+                } else if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rmeta\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n+                } else if file.starts_with(&dylib_prefix) &&\n+                                             file.ends_with(&dypair.1) {\n+                    (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n+                } else {\n+                    if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n+                        staticlibs.push(CrateMismatch {\n+                            path: path.to_path_buf(),\n+                            got: \"static\".to_string(),\n+                        });\n+                    }\n+                    return FileDoesntMatch;\n+                };\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                .or_insert_with(|| (FxHashMap(), FxHashMap()));\n-            let (ref mut rlibs, ref mut dylibs) = *slot;\n+                .or_insert_with(|| (FxHashMap(), FxHashMap(), FxHashMap()));\n+            let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n-                    if rlib {\n-                        rlibs.insert(p, kind);\n-                    } else {\n-                        dylibs.insert(p, kind);\n+                    match found_kind {\n+                        CrateFlavor::Rlib => { rlibs.insert(p, kind); }\n+                        CrateFlavor::Rmeta => { rmetas.insert(p, kind); }\n+                        CrateFlavor::Dylib => { dylibs.insert(p, kind); }\n                     }\n                     FileMatches\n                 })\n@@ -499,15 +508,17 @@ impl<'a> Context<'a> {\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n         let mut libraries = FxHashMap();\n-        for (_hash, (rlibs, dylibs)) in candidates {\n+        for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+            let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n             let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n             if let Some((h, m)) = slot {\n                 libraries.insert(h,\n                                  Library {\n                                      dylib: dylib,\n                                      rlib: rlib,\n+                                     rmeta: rmeta,\n                                      metadata: m,\n                                  });\n             }\n@@ -533,7 +544,7 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    note_crate_name(&mut err, &lib.metadata.get_root().name);\n+                    note_crate_name(&mut err, &lib.metadata.get_root().name.as_str());\n                 }\n                 err.emit();\n                 None\n@@ -703,6 +714,7 @@ impl<'a> Context<'a> {\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n         let mut rlibs = FxHashMap();\n+        let mut rmetas = FxHashMap();\n         let mut dylibs = FxHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n@@ -721,7 +733,8 @@ impl<'a> Context<'a> {\n                         return false;\n                     }\n                 };\n-                if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n+                if file.starts_with(\"lib\") &&\n+                   (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\")) {\n                     return true;\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n@@ -744,6 +757,8 @@ impl<'a> Context<'a> {\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n+                    rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n                     dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n@@ -753,16 +768,18 @@ impl<'a> Context<'a> {\n         // Extract the rlib/dylib pair.\n         let mut slot = None;\n         let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+        let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n         let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n \n-        if rlib.is_none() && dylib.is_none() {\n+        if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n             return None;\n         }\n         match slot {\n             Some((_, metadata)) => {\n                 Some(Library {\n                     dylib: dylib,\n                     rlib: rlib,\n+                    rmeta: rmeta,\n                     metadata: metadata,\n                 })\n             }\n@@ -850,6 +867,15 @@ fn get_metadata_section_imp(target: &Target,\n                 Ok(blob)\n             }\n         };\n+    } else if flavor == CrateFlavor::Rmeta {\n+        let mut file = File::open(filename).map_err(|_|\n+            format!(\"could not open file: '{}'\", filename.display()))?;\n+        let mut buf = vec![];\n+        file.read_to_end(&mut buf).map_err(|_|\n+            format!(\"failed to read rlib metadata: '{}'\", filename.display()))?;\n+        let blob = MetadataBlob::Raw(buf);\n+        verify_decompressed_encoding_version(&blob, filename)?;\n+        return Ok(blob);\n     }\n     unsafe {\n         let buf = common::path2cstr(filename);\n@@ -933,6 +959,8 @@ pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) ->\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n+    } else if filename.ends_with(\".rmeta\") {\n+        CrateFlavor::Rmeta\n     } else {\n         CrateFlavor::Dylib\n     };"}, {"sha": "e11719dc40f2a83aa1ccfdb2047ec46fbabf0397", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -22,6 +22,7 @@ use rustc_back::PanicStrategy;\n \n use rustc_serialize as serialize;\n use syntax::{ast, attr};\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n@@ -163,10 +164,10 @@ pub enum LazyState {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub rustc_version: String,\n-    pub name: String,\n+    pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n-    pub disambiguator: String,\n+    pub disambiguator: Symbol,\n     pub panic_strategy: PanicStrategy,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,"}, {"sha": "5a77de08070281763ba800cc6796895a5cd353fb", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -169,41 +169,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: loop_block });\n \n-                let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n-                    // conduct the test, if necessary\n-                    let body_block;\n-                    if let Some(cond_expr) = opt_cond_expr {\n-                        // This loop has a condition, ergo its exit_block is reachable.\n-                        this.find_loop_scope(expr_span, None).might_break = true;\n+                this.in_loop_scope(\n+                    loop_block, exit_block, destination.clone(),\n+                    move |this| {\n+                        // conduct the test, if necessary\n+                        let body_block;\n+                        if let Some(cond_expr) = opt_cond_expr {\n+                            let loop_block_end;\n+                            let cond = unpack!(\n+                                loop_block_end = this.as_operand(loop_block, cond_expr));\n+                            body_block = this.cfg.start_new_block();\n+                            this.cfg.terminate(loop_block_end, source_info,\n+                                               TerminatorKind::If {\n+                                                   cond: cond,\n+                                                   targets: (body_block, exit_block)\n+                                               });\n \n-                        let loop_block_end;\n-                        let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n-                        body_block = this.cfg.start_new_block();\n-                        this.cfg.terminate(loop_block_end, source_info,\n-                                           TerminatorKind::If {\n-                                               cond: cond,\n-                                               targets: (body_block, exit_block)\n-                                           });\n-                    } else {\n-                        body_block = loop_block;\n-                    }\n+                            // if the test is false, there's no `break` to assign `destination`, so\n+                            // we have to do it; this overwrites any `break`-assigned value but it's\n+                            // always `()` anyway\n+                            this.cfg.push_assign_unit(exit_block, source_info, destination);\n+                        } else {\n+                            body_block = loop_block;\n+                        }\n \n-                    // The \u201creturn\u201d value of the loop body must always be an unit, but we cannot\n-                    // reuse that as a \u201creturn\u201d value of the whole loop expressions, because some\n-                    // loops are diverging (e.g. `loop {}`). Thus, we introduce a unit temporary as\n-                    // the destination for the loop body and assign the loop\u2019s own \u201creturn\u201d value\n-                    // immediately after the iteration is finished.\n-                    let tmp = this.get_unit_temp();\n-                    // Execute the body, branching back to the test.\n-                    let body_block_end = unpack!(this.into(&tmp, body_block, body));\n-                    this.cfg.terminate(body_block_end, source_info,\n-                                       TerminatorKind::Goto { target: loop_block });\n-                });\n-                // If the loop may reach its exit_block, we assign an empty tuple to the\n-                // destination to keep the MIR well-formed.\n-                if might_break {\n-                    this.cfg.push_assign_unit(exit_block, source_info, destination);\n-                }\n+                        // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n+                        // introduce a unit temporary as the destination for the loop body.\n+                        let tmp = this.get_unit_temp();\n+                        // Execute the body, branching back to the test.\n+                        let body_block_end = unpack!(this.into(&tmp, body_block, body));\n+                        this.cfg.terminate(body_block_end, source_info,\n+                                           TerminatorKind::Goto { target: loop_block });\n+                    }\n+                );\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args } => {"}, {"sha": "f04d630379a35c99ed6dfdb27b3515190fe9daf1", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,9 +11,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::scope::LoopScope;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n-use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n@@ -79,14 +77,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                this.break_or_continue(expr_span, label, block,\n-                                       |loop_scope| loop_scope.continue_block)\n+                let LoopScope { continue_block, extent, .. } =\n+                    *this.find_loop_scope(expr_span, label);\n+                this.exit_scope(expr_span, extent, block, continue_block);\n+                this.cfg.start_new_block().unit()\n             }\n-            ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block, |loop_scope| {\n-                    loop_scope.might_break = true;\n-                    loop_scope.break_block\n-                })\n+            ExprKind::Break { label, value } => {\n+                let (break_block, extent, destination) = {\n+                    let LoopScope {\n+                        break_block,\n+                        extent,\n+                        ref break_destination,\n+                        ..\n+                    } = *this.find_loop_scope(expr_span, label);\n+                    (break_block, extent, break_destination.clone())\n+                };\n+                if let Some(value) = value {\n+                    unpack!(block = this.into(&destination, block, value))\n+                } else {\n+                    this.cfg.push_assign_unit(block, source_info, &destination)\n+                }\n+                this.exit_scope(expr_span, extent, block, break_block);\n+                this.cfg.start_new_block().unit()\n             }\n             ExprKind::Return { value } => {\n                 block = match value {\n@@ -115,20 +127,4 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn break_or_continue<F>(&mut self,\n-                            span: Span,\n-                            label: Option<CodeExtent>,\n-                            block: BasicBlock,\n-                            exit_selector: F)\n-                            -> BlockAnd<()>\n-        where F: FnOnce(&mut LoopScope) -> BasicBlock\n-    {\n-        let (exit_block, extent) = {\n-            let loop_scope = self.find_loop_scope(span, label);\n-            (exit_selector(loop_scope), loop_scope.extent)\n-        };\n-        self.exit_scope(span, extent, block, exit_block);\n-        self.cfg.start_new_block().unit()\n-    }\n-\n }"}, {"sha": "5713ee45b9d8f4c5927285d84ea993567b1f7053", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,7 +18,7 @@ use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -38,7 +38,7 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// the current set of loops; see the `scope` module for more\n     /// details\n-    loop_scopes: Vec<scope::LoopScope>,\n+    loop_scopes: Vec<scope::LoopScope<'tcx>>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later"}, {"sha": "e5fac94a8a494eb2f344a6fb5ae6964b01cae69a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -177,16 +177,17 @@ struct FreeData<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct LoopScope {\n+pub struct LoopScope<'tcx> {\n     /// Extent of the loop\n     pub extent: CodeExtent,\n     /// Where the body of the loop begins\n     pub continue_block: BasicBlock,\n     /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n     /// having its condition to become false)\n     pub break_block: BasicBlock,\n-    /// Indicates the reachability of the break_block for this loop\n-    pub might_break: bool\n+    /// The destination of the loop expression itself (i.e. where to put the result of a `break`\n+    /// expression)\n+    pub break_destination: Lvalue<'tcx>,\n }\n \n impl<'tcx> Scope<'tcx> {\n@@ -246,24 +247,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// Returns the might_break attribute of the LoopScope used.\n     pub fn in_loop_scope<F>(&mut self,\n-                               loop_block: BasicBlock,\n-                               break_block: BasicBlock,\n-                               f: F)\n-                               -> bool\n+                            loop_block: BasicBlock,\n+                            break_block: BasicBlock,\n+                            break_destination: Lvalue<'tcx>,\n+                            f: F)\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n         let extent = self.extent_of_innermost_scope();\n         let loop_scope = LoopScope {\n             extent: extent.clone(),\n             continue_block: loop_block,\n             break_block: break_block,\n-            might_break: false\n+            break_destination: break_destination,\n         };\n         self.loop_scopes.push(loop_scope);\n         f(self);\n         let loop_scope = self.loop_scopes.pop().unwrap();\n         assert!(loop_scope.extent == extent);\n-        loop_scope.might_break\n     }\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn find_loop_scope(&mut self,\n                            span: Span,\n                            label: Option<CodeExtent>)\n-                           -> &mut LoopScope {\n+                           -> &mut LoopScope<'tcx> {\n         let loop_scopes = &mut self.loop_scopes;\n         match label {\n             None => {"}, {"sha": "6fa2672593587b2f0885fa08f4e1cc73e67ff58b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -21,7 +21,6 @@ use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n-use rustc::mir::*;\n use rustc::hir;\n use syntax::ptr::P;\n \n@@ -559,8 +558,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n         hir::ExprRet(ref v) =>\n             ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label) =>\n-            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)) },\n+        hir::ExprBreak(label, ref value) =>\n+            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)),\n+                              value: value.to_ref() },\n         hir::ExprAgain(label) =>\n             ExprKind::Continue { label: label.map(|_| loop_label(cx, expr)) },\n         hir::ExprMatch(ref discr, ref arms, _) =>\n@@ -573,7 +573,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprWhile(ref cond, ref body, _) =>\n             ExprKind::Loop { condition: Some(cond.to_ref()),\n                              body: block::to_expr_ref(cx, body) },\n-        hir::ExprLoop(ref body, _) =>\n+        hir::ExprLoop(ref body, _, _) =>\n             ExprKind::Loop { condition: None,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {"}, {"sha": "cfeac606f03d0c45cb8264a2ad1b6e78076b09c7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,7 +16,6 @@\n  */\n \n use hair::*;\n-use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n@@ -29,7 +28,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n@@ -121,7 +120,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn str_literal(&mut self, value: token::InternedString) -> Literal<'tcx> {\n+    pub fn str_literal(&mut self, value: InternedString) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Str(value) }\n     }\n \n@@ -145,7 +144,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         self_ty: Ty<'tcx>,\n                         params: &[Ty<'tcx>])\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n-        let method_name = token::intern(method_name);\n+        let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {"}, {"sha": "50eee7723964e0cc18b346b9ba12e6420eb518dd", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -202,6 +202,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Break {\n         label: Option<CodeExtent>,\n+        value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n         label: Option<CodeExtent>,"}, {"sha": "62e405564dbb72b10a444302bc59d8284f5fb6e6", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(associated_consts)]\n #![feature(box_patterns)]\n #![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n+#![cfg_attr(stage0, feature(item_like_imports))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "a3916e7eca35104b8bbd246630ec45db25e85c06", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -21,7 +21,8 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;\n@@ -39,7 +40,7 @@ impl<'a> AstValidator<'a> {\n         if label.name == keywords::StaticLifetime.name() {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n-        if label.name.as_str() == \"'_\" {\n+        if label.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   id,\n                                   span,\n@@ -89,7 +90,7 @@ impl<'a> AstValidator<'a> {\n \n impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n-        if lt.name.as_str() == \"'_\" {\n+        if lt.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   lt.id,\n                                   lt.span,\n@@ -105,7 +106,7 @@ impl<'a> Visitor for AstValidator<'a> {\n             ExprKind::Loop(_, Some(ident)) |\n             ExprKind::WhileLet(.., Some(ident)) |\n             ExprKind::ForLoop(.., Some(ident)) |\n-            ExprKind::Break(Some(ident)) |\n+            ExprKind::Break(Some(ident), _) |\n             ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span, expr.id);\n             }\n@@ -206,6 +207,13 @@ impl<'a> Visitor for AstValidator<'a> {\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n+                if let Some(attr) =\n+                        item.attrs.iter().find(|attr| attr.name() == \"warn_directory_ownership\") {\n+                    let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n+                    let msg = \"cannot declare a new module at this location\";\n+                    self.session.add_lint(lint, item.id, item.span, msg.to_string());\n+                    attr::mark_used(attr);\n+                }\n             }\n             ItemKind::Union(ref vdata, _) => {\n                 if !vdata.is_struct() {"}, {"sha": "4d8520ed0440a1259fc0124ad9160bf27c2da03b", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -610,7 +610,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprLoop(..) |\n \n         // More control flow (also not very meaningful).\n-        hir::ExprBreak(_) |\n+        hir::ExprBreak(..) |\n         hir::ExprAgain(_) |\n         hir::ExprRet(_) |\n "}, {"sha": "b2ef1abd2a4e78eca2c7f6ad44737a4538bfefff", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -228,4 +228,5 @@ pub impl Foo for Bar {\n register_diagnostics! {\n     E0472, // asm! is unsupported on this target\n     E0561, // patterns aren't allowed in function pointer types\n+    E0571, // `break` with a value in a non-`loop`-loop\n }"}, {"sha": "dafb7bc6e60996d67482cb982f4e83b19071e9cf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -240,7 +240,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.record(\"Attribute\", Id::Attr(attr.node.id), attr);\n+        self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n         self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);"}, {"sha": "c909e75afc1f579c5328a528266d3dbd035005e3", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 71, "deletions": 12, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -12,34 +12,56 @@ use self::Context::*;\n use rustc::session::Session;\n \n use rustc::dep_graph::DepNode;\n+use rustc::hir::def::{Def, DefMap};\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n use syntax_pos::Span;\n \n+#[derive(Clone, Copy, PartialEq)]\n+enum LoopKind {\n+    Loop(hir::LoopSource),\n+    WhileLoop,\n+}\n+\n+impl LoopKind {\n+    fn name(self) -> &'static str {\n+        match self {\n+            LoopKind::Loop(hir::LoopSource::Loop) => \"loop\",\n+            LoopKind::Loop(hir::LoopSource::WhileLet) => \"while let\",\n+            LoopKind::Loop(hir::LoopSource::ForLoop) => \"for\",\n+            LoopKind::WhileLoop => \"while\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq)]\n enum Context {\n     Normal,\n-    Loop,\n+    Loop(LoopKind),\n     Closure,\n }\n \n #[derive(Copy, Clone)]\n-struct CheckLoopVisitor<'a> {\n+struct CheckLoopVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n+    def_map: &'a DefMap,\n+    hir_map: &'a Map<'ast>,\n     cx: Context,\n }\n \n-pub fn check_crate(sess: &Session, map: &Map) {\n+pub fn check_crate(sess: &Session, def_map: &DefMap, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n     krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,\n+        def_map: def_map,\n+        hir_map: map,\n         cx: Normal,\n     }.as_deep_visitor());\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n+impl<'a, 'ast, 'v> Visitor<'v> for CheckLoopVisitor<'a, 'ast> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n@@ -51,25 +73,62 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {\n-                self.visit_expr(&e);\n-                self.with_context(Loop, |v| v.visit_block(&b));\n+                self.with_context(Loop(LoopKind::WhileLoop), |v| {\n+                    v.visit_expr(&e);\n+                    v.visit_block(&b);\n+                });\n             }\n-            hir::ExprLoop(ref b, _) => {\n-                self.with_context(Loop, |v| v.visit_block(&b));\n+            hir::ExprLoop(ref b, _, source) => {\n+                self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., ref b, _) => {\n                 self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n-            hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n+            hir::ExprBreak(ref opt_label, ref opt_expr) => {\n+                if opt_expr.is_some() {\n+                    let loop_kind = if opt_label.is_some() {\n+                        let loop_def = self.def_map.get(&e.id).unwrap().full_def();\n+                        if loop_def == Def::Err {\n+                            None\n+                        } else if let Def::Label(loop_id) = loop_def {\n+                            Some(match self.hir_map.expect_expr(loop_id).node {\n+                                hir::ExprWhile(..) => LoopKind::WhileLoop,\n+                                hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                                ref r => span_bug!(e.span,\n+                                                   \"break label resolved to a non-loop: {:?}\", r),\n+                            })\n+                        } else {\n+                            span_bug!(e.span, \"break resolved to a non-label\")\n+                        }\n+                    } else if let Loop(kind) = self.cx {\n+                        Some(kind)\n+                    } else {\n+                        // `break` outside a loop - caught below\n+                        None\n+                    };\n+                    match loop_kind {\n+                        None | Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n+                        Some(kind) => {\n+                            struct_span_err!(self.sess, e.span, E0571,\n+                                             \"`break` with value from a `{}` loop\",\n+                                             kind.name())\n+                                .span_label(e.span,\n+                                            &format!(\"can only break with a value inside `loop`\"))\n+                                .emit();\n+                        }\n+                    }\n+                }\n+                self.require_loop(\"break\", e.span);\n+            }\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n             _ => intravisit::walk_expr(self, e),\n         }\n     }\n }\n \n-impl<'a> CheckLoopVisitor<'a> {\n+impl<'a, 'ast> CheckLoopVisitor<'a, 'ast> {\n     fn with_context<F>(&mut self, cx: Context, f: F)\n-        where F: FnOnce(&mut CheckLoopVisitor<'a>)\n+        where F: FnOnce(&mut CheckLoopVisitor<'a, 'ast>)\n     {\n         let old_cx = self.cx;\n         self.cx = cx;\n@@ -79,7 +138,7 @@ impl<'a> CheckLoopVisitor<'a> {\n \n     fn require_loop(&self, name: &str, span: Span) {\n         match self.cx {\n-            Loop => {}\n+            Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n                 .span_label(span, &format!(\"cannot break inside of a closure\"))"}, {"sha": "1bfc445fca98d72ca4f7c8f03a92b63dda875fc1", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -69,9 +69,9 @@ pub fn load_plugins(sess: &Session,\n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n                 match plugin.name() {\n-                    Some(ref name) if !plugin.is_value_str() => {\n+                    Some(name) if !plugin.is_value_str() => {\n                         let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n+                        loader.load_plugin(plugin.span, &name.as_str(), args.unwrap_or_default());\n                     },\n                     _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }"}, {"sha": "fe2f9713d1beb29ae0cafd35af921d9fb1711572", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::transform::MirMapPass;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -101,7 +101,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n-        if name.as_str() == \"macro_rules\" {\n+        if name == \"macro_rules\" {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {\n@@ -121,7 +121,7 @@ impl<'a> Registry<'a> {\n     /// It builds for you a `NormalTT` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(token::intern(name),\n+        self.register_syntax_extension(Symbol::intern(name),\n                                        NormalTT(Box::new(expander), None, false));\n     }\n "}, {"sha": "ff2f25a12fc8607874a99d4c945a6a59eb38233e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -31,7 +31,6 @@ use std::rc::Rc;\n \n use syntax::ast::Name;\n use syntax::attr;\n-use syntax::parse::token;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n@@ -41,7 +40,7 @@ use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -139,7 +138,7 @@ impl<'b> Resolver<'b> {\n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let mut source = full_path.segments.last().unwrap().identifier;\n-                        let source_name = source.name.as_str();\n+                        let source_name = source.name;\n                         if source_name == \"mod\" || source_name == \"self\" {\n                             resolve_error(self,\n                                           view_path.span,\n@@ -582,7 +581,7 @@ impl<'b> Resolver<'b> {\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n                 if let Success(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -592,7 +591,7 @@ impl<'b> Resolver<'b> {\n         }\n         for (name, span) in legacy_imports.reexports {\n             self.used_crates.insert(module.def_id().unwrap().krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n             if let Success(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -607,7 +606,7 @@ impl<'b> Resolver<'b> {\n             if attr.check_name(\"macro_escape\") {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n                 let mut err = self.session.struct_span_warn(attr.span, msg);\n-                if let ast::AttrStyle::Inner = attr.node.style {\n+                if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n                 } else {\n                     err.emit();\n@@ -632,7 +631,7 @@ impl<'b> Resolver<'b> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((token::intern(&word.name()), attr.span()));\n+                            imports.imports.push((word.name(), attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }\n@@ -646,7 +645,7 @@ impl<'b> Resolver<'b> {\n                 if let Some(names) = attr.meta_item_list() {\n                     for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.reexports.push((token::intern(&word.name()), attr.span()));\n+                            imports.reexports.push((word.name(), attr.span()));\n                         } else {\n                             bad_macro_reexport(self, attr.span());\n                         }"}, {"sha": "d54f4e7b20c7a709fe2972823ee177c23dfc1f2d", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -59,7 +59,7 @@ items under a new local name.\n \n An example of this error:\n \n-```compile_fail\n+```ignore\n use foo::baz;\n use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n "}, {"sha": "ab3d361a940f9ed9dba097742ff07302db613b76", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -57,7 +57,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -90,7 +90,7 @@ mod resolve_imports;\n \n enum SuggestionType {\n     Macro(String),\n-    Function(token::InternedString),\n+    Function(Symbol),\n     NotFound,\n }\n \n@@ -1039,7 +1039,7 @@ impl PrimitiveTypeTable {\n     }\n \n     fn intern(&mut self, string: &str, primitive_type: PrimTy) {\n-        self.primitive_types.insert(token::intern(string), primitive_type);\n+        self.primitive_types.insert(Symbol::intern(string), primitive_type);\n     }\n }\n \n@@ -1131,7 +1131,6 @@ pub struct Resolver<'a> {\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n-    new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n     use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -1333,7 +1332,6 @@ impl<'a> Resolver<'a> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n-            new_import_semantics: session.features.borrow().item_like_imports,\n             use_extern_macros: session.features.borrow().use_extern_macros,\n \n             exported_macros: Vec::new(),\n@@ -1442,7 +1440,7 @@ impl<'a> Resolver<'a> {\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, false, None) {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n                     search_parent_externals(this, needle, parent)\n@@ -1460,9 +1458,8 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, false, span) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(_) => {\n-                    let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let msg = if \"???\" == &module_name {\n                         let current_module = self.current_module;\n@@ -1480,10 +1477,10 @@ impl<'a> Resolver<'a> {\n \n                                 format!(\"Did you mean `{}{}`?\", prefix, path_str)\n                             }\n-                            None => format!(\"Maybe a missing `extern crate {};`?\", segment_name),\n+                            None => format!(\"Maybe a missing `extern crate {};`?\", name),\n                         }\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", segment_name, module_name)\n+                        format!(\"Could not find `{}` in `{}`\", name, module_name)\n                     };\n \n                     return Failed(span.map(|span| (span, msg)));\n@@ -1617,7 +1614,7 @@ impl<'a> Resolver<'a> {\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, true, false, record_used);\n+                let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1626,7 +1623,7 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -1651,7 +1648,7 @@ impl<'a> Resolver<'a> {\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n-        if &*module_path[0].name.as_str() == \"$crate\" {\n+        if module_path[0].name == \"$crate\" {\n             return Success(PrefixFound(self.resolve_crate_var(module_path[0].ctxt), 1));\n         }\n \n@@ -1667,7 +1664,7 @@ impl<'a> Resolver<'a> {\n             self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() && \"super\" == module_path[i].name.as_str() {\n+        while i < module_path.len() && module_path[i].name == \"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n             if let Some(parent) = containing_module.parent {\n@@ -2635,7 +2632,7 @@ impl<'a> Resolver<'a> {\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n             (Ok(binding), Some(ref ud)) if binding.def() == ud.def &&\n-                                           segments[0].identifier.name.as_str() != \"$crate\" => {\n+                                           segments[0].identifier.name != \"$crate\" => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2772,7 +2769,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2800,7 +2797,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let name = segments.last().unwrap().ident().name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2881,7 +2878,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.macro_names.iter().find(|n| n.as_str() == name) {\n+        if let Some(macro_name) = self.macro_names.iter().find(|&n| n == &name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n@@ -2891,7 +2888,7 @@ impl<'a> Resolver<'a> {\n                     .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n-            if name != found {\n+            if found != name {\n                 return SuggestionType::Function(found);\n             }\n         } SuggestionType::NotFound\n@@ -3000,8 +2997,7 @@ impl<'a> Resolver<'a> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope &&\n-                                    &path_name[..] == keywords::SelfValue.name().as_str() {\n+                            if method_scope && keywords::SelfValue.name() == &*path_name {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);\n@@ -3078,22 +3074,25 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n+            ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n                 match self.search_label(label.node) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n+                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()));\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read.\n-                        self.record_def(expr.id, PathResolution::new(def))\n+                        self.record_def(expr.id, PathResolution::new(def));\n                     }\n                     Some(_) => {\n-                        span_bug!(expr.span, \"label wasn't mapped to a label def!\")\n+                        span_bug!(expr.span, \"label wasn't mapped to a label def!\");\n                     }\n                 }\n+\n+                // visit `break` argument if any\n+                visit::walk_expr(self, expr);\n             }\n \n             ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n@@ -3606,7 +3605,7 @@ fn module_to_string(module: Module) -> String {\n             }\n         } else {\n             // danger, shouldn't be ident?\n-            names.push(token::str_to_ident(\"<opaque>\"));\n+            names.push(Ident::from_str(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }"}, {"sha": "62adf382a69add955ddddc8125e83a7785f9124f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -27,7 +27,6 @@ use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::fold::Folder;\n-use syntax::parse::token::intern;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n@@ -116,7 +115,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n-                if &ident.name.as_str() == \"$crate\" {\n+                if ident.name == \"$crate\" {\n                     path.global = true;\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n                     if module.is_local() {\n@@ -152,7 +151,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n-        if &def.ident.name.as_str() == \"macro_rules\" {\n+        if def.ident.name == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n@@ -207,8 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n-            let name = intern(&attrs[i].name());\n-            match self.builtin_macros.get(&name).cloned() {\n+            match self.builtin_macros.get(&attrs[i].name()).cloned() {\n                 Some(binding) => match *self.get_macro(binding) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -272,7 +270,7 @@ impl<'a> Resolver<'a> {\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_name_in_module(module, name, ns, true, true, record_used) {\n+            match self.resolve_name_in_module(module, name, ns, true, record_used) {\n                 Success(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,"}, {"sha": "47bd1f71084aa3ae24b494b2fd42ffe8cc856b3d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -75,7 +75,6 @@ pub struct NameResolution<'a> {\n     single_imports: SingleImports<'a>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n-    duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -141,7 +140,6 @@ impl<'a> Resolver<'a> {\n                                   module: Module<'a>,\n                                   name: Name,\n                                   ns: Namespace,\n-                                  allow_private_imports: bool,\n                                   ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n                                   -> ResolveResult<&'a NameBinding<'a>> {\n@@ -153,18 +151,8 @@ impl<'a> Resolver<'a> {\n             _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n-        let new_import_semantics = self.new_import_semantics;\n-        let is_disallowed_private_import = |binding: &NameBinding| {\n-            !new_import_semantics && !allow_private_imports && // disallowed\n-            binding.vis != ty::Visibility::Public && binding.is_import() && // non-`pub` import\n-            !binding.is_extern_crate() // not an `extern crate`\n-        };\n-\n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n-                if is_disallowed_private_import(binding) {\n-                    return Failed(None);\n-                }\n                 if self.record_use(name, ns, binding, span) {\n                     return Success(self.dummy_binding);\n                 }\n@@ -177,9 +165,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            let usable =\n-                this.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n-                binding.is_extern_crate(); // c.f. issue #37020\n+            // `extern crate` are always usable for backwards compatability, see issue #37020.\n+            let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n             if usable { Success(binding) } else { Failed(None) }\n         };\n \n@@ -202,7 +189,7 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, true, false, None) {\n+                match self.resolve_name_in_module(module, name, ns, false, None) {\n                     Failed(_) => {}\n                     _ => return Indeterminate,\n                 }\n@@ -224,7 +211,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, true, false, None);\n+                    let result = self.resolve_name_in_module(module, name, ns, false, None);\n                     if let Indeterminate = result {\n                         return Indeterminate;\n                     }\n@@ -311,22 +298,17 @@ impl<'a> Resolver<'a> {\n         self.update_resolution(module, name, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n-                    if !this.new_import_semantics {\n-                        resolution.duplicate_globs.push(binding);\n-                    } else if !old_binding.is_glob_import() &&\n-                              !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n+                    if !old_binding.is_glob_import() &&\n+                       !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n                     } else if binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n                 } else if old_binding.is_glob_import() {\n-                    if !this.new_import_semantics {\n-                        resolution.duplicate_globs.push(old_binding);\n-                        resolution.binding = Some(binding);\n-                    } else if ns == MacroNS && binding.expansion != Mark::root() &&\n-                              binding.def() != old_binding.def() {\n+                    if ns == MacroNS && binding.expansion != Mark::root() &&\n+                       binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(binding, old_binding));\n                     } else {\n                         resolution.binding = Some(binding);\n@@ -366,7 +348,7 @@ impl<'a> Resolver<'a> {\n             let t = f(self, resolution);\n \n             match resolution.binding() {\n-                _ if !self.new_import_semantics && old_binding.is_some() => return t,\n+                _ if old_binding.is_some() => return t,\n                 None => return t,\n                 Some(binding) => match old_binding {\n                     Some(old_binding) if old_binding as *const _ == binding as *const _ => return t,\n@@ -377,10 +359,7 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            if match self.new_import_semantics {\n-                true => self.is_accessible_from(binding.vis, directive.parent),\n-                false => binding.vis == ty::Visibility::Public,\n-            } {\n+            if self.is_accessible_from(binding.vis, directive.parent) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n@@ -528,7 +507,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n                 result[ns].set({\n-                    match this.resolve_name_in_module(module, source, ns, false, false, None) {\n+                    match this.resolve_name_in_module(module, source, ns, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(Undetermined),\n                         Failed(_) => Err(Determined),\n@@ -624,7 +603,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, false, Some(span)) {\n+                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n                     Success(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n@@ -729,8 +708,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.pseudo_vis() == ty::Visibility::Public ||\n-               self.new_import_semantics && self.is_accessible(binding.vis) {\n+            if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n@@ -761,20 +739,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 None => continue,\n             };\n \n-            // Report conflicts\n-            if !self.new_import_semantics {\n-                for duplicate_glob in resolution.duplicate_globs.iter() {\n-                    // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n-                    if !binding.is_import() {\n-                        if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n-                            if binding.is_import() { continue }\n-                        }\n-                    }\n-\n-                    self.report_conflict(module, name, ns, duplicate_glob, binding);\n-                }\n-            }\n-\n             if binding.vis == ty::Visibility::Public &&\n                (binding.is_import() || binding.is_extern_crate()) {\n                 let def = binding.def();"}, {"sha": "87b2b88fe33fccb7dac9494aecc7a86ac805cf97", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -39,7 +39,8 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::*;\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n use syntax::ptr::P;"}, {"sha": "bd5da588a864d2228f91eccabfc43e4000b9d2aa", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -54,7 +54,8 @@ use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n-use syntax::parse::token::{self, keywords, InternedString};\n+use syntax::parse::token;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n@@ -119,7 +120,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             };\n             result.push(CrateData {\n-                name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n+                name: self.tcx.sess.cstore.crate_name(n).to_string(),\n                 number: n.as_u32(),\n                 span: span,\n             });\n@@ -728,16 +729,16 @@ impl Visitor for PathCollector {\n }\n \n fn docs_for_attrs(attrs: &[Attribute]) -> String {\n-    let doc = InternedString::new(\"doc\");\n+    let doc = Symbol::intern(\"doc\");\n     let mut result = String::new();\n \n     for attr in attrs {\n         if attr.name() == doc {\n-            if let Some(ref val) = attr.value_str() {\n-                if attr.node.is_sugared_doc {\n-                    result.push_str(&strip_doc_comment_decoration(val));\n+            if let Some(val) = attr.value_str() {\n+                if attr.is_sugared_doc {\n+                    result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n                 } else {\n-                    result.push_str(val);\n+                    result.push_str(&val.as_str());\n                 }\n                 result.push('\\n');\n             }"}, {"sha": "e06aefd865f1ba6486c1dadf5ab4bb10081f0f84", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,7 +18,8 @@ use std::path::Path;\n \n use syntax::ast;\n use syntax::parse::lexer::{self, Reader, StringReader};\n-use syntax::parse::token::{self, keywords, Token};\n+use syntax::parse::token::{self, Token};\n+use syntax::symbol::keywords;\n use syntax_pos::*;\n \n #[derive(Clone)]"}, {"sha": "665e12cbe87955e624cfeb2ef7e5b03e297718db", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -88,7 +88,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         AsmDialect::Intel => llvm::AsmDialect::Intel,\n     };\n \n-    let asm = CString::new(ia.asm.as_bytes()).unwrap();\n+    let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n     let constraint_cstr = CString::new(all_constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),"}, {"sha": "898e65ce391e609dd295dc29971a85cb09075f42", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -29,7 +29,6 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n \n use {ModuleSource, ModuleTranslation};\n \n@@ -77,7 +76,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n \n         let mname = self.field(attr, MODULE);\n-        let mtrans = self.modules.iter().find(|mtrans| &mtrans.name[..] == &mname[..]);\n+        let mtrans = self.modules.iter().find(|mtrans| *mtrans.name == *mname.as_str());\n         let mtrans = match mtrans {\n             Some(m) => m,\n             None => {\n@@ -113,7 +112,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: &str) -> InternedString {\n+    fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n@@ -137,7 +136,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         let config = &self.tcx.sess.parse_sess.config;\n         let value = self.field(attr, CFG);\n         debug!(\"check_config(config={:?}, value={:?})\", config, value);\n-        if config.iter().any(|c| c.check_name(&value[..])) {\n+        if config.iter().any(|&(name, _)| name == value) {\n             debug!(\"check_config: matched\");\n             return true;\n         }"}, {"sha": "11ab6dcaa87f99fa02a99fac8d9068d8c462d2c1", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -231,7 +231,7 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n-        let kind = &self.config.sess.target.target.options.archive_format[..];\n+        let kind = &*self.config.sess.target.target.options.archive_format;\n         kind.parse().map_err(|_| kind)\n     }\n "}, {"sha": "648dc4c24c9a658c79426f2b53d2f5c707ca7f6a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,7 +19,7 @@ use session::config::{OutputFilenames, Input, OutputType};\n use session::filesearch;\n use session::search_paths::PathKind;\n use session::Session;\n-use middle::cstore::{self, LinkMeta, NativeLibrary};\n+use middle::cstore::{self, LinkMeta, NativeLibrary, LibSource};\n use middle::cstore::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -44,6 +44,7 @@ use std::str;\n use flate;\n use syntax::ast;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n@@ -93,8 +94,8 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != &name[..] {\n+            if let Some((attr, name)) = attr_crate_name {\n+                if name != &**s {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n@@ -123,14 +124,13 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     \"rust_out\".to_string()\n-\n }\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n                        name: &str)\n                        -> LinkMeta {\n     let r = LinkMeta {\n-        crate_name: name.to_owned(),\n+        crate_name: Symbol::intern(name),\n         crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n@@ -263,6 +263,9 @@ pub fn filename_for_input(sess: &Session,\n         config::CrateTypeRlib => {\n             outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n         }\n+        config::CrateTypeMetadata => {\n+            outputs.out_directory.join(&format!(\"lib{}.rmeta\", libname))\n+        }\n         config::CrateTypeCdylib |\n         config::CrateTypeProcMacro |\n         config::CrateTypeDylib => {\n@@ -298,7 +301,7 @@ pub fn each_linked_rlib(sess: &Session,\n                    .or_else(|| fmts.get(&config::CrateTypeCdylib))\n                    .or_else(|| fmts.get(&config::CrateTypeProcMacro));\n     let fmts = fmts.unwrap_or_else(|| {\n-        bug!(\"could not find formats for rlibs\")\n+        bug!(\"could not find formats for rlibs\");\n     });\n     for (cnum, path) in crates {\n         match fmts[cnum.as_usize() - 1] {\n@@ -307,8 +310,12 @@ pub fn each_linked_rlib(sess: &Session,\n         }\n         let name = sess.cstore.crate_name(cnum).clone();\n         let path = match path {\n-            Some(p) => p,\n-            None => {\n+            LibSource::Some(p) => p,\n+            LibSource::MetadataOnly => {\n+                sess.fatal(&format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n+                                    name));\n+            }\n+            LibSource::None => {\n                 sess.fatal(&format!(\"could not find rlib for: `{}`\", name));\n             }\n         };\n@@ -352,6 +359,9 @@ fn link_binary_output(sess: &Session,\n         config::CrateTypeStaticlib => {\n             link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n         }\n+        config::CrateTypeMetadata => {\n+            emit_metadata(sess, trans, &out_filename);\n+        }\n         _ => {\n             link_natively(sess, crate_type, &objects, &out_filename, trans,\n                           outputs, tmpdir.path());\n@@ -390,6 +400,13 @@ fn archive_config<'a>(sess: &'a Session,\n     }\n }\n \n+fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, out_filename: &Path) {\n+    let result = fs::File::create(out_filename).and_then(|mut f| f.write_all(&trans.metadata));\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    }\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -403,6 +420,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                  tmpdir: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n+\n     for obj in objects {\n         ab.add_file(obj);\n     }\n@@ -429,7 +447,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             NativeLibraryKind::NativeFramework |\n             NativeLibraryKind::NativeUnknown => continue,\n         }\n-        ab.add_native_library(&lib.name);\n+        ab.add_native_library(&lib.name.as_str());\n     }\n \n     // After adding all files to the archive, we need to update the\n@@ -464,15 +482,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n             let metadata = tmpdir.join(sess.cstore.metadata_filename());\n-            match fs::File::create(&metadata).and_then(|mut f| {\n-                f.write_all(&trans.metadata)\n-            }) {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    sess.fatal(&format!(\"failed to write {}: {}\",\n-                                        metadata.display(), e));\n-                }\n-            }\n+            emit_metadata(sess, trans, &metadata);\n             ab.add_file(&metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n@@ -615,7 +625,7 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n         let skip_object_files = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n-        ab.add_rlib(path, &name, sess.lto(), skip_object_files).unwrap();\n+        ab.add_rlib(path, &name.as_str(), sess.lto(), skip_object_files).unwrap();\n \n         all_native_libs.extend(sess.cstore.native_libraries(cnum));\n     });\n@@ -934,15 +944,15 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         // don't otherwise explicitly reference them. This can occur for\n         // libraries which are just providing bindings, libraries with generic\n         // functions, etc.\n-        cmd.link_whole_staticlib(&l.name, &search_path);\n+        cmd.link_whole_staticlib(&l.name.as_str(), &search_path);\n     }\n \n     cmd.hint_dynamic();\n \n     for lib in others {\n         match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n             NativeLibraryKind::NativeStatic => bug!(),\n         }\n     }\n@@ -1185,8 +1195,8 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n                 continue\n             }\n             match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n \n                 // ignore statically included native libraries here as we've\n                 // already included them when we included the rust library"}, {"sha": "ccaa0d4e1b1b059de8214d48454ea049d7897eac", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,9 +14,10 @@ use std::path::{Path, PathBuf};\n use std::fs;\n \n use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(CrateNum, Option<PathBuf>)>,\n+    pub used_crates: Vec<(CrateNum, LibSource)>,\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n@@ -35,7 +36,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| l).collect::<Vec<_>>();\n+    let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs[..]);\n     flags.extend_from_slice(&rpaths_to_flags(&rpaths[..]));\n "}, {"sha": "ff40cfda5ff7cb7a865622a3f8c6c69431e068c9", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -113,7 +113,7 @@ use rustc::hir::map::definitions::{DefPath, DefPathData};\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n@@ -275,7 +275,7 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n \n     fn push(&mut self, text: &str) {\n-        self.names.push(token::intern(text).as_str());\n+        self.names.push(Symbol::intern(text).as_str());\n     }\n }\n \n@@ -288,7 +288,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n         krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n-    let path = [token::intern_and_get_ident(prefix)];\n+    let path = [Symbol::intern(prefix).as_str()];\n     mangle(path.iter().cloned(), &hash)\n }\n "}, {"sha": "4353c7bd58645fb1a8b957cd8b3de5243935a9ee", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1128,11 +1128,11 @@ pub fn set_link_section(ccx: &CrateContext,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n     if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n-        if contains_null(&sect) {\n+        if contains_null(&sect.as_str()) {\n             ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n         unsafe {\n-            let buf = CString::new(sect.as_bytes()).unwrap();\n+            let buf = CString::new(sect.as_str().as_bytes()).unwrap();\n             llvm::LLVMSetSection(llval, buf.as_ptr());\n         }\n     }\n@@ -1260,7 +1260,8 @@ fn write_metadata(cx: &SharedCrateContext,\n             config::CrateTypeStaticlib |\n             config::CrateTypeCdylib => MetadataKind::None,\n \n-            config::CrateTypeRlib => MetadataKind::Uncompressed,\n+            config::CrateTypeRlib |\n+            config::CrateTypeMetadata => MetadataKind::Uncompressed,\n \n             config::CrateTypeDylib |\n             config::CrateTypeProcMacro => MetadataKind::Compressed,\n@@ -1600,7 +1601,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n-    if tcx.sess.opts.debugging_opts.no_trans {\n+    if tcx.sess.opts.debugging_opts.no_trans ||\n+       tcx.sess.crate_types.borrow().iter().all(|ct| ct == &config::CrateTypeMetadata) {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n         return CrateTranslation {\n             modules: modules,"}, {"sha": "5c7b004375ed4b778aacf20c16d945633d061b8a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                 -> bool {\n             (bare_fn_ty.abi == Abi::RustIntrinsic ||\n              bare_fn_ty.abi == Abi::PlatformIntrinsic) &&\n-            tcx.item_name(def_id).as_str() == \"drop_in_place\"\n+            tcx.item_name(def_id) == \"drop_in_place\"\n         }\n     }\n }"}, {"sha": "29925d964da253d4b7a26ae008b72575bbf920a1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -52,8 +52,7 @@ use std::ffi::CString;\n use std::cell::{Cell, RefCell, Ref};\n \n use syntax::ast;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n pub use context::{CrateContext, SharedCrateContext};\n@@ -225,7 +224,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n                 VariantInfo {\n                     discr: Disr(0),\n                     fields: v.iter().enumerate().map(|(i, &t)| {\n-                        Field(token::intern(&i.to_string()), t)\n+                        Field(Symbol::intern(&i.to_string()), t)\n                     }).collect()\n                 }\n             }"}, {"sha": "4186721c122acdd839829c26b40c153f652e950b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -123,7 +123,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n                     // static and call it a day. Some linkages (like weak) will make it such\n                     // that the static actually has a null value.\n-                    let linkage = match base::llvm_linkage_by_name(&name) {\n+                    let linkage = match base::llvm_linkage_by_name(&name.as_str()) {\n                         Some(linkage) => linkage,\n                         None => {\n                             ccx.sess().span_fatal(span, \"invalid linkage specified\");"}, {"sha": "771c5ef6d9d28c019b45bdecc93be31b3d8293ad", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -42,7 +42,7 @@ use std::ptr;\n use std::rc::Rc;\n use std::str;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use abi::FnType;\n \n pub struct Stats {"}, {"sha": "5d01ca892b316c4c9849cacafb0c79f84e0937f1", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -44,10 +44,8 @@ use std::ffi::CString;\n use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n-use std::rc::Rc;\n-use syntax::util::interner::Interner;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::{Interner, InternedString};\n use syntax_pos::{self, Span};\n \n \n@@ -117,9 +115,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                 &unique_type_id_str[..]);\n+                 self.get_unique_type_id_as_string(unique_type_id));\n         }\n     }\n \n@@ -133,7 +130,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n     // Get the string representation of a UniqueTypeId. This method will fail if\n     // the id is unknown.\n-    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<str> {\n+    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> &str {\n         let UniqueTypeId(interner_key) = unique_type_id;\n         self.unique_id_interner.get(interner_key)\n     }\n@@ -182,7 +179,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           &self.get_unique_type_id_as_string(enum_type_id),\n+                                           self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n         UniqueTypeId(interner_key)\n@@ -623,29 +620,25 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    let unique_type_id_str =\n-                        type_map.get_unique_type_id_as_string(unique_type_id);\n                     span_bug!(usage_site_span,\n                               \"Expected type metadata for unique \\\n                                type id '{}' to already be in \\\n                                the debuginfo::TypeMap but it \\\n                                was not. (Ty = {})\",\n-                              &unique_type_id_str[..],\n+                              type_map.get_unique_type_id_as_string(unique_type_id),\n                               t);\n                 }\n             };\n \n             match type_map.find_metadata_for_type(t) {\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n-                        let unique_type_id_str =\n-                            type_map.get_unique_type_id_as_string(unique_type_id);\n                         span_bug!(usage_site_span,\n                                   \"Mismatch between Ty and \\\n                                    UniqueTypeId maps in \\\n                                    debuginfo::TypeMap. \\\n                                    UniqueTypeId={}, Ty={}\",\n-                                  &unique_type_id_str[..],\n+                                  type_map.get_unique_type_id_as_string(unique_type_id),\n                                   t);\n                     }\n                 }\n@@ -809,7 +802,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     };\n \n     fn fallback_path(scc: &SharedCrateContext) -> CString {\n-        CString::new(scc.link_meta().crate_name.clone()).unwrap()\n+        CString::new(scc.link_meta().crate_name.to_string()).unwrap()\n     }\n }\n \n@@ -1526,13 +1519,10 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n     let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx)\n-                             .type_map\n-                             .borrow()\n-                             .get_unique_type_id_as_string(unique_type_id);\n-\n     let enum_name = CString::new(enum_name).unwrap();\n-    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id_str = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let enum_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -1566,7 +1556,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_enum_discriminant_name(cx: &CrateContext,\n                                   def_id: DefId)\n-                                  -> token::InternedString {\n+                                  -> InternedString {\n         cx.tcx().item_name(def_id).as_str()\n     }\n }\n@@ -1669,11 +1659,10 @@ fn create_struct_stub(cx: &CrateContext,\n                    -> DICompositeType {\n     let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n     let name = CString::new(struct_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -1707,11 +1696,10 @@ fn create_union_stub(cx: &CrateContext,\n                    -> DICompositeType {\n     let (union_size, union_align) = size_and_align_of(cx, union_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n     let name = CString::new(union_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateUnionType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions"}, {"sha": "a0477c9fc1eee2ea93c9759edad86b4d0750e341", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -35,7 +35,7 @@ pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> S\n         }\n \n         let name = match def_key.disambiguated_data.data {\n-            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n             data => data.as_interned_str()\n         };\n \n@@ -64,7 +64,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n         data => data.as_interned_str()\n     };\n "}, {"sha": "fce1ce561055507c42a5d15d04785122232c0090", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -156,7 +156,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       qualified: bool,\n                       output: &mut String) {\n         if qualified {\n-            output.push_str(&cx.tcx().crate_name(def_id.krate));\n+            output.push_str(&cx.tcx().crate_name(def_id.krate).as_str());\n             for path_element in cx.tcx().def_path(def_id).data {\n                 output.push_str(\"::\");\n                 output.push_str(&path_element.data.as_interned_str());"}, {"sha": "016a76a72531b4c783292281927e621e605029c4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::{self, Ty};\n use Disr;\n use rustc::hir;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use rustc::session::Session;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -107,7 +107,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let sig = tcx.erase_late_bound_regions_and_normalize(&fty.sig);\n     let arg_tys = sig.inputs;\n     let ret_ty = sig.output;\n-    let name = tcx.item_name(def_id).as_str();\n+    let name = &*tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n         DebugLoc::ScopeAt(_, span) => span,\n@@ -123,15 +123,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Call(bcx, llfn, &[], call_debug_location);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if &name[..] == \"unreachable\" {\n+    } else if name == \"unreachable\" {\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n     }\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n-    let simple = get_simple_intrinsic(ccx, &name);\n-    let llval = match (simple, &name[..]) {\n+    let simple = get_simple_intrinsic(ccx, name);\n+    let llval = match (simple, name) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, call_debug_location)\n         }\n@@ -208,7 +208,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = substs.type_at(0);\n-            let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n+            let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n@@ -340,7 +340,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n-                    match &*name {\n+                    match name {\n                         \"ctlz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.ctlz.i{}\", width),\n                                                         llargs[0], call_debug_location),\n                         \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n@@ -394,7 +394,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sty = &arg_tys[0].sty;\n             match float_type_width(sty) {\n                 Some(_width) =>\n-                    match &*name {\n+                    match name {\n                         \"fadd_fast\" => FAddFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fsub_fast\" => FSubFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fmul_fast\" => FMulFast(bcx, llargs[0], llargs[1], call_debug_location),"}, {"sha": "29e6f6af416bcead29174057122ef460d6c69b38", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -30,7 +30,7 @@ use glue;\n use type_::Type;\n \n use rustc_data_structures::fx::FxHashMap;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n@@ -116,6 +116,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if let Some(cleanup_pad) = cleanup_pad {\n                     bcx.cleanup_ret(cleanup_pad, None);\n                 } else {\n+                    let llpersonality = bcx.fcx().eh_personality();\n+                    bcx.set_personality_fn(llpersonality);\n+\n                     let ps = self.get_personality_slot(&bcx);\n                     let lp = bcx.load(ps);\n                     bcx.with_block(|bcx| {\n@@ -321,7 +324,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n-                let filename = token::intern_and_get_ident(&loc.file.name);\n+                let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n \n@@ -351,7 +354,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n-                        let msg_str = token::intern_and_get_ident(err.description());\n+                        let msg_str = Symbol::intern(err.description()).as_str();\n                         let msg_str = C_str_slice(bcx.ccx(), msg_str);\n                         let msg_file_line = C_struct(bcx.ccx(),\n                                                      &[msg_str, filename, line],"}, {"sha": "12cbfcef7d26b17cc50f2a699cfac7c55da2bc6a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -21,7 +21,7 @@ use machine;\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n \n use std::cell::Ref;\n use std::iter;"}, {"sha": "a36960993e47148a13d4d2aefabda75038cd61ae", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -132,7 +132,7 @@ use std::sync::Arc;\n use std::collections::hash_map::DefaultHasher;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use trans_item::TransItem;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -272,7 +272,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n+        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n         debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -320,7 +320,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n-                None => InternedString::new(FALLBACK_CODEGEN_UNIT),\n+                None => Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str(),\n             };\n \n             let make_codegen_unit = || {\n@@ -365,7 +365,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // always ensure we have at least one CGU; otherwise, if we have a\n     // crate with just types (for example), we could wind up with no CGU\n     if codegen_units.is_empty() {\n-        let codegen_unit_name = InternedString::new(FALLBACK_CODEGEN_UNIT);\n+        let codegen_unit_name = Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str();\n         codegen_units.entry(codegen_unit_name.clone())\n                      .or_insert_with(|| CodegenUnit::empty(codegen_unit_name.clone()));\n     }\n@@ -523,7 +523,7 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut mod_path = String::with_capacity(64);\n \n     let def_path = tcx.def_path(def_id);\n-    mod_path.push_str(&tcx.crate_name(def_path.krate));\n+    mod_path.push_str(&tcx.crate_name(def_path.krate).as_str());\n \n     for part in tcx.def_path(def_id)\n                    .data\n@@ -542,14 +542,11 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         mod_path.push_str(\".volatile\");\n     }\n \n-    return token::intern_and_get_ident(&mod_path[..]);\n+    return Symbol::intern(&mod_path[..]).as_str();\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    token::intern_and_get_ident(&format!(\"{}{}{}\",\n-        crate_name,\n-        NUMBERED_CODEGEN_UNIT_MARKER,\n-        index)[..])\n+    Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,"}, {"sha": "f2d1e375793b3bf08754e9ef77143764cfb1418e", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         let attributes = tcx.get_attrs(def_id);\n         if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = base::llvm_linkage_by_name(&name) {\n+            if let Some(linkage) = base::llvm_linkage_by_name(&name.as_str()) {\n                 Some(linkage)\n             } else {\n                 let span = tcx.map.span_if_local(def_id);\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n         // some_crate::\n         if !(self.omit_local_crate_name && def_id.is_local()) {\n-            output.push_str(&self.tcx.crate_name(def_path.krate));\n+            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n             output.push_str(\"::\");\n         }\n "}, {"sha": "c5db8bc8cedc769d152913c6f8edc05d4348dbb5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -71,7 +71,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use std::cell::RefCell;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, Pos};\n use errors::DiagnosticBuilder;\n \n@@ -645,7 +645,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let output_binding = ConvertedBinding {\n-            item_name: token::intern(FN_OUTPUT_NAME),\n+            item_name: Symbol::intern(FN_OUTPUT_NAME),\n             ty: output,\n             span: output_span\n         };\n@@ -1252,7 +1252,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         if bounds.len() > 1 {\n             let spans = bounds.iter().map(|b| {\n                 self.tcx().associated_items(b.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name.as_str() == assoc_name\n+                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n                 })\n                 .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n                 .and_then(|node_id| self.tcx().map.opt_span(node_id))"}, {"sha": "e72dba858c562160dbc42da65d4a53cc8f60109e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::hir;\n \n use syntax_pos::Span;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n #[derive(Copy, Clone, Debug)]\n enum AutoderefKind {\n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         let normalized = traits::normalize_projection_type(&mut selcx,\n                                                            ty::ProjectionTy {\n                                                                trait_ref: trait_ref,\n-                                                               item_name: token::intern(\"Target\"),\n+                                                               item_name: Symbol::intern(\"Target\"),\n                                                            },\n                                                            cause,\n                                                            0);\n@@ -198,7 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span,\n                                             base_expr,\n-                                            token::intern(\"deref_mut\"),\n+                                            Symbol::intern(\"deref_mut\"),\n                                             trait_did,\n                                             base_ty,\n                                             None)\n@@ -211,7 +211,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span,\n                                             base_expr,\n-                                            token::intern(\"deref\"),\n+                                            Symbol::intern(\"deref\"),\n                                             trait_did,\n                                             base_ty,\n                                             None)"}, {"sha": "3ffbbd1be80160acae8a304f4972be13661faba2", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,8 +16,7 @@ use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::print;\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n-use syntax::parse::token;\n-use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -46,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_call(&self,\n                       call_expr: &'gcx hir::Expr,\n                       callee_expr: &'gcx hir::Expr,\n-                      arg_exprs: &'gcx [P<hir::Expr>],\n+                      arg_exprs: &'gcx [hir::Expr],\n                       expected: Expectation<'tcx>)\n                       -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n@@ -160,9 +159,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   -> Option<ty::MethodCallee<'tcx>> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name) in\n-            &[(self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n-              (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-              (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\"))] {\n+            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n+              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\")),\n+              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"))] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n@@ -189,7 +188,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn confirm_builtin_call(&self,\n                             call_expr: &hir::Expr,\n                             callee_ty: Ty<'tcx>,\n-                            arg_exprs: &'gcx [P<hir::Expr>],\n+                            arg_exprs: &'gcx [hir::Expr],\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let error_fn_sig;\n@@ -272,7 +271,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn confirm_deferred_closure_call(&self,\n                                      call_expr: &hir::Expr,\n-                                     arg_exprs: &'gcx [P<hir::Expr>],\n+                                     arg_exprs: &'gcx [hir::Expr],\n                                      expected: Expectation<'tcx>,\n                                      fn_sig: ty::FnSig<'tcx>)\n                                      -> Ty<'tcx> {\n@@ -299,7 +298,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn confirm_overloaded_call(&self,\n                                call_expr: &hir::Expr,\n                                callee_expr: &'gcx hir::Expr,\n-                               arg_exprs: &'gcx [P<hir::Expr>],\n+                               arg_exprs: &'gcx [hir::Expr],\n                                expected: Expectation<'tcx>,\n                                method_callee: ty::MethodCallee<'tcx>)\n                                -> Ty<'tcx> {"}, {"sha": "a07573a7b9eab08c9578f7bfa36d835b412dc060", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -21,7 +21,7 @@ use {CrateCtxt, require_same_types};\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -75,7 +75,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = token::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         ccx.tcx.mk_param(n, name)\n     }\n \n@@ -326,7 +326,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                                      it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = token::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         ccx.tcx.mk_param(n, name)\n     };\n "}, {"sha": "bd34e993e1e86a984a65e413a19e57a2a8d6b6e6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -342,7 +342,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let def = pick.item.def();\n         if let probe::InherentImplPick = pick.kind {\n             if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n+                let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);\n                 self.tcx.sess.span_err(span, &msg);\n             }\n         }"}, {"sha": "eeb7bb287002f7ffb32a93718ff8b2943a667a37", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 175, "deletions": 54, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -103,7 +103,7 @@ use session::{Session, CompileResult};\n use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n-use util::common::{block_query, ErrorReported, indenter, loop_query};\n+use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n@@ -115,8 +115,8 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n@@ -407,6 +407,34 @@ impl Diverges {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct LoopCtxt<'gcx, 'tcx> {\n+    unified: Ty<'tcx>,\n+    coerce_to: Ty<'tcx>,\n+    break_exprs: Vec<&'gcx hir::Expr>,\n+    may_break: bool,\n+}\n+\n+#[derive(Clone)]\n+pub struct EnclosingLoops<'gcx, 'tcx> {\n+    stack: Vec<LoopCtxt<'gcx, 'tcx>>,\n+    by_id: NodeMap<usize>,\n+}\n+\n+impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n+    fn find_loop(&mut self, id: Option<ast::NodeId>) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n+        if let Some(id) = id {\n+            if let Some(ix) = self.by_id.get(&id).cloned() {\n+                Some(&mut self.stack[ix])\n+            } else {\n+                None\n+            }\n+        } else {\n+            self.stack.last_mut()\n+        }\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -433,6 +461,8 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// Whether any child nodes have any type errors.\n     has_errors: Cell<bool>,\n \n+    enclosing_loops: RefCell<EnclosingLoops<'gcx, 'tcx>>,\n+\n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n@@ -931,7 +961,8 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n-        if let Some(ref istring) = attr.value_str() {\n+        if let Some(istring) = attr.value_str() {\n+            let istring = istring.as_str();\n             let parser = Parser::new(&istring);\n             let types = &generics.types;\n             for token in parser {\n@@ -942,7 +973,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name.as_str() == s\n+                            t.name == s\n                         }) {\n                             Some(_) => (),\n                             None => {\n@@ -1502,6 +1533,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      ast::CRATE_NODE_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n+            enclosing_loops: RefCell::new(EnclosingLoops {\n+                stack: Vec::new(),\n+                by_id: NodeMap(),\n+            }),\n             inh: inh,\n         }\n     }\n@@ -2369,7 +2404,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(expr.span,\n                                                      Some(&base_expr),\n-                                                     token::intern(\"index_mut\"),\n+                                                     Symbol::intern(\"index_mut\"),\n                                                      trait_did,\n                                                      autoderefs,\n                                                      unsize,\n@@ -2384,7 +2419,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(expr.span,\n                                                      Some(&base_expr),\n-                                                     token::intern(\"index\"),\n+                                                     Symbol::intern(\"index\"),\n                                                      trait_did,\n                                                      autoderefs,\n                                                      unsize,\n@@ -2408,7 +2443,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                    sp: Span,\n                                    method_fn_ty: Ty<'tcx>,\n                                    callee_expr: &'gcx hir::Expr,\n-                                   args_no_rcvr: &'gcx [P<hir::Expr>],\n+                                   args_no_rcvr: &'gcx [hir::Expr],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)\n                                    -> Ty<'tcx> {\n@@ -2447,7 +2482,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             sp: Span,\n                             fn_inputs: &[Ty<'tcx>],\n                             expected_arg_tys: &[Ty<'tcx>],\n-                            args: &'gcx [P<hir::Expr>],\n+                            args: &'gcx [hir::Expr],\n                             variadic: bool,\n                             tuple_arguments: TupleArgumentsFlag) {\n         let tcx = self.tcx;\n@@ -2821,7 +2856,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_method_call(&self,\n                          expr: &'gcx hir::Expr,\n                          method_name: Spanned<ast::Name>,\n-                         args: &'gcx [P<hir::Expr>],\n+                         args: &'gcx [hir::Expr],\n                          tps: &[P<hir::Ty>],\n                          expected: Expectation<'tcx>,\n                          lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n@@ -3027,7 +3062,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn suggest_field_name(variant: ty::VariantDef<'tcx>,\n                           field: &Spanned<ast::Name>,\n                           skip : Vec<InternedString>)\n-                          -> Option<InternedString> {\n+                          -> Option<Symbol> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n@@ -3126,7 +3161,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.name.span, E0559,\n                                     \"{} `{}::{}` has no field named `{}`\",\n-                                    kind_name, actual, variant.name.as_str(), field.name.node)\n+                                    kind_name, actual, variant.name, field.name.node)\n                 }\n                 _ => {\n                     struct_span_err!(self.tcx.sess, field.name.span, E0560,\n@@ -3146,7 +3181,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     err.span_label(field.name.span, &format!(\"`{}::{}` does not have this field\",\n-                                                             ty, variant.name.as_str()));\n+                                                             ty, variant.name));\n                 }\n                 _ => {\n                     err.span_label(field.name.span, &format!(\"`{}` does not have this field\", ty));\n@@ -3583,7 +3618,74 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               tcx.mk_nil()\n           }\n-          hir::ExprBreak(_) => { tcx.types.never }\n+          hir::ExprBreak(ref label_opt, ref expr_opt) => {\n+            let loop_id = if label_opt.is_some() {\n+                let loop_def = tcx.expect_def(expr.id);\n+                if let Def::Label(loop_id) = loop_def {\n+                    Some(Some(loop_id))\n+                } else if loop_def == Def::Err {\n+                    // an error was already printed, so just ignore it\n+                    None\n+                } else {\n+                    span_bug!(expr.span, \"break label resolved to a non-label\");\n+                }\n+            } else {\n+                Some(None)\n+            };\n+            if let Some(loop_id) = loop_id {\n+                let coerce_to = {\n+                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                    enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+                };\n+                if let Some(coerce_to) = coerce_to {\n+                    let e_ty;\n+                    let cause;\n+                    if let Some(ref e) = *expr_opt {\n+                        // Recurse without `enclosing_loops` borrowed.\n+                        e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        cause = self.misc(e.span);\n+                        // Notably, the recursive call may alter coerce_to - must not keep using it!\n+                    } else {\n+                        // `break` without argument acts like `break ()`.\n+                        e_ty = tcx.mk_nil();\n+                        cause = self.misc(expr.span);\n+                    }\n+                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                    let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+\n+                    let result = if let Some(ref e) = *expr_opt {\n+                        // Special-case the first element, as it has no \"previous expressions\".\n+                        let result = if !ctxt.may_break {\n+                            self.try_coerce(e, e_ty, ctxt.coerce_to)\n+                        } else {\n+                            self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n+                                                       ctxt.unified, e, e_ty)\n+                        };\n+\n+                        ctxt.break_exprs.push(e);\n+                        result\n+                    } else {\n+                        self.eq_types(true, &cause, e_ty, ctxt.unified)\n+                            .map(|InferOk { obligations, .. }| {\n+                                // FIXME(#32730) propagate obligations\n+                                assert!(obligations.is_empty());\n+                                e_ty\n+                            })\n+                    };\n+                    match result {\n+                        Ok(ty) => ctxt.unified = ty,\n+                        Err(err) => {\n+                            self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n+                        }\n+                    }\n+\n+                    ctxt.may_break = true;\n+                }\n+                // Otherwise, we failed to find the enclosing loop; this can only happen if the\n+                // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n+            }\n+            tcx.types.never\n+          }\n           hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {\n             if let Some(ref e) = *expr_opt {\n@@ -3634,27 +3736,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            self.check_expr_has_type(&cond, tcx.types.bool);\n-            let cond_diverging = self.diverges.get();\n-            self.check_block_no_value(&body);\n+            let unified = self.tcx.mk_nil();\n+            let coerce_to = unified;\n+            let ctxt = LoopCtxt {\n+                unified: unified,\n+                coerce_to: coerce_to,\n+                break_exprs: vec![],\n+                may_break: true,\n+            };\n+            self.with_loop_ctxt(expr.id, ctxt, || {\n+                self.check_expr_has_type(&cond, tcx.types.bool);\n+                let cond_diverging = self.diverges.get();\n+                self.check_block_no_value(&body);\n \n-            // We may never reach the body so it diverging means nothing.\n-            self.diverges.set(cond_diverging);\n+                // We may never reach the body so it diverging means nothing.\n+                self.diverges.set(cond_diverging);\n+            });\n \n             if self.has_errors.get() {\n                 tcx.types.err\n             } else {\n                 tcx.mk_nil()\n             }\n           }\n-          hir::ExprLoop(ref body, _) => {\n-            self.check_block_no_value(&body);\n-            if may_break(tcx, expr.id, &body) {\n+          hir::ExprLoop(ref body, _, _) => {\n+            let unified = self.next_ty_var();\n+            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n+            let ctxt = LoopCtxt {\n+                unified: unified,\n+                coerce_to: coerce_to,\n+                break_exprs: vec![],\n+                may_break: false,\n+            };\n+\n+            let ctxt = self.with_loop_ctxt(expr.id, ctxt, || {\n+                self.check_block_no_value(&body);\n+            });\n+            if ctxt.may_break {\n                 // No way to know whether it's diverging because\n                 // of a `break` or an outer `break` or `return.\n                 self.diverges.set(Diverges::Maybe);\n \n-                tcx.mk_nil()\n+                ctxt.unified\n             } else {\n                 tcx.types.never\n             }\n@@ -3669,10 +3792,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_block_with_expected(&b, expected)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n-              self.check_call(expr, &callee, &args[..], expected)\n+              self.check_call(expr, &callee, args, expected)\n           }\n           hir::ExprMethodCall(name, ref tps, ref args) => {\n-              self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref)\n+              self.check_method_call(expr, name, args, &tps[..], expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             if let hir::TyArray(_, ref count_expr) = t.node {\n@@ -3727,7 +3850,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let result = if i == 0 {\n                     self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n-                    let prev_elems = || args[..i].iter().map(|e| &**e);\n+                    let prev_elems = || args[..i].iter().map(|e| &*e);\n                     self.try_find_coercion_lub(&cause, prev_elems, unified, e, e_ty)\n                 };\n \n@@ -4436,19 +4559,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n         if lifetimes.len() > lifetime_defs.len() {\n             let span = lifetimes[lifetime_defs.len()].span;\n-            span_err!(self.tcx.sess, span, E0088,\n-                      \"too many lifetime parameters provided: \\\n-                       expected {}, found {}\",\n-                      count(lifetime_defs.len()),\n-                      count(lifetimes.len()));\n-        } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n-            span_err!(self.tcx.sess, span, E0090,\n-                      \"too few lifetime parameters provided: \\\n-                       expected {}, found {}\",\n-                      count(lifetime_defs.len()),\n-                      count(lifetimes.len()));\n+            struct_span_err!(self.tcx.sess, span, E0088,\n+                             \"too many lifetime parameters provided: \\\n+                              expected {}, found {}\",\n+                              count(lifetime_defs.len()),\n+                              count(lifetimes.len()))\n+                .span_label(span, &format!(\"unexpected lifetime parameter{}\",\n+                                           match lifetimes.len() { 1 => \"\", _ => \"s\" }))\n+                .emit();\n         }\n \n+        // The case where there is not enough lifetime parameters is not checked,\n+        // because this is not possible - a function never takes lifetime parameters.\n+        // See discussion for Pull Request 36208.\n+\n         // Check provided type parameters.\n         let type_defs = segment.map_or(&[][..], |(_, generics)| {\n             if generics.parent.is_none() {\n@@ -4529,27 +4653,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.types.err\n         })\n     }\n-}\n \n-// Returns true if b contains a break that can exit from b\n-pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n-    // First: is there an unlabeled break immediately\n-    // inside the loop?\n-    (loop_query(&b, |e| {\n-        match *e {\n-            hir::ExprBreak(None) => true,\n-            _ => false\n+    fn with_loop_ctxt<F: FnOnce()>(&self, id: ast::NodeId, ctxt: LoopCtxt<'gcx, 'tcx>, f: F)\n+                                   -> LoopCtxt<'gcx, 'tcx> {\n+        let index;\n+        {\n+            let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+            index = enclosing_loops.stack.len();\n+            enclosing_loops.by_id.insert(id, index);\n+            enclosing_loops.stack.push(ctxt);\n         }\n-    })) ||\n-    // Second: is there a labeled break with label\n-    // <id> nested anywhere inside the loop?\n-    (block_query(b, |e| {\n-        if let hir::ExprBreak(Some(_)) = e.node {\n-            tcx.expect_def(e.id) == Def::Label(id)\n-        } else {\n-            false\n+        f();\n+        {\n+            let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+            debug_assert!(enclosing_loops.stack.len() == index + 1);\n+            enclosing_loops.by_id.remove(&id).expect(\"missing loop context\");\n+            (enclosing_loops.stack.pop().expect(\"missing loop context\"))\n         }\n-    }))\n+    }\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "adb8c6be42bc1ed6ed861e1e00b3c44938491f7b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,7 +14,7 @@ use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let rhs_ty_var = self.next_ty_var();\n \n         let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n-                                                    token::intern(name), trait_def_id,\n+                                                    Symbol::intern(name), trait_def_id,\n                                                     lhs_expr) {\n             Ok(return_ty) => return_ty,\n             Err(()) => {\n@@ -248,9 +248,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            -> Ty<'tcx>\n     {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(ex, operand_ty, vec![],\n-                                    token::intern(mname), trait_did,\n-                                    operand_expr) {\n+        let mname = Symbol::intern(mname);\n+        match self.lookup_op_method(ex, operand_ty, vec![], mname, trait_did, operand_expr) {\n             Ok(t) => t,\n             Err(()) => {\n                 self.type_error_message(ex.span, |actual| {"}, {"sha": "c613b62bf2d82b4a3589f01d6f909986588d58b8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -613,19 +613,19 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprCall(ref callee, ref args) => {\n                 if has_method_map {\n                     self.constrain_call(expr, Some(&callee),\n-                                        args.iter().map(|e| &**e), false);\n+                                        args.iter().map(|e| &*e), false);\n                 } else {\n                     self.constrain_callee(callee.id, expr, &callee);\n                     self.constrain_call(expr, None,\n-                                        args.iter().map(|e| &**e), false);\n+                                        args.iter().map(|e| &*e), false);\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprMethodCall(.., ref args) => {\n                 self.constrain_call(expr, Some(&args[0]),\n-                                    args[1..].iter().map(|e| &**e), false);\n+                                    args[1..].iter().map(|e| &*e), false);\n \n                 intravisit::walk_expr(self, expr);\n             }\n@@ -742,7 +742,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.check_expr_fn_block(expr, &body);\n             }\n \n-            hir::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _, _) => {\n                 let repeating_scope = self.set_repeating_scope(body.id);\n                 intravisit::walk_expr(self, expr);\n                 self.set_repeating_scope(repeating_scope);"}, {"sha": "48d79a3ba4c87bb7b5fd932e0abbf7bb6f22d9ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -79,7 +79,7 @@ use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n \n use syntax::{abi, ast, attr};\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n use rustc::hir::{self, map as hir_map, print as pprust};\n@@ -585,7 +585,7 @@ fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n         fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n             index: (base_generics.count() as u32) + (i as u32),\n-            name: token::intern(\"<upvar>\"),\n+            name: Symbol::intern(\"<upvar>\"),\n             def_id: def_id,\n             default_def_id: base_def_id,\n             default: None,"}, {"sha": "2cc1882ce3eae3411adaf179d03132f1127d51af", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -24,9 +24,9 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax::print::pprust as syntax_pprust;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n@@ -242,7 +242,7 @@ impl Clean<ExternalCrate> for CrateNum {\n             }\n         });\n         ExternalCrate {\n-            name: (&cx.sess().cstore.crate_name(self.0)[..]).to_owned(),\n+            name: cx.sess().cstore.crate_name(self.0).to_string(),\n             attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n@@ -2577,7 +2577,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            &a.name()[..] == \"doc\" && match a.meta_item_list() {\n+            a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n                            attr::list_contains_name(l, \"hidden\"),\n                 None => false,"}, {"sha": "31fbcb5059f82188f25ee6f370e788a8fa3ec827", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -2437,7 +2437,6 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         write!(w, \"}}\")?;\n     }\n     write!(w, \"</pre>\")?;\n-    render_stability_since_raw(w, it.stable_since(), None)?;\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n@@ -3053,7 +3052,6 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                                                      Some(\"macro\"),\n                                                      None,\n                                                      None))?;\n-    render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }\n "}, {"sha": "0cb9a49ad67b56ecbf20d5fa82b1025ccb54cca0", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -349,12 +349,47 @@ impl File {\n         })\n     }\n \n+    /// Changes the permissions on the underlying file.\n+    ///\n+    /// # Platform-specific behavior\n+    ///\n+    /// This function currently corresponds to the `fchmod` function on Unix and\n+    /// the `SetFileInformationByHandle` function on Windows. Note that, this\n+    /// [may change in the future][changes].\n+    ///\n+    /// [changes]: ../io/index.html#platform-specific-behavior\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an error if the user lacks permission change\n+    /// attributes on the underlying file. It may also return an error in other\n+    /// os-specific unspecified cases.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(set_permissions_atomic)]\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs::File;\n+    ///\n+    /// let file = File::open(\"foo.txt\")?;\n+    /// let mut perms = file.metadata()?.permissions();\n+    /// perms.set_readonly(true);\n+    /// file.set_permissions(perms)?;\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"set_permissions_atomic\", issue=\"37916\")]\n+    pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> {\n+        self.inner.set_permissions(perm.0)\n+    }\n+\n     /// Get the path that this file points to.\n     ///\n     /// This function is only implemented on Redox, but could be\n     /// implemented on other operating systems using readlink\n     #[cfg(target_os = \"redox\")]\n-    #[stable(feature = \"rust1\", since = \"1.14.0\")]\n+    #[unstable(feature = \"file_path\", issue=\"0\")]\n     pub fn path(&self) -> io::Result<PathBuf> {\n         self.inner.path()\n     }\n@@ -2479,6 +2514,24 @@ mod tests {\n         check!(fs::set_permissions(&file, p));\n     }\n \n+    #[test]\n+    fn fchmod_works() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let file = check!(File::create(&path));\n+        let attr = check!(fs::metadata(&path));\n+        assert!(!attr.permissions().readonly());\n+        let mut p = attr.permissions();\n+        p.set_readonly(true);\n+        check!(file.set_permissions(p.clone()));\n+        let attr = check!(fs::metadata(&path));\n+        assert!(attr.permissions().readonly());\n+\n+        p.set_readonly(false);\n+        check!(file.set_permissions(p));\n+    }\n+\n     #[test]\n     fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();"}, {"sha": "1c016015b7928c9b9da3343bc6fb81b9a7e901b4", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -31,7 +31,7 @@ pub enum SocketAddr {\n     /// An IPv4 socket address which is a (ip, port) combination.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n-    /// An IPv6 socket address\n+    /// An IPv6 socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n }\n@@ -48,6 +48,16 @@ pub struct SocketAddrV6 { inner: c::sockaddr_in6 }\n \n impl SocketAddr {\n     /// Creates a new socket address from the (ip, port) pair.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n         match ip {\n@@ -57,6 +67,15 @@ impl SocketAddr {\n     }\n \n     /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// ```\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     pub fn ip(&self) -> IpAddr {\n         match *self {\n@@ -66,6 +85,16 @@ impl SocketAddr {\n     }\n \n     /// Change the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_ip(&mut self, new_ip: IpAddr) {\n         // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n@@ -77,6 +106,15 @@ impl SocketAddr {\n     }\n \n     /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n         match *self {\n@@ -86,6 +124,16 @@ impl SocketAddr {\n     }\n \n     /// Change the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_port(1025);\n+    /// assert_eq!(socket.port(), 1025);\n+    /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n         match *self {\n@@ -96,6 +144,20 @@ impl SocketAddr {\n \n     /// Returns true if the IP in this `SocketAddr` is a valid IPv4 address,\n     /// false if it's a valid IPv6 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(sockaddr_checker)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// fn main() {\n+    ///     let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    ///     assert_eq!(socket.is_ipv4(), true);\n+    ///     assert_eq!(socket.is_ipv6(), false);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n@@ -106,6 +168,21 @@ impl SocketAddr {\n \n     /// Returns true if the IP in this `SocketAddr` is a valid IPv6 address,\n     /// false if it's a valid IPv4 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(sockaddr_checker)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// fn main() {\n+    ///     let socket = SocketAddr::new(\n+    ///                      IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n+    ///     assert_eq!(socket.is_ipv4(), false);\n+    ///     assert_eq!(socket.is_ipv6(), true);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {"}, {"sha": "c99fda9febc245e94d5042a3e015ef65a716aa53", "filename": "src/libstd/process.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -825,6 +825,21 @@ pub fn exit(code: i32) -> ! {\n     ::sys::os::exit(code)\n }\n \n+/// Terminates the process in an abnormal fashion.\n+///\n+/// The function will never return and will immediately terminate the current\n+/// process in a platform specific \"abnormal\" manner.\n+///\n+/// Note that because this function never returns, and that it terminates the\n+/// process, no destructors on the current stack or any other thread's stack\n+/// will be run. If a clean shutdown is needed it is recommended to only call\n+/// this function at a known point where there are no more destructors left\n+/// to run.\n+#[unstable(feature = \"process_abort\", issue = \"37838\")]\n+pub fn abort() -> ! {\n+    unsafe { ::sys::abort_internal() };\n+}\n+\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use io::prelude::*;"}, {"sha": "9ee0458b5da365d1fae1c99bfa17fbdf0d20113f", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -526,6 +526,11 @@ impl File {\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n \n     pub fn into_fd(self) -> FileDesc { self.0 }\n+\n+    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n+        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n+        Ok(())\n+    }\n }\n \n impl DirBuilder {"}, {"sha": "1a563127f7f0668d69ba11485abdadfd5f49aa7d", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -182,6 +182,7 @@ pub const ERROR_INVALID_HANDLE: DWORD = 6;\n pub const ERROR_NO_MORE_FILES: DWORD = 18;\n pub const ERROR_HANDLE_EOF: DWORD = 38;\n pub const ERROR_FILE_EXISTS: DWORD = 80;\n+pub const ERROR_INVALID_PARAMETER: DWORD = 87;\n pub const ERROR_BROKEN_PIPE: DWORD = 109;\n pub const ERROR_CALL_NOT_IMPLEMENTED: DWORD = 120;\n pub const ERROR_INSUFFICIENT_BUFFER: DWORD = 122;\n@@ -388,6 +389,15 @@ pub enum FILE_INFO_BY_HANDLE_CLASS {\n     MaximumFileInfoByHandlesClass\n }\n \n+#[repr(C)]\n+pub struct FILE_BASIC_INFO {\n+    pub CreationTime: LARGE_INTEGER,\n+    pub LastAccessTime: LARGE_INTEGER,\n+    pub LastWriteTime: LARGE_INTEGER,\n+    pub ChangeTime: LARGE_INTEGER,\n+    pub FileAttributes: DWORD,\n+}\n+\n #[repr(C)]\n pub struct FILE_END_OF_FILE_INFO {\n     pub EndOfFile: LARGE_INTEGER,"}, {"sha": "7d7d78bbd87308315d75551a88c9ac5ef4558ac1", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -417,6 +417,24 @@ impl File {\n             Ok(PathBuf::from(OsString::from_wide(subst)))\n         }\n     }\n+\n+    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n+        let mut info = c::FILE_BASIC_INFO {\n+            CreationTime: 0,\n+            LastAccessTime: 0,\n+            LastWriteTime: 0,\n+            ChangeTime: 0,\n+            FileAttributes: perm.attrs,\n+        };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(self.handle.raw(),\n+                                          c::FileBasicInfo,\n+                                          &mut info as *mut _ as *mut _,\n+                                          size as c::DWORD)\n+        })?;\n+        Ok(())\n+    }\n }\n \n impl FromInner<c::HANDLE> for File {"}, {"sha": "1eb1730547642f18eb3fc162d192f977089c84b0", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -43,6 +43,7 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n         let reader;\n         let mut name;\n         let mut tries = 0;\n+        let mut reject_remote_clients_flag = c::PIPE_REJECT_REMOTE_CLIENTS;\n         loop {\n             tries += 1;\n             let key: u64 = rand::thread_rng().gen();\n@@ -56,12 +57,12 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n \n             let handle = c::CreateNamedPipeW(wide_name.as_ptr(),\n                                              c::PIPE_ACCESS_INBOUND |\n-                                              c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n-                                              c::FILE_FLAG_OVERLAPPED,\n+                                             c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n+                                             c::FILE_FLAG_OVERLAPPED,\n                                              c::PIPE_TYPE_BYTE |\n-                                              c::PIPE_READMODE_BYTE |\n-                                              c::PIPE_WAIT |\n-                                              c::PIPE_REJECT_REMOTE_CLIENTS,\n+                                             c::PIPE_READMODE_BYTE |\n+                                             c::PIPE_WAIT |\n+                                             reject_remote_clients_flag,\n                                              1,\n                                              4096,\n                                              4096,\n@@ -76,11 +77,27 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n             //\n             // Don't try again too much though as this could also perhaps be a\n             // legit error.\n+            // If ERROR_INVALID_PARAMETER is returned, this probably means we're\n+            // running on pre-Vista version where PIPE_REJECT_REMOTE_CLIENTS is\n+            // not supported, so we continue retrying without it. This implies\n+            // reduced security on Windows versions older than Vista by allowing\n+            // connections to this pipe from remote machines.\n+            // Proper fix would increase the number of FFI imports and introduce\n+            // significant amount of Windows XP specific code with no clean\n+            // testing strategy\n+            // for more info see https://github.com/rust-lang/rust/pull/37677\n             if handle == c::INVALID_HANDLE_VALUE {\n                 let err = io::Error::last_os_error();\n-                if tries < 10 &&\n-                   err.raw_os_error() == Some(c::ERROR_ACCESS_DENIED as i32) {\n-                    continue\n+                let raw_os_err = err.raw_os_error();\n+                if tries < 10 {\n+                    if raw_os_err == Some(c::ERROR_ACCESS_DENIED as i32) {\n+                        continue\n+                    } else if reject_remote_clients_flag != 0 &&\n+                        raw_os_err == Some(c::ERROR_INVALID_PARAMETER as i32) {\n+                        reject_remote_clients_flag = 0;\n+                        tries -= 1;\n+                        continue\n+                    }\n                 }\n                 return Err(err)\n             }"}, {"sha": "2a911aceb9d94e01a8be3187953b019271d6103d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 35, "deletions": 86, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,71 +14,43 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n+pub use symbol::Symbol as Name;\n pub use util::ThinVec;\n \n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n use ext::hygiene::SyntaxContext;\n-use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n+use symbol::{Symbol, keywords};\n use tokenstream::{TokenTree};\n \n+use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n \n use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n-/// A name is a part of an identifier, representing a string or gensym. It's\n-/// the result of interning.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Name(pub u32);\n-\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Ident {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub ctxt: SyntaxContext\n }\n \n-impl Name {\n-    pub fn as_str(self) -> token::InternedString {\n-        token::InternedString::new_from_name(self)\n-    }\n-}\n-\n-impl fmt::Debug for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}({})\", self, self.0)\n-    }\n-}\n-\n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.as_str(), f)\n-    }\n-}\n-\n-impl Encodable for Name {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.as_str())\n-    }\n-}\n-\n-impl Decodable for Name {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&d.read_str()?))\n-    }\n-}\n-\n impl Ident {\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n+\n+   /// Maps a string to an identifier with an empty syntax context.\n+   pub fn from_str(s: &str) -> Ident {\n+       Ident::with_empty_ctxt(Symbol::intern(s))\n+   }\n }\n \n impl fmt::Debug for Ident {\n@@ -401,7 +373,7 @@ impl Generics {\n     }\n     pub fn span_for_name(&self, name: &str) -> Option<Span> {\n         for t in &self.ty_params {\n-            if t.ident.name.as_str() == name {\n+            if t.ident.name == name {\n                 return Some(t.span);\n             }\n         }\n@@ -479,7 +451,7 @@ pub struct WhereEqPredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<P<MetaItem>>;\n+pub type CrateConfig = HashSet<(Name, Option<Symbol>)>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n@@ -498,7 +470,7 @@ pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n #[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\n pub enum NestedMetaItemKind {\n     /// A full MetaItem, for recursive meta items.\n-    MetaItem(P<MetaItem>),\n+    MetaItem(MetaItem),\n     /// A literal.\n     ///\n     /// E.g. \"foo\", 64, true\n@@ -508,53 +480,30 @@ pub enum NestedMetaItemKind {\n /// A spanned compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n-pub type MetaItem = Spanned<MetaItemKind>;\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct MetaItem {\n+    pub name: Name,\n+    pub node: MetaItemKind,\n+    pub span: Span,\n+}\n \n /// A compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n-#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n     /// E.g. `test` as in `#[test]`\n-    Word(InternedString),\n+    Word,\n     /// List meta item.\n     ///\n     /// E.g. `derive(..)` as in `#[derive(..)]`\n-    List(InternedString, Vec<NestedMetaItem>),\n+    List(Vec<NestedMetaItem>),\n     /// Name value meta item.\n     ///\n     /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n-    NameValue(InternedString, Lit),\n-}\n-\n-// can't be derived because the MetaItemKind::List requires an unordered comparison\n-impl PartialEq for MetaItemKind {\n-    fn eq(&self, other: &MetaItemKind) -> bool {\n-        use self::MetaItemKind::*;\n-        match *self {\n-            Word(ref ns) => match *other {\n-                Word(ref no) => (*ns) == (*no),\n-                _ => false\n-            },\n-            List(ref ns, ref miss) => match *other {\n-                List(ref no, ref miso) => {\n-                    ns == no &&\n-                        miss.iter().all(|mi| {\n-                            miso.iter().any(|x| x.node == mi.node)\n-                        })\n-                }\n-                _ => false\n-            },\n-            NameValue(ref ns, ref vs) => match *other {\n-                NameValue(ref no, ref vo) => {\n-                    (*ns) == (*no) && vs.node == vo.node\n-                }\n-                _ => false\n-            },\n-        }\n-    }\n+    NameValue(Lit)\n }\n \n /// A Block (`{ .. }`).\n@@ -1050,8 +999,8 @@ pub enum ExprKind {\n \n     /// A referencing operation (`&a` or `&mut a`)\n     AddrOf(Mutability, P<Expr>),\n-    /// A `break`, with an optional label to break\n-    Break(Option<SpannedIdent>),\n+    /// A `break`, with an optional label to break, and an optional expression\n+    Break(Option<SpannedIdent>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n     Continue(Option<SpannedIdent>),\n     /// A `return`, with an optional value to be returned\n@@ -1149,7 +1098,7 @@ pub enum LitIntType {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`)\n-    Str(InternedString, StrStyle),\n+    Str(Symbol, StrStyle),\n     /// A byte string (`b\"foo\"`)\n     ByteStr(Rc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n@@ -1159,9 +1108,9 @@ pub enum LitKind {\n     /// An integer literal (`1`)\n     Int(u64, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n-    Float(InternedString, FloatTy),\n+    Float(Symbol, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n-    FloatUnsuffixed(InternedString),\n+    FloatUnsuffixed(Symbol),\n     /// A boolean literal\n     Bool(bool),\n }\n@@ -1493,7 +1442,7 @@ pub enum AsmDialect {\n /// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")``\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n-    pub constraint: InternedString,\n+    pub constraint: Symbol,\n     pub expr: P<Expr>,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n@@ -1504,11 +1453,11 @@ pub struct InlineAsmOutput {\n /// E.g. `asm!(\"NOP\");`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n-    pub asm: InternedString,\n+    pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n     pub outputs: Vec<InlineAsmOutput>,\n-    pub inputs: Vec<(InternedString, P<Expr>)>,\n-    pub clobbers: Vec<InternedString>,\n+    pub inputs: Vec<(Symbol, P<Expr>)>,\n+    pub clobbers: Vec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n@@ -1755,8 +1704,6 @@ impl ViewPath_ {\n     }\n }\n \n-/// Meta-data associated with an item\n-pub type Attribute = Spanned<Attribute_>;\n \n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n@@ -1770,13 +1717,15 @@ pub enum AttrStyle {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct AttrId(pub usize);\n \n+/// Meta-data associated with an item\n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Attribute_ {\n+pub struct Attribute {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: P<MetaItem>,\n+    pub value: MetaItem,\n     pub is_sugared_doc: bool,\n+    pub span: Span,\n }\n \n /// TraitRef's appear in impls."}, {"sha": "45c120e0b95ca44daa6fc7445707efd986e822f6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 107, "deletions": 126, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -15,17 +15,17 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Attribute_};\n+use ast::{AttrId, Attribute, Name};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n-use codemap::{respan, spanned, dummy_spanned};\n+use codemap::{spanned, dummy_spanned, mk_sp};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::token::InternedString;\n-use parse::{ParseSess, token};\n+use parse::ParseSess;\n use ptr::P;\n+use symbol::Symbol;\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n@@ -37,8 +37,8 @@ thread_local! {\n }\n \n enum AttrError {\n-    MultipleItem(InternedString),\n-    UnknownMetaItem(InternedString),\n+    MultipleItem(Name),\n+    UnknownMetaItem(Name),\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n@@ -61,7 +61,7 @@ fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n \n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -73,7 +73,7 @@ pub fn mark_used(attr: &Attribute) {\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -84,7 +84,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub fn mark_known(attr: &Attribute) {\n     debug!(\"Marking {:?} as known.\", attr);\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     KNOWN_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -96,7 +96,7 @@ pub fn mark_known(attr: &Attribute) {\n }\n \n pub fn is_known(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     KNOWN_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -107,7 +107,7 @@ pub fn is_known(attr: &Attribute) -> bool {\n \n impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n-    pub fn meta_item(&self) -> Option<&P<MetaItem>> {\n+    pub fn meta_item(&self) -> Option<&MetaItem> {\n         match self.node {\n             NestedMetaItemKind::MetaItem(ref item) => Some(&item),\n             _ => None\n@@ -134,18 +134,18 @@ impl NestedMetaItem {\n \n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n-    pub fn name(&self) -> Option<InternedString> {\n+    pub fn name(&self) -> Option<Name> {\n         self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n     /// MetaItemKind::NameValue variant containing a string, otherwise None.\n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         self.meta_item().and_then(|meta_item| meta_item.value_str())\n     }\n \n     /// Returns a MetaItem if self is a MetaItem with Kind Word.\n-    pub fn word(&self) -> Option<&P<MetaItem>> {\n+    pub fn word(&self) -> Option<&MetaItem> {\n         self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n             Some(meta_item)\n         } else {\n@@ -186,16 +186,16 @@ impl NestedMetaItem {\n \n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n-        let matches = name == &self.name()[..];\n+        let matches = self.name() == name;\n         if matches {\n             mark_used(self);\n         }\n         matches\n     }\n \n-    pub fn name(&self) -> InternedString { self.meta().name() }\n+    pub fn name(&self) -> Name { self.meta().name() }\n \n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         self.meta().value_str()\n     }\n \n@@ -218,17 +218,13 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> InternedString {\n-        match self.node {\n-            MetaItemKind::Word(ref n) => (*n).clone(),\n-            MetaItemKind::NameValue(ref n, _) => (*n).clone(),\n-            MetaItemKind::List(ref n, _) => (*n).clone(),\n-        }\n+    pub fn name(&self) -> Name {\n+        self.name\n     }\n \n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n-            MetaItemKind::NameValue(_, ref v) => {\n+            MetaItemKind::NameValue(ref v) => {\n                 match v.node {\n                     ast::LitKind::Str(ref s, _) => Some((*s).clone()),\n                     _ => None,\n@@ -240,22 +236,22 @@ impl MetaItem {\n \n     pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         match self.node {\n-            MetaItemKind::List(_, ref l) => Some(&l[..]),\n+            MetaItemKind::List(ref l) => Some(&l[..]),\n             _ => None\n         }\n     }\n \n     pub fn is_word(&self) -> bool {\n         match self.node {\n-            MetaItemKind::Word(_) => true,\n+            MetaItemKind::Word => true,\n             _ => false,\n         }\n     }\n \n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        name == &self.name()[..]\n+        self.name() == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -270,7 +266,7 @@ impl MetaItem {\n impl Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> &MetaItem {\n-        &self.node.value\n+        &self.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -279,16 +275,15 @@ impl Attribute {\n     pub fn with_desugared_doc<T, F>(&self, f: F) -> T where\n         F: FnOnce(&Attribute) -> T,\n     {\n-        if self.node.is_sugared_doc {\n+        if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                InternedString::new(\"doc\"),\n-                token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        &comment)));\n-            if self.node.style == ast::AttrStyle::Outer {\n-                f(&mk_attr_outer(self.node.id, meta))\n+                Symbol::intern(\"doc\"),\n+                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())));\n+            if self.style == ast::AttrStyle::Outer {\n+                f(&mk_attr_outer(self.id, meta))\n             } else {\n-                f(&mk_attr_inner(self.node.id, meta))\n+                f(&mk_attr_inner(self.id, meta))\n             }\n         } else {\n             f(self)\n@@ -298,41 +293,37 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> P<MetaItem> {\n+pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n     let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> P<MetaItem> {\n+pub fn mk_name_value_item(name: Name, value: ast::Lit) -> MetaItem {\n     mk_spanned_name_value_item(DUMMY_SP, name, value)\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n+pub fn mk_list_item(name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n     mk_spanned_list_item(DUMMY_SP, name, items)\n }\n \n-pub fn mk_list_word_item(name: InternedString) -> ast::NestedMetaItem {\n+pub fn mk_list_word_item(name: Name) -> ast::NestedMetaItem {\n     dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n }\n \n-pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n+pub fn mk_word_item(name: Name) -> MetaItem {\n     mk_spanned_word_item(DUMMY_SP, name)\n }\n \n-pub fn mk_spanned_name_value_item(sp: Span, name: InternedString, value: ast::Lit)\n-                          -> P<MetaItem> {\n-    P(respan(sp, MetaItemKind::NameValue(name, value)))\n+pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> MetaItem {\n+    MetaItem { span: sp, name: name, node: MetaItemKind::NameValue(value) }\n }\n \n-pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<NestedMetaItem>)\n-                            -> P<MetaItem> {\n-    P(respan(sp, MetaItemKind::List(name, items)))\n+pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n+    MetaItem { span: sp, name: name, node: MetaItemKind::List(items) }\n }\n \n-pub fn mk_spanned_word_item(sp: Span, name: InternedString) -> P<MetaItem> {\n-    P(respan(sp, MetaItemKind::Word(name)))\n+pub fn mk_spanned_word_item(sp: Span, name: Name) -> MetaItem {\n+    MetaItem { span: sp, name: name, node: MetaItemKind::Word }\n }\n \n \n@@ -349,71 +340,63 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_inner(DUMMY_SP, id, item)\n }\n \n /// Returns an innter attribute with the given value and span.\n-pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n-    respan(sp,\n-           Attribute_ {\n-            id: id,\n-            style: ast::AttrStyle::Inner,\n-            value: item,\n-            is_sugared_doc: false,\n-          })\n+pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    Attribute {\n+        id: id,\n+        style: ast::AttrStyle::Inner,\n+        value: item,\n+        is_sugared_doc: false,\n+        span: sp,\n+    }\n }\n \n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_outer(DUMMY_SP, id, item)\n }\n \n /// Returns an outer attribute with the given value and span.\n-pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n-    respan(sp,\n-           Attribute_ {\n-            id: id,\n-            style: ast::AttrStyle::Outer,\n-            value: item,\n-            is_sugared_doc: false,\n-          })\n+pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    Attribute {\n+        id: id,\n+        style: ast::AttrStyle::Outer,\n+        value: item,\n+        is_sugared_doc: false,\n+        span: sp,\n+    }\n }\n \n-pub fn mk_doc_attr_outer(id: AttrId, item: P<MetaItem>, is_sugared_doc: bool) -> Attribute {\n-    dummy_spanned(Attribute_ {\n+pub fn mk_doc_attr_outer(id: AttrId, item: MetaItem, is_sugared_doc: bool) -> Attribute {\n+    Attribute {\n         id: id,\n         style: ast::AttrStyle::Outer,\n         value: item,\n         is_sugared_doc: is_sugared_doc,\n-    })\n+        span: DUMMY_SP,\n+    }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n-                           hi: BytePos)\n+pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n-    let style = doc_comment_style(&text);\n+    let style = doc_comment_style(&text.as_str());\n     let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n-    let attr = Attribute_ {\n+    Attribute {\n         id: id,\n         style: style,\n-        value: P(spanned(lo, hi, MetaItemKind::NameValue(InternedString::new(\"doc\"), lit))),\n-        is_sugared_doc: true\n-    };\n-    spanned(lo, hi, attr)\n-}\n-\n-/* Searching */\n-/// Check if `needle` occurs in `haystack` by a structural\n-/// comparison. This is slightly subtle, and relies on ignoring the\n-/// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n-    debug!(\"attr::contains (name={})\", needle.name());\n-    haystack.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n-        item.node == needle.node\n-    })\n+        value: MetaItem {\n+            span: mk_sp(lo, hi),\n+            name: Symbol::intern(\"doc\"),\n+            node: MetaItemKind::NameValue(lit),\n+        },\n+        is_sugared_doc: true,\n+        span: mk_sp(lo, hi),\n+    }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n@@ -432,15 +415,13 @@ pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n     })\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n-                                 -> Option<InternedString> {\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> {\n     attrs.iter()\n         .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n-                                     -> Option<InternedString> {\n+pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Option<Symbol> {\n     items.iter()\n          .rev()\n          .find(|mi| mi.check_name(name))\n@@ -449,12 +430,12 @@ pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n \n /* Higher-level applications */\n \n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n /// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symbol> {\n     attrs.iter().fold(None, |ia,attr| {\n         if attr.check_name(\"export_name\") {\n             if let s@Some(_) = attr.value_str() {\n@@ -488,13 +469,14 @@ pub enum InlineAttr {\n \n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n-    attrs.iter().fold(InlineAttr::None, |ia,attr| {\n-        match attr.node.value.node {\n-            MetaItemKind::Word(ref n) if n == \"inline\" => {\n+    attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+        match attr.value.node {\n+            _ if attr.value.name != \"inline\" => ia,\n+            MetaItemKind::Word => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n             }\n-            MetaItemKind::List(ref n, ref items) if n == \"inline\" => {\n+            MetaItemKind::List(ref items) => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n                     diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n@@ -527,7 +509,7 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n     match cfg.node {\n-        ast::MetaItemKind::List(ref pred, ref mis) => {\n+        ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n                     handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n@@ -537,7 +519,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &pred[..] {\n+            match &*cfg.name.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n@@ -558,11 +540,11 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                 }\n             }\n         },\n-        ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n             if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n                 gated_cfg.check_and_emit(sess, feats);\n             }\n-            contains(&sess.config, cfg)\n+            sess.config.contains(&(cfg.name(), cfg.value_str()))\n         }\n     }\n }\n@@ -571,28 +553,28 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n #[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Stability {\n     pub level: StabilityLevel,\n-    pub feature: InternedString,\n+    pub feature: Symbol,\n     pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// The available stability levels.\n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue\n-    Unstable { reason: Option<InternedString>, issue: u32 },\n-    Stable { since: InternedString },\n+    Unstable { reason: Option<Symbol>, issue: u32 },\n+    Stable { since: Symbol },\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub struct RustcDeprecation {\n-    pub since: InternedString,\n-    pub reason: InternedString,\n+    pub since: Symbol,\n+    pub reason: Symbol,\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub struct Deprecation {\n-    pub since: Option<InternedString>,\n-    pub note: Option<InternedString>,\n+    pub since: Option<Symbol>,\n+    pub note: Option<Symbol>,\n }\n \n impl StabilityLevel {\n@@ -611,15 +593,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n \n     'outer: for attr in attrs_iter {\n         let tag = attr.name();\n-        let tag = &*tag;\n         if tag != \"rustc_deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n \n         mark_used(attr);\n \n         if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n@@ -633,7 +614,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             };\n \n-            match tag {\n+            match &*tag.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -645,7 +626,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut reason = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 _ => {\n@@ -688,7 +669,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n@@ -710,7 +691,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 level: Unstable {\n                                     reason: reason,\n                                     issue: {\n-                                        if let Ok(issue) = issue.parse() {\n+                                        if let Ok(issue) = issue.as_str().parse() {\n                                             issue\n                                         } else {\n                                             span_err!(diagnostic, attr.span(), E0545,\n@@ -743,7 +724,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n@@ -821,7 +802,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         }\n \n         depr = if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n@@ -839,7 +820,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name() {\n+                    match &*mi.name().as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n@@ -875,7 +856,7 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &Handler, metas: &[MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas {\n         let name = meta.name();\n@@ -896,8 +877,8 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n /// structure layout, and `packed` to remove padding.\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n-    match attr.node.value.node {\n-        ast::MetaItemKind::List(ref s, ref items) if s == \"repr\" => {\n+    match attr.value.node {\n+        ast::MetaItemKind::List(ref items) if attr.value.name == \"repr\" => {\n             mark_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n@@ -906,7 +887,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                 }\n \n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.name();\n+                    let word = &*mi.name().as_str();\n                     let hint = match word {\n                         // Can't use \"extern\" because it's not a lexical identifier.\n                         \"C\" => Some(ReprExtern),"}, {"sha": "3cdfa718eabae2a7f85568b8c3dea57bc42cd494", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -871,6 +871,7 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use symbol::keywords;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1097,10 +1098,9 @@ mod tests {\n     #[test]\n     fn t11() {\n         // Test span_to_expanded_string works with expansion\n-        use ast::Name;\n         let cm = init_code_map();\n         let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-        let format = ExpnFormat::MacroBang(Name(0u32));\n+        let format = ExpnFormat::MacroBang(keywords::Invalid.name());\n         let callee = NameAndSpan { format: format,\n                                    allow_internal_unstable: false,\n                                    span: None };\n@@ -1197,11 +1197,9 @@ mod tests {\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end\n-        use ast::Name;\n-\n         let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n \n-        let format_root = ExpnFormat::MacroBang(Name(0u32));\n+        let format_root = ExpnFormat::MacroBang(keywords::Invalid.name());\n         let callee_root = NameAndSpan { format: format_root,\n                                         allow_internal_unstable: false,\n                                         span: Some(root) };\n@@ -1210,7 +1208,7 @@ mod tests {\n         let id_a1 = cm.record_expansion(info_a1);\n         let span_a1 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a1 };\n \n-        let format_a = ExpnFormat::MacroBang(Name(1u32));\n+        let format_a = ExpnFormat::MacroBang(keywords::As.name());\n         let callee_a = NameAndSpan { format: format_a,\n                                       allow_internal_unstable: false,\n                                       span: Some(span_a1) };\n@@ -1223,7 +1221,7 @@ mod tests {\n         let id_b1 = cm.record_expansion(info_b1);\n         let span_b1 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b1 };\n \n-        let format_b = ExpnFormat::MacroBang(Name(2u32));\n+        let format_b = ExpnFormat::MacroBang(keywords::Box.name());\n         let callee_b = NameAndSpan { format: format_b,\n                                      allow_internal_unstable: false,\n                                      span: None };"}, {"sha": "89eea3f6f8b288790ed0648bc293db97f15f9228", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -12,7 +12,7 @@ use attr::HasAttrs;\n use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use {fold, attr};\n use ast;\n-use codemap::{Spanned, respan};\n+use codemap::Spanned;\n use parse::ParseSess;\n use ptr::P;\n \n@@ -106,12 +106,13 @@ impl<'a> StripUnconfigured<'a> {\n         match (cfg.meta_item(), mi.meta_item()) {\n             (Some(cfg), Some(mi)) =>\n                 if cfg_matches(&cfg, self.sess, self.features) {\n-                    self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n+                    self.process_cfg_attr(ast::Attribute {\n                         id: attr::mk_attr_id(),\n-                        style: attr.node.style,\n+                        style: attr.style,\n                         value: mi.clone(),\n                         is_sugared_doc: false,\n-                    }))\n+                        span: mi.span,\n+                    })\n                 } else {\n                     None\n                 },\n@@ -131,8 +132,8 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = match attr.node.value.node {\n-                ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n+            let mis = match attr.value.node {\n+                ast::MetaItemKind::List(ref mis) if is_cfg(&attr) => mis,\n                 _ => return true\n             };\n \n@@ -160,7 +161,7 @@ impl<'a> StripUnconfigured<'a> {\n                                           attr.span,\n                                           GateIssue::Language,\n                                           EXPLAIN_STMT_ATTR_SYNTAX);\n-                if attr.node.is_sugared_doc {\n+                if attr.is_sugared_doc {\n                     err.help(\"`///` is for documentation comments. For a plain comment, use `//`.\");\n                 }\n                 err.emit();"}, {"sha": "fe5cb87ad59b5c89370490754c45576b6bcad900", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,6 +19,7 @@ use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n+use symbol::Symbol;\n use tokenstream::{TokenTree};\n use util::small_vector::SmallVector;\n \n@@ -141,7 +142,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    let sym = Ident::with_empty_ctxt(token::gensym(&format!(\n+    let sym = Ident::with_empty_ctxt(Symbol::gensym(&format!(\n         \"__register_diagnostic_{}\", code\n     )));\n     MacEager::items(SmallVector::many(vec![\n@@ -194,11 +195,11 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n     let (count, expr) =\n         with_registered_diagnostics(|diagnostics| {\n             let descriptions: Vec<P<ast::Expr>> =\n-                diagnostics.iter().filter_map(|(code, info)| {\n+                diagnostics.iter().filter_map(|(&code, info)| {\n                     info.description.map(|description| {\n                         ecx.expr_tuple(span, vec![\n-                            ecx.expr_str(span, code.as_str()),\n-                            ecx.expr_str(span, description.as_str())\n+                            ecx.expr_str(span, code),\n+                            ecx.expr_str(span, description)\n                         ])\n                     })\n                 }).collect();"}, {"sha": "93ca1948ed84b878b2e2b57b627b133d5129abeb", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -28,7 +28,7 @@ pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name.as_str() == \"main\" {\n+            } else if item.ident.name == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "ddbca47429d1876298601836b0ed032e2d1ed1b7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,10 +18,10 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n-use parse::{self, parser};\n+use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n-use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n+use symbol::Symbol;\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -568,9 +568,7 @@ pub struct ExpansionData {\n     pub depth: usize,\n     pub backtrace: ExpnId,\n     pub module: Rc<ModuleData>,\n-\n-    // True if non-inline modules without a `#[path]` are forbidden at the root of this expansion.\n-    pub no_noninline_mod: bool,\n+    pub directory_ownership: DirectoryOwnership,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -601,7 +599,7 @@ impl<'a> ExtCtxt<'a> {\n                 depth: 0,\n                 backtrace: NO_EXPANSION,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                no_noninline_mod: false,\n+                directory_ownership: DirectoryOwnership::Owned,\n             },\n         }\n     }\n@@ -643,7 +641,7 @@ impl<'a> ExtCtxt<'a> {\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n                 info.map_or(None, |i| {\n-                    if i.callee.name().as_str() == \"include\" {\n+                    if i.callee.name() == \"include\" {\n                         // Stop going up the backtrace once include! is encountered\n                         return None;\n                     }\n@@ -735,7 +733,7 @@ impl<'a> ExtCtxt<'a> {\n         self.ecfg.trace_mac = x\n     }\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n-        str_to_ident(st)\n+        ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n@@ -746,15 +744,15 @@ impl<'a> ExtCtxt<'a> {\n         return v\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {\n-        token::intern(st)\n+        Symbol::intern(st)\n     }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                              -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n+                              -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n         expr.span.expn_id = cx.backtrace();\n@@ -765,7 +763,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(ref s, style) => return Some(respan(expr.span, (s.clone(), style))),\n+            ast::LitKind::Str(s, style) => return Some(respan(expr.span, (s, style))),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n@@ -774,7 +772,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n }\n \n pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                      -> Option<(InternedString, ast::StrStyle)> {\n+                      -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg).map(|s| s.node)\n }\n "}, {"sha": "a208b934d79e1da09b7ca1b31ba069b7aca824dd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,8 +14,8 @@ use attr;\n use syntax_pos::{Span, DUMMY_SP, Pos};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n-use parse::token::{self, keywords, InternedString};\n use ptr::P;\n+use symbol::{Symbol, keywords};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -149,7 +149,7 @@ pub trait AstBuilder {\n     fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr>;\n \n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n@@ -158,7 +158,7 @@ pub trait AstBuilder {\n \n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr>;\n+    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr>;\n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;\n \n     fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n@@ -275,22 +275,22 @@ pub trait AstBuilder {\n                     generics: Generics) -> P<ast::Item>;\n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item>;\n \n-    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n+    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem;\n \n-    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem;\n+    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem;\n \n     fn meta_list(&self,\n                  sp: Span,\n-                 name: InternedString,\n+                 name: ast::Name,\n                  mis: Vec<ast::NestedMetaItem> )\n-                 -> P<ast::MetaItem>;\n+                 -> ast::MetaItem;\n     fn meta_name_value(&self,\n                        sp: Span,\n-                       name: InternedString,\n+                       name: ast::Name,\n                        value: ast::LitKind)\n-                       -> P<ast::MetaItem>;\n+                       -> ast::MetaItem;\n \n     fn item_use(&self, sp: Span,\n                 vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item>;\n@@ -755,7 +755,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr> {\n+    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n     }\n \n@@ -777,18 +777,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Break(None))\n+        self.expr(sp, ast::ExprKind::Break(None, None))\n     }\n \n \n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n+    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n-        let expr_file = self.expr_str(span,\n-                                      token::intern_and_get_ident(&loc.file.name));\n+        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n@@ -801,9 +800,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_fail(span,\n-                       InternedString::new(\n-                           \"internal error: entered unreachable code\"))\n+        self.expr_fail(span, Symbol::intern(\"internal error: entered unreachable code\"))\n     }\n \n     fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n@@ -1146,25 +1143,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item_ty_poly(span, name, ty, Generics::default())\n     }\n \n-    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute {\n         attr::mk_spanned_attr_outer(sp, attr::mk_attr_id(), mi)\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n+    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n         attr::mk_spanned_word_item(sp, w)\n     }\n \n-    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem {\n+    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n         respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n     }\n \n-    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<ast::NestedMetaItem>)\n-                 -> P<ast::MetaItem> {\n+    fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n+                 -> ast::MetaItem {\n         attr::mk_spanned_list_item(sp, name, mis)\n     }\n \n-    fn meta_name_value(&self, sp: Span, name: InternedString, value: ast::LitKind)\n-                       -> P<ast::MetaItem> {\n+    fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)\n+                       -> ast::MetaItem {\n         attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n     }\n "}, {"sha": "fd6cae1e1b6688bbfdea9b91da5935b06d5fad99", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -21,12 +21,13 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, PResult, lexer};\n+use parse::{ParseSess, DirectoryOwnership, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{self, intern, keywords};\n+use parse::token;\n use print::pprust;\n use ptr::P;\n use std_inject;\n+use symbol::keywords;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -190,7 +191,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         self.cx.crate_root = std_inject::injected_crate_name(&krate);\n         let mut module = ModuleData {\n-            mod_path: vec![token::str_to_ident(&self.cx.ecfg.crate_name)],\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n             directory: PathBuf::from(self.cx.codemap().span_to_filename(krate.span)),\n         };\n         module.directory.pop();\n@@ -246,7 +247,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n                 }\n                 InvocationKind::Attr { ref attr, .. } => {\n-                    let ident = ast::Ident::with_empty_ctxt(intern(&*attr.name()));\n+                    let ident = Ident::with_empty_ctxt(attr.name());\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }\n@@ -341,7 +342,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        let name = intern(&attr.name());\n+        let name = attr.name();\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n@@ -353,12 +354,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n+                let item = mac.expand(self.cx, attr.span, &attr.value, item);\n                 kind.expect_from_annotatables(item)\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                mac.expand(self.cx, attr.span, &attr.node.value, &item,\n+                mac.expand(self.cx, attr.span, &attr.value, &item,\n                            &mut |item| items.push(item));\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n@@ -726,9 +727,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let no_noninline_mod = mem::replace(&mut self.cx.current_expansion.no_noninline_mod, true);\n+        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n+        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n         let result = noop_fold_block(block, self);\n-        self.cx.current_expansion.no_noninline_mod = no_noninline_mod;\n+        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n         result\n     }\n \n@@ -767,7 +769,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     return noop_fold_item(item, self);\n                 }\n \n-                let orig_no_noninline_mod = self.cx.current_expansion.no_noninline_mod;\n+                let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n                 module.mod_path.push(item.ident);\n \n@@ -778,23 +780,28 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n-                        self.cx.current_expansion.no_noninline_mod = false;\n-                        module.directory.push(&*path);\n+                        self.cx.current_expansion.directory_ownership = DirectoryOwnership::Owned;\n+                        module.directory.push(&*path.as_str());\n                     } else {\n                         module.directory.push(&*item.ident.name.as_str());\n                     }\n                 } else {\n-                    self.cx.current_expansion.no_noninline_mod = false;\n-                    module.directory =\n+                    let mut path =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n-                    module.directory.pop();\n+                    let directory_ownership = match path.file_name().unwrap().to_str() {\n+                        Some(\"mod.rs\") => DirectoryOwnership::Owned,\n+                        _ => DirectoryOwnership::UnownedViaMod(false),\n+                    };\n+                    path.pop();\n+                    module.directory = path;\n+                    self.cx.current_expansion.directory_ownership = directory_ownership;\n                 }\n \n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.no_noninline_mod = orig_no_noninline_mod;\n+                self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 return result;\n             }\n             // Ensure that test functions are accessible from the test harness."}, {"sha": "4fe57a8345e94e707c71192c0f5f0f3bb8b06cbf", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -13,8 +13,8 @@ use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n use fold::*;\n-use parse::token::{intern, keywords};\n use ptr::P;\n+use symbol::{Symbol, keywords};\n use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n@@ -227,7 +227,7 @@ pub fn reconstructed_macro_rules(def: &ast::MacroDef) -> Expansion {\n                     span: DUMMY_SP,\n                     global: false,\n                     segments: vec![ast::PathSegment {\n-                        identifier: ast::Ident::with_empty_ctxt(intern(\"macro_rules\")),\n+                        identifier: ast::Ident::with_empty_ctxt(Symbol::intern(\"macro_rules\")),\n                         parameters: ast::PathParameters::none(),\n                     }],\n                 },"}, {"sha": "21ce89a6dd5be7d54ec78a3d4dde8a87082e2048", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -66,6 +66,7 @@ pub mod prelude {\n     pub use ast::Ident;\n     pub use codemap::{DUMMY_SP, Span};\n     pub use ext::base::{ExtCtxt, MacResult};\n-    pub use parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+    pub use parse::token::{self, Token, DelimToken};\n+    pub use symbol::keywords;\n     pub use tokenstream::{TokenTree, TokenStream};\n }"}, {"sha": "aa777a19a9bcba047fe91ca30f841f19f38be83d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -33,6 +33,7 @@ pub mod rt {\n     use parse::{self, token, classify};\n     use ptr::P;\n     use std::rc::Rc;\n+    use symbol::Symbol;\n \n     use tokenstream::{self, TokenTree};\n \n@@ -211,7 +212,7 @@ pub mod rt {\n     impl_to_tokens_slice! { P<ast::Item>, [] }\n     impl_to_tokens_slice! { ast::Arg, [TokenTree::Token(DUMMY_SP, token::Comma)] }\n \n-    impl ToTokens for P<ast::MetaItem> {\n+    impl ToTokens for ast::MetaItem {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             let nt = token::NtMeta(self.clone());\n             vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n@@ -223,13 +224,13 @@ pub mod rt {\n             let mut r = vec![];\n             // FIXME: The spans could be better\n             r.push(TokenTree::Token(self.span, token::Pound));\n-            if self.node.style == ast::AttrStyle::Inner {\n+            if self.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n             r.push(TokenTree::Delimited(self.span, Rc::new(tokenstream::Delimited {\n                 delim: token::Bracket,\n                 open_span: self.span,\n-                tts: self.node.value.to_tokens(cx),\n+                tts: self.value.to_tokens(cx),\n                 close_span: self.span,\n             })));\n             r\n@@ -238,8 +239,7 @@ pub mod rt {\n \n     impl ToTokens for str {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let lit = ast::LitKind::Str(\n-                token::intern_and_get_ident(self), ast::StrStyle::Cooked);\n+            let lit = ast::LitKind::Str(Symbol::intern(self), ast::StrStyle::Cooked);\n             dummy_spanned(lit).to_tokens(cx)\n         }\n     }\n@@ -405,7 +405,7 @@ pub fn parse_block_panic(parser: &mut Parser) -> P<Block> {\n     panictry!(parser.parse_block())\n }\n \n-pub fn parse_meta_item_panic(parser: &mut Parser) -> P<ast::MetaItem> {\n+pub fn parse_meta_item_panic(parser: &mut Parser) -> ast::MetaItem {\n     panictry!(parser.parse_meta_item())\n }\n \n@@ -527,17 +527,17 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n-fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident(&(*str))).collect()\n+fn ids_ext(strs: Vec<String>) -> Vec<ast::Ident> {\n+    strs.iter().map(|s| ast::Ident::from_str(s)).collect()\n }\n \n-fn id_ext(str: &str) -> ast::Ident {\n-    str_to_ident(str)\n+fn id_ext(s: &str) -> ast::Ident {\n+    ast::Ident::from_str(s)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name.as_str());\n+    let e_str = cx.expr_str(sp, ident.name);\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n@@ -546,7 +546,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n \n // Lift a name to the expr that evaluates to that name\n fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name.as_str());\n+    let e_str = cx.expr_str(sp, ident.name);\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),"}, {"sha": "39b92c7d007dec77b151fd23129b3b9b0e02fbfb", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -13,10 +13,11 @@ use syntax_pos::{self, Pos, Span};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use parse::token;\n+use parse::{token, DirectoryOwnership};\n use parse;\n use print::pprust;\n use ptr::P;\n+use symbol::Symbol;\n use tokenstream;\n use util::small_vector::SmallVector;\n \n@@ -60,15 +61,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n     let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name);\n-    base::MacEager::expr(cx.expr_str(topmost, filename))\n+    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name)))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n-    base::MacEager::expr(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(&s[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n@@ -77,9 +76,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n-    base::MacEager::expr(cx.expr_str(\n-            sp,\n-            token::intern_and_get_ident(&string[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&string)))\n }\n \n /// include! : parse the given file as an expr\n@@ -93,7 +90,8 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n     };\n     // The file will be added to the code map by the parser\n     let path = res_rel_file(cx, sp, Path::new(&file));\n-    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, true, None, sp);\n+    let directory_ownership = DirectoryOwnership::Owned;\n+    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, directory_ownership, None, sp);\n \n     struct ExpandResult<'a> {\n         p: parse::parser::Parser<'a>,\n@@ -144,10 +142,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            let interned = token::intern_and_get_ident(&src[..]);\n             cx.codemap().new_filemap_and_lines(&filename, None, &src);\n \n-            base::MacEager::expr(cx.expr_str(sp, interned))\n+            base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n         }\n         Err(_) => {\n             cx.span_err(sp,"}, {"sha": "4164b4a93ec91d4c91d65bcc65950730eff905e5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,10 +19,11 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use parse::ParseSess;\n use parse::lexer::new_tt_reader;\n-use parse::parser::{Parser, Restrictions};\n-use parse::token::{self, gensym_ident, NtTT, Token};\n+use parse::parser::Parser;\n+use parse::token::{self, NtTT, Token};\n use parse::token::Token::*;\n use print;\n+use symbol::Symbol;\n use tokenstream::{self, TokenTree};\n \n use std::collections::{HashMap};\n@@ -116,11 +117,12 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 let trncbr =\n                     new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n                 let mut p = Parser::new(cx.parse_sess(), Box::new(trncbr));\n-                p.directory = cx.current_expansion.module.directory.clone();\n-                p.restrictions = match cx.current_expansion.no_noninline_mod {\n-                    true => Restrictions::NO_NONINLINE_MOD,\n-                    false => Restrictions::empty(),\n-                };\n+                let module = &cx.current_expansion.module;\n+                p.directory.path = module.directory.clone();\n+                p.directory.ownership = cx.current_expansion.directory_ownership;\n+                p.root_module_name =\n+                    module.mod_path.last().map(|id| (*id.name.as_str()).to_owned());\n+\n                 p.check_unknown_macro_variable();\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n@@ -187,16 +189,16 @@ impl IdentMacroExpander for MacroRulesExpander {\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n-    let lhs_nm =  gensym_ident(\"lhs\");\n-    let rhs_nm =  gensym_ident(\"rhs\");\n+    let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n+    let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n     // $( $lhs:tt => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n-    let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n-    let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n+    let match_lhs_tok = MatchNt(lhs_nm, ast::Ident::from_str(\"tt\"));\n+    let match_rhs_tok = MatchNt(rhs_nm, ast::Ident::from_str(\"tt\"));\n     let argument_gram = vec![\n         TokenTree::Sequence(DUMMY_SP, Rc::new(tokenstream::SequenceRepetition {\n             tts: vec![\n@@ -790,17 +792,16 @@ fn is_in_follow(tok: &Token, frag: &str) -> Result<bool, (String, &'static str)>\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n-                    Ident(i) if (i.name.as_str() == \"if\" ||\n-                                 i.name.as_str() == \"in\") => Ok(true),\n+                    Ident(i) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n                     Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n-                    MatchNt(_, ref frag) if frag.name.as_str() == \"block\" => Ok(true),\n-                    Ident(i) if i.name.as_str() == \"as\" || i.name.as_str() == \"where\" => Ok(true),\n+                    MatchNt(_, ref frag) if frag.name == \"block\" => Ok(true),\n+                    Ident(i) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },"}, {"sha": "aa6a29b78b075d2263a5eb2ed194161f371db08e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n-use parse::token::InternedString;\n+use symbol::Symbol;\n \n use std::ascii::AsciiExt;\n use std::env;\n@@ -59,9 +59,9 @@ macro_rules! declare_features {\n         /// A set of features to be used by later passes.\n         pub struct Features {\n             /// #![feature] attrs for stable language features, for error reporting\n-            pub declared_stable_lang_features: Vec<(InternedString, Span)>,\n+            pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n             /// #![feature] attrs for non-language (library) features\n-            pub declared_lib_features: Vec<(InternedString, Span)>,\n+            pub declared_lib_features: Vec<(Symbol, Span)>,\n             $(pub $feature: bool),+\n         }\n \n@@ -284,9 +284,6 @@ declare_features! (\n     // instead of just the platforms on which it is the C ABI\n     (active, abi_sysv64, \"1.13.0\", Some(36167)),\n \n-    // Use the import semantics from RFC 1560.\n-    (active, item_like_imports, \"1.13.0\", Some(35120)),\n-\n     // Macros 1.1\n     (active, proc_macro, \"1.13.0\", Some(35900)),\n \n@@ -316,6 +313,9 @@ declare_features! (\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n \n     (active, use_extern_macros, \"1.15.0\", Some(35896)),\n+\n+    // Allows `break {expr}` with a value inside `loop`s.\n+    (active, loop_break_value, \"1.14.0\", Some(37339)),\n );\n \n declare_features! (\n@@ -362,6 +362,7 @@ declare_features! (\n     (accepted, question_mark, \"1.13.0\", Some(31436)),\n     // Allows `..` in tuple (struct) patterns\n     (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627)),\n+    (accepted, item_like_imports, \"1.14.0\", Some(35120)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -757,7 +758,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name();\n+        let name = &*cfg.name().as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -804,7 +805,7 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = &*attr.name();\n+        let name = &*attr.name().as_str();\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if n == name {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n@@ -991,11 +992,11 @@ fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n     use ast::NestedMetaItemKind::*;\n \n     match item.node {\n-        Word(..) => false,\n-        NameValue(_, ref lit) => !lit.node.is_str(),\n-        List(_, ref list) => list.iter().any(|li| {\n+        Word => false,\n+        NameValue(ref lit) => !lit.node.is_str(),\n+        List(ref list) => list.iter().any(|li| {\n             match li.node {\n-                MetaItem(ref mi) => contains_novel_literal(&**mi),\n+                MetaItem(ref mi) => contains_novel_literal(&mi),\n                 Literal(_) => true,\n             }\n         }),\n@@ -1013,7 +1014,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n-        if contains_novel_literal(&*(attr.node.value)) {\n+        if contains_novel_literal(&attr.value) {\n             gate_feature_post!(&self, attr_literals, attr.span,\n                                \"non-string literals in attributes, or string \\\n                                literals in top-level positions, are experimental\");\n@@ -1121,9 +1122,8 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n-                                                                     \"link_name\") {\n-            Some(val) => val.starts_with(\"llvm.\"),\n+        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n+            Some(val) => val.as_str().starts_with(\"llvm.\"),\n             _ => false\n         };\n         if links_to_llvm {\n@@ -1192,6 +1192,10 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                     }\n                 }\n             }\n+            ast::ExprKind::Break(_, Some(_)) => {\n+                gate_feature_post!(&self, loop_break_value, e.span,\n+                                   \"`break` with a value is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "6af8efb2a195c6c3408a568b2fa0b8a8f7c04568", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -22,8 +22,9 @@ use ast::*;\n use ast;\n use syntax_pos::Span;\n use codemap::{Spanned, respan};\n-use parse::token::{self, keywords};\n+use parse::token;\n use ptr::P;\n+use symbol::keywords;\n use tokenstream::*;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n@@ -43,15 +44,15 @@ pub trait Folder : Sized {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: Vec<MetaItem>) -> Vec<MetaItem> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n     fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n         noop_fold_meta_list_item(list_item, self)\n     }\n \n-    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n+    fn fold_meta_item(&mut self, meta_item: MetaItem) -> MetaItem {\n         noop_fold_meta_item(meta_item, self)\n     }\n \n@@ -293,8 +294,7 @@ pub trait Folder : Sized {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T)\n-                                       -> Vec<P<MetaItem>> {\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<MetaItem>, fld: &mut T) -> Vec<MetaItem> {\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n@@ -486,16 +486,13 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     })\n }\n \n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc\n-        },\n-        span: fld.new_span(span)\n+pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Option<Attribute> {\n+    Some(Attribute {\n+        id: attr.id,\n+        style: attr.style,\n+        value: fld.fold_meta_item(attr.value),\n+        is_sugared_doc: attr.is_sugared_doc,\n+        span: fld.new_span(attr.span),\n     })\n }\n \n@@ -522,17 +519,18 @@ pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n     }\n }\n \n-pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned {node, span}| Spanned {\n-        node: match node {\n-            MetaItemKind::Word(id) => MetaItemKind::Word(id),\n-            MetaItemKind::List(id, mis) => {\n-                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n-            }\n-            MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s)\n+pub fn noop_fold_meta_item<T: Folder>(mi: MetaItem, fld: &mut T) -> MetaItem {\n+    MetaItem {\n+        name: mi.name,\n+        node: match mi.node {\n+            MetaItemKind::Word => MetaItemKind::Word,\n+            MetaItemKind::List(mis) => {\n+                MetaItemKind::List(mis.move_map(|e| fld.fold_meta_list_item(e)))\n+            },\n+            MetaItemKind::NameValue(s) => MetaItemKind::NameValue(s),\n         },\n-        span: fld.new_span(span)\n-    })\n+        span: fld.new_span(mi.span)\n+    }\n }\n \n pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n@@ -1240,10 +1238,11 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 });\n                 ExprKind::Path(qself, folder.fold_path(path))\n             }\n-            ExprKind::Break(opt_ident) => ExprKind::Break(opt_ident.map(|label|\n-                respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node)))\n-            ),\n+            ExprKind::Break(opt_ident, opt_expr) => {\n+                ExprKind::Break(opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                             folder.fold_ident(label.node))),\n+                                opt_expr.map(|e| folder.fold_expr(e)))\n+            }\n             ExprKind::Continue(opt_ident) => ExprKind::Continue(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n@@ -1334,9 +1333,8 @@ pub fn noop_fold_vis<T: Folder>(vis: Visibility, folder: &mut T) -> Visibility {\n #[cfg(test)]\n mod tests {\n     use std::io;\n-    use ast;\n+    use ast::{self, Ident};\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n-    use parse::token;\n     use print::pprust;\n     use fold;\n     use super::*;\n@@ -1352,7 +1350,7 @@ mod tests {\n \n     impl Folder for ToZzIdentFolder {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n-            token::str_to_ident(\"zz\")\n+            Ident::from_str(\"zz\")\n         }\n         fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n             fold::noop_fold_mac(mac, self)"}, {"sha": "5a1b0d4005e17e12f14303a9dfe0e2b08dcc4dfb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -27,6 +27,7 @@\n #![feature(associated_consts)]\n #![feature(const_fn)]\n #![feature(libc)]\n+#![feature(optin_builtin_traits)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_escape)]\n@@ -83,7 +84,6 @@ pub mod diagnostics {\n pub mod diagnostic_list;\n \n pub mod util {\n-    pub mod interner;\n     pub mod lev_distance;\n     pub mod node_count;\n     pub mod parser;\n@@ -118,6 +118,7 @@ pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n pub mod str;\n+pub mod symbol;\n pub mod test;\n pub mod tokenstream;\n pub mod visit;"}, {"sha": "ded676da3c6761baa0adb4c3cc273836ca375b22", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,12 +11,11 @@\n use attr;\n use ast;\n use syntax_pos::{mk_sp, Span};\n-use codemap::{spanned, Spanned};\n+use codemap::spanned;\n use parse::common::SeqSep;\n use parse::PResult;\n use parse::token;\n use parse::parser::{Parser, TokenType};\n-use ptr::P;\n \n #[derive(PartialEq, Eq, Debug)]\n enum InnerAttributeParsePolicy<'a> {\n@@ -49,13 +48,9 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = ::attr::mk_sugared_doc_attr(\n-                        attr::mk_attr_id(),\n-                        self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n-                        self.span.lo,\n-                        self.span.hi\n-                    );\n-                    if attr.node.style != ast::AttrStyle::Outer {\n+                    let Span { lo, hi, .. } = self.span;\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n                                   `//!` or `/*!`) can only appear before items\");\n@@ -145,14 +140,12 @@ impl<'a> Parser<'a> {\n             style = ast::AttrStyle::Inner;\n         }\n \n-        Ok(Spanned {\n+        Ok(ast::Attribute {\n+            id: attr::mk_attr_id(),\n+            style: style,\n+            value: value,\n+            is_sugared_doc: false,\n             span: span,\n-            node: ast::Attribute_ {\n-                id: attr::mk_attr_id(),\n-                style: style,\n-                value: value,\n-                is_sugared_doc: false,\n-            },\n         })\n     }\n \n@@ -172,15 +165,14 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let attr = self.parse_attribute(true)?;\n-                    assert!(attr.node.style == ast::AttrStyle::Inner);\n+                    assert!(attr.style == ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n-                    let str = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n-                    if attr.node.style == ast::AttrStyle::Inner {\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n                     } else {\n@@ -213,7 +205,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// meta_item : IDENT ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n     /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n-    pub fn parse_meta_item(&mut self) -> PResult<'a, P<ast::MetaItem>> {\n+    pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token {\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n@@ -229,24 +221,15 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         let ident = self.parse_ident()?;\n-        let name = self.id_to_interned_str(ident);\n-        match self.token {\n-            token::Eq => {\n-                self.bump();\n-                let lit = self.parse_unsuffixed_lit()?;\n-                let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n-            }\n-            token::OpenDelim(token::Paren) => {\n-                let inner_items = self.parse_meta_seq()?;\n-                let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::List(name, inner_items))))\n-            }\n-            _ => {\n-                let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::Word(name))))\n-            }\n-        }\n+        let node = if self.eat(&token::Eq) {\n+            ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n+        } else if self.token == token::OpenDelim(token::Paren) {\n+            ast::MetaItemKind::List(self.parse_meta_seq()?)\n+        } else {\n+            ast::MetaItemKind::Word\n+        };\n+        let hi = self.prev_span.hi;\n+        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n     }\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;"}, {"sha": "681dec0ab564d1c922cf60320583f43314e06331", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span};\n use codemap::CodeMap;\n use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n-use parse::token::{self, keywords, str_to_ident};\n+use parse::token;\n use str::char_at;\n+use symbol::{Symbol, keywords};\n use rustc_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n@@ -350,13 +351,13 @@ impl<'a> StringReader<'a> {\n     /// single-byte delimiter).\n     pub fn name_from(&self, start: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n-        self.with_str_from(start, token::intern)\n+        self.with_str_from(start, Symbol::intern)\n     }\n \n     /// As name_from, with an explicit endpoint.\n     pub fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n-        self.with_str_from_to(start, end, token::intern)\n+        self.with_str_from_to(start, end, Symbol::intern)\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -492,7 +493,7 @@ impl<'a> StringReader<'a> {\n             if string == \"_\" {\n                 None\n             } else {\n-                Some(token::intern(string))\n+                Some(Symbol::intern(string))\n             }\n         })\n     }\n@@ -540,7 +541,7 @@ impl<'a> StringReader<'a> {\n                         self.with_str_from(start_bpos, |string| {\n                             // comments with only more \"/\"s are not doc comments\n                             let tok = if is_doc_comment(string) {\n-                                token::DocComment(token::intern(string))\n+                                token::DocComment(Symbol::intern(string))\n                             } else {\n                                 token::Comment\n                             };\n@@ -669,7 +670,7 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     string.into()\n                 };\n-                token::DocComment(token::intern(&string[..]))\n+                token::DocComment(Symbol::intern(&string[..]))\n             } else {\n                 token::Comment\n             };\n@@ -758,7 +759,7 @@ impl<'a> StringReader<'a> {\n             self.err_span_(start_bpos,\n                            self.pos,\n                            \"no valid digits found for number\");\n-            return token::Integer(token::intern(\"0\"));\n+            return token::Integer(Symbol::intern(\"0\"));\n         }\n \n         // might be a float, but don't be greedy if this is actually an\n@@ -1097,7 +1098,7 @@ impl<'a> StringReader<'a> {\n                     token::Underscore\n                 } else {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    token::Ident(str_to_ident(string))\n+                    token::Ident(Ident::from_str(string))\n                 }\n             }));\n         }\n@@ -1277,13 +1278,13 @@ impl<'a> StringReader<'a> {\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n                     let ident = self.with_str_from(start, |lifetime_name| {\n-                        str_to_ident(&format!(\"'{}\", lifetime_name))\n+                        Ident::from_str(&format!(\"'{}\", lifetime_name))\n                     });\n \n                     // Conjure up a \"keyword checking ident\" to make sure that\n                     // the lifetime name is not a keyword.\n                     let keyword_checking_ident = self.with_str_from(start, |lifetime_name| {\n-                        str_to_ident(lifetime_name)\n+                        Ident::from_str(lifetime_name)\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.pos;\n@@ -1310,7 +1311,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from(start)\n                 } else {\n-                    token::intern(\"0\")\n+                    Symbol::intern(\"0\")\n                 };\n                 self.bump(); // advance ch past token\n                 let suffix = self.scan_optional_raw_name();\n@@ -1352,7 +1353,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from(start_bpos + BytePos(1))\n                 } else {\n-                    token::intern(\"??\")\n+                    Symbol::intern(\"??\")\n                 };\n                 self.bump();\n                 let suffix = self.scan_optional_raw_name();\n@@ -1424,7 +1425,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from_to(content_start_bpos, content_end_bpos)\n                 } else {\n-                    token::intern(\"??\")\n+                    Symbol::intern(\"??\")\n                 };\n                 let suffix = self.scan_optional_raw_name();\n                 return Ok(token::Literal(token::StrRaw(id, hash_count), suffix));\n@@ -1551,7 +1552,7 @@ impl<'a> StringReader<'a> {\n         let id = if valid {\n             self.name_from(start)\n         } else {\n-            token::intern(\"?\")\n+            Symbol::intern(\"?\")\n         };\n         self.bump(); // advance ch past token\n         return token::Byte(id);\n@@ -1584,7 +1585,7 @@ impl<'a> StringReader<'a> {\n         let id = if valid {\n             self.name_from(start)\n         } else {\n-            token::intern(\"??\")\n+            Symbol::intern(\"??\")\n         };\n         self.bump();\n         return token::ByteStr(id);\n@@ -1700,11 +1701,12 @@ fn ident_continue(c: Option<char>) -> bool {\n mod tests {\n     use super::*;\n \n+    use ast::Ident;\n+    use symbol::Symbol;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n     use codemap::CodeMap;\n     use errors;\n     use parse::token;\n-    use parse::token::str_to_ident;\n     use std::io;\n     use std::rc::Rc;\n \n@@ -1732,7 +1734,7 @@ mod tests {\n                                       &sh,\n                                       \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\"\n                                           .to_string());\n-        let id = str_to_ident(\"fn\");\n+        let id = Ident::from_str(\"fn\");\n         assert_eq!(string_reader.next_token().tok, token::Comment);\n         assert_eq!(string_reader.next_token().tok, token::Whitespace);\n         let tok1 = string_reader.next_token();\n@@ -1751,7 +1753,7 @@ mod tests {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan {\n-            tok: token::Ident(str_to_ident(\"main\")),\n+            tok: token::Ident(Ident::from_str(\"main\")),\n             sp: Span {\n                 lo: BytePos(24),\n                 hi: BytePos(28),\n@@ -1773,7 +1775,7 @@ mod tests {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident(id: &str) -> token::Token {\n-        token::Ident(str_to_ident(id))\n+        token::Ident(Ident::from_str(id))\n     }\n \n     #[test]\n@@ -1813,31 +1815,31 @@ mod tests {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"a\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n     fn character_space() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\" \")), None));\n+                   token::Literal(token::Char(Symbol::intern(\" \")), None));\n     }\n \n     #[test]\n     fn character_escaped() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n     }\n \n     #[test]\n     fn lifetime_name() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n-                   token::Lifetime(token::str_to_ident(\"'abc\")));\n+                   token::Lifetime(Ident::from_str(\"'abc\")));\n     }\n \n     #[test]\n@@ -1847,7 +1849,7 @@ mod tests {\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n                        .tok,\n-                   token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n+                   token::Literal(token::StrRaw(Symbol::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test]\n@@ -1857,11 +1859,11 @@ mod tests {\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n                 assert_eq!(setup(&cm, &sh, format!(\"{}suffix\", $input)).next_token().tok,\n-                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n-                                          Some(token::intern(\"suffix\"))));\n+                           token::Literal(token::$tok_type(Symbol::intern($tok_contents)),\n+                                          Some(Symbol::intern(\"suffix\"))));\n                 // with a whitespace separator:\n                 assert_eq!(setup(&cm, &sh, format!(\"{} suffix\", $input)).next_token().tok,\n-                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n+                           token::Literal(token::$tok_type(Symbol::intern($tok_contents)),\n                                           None));\n             }}\n         }\n@@ -1877,14 +1879,14 @@ mod tests {\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n         assert_eq!(setup(&cm, &sh, \"2us\".to_string()).next_token().tok,\n-                   token::Literal(token::Integer(token::intern(\"2\")),\n-                                  Some(token::intern(\"us\"))));\n+                   token::Literal(token::Integer(Symbol::intern(\"2\")),\n+                                  Some(Symbol::intern(\"us\"))));\n         assert_eq!(setup(&cm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n-                                  Some(token::intern(\"suffix\"))));\n+                   token::Literal(token::StrRaw(Symbol::intern(\"raw\"), 3),\n+                                  Some(Symbol::intern(\"suffix\"))));\n         assert_eq!(setup(&cm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n-                                  Some(token::intern(\"suffix\"))));\n+                   token::Literal(token::ByteStrRaw(Symbol::intern(\"raw\"), 3),\n+                                  Some(Symbol::intern(\"suffix\"))));\n     }\n \n     #[test]\n@@ -1904,7 +1906,7 @@ mod tests {\n             _ => panic!(\"expected a comment!\"),\n         }\n         assert_eq!(lexer.next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"a\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n@@ -1917,6 +1919,6 @@ mod tests {\n         assert_eq!(comment.sp, ::syntax_pos::mk_sp(BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n-                   token::DocComment(token::intern(\"/// test\")));\n+                   token::DocComment(Symbol::intern(\"/// test\")));\n     }\n }"}, {"sha": "bfaf00a3d3f0814ee319772f306d564a2fea5c73", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 63, "deletions": 57, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,12 +16,13 @@ use syntax_pos::{self, Span, FileMap};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n-use parse::token::InternedString;\n use ptr::P;\n use str::char_at;\n+use symbol::Symbol;\n use tokenstream;\n \n use std::cell::RefCell;\n+use std::collections::HashSet;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n@@ -64,7 +65,7 @@ impl ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n-            config: Vec::new(),\n+            config: HashSet::new(),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map: code_map\n         }\n@@ -75,6 +76,19 @@ impl ParseSess {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct Directory {\n+    pub path: PathBuf,\n+    pub ownership: DirectoryOwnership,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum DirectoryOwnership {\n+    Owned,\n+    UnownedViaBlock,\n+    UnownedViaMod(bool /* legacy warnings? */),\n+}\n+\n // a bunch of utility functions of the form parse_<thing>_from_<source>\n // where <thing> includes crate, expr, item, stmt, tts, and one that\n // uses a HOF to parse anything, and <source> includes file and\n@@ -116,7 +130,7 @@ pub fn parse_item_from_source_str<'a>(name: String, source: String, sess: &'a Pa\n }\n \n pub fn parse_meta_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                      -> PResult<'a, P<ast::MetaItem>> {\n+                                      -> PResult<'a, ast::MetaItem> {\n     new_parser_from_source_str(sess, name, source).parse_meta_item()\n }\n \n@@ -151,11 +165,11 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a>\n /// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n                                     path: &Path,\n-                                    owns_directory: bool,\n+                                    directory_ownership: DirectoryOwnership,\n                                     module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n     let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)));\n-    p.owns_directory = owns_directory;\n+    p.directory.ownership = directory_ownership;\n     p.root_module_name = module_name;\n     p\n }\n@@ -371,13 +385,18 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n-fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n-                      sd: &Handler, sp: Span) -> ast::LitKind {\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, sd: &Handler, sp: Span)\n+                      -> ast::LitKind {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n-    match suffix.as_ref().map(|s| &**s) {\n-        Some(\"f32\") => ast::LitKind::Float(data, ast::FloatTy::F32),\n-        Some(\"f64\") => ast::LitKind::Float(data, ast::FloatTy::F64),\n-        Some(suf) => {\n+    let suffix = match suffix {\n+        Some(suffix) => suffix,\n+        None => return ast::LitKind::FloatUnsuffixed(data),\n+    };\n+\n+    match &*suffix.as_str() {\n+        \"f32\" => ast::LitKind::Float(data, ast::FloatTy::F32),\n+        \"f64\" => ast::LitKind::Float(data, ast::FloatTy::F64),\n+        suf => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n@@ -391,16 +410,13 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n \n             ast::LitKind::FloatUnsuffixed(data)\n         }\n-        None => ast::LitKind::FloatUnsuffixed(data)\n     }\n }\n-pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn float_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let data = token::intern_and_get_ident(&s);\n-    filtered_float_lit(data, suffix.as_ref().map(|s| &**s), sd, sp)\n+    filtered_float_lit(Symbol::intern(&s), suffix, sd, sp)\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n@@ -495,11 +511,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str,\n-                   suffix: Option<InternedString>,\n-                   sd: &Handler,\n-                   sp: Span)\n-                   -> ast::LitKind {\n+pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -521,26 +533,25 @@ pub fn integer_lit(s: &str,\n     }\n \n     // 1f64 and 2f32 etc. are valid float literals.\n-    if let Some(ref suf) = suffix {\n-        if looks_like_width_suffix(&['f'], suf) {\n+    if let Some(suf) = suffix {\n+        if looks_like_width_suffix(&['f'], &suf.as_str()) {\n             match base {\n                 16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n                 8 => sd.span_err(sp, \"octal float literal is not supported\"),\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n-            let ident = token::intern_and_get_ident(&s);\n-            return filtered_float_lit(ident, Some(&suf), sd, sp)\n+            return filtered_float_lit(Symbol::intern(&s), Some(suf), sd, sp)\n         }\n     }\n \n     if base != 10 {\n         s = &s[2..];\n     }\n \n-    if let Some(ref suf) = suffix {\n-        if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n-        ty = match &**suf {\n+    if let Some(suf) = suffix {\n+        if suf.as_str().is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        ty = match &*suf.as_str() {\n             \"isize\" => ast::LitIntType::Signed(ast::IntTy::Is),\n             \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n             \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n@@ -551,7 +562,7 @@ pub fn integer_lit(s: &str,\n             \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n-            _ => {\n+            suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n@@ -599,12 +610,11 @@ mod tests {\n     use std::rc::Rc;\n     use syntax_pos::{self, Span, BytePos, Pos, NO_EXPANSION};\n     use codemap::Spanned;\n-    use ast::{self, PatKind};\n+    use ast::{self, Ident, PatKind};\n     use abi::Abi;\n     use attr::first_attr_value_str_by_name;\n     use parse;\n     use parse::parser::Parser;\n-    use parse::token::{str_to_ident};\n     use print::pprust::item_to_string;\n     use ptr::P;\n     use tokenstream::{self, TokenTree};\n@@ -626,7 +636,7 @@ mod tests {\n                         global: false,\n                         segments: vec![\n                             ast::PathSegment {\n-                                identifier: str_to_ident(\"a\"),\n+                                identifier: Ident::from_str(\"a\"),\n                                 parameters: ast::PathParameters::none(),\n                             }\n                         ],\n@@ -645,11 +655,11 @@ mod tests {\n                             global: true,\n                             segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"a\"),\n+                                    identifier: Ident::from_str(\"a\"),\n                                     parameters: ast::PathParameters::none(),\n                                 },\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"b\"),\n+                                    identifier: Ident::from_str(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                             ]\n@@ -678,8 +688,8 @@ mod tests {\n                 Some(&TokenTree::Token(_, token::Ident(name_zip))),\n                 Some(&TokenTree::Delimited(_, ref macro_delimed)),\n             )\n-            if name_macro_rules.name.as_str() == \"macro_rules\"\n-            && name_zip.name.as_str() == \"zip\" => {\n+            if name_macro_rules.name == \"macro_rules\"\n+            && name_zip.name == \"zip\" => {\n                 let tts = &macro_delimed.tts[..];\n                 match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                     (\n@@ -696,8 +706,7 @@ mod tests {\n                                 Some(&TokenTree::Token(_, token::Dollar)),\n                                 Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n-                            if first_delimed.delim == token::Paren\n-                            && ident.name.as_str() == \"a\" => {},\n+                            if first_delimed.delim == token::Paren && ident.name == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n@@ -708,7 +717,7 @@ mod tests {\n                                 Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n                             if second_delimed.delim == token::Paren\n-                            && ident.name.as_str() == \"a\" => {},\n+                            && ident.name == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),\n                         }\n                     },\n@@ -724,17 +733,17 @@ mod tests {\n         let tts = string_to_tts(\"fn a (b : i32) { b; }\".to_string());\n \n         let expected = vec![\n-            TokenTree::Token(sp(0, 2), token::Ident(str_to_ident(\"fn\"))),\n-            TokenTree::Token(sp(3, 4), token::Ident(str_to_ident(\"a\"))),\n+            TokenTree::Token(sp(0, 2), token::Ident(Ident::from_str(\"fn\"))),\n+            TokenTree::Token(sp(3, 4), token::Ident(Ident::from_str(\"a\"))),\n             TokenTree::Delimited(\n                 sp(5, 14),\n                 Rc::new(tokenstream::Delimited {\n                     delim: token::DelimToken::Paren,\n                     open_span: sp(5, 6),\n                     tts: vec![\n-                        TokenTree::Token(sp(6, 7), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(6, 7), token::Ident(Ident::from_str(\"b\"))),\n                         TokenTree::Token(sp(8, 9), token::Colon),\n-                        TokenTree::Token(sp(10, 13), token::Ident(str_to_ident(\"i32\"))),\n+                        TokenTree::Token(sp(10, 13), token::Ident(Ident::from_str(\"i32\"))),\n                     ],\n                     close_span: sp(13, 14),\n                 })),\n@@ -744,7 +753,7 @@ mod tests {\n                     delim: token::DelimToken::Brace,\n                     open_span: sp(15, 16),\n                     tts: vec![\n-                        TokenTree::Token(sp(17, 18), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(17, 18), token::Ident(Ident::from_str(\"b\"))),\n                         TokenTree::Token(sp(18, 19), token::Semi),\n                     ],\n                     close_span: sp(20, 21),\n@@ -765,7 +774,7 @@ mod tests {\n                             global: false,\n                             segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"d\"),\n+                                    identifier: Ident::from_str(\"d\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                             ],\n@@ -788,7 +797,7 @@ mod tests {\n                                global:false,\n                                segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"b\"),\n+                                    identifier: Ident::from_str(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                                ],\n@@ -812,7 +821,7 @@ mod tests {\n                 id: ast::DUMMY_NODE_ID,\n                 node: PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                     Spanned{ span:sp(0, 1),\n-                                             node: str_to_ident(\"b\")\n+                                             node: Ident::from_str(\"b\")\n                     },\n                                     None),\n                 span: sp(0,1)}));\n@@ -824,7 +833,7 @@ mod tests {\n         // this test depends on the intern order of \"fn\" and \"i32\"\n         assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n                   Some(\n-                      P(ast::Item{ident:str_to_ident(\"a\"),\n+                      P(ast::Item{ident:Ident::from_str(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n@@ -835,8 +844,7 @@ mod tests {\n                                         global:false,\n                                         segments: vec![\n                                             ast::PathSegment {\n-                                                identifier:\n-                                                    str_to_ident(\"i32\"),\n+                                                identifier: Ident::from_str(\"i32\"),\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ],\n@@ -849,7 +857,7 @@ mod tests {\n                                             ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                                 Spanned{\n                                                     span: sp(6,7),\n-                                                    node: str_to_ident(\"b\")},\n+                                                    node: Ident::from_str(\"b\")},\n                                                 None\n                                                     ),\n                                             span: sp(6,7)\n@@ -884,9 +892,7 @@ mod tests {\n                                                         global:false,\n                                                         segments: vec![\n                                                             ast::PathSegment {\n-                                                                identifier:\n-                                                                str_to_ident(\n-                                                                    \"b\"),\n+                                                                identifier: Ident::from_str(\"b\"),\n                                                                 parameters:\n                                                                 ast::PathParameters::none(),\n                                                             }\n@@ -998,20 +1004,20 @@ mod tests {\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[..], \"/// doc comment\");\n+        assert_eq!(doc, \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n-        let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, &sess).unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n+        assert_eq!(doc, \"/** doc comment\\n *  with CRLF */\");\n     }\n \n     #[test]"}, {"sha": "49226be4147d7c4b9b01a062f4b44c4997fcc45f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 121, "deletions": 110, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -38,7 +38,7 @@ use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n-use ast;\n+use {ast, attr};\n use codemap::{self, CodeMap, Spanned, spanned, respan};\n use syntax_pos::{self, Span, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n@@ -48,13 +48,14 @@ use parse::classify;\n use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n-use parse::token::{self, intern, keywords, MatchNt, SubstNt, InternedString};\n-use parse::{new_sub_parser_from_file, ParseSess};\n+use parse::token::{self, MatchNt, SubstNt};\n+use parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use parse::PResult;\n use tokenstream::{self, Delimited, SequenceRepetition, TokenTree};\n+use symbol::{Symbol, keywords};\n use util::ThinVec;\n \n use std::collections::HashSet;\n@@ -67,7 +68,6 @@ bitflags! {\n     flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n-        const NO_NONINLINE_MOD  = 1 << 2,\n     }\n }\n \n@@ -199,12 +199,9 @@ pub struct Parser<'a> {\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    pub directory: PathBuf,\n+    pub directory: Directory,\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(token::DelimToken, Span)>,\n-    /// Flag if this parser \"owns\" the directory that it is currently parsing\n-    /// in. This will affect how nested files are looked up.\n-    pub owns_directory: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n@@ -244,8 +241,9 @@ pub struct ModulePath {\n }\n \n pub struct ModulePathSuccess {\n-    pub path: ::std::path::PathBuf,\n-    pub owns_directory: bool,\n+    pub path: PathBuf,\n+    pub directory_ownership: DirectoryOwnership,\n+    warn: bool,\n }\n \n pub struct ModulePathError {\n@@ -295,9 +293,8 @@ impl<'a> Parser<'a> {\n             quote_depth: 0,\n             parsing_token_tree: false,\n             obsolete_set: HashSet::new(),\n-            directory: PathBuf::new(),\n+            directory: Directory { path: PathBuf::new(), ownership: DirectoryOwnership::Owned },\n             open_braces: Vec::new(),\n-            owns_directory: true,\n             root_module_name: None,\n             expected_tokens: Vec::new(),\n             tts: Vec::new(),\n@@ -309,8 +306,8 @@ impl<'a> Parser<'a> {\n         parser.token = tok.tok;\n         parser.span = tok.sp;\n         if parser.span != syntax_pos::DUMMY_SP {\n-            parser.directory = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n-            parser.directory.pop();\n+            parser.directory.path = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n+            parser.directory.path.pop();\n         }\n         parser\n     }\n@@ -998,10 +995,6 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n-        id.name.as_str()\n-    }\n-\n     /// Is the current token one of the keywords that signals a bare function\n     /// type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n@@ -1523,34 +1516,28 @@ impl<'a> Parser<'a> {\n                     // float literals, so all the handling is done\n                     // internally.\n                     token::Integer(s) => {\n-                        (false, parse::integer_lit(&s.as_str(),\n-                                                   suf.as_ref().map(|s| s.as_str()),\n-                                                   &self.sess.span_diagnostic,\n-                                                   self.span))\n+                        let diag = &self.sess.span_diagnostic;\n+                        (false, parse::integer_lit(&s.as_str(), suf, diag, self.span))\n                     }\n                     token::Float(s) => {\n-                        (false, parse::float_lit(&s.as_str(),\n-                                                 suf.as_ref().map(|s| s.as_str()),\n-                                                  &self.sess.span_diagnostic,\n-                                                 self.span))\n+                        let diag = &self.sess.span_diagnostic;\n+                        (false, parse::float_lit(&s.as_str(), suf, diag, self.span))\n                     }\n \n                     token::Str_(s) => {\n-                        (true,\n-                         LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n-                                      ast::StrStyle::Cooked))\n+                        let s = Symbol::intern(&parse::str_lit(&s.as_str()));\n+                        (true, LitKind::Str(s, ast::StrStyle::Cooked))\n                     }\n                     token::StrRaw(s, n) => {\n-                        (true,\n-                         LitKind::Str(\n-                            token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n-                            ast::StrStyle::Raw(n)))\n+                        let s = Symbol::intern(&parse::raw_str_lit(&s.as_str()));\n+                        (true, LitKind::Str(s, ast::StrStyle::Raw(n)))\n+                    }\n+                    token::ByteStr(i) => {\n+                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str())))\n+                    }\n+                    token::ByteStrRaw(i, _) => {\n+                        (true, LitKind::ByteStr(Rc::new(i.to_string().into_bytes())))\n                     }\n-                    token::ByteStr(i) =>\n-                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str()))),\n-                    token::ByteStrRaw(i, _) =>\n-                        (true,\n-                         LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))),\n                 };\n \n                 if suffix_illegal {\n@@ -2269,15 +2256,25 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Ret(None);\n                     }\n                 } else if self.eat_keyword(keywords::Break) {\n-                    if self.token.is_lifetime() {\n-                        ex = ExprKind::Break(Some(Spanned {\n+                    let lt = if self.token.is_lifetime() {\n+                        let spanned_lt = Spanned {\n                             node: self.get_lifetime(),\n                             span: self.span\n-                        }));\n+                        };\n                         self.bump();\n+                        Some(spanned_lt)\n                     } else {\n-                        ex = ExprKind::Break(None);\n-                    }\n+                        None\n+                    };\n+                    let e = if self.token.can_begin_expr()\n+                               && !(self.token == token::OpenDelim(token::Brace)\n+                                    && self.restrictions.contains(\n+                                           Restrictions::RESTRICTION_NO_STRUCT_LITERAL)) {\n+                        Some(self.parse_expr()?)\n+                    } else {\n+                        None\n+                    };\n+                    ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `check_strict_keywords`, so\n@@ -2544,7 +2541,7 @@ impl<'a> Parser<'a> {\n                     let prev_span = self.prev_span;\n                     let fstr = n.as_str();\n                     let mut err = self.diagnostic().struct_span_err(prev_span,\n-                        &format!(\"unexpected token: `{}`\", n.as_str()));\n+                        &format!(\"unexpected token: `{}`\", n));\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n@@ -2627,7 +2624,7 @@ impl<'a> Parser<'a> {\n                                       })));\n                 } else if self.token.is_keyword(keywords::Crate) {\n                     let ident = match self.token {\n-                        token::Ident(id) => ast::Ident { name: token::intern(\"$crate\"), ..id },\n+                        token::Ident(id) => ast::Ident { name: Symbol::intern(\"$crate\"), ..id },\n                         _ => unreachable!(),\n                     };\n                     self.bump();\n@@ -3751,9 +3748,7 @@ impl<'a> Parser<'a> {\n     /// Emit an expected item after attributes error.\n     fn expected_item_err(&self, attrs: &[Attribute]) {\n         let message = match attrs.last() {\n-            Some(&Attribute { node: ast::Attribute_ { is_sugared_doc: true, .. }, .. }) => {\n-                \"expected item after doc comment\"\n-            }\n+            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n             _ => \"expected item after attributes\",\n         };\n \n@@ -3977,9 +3972,11 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n-            let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n-            match self.with_res(restrictions,\n-                                |this| this.parse_item_(attrs.clone(), false, true))? {\n+            let old_directory_ownership =\n+                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+            let item = self.parse_item_(attrs.clone(), false, true)?;\n+            self.directory.ownership = old_directory_ownership;\n+            match item {\n                 Some(i) => Stmt {\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, i.span.hi),\n@@ -4837,7 +4834,7 @@ impl<'a> Parser<'a> {\n             Visibility::Inherited => (),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n-                    token::Ident(sid) => sid.name == intern(\"macro_rules\"),\n+                    token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {\n@@ -5282,39 +5279,53 @@ impl<'a> Parser<'a> {\n             self.bump();\n             if in_cfg {\n                 // This mod is in an external file. Let's go get it!\n-                let (m, attrs) = self.eval_src_mod(id, &outer_attrs, id_span)?;\n-                Ok((id, m, Some(attrs)))\n+                let ModulePathSuccess { path, directory_ownership, warn } =\n+                    self.submod_path(id, &outer_attrs, id_span)?;\n+                let (module, mut attrs) =\n+                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n+                if warn {\n+                    let attr = ast::Attribute {\n+                        id: attr::mk_attr_id(),\n+                        style: ast::AttrStyle::Outer,\n+                        value: ast::MetaItem {\n+                            name: Symbol::intern(\"warn_directory_ownership\"),\n+                            node: ast::MetaItemKind::Word,\n+                            span: syntax_pos::DUMMY_SP,\n+                        },\n+                        is_sugared_doc: false,\n+                        span: syntax_pos::DUMMY_SP,\n+                    };\n+                    attr::mark_known(&attr);\n+                    attrs.push(attr);\n+                }\n+                Ok((id, module, Some(attrs)))\n             } else {\n                 let placeholder = ast::Mod { inner: syntax_pos::DUMMY_SP, items: Vec::new() };\n                 Ok((id, ItemKind::Mod(placeholder), None))\n             }\n         } else {\n-            let directory = self.directory.clone();\n-            let restrictions = self.push_directory(id, &outer_attrs);\n+            let old_directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.span.lo;\n             let attrs = self.parse_inner_attributes()?;\n-            let m = self.with_res(restrictions, |this| {\n-                this.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)\n-            })?;\n-            self.directory = directory;\n-            Ok((id, ItemKind::Mod(m), Some(attrs)))\n+            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n+            self.directory = old_directory;\n+            Ok((id, ItemKind::Mod(module), Some(attrs)))\n         }\n     }\n \n-    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) -> Restrictions {\n-        if let Some(path) = ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            self.directory.push(&*path);\n-            self.restrictions - Restrictions::NO_NONINLINE_MOD\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n+        if let Some(path) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n+            self.directory.path.push(&*path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned;\n         } else {\n-            let default_path = self.id_to_interned_str(id);\n-            self.directory.push(&*default_path);\n-            self.restrictions\n+            self.directory.path.push(&*id.name.as_str());\n         }\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d))\n+        attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d.as_str()))\n     }\n \n     /// Returns either a path to a module, or .\n@@ -5329,8 +5340,16 @@ impl<'a> Parser<'a> {\n         let secondary_exists = codemap.file_exists(&secondary_path);\n \n         let result = match (default_exists, secondary_exists) {\n-            (true, false) => Ok(ModulePathSuccess { path: default_path, owns_directory: false }),\n-            (false, true) => Ok(ModulePathSuccess { path: secondary_path, owns_directory: true }),\n+            (true, false) => Ok(ModulePathSuccess {\n+                path: default_path,\n+                directory_ownership: DirectoryOwnership::UnownedViaMod(false),\n+                warn: false,\n+            }),\n+            (false, true) => Ok(ModulePathSuccess {\n+                path: secondary_path,\n+                directory_ownership: DirectoryOwnership::Owned,\n+                warn: false,\n+            }),\n             (false, false) => Err(ModulePathError {\n                 err_msg: format!(\"file not found for module `{}`\", mod_name),\n                 help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n@@ -5358,13 +5377,20 @@ impl<'a> Parser<'a> {\n                    id: ast::Ident,\n                    outer_attrs: &[ast::Attribute],\n                    id_sp: Span) -> PResult<'a, ModulePathSuccess> {\n-        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &self.directory) {\n-            return Ok(ModulePathSuccess { path: p, owns_directory: true });\n+        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n+            return Ok(ModulePathSuccess {\n+                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n+                    Some(\"mod.rs\") => DirectoryOwnership::Owned,\n+                    _ => DirectoryOwnership::UnownedViaMod(true),\n+                },\n+                path: path,\n+                warn: false,\n+            });\n         }\n \n-        let paths = Parser::default_submod_path(id, &self.directory, self.sess.codemap());\n+        let paths = Parser::default_submod_path(id, &self.directory.path, self.sess.codemap());\n \n-        if self.restrictions.contains(Restrictions::NO_NONINLINE_MOD) {\n+        if let DirectoryOwnership::UnownedViaBlock = self.directory.ownership {\n             let msg =\n                 \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n             let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n@@ -5374,10 +5400,15 @@ impl<'a> Parser<'a> {\n                 err.span_note(id_sp, &msg);\n             }\n             return Err(err);\n-        } else if !self.owns_directory {\n+        } else if let DirectoryOwnership::UnownedViaMod(warn) = self.directory.ownership {\n+            if warn {\n+                if let Ok(result) = paths.result {\n+                    return Ok(ModulePathSuccess { warn: true, ..result });\n+                }\n+            }\n             let mut err = self.diagnostic().struct_span_err(id_sp,\n                 \"cannot declare a new module at this location\");\n-            let this_module = match self.directory.file_name() {\n+            let this_module = match self.directory.path.file_name() {\n                 Some(file_name) => file_name.to_str().unwrap().to_owned(),\n                 None => self.root_module_name.as_ref().unwrap().clone(),\n             };\n@@ -5390,8 +5421,10 @@ impl<'a> Parser<'a> {\n                               &format!(\"... or maybe `use` the module `{}` instead \\\n                                         of possibly redeclaring it\",\n                                        paths.name));\n-            }\n-            return Err(err);\n+                return Err(err);\n+            } else {\n+                return Err(err);\n+            };\n         }\n \n         match paths.result {\n@@ -5402,25 +5435,11 @@ impl<'a> Parser<'a> {\n \n     /// Read a module from a source file.\n     fn eval_src_mod(&mut self,\n-                    id: ast::Ident,\n-                    outer_attrs: &[ast::Attribute],\n+                    path: PathBuf,\n+                    directory_ownership: DirectoryOwnership,\n+                    name: String,\n                     id_sp: Span)\n                     -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n-        let ModulePathSuccess { path, owns_directory } = self.submod_path(id,\n-                                                                          outer_attrs,\n-                                                                          id_sp)?;\n-\n-        self.eval_src_mod_from_path(path,\n-                                    owns_directory,\n-                                    id.to_string(),\n-                                    id_sp)\n-    }\n-\n-    fn eval_src_mod_from_path(&mut self,\n-                              path: PathBuf,\n-                              owns_directory: bool,\n-                              name: String,\n-                              id_sp: Span) -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n             let mut err = String::from(\"circular modules: \");\n@@ -5435,7 +5454,8 @@ impl<'a> Parser<'a> {\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);\n \n-        let mut p0 = new_sub_parser_from_file(self.sess, &path, owns_directory, Some(name), id_sp);\n+        let mut p0 =\n+            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n         let mod_inner_lo = p0.span.lo;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n@@ -6128,26 +6148,17 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn parse_optional_str(&mut self)\n-                              -> Option<(InternedString,\n-                                         ast::StrStyle,\n-                                         Option<ast::Name>)> {\n+    pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n         let ret = match self.token {\n-            token::Literal(token::Str_(s), suf) => {\n-                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                (s, ast::StrStyle::Cooked, suf)\n-            }\n-            token::Literal(token::StrRaw(s, n), suf) => {\n-                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                (s, ast::StrStyle::Raw(n), suf)\n-            }\n+            token::Literal(token::Str_(s), suf) => (s, ast::StrStyle::Cooked, suf),\n+            token::Literal(token::StrRaw(s, n), suf) => (s, ast::StrStyle::Raw(n), suf),\n             _ => return None\n         };\n         self.bump();\n         Some(ret)\n     }\n \n-    pub fn parse_str(&mut self) -> PResult<'a, (InternedString, StrStyle)> {\n+    pub fn parse_str(&mut self) -> PResult<'a, (Symbol, StrStyle)> {\n         match self.parse_optional_str() {\n             Some((s, style, suf)) => {\n                 let sp = self.prev_span;"}, {"sha": "8ac39dd462e7cbf254667b21f5e12ae21329d352", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 272, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,13 +16,10 @@ pub use self::Token::*;\n \n use ast::{self};\n use ptr::P;\n-use util::interner::Interner;\n+use symbol::keywords;\n use tokenstream;\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::cell::RefCell;\n use std::fmt;\n-use std::ops::Deref;\n use std::rc::Rc;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -301,7 +298,7 @@ pub enum Nonterminal {\n     NtTy(P<ast::Ty>),\n     NtIdent(ast::SpannedIdent),\n     /// Stuff inside brackets for attributes\n-    NtMeta(P<ast::MetaItem>),\n+    NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n     NtTT(tokenstream::TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n@@ -335,270 +332,3 @@ impl fmt::Debug for Nonterminal {\n         }\n     }\n }\n-\n-// In this macro, there is the requirement that the name (the number) must be monotonically\n-// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero.\n-macro_rules! declare_keywords {(\n-    $( ($index: expr, $konst: ident, $string: expr) )*\n-) => {\n-    pub mod keywords {\n-        use ast;\n-        #[derive(Clone, Copy, PartialEq, Eq)]\n-        pub struct Keyword {\n-            ident: ast::Ident,\n-        }\n-        impl Keyword {\n-            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n-            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n-        }\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n-            };\n-        )*\n-    }\n-\n-    fn mk_fresh_ident_interner() -> IdentInterner {\n-        Interner::prefill(&[$($string,)*])\n-    }\n-}}\n-\n-// NB: leaving holes in the ident table is bad! a different ident will get\n-// interned with the id from the hole, but it will be between the min and max\n-// of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n-// this should be rarely necessary though if the keywords are kept in alphabetic order.\n-declare_keywords! {\n-    // Invalid identifier\n-    (0,  Invalid,        \"\")\n-\n-    // Strict keywords used in the language.\n-    (1,  As,             \"as\")\n-    (2,  Box,            \"box\")\n-    (3,  Break,          \"break\")\n-    (4,  Const,          \"const\")\n-    (5,  Continue,       \"continue\")\n-    (6,  Crate,          \"crate\")\n-    (7,  Else,           \"else\")\n-    (8,  Enum,           \"enum\")\n-    (9,  Extern,         \"extern\")\n-    (10, False,          \"false\")\n-    (11, Fn,             \"fn\")\n-    (12, For,            \"for\")\n-    (13, If,             \"if\")\n-    (14, Impl,           \"impl\")\n-    (15, In,             \"in\")\n-    (16, Let,            \"let\")\n-    (17, Loop,           \"loop\")\n-    (18, Match,          \"match\")\n-    (19, Mod,            \"mod\")\n-    (20, Move,           \"move\")\n-    (21, Mut,            \"mut\")\n-    (22, Pub,            \"pub\")\n-    (23, Ref,            \"ref\")\n-    (24, Return,         \"return\")\n-    (25, SelfValue,      \"self\")\n-    (26, SelfType,       \"Self\")\n-    (27, Static,         \"static\")\n-    (28, Struct,         \"struct\")\n-    (29, Super,          \"super\")\n-    (30, Trait,          \"trait\")\n-    (31, True,           \"true\")\n-    (32, Type,           \"type\")\n-    (33, Unsafe,         \"unsafe\")\n-    (34, Use,            \"use\")\n-    (35, Where,          \"where\")\n-    (36, While,          \"while\")\n-\n-    // Keywords reserved for future use.\n-    (37, Abstract,       \"abstract\")\n-    (38, Alignof,        \"alignof\")\n-    (39, Become,         \"become\")\n-    (40, Do,             \"do\")\n-    (41, Final,          \"final\")\n-    (42, Macro,          \"macro\")\n-    (43, Offsetof,       \"offsetof\")\n-    (44, Override,       \"override\")\n-    (45, Priv,           \"priv\")\n-    (46, Proc,           \"proc\")\n-    (47, Pure,           \"pure\")\n-    (48, Sizeof,         \"sizeof\")\n-    (49, Typeof,         \"typeof\")\n-    (50, Unsized,        \"unsized\")\n-    (51, Virtual,        \"virtual\")\n-    (52, Yield,          \"yield\")\n-\n-    // Weak keywords, have special meaning only in specific contexts.\n-    (53, Default,        \"default\")\n-    (54, StaticLifetime, \"'static\")\n-    (55, Union,          \"union\")\n-}\n-\n-// looks like we can get rid of this completely...\n-pub type IdentInterner = Interner;\n-\n-// if an interner exists in TLS, return it. Otherwise, prepare a\n-// fresh one.\n-// FIXME(eddyb) #8726 This should probably use a thread-local reference.\n-pub fn with_ident_interner<T, F: FnOnce(&mut IdentInterner) -> T>(f: F) -> T {\n-    thread_local!(static KEY: RefCell<IdentInterner> = {\n-        RefCell::new(mk_fresh_ident_interner())\n-    });\n-    KEY.with(|interner| f(&mut *interner.borrow_mut()))\n-}\n-\n-/// Reset the ident interner to its initial state.\n-pub fn reset_ident_interner() {\n-    with_ident_interner(|interner| *interner = mk_fresh_ident_interner());\n-}\n-\n-pub fn clear_ident_interner() {\n-    with_ident_interner(|interner| *interner = IdentInterner::new());\n-}\n-\n-/// Represents a string stored in the thread-local interner. Because the\n-/// interner lives for the life of the thread, this can be safely treated as an\n-/// immortal string, as long as it never crosses between threads.\n-///\n-/// FIXME(pcwalton): You must be careful about what you do in the destructors\n-/// of objects stored in TLS, because they may run after the interner is\n-/// destroyed. In particular, they must not access string contents. This can\n-/// be fixed in the future by just leaking all strings until thread death\n-/// somehow.\n-#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n-pub struct InternedString {\n-    string: Rc<str>,\n-}\n-\n-impl InternedString {\n-    #[inline]\n-    pub fn new(string: &'static str) -> InternedString {\n-        InternedString {\n-            string: Rc::__from_str(string),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn new_from_name(name: ast::Name) -> InternedString {\n-        with_ident_interner(|interner| InternedString { string: interner.get(name) })\n-    }\n-}\n-\n-impl Deref for InternedString {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str { &self.string }\n-}\n-\n-impl fmt::Debug for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.string, f)\n-    }\n-}\n-\n-impl fmt::Display for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.string, f)\n-    }\n-}\n-\n-impl<'a> PartialEq<&'a str> for InternedString {\n-    #[inline(always)]\n-    fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(&self.string[..], *other)\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(&self.string[..], *other)\n-    }\n-}\n-\n-impl<'a> PartialEq<InternedString> for &'a str {\n-    #[inline(always)]\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, &other.string[..])\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, &other.string[..])\n-    }\n-}\n-\n-impl PartialEq<str> for InternedString {\n-    #[inline(always)]\n-    fn eq(&self, other: &str) -> bool {\n-        PartialEq::eq(&self.string[..], other)\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &str) -> bool {\n-        PartialEq::ne(&self.string[..], other)\n-    }\n-}\n-\n-impl PartialEq<InternedString> for str {\n-    #[inline(always)]\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(self, &other.string[..])\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(self, &other.string[..])\n-    }\n-}\n-\n-impl Decodable for InternedString {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(intern(&d.read_str()?).as_str())\n-    }\n-}\n-\n-impl Encodable for InternedString {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.string)\n-    }\n-}\n-\n-/// Interns and returns the string contents of an identifier, using the\n-/// thread-local interner.\n-#[inline]\n-pub fn intern_and_get_ident(s: &str) -> InternedString {\n-    intern(s).as_str()\n-}\n-\n-/// Maps a string to its interned representation.\n-#[inline]\n-pub fn intern(s: &str) -> ast::Name {\n-    with_ident_interner(|interner| interner.intern(s))\n-}\n-\n-/// gensym's a new usize, using the current interner.\n-#[inline]\n-pub fn gensym(s: &str) -> ast::Name {\n-    with_ident_interner(|interner| interner.gensym(s))\n-}\n-\n-/// Maps a string to an identifier with an empty syntax context.\n-#[inline]\n-pub fn str_to_ident(s: &str) -> ast::Ident {\n-    ast::Ident::with_empty_ctxt(intern(s))\n-}\n-\n-/// Maps a string to a gensym'ed identifier.\n-#[inline]\n-pub fn gensym_ident(s: &str) -> ast::Ident {\n-    ast::Ident::with_empty_ctxt(gensym(s))\n-}\n-\n-// create a fresh name that maps to the same string as the old one.\n-// note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n-// that is, that the new name and the old one are connected to ptr_eq strings.\n-pub fn fresh_name(src: ast::Ident) -> ast::Name {\n-    with_ident_interner(|interner| interner.gensym_copy(src.name))\n-    // following: debug version. Could work in final except that it's incompatible with\n-    // good error messages and uses of struct names in ambiguous could-be-binding\n-    // locations. Also definitely destroys the guarantee given above about ptr_eq.\n-    /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n-    gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n-}"}, {"sha": "c28b9d00501b70fd6a989f27af86ad170873d3df", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,14 +19,15 @@ use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n use errors;\n-use parse::token::{self, keywords, BinOpToken, Token, InternedString};\n+use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, eof};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n+use symbol::{Symbol, keywords};\n use tokenstream::{self, TokenTree};\n \n use std::ascii;\n@@ -119,14 +120,13 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_list_word_item(InternedString::new(\"prelude_import\"));\n-        let list = attr::mk_list_item(InternedString::new(\"feature\"),\n-                                      vec![prelude_import_meta]);\n+        let prelude_import_meta = attr::mk_list_word_item(Symbol::intern(\"prelude_import\"));\n+        let list = attr::mk_list_item(Symbol::intern(\"feature\"), vec![prelude_import_meta]);\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n         try!(s.print_attribute(&fake_attr));\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(InternedString::new(\"no_std\"));\n+        let no_std_meta = attr::mk_word_item(Symbol::intern(\"no_std\"));\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), no_std_meta);\n         try!(s.print_attribute(&fake_attr));\n     }\n@@ -630,7 +630,7 @@ pub trait PrintState<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitKind::Str(ref st, style) => self.print_string(&st, style),\n+            ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n@@ -664,7 +664,7 @@ pub trait PrintState<'a> {\n                          &f,\n                          t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n+            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f.as_str()),\n             ast::LitKind::Bool(val) => {\n                 if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n             }\n@@ -727,7 +727,7 @@ pub trait PrintState<'a> {\n                               trailing_hardbreak: bool) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n-            if attr.node.style == kind {\n+            if attr.style == kind {\n                 try!(self.print_attribute_inline(attr, is_inline));\n                 if is_inline {\n                     try!(self.nbsp());\n@@ -751,11 +751,11 @@ pub trait PrintState<'a> {\n             try!(self.hardbreak_if_not_bol());\n         }\n         try!(self.maybe_print_comment(attr.span.lo));\n-        if attr.node.is_sugared_doc {\n-            try!(word(self.writer(), &attr.value_str().unwrap()));\n+        if attr.is_sugared_doc {\n+            try!(word(self.writer(), &attr.value_str().unwrap().as_str()));\n             hardbreak(self.writer())\n         } else {\n-            match attr.node.style {\n+            match attr.style {\n                 ast::AttrStyle::Inner => try!(word(self.writer(), \"#![\")),\n                 ast::AttrStyle::Outer => try!(word(self.writer(), \"#[\")),\n             }\n@@ -778,16 +778,16 @@ pub trait PrintState<'a> {\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match item.node {\n-            ast::MetaItemKind::Word(ref name) => {\n-                try!(word(self.writer(), &name));\n+            ast::MetaItemKind::Word => {\n+                try!(word(self.writer(), &item.name.as_str()));\n             }\n-            ast::MetaItemKind::NameValue(ref name, ref value) => {\n-                try!(self.word_space(&name[..]));\n+            ast::MetaItemKind::NameValue(ref value) => {\n+                try!(self.word_space(&item.name.as_str()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n-            ast::MetaItemKind::List(ref name, ref items) => {\n-                try!(word(self.writer(), &name));\n+            ast::MetaItemKind::List(ref items) => {\n+                try!(word(self.writer(), &item.name.as_str()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                               &items[..],\n@@ -2191,13 +2191,17 @@ impl<'a> State<'a> {\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, true))\n             }\n-            ast::ExprKind::Break(opt_ident) => {\n+            ast::ExprKind::Break(opt_ident, ref opt_expr) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident.node));\n                     try!(space(&mut self.s));\n                 }\n+                if let Some(ref expr) = *opt_expr {\n+                    try!(self.print_expr(expr));\n+                    try!(space(&mut self.s));\n+                }\n             }\n             ast::ExprKind::Continue(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n@@ -2220,19 +2224,18 @@ impl<'a> State<'a> {\n             ast::ExprKind::InlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n-                try!(self.print_string(&a.asm, a.asm_str_style));\n+                try!(self.print_string(&a.asm.as_str(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.outputs,\n-                                   |s, out| {\n-                    let mut ch = out.constraint.chars();\n+                try!(self.commasep(Inconsistent, &a.outputs, |s, out| {\n+                    let constraint = out.constraint.as_str();\n+                    let mut ch = constraint.chars();\n                     match ch.next() {\n                         Some('=') if out.is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked))\n                         }\n-                        _ => try!(s.print_string(&out.constraint,\n-                                            ast::StrStyle::Cooked))\n+                        _ => try!(s.print_string(&constraint, ast::StrStyle::Cooked))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&out.expr));\n@@ -2242,9 +2245,8 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.inputs,\n-                                   |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n+                try!(self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n+                    try!(s.print_string(&co.as_str(), ast::StrStyle::Cooked));\n                     try!(s.popen());\n                     try!(s.print_expr(&o));\n                     try!(s.pclose());\n@@ -2255,7 +2257,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers,\n                                    |s, co| {\n-                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n+                    try!(s.print_string(&co.as_str(), ast::StrStyle::Cooked));\n                     Ok(())\n                 }));\n \n@@ -3082,12 +3084,11 @@ mod tests {\n \n     use ast;\n     use codemap;\n-    use parse::token;\n     use syntax_pos;\n \n     #[test]\n     fn test_fun_to_string() {\n-        let abba_ident = token::str_to_ident(\"abba\");\n+        let abba_ident = ast::Ident::from_str(\"abba\");\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n@@ -3103,7 +3104,7 @@ mod tests {\n \n     #[test]\n     fn test_variant_to_string() {\n-        let ident = token::str_to_ident(\"principal_skinner\");\n+        let ident = ast::Ident::from_str(\"principal_skinner\");\n \n         let var = codemap::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n             name: ident,"}, {"sha": "6a291ad9c408a372ed1dbd9b7af1b8c59f9a0335", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -10,10 +10,10 @@\n \n use ast;\n use attr;\n+use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n-use parse::token::{intern, InternedString, keywords};\n-use parse::{token, ParseSess};\n+use parse::ParseSess;\n use ptr::P;\n \n /// Craft a span that will be ignored by the stability lint's\n@@ -23,7 +23,7 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"std_inject\")),\n+            format: MacroAttribute(Symbol::intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n@@ -53,37 +53,36 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         None => return krate,\n     };\n \n-    let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n+    let crate_name = Symbol::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n-                                        attr::mk_word_item(InternedString::new(\"macro_use\")))],\n+                                        attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),\n-        ident: token::str_to_ident(name),\n+        ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n         span: DUMMY_SP,\n     }));\n \n     let span = ignored_span(sess, DUMMY_SP);\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n-            node: ast::Attribute_ {\n-                style: ast::AttrStyle::Outer,\n-                value: P(ast::MetaItem {\n-                    node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n-                    span: span,\n-                }),\n-                id: attr::mk_attr_id(),\n-                is_sugared_doc: false,\n+            style: ast::AttrStyle::Outer,\n+            value: ast::MetaItem {\n+                name: Symbol::intern(\"prelude_import\"),\n+                node: ast::MetaItemKind::Word,\n+                span: span,\n             },\n+            id: attr::mk_attr_id(),\n+            is_sugared_doc: false,\n             span: span,\n         }],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n             segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n-                identifier: token::str_to_ident(name),\n+                identifier: ast::Ident::from_str(name),\n                 parameters: ast::PathParameters::none(),\n             }).collect(),\n             span: span,"}, {"sha": "fe9a176179ce67aebc42f13398c418b104c7f4cd", "filename": "src/libsyntax/symbol.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,303 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An \"interner\" is a data structure that associates values with usize tags and\n+//! allows bidirectional lookup; i.e. given a value, one can easily find the\n+//! type, and vice versa.\n+\n+use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::fmt;\n+\n+/// A symbol is an interned or gensymed string.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Symbol(u32);\n+\n+// The interner in thread-local, so `Symbol` shouldn't move between threads.\n+impl !Send for Symbol { }\n+\n+impl Symbol {\n+    /// Maps a string to its interned representation.\n+    pub fn intern(string: &str) -> Self {\n+        with_interner(|interner| interner.intern(string))\n+    }\n+\n+    /// gensym's a new usize, using the current interner.\n+    pub fn gensym(string: &str) -> Self {\n+        with_interner(|interner| interner.gensym(string))\n+    }\n+\n+    pub fn as_str(self) -> InternedString {\n+        with_interner(|interner| unsafe {\n+            InternedString {\n+                string: ::std::mem::transmute::<&str, &str>(interner.get(self))\n+            }\n+        })\n+    }\n+\n+    pub fn as_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Debug for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}({})\", self, self.0)\n+    }\n+}\n+\n+impl fmt::Display for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.as_str(), f)\n+    }\n+}\n+\n+impl Encodable for Symbol {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.as_str())\n+    }\n+}\n+\n+impl Decodable for Symbol {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Symbol, D::Error> {\n+        Ok(Symbol::intern(&d.read_str()?))\n+    }\n+}\n+\n+impl<'a> PartialEq<&'a str> for Symbol {\n+    fn eq(&self, other: &&str) -> bool {\n+        *self.as_str() == **other\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct Interner {\n+    names: HashMap<Box<str>, Symbol>,\n+    strings: Vec<Box<str>>,\n+}\n+\n+impl Interner {\n+    pub fn new() -> Self {\n+        Interner::default()\n+    }\n+\n+    fn prefill(init: &[&str]) -> Self {\n+        let mut this = Interner::new();\n+        for &string in init {\n+            this.intern(string);\n+        }\n+        this\n+    }\n+\n+    pub fn intern(&mut self, string: &str) -> Symbol {\n+        if let Some(&name) = self.names.get(string) {\n+            return name;\n+        }\n+\n+        let name = Symbol(self.strings.len() as u32);\n+        let string = string.to_string().into_boxed_str();\n+        self.strings.push(string.clone());\n+        self.names.insert(string, name);\n+        name\n+    }\n+\n+    fn gensym(&mut self, string: &str) -> Symbol {\n+        let gensym = Symbol(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        self.strings.push(string.to_string().into_boxed_str());\n+        gensym\n+    }\n+\n+    pub fn get(&self, name: Symbol) -> &str {\n+        &self.strings[name.0 as usize]\n+    }\n+}\n+\n+// In this macro, there is the requirement that the name (the number) must be monotonically\n+// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n+// except starting from the next number instead of zero.\n+macro_rules! declare_keywords {(\n+    $( ($index: expr, $konst: ident, $string: expr) )*\n+) => {\n+    pub mod keywords {\n+        use ast;\n+        #[derive(Clone, Copy, PartialEq, Eq)]\n+        pub struct Keyword {\n+            ident: ast::Ident,\n+        }\n+        impl Keyword {\n+            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n+            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n+        }\n+        $(\n+            #[allow(non_upper_case_globals)]\n+            pub const $konst: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n+            };\n+        )*\n+    }\n+\n+    impl Interner {\n+        fn fresh() -> Self {\n+            Interner::prefill(&[$($string,)*])\n+        }\n+    }\n+}}\n+\n+// NB: leaving holes in the ident table is bad! a different ident will get\n+// interned with the id from the hole, but it will be between the min and max\n+// of the reserved words, and thus tagged as \"reserved\".\n+// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// this should be rarely necessary though if the keywords are kept in alphabetic order.\n+declare_keywords! {\n+    // Invalid identifier\n+    (0,  Invalid,        \"\")\n+\n+    // Strict keywords used in the language.\n+    (1,  As,             \"as\")\n+    (2,  Box,            \"box\")\n+    (3,  Break,          \"break\")\n+    (4,  Const,          \"const\")\n+    (5,  Continue,       \"continue\")\n+    (6,  Crate,          \"crate\")\n+    (7,  Else,           \"else\")\n+    (8,  Enum,           \"enum\")\n+    (9,  Extern,         \"extern\")\n+    (10, False,          \"false\")\n+    (11, Fn,             \"fn\")\n+    (12, For,            \"for\")\n+    (13, If,             \"if\")\n+    (14, Impl,           \"impl\")\n+    (15, In,             \"in\")\n+    (16, Let,            \"let\")\n+    (17, Loop,           \"loop\")\n+    (18, Match,          \"match\")\n+    (19, Mod,            \"mod\")\n+    (20, Move,           \"move\")\n+    (21, Mut,            \"mut\")\n+    (22, Pub,            \"pub\")\n+    (23, Ref,            \"ref\")\n+    (24, Return,         \"return\")\n+    (25, SelfValue,      \"self\")\n+    (26, SelfType,       \"Self\")\n+    (27, Static,         \"static\")\n+    (28, Struct,         \"struct\")\n+    (29, Super,          \"super\")\n+    (30, Trait,          \"trait\")\n+    (31, True,           \"true\")\n+    (32, Type,           \"type\")\n+    (33, Unsafe,         \"unsafe\")\n+    (34, Use,            \"use\")\n+    (35, Where,          \"where\")\n+    (36, While,          \"while\")\n+\n+    // Keywords reserved for future use.\n+    (37, Abstract,       \"abstract\")\n+    (38, Alignof,        \"alignof\")\n+    (39, Become,         \"become\")\n+    (40, Do,             \"do\")\n+    (41, Final,          \"final\")\n+    (42, Macro,          \"macro\")\n+    (43, Offsetof,       \"offsetof\")\n+    (44, Override,       \"override\")\n+    (45, Priv,           \"priv\")\n+    (46, Proc,           \"proc\")\n+    (47, Pure,           \"pure\")\n+    (48, Sizeof,         \"sizeof\")\n+    (49, Typeof,         \"typeof\")\n+    (50, Unsized,        \"unsized\")\n+    (51, Virtual,        \"virtual\")\n+    (52, Yield,          \"yield\")\n+\n+    // Weak keywords, have special meaning only in specific contexts.\n+    (53, Default,        \"default\")\n+    (54, StaticLifetime, \"'static\")\n+    (55, Union,          \"union\")\n+}\n+\n+// If an interner exists in TLS, return it. Otherwise, prepare a fresh one.\n+fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n+    thread_local!(static INTERNER: RefCell<Interner> = {\n+        RefCell::new(Interner::fresh())\n+    });\n+    INTERNER.with(|interner| f(&mut *interner.borrow_mut()))\n+}\n+\n+/// Represents a string stored in the thread-local interner. Because the\n+/// interner lives for the life of the thread, this can be safely treated as an\n+/// immortal string, as long as it never crosses between threads.\n+///\n+/// FIXME(pcwalton): You must be careful about what you do in the destructors\n+/// of objects stored in TLS, because they may run after the interner is\n+/// destroyed. In particular, they must not access string contents. This can\n+/// be fixed in the future by just leaking all strings until thread death\n+/// somehow.\n+#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n+pub struct InternedString {\n+    string: &'static str,\n+}\n+\n+impl !Send for InternedString { }\n+\n+impl ::std::ops::Deref for InternedString {\n+    type Target = str;\n+    fn deref(&self) -> &str { self.string }\n+}\n+\n+impl fmt::Debug for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.string, f)\n+    }\n+}\n+\n+impl fmt::Display for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.string, f)\n+    }\n+}\n+\n+impl Decodable for InternedString {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n+        Ok(Symbol::intern(&d.read_str()?).as_str())\n+    }\n+}\n+\n+impl Encodable for InternedString {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(self.string)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ast::Name;\n+\n+    #[test]\n+    fn interner_tests() {\n+        let mut i: Interner = Interner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (\"dog\"), Name(0));\n+        // different string gets a different #:\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        // dog is still at zero\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n+        // gensym gets 3\n+        assert_eq!(i.gensym(\"zebra\"), Name(2));\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym(\"zebra\"), Name(3));\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym(\"dog\"), Name(4));\n+    }\n+}"}, {"sha": "4de3baf7d14fb27aaa240724903e35ecd2ab91a3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -34,21 +34,21 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use parse::token::{intern, keywords, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n-use ast;\n+use ast::{self, Ident};\n use ptr::P;\n+use symbol::{self, Symbol, keywords};\n use util::small_vector::SmallVector;\n \n enum ShouldPanic {\n     No,\n-    Yes(Option<InternedString>),\n+    Yes(Option<Symbol>),\n }\n \n struct Test {\n     span: Span,\n-    path: Vec<ast::Ident> ,\n+    path: Vec<Ident> ,\n     bench: bool,\n     ignore: bool,\n     should_panic: ShouldPanic\n@@ -57,14 +57,14 @@ struct Test {\n struct TestCtxt<'a> {\n     sess: &'a ParseSess,\n     span_diagnostic: &'a errors::Handler,\n-    path: Vec<ast::Ident>,\n+    path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n-    reexport_test_harness_main: Option<InternedString>,\n+    reexport_test_harness_main: Option<Symbol>,\n     is_test_crate: bool,\n \n     // top-level re-export submodule, filled out after folding is finished\n-    toplevel_reexport: Option<ast::Ident>,\n+    toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -91,10 +91,10 @@ pub fn modify_for_testing(sess: &ParseSess,\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n-    tests: Vec<ast::Ident>,\n+    tests: Vec<Ident>,\n \n     // submodule name, gensym'd identifier for re-exports\n-    tested_submods: Vec<(ast::Ident, ast::Ident)>,\n+    tested_submods: Vec<(Ident, Ident)>,\n }\n \n impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n@@ -191,8 +191,8 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n-                    let allow_str = InternedString::new(\"allow\");\n-                    let dead_code_str = InternedString::new(\"dead_code\");\n+                    let allow_str = Symbol::intern(\"allow\");\n+                    let dead_code_str = Symbol::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n                     let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n                     let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n@@ -222,15 +222,18 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n-fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident>,\n-                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n-    let super_ = token::str_to_ident(\"super\");\n+fn mk_reexport_mod(cx: &mut TestCtxt,\n+                   parent: ast::NodeId,\n+                   tests: Vec<Ident>,\n+                   tested_submods: Vec<(Ident, Ident)>)\n+                   -> (P<ast::Item>, Ident) {\n+    let super_ = Ident::from_str(\"super\");\n \n     // Generate imports with `#[allow(private_in_public)]` to work around issue #36768.\n     let allow_private_in_public = cx.ext_cx.attribute(DUMMY_SP, cx.ext_cx.meta_list(\n         DUMMY_SP,\n-        InternedString::new(\"allow\"),\n-        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, InternedString::new(\"private_in_public\"))],\n+        Symbol::intern(\"allow\"),\n+        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, Symbol::intern(\"private_in_public\"))],\n     ));\n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n@@ -247,7 +250,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n         items: items,\n     };\n \n-    let sym = token::gensym_ident(\"__test_reexports\");\n+    let sym = Ident::with_empty_ctxt(Symbol::gensym(\"__test_reexports\"));\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n@@ -264,7 +267,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n \n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut Resolver,\n-                         reexport_test_harness_main: Option<InternedString>,\n+                         reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n@@ -286,7 +289,7 @@ fn generate_test_harness(sess: &ParseSess,\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"test\")),\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: false,\n         }\n@@ -306,7 +309,7 @@ fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"test\")),\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n@@ -456,7 +459,7 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n-    let id_test = token::str_to_ident(\"test\");\n+    let id_test = Ident::from_str(\"test\");\n     let (vi, vis, ident) = if cx.is_test_crate {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n@@ -487,16 +490,17 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let ecx = &cx.ext_cx;\n \n     // test::test_main_static\n-    let test_main_path = ecx.path(sp, vec![token::str_to_ident(\"test\"),\n-                                           token::str_to_ident(\"test_main_static\")]);\n+    let test_main_path =\n+        ecx.path(sp, vec![Ident::from_str(\"test\"), Ident::from_str(\"test_main_static\")]);\n+\n     // test::test_main_static(...)\n     let test_main_path_expr = ecx.expr_path(test_main_path);\n-    let tests_ident_expr = ecx.expr_ident(sp, token::str_to_ident(\"TESTS\"));\n+    let tests_ident_expr = ecx.expr_ident(sp, Ident::from_str(\"TESTS\"));\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n                                        vec![tests_ident_expr]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n     // #![main]\n-    let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n+    let main_meta = ecx.meta_word(sp, Symbol::intern(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n@@ -506,7 +510,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n                            dummy_spanned(ast::Constness::NotConst),\n                            ::abi::Abi::Rust, ast::Generics::default(), main_body);\n     let main = P(ast::Item {\n-        ident: token::str_to_ident(\"main\"),\n+        ident: Ident::from_str(\"main\"),\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n@@ -533,7 +537,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemKind::Mod(testmod);\n-    let mod_ident = token::gensym_ident(\"__test\");\n+    let mod_ident = Ident::with_empty_ctxt(Symbol::gensym(\"__test\"));\n \n     let mut expander = cx.ext_cx.monotonic_expander();\n     let item = expander.fold_item(P(ast::Item {\n@@ -544,13 +548,13 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n     })).pop().unwrap();\n-    let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n+    let reexport = cx.reexport_test_harness_main.map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = token::str_to_ident(&s);\n+        let reexport_ident = Ident::with_empty_ctxt(s);\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n-                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n+                                       path_node(vec![mod_ident, Ident::from_str(\"main\")])));\n \n         expander.fold_item(P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n@@ -571,7 +575,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n     codemap::Spanned { node: t, span: DUMMY_SP }\n }\n \n-fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n+fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n@@ -582,7 +586,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn path_name_i(idents: &[ast::Ident]) -> String {\n+fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n }\n@@ -614,7 +618,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs) {\n-        Some(ref s) if \"test\" == &s[..] => true,\n+        Some(s) if \"test\" == &*s.as_str() => true,\n         _ => false\n     }\n }\n@@ -660,7 +664,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n \n     // path to the #[test] function: \"foo::bar::baz\"\n     let path_string = path_name_i(&path[..]);\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[..]));\n+    let name_expr = ecx.expr_str(span, Symbol::intern(&path_string));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,\n@@ -673,10 +677,10 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     };\n     let fail_expr = match test.should_panic {\n         ShouldPanic::No => ecx.expr_path(should_panic_path(\"No\")),\n-        ShouldPanic::Yes(ref msg) => {\n-            match *msg {\n-                Some(ref msg) => {\n-                    let msg = ecx.expr_str(span, msg.clone());\n+        ShouldPanic::Yes(msg) => {\n+            match msg {\n+                Some(msg) => {\n+                    let msg = ecx.expr_str(span, msg);\n                     let path = should_panic_path(\"YesWithMessage\");\n                     ecx.expr_call(span, ecx.expr_path(path), vec![msg])\n                 }"}, {"sha": "0d5dcaf339feb086f6dddabb627cf161cce958cb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -34,6 +34,7 @@ use parse::lexer;\n use parse;\n use parse::token::{self, Token, Lit, Nonterminal};\n use print::pprust;\n+use symbol::Symbol;\n \n use std::fmt;\n use std::iter::*;\n@@ -173,10 +174,10 @@ impl TokenTree {\n                 TokenTree::Delimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,\n-                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n+                    tts: vec![TokenTree::Token(sp, token::Ident(ast::Ident::from_str(\"doc\"))),\n                               TokenTree::Token(sp, token::Eq),\n                               TokenTree::Token(sp, token::Literal(\n-                                  token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n+                                  token::StrRaw(Symbol::intern(&stripped), num_of_hashes), None))],\n                     close_span: sp,\n                 }))\n             }\n@@ -295,15 +296,15 @@ impl TokenTree {\n     pub fn maybe_str(&self) -> Option<ast::Lit> {\n         match *self {\n             TokenTree::Token(sp, Token::Literal(Lit::Str_(s), _)) => {\n-                let l = LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                let l = LitKind::Str(Symbol::intern(&parse::str_lit(&s.as_str())),\n                                      ast::StrStyle::Cooked);\n                 Some(Spanned {\n                     node: l,\n                     span: sp,\n                 })\n             }\n             TokenTree::Token(sp, Token::Literal(Lit::StrRaw(s, n), _)) => {\n-                let l = LitKind::Str(token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                let l = LitKind::Str(Symbol::intern(&parse::raw_str_lit(&s.as_str())),\n                                      ast::StrStyle::Raw(n));\n                 Some(Spanned {\n                     node: l,\n@@ -871,8 +872,9 @@ impl Index<usize> for InternalTS {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use syntax::ast::Ident;\n     use syntax_pos::{Span, BytePos, NO_EXPANSION, DUMMY_SP};\n-    use parse::token::{self, str_to_ident, Token};\n+    use parse::token::{self, Token};\n     use util::parser_testing::string_to_tts;\n     use std::rc::Rc;\n \n@@ -967,15 +969,17 @@ mod tests {\n         let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()))\n             .slice(2..3);\n         let test_eqs = TokenStream::from_tts(vec![TokenTree::Token(sp(5,8),\n-                                                    token::Ident(str_to_ident(\"bar\")))]);\n+                                                    token::Ident(Ident::from_str(\"bar\")))]);\n         assert_eq!(test_res, test_eqs)\n     }\n \n     #[test]\n     fn test_is_empty() {\n         let test0 = TokenStream::from_tts(Vec::new());\n-        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),\n-                                                                Token::Ident(str_to_ident(\"a\")))]);\n+        let test1 = TokenStream::from_tts(\n+            vec![TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\")))]\n+        );\n+\n         let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n \n         assert_eq!(test0.is_empty(), true);\n@@ -1035,20 +1039,20 @@ mod tests {\n         assert_eq!(test0, None);\n \n         let test1_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                                        token::Ident(Ident::from_str(\"bar\"))),\n                                        TokenTree::Token(sp(4, 6), token::ModSep),\n                                        TokenTree::Token(sp(6, 9),\n-                                                        token::Ident(str_to_ident(\"baz\")))]);\n+                                                        token::Ident(Ident::from_str(\"baz\")))]);\n         assert_eq!(test1, Some(test1_expected));\n \n         let test2_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(str_to_ident(\"foo\"))),\n+                                                        token::Ident(Ident::from_str(\"foo\"))),\n                                        TokenTree::Token(sp(4, 5), token::Comma),\n                                        TokenTree::Token(sp(5, 8),\n-                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                                        token::Ident(Ident::from_str(\"bar\"))),\n                                        TokenTree::Token(sp(8, 9), token::Comma),\n                                        TokenTree::Token(sp(9, 12),\n-                                                        token::Ident(str_to_ident(\"baz\")))]);\n+                                                        token::Ident(Ident::from_str(\"baz\")))]);\n         assert_eq!(test2, Some(test2_expected));\n \n         assert_eq!(test3, None);\n@@ -1069,7 +1073,7 @@ mod tests {\n \n         assert_eq!(test0, None);\n         assert_eq!(test1, None);\n-        assert_eq!(test2, Some(str_to_ident(\"foo\")));\n+        assert_eq!(test2, Some(Ident::from_str(\"foo\")));\n         assert_eq!(test3, None);\n         assert_eq!(test4, None);\n     }\n@@ -1079,9 +1083,9 @@ mod tests {\n         let test0 = as_paren_delimited_stream(string_to_tts(\"foo,bar,\".to_string()));\n         let test1 = as_paren_delimited_stream(string_to_tts(\"baz(foo,bar)\".to_string()));\n \n-        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"foo\"))),\n+        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"foo\"))),\n                              TokenTree::Token(sp(3, 4), token::Comma),\n-                             TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"bar\"))),\n                              TokenTree::Token(sp(7, 8), token::Comma)];\n         let test0_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 8),\n                                                                Rc::new(Delimited {\n@@ -1094,11 +1098,11 @@ mod tests {\n         assert_eq!(test0, test0_stream);\n \n \n-        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"foo\"))),\n+        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"foo\"))),\n                              TokenTree::Token(sp(7, 8), token::Comma),\n-                             TokenTree::Token(sp(8, 11), token::Ident(str_to_ident(\"bar\")))];\n+                             TokenTree::Token(sp(8, 11), token::Ident(Ident::from_str(\"bar\")))];\n \n-        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"baz\"))),\n+        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"baz\"))),\n                                TokenTree::Delimited(sp(3, 12),\n                                                     Rc::new(Delimited {\n                                                         delim: token::DelimToken::Paren,"}, {"sha": "f56c6cedcd18678e4971d48d96b8392a0c6280a0", "filename": "src/libsyntax/util/interner.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An \"interner\" is a data structure that associates values with usize tags and\n-//! allows bidirectional lookup; i.e. given a value, one can easily find the\n-//! type, and vice versa.\n-\n-use ast::Name;\n-\n-use std::collections::HashMap;\n-use std::rc::Rc;\n-\n-#[derive(Default)]\n-pub struct Interner {\n-    names: HashMap<Rc<str>, Name>,\n-    strings: Vec<Rc<str>>,\n-}\n-\n-/// When traits can extend traits, we should extend index<Name,T> to get []\n-impl Interner {\n-    pub fn new() -> Self {\n-        Interner::default()\n-    }\n-\n-    pub fn prefill(init: &[&str]) -> Self {\n-        let mut this = Interner::new();\n-        for &string in init {\n-            this.intern(string);\n-        }\n-        this\n-    }\n-\n-    pub fn intern(&mut self, string: &str) -> Name {\n-        if let Some(&name) = self.names.get(string) {\n-            return name;\n-        }\n-\n-        let name = Name(self.strings.len() as u32);\n-        let string = Rc::__from_str(string);\n-        self.strings.push(string.clone());\n-        self.names.insert(string, name);\n-        name\n-    }\n-\n-    pub fn gensym(&mut self, string: &str) -> Name {\n-        let gensym = Name(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        self.strings.push(Rc::__from_str(string));\n-        gensym\n-    }\n-\n-    /// Create a gensym with the same name as an existing entry.\n-    pub fn gensym_copy(&mut self, name: Name) -> Name {\n-        let gensym = Name(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        let string = self.strings[name.0 as usize].clone();\n-        self.strings.push(string);\n-        gensym\n-    }\n-\n-    pub fn get(&self, name: Name) -> Rc<str> {\n-        self.strings[name.0 as usize].clone()\n-    }\n-\n-    pub fn find(&self, string: &str) -> Option<Name> {\n-        self.names.get(string).cloned()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ast::Name;\n-\n-    #[test]\n-    fn interner_tests() {\n-        let mut i: Interner = Interner::new();\n-        // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), Name(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), Name(2));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Name(3));\n-        // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Name(4));\n-        // gensym tests again with gensym_copy:\n-        assert_eq!(i.gensym_copy(Name(2)), Name(5));\n-        assert_eq!(&*i.get(Name(5)), \"zebra\");\n-        assert_eq!(i.gensym_copy(Name(2)), Name(6));\n-        assert_eq!(&*i.get(Name(6)), \"zebra\");\n-        assert_eq!(&*i.get(Name(0)), \"dog\");\n-        assert_eq!(&*i.get(Name(1)), \"cat\");\n-        assert_eq!(&*i.get(Name(2)), \"zebra\");\n-        assert_eq!(&*i.get(Name(3)), \"zebra\");\n-        assert_eq!(&*i.get(Name(4)), \"dog\");\n-    }\n-}"}, {"sha": "a6fff2d707469ffd2d4d1607dfb658b62b4a1139", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::Name;\n use std::cmp;\n-use parse::token::InternedString;\n+use symbol::Symbol;\n \n /// To find the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {\n@@ -48,14 +47,14 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n /// to one-third of the given word\n pub fn find_best_match_for_name<'a, T>(iter_names: T,\n                                        lookup: &str,\n-                                       dist: Option<usize>) -> Option<InternedString>\n-    where T: Iterator<Item = &'a Name> {\n+                                       dist: Option<usize>) -> Option<Symbol>\n+    where T: Iterator<Item = &'a Symbol> {\n     let max_dist = dist.map_or_else(|| cmp::max(lookup.len(), 3) / 3, |d| d);\n     iter_names\n-    .filter_map(|name| {\n+    .filter_map(|&name| {\n         let dist = lev_distance(lookup, &name.as_str());\n         match dist <= max_dist {    // filter the unwanted cases\n-            true => Some((name.as_str(), dist)),\n+            true => Some((name, dist)),\n             false => None,\n         }\n     })"}, {"sha": "ce24fe1eb61e241d6eee5830c982e01b49c20638", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use parse::token::{Token, BinOpToken, keywords};\n+use parse::token::{Token, BinOpToken};\n+use symbol::keywords;\n use ast::BinOpKind;\n \n /// Associative operator with precedence."}, {"sha": "e703dc6b4191c50f933fa82e98777eb9cbf189fe", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, Ident};\n use parse::{ParseSess,PResult,filemap_to_tts};\n use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n-use parse::token;\n use ptr::P;\n use tokenstream;\n use std::iter::Peekable;\n@@ -78,9 +77,9 @@ pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n     })\n }\n \n-/// Convert a vector of strings to a vector of ast::Ident's\n-pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n-    ids.iter().map(|u| token::str_to_ident(*u)).collect()\n+/// Convert a vector of strings to a vector of Ident's\n+pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<Ident> {\n+    ids.iter().map(|u| Ident::from_str(*u)).collect()\n }\n \n /// Does the given string match the pattern? whitespace in the first string"}, {"sha": "da36225fb329cdd17d51846e2b953a07abb82f6a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -746,7 +746,11 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_sp_ident) | ExprKind::Continue(ref opt_sp_ident) => {\n+        ExprKind::Break(ref opt_sp_ident, ref opt_expr) => {\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref opt_sp_ident) => {\n             walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Ret(ref optional_expression) => {"}, {"sha": "a5e083f926a07ad97184355a2604f2c73ee4726a", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -17,9 +17,9 @@ use syntax::codemap;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n-use syntax::parse::token::intern;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -73,7 +73,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n-    let mut asm = token::InternedString::new(\"\");\n+    let mut asm = Symbol::intern(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();\n@@ -135,11 +135,12 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let mut ch = constraint.chars();\n+                    let constraint_str = constraint.as_str();\n+                    let mut ch = constraint_str.chars();\n                     let output = match ch.next() {\n                         Some('=') => None,\n                         Some('+') => {\n-                            Some(token::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n+                            Some(Symbol::intern(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -148,9 +149,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     };\n \n                     let is_rw = output.is_some();\n-                    let is_indirect = constraint.contains(\"*\");\n+                    let is_indirect = constraint_str.contains(\"*\");\n                     outputs.push(ast::InlineAsmOutput {\n-                        constraint: output.unwrap_or(constraint.clone()),\n+                        constraint: output.unwrap_or(constraint),\n                         expr: out,\n                         is_rw: is_rw,\n                         is_indirect: is_indirect,\n@@ -166,9 +167,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     let (constraint, _str_style) = panictry!(p.parse_str());\n \n-                    if constraint.starts_with(\"=\") {\n+                    if constraint.as_str().starts_with(\"=\") {\n                         cx.span_err(p.prev_span, \"input operand constraint contains '='\");\n-                    } else if constraint.starts_with(\"+\") {\n+                    } else if constraint.as_str().starts_with(\"+\") {\n                         cx.span_err(p.prev_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -190,7 +191,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n-                    } else if s.starts_with(\"{\") || s.ends_with(\"}\") {\n+                    } else if s.as_str().starts_with(\"{\") || s.as_str().ends_with(\"}\") {\n                         cx.span_err(p.prev_span, \"clobber should not be surrounded by braces\");\n                     }\n \n@@ -242,7 +243,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     let expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: sp,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroBang(intern(\"asm\")),\n+            format: codemap::MacroBang(Symbol::intern(\"asm\")),\n             span: None,\n             allow_internal_unstable: false,\n         },\n@@ -251,7 +252,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n-            asm: token::intern_and_get_ident(&asm),\n+            asm: asm,\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "bfe18dc4060c929820c2a6c363bf213c84193846", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,7 +11,7 @@\n use syntax::ast;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n use syntax::tokenstream;\n \n@@ -33,7 +33,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitKind::Str(ref s, _) |\n                     ast::LitKind::Float(ref s, _) |\n                     ast::LitKind::FloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(&s);\n+                        accumulator.push_str(&s.as_str());\n                     }\n                     ast::LitKind::Char(c) => {\n                         accumulator.push(c);\n@@ -57,5 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MacEager::expr(cx.expr_str(sp, token::intern_and_get_ident(&accumulator[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "b26e33eb384dc0017fc942a16ec9e62e0bf9e6c7", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -13,7 +13,6 @@ use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::parse::token::str_to_ident;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n@@ -51,7 +50,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         }\n     }\n-    let res = str_to_ident(&res_str);\n+    let res = ast::Ident::from_str(&res_str);\n \n     struct Result {\n         ident: ast::Ident,"}, {"sha": "d14b59d6c70e2f20bdaa0dde1ab1706501c10e22", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -15,8 +15,8 @@ use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n@@ -74,7 +74,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "6ab5987a159cad3983df2818414950279f52523f", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,18 +14,18 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n-    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let hidden = cx.meta_list_item_word(span, Symbol::intern(\"hidden\"));\n+    let doc = cx.meta_list(span, Symbol::intern(\"doc\"), vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "9fc3d997585d711abfbc3fb2403a554c0bfc1deb", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,16 +14,16 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n                            push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "f2a050ce971edc76d414d9998ccfaa70d0a414f7", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,8 +14,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n@@ -64,7 +64,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n \n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,"}, {"sha": "ce4d549d696f4d344fb3f2e938f9e370db456fb8", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,8 +16,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n@@ -27,7 +27,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    push: &mut FnMut(Annotatable)) {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n@@ -51,7 +51,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                     vec![Box::new(ordering_ty)],\n                                     true));\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n \n     let partial_cmp_def = MethodDef {"}, {"sha": "1076a6a6d63a5bef4e90c8816dc9304af46c4b8d", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -17,10 +17,9 @@ use syntax::attr::{mark_used, mark_known};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::fold::Folder;\n-use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n \n-struct MarkAttrs<'a>(&'a [InternedString]);\n+struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n@@ -33,13 +32,11 @@ impl<'a> Visitor for MarkAttrs<'a> {\n \n pub struct CustomDerive {\n     inner: fn(TokenStream) -> TokenStream,\n-    attrs: Vec<InternedString>,\n+    attrs: Vec<ast::Name>,\n }\n \n impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream,\n-               attrs: Vec<InternedString>)\n-               -> CustomDerive {\n+    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> CustomDerive {\n         CustomDerive { inner: inner, attrs: attrs }\n     }\n }"}, {"sha": "a767716466cb15d13e1902ecccf1fa4a97a73064", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,11 +11,10 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -69,9 +68,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n     // We want to make sure we have the expn_id set so that we can use unstable methods\n     let span = Span { expn_id: cx.backtrace(), ..span };\n-    let name = cx.expr_lit(span,\n-                           ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n-    let builder = token::str_to_ident(\"builder\");\n+    let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n+    let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -83,7 +81,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n             if !is_struct {\n                 // tuple struct/\"normal\" variant\n                 let expr =\n-                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_tuple\"), vec![name]);\n+                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n@@ -93,7 +91,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n                     let expr = cx.expr_method_call(span,\n                                                    builder_expr.clone(),\n-                                                   token::str_to_ident(\"field\"),\n+                                                   Ident::from_str(\"field\"),\n                                                    vec![field]);\n \n                     // Use `let _ = expr;` to avoid triggering the\n@@ -103,20 +101,20 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n             } else {\n                 // normal struct/struct variant\n                 let expr =\n-                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_struct\"), vec![name]);\n+                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n                     let name = cx.expr_lit(field.span,\n-                                           ast::LitKind::Str(field.name.unwrap().name.as_str(),\n+                                           ast::LitKind::Str(field.name.unwrap().name,\n                                                              ast::StrStyle::Cooked));\n \n                     // Use double indirection to make sure this works for unsized types\n                     let field = cx.expr_addr_of(field.span, field.self_.clone());\n                     let field = cx.expr_addr_of(field.span, field);\n                     let expr = cx.expr_method_call(span,\n                                                    builder_expr.clone(),\n-                                                   token::str_to_ident(\"field\"),\n+                                                   Ident::from_str(\"field\"),\n                                                    vec![name, field]);\n                     stmts.push(stmt_let_undescore(cx, span, expr));\n                 }\n@@ -126,7 +124,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n         _ => unreachable!(),\n     };\n \n-    let expr = cx.expr_method_call(span, builder_expr, token::str_to_ident(\"finish\"), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "e2634c60dcaad0cd8f16ab3e824c8a54e8b7ccbb", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,9 +18,8 @@ use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n@@ -131,7 +130,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, nfields),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n@@ -143,7 +142,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span, ident.name.as_str()));\n+                variants.push(cx.expr_str(v_span, ident.name));\n \n                 let path = cx.path(trait_span, vec![substr.type_ident, ident]);\n                 let decoded = decode_static_fields(cx, v_span, path, parts, |cx, span, _, field| {\n@@ -175,7 +174,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n@@ -191,7 +190,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                            fields: &StaticFields,\n                            mut getarg: F)\n                            -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, Symbol, usize) -> P<Expr>\n {\n     match *fields {\n         Unnamed(ref fields, is_tuple) => {\n@@ -202,10 +201,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                 let fields = fields.iter()\n                     .enumerate()\n                     .map(|(i, &span)| {\n-                        getarg(cx,\n-                               span,\n-                               token::intern_and_get_ident(&format!(\"_field{}\", i)),\n-                               i)\n+                        getarg(cx, span, Symbol::intern(&format!(\"_field{}\", i)), i)\n                     })\n                     .collect();\n \n@@ -217,7 +213,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n             let fields = fields.iter()\n                 .enumerate()\n                 .map(|(i, &(ident, span))| {\n-                    let arg = getarg(cx, span, ident.name.as_str(), i);\n+                    let arg = getarg(cx, span, ident.name, i);\n                     cx.field_imm(span, ident, arg)\n                 })\n                 .collect();"}, {"sha": "69391f48c2288dd512119c79d23412b5423b53ba", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -14,16 +14,16 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n                                push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "092738ab8a03d372333f6272ae608e775cc9d617", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -95,8 +95,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n@@ -192,8 +192,8 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => id.name.as_str(),\n-                    None => token::intern_and_get_ident(&format!(\"_field{}\", i)),\n+                    Some(id) => id.name,\n+                    None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n@@ -226,7 +226,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, fields.len()),\n                                      blk])\n         }\n@@ -265,7 +265,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, variant.node.name.name.as_str());\n+            let name = cx.expr_str(trait_span, variant.node.name.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n@@ -277,8 +277,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          vec![cx.expr_str(trait_span,\n-                                                           substr.type_ident.name.as_str()),\n+                                          vec![cx.expr_str(trait_span ,substr.type_ident.name),\n                                                blk]);\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }"}, {"sha": "63cd7678321ef832686b8f68fe827d064e8839dd", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -198,8 +198,8 @@ use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, dummy_spanned, respan};\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{InternedString, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use errors::Handler;\n \n@@ -442,7 +442,7 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        match &a.name()[..] {\n+                        match &*a.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n                             _ => false,\n                         }\n@@ -639,15 +639,15 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(self.span,\n                                 cx.meta_word(self.span,\n-                                             InternedString::new(\"automatically_derived\")));\n+                                             Symbol::intern(\"automatically_derived\")));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let unused_qual = cx.attribute(self.span,\n-                                       cx.meta_list(self.span,\n-                                                    InternedString::new(\"allow\"),\n-                                                    vec![cx.meta_list_item_word(self.span,\n-                                           InternedString::new(\"unused_qualifications\"))]));\n+        let unused_qual = {\n+            let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n+            cx.attribute(self.span, cx.meta_list(self.span, Symbol::intern(\"allow\"), vec![word]))\n+        };\n+\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());\n "}, {"sha": "535d7de19e341aa5432f89d3a57512cd21f19f08", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,8 +16,8 @@ use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate::{self, emit_feature_err};\n-use syntax::parse::token::{intern, intern_and_get_ident};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n macro_rules! pathvec {\n@@ -80,7 +80,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n         expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(intern(attr_name)),\n+                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n             },\n@@ -105,17 +105,18 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         }\n     };\n \n+    let derive = Symbol::intern(\"derive\");\n     let mut derive_attrs = Vec::new();\n     item = item.map_attrs(|attrs| {\n-        let partition = attrs.into_iter().partition(|attr| &attr.name() == \"derive\");\n+        let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n         derive_attrs = partition.0;\n         partition.1\n     });\n \n     // Expand `#[derive]`s after other attribute macro invocations.\n     if cx.resolver.find_attr_invoc(&mut item.attrs.clone()).is_some() {\n         return vec![Annotatable::Item(item.map_attrs(|mut attrs| {\n-            attrs.push(cx.attribute(span, P(mitem.clone())));\n+            attrs.push(cx.attribute(span, mitem.clone()));\n             attrs.extend(derive_attrs);\n             attrs\n         }))];\n@@ -135,7 +136,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     let mut traits = get_traits(mitem, cx);\n     for derive_attr in derive_attrs {\n-        traits.extend(get_traits(&derive_attr.node.value, cx));\n+        traits.extend(get_traits(&derive_attr.value, cx));\n     }\n \n     // First, weed out malformed #[derive]\n@@ -158,9 +159,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         let tword = titem.word().unwrap();\n         let tname = tword.name();\n \n-        if is_builtin_trait(&tname) || {\n-            let derive_mode =\n-                ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(intern(&tname)));\n+        if is_builtin_trait(tname) || {\n+            let derive_mode = ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(tname));\n             cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n                 if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n             }).unwrap_or(false)\n@@ -176,7 +176,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                            feature_gate::EXPLAIN_CUSTOM_DERIVE);\n         } else {\n             cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n+            let name = Symbol::intern(&format!(\"derive_{}\", tname));\n             let mitem = cx.meta_word(titem.span, name);\n             new_attributes.push(cx.attribute(mitem.span, mitem));\n         }\n@@ -186,9 +186,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         item = item.map(|mut i| {\n             i.attrs.extend(new_attributes);\n             if traits.len() > 0 {\n-                let list = cx.meta_list(mitem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        traits);\n+                let list = cx.meta_list(mitem.span, derive, traits);\n                 i.attrs.push(cx.attribute(mitem.span, list));\n             }\n             i\n@@ -217,7 +215,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let macros_11_derive = traits.iter()\n                                  .cloned()\n                                  .enumerate()\n-                                 .filter(|&(_, ref name)| !is_builtin_trait(&name.name().unwrap()))\n+                                 .filter(|&(_, ref name)| !is_builtin_trait(name.name().unwrap()))\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n         if !cx.ecfg.features.unwrap().proc_macro {\n@@ -226,24 +224,20 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n             emit_feature_err(cx.parse_sess, \"proc_macro\", titem.span, issue, msg);\n         }\n \n-        let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n+        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n         let path = ast::Path::from_ident(titem.span, tname);\n         let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n \n         traits.remove(i);\n         if traits.len() > 0 {\n             item = item.map(|mut i| {\n-                let list = cx.meta_list(mitem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        traits);\n+                let list = cx.meta_list(mitem.span, derive, traits);\n                 i.attrs.push(cx.attribute(mitem.span, list));\n                 i\n             });\n         }\n         let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n-        let mitem = cx.meta_list(titem.span,\n-                                 intern_and_get_ident(\"derive\"),\n-                                 vec![titem]);\n+        let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n         let item = Annotatable::Item(item);\n         if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n             return ext.expand(cx, mitem.span, &mitem, item);\n@@ -257,9 +251,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n     // `#[structural_match]` attribute.\n-    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"PartialEq\") &&\n-       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Eq\") {\n-        let structural_match = intern_and_get_ident(\"structural_match\");\n+    let (partial_eq, eq) = (Symbol::intern(\"PartialEq\"), Symbol::intern(\"Eq\"));\n+    if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n+       traits.iter().any(|t| t.name() == Some(eq)) {\n+        let structural_match = Symbol::intern(\"structural_match\");\n         let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n         let meta = cx.meta_word(span, structural_match);\n         item = item.map(|mut i| {\n@@ -272,9 +267,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     // the same as the copy implementation.\n     //\n     // Add a marker attribute here picked up during #[derive(Clone)]\n-    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"Clone\") &&\n-       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Copy\") {\n-        let marker = intern_and_get_ident(\"rustc_copy_clone_marker\");\n+    let (copy, clone) = (Symbol::intern(\"Copy\"), Symbol::intern(\"Clone\"));\n+    if traits.iter().any(|t| t.name() == Some(clone)) &&\n+       traits.iter().any(|t| t.name() == Some(copy)) {\n+        let marker = Symbol::intern(\"rustc_copy_clone_marker\");\n         let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n         let meta = cx.meta_word(span, marker);\n         item = item.map(|mut i| {\n@@ -286,14 +282,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let mut items = Vec::new();\n     for titem in traits.iter() {\n         let tname = titem.word().unwrap().name();\n-        let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n+        let name = Symbol::intern(&format!(\"derive({})\", tname));\n         let mitem = cx.meta_word(titem.span, name);\n \n         let span = Span {\n             expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n                 call_site: titem.span,\n                 callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                    format: codemap::MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n                     span: Some(titem.span),\n                     allow_internal_unstable: true,\n                 },\n@@ -302,7 +298,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         };\n \n         let my_item = Annotatable::Item(item);\n-        expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n+        expand_builtin(&tname.as_str(), cx, span, &mitem, &my_item, &mut |a| {\n             items.push(a);\n         });\n         item = my_item.expect_item();\n@@ -314,8 +310,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n-        pub fn is_builtin_trait(name: &str) -> bool {\n-            match name {\n+        pub fn is_builtin_trait(name: ast::Name) -> bool {\n+            match &*name.as_str() {\n                 $( $name )|+ => true,\n                 _ => false,\n             }\n@@ -412,7 +408,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     span.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: span,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroAttribute(intern(\"derive\")),\n+            format: codemap::MacroAttribute(Symbol::intern(\"derive\")),\n             span: Some(span),\n             allow_internal_unstable: true,\n         },"}, {"sha": "ecf0a8f377ea3dc3c81f220cc3688020525778bf", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n@@ -32,7 +32,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some(v) => v,\n     };\n \n-    let e = match env::var(&var[..]) {\n+    let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n@@ -49,7 +49,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Ok(s) => {\n             cx.expr_call_global(sp,\n                                 cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n-                                vec![cx.expr_str(sp, token::intern_and_get_ident(&s[..]))])\n+                                vec![cx.expr_str(sp, Symbol::intern(&s))])\n         }\n     };\n     MacEager::expr(e)\n@@ -73,7 +73,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n-        None => token::intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n+        None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n@@ -87,12 +87,12 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let e = match env::var(&var[..]) {\n+    let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n-            cx.span_err(sp, &msg);\n+            cx.span_err(sp, &msg.as_str());\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s)),\n+        Ok(s) => cx.expr_str(sp, Symbol::intern(&s)),\n     };\n     MacEager::expr(e)\n }"}, {"sha": "d2afa08cadaf4efb40b16f32b46996a9078dc06a", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -17,8 +17,9 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n@@ -369,7 +370,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(&self.literal);\n+        let s = Symbol::intern(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -727,7 +728,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         fmtsp: fmt.span,\n     };\n \n-    let mut parser = parse::Parser::new(&fmt.node.0);\n+    let fmt_str = &*fmt.node.0.as_str();\n+    let mut parser = parse::Parser::new(fmt_str);\n     let mut pieces = vec![];\n \n     loop {\n@@ -808,7 +810,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         // Decide if we want to look for foreign formatting directives.\n         if args_used < args_unused {\n             use super::format_foreign as foreign;\n-            let fmt_str = &fmt.node.0[..];\n \n             // The set of foreign substitutions we've explained.  This prevents spamming the user\n             // with `%d should be written as {}` over and over again."}, {"sha": "e83fd55cd714bfe5032e593fd66e880d2d4b9040", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -53,7 +53,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n-use syntax::parse::token::intern;\n+use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n@@ -62,11 +62,11 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n+    register(Symbol::intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n \n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(intern(stringify!($name)),\n+            register(Symbol::intern(stringify!($name)),\n                      NormalTT(Box::new($f as MacroExpanderFn), None, false));\n         )* }\n     }\n@@ -112,9 +112,10 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     }\n \n     // format_args uses `unstable` things internally.\n-    register(intern(\"format_args\"), NormalTT(Box::new(format::expand_format_args), None, true));\n+    register(Symbol::intern(\"format_args\"),\n+             NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n+    register(Symbol::intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "bbdbda701ae8eba464d48f88f7a9f6b9e33e8d16", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -17,20 +17,20 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::parse::ParseSess;\n-use syntax::parse::token::{self, InternedString};\n use syntax::feature_gate::Features;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n \n use deriving;\n \n struct CustomDerive {\n-    trait_name: InternedString,\n+    trait_name: ast::Name,\n     function_name: Ident,\n     span: Span,\n-    attrs: Vec<InternedString>,\n+    attrs: Vec<ast::Name>,\n }\n \n struct CollectCustomDerives<'a> {\n@@ -183,7 +183,7 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n             self.handler.span_err(trait_attr.span(), \"must only be one word\");\n         }\n \n-        if deriving::is_builtin_trait(&trait_name) {\n+        if deriving::is_builtin_trait(trait_name) {\n             self.handler.span_err(trait_attr.span(),\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n@@ -271,29 +271,29 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(token::intern(\"proc_macro\")),\n+            format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n     });\n     let span = Span { expn_id: eid, ..DUMMY_SP };\n \n-    let proc_macro = token::str_to_ident(\"proc_macro\");\n+    let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let __internal = token::str_to_ident(\"__internal\");\n-    let registry = token::str_to_ident(\"Registry\");\n-    let registrar = token::str_to_ident(\"registrar\");\n-    let register_custom_derive = token::str_to_ident(\"register_custom_derive\");\n+    let __internal = Ident::from_str(\"__internal\");\n+    let registry = Ident::from_str(\"Registry\");\n+    let registrar = Ident::from_str(\"registrar\");\n+    let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n-        let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n+        let trait_name = cx.expr_str(cd.span, cd.trait_name);\n         let attrs = cx.expr_vec_slice(\n             span,\n-            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.clone())).collect::<Vec<_>>()\n+            cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n         );\n         (path, trait_name, attrs)\n     }).map(|(path, trait_name, attrs)| {\n@@ -316,15 +316,14 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                           cx.ty(span, ast::TyKind::Tup(Vec::new())),\n                           cx.block(span, stmts));\n \n-    let derive_registrar = token::intern_and_get_ident(\"rustc_derive_registrar\");\n-    let derive_registrar = cx.meta_word(span, derive_registrar);\n+    let derive_registrar = cx.meta_word(span, Symbol::intern(\"rustc_derive_registrar\"));\n     let derive_registrar = cx.attribute(span, derive_registrar);\n     let func = func.map(|mut i| {\n         i.attrs.push(derive_registrar);\n         i.vis = ast::Visibility::Public;\n         i\n     });\n-    let ident = ast::Ident::with_empty_ctxt(token::gensym(\"registrar\"));\n+    let ident = ast::Ident::with_empty_ctxt(Symbol::gensym(\"registrar\"));\n     let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n         i.vis = ast::Visibility::Public;\n         i"}, {"sha": "48be8e0c53c2ed2c41363da6e7c843efb8053135", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,7 +11,7 @@\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base;\n use syntax::feature_gate;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n "}, {"sha": "70f7ee3004dd437a74832efc6e9b72c7abdf245c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -22,6 +22,9 @@\n #include \"llvm/Target/TargetSubtargetInfo.h\"\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n \n+#if LLVM_VERSION_GE(4, 0)\n+#include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n+#endif\n \n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n@@ -539,7 +542,11 @@ LLVMRustPrintPasses() {\n \n extern \"C\" void\n LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n+#if LLVM_VERSION_GE(4, 0)\n+    unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n+#else\n     unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n+#endif\n }\n \n extern \"C\" void"}, {"sha": "b035e134e37d52abedff817571f0f6e362991de8", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -155,13 +155,10 @@ from_rust(LLVMRustAttribute kind) {\n   }\n }\n \n-extern \"C\" LLVMAttributeRef LLVMRustCreateAttribute(LLVMContextRef C, LLVMRustAttribute Kind, uint64_t Val) {\n-  return wrap(Attribute::get(*unwrap(C), from_rust(Kind), Val));\n-}\n-\n-extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, LLVMAttributeRef attr) {\n+extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, LLVMRustAttribute attr) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n-  AttrBuilder B(unwrap(attr));\n+  Attribute Attr = Attribute::get(Call->getContext(), from_rust(attr));\n+  AttrBuilder B(Attr);\n   Call.setAttributes(\n     Call.getAttributes().addAttributes(Call->getContext(), index,\n                                        AttributeSet::get(Call->getContext(),\n@@ -183,10 +180,11 @@ extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n \n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn,\n \t\t\t\t\t     unsigned index,\n-\t\t\t\t\t     LLVMAttributeRef attr)\n+\t\t\t\t\t     LLVMRustAttribute attr)\n {\n   Function *A = unwrap<Function>(Fn);\n-  AttrBuilder B(unwrap(attr));\n+  Attribute Attr = Attribute::get(A->getContext(), from_rust(attr));\n+  AttrBuilder B(Attr);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n@@ -212,11 +210,12 @@ extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n \n extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n \t\t\t\t\t\t unsigned index,\n-\t\t\t\t\t\t LLVMAttributeRef attr)\n+\t\t\t\t\t\t LLVMRustAttribute attr)\n {\n   Function *F = unwrap<Function>(Fn);\n   const AttributeSet PAL = F->getAttributes();\n-  AttrBuilder B(unwrap(attr));\n+  Attribute Attr = Attribute::get(F->getContext(), from_rust(attr));\n+  AttrBuilder B(Attr);\n   const AttributeSet PALnew =\n     PAL.removeAttributes(F->getContext(), index,\n                          AttributeSet::get(F->getContext(), index, B));"}, {"sha": "8647797270f9a841f5092b974faf0ec745509cbb", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "dc88bfc40595f4401da5db5c86f16c2eede12ccd", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,8 +19,9 @@ extern crate rustc_plugin;\n \n use syntax::ast::{self, Item, MetaItem, ItemKind};\n use syntax::ext::base::*;\n-use syntax::parse::{self, token};\n+use syntax::parse;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n@@ -34,11 +35,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        token::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        token::intern(\"duplicate\"),\n+        Symbol::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n }\n@@ -102,9 +103,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n-        ast::MetaItemKind::List(_, ref xs) => {\n+        ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                token::str_to_ident(&word.name())\n+                ast::Ident::with_empty_ctxt(word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "8acab3369e48fb3ef3ba71b3c45160eaf2750970", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,8 +16,8 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::parse;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -30,7 +30,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "9ec09603224107bf298f2e2e282c852cfff6f5d7", "filename": "src/test/compile-fail/E0088.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2FE0088.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2FE0088.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0088.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -9,7 +9,12 @@\n // except according to those terms.\n \n fn f() {}\n+fn g<'a>() {}\n \n fn main() {\n     f::<'static>(); //~ ERROR E0088\n+    //~^ unexpected lifetime parameter\n+\n+    g::<'static, 'static>(); //~ ERROR E0088\n+    //~^ unexpected lifetime parameters\n }"}, {"sha": "29b139d771b0deebe0fa6054f8059831bee9fc3b", "filename": "src/test/compile-fail/auxiliary/namespace-mix-old.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: Remove when `item_like_imports` is stabilized.\n-\n-pub mod c {\n-    pub struct S {}\n-    pub struct TS();\n-    pub struct US;\n-    pub enum E {\n-        V {},\n-        TV(),\n-        UV,\n-    }\n-\n-    pub struct Item;\n-}\n-\n-pub mod proxy {\n-    pub use c::*;\n-    pub use c::E::*;\n-}\n-\n-pub mod xm1 {\n-    pub use ::proxy::*;\n-    pub type S = ::c::Item;\n-}\n-pub mod xm2 {\n-    pub use ::proxy::*;\n-    pub const S: ::c::Item = ::c::Item;\n-}\n-\n-pub mod xm3 {\n-    pub use ::proxy::*;\n-    pub type TS = ::c::Item;\n-}\n-pub mod xm4 {\n-    pub use ::proxy::*;\n-    pub const TS: ::c::Item = ::c::Item;\n-}\n-\n-pub mod xm5 {\n-    pub use ::proxy::*;\n-    pub type US = ::c::Item;\n-}\n-pub mod xm6 {\n-    pub use ::proxy::*;\n-    pub const US: ::c::Item = ::c::Item;\n-}\n-\n-pub mod xm7 {\n-    pub use ::proxy::*;\n-    pub type V = ::c::Item;\n-}\n-pub mod xm8 {\n-    pub use ::proxy::*;\n-    pub const V: ::c::Item = ::c::Item;\n-}\n-\n-pub mod xm9 {\n-    pub use ::proxy::*;\n-    pub type TV = ::c::Item;\n-}\n-pub mod xmA {\n-    pub use ::proxy::*;\n-    pub const TV: ::c::Item = ::c::Item;\n-}\n-\n-pub mod xmB {\n-    pub use ::proxy::*;\n-    pub type UV = ::c::Item;\n-}\n-pub mod xmC {\n-    pub use ::proxy::*;\n-    pub const UV: ::c::Item = ::c::Item;\n-}"}, {"sha": "d82e9bb7022839b251017326536bf308d72fa51c", "filename": "src/test/compile-fail/auxiliary/namespace-mix.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(item_like_imports)]\n-\n pub mod c {\n     pub struct S {}\n     pub struct TS();", "previous_filename": "src/test/compile-fail/auxiliary/namespace-mix-new.rs"}, {"sha": "7bd1a96f452d83a53c47aaeb4cbe7a397c08b466", "filename": "src/test/compile-fail/auxiliary/rmeta_meta.rs", "status": "renamed", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_meta.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that import shadowing using globs causes errors\n+// no-prefer-dynamic\n \n-#![no_implicit_prelude]\n+#![crate_type=\"metadata\"]\n \n-use qux::*;\n-use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n-\n-mod foo {\n-    pub type Baz = isize;\n-}\n-\n-mod bar {\n-    pub type Baz = isize;\n+pub struct Foo {\n+    pub field: i32,\n }\n-\n-mod qux {\n-    pub use bar::Baz;\n-}\n-\n-fn main() {}", "previous_filename": "src/test/compile-fail/import-shadow-6.rs"}, {"sha": "6096c4df05bb0349d8961399905c4294ce4c1798", "filename": "src/test/compile-fail/auxiliary/rmeta_rlib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_rlib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub struct Foo {\n+    pub field: i32,\n+}"}, {"sha": "75e3426a399359ff32c9d5f4748bb9d5c5cc7973", "filename": "src/test/compile-fail/directory_ownership/backcompat-warnings.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fbackcompat-warnings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fbackcompat-warnings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fbackcompat-warnings.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:issue_12612_1.rs\n+// error-pattern: cannot declare a new module at this location\n+// error-pattern: will become a hard error\n+// error-pattern: compilation successful\n \n-extern crate issue_12612_1 as foo;\n+#![feature(rustc_attrs)]\n \n-use foo::bar;\n-\n-mod test {\n-    use bar::foo; //~ ERROR unresolved import `bar::foo` [E0432]\n-                  //~^ Maybe a missing `extern crate bar;`?\n-}\n+#[path=\"mod_file_not_owning_aux3.rs\"]\n+mod foo;\n \n+#[rustc_error]\n fn main() {}", "previous_filename": "src/test/compile-fail/issue-12612.rs"}, {"sha": "8e631a64f7a27c0978fb35e18cb11ca88bcd4526", "filename": "src/test/compile-fail/directory_ownership/macro-expanded-mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "previous_filename": "src/test/compile-fail/macro-expanded-mod.rs"}, {"sha": "3ec34362da559d6c99ec9cfe801fbc1837ad2630", "filename": "src/test/compile-fail/directory_ownership/macro_expanded_mod_helper/foo/bar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fbar.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "previous_filename": "src/test/compile-fail/macro_expanded_mod_helper/foo/bar.rs"}, {"sha": "25fcf11ce175b3637aac9654d86f89721a20e84d", "filename": "src/test/compile-fail/directory_ownership/macro_expanded_mod_helper/foo/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fmod.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "previous_filename": "src/test/compile-fail/macro_expanded_mod_helper/foo/mod.rs"}, {"sha": "adbcedd91f205ffe69d7f57099540a4a76cadb8a", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n // error-pattern: cannot declare a new module at this location\n \n mod mod_file_not_owning_aux1;", "previous_filename": "src/test/compile-fail/mod_file_not_owning.rs"}, {"sha": "4ac94a92e376c52e8e1487197d8fc73f087f41d2", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning_aux1.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux1.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -10,4 +10,7 @@\n \n // ignore-test this is not a test\n \n-mod mod_file_not_owning_aux2;\n+macro_rules! m {\n+    () => { mod mod_file_not_owning_aux2; }\n+}\n+m!();", "previous_filename": "src/test/compile-fail/mod_file_not_owning_aux1.rs"}, {"sha": "41401d640f6242aa2ae5dd985a3d2a5236b79774", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning_aux2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux2.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "previous_filename": "src/test/compile-fail/mod_file_not_owning_aux2.rs"}, {"sha": "3a164fd55d92702a01dbe8c6d7befdd3ca823b17", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning_aux3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux3.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test this is not a test\n+\n+mod mod_file_not_owning_aux2;"}, {"sha": "c4ede12e8208277d5a7dd272442ac3fa4ca774cd", "filename": "src/test/compile-fail/directory_ownership/non-inline-mod-restriction.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "previous_filename": "src/test/compile-fail/non-inline-mod-restriction.rs"}, {"sha": "854f790befcf7b5917d19f5f931840f717777928", "filename": "src/test/compile-fail/directory_ownership/unowned_mod_with_path.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Funowned_mod_with_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Funowned_mod_with_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Funowned_mod_with_path.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot declare a new module at this location\n+\n+// This is not a directory owner since the file name is not \"mod.rs\".\n+#[path = \"mod_file_not_owning_aux1.rs\"]\n+mod foo;"}, {"sha": "1632c40d59fdf0fbc67c599d045ff1ee5d40d7ab", "filename": "src/test/compile-fail/feature-gate-loop-break-value.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Ffeature-gate-loop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Ffeature-gate-loop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-loop-break-value.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    loop {\n+        break 123; //~ ERROR `break` with a value is experimental\n+    }\n+}"}, {"sha": "8f1b8ec91db38aafa4b79e74ebe7cbb89a71387e", "filename": "src/test/compile-fail/glob-cycles.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fglob-cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fglob-cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fglob-cycles.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,19 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n mod foo {\n     pub use bar::*;\n-    pub use main as f; //~ ERROR has already been imported\n+    pub use main as f;\n }\n \n mod bar {\n     pub use foo::*;\n }\n \n pub use foo::*;\n-pub use baz::*; //~ ERROR has already been imported\n+pub use baz::*;\n mod baz {\n     pub use super::*;\n }\n \n-pub fn main() {}\n+#[rustc_error]\n+pub fn main() {} //~ ERROR compilation successful"}, {"sha": "dc300bc7baa7705823103a9f7c2f37382eb8399a", "filename": "src/test/compile-fail/import-shadow-5.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that import shadowing using globs causes errors\n-\n-#![no_implicit_prelude]\n-\n-use foo::Baz;\n-use bar::Baz; //~ERROR a type named `Baz` has already been imported in this module\n-\n-mod foo {\n-    pub type Baz = isize;\n-}\n-\n-mod bar {\n-    pub type Baz = isize;\n-}\n-\n-mod qux {\n-    pub use bar::Baz;\n-}\n-\n-fn main() {}"}, {"sha": "34aba15b3922892d781b5b15545ec9f39115f10e", "filename": "src/test/compile-fail/import-shadow-7.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that import shadowing using globs causes errors\n-\n-#![no_implicit_prelude]\n-\n-use foo::*;\n-use qux::*; //~ERROR a type named `Baz` has already been imported in this module\n-\n-mod foo {\n-    pub type Baz = isize;\n-}\n-\n-mod bar {\n-    pub type Baz = isize;\n-}\n-\n-mod qux {\n-    pub use bar::Baz;\n-}\n-\n-fn main() {}"}, {"sha": "81a5334ed7ab7675867ad8c184784b12d72095c6", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -20,6 +20,6 @@ mod zed {\n }\n \n fn main() {\n-    zed::foo(); //~ ERROR unresolved name\n+    zed::foo(); //~ ERROR `foo` is private\n     bar();\n }"}, {"sha": "8dd69d8c24c855afc267e983199f09e1ed103675", "filename": "src/test/compile-fail/imports/duplicate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(item_like_imports)]\n-\n mod a {\n     pub fn foo() {}\n }"}, {"sha": "65e6e8d01b05f119c6bd6de43eb287c5ed4df57c", "filename": "src/test/compile-fail/imports/reexports.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimports%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimports%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Freexports.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(item_like_imports)]\n-\n mod a {\n     fn foo() {}\n     mod foo {}"}, {"sha": "05ecc781af30d53b22689e613d3ab4ca74eb8351", "filename": "src/test/compile-fail/imports/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimports%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fimports%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Funused.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(pub_restricted, item_like_imports)]\n+#![feature(pub_restricted)]\n #![deny(unused)]\n \n mod foo {"}, {"sha": "2c54ed3e857e93130c5456b62fd54417b7214945", "filename": "src/test/compile-fail/issue-32797.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fissue-32797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fissue-32797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32797.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n pub use bar::*;\n mod bar {\n     pub use super::*;\n }\n \n-pub use baz::*; //~ ERROR already been imported\n+pub use baz::*;\n mod baz {\n     pub use main as f;\n }\n \n-pub fn main() {}\n+#[rustc_error]\n+pub fn main() {} //~ ERROR compilation successful"}, {"sha": "41383e93603d36cd3b12921a95c3f774b9535900", "filename": "src/test/compile-fail/issue-32833.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fissue-32833.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fissue-32833.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32833.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -11,8 +11,7 @@\n use bar::Foo; //~ ERROR unresolved import `bar::Foo` [E0432]\n               //~^ no `Foo` in `bar`\n mod bar {\n-    use Foo; //~ ERROR unresolved import `Foo` [E0432]\n-             //~^ no `Foo` in the root\n+    use Foo;\n }\n \n fn main() {}"}, {"sha": "d4f29597486983038dee9b9f870e1be8fbb53df5", "filename": "src/test/compile-fail/loop-break-value.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(loop_break_value)]\n+#![feature(never_type)]\n+\n+fn main() {\n+    let val: ! = loop { break break; };\n+    //~^ ERROR mismatched types\n+\n+    loop {\n+        if true {\n+            break \"asdf\";\n+        } else {\n+            break 123; //~ ERROR mismatched types\n+        }\n+    };\n+\n+    let _: i32 = loop {\n+        break \"asdf\"; //~ ERROR mismatched types\n+    };\n+\n+    let _: i32 = 'outer_loop: loop {\n+        loop {\n+            break 'outer_loop \"nope\"; //~ ERROR mismatched types\n+            break \"ok\";\n+        };\n+    };\n+\n+    'while_loop: while true {\n+        break;\n+        break (); //~ ERROR `break` with value from a `while` loop\n+        loop {\n+            break 'while_loop 123;\n+            //~^ ERROR `break` with value from a `while` loop\n+            //~| ERROR mismatched types\n+            break 456;\n+            break 789;\n+        };\n+    }\n+\n+    'while_let_loop: while let Some(_) = Some(()) {\n+        if break () { //~ ERROR `break` with value from a `while let` loop\n+            break;\n+            break None;\n+            //~^ ERROR `break` with value from a `while let` loop\n+            //~| ERROR mismatched types\n+        }\n+        loop {\n+            break 'while_let_loop \"nope\";\n+            //~^ ERROR `break` with value from a `while let` loop\n+            //~| ERROR mismatched types\n+            break 33;\n+        };\n+    }\n+\n+    'for_loop: for _ in &[1,2,3] {\n+        break (); //~ ERROR `break` with value from a `for` loop\n+        break [()];\n+        //~^ ERROR `break` with value from a `for` loop\n+        //~| ERROR mismatched types\n+        loop {\n+            break Some(3);\n+            break 'for_loop Some(17);\n+            //~^ ERROR `break` with value from a `for` loop\n+            //~| ERROR mismatched types\n+        };\n+    }\n+\n+    let _: i32 = 'a: loop {\n+        let _: () = 'b: loop {\n+            break ('c: loop {\n+                break;\n+                break 'c 123; //~ ERROR mismatched types\n+            });\n+            break 'a 123;\n+        };\n+    };\n+\n+    loop {\n+        break (break, break); //~ ERROR mismatched types\n+    };\n+\n+    loop {\n+        break;\n+        break 2; //~ ERROR mismatched types\n+    };\n+\n+    loop {\n+        break 2;\n+        break; //~ ERROR mismatched types\n+        break 4;\n+    };\n+}"}, {"sha": "8cd82050814a001674d250edccb542fddc0e3b18", "filename": "src/test/compile-fail/namespace-mix-old.rs", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2029fc62d744e252a5a077ce0dfbf2d1683d25/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs?ref=ae2029fc62d744e252a5a077ce0dfbf2d1683d25", "patch": "@@ -1,172 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: Remove when `item_like_imports` is stabilized.\n-\n-// aux-build:namespace-mix-old.rs\n-\n-extern crate namespace_mix_old;\n-use namespace_mix_old::{xm1, xm2, xm3, xm4, xm5, xm6, xm7, xm8, xm9, xmA, xmB, xmC};\n-\n-mod c {\n-    pub struct S {}\n-    pub struct TS();\n-    pub struct US;\n-    pub enum E {\n-        V {},\n-        TV(),\n-        UV,\n-    }\n-\n-    pub struct Item;\n-}\n-\n-mod proxy {\n-    pub use c::*;\n-    pub use c::E::*;\n-}\n-\n-// Use something emitting the type argument name, e.g. unsatisfied bound.\n-trait Impossible {}\n-fn check<T: Impossible>(_: T) {}\n-\n-mod m1 {\n-    pub use ::proxy::*;\n-    pub type S = ::c::Item;\n-}\n-mod m2 {\n-    pub use ::proxy::*;\n-    pub const S: ::c::Item = ::c::Item;\n-}\n-\n-fn f12() {\n-    check(m1::S{}); //~ ERROR c::Item\n-    check(m1::S); //~ ERROR unresolved name\n-    check(m2::S{}); //~ ERROR c::S\n-    check(m2::S); //~ ERROR c::Item\n-}\n-fn xf12() {\n-    check(xm1::S{}); //~ ERROR c::Item\n-    check(xm1::S); //~ ERROR unresolved name\n-    check(xm2::S{}); //~ ERROR c::S\n-    check(xm2::S); //~ ERROR c::Item\n-}\n-\n-mod m3 {\n-    pub use ::proxy::*;\n-    pub type TS = ::c::Item;\n-}\n-mod m4 {\n-    pub use ::proxy::*;\n-    pub const TS: ::c::Item = ::c::Item;\n-}\n-\n-fn f34() {\n-    check(m3::TS{}); //~ ERROR c::Item\n-    check(m3::TS); //~ ERROR c::TS\n-    check(m4::TS{}); //~ ERROR c::TS\n-    check(m4::TS); //~ ERROR c::Item\n-}\n-fn xf34() {\n-    check(xm3::TS{}); //~ ERROR c::Item\n-    check(xm3::TS); //~ ERROR c::TS\n-    check(xm4::TS{}); //~ ERROR c::TS\n-    check(xm4::TS); //~ ERROR c::Item\n-}\n-\n-mod m5 {\n-    pub use ::proxy::*;\n-    pub type US = ::c::Item;\n-}\n-mod m6 {\n-    pub use ::proxy::*;\n-    pub const US: ::c::Item = ::c::Item;\n-}\n-\n-fn f56() {\n-    check(m5::US{}); //~ ERROR c::Item\n-    check(m5::US); //~ ERROR c::US\n-    check(m6::US{}); //~ ERROR c::US\n-    check(m6::US); //~ ERROR c::Item\n-}\n-fn xf56() {\n-    check(xm5::US{}); //~ ERROR c::Item\n-    check(xm5::US); //~ ERROR c::US\n-    check(xm6::US{}); //~ ERROR c::US\n-    check(xm6::US); //~ ERROR c::Item\n-}\n-\n-mod m7 {\n-    pub use ::proxy::*;\n-    pub type V = ::c::Item;\n-}\n-mod m8 {\n-    pub use ::proxy::*;\n-    pub const V: ::c::Item = ::c::Item;\n-}\n-\n-fn f78() {\n-    check(m7::V{}); //~ ERROR c::Item\n-    check(m7::V); //~ ERROR name of a struct or struct variant\n-    check(m8::V{}); //~ ERROR c::E\n-    check(m8::V); //~ ERROR c::Item\n-}\n-fn xf78() {\n-    check(xm7::V{}); //~ ERROR c::Item\n-    check(xm7::V); //~ ERROR name of a struct or struct variant\n-    check(xm8::V{}); //~ ERROR c::E\n-    check(xm8::V); //~ ERROR c::Item\n-}\n-\n-mod m9 {\n-    pub use ::proxy::*;\n-    pub type TV = ::c::Item;\n-}\n-mod mA {\n-    pub use ::proxy::*;\n-    pub const TV: ::c::Item = ::c::Item;\n-}\n-\n-fn f9A() {\n-    check(m9::TV{}); //~ ERROR c::Item\n-    check(m9::TV); //~ ERROR c::E\n-    check(mA::TV{}); //~ ERROR c::E\n-    check(mA::TV); //~ ERROR c::Item\n-}\n-fn xf9A() {\n-    check(xm9::TV{}); //~ ERROR c::Item\n-    check(xm9::TV); //~ ERROR c::E\n-    check(xmA::TV{}); //~ ERROR c::E\n-    check(xmA::TV); //~ ERROR c::Item\n-}\n-\n-mod mB {\n-    pub use ::proxy::*;\n-    pub type UV = ::c::Item;\n-}\n-mod mC {\n-    pub use ::proxy::*;\n-    pub const UV: ::c::Item = ::c::Item;\n-}\n-\n-fn fBC() {\n-    check(mB::UV{}); //~ ERROR c::Item\n-    check(mB::UV); //~ ERROR c::E\n-    check(mC::UV{}); //~ ERROR c::E\n-    check(mC::UV); //~ ERROR c::Item\n-}\n-fn xfBC() {\n-    check(xmB::UV{}); //~ ERROR c::Item\n-    check(xmB::UV); //~ ERROR c::E\n-    check(xmC::UV{}); //~ ERROR c::E\n-    check(xmC::UV); //~ ERROR c::Item\n-}\n-\n-fn main() {}"}, {"sha": "cb7894b726f46f597e60d1a102302a6c8ec375c2", "filename": "src/test/compile-fail/namespace-mix.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fnamespace-mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fnamespace-mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:namespace-mix-new.rs\n+// aux-build:namespace-mix.rs\n \n-#![feature(item_like_imports)]\n-\n-extern crate namespace_mix_new;\n-use namespace_mix_new::*;\n+extern crate namespace_mix;\n+use namespace_mix::*;\n \n mod c {\n     pub struct S {}", "previous_filename": "src/test/compile-fail/namespace-mix-new.rs"}, {"sha": "113dd2879406892e60fa0938d6e433b76393b258", "filename": "src/test/compile-fail/privacy2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -31,8 +31,7 @@ fn test1() {\n \n fn test2() {\n     use bar::glob::foo;\n-    //~^ ERROR unresolved import `bar::glob::foo` [E0432]\n-    //~| no `foo` in `bar::glob`\n+    //~^ ERROR `foo` is private\n }\n \n #[start] fn main(_: isize, _: *const *const u8) -> isize { 3 }"}, {"sha": "f2ac37a2ce9f597925d07daa1bde884abc3ca770", "filename": "src/test/compile-fail/rmeta-lib-pass.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta-lib-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta-lib-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta-lib-pass.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rmeta_rlib.rs\n+// no-prefer-dynamic\n+// must-compile-successfully\n+\n+// Check that building a metadata crate works with a dependent, rlib crate.\n+// This is a cfail test since there is no executable to run.\n+\n+#![crate_type=\"metadata\"]\n+\n+extern crate rmeta_rlib;\n+use rmeta_rlib::Foo;\n+\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n+}"}, {"sha": "2c0b6f77c1e08114d0239f36fac1192e5f71d86f", "filename": "src/test/compile-fail/rmeta-pass.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta-pass.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rmeta_meta.rs\n+// no-prefer-dynamic\n+// must-compile-successfully\n+\n+// Check that building a metadata crate works with a dependent, metadata-only\n+// crate.\n+// This is a cfail test since there is no executable to run.\n+\n+#![crate_type=\"metadata\"]\n+\n+extern crate rmeta_meta;\n+use rmeta_meta::Foo;\n+\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n+}"}, {"sha": "e81e0541096d62c9bca728ef0101907600fcd8ac", "filename": "src/test/compile-fail/rmeta.rs", "status": "renamed", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that import shadowing using globs causes errors\n+// no-prefer-dynamic\n \n-#![no_implicit_prelude]\n+// Check that building a metadata crate finds an error.\n \n-use foo::*;\n-use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n+#![crate_type=\"metadata\"]\n \n-mod foo {\n-    pub type Baz = isize;\n+fn main() {\n+    let _ = Foo; //~ ERROR unresolved name `Foo`\n }\n-\n-mod bar {\n-    pub type Baz = isize;\n-}\n-\n-mod qux {\n-    pub use bar::Baz;\n-}\n-\n-fn main() {}", "previous_filename": "src/test/compile-fail/import-shadow-2.rs"}, {"sha": "3b7d1f3cc904ac2ff37e52c5588a935bf6c27d29", "filename": "src/test/compile-fail/rmeta_lib.rs", "status": "renamed", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that import shadowing using globs causes errors\n+// aux-build:rmeta_meta.rs\n+// no-prefer-dynamic\n+// error-pattern: crate `rmeta_meta` required to be available in rlib, but it was not available\n \n-#![no_implicit_prelude]\n+// Check that building a non-metadata crate fails if a dependent crate is\n+// metadata-only.\n \n-use foo::Baz;\n-use bar::*; //~ERROR a type named `Baz` has already been imported in this module\n+extern crate rmeta_meta;\n+use rmeta_meta::Foo;\n \n-mod foo {\n-    pub type Baz = isize;\n+fn main() {\n+    let _ = Foo { field: 42 };\n }\n-\n-mod bar {\n-    pub type Baz = isize;\n-}\n-\n-mod qux {\n-    pub use bar::Baz;\n-}\n-\n-fn main() {}", "previous_filename": "src/test/compile-fail/import-shadow-3.rs"}, {"sha": "1c922c281397a8f45102c2d64a909a2819b05000", "filename": "src/test/compile-fail/rmeta_meta_main.rs", "status": "renamed", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta_meta_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Frmeta_meta_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta_meta_main.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that import shadowing using globs causes errors\n+// aux-build:rmeta_meta.rs\n+// no-prefer-dynamic\n \n-#![no_implicit_prelude]\n+// Check that building a metadata crate finds an error with a dependent,\n+// metadata-only crate.\n \n-use foo::*;\n-use bar::Baz; //~ERROR a type named `Baz` has already been imported in this module\n+#![crate_type=\"metadata\"]\n \n-mod foo {\n-    pub type Baz = isize;\n-}\n-\n-mod bar {\n-    pub type Baz = isize;\n-}\n+extern crate rmeta_meta;\n+use rmeta_meta::Foo;\n \n-mod qux {\n-    pub use bar::Baz;\n+fn main() {\n+    let _ = Foo { field2: 42 }; //~ ERROR struct `rmeta_meta::Foo` has no field named `field2`\n }\n-\n-fn main() {}", "previous_filename": "src/test/compile-fail/import-shadow-4.rs"}, {"sha": "e7e57a73de02f7176fa6d6a8a70b77114489a29d", "filename": "src/test/compile-fail/shadowed-use-visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,11 +16,11 @@ mod foo {\n }\n \n mod bar {\n-    use foo::bar::f as g; //~ ERROR unresolved import\n+    use foo::bar::f as g; //~ ERROR module `bar` is private\n \n     use foo as f;\n     pub use foo::*;\n }\n \n-use bar::f::f; //~ ERROR unresolved import\n+use bar::f::f; //~ ERROR module `f` is private\n fn main() {}"}, {"sha": "44e9260770e03ccfe83441c2b83b1dc32566310b", "filename": "src/test/compile-fail/variant-namespacing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fvariant-namespacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fcompile-fail%2Fvariant-namespacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariant-namespacing.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -31,11 +31,11 @@ const XTuple: u8 = 0;\n const XUnit: u8 = 0;\n \n extern crate variant_namespacing;\n-pub use variant_namespacing::XE::*;\n+pub use variant_namespacing::XE::{XStruct, XTuple, XUnit};\n //~^ ERROR `XStruct` has already been defined\n //~| ERROR `XTuple` has already been defined\n //~| ERROR `XUnit` has already been defined\n-pub use E::*;\n+pub use E::{Struct, Tuple, Unit};\n //~^ ERROR `Struct` has already been defined\n //~| ERROR `Tuple` has already been defined\n //~| ERROR `Unit` has already been defined"}, {"sha": "261eb38a51aebee089915408fd61f716ff28c0fc", "filename": "src/test/incremental/change_add_field/struct_point.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change a type definition by adding a field.  Fns with\n+// this type in their signature are recompiled, as are their callers.\n+// Fns with that type used only in their body are also recompiled, but\n+// their callers are not.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(static_in_const)]\n+#![allow(dead_code)]\n+\n+// These are expected to require translation.\n+#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_with_type_in_sig\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-call_fn_with_type_in_sig\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_with_type_in_body\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+#![rustc_partition_reused(module=\"struct_point-call_fn_with_type_in_body\", cfg=\"rpass2\")]\n+\n+mod point {\n+    #[cfg(rpass1)]\n+    pub struct Point {\n+        pub x: f32,\n+        pub y: f32,\n+    }\n+\n+    #[cfg(rpass2)]\n+    pub struct Point {\n+        pub x: f32,\n+        pub y: f32,\n+        pub z: f32,\n+    }\n+\n+    impl Point {\n+        pub fn origin() -> Point {\n+            #[cfg(rpass1)]\n+            return Point { x: 0.0, y: 0.0 };\n+\n+            #[cfg(rpass2)]\n+            return Point { x: 0.0, y: 0.0, z: 0.0 };\n+        }\n+\n+        pub fn total(&self) -> f32 {\n+            #[cfg(rpass1)]\n+            return self.x + self.y;\n+\n+            #[cfg(rpass2)]\n+            return self.x + self.y + self.z;\n+        }\n+\n+        pub fn x(&self) -> f32 {\n+            self.x\n+        }\n+    }\n+}\n+\n+/// A fn that has the changed type in its signature; must currently be\n+/// rebuilt.\n+///\n+/// You could imagine that, in the future, if the change were\n+/// sufficiently \"private\", we might not need to type-check again.\n+/// Rebuilding is probably always necessary since the layout may be\n+/// affected.\n+mod fn_with_type_in_sig {\n+    use point::Point;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn boop(p: Option<&Point>) -> f32 {\n+        p.map(|p| p.total()).unwrap_or(0.0)\n+    }\n+}\n+\n+/// Call a fn that has the changed type in its signature; this\n+/// currently must also be rebuilt.\n+///\n+/// You could imagine that, in the future, if the change were\n+/// sufficiently \"private\", we might not need to type-check again.\n+/// Rebuilding is probably always necessary since the layout may be\n+/// affected.\n+mod call_fn_with_type_in_sig {\n+    use fn_with_type_in_sig;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn bip() -> f32 {\n+        fn_with_type_in_sig::boop(None)\n+    }\n+}\n+\n+/// A fn that uses the changed type, but only in its body, not its\n+/// signature.\n+///\n+/// You could imagine that, in the future, if the change were\n+/// sufficiently \"private\", we might not need to type-check again.\n+/// Rebuilding is probably always necessary since the layout may be\n+/// affected.\n+mod fn_with_type_in_body {\n+    use point::Point;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn boop() -> f32 {\n+        Point::origin().total()\n+    }\n+}\n+\n+/// A fn X that calls a fn Y, where Y uses the changed type in its\n+/// body. In this case, the effects of the change should be contained\n+/// to Y; X should not have to be rebuilt, nor should it need to be\n+/// typechecked again.\n+mod call_fn_with_type_in_body {\n+    use fn_with_type_in_body;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn bip() -> f32 {\n+        fn_with_type_in_body::boop()\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin(p: Point) -> Point {\n+        Point { ..p }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "665eafb4f4eeb66fcd3310a506b575c4f163374a", "filename": "src/test/incremental/change_pub_inherent_method_body/struct_point.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change the body of a public, inherent method.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![allow(dead_code)]\n+\n+#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n+\n+// FIXME(#35078) -- this gets recompiled because we don't separate sig from body\n+#![rustc_partition_translated(module=\"struct_point-fn_calls_changed_method\", cfg=\"rpass2\")]\n+\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_another_method\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+mod point {\n+    pub struct Point {\n+        pub x: f32,\n+        pub y: f32,\n+    }\n+\n+    impl Point {\n+        pub fn distance_from_origin(&self) -> f32 {\n+            #[cfg(rpass1)]\n+            return self.x * self.x + self.y * self.y;\n+\n+            #[cfg(rpass2)]\n+            return (self.x * self.x + self.y * self.y).sqrt();\n+        }\n+\n+        pub fn x(&self) -> f32 {\n+            self.x\n+        }\n+    }\n+}\n+\n+/// A fn item that calls the method on `Point` which changed\n+mod fn_calls_changed_method {\n+    use point::Point;\n+\n+    // FIXME(#35078) -- this gets recompiled because we don't separate sig from body\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let p = Point { x: 2.0, y: 2.0 };\n+        p.distance_from_origin();\n+    }\n+}\n+\n+/// A fn item that calls a method on `Point` which did not change\n+mod fn_calls_another_method {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let p = Point { x: 2.0, y: 2.0 };\n+        p.x();\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "54e06e16998cdfa92aee3af600d622d243c0c30e", "filename": "src/test/incremental/change_pub_inherent_method_sig/struct_point.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change the *signature* of a public, inherent method.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(static_in_const)]\n+#![allow(dead_code)]\n+\n+// These are expected to require translation.\n+#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_calls_changed_method\", cfg=\"rpass2\")]\n+\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_another_method\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+mod point {\n+    pub struct Point {\n+        pub x: f32,\n+        pub y: f32,\n+    }\n+\n+    impl Point {\n+        #[cfg(rpass1)]\n+        pub fn distance_from_point(&self, p: Option<Point>) -> f32 {\n+            let p = p.unwrap_or(Point { x: 0.0, y: 0.0 });\n+            let x_diff = self.x - p.x;\n+            let y_diff = self.y - p.y;\n+            return x_diff * x_diff + y_diff * y_diff;\n+        }\n+\n+        #[cfg(rpass2)]\n+        pub fn distance_from_point(&self, p: Option<&Point>) -> f32 {\n+            const ORIGIN: &Point = &Point { x: 0.0, y: 0.0 };\n+            let p = p.unwrap_or(ORIGIN);\n+            let x_diff = self.x - p.x;\n+            let y_diff = self.y - p.y;\n+            return x_diff * x_diff + y_diff * y_diff;\n+        }\n+\n+        pub fn x(&self) -> f32 {\n+            self.x\n+        }\n+    }\n+}\n+\n+/// A fn item that calls the method that was changed\n+mod fn_calls_changed_method {\n+    use point::Point;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let p = Point { x: 2.0, y: 2.0 };\n+        p.distance_from_point(None);\n+    }\n+}\n+\n+/// A fn item that calls a method that was not changed\n+mod fn_calls_another_method {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let p = Point { x: 2.0, y: 2.0 };\n+        p.x();\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "7a8502f7caab188498da846377ff91dc3f1e8909", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,306 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `for` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change iteration variable name ----------------------------------------------\n+#[cfg(cfail1)]\n+fn change_iteration_variable_name() {\n+    let mut _x = 0;\n+    for _i in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_iteration_variable_name() {\n+    let mut _x = 0;\n+    for _a in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change iteration variable pattern -------------------------------------------\n+#[cfg(cfail1)]\n+fn change_iteration_variable_pattern() {\n+    let mut _x = 0;\n+    for _i in &[0, 1, 2] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_iteration_variable_pattern() {\n+    let mut _x = 0;\n+    for &_i in &[0, 1, 2] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change iterable -------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_iterable() {\n+    let mut _x = 0;\n+    for _ in &[0, 1, 2] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_iterable() {\n+    let mut _x = 0;\n+    for _ in &[0, 1, 3] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "eaa5f68b98c4bcc8fa256ee0a5e60b4e9b0e446c", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `loop` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "405645bd1b842311fe4c4c923710ef36d5490e9e", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `while let` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while let Some(1u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "f16611ee463e0f9d0c99d72bd65f315d9db4e99b", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `while` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while false {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "092adbf29e340cd52394c00e169fdb4dd746544f", "filename": "src/test/parse-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:expected `]`\n+// error-pattern:expected one of `=` or `]`\n \n // asterisk is bogus\n #[attr*]"}, {"sha": "94770aa875b4258b04cc336e54fdcf11ad688d8e", "filename": "src/test/parse-fail/circular_modules_hello.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fparse-fail%2Fcircular_modules_hello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Fparse-fail%2Fcircular_modules_hello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fcircular_modules_hello.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -12,6 +12,7 @@\n \n // ignore-test: this is an auxiliary file for circular-modules-main.rs\n \n+#[path = \"circular_modules_main.rs\"]\n mod circular_modules_main;\n \n pub fn say_hello() {"}, {"sha": "d692bb519c149ec33c24269302f268505e24f507", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -19,8 +19,8 @@ extern crate syntax_pos;\n \n use syntax::ast;\n use syntax::codemap;\n-use syntax::parse;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -33,7 +33,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "0336fe277c51f8eb6f064d6e248d1f0d00e26653", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -25,6 +25,7 @@ use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n \n+use std::collections::HashSet;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n@@ -65,7 +66,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n-    let cfg = build_configuration(&sess, vec![]);\n+    let cfg = build_configuration(&sess, HashSet::new());\n     let control = CompileController::basic();\n     let input = Input::Str { name: anon_src(), input: code };\n     compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);"}, {"sha": "27b69baf97787b794b246d27c0df5c4e4db99f50", "filename": "src/test/run-make/issue-37893/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-37893%2FMakefile?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,4 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) a.rs && $(RUSTC) b.rs && $(RUSTC) c.rs"}, {"sha": "3dff45388c75bf212d29ad9ce1600e8205024b30", "filename": "src/test/run-make/issue-37893/a.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-37893%2Fa.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(proc_macro)]\n+#![allow(unused)]\n+#![crate_type = \"proc-macro\"]"}, {"sha": "82f48f6d8d667094e44426d9a7ae4caac2e41dbe", "filename": "src/test/run-make/issue-37893/b.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-37893%2Fb.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub mod bar {\n-    pub fn foo() {}\n-}\n+#![crate_type = \"lib\"]\n+#[macro_use] extern crate a;", "previous_filename": "src/test/compile-fail/auxiliary/issue_12612_1.rs"}, {"sha": "eee55cc23696651e1ea95a51d4b1435644b62640", "filename": "src/test/run-make/issue-37893/c.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-make%2Fissue-37893%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-37893%2Fc.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"staticlib\"]\n+extern crate b;\n+extern crate a;"}, {"sha": "664bb9da89a5765fa19fb4dd4a94f3f5930dcd06", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_noprelude_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -20,10 +20,10 @@ extern crate syntax;\n \n use proc_macro_tokens::build::ident_eq;\n \n+use syntax::ast::Ident;\n use syntax::ext::base::{ExtCtxt, MacResult};\n use syntax::ext::proc_macro_shim::build_block_emitter;\n use syntax::tokenstream::{TokenTree, TokenStream};\n-use syntax::parse::token::str_to_ident;\n use syntax::codemap::Span;\n \n use rustc_plugin::Registry;\n@@ -57,7 +57,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "31a5f5968bab6addf652bb73bf1a9fb834826497", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::Ident;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::ext::proc_macro_shim::build_block_emitter;\n use syntax::ext::base::{ExtCtxt, MacResult};\n-use syntax::parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+use syntax::parse::token::{self, Token, DelimToken};\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n #[plugin_registrar]\n@@ -58,7 +58,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "6a2d159a4bdd96e774025f72df238e7ddac836ae", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_prelude_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -52,7 +52,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "63dbd4d5bed047a7ffe0039210a0e49c5ffe2f1d", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n \n-#![feature(plugin_registrar, rustc_private, item_like_imports)]\n+#![feature(plugin_registrar, rustc_private)]\n \n extern crate syntax;\n extern crate syntax_ext;\n@@ -25,12 +25,12 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{intern, InternedString};\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(intern(\"derive_CustomPartialEq\"),\n+    reg.register_syntax_extension(Symbol::intern(\"derive_CustomPartialEq\"),\n                                   MultiDecorator(Box::new(expand_deriving_partial_eq)));\n }\n \n@@ -52,7 +52,7 @@ fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, it\n                 substr)\n     }\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let methods = vec![MethodDef {\n         name: \"eq\","}, {"sha": "07f7d6bad7bf2b40967b8830f4bdc380dafcd0cc", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_plugin;\n use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;\n@@ -32,7 +32,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        token::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n \n@@ -66,7 +66,7 @@ fn expand(cx: &mut ExtCtxt,\n                             |cx, span, subexpr, field, _| {\n                                 cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n                                     cx.expr_method_call(span, field,\n-                                        token::str_to_ident(\"total_sum\"), vec![]))\n+                                        ast::Ident::from_str(\"total_sum\"), vec![]))\n                             },\n                             zero,\n                             box |cx, span, _, _| { cx.span_bug(span, \"wtf??\"); },"}, {"sha": "50b16a0e26fb49b79a951e0b8d019a73e5012aa9", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_plugin;\n use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n@@ -34,7 +34,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        token::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n "}, {"sha": "8647797270f9a841f5092b974faf0ec745509cbb", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "29cc6b7db94741c4b44b1f0b5e66a65cea1a5b0a", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -23,6 +23,7 @@ use syntax::ext::base::*;\n use syntax::ext::quote::rt::ToTokens;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n@@ -36,15 +37,15 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        token::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        token::intern(\"duplicate\"),\n+        Symbol::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n     reg.register_syntax_extension(\n-        token::intern(\"caller\"),\n+        Symbol::intern(\"caller\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_caller)));\n }\n@@ -108,9 +109,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     it: &Annotatable,\n                     push: &mut FnMut(Annotatable)) {\n     let copy_name = match mi.node {\n-        ast::MetaItemKind::List(_, ref xs) => {\n+        ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                token::str_to_ident(&word.name())\n+                ast::Ident::with_empty_ctxt(word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;\n@@ -179,7 +180,7 @@ fn expand_caller(cx: &mut ExtCtxt,\n         }\n \n         let fn_name = match list[0].name() {\n-            Some(name) => token::str_to_ident(&name),\n+            Some(name) => ast::Ident::with_empty_ctxt(name),\n             None => cx.span_fatal(list[0].span(), \"First parameter must be an ident.\")\n         };\n "}, {"sha": "ba2af77cdb297f75c2cbc2e6e66c6ee08c4031d3", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -22,9 +22,9 @@ use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT};\n-use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n use rustc_plugin::Registry;\n@@ -40,15 +40,14 @@ impl TTMacroExpander for Expander {\n                    _: &[tokenstream::TokenTree]) -> Box<MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n-        let interned = token::intern_and_get_ident(&args[..]);\n-        MacEager::expr(ecx.expr_str(sp, interned))\n+        MacEager::expr(ecx.expr_str(sp, Symbol::intern(&args)))\n     }\n }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n-    reg.register_syntax_extension(token::intern(\"plugin_args\"),\n+    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         NormalTT(Box::new(Expander { args: args, }), None, false));\n }"}, {"sha": "f97fb04aadf6ab2149c47be89aaaa677d9e54f0a", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,18 +18,19 @@ use proc_macro_tokens::prelude::*;\n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::proc_macro_shim::prelude::*;\n+use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(token::intern(\"attr_tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"attr_tru\"),\n                                   SyntaxExtension::AttrProcMacro(Box::new(attr_tru)));\n-    reg.register_syntax_extension(token::intern(\"attr_identity\"),\n+    reg.register_syntax_extension(Symbol::intern(\"attr_identity\"),\n                                   SyntaxExtension::AttrProcMacro(Box::new(attr_identity)));\n-    reg.register_syntax_extension(token::intern(\"tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"tru\"),\n                                   SyntaxExtension::ProcMacro(Box::new(tru)));\n-    reg.register_syntax_extension(token::intern(\"ret_tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"ret_tru\"),\n                                   SyntaxExtension::ProcMacro(Box::new(ret_tru)));\n-    reg.register_syntax_extension(token::intern(\"identity\"),\n+    reg.register_syntax_extension(Symbol::intern(\"identity\"),\n                                   SyntaxExtension::ProcMacro(Box::new(identity)));\n }\n "}, {"sha": "2b3857048f36732acc33f5c524aa8cd6f7fa978c", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,8 +18,8 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::parse::token::{str_to_ident, NtExpr, NtPat};\n-use syntax::ast::{Pat};\n+use syntax::parse::token::{NtExpr, NtPat};\n+use syntax::ast::{Ident, Pat};\n use syntax::tokenstream::{TokenTree};\n use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::ext::build::AstBuilder;\n@@ -44,12 +44,12 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         }\n     };\n \n-    let matched_nt = match *map[&str_to_ident(\"matched\")] {\n+    let matched_nt = match *map[&Ident::from_str(\"matched\")] {\n         MatchedNonterminal(ref nt) => nt.clone(),\n         _ => unreachable!(),\n     };\n \n-    let mac_expr = match (&*matched_nt, &*map[&str_to_ident(\"pat\")]) {\n+    let mac_expr = match (&*matched_nt, &*map[&Ident::from_str(\"pat\")]) {\n         (&NtExpr(ref matched_expr), &MatchedSeq(ref pats, seq_sp)) => {\n             let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt| {\n                 match **pat_nt {"}, {"sha": "948b20c14771fa48aaf5c60d9e09366daaf75263", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -18,9 +18,6 @@ extern crate proc_macro_tokens;\n use proc_macro_tokens::prelude::*;\n \n extern crate syntax;\n-use syntax::ast::Ident;\n-use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token::{self, Token, keywords, str_to_ident};\n \n fn main() {\n     let lex_true = lex(\"true\");"}, {"sha": "b4ed57192ccf69647015b18639b858c7d7d574df", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::print::pprust::*;\n-use syntax::parse::token::intern;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -29,7 +29,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }\n@@ -97,7 +97,7 @@ fn main() {\n     // quote_meta_item!\n \n     let meta = quote_meta_item!(cx, cfg(foo = \"bar\"));\n-    check!(meta_item_to_string, meta, *quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n+    check!(meta_item_to_string, meta, quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n \n     let attr = quote_attr!(cx, #![$meta]);\n     check!(attribute_to_string, attr; r#\"#![cfg(foo = \"bar\")]\"#);"}, {"sha": "28c11315fa1cd2f247350109e8695ddefdf82b27", "filename": "src/test/run-pass/auxiliary/rmeta_rlib.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"rlib\"]\n+#![crate_name=\"rmeta_aux\"]\n+\n+pub struct Foo {\n+    pub field: i32,\n+}"}, {"sha": "394845b66f3d3a105694589464d879349d60096a", "filename": "src/test/run-pass/auxiliary/rmeta_rmeta.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"metadata\"]\n+#![crate_name=\"rmeta_aux\"]\n+\n+pub struct Foo {\n+    pub field2: i32,\n+}"}, {"sha": "f845a2ee571622b699ce35054b0480f63d14177d", "filename": "src/test/run-pass/imports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimports.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(item_like_imports)]\n #![allow(unused)]\n \n // Like other items, private imports can be imported and used non-lexically in paths."}, {"sha": "6a5e051c0c7322d72c18a136b0bca887e537b871", "filename": "src/test/run-pass/loop-break-value.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-break-value.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(loop_break_value)]\n+#![feature(never_type)]\n+\n+#[allow(unused)]\n+fn never_returns() {\n+    loop {\n+        break loop {};\n+    }\n+}\n+\n+pub fn main() {\n+    let value = 'outer: loop {\n+        if 1 == 1 {\n+            break 13;\n+        } else {\n+            let _never: ! = loop {\n+                break loop {\n+                    break 'outer panic!();\n+                }\n+            };\n+        }\n+    };\n+    assert_eq!(value, 13);\n+\n+    let x = [1, 3u32, 5];\n+    let y = [17];\n+    let z = [];\n+    let coerced: &[_] = loop {\n+        match 2 {\n+            1 => break &x,\n+            2 => break &y,\n+            3 => break &z,\n+            _ => (),\n+        }\n+    };\n+    assert_eq!(coerced, &[17u32]);\n+\n+    let trait_unified = loop {\n+        break if true {\n+            break Default::default()\n+        } else {\n+            break [13, 14]\n+        };\n+    };\n+    assert_eq!(trait_unified, [0, 0]);\n+\n+    let trait_unified_2 = loop {\n+        if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            break Default::default()\n+        };\n+    };\n+    assert_eq!(trait_unified_2, [\"\"]);\n+\n+    let trait_unified_3 = loop {\n+        break if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            [\"Yes\".into()]\n+        };\n+    };\n+    assert_eq!(trait_unified_3, [\"Yes\"]);\n+\n+    let regular_break = loop {\n+        if true {\n+            break;\n+        } else {\n+            break break Default::default();\n+        }\n+    };\n+    assert_eq!(regular_break, ());\n+\n+    let regular_break_2 = loop {\n+        if true {\n+            break Default::default();\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_2, ());\n+\n+    let regular_break_3 = loop {\n+        break if true {\n+            Default::default()\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_3, ());\n+\n+    let regular_break_4 = loop {\n+        break ();\n+        break;\n+    };\n+    assert_eq!(regular_break_4, ());\n+\n+    let regular_break_5 = loop {\n+        break;\n+        break ();\n+    };\n+    assert_eq!(regular_break_5, ());\n+\n+    let nested_break_value = 'outer2: loop {\n+        let _a: u32 = 'inner: loop {\n+            if true {\n+                break 'outer2 \"hello\";\n+            } else {\n+                break 'inner 17;\n+            }\n+        };\n+        panic!();\n+    };\n+    assert_eq!(nested_break_value, \"hello\");\n+\n+    let break_from_while_cond = loop {\n+        while break {\n+            panic!();\n+        }\n+        break 123;\n+    };\n+    assert_eq!(break_from_while_cond, 123);\n+}"}, {"sha": "11684d8663af8ee9c75f3e21081c50b665ed5a16", "filename": "src/test/run-pass/rmeta.rs", "status": "renamed", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Frmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c91dfb6a2e21c82966d0a13f9cd3e51da94654/src%2Ftest%2Frun-pass%2Frmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frmeta.rs?ref=b3c91dfb6a2e21c82966d0a13f9cd3e51da94654", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that import shadowing using globs causes errors\n+// Test that using rlibs and rmeta dep crates work together. Specifically, that\n+// there can be both an rmeta and an rlib file and rustc will prefer the rlib.\n \n-#![no_implicit_prelude]\n+// aux-build:rmeta_rmeta.rs\n+// aux-build:rmeta_rlib.rs\n \n-use foo::*;\n-use bar::*; //~ERROR a type named `Baz` has already been imported in this module\n+extern crate rmeta_aux;\n+use rmeta_aux::Foo;\n \n-mod foo {\n-    pub type Baz = isize;\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n }\n-\n-mod bar {\n-    pub type Baz = isize;\n-}\n-\n-mod qux {\n-    pub use bar::Baz;\n-}\n-\n-fn main() {}", "previous_filename": "src/test/compile-fail/import-shadow-1.rs"}]}