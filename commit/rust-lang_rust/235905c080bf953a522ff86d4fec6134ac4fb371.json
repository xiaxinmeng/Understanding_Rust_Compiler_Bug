{"sha": "235905c080bf953a522ff86d4fec6134ac4fb371", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNTkwNWMwODBiZjk1M2E1MjJmZjg2ZDRmZWM2MTM0YWM0ZmIzNzE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-06T17:14:57Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-11T20:08:24Z"}, "message": "Fix handling of trait methods with bodies and improve efficiency", "tree": {"sha": "6cda1fc5a4ab5400f6cafde46dcd52ce16f8f898", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cda1fc5a4ab5400f6cafde46dcd52ce16f8f898"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/235905c080bf953a522ff86d4fec6134ac4fb371", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/235905c080bf953a522ff86d4fec6134ac4fb371", "html_url": "https://github.com/rust-lang/rust/commit/235905c080bf953a522ff86d4fec6134ac4fb371", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/235905c080bf953a522ff86d4fec6134ac4fb371/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b05f0bec1a6f576cd275e52a8a0a0165fb25f77a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b05f0bec1a6f576cd275e52a8a0a0165fb25f77a", "html_url": "https://github.com/rust-lang/rust/commit/b05f0bec1a6f576cd275e52a8a0a0165fb25f77a"}], "stats": {"total": 109, "additions": 70, "deletions": 39}, "files": [{"sha": "7022136f23984070ff1754cc394c5aee020de220", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=235905c080bf953a522ff86d4fec6134ac4fb371", "patch": "@@ -336,22 +336,24 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n                         self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness);\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        if block.is_none() {\n-                            self.check_decl_no_pat(&sig.decl, |span, mut_ident| {\n-                                if mut_ident {\n+                        self.check_decl_no_pat(&sig.decl, |span, mut_ident| {\n+                            if mut_ident {\n+                                if block.is_none() {\n                                     self.session.buffer_lint(\n                                         lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n                                         trait_item.id, span,\n-                                        \"patterns aren't allowed in methods without bodies\");\n-                                } else {\n-                                    let mut err = struct_span_err!(self.session, span, E0642,\n-                                        \"patterns aren't allowed in methods without bodies\");\n-                                    err.span_suggestion(span,\n-                                        \"use an underscore to ignore the name\", \"_\".to_owned());\n-                                    err.emit();\n+                                        \"patterns aren't allowed in trait methods\");\n                                 }\n-                            });\n-                        }\n+                            } else {\n+                                let mut err = struct_span_err!(self.session, span, E0642,\n+                                    \"patterns aren't allowed in trait methods\");\n+                                let suggestion = \"give this argument a name or use an \\\n+                                                  underscore to ignore it, instead of a \\\n+                                                  tuple pattern\";\n+                                err.span_suggestion(span, suggestion, \"_\".to_owned());\n+                                err.emit();\n+                            }\n+                        });\n                     }\n                 }\n             }"}, {"sha": "57eb1f52fb703429a397204956fbc4ceaa6f654a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=235905c080bf953a522ff86d4fec6134ac4fb371", "patch": "@@ -1744,7 +1744,16 @@ impl<'a> Parser<'a> {\n     fn parse_arg_general(&mut self, require_name: bool) -> PResult<'a, Arg> {\n         maybe_whole!(self, NtArg, |x| x);\n \n-        let parser_snapshot_before_pat = self.clone();\n+        // If we see `ident :`, then we know that the argument is just of the\n+        // form `type`, which means we won't need to recover from parsing a\n+        // pattern and so we don't need to store a parser snapshot.\n+        let parser_snapshot_before_pat = if\n+            self.look_ahead(1, |t| t.is_ident()) &&\n+            self.look_ahead(2, |t| t == &token::Colon) {\n+                None\n+            } else {\n+                Some(self.clone())\n+            };\n \n         // We're going to try parsing the argument as a pattern (even if it's not\n         // allowed, such as for trait methods without bodies). This way we can provide\n@@ -1755,29 +1764,31 @@ impl<'a> Parser<'a> {\n             (pat, self.parse_ty()?)\n         };\n \n-        let is_named_argument = self.is_named_argument();\n         match pat_arg {\n             Ok((pat, ty)) => {\n                 Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n             }\n             Err(mut err) => {\n-                if require_name || is_named_argument {\n-                    Err(err)\n-                } else {\n-                    err.cancel();\n-                    // Recover from attempting to parse the argument as a pattern. This means\n-                    // the type is alone, with no name, e.g. `fn foo(u32)`.\n-                    mem::replace(self, parser_snapshot_before_pat);\n-                    debug!(\"parse_arg_general ident_to_pat\");\n-                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n-                    let ty = self.parse_ty()?;\n-                    let pat = P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Ident(\n-                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                        span: ty.span,\n-                    });\n-                    Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n+                match (require_name || self.is_named_argument(), parser_snapshot_before_pat) {\n+                    (true, _) | (_, None) => {\n+                        Err(err)\n+                    }\n+                    (false, Some(parser_snapshot_before_pat)) => {\n+                        err.cancel();\n+                        // Recover from attempting to parse the argument as a pattern. This means\n+                        // the type is alone, with no name, e.g. `fn foo(u32)`.\n+                        mem::replace(self, parser_snapshot_before_pat);\n+                        debug!(\"parse_arg_general ident_to_pat\");\n+                        let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                        let ty = self.parse_ty()?;\n+                        let pat = P(Pat {\n+                            id: ast::DUMMY_NODE_ID,\n+                            node: PatKind::Ident(\n+                                BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                            span: ty.span,\n+                        });\n+                        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n+                    }\n                 }\n             }\n         }"}, {"sha": "80e69679801192f5d89af40b70729473d73c66e1", "filename": "src/test/compile-fail/no-patterns-in-args-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-2.rs?ref=235905c080bf953a522ff86d4fec6134ac4fb371", "patch": "@@ -11,9 +11,9 @@\n #![deny(patterns_in_fns_without_body)]\n \n trait Tr {\n-    fn f1(mut arg: u8); //~ ERROR patterns aren't allowed in methods without bodies\n+    fn f1(mut arg: u8); //~ ERROR patterns aren't allowed in trait methods\n                         //~^ WARN was previously accepted\n-    fn f2(&arg: u8); //~ ERROR patterns aren't allowed in methods without bodies\n+    fn f2(&arg: u8); //~ ERROR patterns aren't allowed in trait methods\n     fn g1(arg: u8); // OK\n     fn g2(_: u8); // OK\n     #[allow(anonymous_parameters)]"}, {"sha": "546c40ecbd045a84d839eae73124cc9fac3bdcab", "filename": "src/test/compile-fail/no-patterns-in-args-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-macro.rs?ref=235905c080bf953a522ff86d4fec6134ac4fb371", "patch": "@@ -30,7 +30,7 @@ mod bad_pat {\n     m!((bad, pat));\n     //~^ ERROR patterns aren't allowed in function pointer types\n     //~| ERROR patterns aren't allowed in foreign function declarations\n-    //~| ERROR patterns aren't allowed in methods without bodies\n+    //~| ERROR patterns aren't allowed in trait methods\n }\n \n fn main() {}"}, {"sha": "837a9365271e28291869c1f52e058f2ab0a077cf", "filename": "src/test/ui/E0642.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fui%2FE0642.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fui%2FE0642.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0642.rs?ref=235905c080bf953a522ff86d4fec6134ac4fb371", "patch": "@@ -9,7 +9,11 @@\n // except according to those terms.\n \n trait Foo {\n-    fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in methods without bodies\n+    fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in trait methods\n+}\n+\n+trait Bar {\n+    fn bar((x, y): (i32, i32)) {} //~ ERROR patterns aren't allowed in trait methods\n }\n \n fn main() {}"}, {"sha": "07ec8b4cc2c8fe8e60395f1253f57ab9b7bbe0bc", "filename": "src/test/ui/E0642.stderr", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fui%2FE0642.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235905c080bf953a522ff86d4fec6134ac4fb371/src%2Ftest%2Fui%2FE0642.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0642.stderr?ref=235905c080bf953a522ff86d4fec6134ac4fb371", "patch": "@@ -1,9 +1,23 @@\n-error[E0642]: patterns aren't allowed in methods without bodies\n+error[E0642]: patterns aren't allowed in trait methods\n   --> $DIR/E0642.rs:12:12\n    |\n-LL |     fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in methods without bodies\n-   |            ^^^^^^ help: use an underscore to ignore the name: `_`\n+LL |     fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in trait methods\n+   |            ^^^^^^\n+help: give this argument a name or use an underscore to ignore it, instead of a tuple pattern\n+   |\n+LL |     fn foo(_: (i32, i32)); //~ ERROR patterns aren't allowed in trait methods\n+   |            ^\n+\n+error[E0642]: patterns aren't allowed in trait methods\n+  --> $DIR/E0642.rs:16:12\n+   |\n+LL |     fn bar((x, y): (i32, i32)) {} //~ ERROR patterns aren't allowed in trait methods\n+   |            ^^^^^^\n+help: give this argument a name or use an underscore to ignore it, instead of a tuple pattern\n+   |\n+LL |     fn bar(_: (i32, i32)) {} //~ ERROR patterns aren't allowed in trait methods\n+   |            ^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0642`."}]}