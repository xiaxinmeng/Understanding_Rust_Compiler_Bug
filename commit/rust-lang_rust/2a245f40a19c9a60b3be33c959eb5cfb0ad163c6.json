{"sha": "2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMjQ1ZjQwYTE5YzlhNjBiM2JlMzNjOTU5ZWI1Y2ZiMGFkMTYzYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-15T12:41:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-15T12:41:28Z"}, "message": "Auto merge of #85328 - GuillaumeGomez:rollup-exe9nbj, r=GuillaumeGomez\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #84461 (rustdoc: Remove unnecessary `StripItem` wrapper)\n - #85067 (Minimize amount of fake `DefId`s used in rustdoc)\n - #85207 (Fix typo in comment)\n - #85215 (coverage bug fixes and some refactoring)\n - #85221 (dbg macro: Discuss use in tests, and slightly clarify)\n - #85246 (Miner code formatting)\n - #85253 (swap function order for better read flow)\n - #85256 (Fix display for \"implementors\" section)\n - #85268 (Use my real name)\n - #85278 (Improve match statements)\n - #85289 (Fix toggle position on mobile)\n - #85323 (Fix eslint errors)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6a8fc519df8fdd71054f89c108b98be09ba66f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a8fc519df8fdd71054f89c108b98be09ba66f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "html_url": "https://github.com/rust-lang/rust/commit/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b439be03c9c30d173c45785a03a03cba98af5ab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b439be03c9c30d173c45785a03a03cba98af5ab6", "html_url": "https://github.com/rust-lang/rust/commit/b439be03c9c30d173c45785a03a03cba98af5ab6"}, {"sha": "46bc5526db95b03e5b21901e428a5a41d76a1b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/46bc5526db95b03e5b21901e428a5a41d76a1b62", "html_url": "https://github.com/rust-lang/rust/commit/46bc5526db95b03e5b21901e428a5a41d76a1b62"}], "stats": {"total": 874, "additions": 427, "deletions": 447}, "files": [{"sha": "cd617ca2f4285c65243e742f335e7f576574f60f", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -43,7 +43,7 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n-Camelid <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n+Noah Lev <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>"}, {"sha": "08442c588f87902ba3dede3d04cd3f7cf87f8090", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -49,9 +49,9 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     }\n \n     fn create(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>, is_used: bool) -> Self {\n-        let coverageinfo = tcx.coverageinfo(instance.def_id());\n+        let coverageinfo = tcx.coverageinfo(instance.def);\n         debug!(\n-            \"FunctionCoverage::new(instance={:?}) has coverageinfo={:?}. is_used={}\",\n+            \"FunctionCoverage::create(instance={:?}) has coverageinfo={:?}. is_used={}\",\n             instance, coverageinfo, is_used\n         );\n         Self {"}, {"sha": "a283bf1de763a9da378109d255792eeef0d2f8ff", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.add_coverage_counter(instance, id, code_region);\n                     }\n \n-                    let coverageinfo = bx.tcx().coverageinfo(instance.def_id());\n+                    let coverageinfo = bx.tcx().coverageinfo(instance.def);\n \n                     let fn_name = bx.get_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);"}, {"sha": "5f05b59d5a6d4fd3389bf2e9b3ce91b198384c28", "filename": "compiler/rustc_error_codes/src/error_codes/E0277.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -29,16 +29,16 @@ trait Foo {\n     fn bar(&self);\n }\n \n-fn some_func<T: Foo>(foo: T) {\n-    foo.bar(); // we can now use this method since i32 implements the\n-               // Foo trait\n-}\n-\n // we implement the trait on the i32 type\n impl Foo for i32 {\n     fn bar(&self) {}\n }\n \n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar(); // we can now use this method since i32 implements the\n+               // Foo trait\n+}\n+\n fn main() {\n     some_func(5i32); // ok!\n }"}, {"sha": "b60d70039458a4ff1207dfeb9851254780b32f61", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -335,10 +335,9 @@ rustc_queries! {\n \n     /// Returns coverage summary info for a function, after executing the `InstrumentCoverage`\n     /// MIR pass (assuming the -Zinstrument-coverage option is enabled).\n-    query coverageinfo(key: DefId) -> mir::CoverageInfo {\n-        desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key) }\n+    query coverageinfo(key: ty::InstanceDef<'tcx>) -> mir::CoverageInfo {\n+        desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key.def_id()) }\n         storage(ArenaCacheSelector<'tcx>)\n-        cache_on_disk_if { key.is_local() }\n     }\n \n     /// Returns the name of the file that contains the function body, if instrumented for coverage."}, {"sha": "1bfbb843114da3ea6c4ec545fbdd1f8e15e1850c", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -137,10 +137,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                         self.loc,\n                         InteriorOfSliceOrArray {\n                             ty: place_ty,\n-                            is_index: match elem {\n-                                ProjectionElem::Index(..) => true,\n-                                _ => false,\n-                            },\n+                            is_index: matches!(elem, ProjectionElem::Index(..)),\n                         },\n                     ));\n                 }"}, {"sha": "2397d627880f337f63fbfa470757f8b40d7d3185", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -120,6 +120,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n \n use std::iter;\n use std::lazy::SyncOnceCell;\n@@ -636,6 +637,7 @@ pub(super) fn dump_coverage_spanview(\n     mir_body: &mir::Body<'tcx>,\n     basic_coverage_blocks: &CoverageGraph,\n     pass_name: &str,\n+    body_span: Span,\n     coverage_spans: &Vec<CoverageSpan>,\n ) {\n     let mir_source = mir_body.source;\n@@ -647,7 +649,7 @@ pub(super) fn dump_coverage_spanview(\n     let crate_name = tcx.crate_name(def_id.krate);\n     let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n     let title = format!(\"{}.{} - Coverage Spans\", crate_name, item_name);\n-    spanview::write_document(tcx, def_id, span_viewables, &title, &mut file)\n+    spanview::write_document(tcx, body_span, span_viewables, &title, &mut file)\n         .expect(\"Unexpected IO error dumping coverage spans as HTML\");\n }\n "}, {"sha": "71c244fdd4a3ae5e991340a2b67251eca40c8ca9", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n \n         trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n         Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n-        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n+        trace!(\"InstrumentCoverage done for {:?}\", mir_source.def_id());\n     }\n }\n \n@@ -116,25 +116,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let def_id = mir_body.source.def_id();\n         let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, def_id);\n \n-        let mut body_span = hir_body.value.span;\n-\n-        if tcx.is_closure(def_id) {\n-            // If the MIR function is a closure, and if the closure body span\n-            // starts from a macro, but it's content is not in that macro, try\n-            // to find a non-macro callsite, and instrument the spans there\n-            // instead.\n-            loop {\n-                let expn_data = body_span.ctxt().outer_expn_data();\n-                if expn_data.is_root() {\n-                    break;\n-                }\n-                if let ExpnKind::Macro { .. } = expn_data.kind {\n-                    body_span = expn_data.call_site;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n+        let body_span = get_body_span(tcx, hir_body, mir_body);\n \n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n@@ -144,6 +126,15 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             Some(fn_sig) => fn_sig.span.with_hi(body_span.lo()),\n             None => body_span.shrink_to_lo(),\n         };\n+\n+        debug!(\n+            \"instrumenting {}: {:?}, fn sig span: {:?}, body span: {:?}\",\n+            if tcx.is_closure(def_id) { \"closure\" } else { \"function\" },\n+            def_id,\n+            fn_sig_span,\n+            body_span\n+        );\n+\n         let function_source_hash = hash_mir_source(tcx, hir_body);\n         let basic_coverage_blocks = CoverageGraph::from_mir(mir_body);\n         Self {\n@@ -160,19 +151,11 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n     fn inject_counters(&'a mut self) {\n         let tcx = self.tcx;\n-        let source_map = tcx.sess.source_map();\n         let mir_source = self.mir_body.source;\n         let def_id = mir_source.def_id();\n         let fn_sig_span = self.fn_sig_span;\n         let body_span = self.body_span;\n \n-        debug!(\n-            \"instrumenting {:?}, fn sig span: {}, body span: {}\",\n-            def_id,\n-            source_map.span_to_diagnostic_string(fn_sig_span),\n-            source_map.span_to_diagnostic_string(body_span)\n-        );\n-\n         let mut graphviz_data = debug::GraphvizData::new();\n         let mut debug_used_expressions = debug::UsedExpressions::new();\n \n@@ -204,6 +187,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 self.mir_body,\n                 &self.basic_coverage_blocks,\n                 self.pass_name,\n+                body_span,\n                 &coverage_spans,\n             );\n         }\n@@ -560,6 +544,35 @@ fn fn_sig_and_body<'tcx>(\n     (hir::map::fn_sig(hir_node), tcx.hir().body(fn_body_id))\n }\n \n+fn get_body_span<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    hir_body: &rustc_hir::Body<'tcx>,\n+    mir_body: &mut mir::Body<'tcx>,\n+) -> Span {\n+    let mut body_span = hir_body.value.span;\n+    let def_id = mir_body.source.def_id();\n+\n+    if tcx.is_closure(def_id) {\n+        // If the MIR function is a closure, and if the closure body span\n+        // starts from a macro, but it's content is not in that macro, try\n+        // to find a non-macro callsite, and instrument the spans there\n+        // instead.\n+        loop {\n+            let expn_data = body_span.ctxt().outer_expn_data();\n+            if expn_data.is_root() {\n+                break;\n+            }\n+            if let ExpnKind::Macro { .. } = expn_data.kind {\n+                body_span = expn_data.call_site;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    body_span\n+}\n+\n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     hash(&mut hcx, &hir_body.value).to_smaller_hash()"}, {"sha": "760f16eae6b1f85be18bea6412b0f260c77b4ed8", "filename": "compiler/rustc_mir/src/transform/coverage/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -120,8 +120,8 @@ impl CoverageVisitor {\n     }\n }\n \n-fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo {\n-    let mir_body = mir_body(tcx, def_id);\n+fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) -> CoverageInfo {\n+    let mir_body = tcx.instance_mir(instance_def);\n \n     let mut coverage_visitor = CoverageVisitor {\n         // num_counters always has at least the `ZERO` counter."}, {"sha": "f62171b3c535c757fe25accb398462dfa7bce5b3", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -530,17 +530,25 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(move |(index, statement)| {\n-                        filtered_statement_span(statement, self.body_span).map(\n-                            |(span, expn_span)| {\n-                                CoverageSpan::for_statement(\n-                                    statement, span, expn_span, bcb, bb, index,\n-                                )\n-                            },\n-                        )\n+                        filtered_statement_span(statement).map(|span| {\n+                            CoverageSpan::for_statement(\n+                                statement,\n+                                function_source_span(span, self.body_span),\n+                                span,\n+                                bcb,\n+                                bb,\n+                                index,\n+                            )\n+                        })\n                     })\n-                    .chain(filtered_terminator_span(data.terminator(), self.body_span).map(\n-                        |(span, expn_span)| CoverageSpan::for_terminator(span, expn_span, bcb, bb),\n-                    ))\n+                    .chain(filtered_terminator_span(data.terminator()).map(|span| {\n+                        CoverageSpan::for_terminator(\n+                            function_source_span(span, self.body_span),\n+                            span,\n+                            bcb,\n+                            bb,\n+                        )\n+                    }))\n             })\n             .collect()\n     }\n@@ -795,13 +803,9 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n-/// See `function_source_span()` for a description of the two returned spans.\n-/// If the MIR `Statement` is not contributive to computing coverage spans,\n-/// returns `None`.\n-pub(super) fn filtered_statement_span(\n-    statement: &'a Statement<'tcx>,\n-    body_span: Span,\n-) -> Option<(Span, Span)> {\n+/// If the MIR `Statement` has a span contributive to computing coverage spans,\n+/// return it; otherwise return `None`.\n+pub(super) fn filtered_statement_span(statement: &'a Statement<'tcx>) -> Option<Span> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -838,18 +842,14 @@ pub(super) fn filtered_statement_span(\n         | StatementKind::LlvmInlineAsm(_)\n         | StatementKind::Retag(_, _)\n         | StatementKind::AscribeUserType(_, _) => {\n-            Some(function_source_span(statement.source_info.span, body_span))\n+            Some(statement.source_info.span)\n         }\n     }\n }\n \n-/// See `function_source_span()` for a description of the two returned spans.\n-/// If the MIR `Terminator` is not contributive to computing coverage spans,\n-/// returns `None`.\n-pub(super) fn filtered_terminator_span(\n-    terminator: &'a Terminator<'tcx>,\n-    body_span: Span,\n-) -> Option<(Span, Span)> {\n+/// If the MIR `Terminator` has a span contributive to computing coverage spans,\n+/// return it; otherwise return `None`.\n+pub(super) fn filtered_terminator_span(terminator: &'a Terminator<'tcx>) -> Option<Span> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from\n@@ -873,7 +873,7 @@ pub(super) fn filtered_terminator_span(\n                     span = span.with_lo(constant.span.lo());\n                 }\n             }\n-            Some(function_source_span(span, body_span))\n+            Some(span)\n         }\n \n         // Retain spans from all other terminators\n@@ -884,28 +884,20 @@ pub(super) fn filtered_terminator_span(\n         | TerminatorKind::GeneratorDrop\n         | TerminatorKind::FalseUnwind { .. }\n         | TerminatorKind::InlineAsm { .. } => {\n-            Some(function_source_span(terminator.source_info.span, body_span))\n+            Some(terminator.source_info.span)\n         }\n     }\n }\n \n-/// Returns two spans from the given span (the span associated with a\n-/// `Statement` or `Terminator`):\n-///\n-///   1. An extrapolated span (pre-expansion[^1]) corresponding to a range within\n-///      the function's body source. This span is guaranteed to be contained\n-///      within, or equal to, the `body_span`. If the extrapolated span is not\n-///      contained within the `body_span`, the `body_span` is returned.\n-///   2. The actual `span` value from the `Statement`, before expansion.\n-///\n-/// Only the first span is used when computing coverage code regions. The second\n-/// span is useful if additional expansion data is needed (such as to look up\n-/// the macro name for a composed span within that macro).)\n+/// Returns an extrapolated span (pre-expansion[^1]) corresponding to a range\n+/// within the function's body source. This span is guaranteed to be contained\n+/// within, or equal to, the `body_span`. If the extrapolated span is not\n+/// contained within the `body_span`, the `body_span` is returned.\n ///\n-/// [^1]Expansions result from Rust syntax including macros, syntactic\n-/// sugar, etc.).\n+/// [^1]Expansions result from Rust syntax including macros, syntactic sugar,\n+/// etc.).\n #[inline]\n-fn function_source_span(span: Span, body_span: Span) -> (Span, Span) {\n+pub(super) fn function_source_span(span: Span, body_span: Span) -> Span {\n     let original_span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n-    (if body_span.contains(original_span) { original_span } else { body_span }, span)\n+    if body_span.contains(original_span) { original_span } else { body_span }\n }"}, {"sha": "b04c2d542d459fda4a9b5aa30f1e0208b65bede1", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -683,12 +683,10 @@ fn test_make_bcb_counters() {\n         let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n         let mut coverage_spans = Vec::new();\n         for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n-            if let Some((span, expn_span)) =\n-                spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n-            {\n+            if let Some(span) = spans::filtered_terminator_span(data.terminator(&mir_body)) {\n                 coverage_spans.push(spans::CoverageSpan::for_terminator(\n+                    spans::function_source_span(span, body_span),\n                     span,\n-                    expn_span,\n                     bcb,\n                     data.last_bb(),\n                 ));"}, {"sha": "7934d4ba8499c5364e09b7e00eede429b6d299c3", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -170,10 +170,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n }\n \n fn is_switch<'tcx>(terminator: &Terminator<'tcx>) -> bool {\n-    match terminator.kind {\n-        TerminatorKind::SwitchInt { .. } => true,\n-        _ => false,\n-    }\n+    matches!(terminator.kind, TerminatorKind::SwitchInt { .. })\n }\n \n struct Helper<'a, 'tcx> {"}, {"sha": "89fddc95c98f7802cfdc9f8b555c5300e2588ccf", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -628,10 +628,7 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n                     // But `asm!(...)` could abort the program,\n                     // so we cannot assume that the `unreachable` terminator itself is reachable.\n                     // FIXME(Centril): use a normalization pass instead of a check.\n-                    || bb.statements.iter().any(|stmt| match stmt.kind {\n-                        StatementKind::LlvmInlineAsm(..) => true,\n-                        _ => false,\n-                    })\n+                    || bb.statements.iter().any(|stmt| matches!(stmt.kind, StatementKind::LlvmInlineAsm(..)))\n                     })\n                     .peekable();\n "}, {"sha": "42683dac426e3b1fdd5271658149c50ca42bd014", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -131,32 +131,32 @@ where\n             }\n         }\n     }\n-    write_document(tcx, def_id, span_viewables, title, w)?;\n+    write_document(tcx, fn_span(tcx, def_id), span_viewables, title, w)?;\n     Ok(())\n }\n \n /// Generate a spanview HTML+CSS document for the given local function `def_id`, and a pre-generated\n /// list `SpanViewable`s.\n pub fn write_document<'tcx, W>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    spanview_span: Span,\n     mut span_viewables: Vec<SpanViewable>,\n     title: &str,\n     w: &mut W,\n ) -> io::Result<()>\n where\n     W: Write,\n {\n-    let fn_span = fn_span(tcx, def_id);\n-    let mut from_pos = fn_span.lo();\n-    let end_pos = fn_span.hi();\n+    let mut from_pos = spanview_span.lo();\n+    let end_pos = spanview_span.hi();\n     let source_map = tcx.sess.source_map();\n     let start = source_map.lookup_char_pos(from_pos);\n     let indent_to_initial_start_col = \" \".repeat(start.col.to_usize());\n     debug!(\n-        \"fn_span source is:\\n{}{}\",\n+        \"spanview_span={:?}; source is:\\n{}{}\",\n+        spanview_span,\n         indent_to_initial_start_col,\n-        source_map.span_to_snippet(fn_span).expect(\"function should have printable source\")\n+        source_map.span_to_snippet(spanview_span).expect(\"function should have printable source\")\n     );\n     writeln!(w, \"{}\", HEADER)?;\n     writeln!(w, \"<title>{}</title>\", title)?;"}, {"sha": "b2c5df5410dcab9fa484fc654722a5241a1c9315", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -185,9 +185,10 @@ macro_rules! eprintln {\n /// builds or when debugging in release mode is significantly faster.\n ///\n /// Note that the macro is intended as a debugging tool and therefore you\n-/// should avoid having uses of it in version control for long periods.\n-/// Use cases involving debug output that should be added to version control\n-/// are better served by macros such as [`debug!`] from the [`log`] crate.\n+/// should avoid having uses of it in version control for long periods\n+/// (other than in tests and similar).\n+/// Debug output from production code is better done with other facilities\n+/// such as the [`debug!`] macro from the [`log`] crate.\n ///\n /// # Stability\n ///"}, {"sha": "cbe14767bd3e7f7e2513e8c60ed3d1b1af19b9c5", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -569,7 +569,7 @@ pub struct Components<'a> {\n     prefix: Option<Prefix<'a>>,\n \n     // true if path *physically* has a root separator; for most Windows\n-    // prefixes, it may have a \"logical\" rootseparator for the purposes of\n+    // prefixes, it may have a \"logical\" root separator for the purposes of\n     // normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.\n     has_physical_root: bool,\n "}, {"sha": "feeb03b1b67004db00205d262f0d8b7d523e73d0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -533,8 +533,7 @@ impl Clean<Generics> for hir::Generics<'_> {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds\n-                            .insert(FakeDefId::new_real(did).into(), bounds.clone());\n+                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n                     }\n                     GenericParamDefKind::Const { .. } => unreachable!(),\n                 }\n@@ -615,7 +614,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .collect::<Vec<GenericParamDef>>();\n \n         // param index -> [(DefId of trait, associated type name, type)]\n-        let mut impl_trait_proj = FxHashMap::<u32, Vec<(FakeDefId, Symbol, Ty<'tcx>)>>::default();\n+        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n \n         let where_predicates = preds\n             .predicates\n@@ -687,13 +686,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 if let Some(proj) = impl_trait_proj.remove(&idx) {\n                     for (trait_did, name, rhs) in proj {\n                         let rhs = rhs.clean(cx);\n-                        simplify::merge_bounds(\n-                            cx,\n-                            &mut bounds,\n-                            trait_did.expect_real(),\n-                            name,\n-                            &rhs,\n-                        );\n+                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n                     }\n                 }\n             } else {\n@@ -1183,8 +1176,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 if let Some(new_ty) = cx.ty_substs.get(&did).cloned() {\n                     return new_ty;\n                 }\n-                if let Some(bounds) = cx.impl_trait_bounds.remove(&FakeDefId::new_real(did).into())\n-                {\n+                if let Some(bounds) = cx.impl_trait_bounds.remove(&did.into()) {\n                     return ImplTrait(bounds);\n                 }\n             }"}, {"sha": "edd3d77eeb7809b0acec5031b56f2c4983d43e05", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -73,10 +73,6 @@ impl FakeDefId {\n         Self::Fake(DefIndex::from(id), krate)\n     }\n \n-    crate fn new_real(id: DefId) -> Self {\n-        Self::Real(id)\n-    }\n-\n     #[inline]\n     crate fn is_local(self) -> bool {\n         match self {\n@@ -470,7 +466,7 @@ impl Item {\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n                 match did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did.expect_real(), cx) {\n+                        if let Some((mut href, ..)) = href(did.clone(), cx) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);\n@@ -972,7 +968,7 @@ crate struct ItemLink {\n     /// This may not be the same as `link` if there was a disambiguator\n     /// in an intra-doc link (e.g. \\[`fn@f`\\])\n     pub(crate) link_text: String,\n-    pub(crate) did: Option<FakeDefId>,\n+    pub(crate) did: Option<DefId>,\n     /// The url fragment to append to the link\n     pub(crate) fragment: Option<String>,\n }"}, {"sha": "2930c3c5fb7ec510bdea8ac02a2ec01a78f48cd6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -576,12 +576,12 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n crate enum ImplTraitParam {\n-    DefId(FakeDefId),\n+    DefId(DefId),\n     ParamIndex(u32),\n }\n \n-impl From<FakeDefId> for ImplTraitParam {\n-    fn from(did: FakeDefId) -> Self {\n+impl From<DefId> for ImplTraitParam {\n+    fn from(did: DefId) -> Self {\n         ImplTraitParam::DefId(did)\n     }\n }"}, {"sha": "723792381ef09df8d1820090f1a53a3bf4fada9b", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -1,17 +1,10 @@\n use crate::clean::*;\n \n-crate struct StripItem(pub Item);\n-\n-impl StripItem {\n-    crate fn strip(self) -> Item {\n-        match self.0 {\n-            Item { kind: box StrippedItem(..), .. } => self.0,\n-            mut i => {\n-                i.kind = box StrippedItem(i.kind);\n-                i\n-            }\n-        }\n+crate fn strip_item(mut item: Item) -> Item {\n+    if !matches!(*item.kind, StrippedItem(..)) {\n+        item.kind = box StrippedItem(item.kind);\n     }\n+    item\n }\n \n crate trait DocFolder: Sized {"}, {"sha": "5734a4a98e2b5f32f870497f28c8e567410d747e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -67,7 +67,7 @@ crate struct Cache {\n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    crate implementors: FxHashMap<FakeDefId, Vec<Impl>>,\n+    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n     crate extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc: item\n                                 .doc_value()\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n-                            parent: parent.map(FakeDefId::new_real),\n+                            parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item, &self.empty_cache, self.tcx),\n                             aliases: item.attrs.get_doc_aliases(),"}, {"sha": "3e056c4b67a70df1d3127b54b22d9e7b910444cf", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -7,7 +7,7 @@ use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n use crate::clean::types::{\n-    FakeDefId, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n+    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n };\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n@@ -82,7 +82,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 defid_to_pathid.insert(defid, pathid);\n                 lastpathid += 1;\n \n-                if let Some(&(ref fqp, short)) = paths.get(&defid.expect_real()) {\n+                if let Some(&(ref fqp, short)) = paths.get(&defid) {\n                     crate_paths.push((short, fqp.last().unwrap().clone()));\n                     Some(pathid)\n                 } else {\n@@ -214,7 +214,7 @@ crate fn get_index_search_type<'tcx>(\n \n fn get_index_type(clean_type: &clean::Type, cache: &Cache) -> RenderType {\n     RenderType {\n-        ty: clean_type.def_id_full(cache).map(FakeDefId::new_real),\n+        ty: clean_type.def_id_full(cache),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: get_generics(clean_type, cache),\n@@ -256,7 +256,7 @@ fn get_generics(clean_type: &clean::Type, cache: &Cache) -> Option<Vec<Generic>>\n             .filter_map(|t| {\n                 get_index_type_name(t, false).map(|name| Generic {\n                     name: name.as_str().to_ascii_lowercase(),\n-                    defid: t.def_id_full(cache).map(FakeDefId::new_real),\n+                    defid: t.def_id_full(cache),\n                     idx: None,\n                 })\n             })"}, {"sha": "e4dbf145866296a64416c840d92f6de732e45cc1", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -87,7 +87,7 @@ crate struct IndexItem {\n     crate name: String,\n     crate path: String,\n     crate desc: String,\n-    crate parent: Option<FakeDefId>,\n+    crate parent: Option<DefId>,\n     crate parent_idx: Option<usize>,\n     crate search_type: Option<IndexItemFunctionType>,\n     crate aliases: Box<[String]>,\n@@ -96,7 +96,7 @@ crate struct IndexItem {\n /// A type used for the search index.\n #[derive(Debug)]\n crate struct RenderType {\n-    ty: Option<FakeDefId>,\n+    ty: Option<DefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n     generics: Option<Vec<Generic>>,\n@@ -128,7 +128,7 @@ impl Serialize for RenderType {\n #[derive(Debug)]\n crate struct Generic {\n     name: String,\n-    defid: Option<FakeDefId>,\n+    defid: Option<DefId>,\n     idx: Option<usize>,\n }\n \n@@ -2137,7 +2137,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"</div>\",\n     );\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n         let cache = cx.cache();\n         let mut res = implementors\n             .iter()"}, {"sha": "ff639cb292462acd82cbbd4766ef3626b7fcd5d4", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -642,7 +642,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();"}, {"sha": "c25a73f58eb602328f078f352ff71965f740485f", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -465,8 +465,6 @@ pub(super) fn write_shared(\n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n     for (&did, imps) in &cx.cache.implementors {\n-        let did = did.expect_real();\n-\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't"}, {"sha": "be30871ea4c70f2a27bb2d692a8173041f17ccb7", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -1,6 +1,6 @@\n // Local js definitions:\n-/* global addClass, getSettingValue, hasClass */\n-/* global onEach, onEachLazy, hasOwnProperty, removeClass, updateLocalStorage */\n+/* global addClass, getSettingValue, hasClass, searchState */\n+/* global onEach, onEachLazy, removeClass */\n /* global switchTheme, useSystemTheme */\n \n if (!String.prototype.startsWith) {\n@@ -347,10 +347,6 @@ function hideThemeButtonState() {\n         document.getElementsByTagName(\"body\")[0].style.marginTop = \"\";\n     }\n \n-    function isHidden(elem) {\n-        return elem.offsetHeight === 0;\n-    }\n-\n     var toggleAllDocsId = \"toggle-all-docs\";\n     var main = document.getElementById(\"main\");\n     var savedHash = \"\";\n@@ -553,7 +549,7 @@ function hideThemeButtonState() {\n                     len = window.rootPath.match(/\\.\\.\\//g).length + 1;\n \n                 for (i = 0; i < len; ++i) {\n-                    match = url.match(/\\/[^\\/]*$/);\n+                    match = url.match(/\\/[^/]*$/);\n                     if (i < len - 1) {\n                         stripped = match[0] + stripped;\n                     }\n@@ -952,13 +948,11 @@ function hideThemeButtonState() {\n         });\n \n         var currentType = document.getElementsByClassName(\"type-decl\")[0];\n-        var className = null;\n         if (currentType) {\n             currentType = currentType.getElementsByClassName(\"rust\")[0];\n             if (currentType) {\n                 onEachLazy(currentType.classList, function(item) {\n                     if (item !== \"main\") {\n-                        className = item;\n                         return true;\n                     }\n                 });\n@@ -1047,7 +1041,7 @@ function hideThemeButtonState() {\n         };\n     }\n \n-    function buildHelperPopup() {\n+    var buildHelperPopup = function() {\n         var popup = document.createElement(\"aside\");\n         addClass(popup, \"hidden\");\n         popup.id = \"help\";\n@@ -1114,7 +1108,7 @@ function hideThemeButtonState() {\n         insertAfter(popup, searchState.outputElement());\n         // So that it's only built once and then it'll do nothing when called!\n         buildHelperPopup = function() {};\n-    }\n+    };\n \n     onHashChange(null);\n     window.addEventListener(\"hashchange\", onHashChange);"}, {"sha": "e2e1aefa4a84207cf2530217cfae8b1f264bf494", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 199, "deletions": 193, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -542,7 +542,7 @@ h4 > code, h3 > code, .invisible > code {\n \tfont-size: 0.8em;\n }\n \n-.content .methods > div:not(.notable-traits) {\n+.content .methods > div:not(.notable-traits):not(.methods) {\n \tmargin-left: 40px;\n \tmargin-bottom: 15px;\n }\n@@ -1293,6 +1293,201 @@ h4 > .notable-traits {\n \tborder-top: 1px solid;\n }\n \n+\n+\n+h3.notable {\n+\tmargin: 0;\n+\tmargin-bottom: 13px;\n+\tfont-size: 19px;\n+}\n+\n+kbd {\n+\tdisplay: inline-block;\n+\tpadding: 3px 5px;\n+\tfont: 15px monospace;\n+\tline-height: 10px;\n+\tvertical-align: middle;\n+\tborder: solid 1px;\n+\tborder-radius: 3px;\n+\tbox-shadow: inset 0 -1px 0;\n+\tcursor: default;\n+}\n+\n+.hidden-by-impl-hider,\n+.hidden-by-usual-hider {\n+\t/* important because of conflicting rule for small screens */\n+\tdisplay: none !important;\n+}\n+\n+#implementations-list > h3 > span.in-band {\n+\twidth: 100%;\n+}\n+\n+.table-display {\n+\twidth: 100%;\n+\tborder: 0;\n+\tborder-collapse: collapse;\n+\tborder-spacing: 0;\n+\tfont-size: 16px;\n+}\n+\n+.table-display tr td:first-child {\n+\tpadding-right: 0;\n+}\n+\n+.table-display tr td:last-child {\n+\tfloat: right;\n+}\n+.table-display .out-of-band {\n+\tposition: relative;\n+\tfont-size: 19px;\n+\tdisplay: block;\n+}\n+#implementors-list > .impl-items .table-display .out-of-band {\n+\tfont-size: 17px;\n+}\n+\n+.table-display td:hover .anchor {\n+\tdisplay: block;\n+\ttop: 2px;\n+\tleft: -5px;\n+}\n+\n+#main > ul {\n+\tpadding-left: 10px;\n+}\n+#main > ul > li {\n+\tlist-style: none;\n+}\n+\n+.non-exhaustive {\n+\tmargin-bottom: 1em;\n+}\n+\n+div.children {\n+\tpadding-left: 27px;\n+\tdisplay: none;\n+}\n+div.name {\n+\tcursor: pointer;\n+\tposition: relative;\n+\tmargin-left: 16px;\n+}\n+div.files > a {\n+\tdisplay: block;\n+\tpadding: 0 3px;\n+}\n+div.files > a:hover, div.name:hover {\n+\tbackground-color: #a14b4b;\n+}\n+div.name.expand + .children {\n+\tdisplay: block;\n+}\n+div.name::before {\n+\tcontent: \"\\25B6\";\n+\tpadding-left: 4px;\n+\tfont-size: 0.7em;\n+\tposition: absolute;\n+\tleft: -16px;\n+\ttop: 4px;\n+}\n+div.name.expand::before {\n+\ttransform: rotate(90deg);\n+\tleft: -15px;\n+\ttop: 2px;\n+}\n+\n+/* The hideme class is used on summary tags that contain a span with\n+\tplaceholder text shown only when the toggle is closed. For instance,\n+\t\"Expand description\" or \"Show methods\". */\n+details.rustdoc-toggle > summary.hideme {\n+\tcursor: pointer;\n+}\n+\n+details.rustdoc-toggle > summary, details.undocumented > summary {\n+\tlist-style: none;\n+}\n+details.rustdoc-toggle > summary::-webkit-details-marker,\n+details.rustdoc-toggle > summary::marker,\n+details.undocumented > summary::-webkit-details-marker,\n+details.undocumented > summary::marker {\n+\tdisplay: none;\n+}\n+\n+details.rustdoc-toggle > summary.hideme > span {\n+\tmargin-left: 9px;\n+}\n+\n+details.rustdoc-toggle > summary::before {\n+\tcontent: \"[+]\";\n+\tfont-weight: 300;\n+\tfont-size: 0.8em;\n+\tletter-spacing: 1px;\n+\tcursor: pointer;\n+}\n+\n+details.rustdoc-toggle.top-doc > summary,\n+details.rustdoc-toggle.top-doc > summary::before,\n+details.rustdoc-toggle.non-exhaustive > summary,\n+details.rustdoc-toggle.non-exhaustive > summary::before {\n+\tfont-family: 'Fira Sans';\n+\tfont-size: 16px;\n+}\n+\n+details.non-exhaustive {\n+\tmargin-bottom: 8px;\n+}\n+\n+details.rustdoc-toggle > summary.hideme::before {\n+\tposition: relative;\n+}\n+\n+details.rustdoc-toggle > summary:not(.hideme)::before {\n+\tposition: absolute;\n+\tleft: -23px;\n+\ttop: initial;\n+}\n+\n+.impl-items > details.rustdoc-toggle > summary:not(.hideme)::before,\n+.undocumented > details.rustdoc-toggle > summary:not(.hideme)::before {\n+\tposition: absolute;\n+\ttop: 3px;\n+\tleft: -2px;\n+}\n+\n+/* When a \"hideme\" summary is open and the \"Expand description\" or \"Show\n+\tmethods\" text is hidden, we want the [-] toggle that remains to not\n+\taffect the layout of the items to its right. To do that, we use\n+\tabsolute positioning. Note that we also set position: relative\n+\ton the parent <details> to make this work properly. */\n+details.rustdoc-toggle[open] > summary.hideme {\n+\tposition: absolute;\n+}\n+\n+details.rustdoc-toggle, details.undocumented {\n+\tposition: relative;\n+}\n+\n+details.rustdoc-toggle[open] > summary.hideme > span {\n+\tdisplay: none;\n+}\n+\n+details.rustdoc-toggle[open] > summary::before {\n+\tcontent: \"[\u2212]\";\n+\tdisplay: inline;\n+}\n+\n+details.undocumented > summary::before {\n+\tcontent: \"[+] Show hidden undocumented items\";\n+\tcursor: pointer;\n+\tfont-size: 16px;\n+\tfont-weight: 300;\n+}\n+\n+details.undocumented[open] > summary::before {\n+\tcontent: \"[\u2212] Hide undocumented items\";\n+}\n+\n /* Media Queries */\n \n @media (min-width: 701px) {\n@@ -1492,8 +1687,9 @@ h4 > .notable-traits {\n \t\tborder-bottom: 1px solid;\n \t}\n \n-\t.item-list > details.rustdoc-toggle > summary:not(.hideme)::before {\n-\t\tleft: -10px;\n+\t#main > details.rustdoc-toggle > summary::before,\n+\t#main > div > details.rustdoc-toggle > summary::before {\n+\t\tleft: -11px;\n \t}\n \n \t#all-types {\n@@ -1587,193 +1783,3 @@ h4 > .notable-traits {\n \t\tmargin-left: 12px;\n \t}\n }\n-\n-h3.notable {\n-\tmargin: 0;\n-\tmargin-bottom: 13px;\n-\tfont-size: 19px;\n-}\n-\n-kbd {\n-\tdisplay: inline-block;\n-\tpadding: 3px 5px;\n-\tfont: 15px monospace;\n-\tline-height: 10px;\n-\tvertical-align: middle;\n-\tborder: solid 1px;\n-\tborder-radius: 3px;\n-\tbox-shadow: inset 0 -1px 0;\n-\tcursor: default;\n-}\n-\n-.hidden-by-impl-hider,\n-.hidden-by-usual-hider {\n-\t/* important because of conflicting rule for small screens */\n-\tdisplay: none !important;\n-}\n-\n-#implementations-list > h3 > span.in-band {\n-\twidth: 100%;\n-}\n-\n-.table-display {\n-\twidth: 100%;\n-\tborder: 0;\n-\tborder-collapse: collapse;\n-\tborder-spacing: 0;\n-\tfont-size: 16px;\n-}\n-\n-.table-display tr td:first-child {\n-\tpadding-right: 0;\n-}\n-\n-.table-display tr td:last-child {\n-\tfloat: right;\n-}\n-.table-display .out-of-band {\n-\tposition: relative;\n-\tfont-size: 19px;\n-\tdisplay: block;\n-}\n-#implementors-list > .impl-items .table-display .out-of-band {\n-\tfont-size: 17px;\n-}\n-\n-.table-display td:hover .anchor {\n-\tdisplay: block;\n-\ttop: 2px;\n-\tleft: -5px;\n-}\n-\n-#main > ul {\n-\tpadding-left: 10px;\n-}\n-#main > ul > li {\n-\tlist-style: none;\n-}\n-\n-.non-exhaustive {\n-\tmargin-bottom: 1em;\n-}\n-\n-div.children {\n-\tpadding-left: 27px;\n-\tdisplay: none;\n-}\n-div.name {\n-\tcursor: pointer;\n-\tposition: relative;\n-\tmargin-left: 16px;\n-}\n-div.files > a {\n-\tdisplay: block;\n-\tpadding: 0 3px;\n-}\n-div.files > a:hover, div.name:hover {\n-\tbackground-color: #a14b4b;\n-}\n-div.name.expand + .children {\n-\tdisplay: block;\n-}\n-div.name::before {\n-\tcontent: \"\\25B6\";\n-\tpadding-left: 4px;\n-\tfont-size: 0.7em;\n-\tposition: absolute;\n-\tleft: -16px;\n-\ttop: 4px;\n-}\n-div.name.expand::before {\n-\ttransform: rotate(90deg);\n-\tleft: -15px;\n-\ttop: 2px;\n-}\n-\n-/* The hideme class is used on summary tags that contain a span with\n-\tplaceholder text shown only when the toggle is closed. For instance,\n-\t\"Expand description\" or \"Show methods\". */\n-details.rustdoc-toggle > summary.hideme {\n-\tcursor: pointer;\n-}\n-\n-details.rustdoc-toggle > summary::-webkit-details-marker,\n-details.rustdoc-toggle > summary::marker,\n-details.undocumented > summary::-webkit-details-marker,\n-details.undocumented > summary::marker {\n-\tdisplay: none;\n-}\n-\n-details.rustdoc-toggle > summary.hideme > span {\n-\tmargin-left: 9px;\n-}\n-\n-details.rustdoc-toggle > summary::before {\n-\tcontent: \"[+]\";\n-\tfont-weight: 300;\n-\tfont-size: 0.8em;\n-\tletter-spacing: 1px;\n-\tcursor: pointer;\n-}\n-\n-details.rustdoc-toggle.top-doc > summary,\n-details.rustdoc-toggle.top-doc > summary::before,\n-details.rustdoc-toggle.non-exhaustive > summary,\n-details.rustdoc-toggle.non-exhaustive > summary::before {\n-\tfont-family: 'Fira Sans';\n-\tfont-size: 16px;\n-}\n-\n-details.non-exhaustive {\n-\tmargin-bottom: 8px;\n-}\n-\n-details.rustdoc-toggle > summary.hideme::before {\n-\tposition: relative;\n-}\n-\n-details.rustdoc-toggle > summary:not(.hideme)::before {\n-\tposition: absolute;\n-\tleft: -23px;\n-\ttop: initial;\n-}\n-\n-.impl-items > details.rustdoc-toggle > summary:not(.hideme)::before,\n-.undocumented > details.rustdoc-toggle > summary:not(.hideme)::before {\n-\tposition: absolute;\n-\ttop: 3px;\n-\tleft: -2px;\n-}\n-\n-/* When a \"hideme\" summary is open and the \"Expand description\" or \"Show\n-\tmethods\" text is hidden, we want the [-] toggle that remains to not\n-\taffect the layout of the items to its right. To do that, we use\n-\tabsolute positioning. Note that we also set position: relative\n-\ton the parent <details> to make this work properly. */\n-details.rustdoc-toggle[open] > summary.hideme {\n-\tposition: absolute;\n-}\n-\n-details.rustdoc-toggle, details.undocumented {\n-\tposition: relative;\n-}\n-\n-details.rustdoc-toggle[open] > summary.hideme > span {\n-\tdisplay: none;\n-}\n-\n-details.rustdoc-toggle[open] > summary::before {\n-\tcontent: \"[\u2212]\";\n-\tdisplay: inline;\n-}\n-\n-details.undocumented > summary::before {\n-\tcontent: \"[+] Show hidden undocumented items\";\n-\tcursor: pointer;\n-\tfont-size: 16px;\n-\tfont-weight: 300;\n-}\n-\n-details.undocumented[open] > summary::before {\n-\tcontent: \"[-] Hide undocumented items\";\n-}"}, {"sha": "c53b3d5f14bc644ce2f5bb1521943c51671b827b", "filename": "src/librustdoc/html/static/search.js", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -1,3 +1,6 @@\n+/* global addClass, getNakedUrl, getSettingValue, hasOwnPropertyRustdoc, initSearch, onEach */\n+/* global onEachLazy, removeClass, searchState, updateLocalStorage */\n+\n (function() {\n // This mapping table should match the discriminants of\n // `rustdoc::html::item_type::ItemType` type in Rust.\n@@ -170,7 +173,7 @@ window.initSearch = function(rawSearchIndex) {\n         function sortResults(results, isType) {\n             var ar = [];\n             for (var entry in results) {\n-                if (hasOwnProperty(results, entry)) {\n+                if (hasOwnPropertyRustdoc(results, entry)) {\n                     ar.push(results[entry]);\n                 }\n             }\n@@ -254,7 +257,7 @@ window.initSearch = function(rawSearchIndex) {\n             });\n \n             for (i = 0, len = results.length; i < len; ++i) {\n-                var result = results[i];\n+                result = results[i];\n \n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n@@ -301,7 +304,7 @@ window.initSearch = function(rawSearchIndex) {\n                 if (obj.length > GENERICS_DATA &&\n                       obj[GENERICS_DATA].length >= val.generics.length) {\n                     var elems = Object.create(null);\n-                    var elength = object[GENERICS_DATA].length;\n+                    var elength = obj[GENERICS_DATA].length;\n                     for (var x = 0; x < elength; ++x) {\n                         elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n                     }\n@@ -717,7 +720,7 @@ window.initSearch = function(rawSearchIndex) {\n             query.output = val;\n             query.search = val;\n             // gather matching search results up to a certain maximum\n-            val = val.replace(/\\_/g, \"\");\n+            val = val.replace(/_/g, \"\");\n \n             var valGenerics = extractGenerics(val);\n \n@@ -1242,7 +1245,9 @@ window.initSearch = function(rawSearchIndex) {\n     function getFilterCrates() {\n         var elem = document.getElementById(\"crate-search\");\n \n-        if (elem && elem.value !== \"All crates\" && hasOwnProperty(rawSearchIndex, elem.value)) {\n+        if (elem && elem.value !== \"All crates\" &&\n+            hasOwnPropertyRustdoc(rawSearchIndex, elem.value))\n+        {\n             return elem.value;\n         }\n         return undefined;\n@@ -1293,14 +1298,13 @@ window.initSearch = function(rawSearchIndex) {\n         var id = 0;\n \n         for (var crate in rawSearchIndex) {\n-            if (!hasOwnProperty(rawSearchIndex, crate)) { continue; }\n+            if (!hasOwnPropertyRustdoc(rawSearchIndex, crate)) {\n+                continue;\n+            }\n \n             var crateSize = 0;\n \n             searchWords.push(crate);\n-            var normalizedName = crate.indexOf(\"_\") === -1\n-                ? crate\n-                : crate.replace(/_/g, \"\");\n             // This object should have exactly the same set of fields as the \"row\"\n             // object defined below. Your JavaScript runtime will thank you.\n             // https://mathiasbynens.be/notes/shapes-ics\n@@ -1313,7 +1317,7 @@ window.initSearch = function(rawSearchIndex) {\n                 parent: undefined,\n                 type: null,\n                 id: id,\n-                normalizedName: normalizedName,\n+                normalizedName: crate.indexOf(\"_\") === -1 ? crate : crate.replace(/_/g, \"\"),\n             };\n             id += 1;\n             searchIndex.push(crateRow);\n@@ -1363,9 +1367,6 @@ window.initSearch = function(rawSearchIndex) {\n                     word = \"\";\n                     searchWords.push(\"\");\n                 }\n-                var normalizedName = word.indexOf(\"_\") === -1\n-                    ? word\n-                    : word.replace(/_/g, \"\");\n                 var row = {\n                     crate: crate,\n                     ty: itemTypes[i],\n@@ -1375,7 +1376,7 @@ window.initSearch = function(rawSearchIndex) {\n                     parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n                     type: itemFunctionSearchTypes[i],\n                     id: id,\n-                    normalizedName: normalizedName,\n+                    normalizedName: word.indexOf(\"_\") === -1 ? word : word.replace(/_/g, \"\"),\n                 };\n                 id += 1;\n                 searchIndex.push(row);\n@@ -1387,9 +1388,11 @@ window.initSearch = function(rawSearchIndex) {\n                 ALIASES[crate] = {};\n                 var j, local_aliases;\n                 for (var alias_name in aliases) {\n-                    if (!aliases.hasOwnProperty(alias_name)) { continue; }\n+                    if (!hasOwnPropertyRustdoc(aliases, alias_name)) {\n+                        continue;\n+                    }\n \n-                    if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n+                    if (!hasOwnPropertyRustdoc(ALIASES[crate], alias_name)) {\n                         ALIASES[crate][alias_name] = [];\n                     }\n                     local_aliases = aliases[alias_name];"}, {"sha": "4d9a59f836b9e1b0d2604a95dbfe8883ac93111d", "filename": "src/librustdoc/html/static/source-script.js", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsource-script.js?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -2,7 +2,8 @@\n /* global search, sourcesIndex */\n \n // Local js definitions:\n-/* global addClass, getCurrentValue, hasClass, removeClass, updateLocalStorage */\n+/* global addClass, getCurrentValue, hasClass, onEachLazy, removeClass, searchState */\n+/* global updateLocalStorage */\n (function() {\n \n function getCurrentFilePath() {\n@@ -153,7 +154,7 @@ function createSourceSidebar() {\n \n var lineNumbersRegex = /^#?(\\d+)(?:-(\\d+))?$/;\n \n-function highlightSourceLines(match, ev) {\n+function highlightSourceLines(scrollTo, match) {\n     if (typeof match === \"undefined\") {\n         match = window.location.hash.match(lineNumbersRegex);\n     }\n@@ -174,7 +175,7 @@ function highlightSourceLines(match, ev) {\n     if (!elem) {\n         return;\n     }\n-    if (!ev) {\n+    if (scrollTo) {\n         var x = document.getElementById(from);\n         if (x) {\n             x.scrollIntoView();\n@@ -202,7 +203,7 @@ var handleSourceHighlight = (function() {\n             y = window.scrollY;\n         if (searchState.browserSupportsHistoryApi()) {\n             history.replaceState(null, null, \"#\" + name);\n-            highlightSourceLines();\n+            highlightSourceLines(true);\n         } else {\n             location.replace(\"#\" + name);\n         }\n@@ -234,15 +235,15 @@ var handleSourceHighlight = (function() {\n window.addEventListener(\"hashchange\", function() {\n     var match = window.location.hash.match(lineNumbersRegex);\n     if (match) {\n-        return highlightSourceLines(match, ev);\n+        return highlightSourceLines(false, match);\n     }\n });\n \n onEachLazy(document.getElementsByClassName(\"line-numbers\"), function(el) {\n     el.addEventListener(\"click\", handleSourceHighlight);\n });\n \n-highlightSourceLines();\n+highlightSourceLines(true);\n \n window.createSourceSidebar = createSourceSidebar;\n })();"}, {"sha": "2eaa81a97d8c5e46f59d1441a4f0bae37eed007e", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -84,7 +84,7 @@ function onEachLazy(lazyArray, func, reversed) {\n }\n \n // eslint-disable-next-line no-unused-vars\n-function hasOwnProperty(obj, property) {\n+function hasOwnPropertyRustdoc(obj, property) {\n     return Object.prototype.hasOwnProperty.call(obj, property);\n }\n "}, {"sha": "5ac43c736462257f12cd7bbb5184b90184da56ff", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -14,9 +14,8 @@ use rustc_span::Pos;\n \n use rustdoc_json_types::*;\n \n-use crate::clean;\n use crate::clean::utils::print_const_expr;\n-use crate::clean::FakeDefId;\n+use crate::clean::{self, FakeDefId};\n use crate::formats::item_type::ItemType;\n use crate::json::JsonRenderer;\n use std::collections::HashSet;\n@@ -31,7 +30,7 @@ impl JsonRenderer<'_> {\n             .into_iter()\n             .flatten()\n             .filter_map(|clean::ItemLink { link, did, .. }| {\n-                did.map(|did| (link.clone(), from_def_id(did)))\n+                did.map(|did| (link.clone(), from_def_id(did.into())))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();"}, {"sha": "f8bd971081395a126f771a8bbc9921d3d20de4cd", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -12,13 +12,14 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n \n use rustdoc_json_types as types;\n \n use crate::clean;\n-use crate::clean::{ExternalCrate, FakeDefId};\n+use crate::clean::ExternalCrate;\n use crate::config::RenderOptions;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -42,7 +43,7 @@ impl JsonRenderer<'tcx> {\n         self.tcx.sess\n     }\n \n-    fn get_trait_implementors(&mut self, id: FakeDefId) -> Vec<types::Id> {\n+    fn get_trait_implementors(&mut self, id: DefId) -> Vec<types::Id> {\n         Rc::clone(&self.cache)\n             .implementors\n             .get(&id)\n@@ -59,10 +60,10 @@ impl JsonRenderer<'tcx> {\n             .unwrap_or_default()\n     }\n \n-    fn get_impls(&mut self, id: FakeDefId) -> Vec<types::Id> {\n+    fn get_impls(&mut self, id: DefId) -> Vec<types::Id> {\n         Rc::clone(&self.cache)\n             .impls\n-            .get(&id.expect_real())\n+            .get(&id)\n             .map(|impls| {\n                 impls\n                     .iter()\n@@ -163,11 +164,11 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n-                t.implementors = self.get_trait_implementors(id)\n+                t.implementors = self.get_trait_implementors(id.expect_real())\n             } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id)\n+                s.impls = self.get_impls(id.expect_real())\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id)\n+                e.impls = self.get_impls(id.expect_real())\n             }\n             let removed = self.index.borrow_mut().insert(from_def_id(id), new_item.clone());\n "}, {"sha": "88207b67743cf57233420100d32291da3ee79040", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -30,9 +30,7 @@ use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{\n-    self, utils::find_nearest_parent_module, Crate, FakeDefId, Item, ItemLink, PrimitiveType,\n-};\n+use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n@@ -248,7 +246,7 @@ enum AnchorFailure {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n-    module_id: FakeDefId,\n+    module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n     extra_fragment: Option<String>,\n@@ -274,7 +272,7 @@ struct LinkCollector<'a, 'tcx> {\n     ///\n     /// The last module will be used if the parent scope of the current item is\n     /// unknown.\n-    mod_ids: Vec<FakeDefId>,\n+    mod_ids: Vec<DefId>,\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n@@ -861,7 +859,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.def_id);\n+            self.mod_ids.push(item.def_id.expect_real());\n         }\n \n         // We want to resolve in the lexical scope of the documentation.\n@@ -888,7 +886,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         Some(if item.is_mod() {\n             if !inner_docs {\n-                self.mod_ids.push(item.def_id);\n+                self.mod_ids.push(item.def_id.expect_real());\n             }\n \n             let ret = self.fold_item_recur(item);\n@@ -1070,11 +1068,8 @@ impl LinkCollector<'_, '_> {\n         // we've already pushed this node onto the resolution stack but\n         // for outer comments we explicitly try and resolve against the\n         // parent_node first.\n-        let base_node = if item.is_mod() && inner_docs {\n-            self.mod_ids.last().copied()\n-        } else {\n-            parent_node.map(|id| FakeDefId::new_real(id))\n-        };\n+        let base_node =\n+            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n \n         let mut module_id = if let Some(id) = base_node {\n             id\n@@ -1119,7 +1114,7 @@ impl LinkCollector<'_, '_> {\n                 resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n                 path_str = &resolved_self;\n             }\n-            module_id = FakeDefId::new_real(DefId { krate, index: CRATE_DEF_INDEX });\n+            module_id = DefId { krate, index: CRATE_DEF_INDEX };\n         }\n \n         let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n@@ -1180,8 +1175,8 @@ impl LinkCollector<'_, '_> {\n             report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, callback);\n         };\n \n-        let verify = |kind: DefKind, id: FakeDefId| {\n-            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id.expect_real()));\n+        let verify = |kind: DefKind, id: DefId| {\n+            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id));\n             debug!(\"intra-doc link to {} resolved to {:?} (id: {:?})\", path_str, res, id);\n \n             // Disallow e.g. linking to enums with `struct@`\n@@ -1345,7 +1340,7 @@ impl LinkCollector<'_, '_> {\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, expected_ns, base_node.expect_real(), extra_fragment) {\n+                match self.resolve(path_str, expected_ns, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1354,12 +1349,9 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n-                                if let Some(res) = self.check_full_res(\n-                                    new_ns,\n-                                    path_str,\n-                                    base_node.expect_real(),\n-                                    extra_fragment,\n-                                ) {\n+                                if let Some(res) =\n+                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n+                                {\n                                     kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n                                     break;\n                                 }\n@@ -1381,14 +1373,9 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .resolve_macro(path_str, base_node.expect_real())\n+                        .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(\n-                        path_str,\n-                        TypeNS,\n-                        base_node.expect_real(),\n-                        extra_fragment,\n-                    ) {\n+                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1399,12 +1386,7 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(\n-                        path_str,\n-                        ValueNS,\n-                        base_node.expect_real(),\n-                        extra_fragment,\n-                    ) {\n+                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, diag, msg);\n@@ -1460,17 +1442,14 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.resolve_macro(path_str, base_node.expect_real()) {\n+                match self.resolve_macro(path_str, base_node) {\n                     Ok(res) => Some((res, extra_fragment.clone())),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n-                            if let Some(res) = self.check_full_res(\n-                                ns,\n-                                path_str,\n-                                base_node.expect_real(),\n-                                extra_fragment,\n-                            ) {\n+                            if let Some(res) =\n+                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n+                            {\n                                 kind =\n                                     ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n                                 break;"}, {"sha": "9b7e10b2688bb71bf58e200627da73444ac8181e", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -126,7 +126,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n         // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n         // `Deref` target type and the impl for type positions, this map of types is keyed by\n         // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-        if cleaner.keep_impl_with_def_id(&FakeDefId::new_real(*type_did)) {\n+        if cleaner.keep_impl_with_def_id(FakeDefId::Real(*type_did)) {\n             add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n         }\n     }\n@@ -206,13 +206,13 @@ impl BadImplStripper {\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id() {\n-            self.keep_impl_with_def_id(&did.into())\n+            self.keep_impl_with_def_id(did.into())\n         } else {\n             false\n         }\n     }\n \n-    fn keep_impl_with_def_id(&self, did: &FakeDefId) -> bool {\n-        self.items.contains(did)\n+    fn keep_impl_with_def_id(&self, did: FakeDefId) -> bool {\n+        self.items.contains(&did)\n     }\n }"}, {"sha": "87573e8e037a96c22d546d48647b19c735d65727", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -4,7 +4,7 @@ use std::mem;\n use crate::clean;\n use crate::clean::{FakeDefIdSet, Item, NestedAttributesExt};\n use crate::core::DocContext;\n-use crate::fold::{DocFolder, StripItem};\n+use crate::fold::{strip_item, DocFolder};\n use crate::passes::{ImplStripper, Pass};\n \n crate const STRIP_HIDDEN: Pass = Pass {\n@@ -44,7 +44,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                     // strip things like impl methods but when doing so\n                     // we must not add any items to the `retained` set.\n                     let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = StripItem(self.fold_item_recur(i)).strip();\n+                    let ret = strip_item(self.fold_item_recur(i));\n                     self.update_retained = old;\n                     return Some(ret);\n                 }"}, {"sha": "528518410aa0680a7c0dc24cd7e2cfba1b891b22", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::middle::privacy::AccessLevels;\n use std::mem;\n \n use crate::clean::{self, FakeDefIdSet, GetDefId, Item};\n-use crate::fold::{DocFolder, StripItem};\n+use crate::fold::{strip_item, DocFolder};\n \n crate struct Stripper<'a> {\n     crate retained: &'a mut FakeDefIdSet,\n@@ -51,15 +51,15 @@ impl<'a> DocFolder for Stripper<'a> {\n \n             clean::StructFieldItem(..) => {\n                 if !i.visibility.is_public() {\n-                    return Some(StripItem(i).strip());\n+                    return Some(strip_item(i));\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n                 if i.def_id.is_local() && !i.visibility.is_public() {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = StripItem(self.fold_item_recur(i)).strip();\n+                    let ret = strip_item(self.fold_item_recur(i));\n                     self.update_retained = old;\n                     return Some(ret);\n                 }"}, {"sha": "fcdfc0344db809db9fb41e38a45642e6b639a763", "filename": "src/test/rustdoc-gui/toggle-docs-mobile.goml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -0,0 +1,21 @@\n+goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n+size: (433, 600)\n+assert: (\".top-doc\", \"open\", \"\")\n+click: (4, 280) // This is the position of the top doc comment toggle\n+assert-false: (\".top-doc\", \"open\", \"\")\n+click: (4, 280)\n+assert: (\".top-doc\", \"open\", \"\")\n+// To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n+click: (3, 280)\n+assert: (\".top-doc\", \"open\", \"\")\n+\n+// Now we do the same but with a little bigger width\n+size: (600, 600)\n+assert: (\".top-doc\", \"open\", \"\")\n+click: (4, 240) // New Y position since all search elements are back on one line.\n+assert-false: (\".top-doc\", \"open\", \"\")\n+click: (4, 240)\n+assert: (\".top-doc\", \"open\", \"\")\n+// To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n+click: (3, 240)\n+assert: (\".top-doc\", \"open\", \"\")"}, {"sha": "86b16f8b0e60d8bba1d879c66fe6b37db9ed88c6", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "patch": "@@ -267,9 +267,10 @@ function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n                            \"handleAliases\", \"getQuery\", \"buildIndex\", \"execQuery\", \"execSearch\",\n                            \"removeEmptyStringsFromArray\"];\n \n+    const functions = [\"hasOwnPropertyRustdoc\", \"onEach\"];\n     ALIASES = {};\n     finalJS += 'window = { \"currentCrate\": \"' + crate + '\", rootPath: \"../\" };\\n';\n-    finalJS += loadThings([\"hasOwnProperty\", \"onEach\"], 'function', extractFunction, storageJs);\n+    finalJS += loadThings(functions, 'function', extractFunction, storageJs);\n     finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, searchJs);\n     finalJS += loadThings(variablesToLoad, 'variable', extractVariable, searchJs);\n     finalJS += loadThings(functionsToLoad, 'function', extractFunction, searchJs);"}]}