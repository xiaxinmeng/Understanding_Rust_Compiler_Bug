{"sha": "d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "node_id": "C_kwDOAAsO6NoAKGQ4YjFlYzZhMjVkODAwNjkxZGE1MGZhNzgzNGY4ZGIyYTJmMTI0YjY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T14:43:02Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T14:43:02Z"}, "message": "Remove unnecessary option wrapping", "tree": {"sha": "f546bd4c4bab783437cf9f304ecf931798138cfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f546bd4c4bab783437cf9f304ecf931798138cfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "html_url": "https://github.com/rust-lang/rust/commit/d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8b1ec6a25d800691da50fa7834f8db2a2f124b6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27fad2ad751bc813a98db18d8c31ea3cb178d228", "url": "https://api.github.com/repos/rust-lang/rust/commits/27fad2ad751bc813a98db18d8c31ea3cb178d228", "html_url": "https://github.com/rust-lang/rust/commit/27fad2ad751bc813a98db18d8c31ea3cb178d228"}], "stats": {"total": 23, "additions": 11, "deletions": 12}, "files": [{"sha": "891e1fab2ed478622ae1883889e759aabdb10167", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8b1ec6a25d800691da50fa7834f8db2a2f124b6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b1ec6a25d800691da50fa7834f8db2a2f124b6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "patch": "@@ -35,17 +35,17 @@ impl<'a> InferenceContext<'a> {\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n             let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n             let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n-            self.resolve_ty_assoc_item(ty, last.name, id)?\n+            self.resolve_ty_assoc_item(ty, last.name, id).map(|(it, substs)| (it, Some(substs)))?\n         } else {\n             // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n                 self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),\n-                ResolveValueResult::Partial(def, remaining_index) => {\n-                    self.resolve_assoc_item(def, path, remaining_index, id)?\n-                }\n+                ResolveValueResult::Partial(def, remaining_index) => self\n+                    .resolve_assoc_item(def, path, remaining_index, id)\n+                    .map(|(it, substs)| (it, Some(substs)))?,\n             }\n         };\n \n@@ -113,7 +113,7 @@ impl<'a> InferenceContext<'a> {\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         assert!(remaining_index < path.segments().len());\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n@@ -166,7 +166,7 @@ impl<'a> InferenceContext<'a> {\n         trait_ref: TraitRef,\n         segment: PathSegment<'_>,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         let trait_ = trait_ref.hir_trait_id();\n         let item =\n             self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id)).find_map(|item| {\n@@ -202,16 +202,15 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         self.write_assoc_resolution(id, item, trait_ref.substitution.clone());\n-        Some((def, Some(trait_ref.substitution)))\n+        Some((def, trait_ref.substitution))\n     }\n \n-    // FIXME: Change sig to -> Option<(ValueNs, Substitution)>, subs aren't optional from here anymore\n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         if let TyKind::Error = ty.kind(Interner) {\n             return None;\n         }\n@@ -280,15 +279,15 @@ impl<'a> InferenceContext<'a> {\n         if !visible {\n             self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item });\n         }\n-        Some((def, Some(substs)))\n+        Some((def, substs))\n     }\n \n     fn resolve_enum_variant_on_ty(\n         &mut self,\n         ty: &Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         let ty = self.resolve_ty_shallow(ty);\n         let (enum_id, subst) = match ty.as_adt() {\n             Some((AdtId::EnumId(e), subst)) => (e, subst),\n@@ -298,6 +297,6 @@ impl<'a> InferenceContext<'a> {\n         let local_id = enum_data.variant(name)?;\n         let variant = EnumVariantId { parent: enum_id, local_id };\n         self.write_variant_resolution(id, variant.into());\n-        Some((ValueNs::EnumVariantId(variant), Some(subst.clone())))\n+        Some((ValueNs::EnumVariantId(variant), subst.clone()))\n     }\n }"}]}