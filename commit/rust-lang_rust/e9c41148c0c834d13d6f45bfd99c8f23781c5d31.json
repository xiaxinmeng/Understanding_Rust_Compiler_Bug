{"sha": "e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YzQxMTQ4YzBjODM0ZDEzZDZmNDViZmQ5OWM4ZjIzNzgxYzVkMzE=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-07-29T22:07:28Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-09-09T21:16:49Z"}, "message": "Convert Place's projection to a boxed slice", "tree": {"sha": "2a320e3101debf4bab12c6f07c434a0ab4328a9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a320e3101debf4bab12c6f07c434a0ab4328a9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAl12wUEACgkQiMlBzaHU\nZDLRehAAgeSW8wIPEhrctKJc89Lj1E2ozb+pz1ebt+F4eELPgnndnUocOWgm/eg5\n01o88pPD4hZPwIAFYkdhjoJZcz2IWN0NXcLqmiBP/x6XWRxxFJNAvg9sZ/fU78Ez\nCoc5WL3IGrxvNe3JrGkmhcyT1yOVKAV2JI8CV4v/U42KC20M7E5ouJlQdiI1Ce83\n2m8jqAf9rvSeBpkb/QVyIAFX2/1RBqTyakd1l6DRPrmINjA+iiPS2zW8JjfcTUpY\ntQ6wmYBcrIi5J6/EcCz4/FLeBFoUy8M5KfqZZV6aUwXID2oKArU5t3Vx7L4aeqlV\n6QDg40iDhQyfvhMbXMXIzNPlBEpBWtjL9UPXkNbG5Ff3PWJ4C8NHzGZ6MomvSWQc\nJSvxa6QNOHutSxr7UIFJoW//5lhqdK4zKVo1/n/TK5KZEQrG4KbZqHHfKE84noXN\nQA9otkGop9rfnEb85o7mHtsXPerfS6plNtGENapDO57Z2khOGA091DwaUt7/RwHc\nQEOqMY9E9Cl/tnX0AZs2BCJ7Q2rYKxLNainQGRM4p4wAXaAOvLyfItOxTbsNutq5\nB/LhOmO2GaMY/6B++Ob0Q3HrXa+sf8h9CiUc/gsv6+2h86DIPZUy0e9cnDUIvK1Z\nLD7QlspNI/NptpM0obUFZ9zNDC/t/tUypnRKYttcdtCAcb9hgts=\n=vTox\n-----END PGP SIGNATURE-----", "payload": "tree 2a320e3101debf4bab12c6f07c434a0ab4328a9e\nparent 824383d4ab66abd32abc6e19b68d78ecfddcb7d4\nauthor Santiago Pastorino <spastorino@gmail.com> 1564438048 +0200\ncommitter Santiago Pastorino <spastorino@gmail.com> 1568063809 -0300\n\nConvert Place's projection to a boxed slice\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "html_url": "https://github.com/rust-lang/rust/commit/e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "824383d4ab66abd32abc6e19b68d78ecfddcb7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/824383d4ab66abd32abc6e19b68d78ecfddcb7d4", "html_url": "https://github.com/rust-lang/rust/commit/824383d4ab66abd32abc6e19b68d78ecfddcb7d4"}], "stats": {"total": 2969, "additions": 1399, "deletions": 1570}, "files": [{"sha": "602ce12c37d818c2bf0e536d189378c731a964c3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 82, "deletions": 208, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -32,7 +32,6 @@ use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n use std::vec::IntoIter;\n@@ -1548,7 +1547,7 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Statement<'_>, 56);\n+static_assert_size!(Statement<'_>, 64);\n \n impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -1717,7 +1716,7 @@ pub struct Place<'tcx> {\n     pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: Option<Box<Projection<'tcx>>>,\n+    pub projection: Box<[PlaceElem<'tcx>]>,\n }\n \n #[derive(\n@@ -1760,15 +1759,6 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     def_id\n });\n \n-/// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n-pub struct Projection<'tcx> {\n-    pub base: Option<Box<Projection<'tcx>>>,\n-    pub elem: PlaceElem<'tcx>,\n-}\n-\n #[derive(\n     Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n@@ -1850,14 +1840,22 @@ newtype_index! {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n     pub base: &'a PlaceBase<'tcx>,\n-    pub projection: &'a Option<Box<Projection<'tcx>>>,\n+    pub projection: &'a [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub const RETURN_PLACE: Place<'tcx> = Place {\n-        base: PlaceBase::Local(RETURN_PLACE),\n-        projection: None,\n-    };\n+    // FIXME change this back to a const when projection is a shared slice.\n+    //\n+    // pub const RETURN_PLACE: Place<'tcx> = Place {\n+    //     base: PlaceBase::Local(RETURN_PLACE),\n+    //     projection: &[],\n+    // };\n+    pub fn return_place() -> Place<'tcx> {\n+        Place {\n+            base: PlaceBase::Local(RETURN_PLACE),\n+            projection: Box::new([]),\n+        }\n+    }\n \n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n@@ -1883,9 +1881,13 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        // FIXME(spastorino): revisit this again once projection is not a Box<[T]> anymore\n+        let mut projection = self.projection.into_vec();\n+        projection.push(elem);\n+\n         Place {\n             base: self.base,\n-            projection: Some(Box::new(Projection { base: self.projection, elem })),\n+            projection: projection.into_boxed_slice(),\n         }\n     }\n \n@@ -1894,7 +1896,7 @@ impl<'tcx> Place<'tcx> {\n     /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n     /// same region of memory as its base.\n     pub fn is_indirect(&self) -> bool {\n-        self.iterate(|_, mut projections| projections.any(|proj| proj.elem.is_indirect()))\n+        self.projection.iter().any(|elem| elem.is_indirect())\n     }\n \n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n@@ -1905,61 +1907,16 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             } |\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: box [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n \n-    /// Recursively \"iterates\" over place components, generating a `PlaceBase` and\n-    /// `Projections` list and invoking `op` with a `ProjectionsIter`.\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(&self.base, &self.projection, op)\n-    }\n-\n-    pub fn iterate_over<R>(\n-        place_base: &PlaceBase<'tcx>,\n-        place_projection: &Option<Box<Projection<'tcx>>>,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        fn iterate_over2<'tcx, R>(\n-            place_base: &PlaceBase<'tcx>,\n-            place_projection: &Option<Box<Projection<'tcx>>>,\n-            next: &Projections<'_, 'tcx>,\n-            op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-        ) -> R {\n-            match place_projection {\n-                None => {\n-                    op(place_base, next.iter())\n-                }\n-\n-                Some(interior) => {\n-                    iterate_over2(\n-                        place_base,\n-                        &interior.base,\n-                        &Projections::List {\n-                            projection: interior,\n-                            next,\n-                        },\n-                        op,\n-                    )\n-                }\n-            }\n-        }\n-\n-        iterate_over2(place_base, place_projection, &Projections::Empty, op)\n-    }\n-\n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n         PlaceRef {\n             base: &self.base,\n@@ -1972,7 +1929,7 @@ impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n         Place {\n             base: local.into(),\n-            projection: None,\n+            projection: Box::new([]),\n         }\n     }\n }\n@@ -1984,13 +1941,6 @@ impl From<Local> for PlaceBase<'_> {\n }\n \n impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(self.base, self.projection, op)\n-    }\n-\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //\n@@ -1999,143 +1949,71 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n         match self {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } |\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n }\n \n-/// A linked list of projections running up the stack; begins with the\n-/// innermost projection and extends to the outermost (e.g., `a.b.c`\n-/// would have the place `b` with a \"next\" pointer to `b.c`).\n-/// Created by `Place::iterate`.\n-///\n-/// N.B., this particular impl strategy is not the most obvious. It was\n-/// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-pub enum Projections<'p, 'tcx> {\n-    Empty,\n-\n-    List { projection: &'p Projection<'tcx>, next: &'p Projections<'p, 'tcx> },\n-}\n-\n-impl<'p, 'tcx> Projections<'p, 'tcx> {\n-    fn iter(&self) -> ProjectionsIter<'_, 'tcx> {\n-        ProjectionsIter { value: self }\n-    }\n-}\n-\n-impl<'p, 'tcx> IntoIterator for &'p Projections<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-    type IntoIter = ProjectionsIter<'p, 'tcx>;\n-\n-    /// Converts a list of `Projection` components into an iterator;\n-    /// this iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermost\" projection and then with each\n-    /// projection therefrom. So given a place like `a.b.c` it would\n-    /// yield up:\n-    ///\n-    /// ```notrust\n-    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n-    /// ```\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-/// Iterator over components; see `Projections::iter` for more\n-/// information.\n-///\n-/// N.B., this is not a *true* Rust iterator -- the code above just\n-/// manually invokes `next`. This is because we (sometimes) want to\n-/// keep executing even after `None` has been returned.\n-pub struct ProjectionsIter<'p, 'tcx> {\n-    pub value: &'p Projections<'p, 'tcx>,\n-}\n-\n-impl<'p, 'tcx> Iterator for ProjectionsIter<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let &Projections::List { projection, next } = self.value {\n-            self.value = next;\n-            Some(projection)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'p, 'tcx> FusedIterator for ProjectionsIter<'p, 'tcx> {}\n-\n impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        self.iterate(|_place_base, place_projections| {\n-            // FIXME: remove this collect once we have migrated to slices\n-            let projs_vec: Vec<_> = place_projections.collect();\n-            for projection in projs_vec.iter().rev() {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n-                        write!(fmt, \"(\").unwrap();\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \"(*\").unwrap();\n-                    }\n-                    ProjectionElem::Index(_)\n-                    | ProjectionElem::ConstantIndex { .. }\n-                    | ProjectionElem::Subslice { .. } => {}\n+        for elem in self.projection.iter().rev() {\n+            match elem {\n+                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n+                    write!(fmt, \"(\").unwrap();\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \"(*\").unwrap();\n                 }\n+                ProjectionElem::Index(_)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {}\n             }\n-        });\n+        }\n \n-        self.iterate(|place_base, place_projections| {\n-            write!(fmt, \"{:?}\", place_base)?;\n+        write!(fmt, \"{:?}\", self.base)?;\n \n-            for projection in place_projections {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(Some(name), _index) => {\n-                        write!(fmt, \" as {})\", name)?;\n-                    }\n-                    ProjectionElem::Downcast(None, index) => {\n-                        write!(fmt, \" as variant#{:?})\", index)?;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \")\")?;\n-                    }\n-                    ProjectionElem::Field(field, ty) => {\n-                        write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n-                    }\n-                    ProjectionElem::Index(ref index) => {\n-                        write!(fmt, \"[{:?}]\", index)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n-                        write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n-                        write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if to == 0 => {\n-                        write!(fmt, \"[{:?}:]\", from)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if from == 0 => {\n-                        write!(fmt, \"[:-{:?}]\", to)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } => {\n-                        write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n-                    }\n+        for elem in self.projection.iter() {\n+            match elem {\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \" as {})\", name)?;\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \" as variant#{:?})\", index)?;\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \")\")?;\n+                }\n+                ProjectionElem::Field(field, ty) => {\n+                    write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n+                }\n+                ProjectionElem::Index(ref index) => {\n+                    write!(fmt, \"[{:?}]\", index)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n+                    write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n+                    write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *to == 0 => {\n+                    write!(fmt, \"[{:?}:]\", from)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *from == 0 => {\n+                    write!(fmt, \"[:-{:?}]\", to)?;\n+                }\n+                ProjectionElem::Subslice { from, to } => {\n+                    write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n                 }\n             }\n+        }\n \n-            Ok(())\n-        })\n+        Ok(())\n     }\n }\n \n@@ -3409,30 +3287,26 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n-        let base = self.base.fold_with(folder);\n-        let elem = match self.elem {\n+        match self {\n             Deref => Deref,\n-            Field(f, ref ty) => Field(f, ty.fold_with(folder)),\n-            Index(ref v) => Index(v.fold_with(folder)),\n-            ref elem => elem.clone(),\n-        };\n-\n-        Projection { base, elem }\n+            Field(f, ty) => Field(*f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            elem => elem.clone(),\n+        }\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use crate::mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor)\n-            || match self.elem {\n-                Field(_, ref ty) => ty.visit_with(visitor),\n-                Index(ref v) => v.visit_with(visitor),\n-                _ => false,\n-            }\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n     }\n }\n "}, {"sha": "fbe25de0e762ca2d69ff3268b02e17dda5545d70", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -121,21 +121,19 @@ BraceStructTypeFoldableImpl! {\n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n         base: &PlaceBase<'tcx>,\n-        projection: &Option<Box<Projection<'tcx>>>,\n+        projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>\n     ) -> PlaceTy<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n-        Place::iterate_over(base, projection, |place_base, place_projections| {\n-            let mut place_ty = place_base.ty(local_decls);\n+        let mut place_ty = base.ty(local_decls);\n \n-            for proj in place_projections {\n-                place_ty = place_ty.projection_ty(tcx, &proj.elem);\n-            }\n+        for elem in projection.iter() {\n+            place_ty = place_ty.projection_ty(tcx, elem);\n+        }\n \n-            place_ty\n-        })\n+        place_ty\n     }\n \n     pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>"}, {"sha": "36aa891aaf4aa6e2ff1cb18773256f1880017487", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -152,18 +152,18 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_place_base(place_base, context, location);\n+                self.super_place_base(base, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                place: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place_base, place, context, location);\n+                self.super_projection(base, projection, context, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -685,7 +685,7 @@ macro_rules! make_mir_visitor {\n                             location: Location) {\n                 let mut context = context;\n \n-                if place.projection.is_some() {\n+                if !place.projection.is_empty() {\n                     context = if context.is_mutating_use() {\n                         PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                     } else {\n@@ -695,9 +695,10 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_place_base(& $($mutability)? place.base, context, location);\n \n-                if let Some(box proj) = & $($mutability)? place.projection {\n-                    self.visit_projection(& $($mutability)? place.base, proj, context, location);\n-                }\n+                self.visit_projection(& $($mutability)? place.base,\n+                                      & $($mutability)? place.projection,\n+                                      context,\n+                                      location);\n             }\n \n             fn super_place_base(&mut self,\n@@ -715,31 +716,34 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                proj: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                if let Some(box proj_base) = & $($mutability)? proj.base {\n-                    self.visit_projection(place_base, proj_base, context, location);\n-                }\n-\n-                match & $($mutability)? proj.elem {\n-                    ProjectionElem::Field(_field, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n-                    }\n-                    ProjectionElem::Index(local) => {\n-                        self.visit_local(\n-                            local,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                            location\n-                        );\n-                    }\n-                    ProjectionElem::Deref |\n-                    ProjectionElem::Subslice { from: _, to: _ } |\n-                    ProjectionElem::ConstantIndex { offset: _,\n-                                                    min_length: _,\n-                                                    from_end: _ } |\n-                    ProjectionElem::Downcast(_, _) => {\n+                if !projection.is_empty() {\n+                    let proj_len = projection.len();\n+                    let proj_base = & $($mutability)? projection[..proj_len - 1];\n+                    self.visit_projection(base, proj_base, context, location);\n+\n+                    let elem = & $($mutability)? projection[proj_len - 1];\n+                    match elem {\n+                        ProjectionElem::Field(_field, ty) => {\n+                            self.visit_ty(ty, TyContext::Location(location));\n+                        }\n+                        ProjectionElem::Index(local) => {\n+                            self.visit_local(\n+                                local,\n+                                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                                location\n+                            );\n+                        }\n+                        ProjectionElem::Deref |\n+                        ProjectionElem::Subslice { from: _, to: _ } |\n+                        ProjectionElem::ConstantIndex { offset: _,\n+                                                        min_length: _,\n+                                                        from_end: _ } |\n+                        ProjectionElem::Downcast(_, _) => {\n+                        }\n                     }\n                 }\n             }"}, {"sha": "1708d7235b45b1d56badb6b3d7288d32b2bca6f4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -4,6 +4,7 @@\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n+#![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]"}, {"sha": "5449dbdc913b8951954f699db02a80c27385de27", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -105,7 +105,10 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     ) {\n         let cx = self.fx.cx;\n \n-        if let Some(proj) = place_ref.projection {\n+        if let [.., elem] = place_ref.projection {\n+            // FIXME(spastorino) include this in the pattern when stabilized\n+            let proj_base = &place_ref.projection[..place_ref.projection.len() - 1];\n+\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n                 PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n@@ -114,12 +117,12 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, &proj.base, self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n-                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .projection_ty(cx.tcx(), elem)\n                     .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 let span = if let mir::PlaceBase::Local(index) = place_ref.base {\n@@ -131,7 +134,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     return;\n                 }\n \n-                if let mir::ProjectionElem::Field(..) = proj.elem {\n+                if let mir::ProjectionElem::Field(..) = elem {\n                     let layout = cx.spanned_layout_of(base_ty.ty, span);\n                     if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n@@ -140,7 +143,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                         self.process_place(\n                             &mir::PlaceRef {\n                                 base: place_ref.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             context,\n                             location,\n@@ -151,11 +154,11 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             }\n \n             // A deref projection only reads the pointer, never needs the place.\n-            if let mir::ProjectionElem::Deref = proj.elem {\n+            if let mir::ProjectionElem::Deref = elem {\n                 self.process_place(\n                     &mir::PlaceRef {\n                         base: place_ref.base,\n-                        projection: &proj.base,\n+                        projection: proj_base,\n                     },\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                     location\n@@ -168,7 +171,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         // visit_place API\n         let mut context = context;\n \n-        if place_ref.projection.is_some() {\n+        if !place_ref.projection.is_empty() {\n             context = if context.is_mutating_use() {\n                 PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             } else {\n@@ -177,10 +180,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         }\n \n         self.visit_place_base(place_ref.base, context, location);\n-\n-        if let Some(box proj) = place_ref.projection {\n-            self.visit_projection(place_ref.base, proj, context, location);\n-        }\n+        self.visit_projection(place_ref.base, place_ref.projection, context, location);\n     }\n \n }\n@@ -196,7 +196,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *place {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;"}, {"sha": "915006938fe566770ed312c477d42469cc70099a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n-                    self.codegen_consume(&mut bx, &mir::Place::RETURN_PLACE.as_ref());\n+                    self.codegen_consume(&mut bx, &mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -612,7 +612,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     ty,\n                                     def_id: _,\n                                 }),\n-                                projection: None,\n+                                projection: box [],\n                             }\n                         ) |\n                         mir::Operand::Move(\n@@ -622,7 +622,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     ty,\n                                     def_id: _,\n                                 }),\n-                                projection: None,\n+                                projection: box [],\n                             }\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n@@ -1105,7 +1105,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n         let dest = if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n@@ -1166,7 +1166,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) {\n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),"}, {"sha": "58a13d685ddf97e972f10a2f0c42e4bb8f2cd512", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -384,47 +384,45 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        place_ref.iterate(|place_base, place_projection| {\n-            if let mir::PlaceBase::Local(index) = place_base {\n-                match self.locals[*index] {\n-                    LocalRef::Operand(Some(mut o)) => {\n-                        // Moves out of scalar and scalar pair fields are trivial.\n-                        for proj in place_projection {\n-                            match proj.elem {\n-                                mir::ProjectionElem::Field(ref f, _) => {\n-                                    o = o.extract_field(bx, f.index());\n-                                }\n-                                mir::ProjectionElem::Index(_) |\n-                                mir::ProjectionElem::ConstantIndex { .. } => {\n-                                    // ZSTs don't require any actual memory access.\n-                                    // FIXME(eddyb) deduplicate this with the identical\n-                                    // checks in `codegen_consume` and `extract_field`.\n-                                    let elem = o.layout.field(bx.cx(), 0);\n-                                    if elem.is_zst() {\n-                                        o = OperandRef::new_zst(bx, elem);\n-                                    } else {\n-                                        return None;\n-                                    }\n+        if let mir::PlaceBase::Local(index) = place_ref.base {\n+            match self.locals[*index] {\n+                LocalRef::Operand(Some(mut o)) => {\n+                    // Moves out of scalar and scalar pair fields are trivial.\n+                    for elem in place_ref.projection.iter() {\n+                        match elem {\n+                            mir::ProjectionElem::Field(ref f, _) => {\n+                                o = o.extract_field(bx, f.index());\n+                            }\n+                            mir::ProjectionElem::Index(_) |\n+                            mir::ProjectionElem::ConstantIndex { .. } => {\n+                                // ZSTs don't require any actual memory access.\n+                                // FIXME(eddyb) deduplicate this with the identical\n+                                // checks in `codegen_consume` and `extract_field`.\n+                                let elem = o.layout.field(bx.cx(), 0);\n+                                if elem.is_zst() {\n+                                    o = OperandRef::new_zst(bx, elem);\n+                                } else {\n+                                    return None;\n                                 }\n-                                _ => return None,\n                             }\n+                            _ => return None,\n                         }\n-\n-                        Some(o)\n-                    }\n-                    LocalRef::Operand(None) => {\n-                        bug!(\"use of {:?} before def\", place_ref);\n-                    }\n-                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                        // watch out for locals that do not have an\n-                        // alloca; they are handled somewhat differently\n-                        None\n                     }\n+\n+                    Some(o)\n+                }\n+                LocalRef::Operand(None) => {\n+                    bug!(\"use of {:?} before def\", place_ref);\n+                }\n+                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                    // watch out for locals that do not have an\n+                    // alloca; they are handled somewhat differently\n+                    None\n                 }\n-            } else {\n-                None\n             }\n-        })\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn codegen_consume("}, {"sha": "df90da7ee8fae5ce6015b2b3fbc8e49dd949312d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let result = match &place_ref {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Local(index),\n-                projection: None,\n+                projection: [],\n             } => {\n                 match self.locals[*index] {\n                     LocalRef::Place(place) => {\n@@ -469,7 +469,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     kind: mir::StaticKind::Promoted(promoted, substs),\n                     def_id,\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let instance = Instance::new(*def_id, self.monomorphize(substs));\n@@ -504,7 +504,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     kind: mir::StaticKind::Static,\n                     def_id,\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n@@ -514,11 +514,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             },\n             mir::PlaceRef {\n                 base,\n-                projection: Some(box mir::Projection {\n-                    base: proj_base,\n-                    elem: mir::ProjectionElem::Deref,\n-                }),\n+                projection: [.., mir::ProjectionElem::Deref],\n             } => {\n+                let proj_base = &place_ref.projection[..place_ref.projection.len() - 1];\n+\n                 // Load the pointer from its location.\n                 self.codegen_consume(bx, &mir::PlaceRef {\n                     base,\n@@ -527,22 +526,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             mir::PlaceRef {\n                 base,\n-                projection: Some(projection),\n+                projection: [.., elem],\n             } => {\n+                let proj_base = &place_ref.projection[..place_ref.projection.len() - 1];\n+\n                 // FIXME turn this recursion into iteration\n                 let cg_base = self.codegen_place(bx, &mir::PlaceRef {\n                     base,\n-                    projection: &projection.base,\n+                    projection: proj_base,\n                 });\n \n-                match projection.elem {\n+                match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Copy(\n-                            mir::Place::from(index)\n+                            mir::Place::from(*index)\n                         );\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n@@ -551,27 +552,27 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(*offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(*offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            bx.cx().const_usize(from as u64));\n+                            bx.cx().const_usize(*from as u64));\n                         let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n-                            .projection_ty(tcx, &projection.elem).ty;\n+                            .projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((from as u64) + (to as u64))));\n+                                bx.cx().const_usize((*from as u64) + (*to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new\n@@ -582,7 +583,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         subslice\n                     }\n                     mir::ProjectionElem::Downcast(_, v) => {\n-                        cg_base.project_downcast(bx, v)\n+                        cg_base.project_downcast(bx, *v)\n                     }\n                 }\n             }"}, {"sha": "0a932bc3e157486ce948e01f31a18488e8b1a34f", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -522,7 +522,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {"}, {"sha": "b1bc57c2e90ec88fa85564585d16f0ac0073b05b", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -19,7 +19,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::StatementKind::Assign(ref place, ref rvalue) => {\n                 if let mir::Place {\n                     base: mir::PlaceBase::Local(index),\n-                    projection: None,\n+                    projection: box [],\n                 } = *place {\n                     match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {"}, {"sha": "db19cbc3175f8c60be5c0edbcdd637525134cc49", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         // so extract `temp`.\n         let temp = if let &mir::Place {\n             base: mir::PlaceBase::Local(temp),\n-            projection: None,\n+            projection: box [],\n         } = assigned_place {\n             temp\n         } else {"}, {"sha": "a6f7c8f227c99b03c42f1edfbe20718973e211b9", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -2,8 +2,8 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n+    Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -244,7 +244,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 let span = if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = place {\n                     let decl = &self.body.local_decls[*local];\n                     Some(decl.source_info.span)\n@@ -614,17 +614,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = first_borrowed_place;\n \n-                let mut current = projection;\n+                for (i, elem) in projection.iter().enumerate().rev() {\n+                    let base_proj = &projection[..i];\n \n-                while let Some(box Projection { base: base_proj, elem }) = current {\n                     match elem {\n                         ProjectionElem::Field(field, _) if union_ty(base, base_proj).is_some() => {\n                             return Some((PlaceRef {\n                                 base: base,\n                                 projection: base_proj,\n                             }, field));\n                         },\n-                        _ => current = base_proj,\n+                        _ => {},\n                     }\n                 }\n                 None\n@@ -637,9 +637,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = second_borrowed_place;\n \n-                let mut current = projection;\n+                for (i, elem) in projection.iter().enumerate().rev() {\n+                    let proj_base = &projection[..i];\n \n-                while let Some(box Projection { base: proj_base, elem }) = current {\n                     if let ProjectionElem::Field(field, _) = elem {\n                         if let Some(union_ty) = union_ty(base, proj_base) {\n                             if field != target_field\n@@ -660,8 +660,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         }\n                     }\n-\n-                    current = proj_base;\n                 }\n                 None\n             })\n@@ -707,7 +705,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        assert!(root_place.projection.is_none());\n+        assert!(root_place.projection.is_empty());\n         let proper_span = match root_place.base {\n             PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n             _ => drop_span,\n@@ -716,7 +714,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if self.access_place_error_reported\n             .contains(&(Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.clone(),\n+                projection: root_place.projection.to_vec().into_boxed_slice(),\n             }, borrow_span))\n         {\n             debug!(\n@@ -729,7 +727,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.access_place_error_reported\n             .insert((Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.clone(),\n+                projection: root_place.projection.to_vec().into_boxed_slice(),\n             }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n@@ -1107,7 +1105,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let local_kind = match borrow.borrowed_place {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } => {\n                     match self.body.local_kind(local) {\n                         LocalKind::ReturnPointer\n@@ -1136,7 +1134,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 .unwrap();\n             let local = if let PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } = root_place {\n                 local\n             } else {\n@@ -1446,7 +1444,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         let (from_arg, local_decl) = if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = *err_place {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n@@ -1519,10 +1517,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn classify_drop_access_kind(&self, place: PlaceRef<'cx, 'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place.projection {\n-            None => {\n+            [] => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n-            Some(box Projection { ref base, ref elem }) => {\n+            [.., elem] => {\n+                // FIXME(spastorino) revisit when we get rid of Box\n+                let base = &place.projection[..place.projection.len() - 1];\n+\n+                // FIXME(spastorino) make this iterate\n                 let base_access = self.classify_drop_access_kind(PlaceRef {\n                     base: place.base,\n                     projection: base,\n@@ -1609,7 +1611,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut target = *match reservation {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } if self.body.local_kind(*local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n@@ -1625,7 +1627,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let StatementKind::Assign(\n                     Place {\n                         base: PlaceBase::Local(assigned_to),\n-                        projection: None,\n+                        projection: box [],\n                     },\n                     box rvalue\n                 ) = &stmt.kind {\n@@ -1753,7 +1755,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let TerminatorKind::Call {\n                 destination: Some((Place {\n                     base: PlaceBase::Local(assigned_to),\n-                    projection: None,\n+                    projection: box [],\n                 }, _)),\n                 args,\n                 .."}, {"sha": "1fbedc49ecf3f62c09493555250ffddb36519b45", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -152,7 +152,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n@@ -162,7 +162,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 buf.push_str(\"promoted\");\n             }\n@@ -173,15 +173,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         def_id,\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n             PlaceRef {\n                 base,\n-                projection: Some(ref proj),\n+                projection: [.., elem],\n             } => {\n-                match proj.elem {\n+                let proj_base = &place.projection[..place.projection.len() - 1];\n+\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n                             self.is_upvar_field_projection(place);\n@@ -199,20 +201,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 self.append_place_to_string(\n                                     PlaceRef {\n                                         base,\n-                                        projection: &proj.base,\n+                                        projection: proj_base,\n                                     },\n                                     buf,\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n                             } else {\n-                                match (&proj.base, base) {\n-                                    (None, PlaceBase::Local(local)) => {\n+                                match (proj_base, base) {\n+                                    ([], PlaceBase::Local(local)) => {\n                                         if self.body.local_decls[*local].is_ref_for_guard() {\n                                             self.append_place_to_string(\n                                                 PlaceRef {\n                                                     base,\n-                                                    projection: &proj.base,\n+                                                    projection: proj_base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -224,7 +226,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             self.append_place_to_string(\n                                                 PlaceRef {\n                                                     base,\n-                                                    projection: &proj.base,\n+                                                    projection: proj_base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -238,7 +240,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                         self.append_place_to_string(\n                                             PlaceRef {\n                                                 base,\n-                                                projection: &proj.base,\n+                                                projection: proj_base,\n                                             },\n                                             buf,\n                                             autoderef,\n@@ -253,7 +255,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n@@ -275,12 +277,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         } else {\n                             let field_name = self.describe_field(PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n-                            }, field);\n+                                projection: proj_base,\n+                            }, *field);\n                             self.append_place_to_string(\n                                 PlaceRef {\n                                     base,\n-                                    projection: &proj.base,\n+                                    projection: proj_base,\n                                 },\n                                 buf,\n                                 autoderef,\n@@ -295,14 +297,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n                         )?;\n                         buf.push_str(\"[\");\n-                        if self.append_local_to_string(index, buf).is_err() {\n+                        if self.append_local_to_string(*index, buf).is_err() {\n                             buf.push_str(\"_\");\n                         }\n                         buf.push_str(\"]\");\n@@ -315,7 +317,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n@@ -349,38 +351,44 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef {\n                 base: PlaceBase::Static(static_),\n-                projection: None,\n+                projection: [],\n             } =>\n                 self.describe_field_from_ty(&static_.ty, field, None),\n             PlaceRef {\n                 base,\n-                projection: Some(proj),\n-            } => match proj.elem {\n-                ProjectionElem::Deref => self.describe_field(PlaceRef {\n-                    base,\n-                    projection: &proj.base,\n-                }, field),\n+                projection: [.., elem],\n+            } => match elem {\n+                ProjectionElem::Deref => {\n+                    let proj_base = &place.projection[..place.projection.len() - 1];\n+\n+                    self.describe_field(PlaceRef {\n+                        base,\n+                        projection: proj_base,\n+                    }, field)\n+                }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n                         Place::ty_from(place.base, place.projection, self.body, self.infcx.tcx).ty;\n-                    self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n+                    self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field, None)\n                 }\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {\n+                    let proj_base = &place.projection[..place.projection.len() - 1];\n+\n                     self.describe_field(PlaceRef {\n                         base,\n-                        projection: &proj.base,\n+                        projection: proj_base,\n                     }, field)\n                 }\n             },\n@@ -445,7 +453,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 def_id,\n                 ..\n             }),\n-            projection: None,\n+            projection: [],\n         } = place_ref {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n@@ -830,7 +838,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some(&Statement {\n                 kind: StatementKind::Assign(Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 }, _),\n                 ..\n             }) => local,"}, {"sha": "041047bf7cdc86b75910a926113c1429076317dc", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -10,10 +10,10 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n-    Static, StaticKind\n+    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceElem,\n+    PlaceRef, Static, StaticKind\n };\n-use rustc::mir::{Field, Projection, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n@@ -905,7 +905,7 @@ enum InitializationRequiringAction {\n \n struct RootPlace<'d, 'tcx> {\n     place_base: &'d PlaceBase<'tcx>,\n-    place_projection: &'d Option<Box<Projection<'tcx>>>,\n+    place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n \n@@ -1191,7 +1191,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // before (at this point in the flow).\n         if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = place_span.0 {\n             if let Mutability::Not = self.body.local_decls[*local].mutability {\n                 // check for reassignments to immutable local variables\n@@ -1331,7 +1331,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n-            if place.projection.is_some() {\n+            if !place.projection.is_empty() {\n                 if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n                     this.used_mut_upvars.push(field);\n                 }\n@@ -1346,11 +1346,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) |\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) if self.body.local_decls[local].is_user_variable.is_none() => {\n                 if self.body.local_decls[local].ty.is_mutable_ptr() {\n                     // The variable will be marked as mutable by the borrow.\n@@ -1468,7 +1468,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.projection.is_none());\n+        assert!(root_place.projection.is_empty());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n             PlaceBase::Static(box Static {\n                 kind: StaticKind::Promoted(..),\n@@ -1756,13 +1756,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n-        // recur down place; dispatch to external checks when necessary\n-        let mut place_projection = &place.projection;\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        while let Some(proj) = place_projection {\n-            let Projection { ref base, ref elem } = **proj;\n-            match *elem {\n+        for (i, elem) in place.projection.iter().enumerate().rev() {\n+            match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n@@ -1774,11 +1771,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // assigning to (*P) requires P to be initialized\n                 ProjectionElem::Deref => {\n+                    let proj_base = &place.projection[..i];\n+\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n                             base: &place.base,\n-                            projection: base,\n+                            projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n                     // recur further)\n@@ -1791,18 +1790,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n \n                 ProjectionElem::Field(..) => {\n+                    let proj_base = &place.projection[..i];\n                     // if type of `P` has a dtor, then\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n                     match base_ty.sty {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n                                     base: &place.base,\n-                                    projection: base,\n+                                    projection: proj_base,\n                                 }, span), flow_state);\n \n                             // (base initialized; no need to\n@@ -1815,7 +1815,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n                                 base: &place.base,\n-                                projection: base,\n+                                projection: proj_base,\n                             }, span, flow_state);\n \n                             if let PlaceBase::Local(local) = place.base {\n@@ -1835,8 +1835,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            place_projection = base;\n         }\n \n         fn check_parent_of_field<'cx, 'tcx>(\n@@ -2084,7 +2082,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match root_place {\n             RootPlace {\n                 place_base: PlaceBase::Local(local),\n-                place_projection: None,\n+                place_projection: [],\n                 is_local_mutation_allowed,\n             } => {\n                 // If the local may have been initialized, and it is now currently being\n@@ -2103,7 +2101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {}\n             RootPlace {\n                 place_base,\n-                place_projection: place_projection @ Some(_),\n+                place_projection: place_projection @ [.., _],\n                 is_local_mutation_allowed: _,\n             } => {\n                 if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -2115,7 +2113,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             RootPlace {\n                 place_base: PlaceBase::Static(..),\n-                place_projection: None,\n+                place_projection: [],\n                 is_local_mutation_allowed: _,\n             } => {}\n         }\n@@ -2131,7 +2129,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n@@ -2162,7 +2160,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } =>\n                 Ok(RootPlace {\n                     place_base: place.base,\n@@ -2175,7 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id,\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 if !self.infcx.tcx.is_mutable_static(*def_id) {\n                     Err(place)\n@@ -2189,12 +2187,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             PlaceRef {\n                 base: _,\n-                projection: Some(proj),\n+                projection: [.., elem],\n             } => {\n-                match proj.elem {\n+                let proj_base = &place.projection[..place.projection.len() - 1];\n+\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, &proj.base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, proj_base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n@@ -2216,7 +2216,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                                         self.is_mutable(PlaceRef {\n                                             base: place.base,\n-                                            projection: &proj.base,\n+                                            projection: proj_base,\n                                         }, mode)\n                                     }\n                                 }\n@@ -2240,7 +2240,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ if base_ty.is_box() => {\n                                 self.is_mutable(PlaceRef {\n                                     base: place.base,\n-                                    projection: &proj.base,\n+                                    projection: proj_base,\n                                 }, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n@@ -2297,7 +2297,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // ```\n                                     let _ = self.is_mutable(PlaceRef {\n                                         base: place.base,\n-                                        projection: &proj.base,\n+                                        projection: proj_base,\n                                     }, is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n                                         place_base: place.base,\n@@ -2309,7 +2309,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         } else {\n                             self.is_mutable(PlaceRef {\n                                 base: place.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             }, is_local_mutation_allowed)\n                         }\n                     }\n@@ -2326,21 +2326,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut place_projection = place_ref.projection;\n         let mut by_ref = false;\n \n-        if let Some(box Projection {\n-            base,\n-            elem: ProjectionElem::Deref,\n-        }) = place_projection {\n-            place_projection = &base;\n+        if let [.., ProjectionElem::Deref] = place_projection {\n+            place_projection = &place_projection[..place_projection.len() - 1];\n             by_ref = true;\n         }\n \n         match place_projection {\n-            Some(box Projection {\n-                base,\n-                elem: ProjectionElem::Field(field, _ty),\n-            }) => {\n+            [.., ProjectionElem::Field(field, _ty)] => {\n+                let base = &place_projection[..place_projection.len() - 1];\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, &base, self.body, tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.base, base, self.body, tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator()) &&\n                     (!by_ref || self.upvars[field.index()].by_ref) {"}, {"sha": "d346a4cdfa21a1f85f594345eefc4d826001ef0b", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(StatementKind::Assign(\n                     Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n+                        projection: box [],\n                     },\n                     box Rvalue::Use(Operand::Move(move_from)),\n                 )) = self.body.basic_blocks()[location.block]\n@@ -274,16 +274,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let description = if place.projection.is_none() {\n+        let description = if place.projection.is_empty() {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n-            let mut base_static = &place.projection;\n-            while let Some(box Projection { base: Some(ref proj), .. }) = base_static {\n-                base_static = &proj.base;\n-            }\n             let base_static = PlaceRef {\n                 base: &place.base,\n-                projection: base_static,\n+                projection: &place.projection[..1],\n             };\n \n             format!(\n@@ -310,16 +306,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n         let deref_base = match deref_target_place.projection {\n-            Some(box Projection { ref base, elem: ProjectionElem::Deref }) => PlaceRef {\n-                base: &deref_target_place.base,\n-                projection: base,\n-            },\n+            box [.., ProjectionElem::Deref] => {\n+                let proj_base =\n+                    &deref_target_place.projection[..deref_target_place.projection.len() - 1];\n+\n+                PlaceRef {\n+                    base: &deref_target_place.base,\n+                    projection: proj_base,\n+                }\n+            }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n         if let PlaceRef {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: [],\n         } = deref_base {\n             let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {"}, {"sha": "dbc1d1700933f5ed52026dd4d291dd1f5b295263", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 39, "deletions": 72, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n use rustc::mir::{\n-    Mutability, Place, PlaceRef, PlaceBase, Projection, ProjectionElem, Static, StaticKind\n+    Mutability, Place, PlaceRef, PlaceBase, ProjectionElem, Static, StaticKind\n };\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -47,12 +47,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         match the_place_err {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if let Place {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: box [],\n                 } = access_place {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n@@ -65,14 +65,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Field(upvar_index, _),\n-                    }),\n+                projection: [.., ProjectionElem::Field(upvar_index, _)],\n             } => {\n+                let proj_base = &the_place_err.projection[..the_place_err.projection.len() - 1];\n+\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, &base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&the_place_err.base, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -86,14 +84,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Deref,\n-                    }),\n+                projection: [.., ProjectionElem::Deref],\n             } => {\n+                // FIXME(spastorino) once released use box [base @ .., ProjectionElem::Deref]\n+                let base = &the_place_err.projection[..the_place_err.projection.len() - 1];\n+\n                 if the_place_err.base == &PlaceBase::Local(Local::new(1)) &&\n-                    base.is_none() &&\n+                    base.is_empty() &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n@@ -114,7 +111,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                         }\n                 } else if {\n-                    if let (PlaceBase::Local(local), None) = (&the_place_err.base, base) {\n+                    if let (PlaceBase::Local(local), []) = (&the_place_err.base, base) {\n                         self.body.local_decls[*local].is_ref_for_guard()\n                     } else {\n                         false\n@@ -151,7 +148,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => unreachable!(),\n \n             PlaceRef {\n@@ -161,11 +158,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         def_id,\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 if let Place {\n                     base: PlaceBase::Static(_),\n-                    projection: None,\n+                    projection: box [],\n                 } = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n@@ -178,33 +175,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::Index(_),\n-                    }),\n+                projection: [.., ProjectionElem::Index(_)],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::ConstantIndex { .. },\n-                    }),\n+                projection: [.., ProjectionElem::ConstantIndex { .. }],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Subslice { .. },\n-                }),\n+                projection: [.., ProjectionElem::Subslice { .. }],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Downcast(..),\n-                }),\n+                projection: [.., ProjectionElem::Downcast(..)],\n             } => bug!(\"Unexpected immutable place.\"),\n         }\n \n@@ -262,22 +245,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // after the field access).\n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: Some(box Projection {\n-                        base: Some(box Projection {\n-                            base: base_proj,\n-                            elem: ProjectionElem::Deref,\n-                        }),\n-                        elem: ProjectionElem::Field(field, _),\n-                    }),\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [..,\n+                             ProjectionElem::Deref,\n+                             ProjectionElem::Field(field, _),\n+                             ProjectionElem::Deref,\n+                ],\n             } => {\n+                let base_proj = &the_place_err.projection[..the_place_err.projection.len() - 3];\n+\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(&base, &base_proj, self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, base_proj, self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -292,7 +272,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Suggest removing a `&mut` from the use of a mutable reference.\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } if {\n                 self.body.local_decls.get(*local).map(|local_decl| {\n                     if let ClearCrossCrate::Set(\n@@ -328,7 +308,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // variable) mutations...\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } if self.body.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n@@ -349,13 +329,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Also suggest adding mut for upvars\n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: proj_base,\n-                    elem: ProjectionElem::Field(upvar_index, _),\n-                }),\n+                projection: [.., ProjectionElem::Field(upvar_index, _)],\n             } => {\n+                let proj_base = &the_place_err.projection[..the_place_err.projection.len() - 1];\n+\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&base, &proj_base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -385,7 +364,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             PlaceRef {\n                 base: PlaceBase::Local(_),\n-                projection: None,\n+                projection: [],\n             } if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n@@ -400,10 +379,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } if {\n                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n                     self.body.local_decls[*local].is_user_variable\n@@ -427,10 +403,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // arbitrary base for the projection?\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } if self.body.local_decls[*local].is_user_variable.is_some() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n@@ -510,10 +483,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             // FIXME document what is this 1 magic number about\n             } if *base == PlaceBase::Local(Local::new(1)) &&\n                   !self.upvars.is_empty() =>\n@@ -527,10 +497,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [.., ProjectionElem::Deref],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n "}, {"sha": "1e5f613aedc233b20a0c3a84c91f6b6e377cf767", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -8,9 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, Projection,\n-    ProjectionElem, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n-    UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty};\n@@ -229,14 +228,11 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             match place {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } |\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: Some(box Projection {\n-                        base: None,\n-                        elem: ProjectionElem::Deref,\n-                    }),\n+                    projection: box [ProjectionElem::Deref],\n                 } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n@@ -261,7 +257,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n \n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: Some(_),\n+                    projection: box [.., _],\n                 } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!("}, {"sha": "ad68b4bc054bb7006c18308e797868a489d8482a", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -274,7 +274,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place {\n                             base: PlaceBase::Local(borrowed_local),\n-                            projection: None,\n+                            projection: box [],\n                         } = place {\n                              if body.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n@@ -495,11 +495,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Operand::Constant(c) => c.span,\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(l),\n-                                projection: None,\n+                                projection: box [],\n                             }) |\n                             Operand::Move(Place {\n                                 base: PlaceBase::Local(l),\n-                                projection: None,\n+                                projection: box [],\n                             }) => {\n                                 let local_decl = &self.body.local_decls[*l];\n                                 if local_decl.name.is_none() {\n@@ -543,7 +543,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut target = if let Some(&Statement {\n             kind: StatementKind::Assign(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }, _),\n             ..\n         }) = stmt\n@@ -583,11 +583,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Use(operand) => match operand {\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                             | Operand::Move(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                                 if *from == target =>\n                             {\n@@ -602,11 +602,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ) => match operand {\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                             | Operand::Move(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                                 if *from == target =>\n                             {\n@@ -639,7 +639,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let TerminatorKind::Call {\n                     destination: Some((Place {\n                         base: PlaceBase::Local(dest),\n-                        projection: None,\n+                        projection: box [],\n                     }, block)),\n                     args,\n                     ..\n@@ -653,7 +653,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let found_target = args.iter().any(|arg| {\n                         if let Operand::Move(Place {\n                             base: PlaceBase::Local(potential),\n-                            projection: None,\n+                            projection: box [],\n                         }) = arg {\n                             *potential == target\n                         } else {"}, {"sha": "599472958f4fcf12f110f70f22c0eaed84613707", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 93, "deletions": 101, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -421,107 +421,104 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        place.iterate(|place_base, place_projection| {\n-            let mut place_ty = match place_base {\n-                PlaceBase::Local(index) =>\n-                    PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-                PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n-                    let sty = self.sanitize_type(place, sty);\n-                    let check_err =\n-                        |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n-                         place: &Place<'tcx>,\n-                         ty,\n-                         sty| {\n-                            if let Err(terr) = verifier.cx.eq_types(\n-                                sty,\n-                                ty,\n-                                location.to_locations(),\n-                                ConstraintCategory::Boring,\n-                            ) {\n-                                span_mirbug!(\n-                                verifier,\n-                                place,\n-                                \"bad promoted type ({:?}: {:?}): {:?}\",\n-                                ty,\n-                                sty,\n-                                terr\n-                            );\n-                            };\n+        let mut place_ty = match &place.base {\n+            PlaceBase::Local(index) =>\n+                PlaceTy::from_ty(self.body.local_decls[*index].ty),\n+            PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n+                let sty = self.sanitize_type(place, sty);\n+                let check_err =\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n+                     place: &Place<'tcx>,\n+                     ty,\n+                     sty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            sty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                            verifier,\n+                            place,\n+                            \"bad promoted type ({:?}: {:?}): {:?}\",\n+                            ty,\n+                            sty,\n+                            terr\n+                        );\n                         };\n-                    match kind {\n-                        StaticKind::Promoted(promoted, _) => {\n-                            if !self.errors_reported {\n-                                let promoted_body = &self.promoted[*promoted];\n-                                self.sanitize_promoted(promoted_body, location);\n-\n-                                let promoted_ty = promoted_body.return_ty();\n-                                check_err(self, place, promoted_ty, sty);\n-                            }\n+                    };\n+                match kind {\n+                    StaticKind::Promoted(promoted, _) => {\n+                        if !self.errors_reported {\n+                            let promoted_body = &self.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_body, location);\n+\n+                            let promoted_ty = promoted_body.return_ty();\n+                            check_err(self, place, promoted_ty, sty);\n                         }\n-                        StaticKind::Static => {\n-                            let ty = self.tcx().type_of(*def_id);\n-                            let ty = self.cx.normalize(ty, location);\n+                    }\n+                    StaticKind::Static => {\n+                        let ty = self.tcx().type_of(*def_id);\n+                        let ty = self.cx.normalize(ty, location);\n \n-                            check_err(self, place, ty, sty);\n-                        }\n+                        check_err(self, place, ty, sty);\n                     }\n-                    PlaceTy::from_ty(sty)\n                 }\n-            };\n+                PlaceTy::from_ty(sty)\n+            }\n+        };\n \n-            // FIXME use place_projection.is_empty() when is available\n-            if place.projection.is_none() {\n-                if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                    let is_promoted = match place {\n-                        Place {\n-                            base: PlaceBase::Static(box Static {\n-                                kind: StaticKind::Promoted(..),\n-                                ..\n-                            }),\n-                            projection: None,\n-                        } => true,\n-                        _ => false,\n-                    };\n+        if place.projection.is_empty() {\n+            if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+                let is_promoted = match place {\n+                    Place {\n+                        base: PlaceBase::Static(box Static {\n+                            kind: StaticKind::Promoted(..),\n+                            ..\n+                        }),\n+                        projection: box [],\n+                    } => true,\n+                    _ => false,\n+                };\n \n-                    if !is_promoted {\n-                        let tcx = self.tcx();\n-                        let trait_ref = ty::TraitRef {\n-                            def_id: tcx.lang_items().copy_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-                        };\n+                if !is_promoted {\n+                    let tcx = self.tcx();\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().copy_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    };\n \n-                        // In order to have a Copy operand, the type T of the\n-                        // value must be Copy. Note that we prove that T: Copy,\n-                        // rather than using the `is_copy_modulo_regions`\n-                        // test. This is important because\n-                        // `is_copy_modulo_regions` ignores the resulting region\n-                        // obligations and assumes they pass. This can result in\n-                        // bounds from Copy impls being unsoundly ignored (e.g.,\n-                        // #29149). Note that we decide to use Copy before knowing\n-                        // whether the bounds fully apply: in effect, the rule is\n-                        // that if a value of some type could implement Copy, then\n-                        // it must.\n-                        self.cx.prove_trait_ref(\n-                            trait_ref,\n-                            location.to_locations(),\n-                            ConstraintCategory::CopyBound,\n-                        );\n-                    }\n+                    // In order to have a Copy operand, the type T of the\n+                    // value must be Copy. Note that we prove that T: Copy,\n+                    // rather than using the `is_copy_modulo_regions`\n+                    // test. This is important because\n+                    // `is_copy_modulo_regions` ignores the resulting region\n+                    // obligations and assumes they pass. This can result in\n+                    // bounds from Copy impls being unsoundly ignored (e.g.,\n+                    // #29149). Note that we decide to use Copy before knowing\n+                    // whether the bounds fully apply: in effect, the rule is\n+                    // that if a value of some type could implement Copy, then\n+                    // it must.\n+                    self.cx.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                        ConstraintCategory::CopyBound,\n+                    );\n                 }\n             }\n+        }\n \n-            for proj in place_projection {\n-                if place_ty.variant_index.is_none() {\n-                    if place_ty.ty.references_error() {\n-                        assert!(self.errors_reported);\n-                        return PlaceTy::from_ty(self.tcx().types.err);\n-                    }\n+        for elem in place.projection.iter() {\n+            if place_ty.variant_index.is_none() {\n+                if place_ty.ty.references_error() {\n+                    assert!(self.errors_reported);\n+                    return PlaceTy::from_ty(self.tcx().types.err);\n                 }\n-                place_ty = self.sanitize_projection(place_ty, &proj.elem, place, location)\n             }\n+            place_ty = self.sanitize_projection(place_ty, elem, place, location)\n+        }\n \n-            place_ty\n-        })\n+        place_ty\n     }\n \n     fn sanitize_promoted(&mut self, promoted_body: &'b Body<'tcx>, location: Location) {\n@@ -1354,7 +1351,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let category = match *place {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: None,\n+                        projection: box [],\n                     } => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n@@ -1373,7 +1370,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     },\n                     Place {\n                         base: PlaceBase::Local(l),\n-                        projection: None,\n+                        projection: box [],\n                     } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -1660,7 +1657,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let category = match *dest {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: None,\n+                        projection: box [],\n                     } => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n@@ -1682,7 +1679,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                     Place {\n                         base: PlaceBase::Local(l),\n-                        projection: None,\n+                        projection: box [],\n                     } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -2416,19 +2413,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // *p`, where the `p` has type `&'b mut Foo`, for example, we\n         // need to ensure that `'b: 'a`.\n \n-        let mut borrowed_projection = &borrowed_place.projection;\n-\n         debug!(\n             \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n             location, borrow_region, borrowed_place\n         );\n-        while let Some(box proj) = borrowed_projection {\n-            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_projection);\n+        for (i, elem) in borrowed_place.projection.iter().enumerate().rev() {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", elem);\n+            let proj_base = &borrowed_place.projection[..i];\n \n-            match proj.elem {\n+            match elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&borrowed_place.base, &proj.base, body, tcx).ty;\n+                    let base_ty = Place::ty_from(&borrowed_place.base, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n@@ -2490,10 +2486,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // other field access\n                 }\n             }\n-\n-            // The \"propagate\" case. We need to check that our base is valid\n-            // for the borrow's lifetime.\n-            borrowed_projection = &proj.base;\n         }\n     }\n "}, {"sha": "50067345c65ee56fd7d65c8cbbaa99de61bfba4c", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -25,55 +25,55 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        self.iterate(|place_base, place_projection| {\n-            let ignore = match place_base {\n-                // If a local variable is immutable, then we only need to track borrows to guard\n-                // against two kinds of errors:\n-                // * The variable being dropped while still borrowed (e.g., because the fn returns\n-                //   a reference to a local variable)\n-                // * The variable being moved while still borrowed\n-                //\n-                // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-                // so we don't have to worry about mutation while borrowed.\n-                PlaceBase::Local(index) => {\n-                    match locals_state_at_exit {\n-                        LocalsStateAtExit::AllAreInvalidated => false,\n-                        LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                            let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                                body.local_decls[*index].mutability == Mutability::Not;\n-                            debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                            ignore\n-                        }\n+        let ignore = match self.base {\n+            // If a local variable is immutable, then we only need to track borrows to guard\n+            // against two kinds of errors:\n+            // * The variable being dropped while still borrowed (e.g., because the fn returns\n+            //   a reference to a local variable)\n+            // * The variable being moved while still borrowed\n+            //\n+            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+            // so we don't have to worry about mutation while borrowed.\n+            PlaceBase::Local(index) => {\n+                match locals_state_at_exit {\n+                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                        let ignore = !has_storage_dead_or_moved.contains(index) &&\n+                            body.local_decls[index].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                        ignore\n                     }\n                 }\n-                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n-                    false,\n-                PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                    tcx.is_mutable_static(*def_id)\n-                }\n-            };\n+            }\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n+                false,\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n+                tcx.is_mutable_static(def_id)\n+            }\n+        };\n \n-            for proj in place_projection {\n-                if proj.elem == ProjectionElem::Deref {\n-                    let ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n-                    match ty.sty {\n-                        // For both derefs of raw pointers and `&T`\n-                        // references, the original path is `Copy` and\n-                        // therefore not significant.  In particular,\n-                        // there is nothing the user can do to the\n-                        // original path that would invalidate the\n-                        // newly created reference -- and if there\n-                        // were, then the user could have copied the\n-                        // original path into a new variable and\n-                        // borrowed *that* one, leaving the original\n-                        // path unborrowed.\n-                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n-                        _ => {}\n-                    }\n+        for (i, elem) in self.projection.iter().enumerate() {\n+            let proj_base = &self.projection[..i];\n+\n+            if *elem == ProjectionElem::Deref {\n+                let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n+                match ty.sty {\n+                    // For both derefs of raw pointers and `&T`\n+                    // references, the original path is `Copy` and\n+                    // therefore not significant.  In particular,\n+                    // there is nothing the user can do to the\n+                    // original path that would invalidate the\n+                    // newly created reference -- and if there\n+                    // were, then the user could have copied the\n+                    // original path into a new variable and\n+                    // borrowed *that* one, leaving the original\n+                    // path unborrowed.\n+                    ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n+                    _ => {}\n                 }\n             }\n+        }\n \n-            ignore\n-        })\n+        ignore\n     }\n }"}, {"sha": "dafa0b6631fe2cc44fff700a819f50ec361900dd", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 162, "deletions": 156, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -3,8 +3,7 @@ use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{\n-    Body, BorrowKind, Place, PlaceBase, PlaceRef, Projection, ProjectionElem, ProjectionsIter,\n-    StaticKind,\n+    Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem, StaticKind,\n };\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n@@ -67,39 +66,35 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     // it's so common that it's a speed win to check for it first.\n     if let Place {\n         base: PlaceBase::Local(l1),\n-        projection: None,\n+        projection: box [],\n     } = borrow_place {\n         if let PlaceRef {\n             base: PlaceBase::Local(l2),\n-            projection: None,\n+            projection: [],\n         } = access_place {\n             return l1 == l2;\n         }\n     }\n \n-    borrow_place.iterate(|borrow_base, borrow_projections| {\n-        access_place.iterate(|access_base, access_projections| {\n-            place_components_conflict(\n-                tcx,\n-                param_env,\n-                body,\n-                (borrow_base, borrow_projections),\n-                borrow_kind,\n-                (access_base, access_projections),\n-                access,\n-                bias,\n-            )\n-        })\n-    })\n+    place_components_conflict(\n+        tcx,\n+        param_env,\n+        body,\n+        borrow_place,\n+        borrow_kind,\n+        access_place,\n+        access,\n+        bias,\n+    )\n }\n \n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n+    borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n+    access_place: PlaceRef<'_, 'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -145,8 +140,8 @@ fn place_components_conflict<'tcx>(\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n \n-    let borrow_base = borrow_projections.0;\n-    let access_base = access_projections.0;\n+    let borrow_base = &borrow_place.base;\n+    let access_base = access_place.base;\n \n     match place_base_conflict(tcx, param_env, borrow_base, access_base) {\n         Overlap::Arbitrary => {\n@@ -163,147 +158,157 @@ fn place_components_conflict<'tcx>(\n         }\n     }\n \n-    let mut borrow_projections = borrow_projections.1;\n-    let mut access_projections = access_projections.1;\n-\n-    loop {\n-        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-        if let Some(borrow_c) = borrow_projections.next() {\n-            debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n+    // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+    for (i, (borrow_c, access_c)) in\n+        borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n+    {\n+        debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n+        let borrow_proj_base = &borrow_place.projection[..i];\n \n-            if let Some(access_c) = access_projections.next() {\n-                debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n+        debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n \n-                // Borrow and access path both have more components.\n-                //\n-                // Examples:\n-                //\n-                // - borrow of `a.(...)`, access to `a.(...)`\n-                // - borrow of `a.(...)`, access to `b.(...)`\n-                //\n-                // Here we only see the components we have checked so\n-                // far (in our examples, just the first component). We\n-                // check whether the components being borrowed vs\n-                // accessed are disjoint (as in the second example,\n-                // but not the first).\n-                match place_projection_conflict(tcx, body, borrow_base, borrow_c, access_c, bias) {\n-                    Overlap::Arbitrary => {\n-                        // We have encountered different fields of potentially\n-                        // the same union - the borrow now partially overlaps.\n-                        //\n-                        // There is no *easy* way of comparing the fields\n-                        // further on, because they might have different types\n-                        // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n-                        // `.y` come from different structs).\n-                        //\n-                        // We could try to do some things here - e.g., count\n-                        // dereferences - but that's probably not a good\n-                        // idea, at least for now, so just give up and\n-                        // report a conflict. This is unsafe code anyway so\n-                        // the user could always use raw pointers.\n-                        debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n-                        return true;\n-                    }\n-                    Overlap::EqualOrDisjoint => {\n-                        // This is the recursive case - proceed to the next element.\n-                    }\n-                    Overlap::Disjoint => {\n-                        // We have proven the borrow disjoint - further\n-                        // projections will remain disjoint.\n-                        debug!(\"borrow_conflicts_with_place: disjoint\");\n-                        return false;\n-                    }\n-                }\n-            } else {\n-                // Borrow path is longer than the access path. Examples:\n+        // Borrow and access path both have more components.\n+        //\n+        // Examples:\n+        //\n+        // - borrow of `a.(...)`, access to `a.(...)`\n+        // - borrow of `a.(...)`, access to `b.(...)`\n+        //\n+        // Here we only see the components we have checked so\n+        // far (in our examples, just the first component). We\n+        // check whether the components being borrowed vs\n+        // accessed are disjoint (as in the second example,\n+        // but not the first).\n+        match place_projection_conflict(\n+            tcx,\n+            body,\n+            borrow_base,\n+            borrow_proj_base,\n+            borrow_c,\n+            access_c,\n+            bias,\n+        ) {\n+            Overlap::Arbitrary => {\n+                // We have encountered different fields of potentially\n+                // the same union - the borrow now partially overlaps.\n                 //\n-                // - borrow of `a.b.c`, access to `a.b`\n+                // There is no *easy* way of comparing the fields\n+                // further on, because they might have different types\n+                // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n+                // `.y` come from different structs).\n                 //\n-                // Here, we know that the borrow can access a part of\n-                // our place. This is a conflict if that is a part our\n-                // access cares about.\n+                // We could try to do some things here - e.g., count\n+                // dereferences - but that's probably not a good\n+                // idea, at least for now, so just give up and\n+                // report a conflict. This is unsafe code anyway so\n+                // the user could always use raw pointers.\n+                debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                return true;\n+            }\n+            Overlap::EqualOrDisjoint => {\n+                // This is the recursive case - proceed to the next element.\n+            }\n+            Overlap::Disjoint => {\n+                // We have proven the borrow disjoint - further\n+                // projections will remain disjoint.\n+                debug!(\"borrow_conflicts_with_place: disjoint\");\n+                return false;\n+            }\n+        }\n+    }\n+\n+    if borrow_place.projection.len() > access_place.projection.len() {\n+        for (i, elem) in borrow_place.projection[access_place.projection.len()..].iter().enumerate()\n+        {\n+            // Borrow path is longer than the access path. Examples:\n+            //\n+            // - borrow of `a.b.c`, access to `a.b`\n+            //\n+            // Here, we know that the borrow can access a part of\n+            // our place. This is a conflict if that is a part our\n+            // access cares about.\n \n-                let base = &borrow_c.base;\n-                let elem = &borrow_c.elem;\n-                let base_ty = Place::ty_from(borrow_base, base, body, tcx).ty;\n+            let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n+            let base_ty = Place::ty_from(borrow_base, proj_base, body, tcx).ty;\n \n-                match (elem, &base_ty.sty, access) {\n-                    (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n-                    | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n-                        // The array length is like  additional fields on the\n-                        // type; it does not overlap any existing data there.\n-                        // Furthermore, if cannot actually be a prefix of any\n-                        // borrowed place (at least in MIR as it is currently.)\n-                        //\n-                        // e.g., a (mutable) borrow of `a[5]` while we read the\n-                        // array length of `a`.\n-                        debug!(\"borrow_conflicts_with_place: implicit field\");\n-                        return false;\n-                    }\n+            match (elem, &base_ty.sty, access) {\n+                (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n+                | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n+                    // The array length is like  additional fields on the\n+                    // type; it does not overlap any existing data there.\n+                    // Furthermore, if cannot actually be a prefix of any\n+                    // borrowed place (at least in MIR as it is currently.)\n+                    //\n+                    // e.g., a (mutable) borrow of `a[5]` while we read the\n+                    // array length of `a`.\n+                    debug!(\"borrow_conflicts_with_place: implicit field\");\n+                    return false;\n+                }\n \n-                    (ProjectionElem::Deref, _, Shallow(None)) => {\n-                        // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n-                        // prefix thereof - the shallow access can't touch anything behind\n-                        // the pointer.\n-                        debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n-                        return false;\n-                    }\n-                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n-                        // Shouldn't be tracked\n-                        bug!(\"Tracking borrow behind shared reference.\");\n-                    }\n-                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n-                        // Values behind a mutable reference are not access either by dropping a\n-                        // value, or by StorageDead\n-                        debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n-                        return false;\n-                    }\n+                (ProjectionElem::Deref, _, Shallow(None)) => {\n+                    // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n+                    // prefix thereof - the shallow access can't touch anything behind\n+                    // the pointer.\n+                    debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                    return false;\n+                }\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n+                    // Shouldn't be tracked\n+                    bug!(\"Tracking borrow behind shared reference.\");\n+                }\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n+                    // Values behind a mutable reference are not access either by dropping a\n+                    // value, or by StorageDead\n+                    debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n+                    return false;\n+                }\n \n-                    (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n-                        // Drop can read/write arbitrary projections, so places\n-                        // conflict regardless of further projections.\n-                        if def.has_dtor(tcx) {\n-                            return true;\n-                        }\n+                (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n+                    // Drop can read/write arbitrary projections, so places\n+                    // conflict regardless of further projections.\n+                    if def.has_dtor(tcx) {\n+                        return true;\n                     }\n+                }\n \n-                    (ProjectionElem::Deref, _, Deep)\n-                    | (ProjectionElem::Deref, _, AccessDepth::Drop)\n-                    | (ProjectionElem::Field { .. }, _, _)\n-                    | (ProjectionElem::Index { .. }, _, _)\n-                    | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                    | (ProjectionElem::Subslice { .. }, _, _)\n-                    | (ProjectionElem::Downcast { .. }, _, _) => {\n-                        // Recursive case. This can still be disjoint on a\n-                        // further iteration if this a shallow access and\n-                        // there's a deref later on, e.g., a borrow\n-                        // of `*x.y` while accessing `x`.\n-                    }\n+                (ProjectionElem::Deref, _, Deep)\n+                | (ProjectionElem::Deref, _, AccessDepth::Drop)\n+                | (ProjectionElem::Field { .. }, _, _)\n+                | (ProjectionElem::Index { .. }, _, _)\n+                | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                | (ProjectionElem::Subslice { .. }, _, _)\n+                | (ProjectionElem::Downcast { .. }, _, _) => {\n+                    // Recursive case. This can still be disjoint on a\n+                    // further iteration if this a shallow access and\n+                    // there's a deref later on, e.g., a borrow\n+                    // of `*x.y` while accessing `x`.\n                 }\n             }\n-        } else {\n-            // Borrow path ran out but access path may not\n-            // have. Examples:\n-            //\n-            // - borrow of `a.b`, access to `a.b.c`\n-            // - borrow of `a.b`, access to `a.b`\n-            //\n-            // In the first example, where we didn't run out of\n-            // access, the borrow can access all of our place, so we\n-            // have a conflict.\n-            //\n-            // If the second example, where we did, then we still know\n-            // that the borrow can access a *part* of our place that\n-            // our access cares about, so we still have a conflict.\n-            if borrow_kind == BorrowKind::Shallow && access_projections.next().is_some() {\n-                debug!(\"borrow_conflicts_with_place: shallow borrow\");\n-                return false;\n-            } else {\n-                debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n-                return true;\n-            }\n         }\n     }\n+\n+    // Borrow path ran out but access path may not\n+    // have. Examples:\n+    //\n+    // - borrow of `a.b`, access to `a.b.c`\n+    // - borrow of `a.b`, access to `a.b`\n+    //\n+    // In the first example, where we didn't run out of\n+    // access, the borrow can access all of our place, so we\n+    // have a conflict.\n+    //\n+    // If the second example, where we did, then we still know\n+    // that the borrow can access a *part* of our place that\n+    // our access cares about, so we still have a conflict.\n+    if borrow_kind == BorrowKind::Shallow\n+        && borrow_place.projection.len() < access_place.projection.len()\n+    {\n+        debug!(\"borrow_conflicts_with_place: shallow borrow\");\n+        false\n+    } else {\n+        debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n+        true\n+    }\n }\n \n // Given that the bases of `elem1` and `elem2` are always either equal\n@@ -381,11 +386,12 @@ fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     pi1_base: &PlaceBase<'tcx>,\n-    pi1: &Projection<'tcx>,\n-    pi2: &Projection<'tcx>,\n+    pi1_proj_base: &[PlaceElem<'tcx>],\n+    pi1_elem: &PlaceElem<'tcx>,\n+    pi2_elem: &PlaceElem<'tcx>,\n     bias: PlaceConflictBias,\n ) -> Overlap {\n-    match (&pi1.elem, &pi2.elem) {\n+    match (pi1_elem, pi2_elem) {\n         (ProjectionElem::Deref, ProjectionElem::Deref) => {\n             // derefs (e.g., `*x` vs. `*x`) - recur.\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n@@ -397,7 +403,7 @@ fn place_projection_conflict<'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = Place::ty_from(pi1_base, &pi1.base, body, tcx).ty;\n+                let ty = Place::ty_from(pi1_base, pi1_proj_base, body, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck.\n@@ -493,7 +499,7 @@ fn place_projection_conflict<'tcx>(\n             // element (like -1 in Python) and `min_length` the first.\n             // Therefore, `min_length - offset_from_end` gives the minimal possible\n             // offset from the beginning\n-            if *offset_from_begin >= min_length - offset_from_end {\n+            if *offset_from_begin >= *min_length - *offset_from_end {\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n@@ -538,8 +544,8 @@ fn place_projection_conflict<'tcx>(\n         | (ProjectionElem::Subslice { .. }, _)\n         | (ProjectionElem::Downcast(..), _) => bug!(\n             \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-            pi1,\n-            pi2\n+            pi1_elem,\n+            pi2_elem\n         ),\n     }\n }"}, {"sha": "6adc693527f015b7efc686d596ab8d7d82d7229a", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 99, "deletions": 104, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -19,17 +19,9 @@ pub trait IsPrefixOf<'cx, 'tcx> {\n \n impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n     fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n-        let mut cursor = other.projection;\n-        loop {\n-            if self.projection == cursor {\n-                return self.base == other.base;\n-            }\n-\n-            match cursor {\n-                None => return false,\n-                Some(proj) => cursor = &proj.base,\n-            }\n-        }\n+        self.base == other.base\n+            && self.projection.len() <= other.projection.len()\n+            && self.projection == &other.projection[..self.projection.len()]\n     }\n }\n \n@@ -81,112 +73,115 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {\n-            let proj = match &cursor {\n+            match &cursor {\n                 PlaceRef {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: [],\n                 }\n                 | // search yielded this leaf\n                 PlaceRef {\n                     base: PlaceBase::Static(_),\n-                    projection: None,\n+                    projection: [],\n                 } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n                 PlaceRef {\n                     base: _,\n-                    projection: Some(proj),\n-                } => proj,\n-            };\n-\n-            match proj.elem {\n-                ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n-                    // FIXME: add union handling\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Index(_) => {\n-                    cursor = PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    };\n-                    continue 'cursor;\n-                }\n-                ProjectionElem::Deref => {\n-                    // (handled below)\n-                }\n-            }\n-\n-            assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-            match self.kind {\n-                PrefixSet::Shallow => {\n-                    // shallow prefixes are found by stripping away\n-                    // fields, but stop at *any* dereference.\n-                    // So we can just stop the traversal now.\n-                    self.next = None;\n-                    return Some(cursor);\n-                }\n-                PrefixSet::All => {\n-                    // all prefixes: just blindly enqueue the base\n-                    // of the projection.\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-                PrefixSet::Supporting => {\n-                    // fall through!\n-                }\n-            }\n-\n-            assert_eq!(self.kind, PrefixSet::Supporting);\n-            // supporting prefixes: strip away fields and\n-            // derefs, except we stop at the deref of a shared\n-            // reference.\n-\n-            let ty = Place::ty_from(cursor.base, &proj.base, self.body, self.tcx).ty;\n-            match ty.sty {\n-                ty::RawPtr(_) |\n-                ty::Ref(\n-                    _, /*rgn*/\n-                    _, /*ty*/\n-                    hir::MutImmutable\n-                    ) => {\n-                    // don't continue traversing over derefs of raw pointers or shared borrows.\n-                    self.next = None;\n-                    return Some(cursor);\n-                }\n-\n-                ty::Ref(\n-                    _, /*rgn*/\n-                    _, /*ty*/\n-                    hir::MutMutable,\n-                    ) => {\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-\n-                ty::Adt(..) if ty.is_box() => {\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n+                    projection: [.., elem],\n+                } => {\n+                    let proj_base = &cursor.projection[..cursor.projection.len() - 1];\n+\n+                    match elem {\n+                        ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(_) => {\n+                            cursor = PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            };\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(*elem, ProjectionElem::Deref);\n+\n+                    match self.kind {\n+                        PrefixSet::Shallow => {\n+                            // shallow prefixes are found by stripping away\n+                            // fields, but stop at *any* dereference.\n+                            // So we can just stop the traversal now.\n+                            self.next = None;\n+                            return Some(cursor);\n+                        }\n+                        PrefixSet::All => {\n+                            // all prefixes: just blindly enqueue the base\n+                            // of the projection\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+                        PrefixSet::Supporting => {\n+                            // fall through!\n+                        }\n+                    }\n+\n+                    assert_eq!(self.kind, PrefixSet::Supporting);\n+                    // supporting prefixes: strip away fields and\n+                    // derefs, except we stop at the deref of a shared\n+                    // reference.\n+\n+                    let ty = Place::ty_from(cursor.base, proj_base, self.body, self.tcx).ty;\n+                    match ty.sty {\n+                        ty::RawPtr(_) |\n+                        ty::Ref(\n+                            _, /*rgn*/\n+                            _, /*ty*/\n+                            hir::MutImmutable\n+                            ) => {\n+                            // don't continue traversing over derefs of raw pointers or shared\n+                            // borrows.\n+                            self.next = None;\n+                            return Some(cursor);\n+                        }\n+\n+                        ty::Ref(\n+                            _, /*rgn*/\n+                            _, /*ty*/\n+                            hir::MutMutable,\n+                            ) => {\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+\n+                        ty::Adt(..) if ty.is_box() => {\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n                 }\n-\n-                _ => panic!(\"unknown type fed to Projection Deref.\"),\n             }\n         }\n     }"}, {"sha": "8bfd24a1e59156926b4463d36ac90b547c0acbd2", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -120,7 +120,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                 );\n                 if let Place {\n                     base: PlaceBase::Local(user_local),\n-                    projection: None,\n+                    projection: box [],\n                 } = path.place {\n                     self.mbcx.used_mut.insert(user_local);\n                 }"}, {"sha": "5af66faf6ee1e8d81883183264389a831266dc22", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     kind: StaticKind::Static,\n                     def_id: id,\n                 })),\n-                projection: None,\n+                projection: box [],\n             }),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {"}, {"sha": "1371bc5aee82f5982722bae6cd727acf555969cd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -500,14 +500,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let mutability = match arg_place {\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             } => this.local_decls[local].mutability,\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                })\n+                projection: box [ProjectionElem::Deref],\n             } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n@@ -517,21 +514,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             Place {\n                 ref base,\n-                projection: Some(box Projection {\n-                    base: ref base_proj,\n-                    elem: ProjectionElem::Field(upvar_index, _),\n-                }),\n+                projection: box [.., ProjectionElem::Field(upvar_index, _)],\n             }\n             | Place {\n                 ref base,\n-                projection: Some(box Projection {\n-                    base: Some(box Projection {\n-                        base: ref base_proj,\n-                        elem: ProjectionElem::Field(upvar_index, _),\n-                    }),\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: box [.., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n             } => {\n+                let base_proj = if let ProjectionElem::Deref =\n+                    arg_place.projection[arg_place.projection.len() - 1]\n+                {\n+                    &arg_place.projection[..arg_place.projection.len() - 2]\n+                } else {\n+                    &arg_place.projection[..arg_place.projection.len() - 1]\n+                };\n+\n                 let place = PlaceRef {\n                     base,\n                     projection: base_proj,"}, {"sha": "45f4a1685360624983dceb733a847435e4f11481", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Create a \"fake\" temporary variable so that we check that the\n                 // value is Sized. Usually, this is caught in type checking, but\n                 // in the case of box expr there is no such check.\n-                if destination.projection.is_some() {\n+                if !destination.projection.is_empty() {\n                     this.local_decls\n                         .push(LocalDecl::new_temp(expr.ty, expr.span));\n                 }"}, {"sha": "8c94723e3cc2e51a0f57f4f4948e0bd28f07dce9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -942,13 +942,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for Binding { source, .. }\n                 in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n-                let mut cursor = &source.projection;\n-                while let Some(box Projection { base, elem }) = cursor {\n-                    cursor = base;\n+                for (i, elem) in source.projection.iter().enumerate().rev() {\n+                    let proj_base = &source.projection[..i];\n+\n                     if let ProjectionElem::Deref = elem {\n                         fake_borrows.insert(Place {\n                             base: source.base.clone(),\n-                            projection: cursor.clone(),\n+                            projection: proj_base.to_vec().into_boxed_slice(),\n                         });\n                         break;\n                     }\n@@ -1295,18 +1295,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n         for place in fake_borrows\n         {\n-            let mut prefix_cursor = &place.projection;\n-            while let Some(box Projection { base, elem }) = prefix_cursor {\n+            for (i, elem) in place.projection.iter().enumerate().rev() {\n+                let proj_base = &place.projection[..i];\n+\n                 if let ProjectionElem::Deref = elem {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n                     all_fake_borrows.push(PlaceRef {\n                         base: &place.base,\n-                        projection: base,\n+                        projection: proj_base,\n                     });\n                 }\n-                prefix_cursor = base;\n             }\n \n             all_fake_borrows.push(place.as_ref());\n@@ -1493,7 +1493,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     BorrowKind::Shallow,\n                     Place {\n                         base: place.base.clone(),\n-                        projection: place.projection.clone(),\n+                        projection: place.projection.to_vec().into_boxed_slice(),\n                     },\n                 );\n                 self.cfg.push_assign("}, {"sha": "647d7515fe98df36baad06b6f4386c05100fcbe4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -609,7 +609,7 @@ where\n         unpack!(block = builder.in_breakable_scope(\n             None,\n             START_BLOCK,\n-            Place::RETURN_PLACE,\n+            Place::return_place(),\n             |builder| {\n                 builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(block, &arguments, arg_scope, &body.value)\n@@ -670,7 +670,7 @@ fn construct_const<'a, 'tcx>(\n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Place::RETURN_PLACE, block, expr));\n+    unpack!(block = builder.into_expr(&Place::return_place(), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -871,7 +871,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::RETURN_PLACE, block, body)\n+        self.into(&Place::return_place(), block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "ee6d42de388d9bd0ecbdf122fd1dfd33d45c8d06", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -314,7 +314,7 @@ impl<'tcx> Scopes<'tcx> {\n         match target {\n             BreakableTarget::Return => {\n                 let scope = &self.breakable_scopes[0];\n-                if scope.break_destination != Place::RETURN_PLACE {\n+                if scope.break_destination != Place::return_place() {\n                     span_bug!(span, \"`return` in item with no return scope\");\n                 }\n                 (scope.break_block, scope.region_scope, Some(scope.break_destination.clone()))\n@@ -853,11 +853,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ if self.local_scope().is_none() => (),\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(cond_temp),\n-                projection: None,\n+                projection: box [],\n             })\n             | Operand::Move(Place {\n                 base: PlaceBase::Local(cond_temp),\n-                projection: None,\n+                projection: box [],\n             }) => {\n                 // Manually drop the condition on both branches.\n                 let top_scope = self.scopes.scopes.last_mut().unwrap();"}, {"sha": "672bbda7502fe5463fd65da5c1f8d30b375872dd", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -10,17 +10,12 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n-    where F: FnMut(&mir::Projection<'tcx>) -> bool\n+    where F: FnMut(&[mir::PlaceElem<'tcx>]) -> bool\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n-        match move_data.move_paths[child_index].place.projection {\n-            Some(ref proj) => {\n-                if cond(proj) {\n-                    return Some(child_index)\n-                }\n-            }\n-            _ => {}\n+        if cond(&move_data.move_paths[child_index].place.projection) {\n+            return Some(child_index)\n         }\n         next_child = move_data.move_paths[child_index].next_sibling;\n     }"}, {"sha": "04674fb58cb9f6ffa6c76cb3bab4917f8ae05f0d", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // If the borrowed place is a local with no projections, all other borrows of this\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n-            if place.projection.is_none() {\n+            if place.projection.is_empty() {\n                 trans.kill_all(other_borrows_of_local);\n                 return;\n             }"}, {"sha": "1d99470d08b0c5d779dadf28986888b334186a6c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -94,72 +94,74 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n-        place.iterate(|place_base, place_projection| {\n-            let mut base = match place_base {\n-                PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[*local],\n-                PlaceBase::Static(..) => {\n-                    return Err(MoveError::cannot_move_out_of(self.loc, Static));\n-                }\n-            };\n+        let mut base = match place.base {\n+            PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[local],\n+            PlaceBase::Static(..) => {\n+                return Err(MoveError::cannot_move_out_of(self.loc, Static));\n+            }\n+        };\n \n-            for proj in place_projection {\n-                let body = self.builder.body;\n-                let tcx = self.builder.tcx;\n-                let place_ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n-                match place_ty.sty {\n-                    ty::Ref(..) | ty::RawPtr(..) => {\n-                        return Err(MoveError::cannot_move_out_of(\n-                            self.loc,\n-                            BorrowedContent {\n-                                target_place: Place {\n-                                    base: place_base.clone(),\n-                                    projection: Some(Box::new(proj.clone())),\n-                                },\n+        for (i, elem) in place.projection.iter().enumerate() {\n+            let proj_base = &place.projection[..i];\n+            let body = self.builder.body;\n+            let tcx = self.builder.tcx;\n+            let place_ty = Place::ty_from(&place.base, proj_base, body, tcx).ty;\n+            match place_ty.sty {\n+                ty::Ref(..) | ty::RawPtr(..) => {\n+                    let proj = &place.projection[..i+1];\n+                    return Err(MoveError::cannot_move_out_of(\n+                        self.loc,\n+                        BorrowedContent {\n+                            target_place: Place {\n+                                base: place.base.clone(),\n+                                projection: proj.to_vec().into_boxed_slice(),\n                             },\n-                        ));\n-                    }\n-                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() => {\n+                        },\n+                    ));\n+                }\n+                ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() => {\n+                    return Err(MoveError::cannot_move_out_of(\n+                        self.loc,\n+                        InteriorOfTypeWithDestructor { container_ty: place_ty },\n+                    ));\n+                }\n+                // move out of union - always move the entire union\n+                ty::Adt(adt, _) if adt.is_union() => {\n+                    return Err(MoveError::UnionMove { path: base });\n+                }\n+                ty::Slice(_) => {\n+                    return Err(MoveError::cannot_move_out_of(\n+                        self.loc,\n+                        InteriorOfSliceOrArray {\n+                            ty: place_ty,\n+                            is_index: match elem {\n+                                ProjectionElem::Index(..) => true,\n+                                _ => false,\n+                            },\n+                        },\n+                    ));\n+                }\n+                ty::Array(..) => match elem {\n+                    ProjectionElem::Index(..) => {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n-                            InteriorOfTypeWithDestructor { container_ty: place_ty },\n+                            InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n                         ));\n                     }\n-                    // move out of union - always move the entire union\n-                    ty::Adt(adt, _) if adt.is_union() => {\n-                        return Err(MoveError::UnionMove { path: base });\n-                    }\n-                    ty::Slice(_) => {\n-                        return Err(MoveError::cannot_move_out_of(\n-                            self.loc,\n-                            InteriorOfSliceOrArray {\n-                                ty: place_ty,\n-                                is_index: match proj.elem {\n-                                    ProjectionElem::Index(..) => true,\n-                                    _ => false,\n-                                },\n-                            },\n-                        ));\n+                    _ => {\n+                        // FIXME: still badly broken\n                     }\n-                    ty::Array(..) => match proj.elem {\n-                        ProjectionElem::Index(..) => {\n-                            return Err(MoveError::cannot_move_out_of(\n-                                self.loc,\n-                                InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n-                            ));\n-                        }\n-                        _ => {\n-                            // FIXME: still badly broken\n-                        }\n-                    },\n-                    _ => {}\n-                };\n+                },\n+                _ => {}\n+            };\n \n-                base = match self\n-                    .builder\n-                    .data\n-                    .rev_lookup\n-                    .projections\n-                    .entry((base, proj.elem.lift()))\n+            let proj = &place.projection[..i+1];\n+            base = match self\n+                .builder\n+                .data\n+                .rev_lookup\n+                .projections\n+                .entry((base, elem.lift()))\n                 {\n                     Entry::Occupied(ent) => *ent.get(),\n                     Entry::Vacant(ent) => {\n@@ -169,18 +171,17 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             &mut self.builder.data.init_path_map,\n                             Some(base),\n                             Place {\n-                                base: place_base.clone(),\n-                                projection: Some(Box::new(proj.clone())),\n+                                base: place.base.clone(),\n+                                projection: proj.to_vec().into_boxed_slice(),\n                             },\n                         );\n                         ent.insert(path);\n                         path\n                     }\n                 };\n-            }\n+        }\n \n-            Ok(base)\n-        })\n+        Ok(base)\n     }\n \n     fn create_move_path(&mut self, place: &Place<'tcx>) {\n@@ -355,7 +356,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Unreachable => {}\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Place::RETURN_PLACE);\n+                self.gather_move(&Place::return_place());\n             }\n \n             TerminatorKind::Assert { ref cond, .. } => {\n@@ -435,9 +436,8 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n         // Check if we are assigning into a field of a union, if so, lookup the place\n         // of the union so it is marked as initialized again.\n-        if let Some(box Projection { base: proj_base, elem: ProjectionElem::Field(_, _) }) =\n-            place.projection\n-        {\n+        if let [.., ProjectionElem::Field(_, _)] = place.projection {\n+            let proj_base = &place.projection[..place.projection.len() - 1];\n             if let ty::Adt(def, _) =\n                 Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.sty\n             {"}, {"sha": "156c19c6363e58a74ffd4077f7af571112617979", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -245,23 +245,21 @@ impl MovePathLookup {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, place_ref: PlaceRef<'_, '_>) -> LookupResult {\n-        place_ref.iterate(|place_base, place_projection| {\n-            let mut result = match place_base {\n-                PlaceBase::Local(local) => self.locals[*local],\n-                PlaceBase::Static(..) => return LookupResult::Parent(None),\n-            };\n-\n-            for proj in place_projection {\n-                if let Some(&subpath) = self.projections.get(&(result, proj.elem.lift())) {\n-                    result = subpath;\n-                } else {\n-                    return LookupResult::Parent(Some(result));\n-                }\n+    pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n+        let mut result = match place.base {\n+            PlaceBase::Local(local) => self.locals[*local],\n+            PlaceBase::Static(..) => return LookupResult::Parent(None),\n+        };\n+\n+        for elem in place.projection.iter() {\n+            if let Some(&subpath) = self.projections.get(&(result, elem.lift())) {\n+                result = subpath;\n+            } else {\n+                return LookupResult::Parent(Some(result));\n             }\n+        }\n \n-            LookupResult::Exact(result)\n-        })\n+        LookupResult::Exact(result)\n     }\n \n     pub fn find_local(&self, local: Local) -> MovePathIndex {\n@@ -329,7 +327,7 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place { base: PlaceBase::Local(l), projection: None } = path.place {\n+            if let Place { base: PlaceBase::Local(l), projection: box [] } = path.place {\n                 return Some(l);\n             }\n             if let Some(parent) = path.parent {"}, {"sha": "06b7206f4292c8aca5edbdfd9581d868a98beee6", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -472,39 +472,37 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // avoid allocations.\n     pub(super) fn eval_place_to_op(\n         &self,\n-        mir_place: &mir::Place<'tcx>,\n+        place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::PlaceBase;\n \n-        mir_place.iterate(|place_base, place_projection| {\n-            let mut op = match place_base {\n-                PlaceBase::Local(mir::RETURN_PLACE) =>\n-                    throw_unsup!(ReadFromReturnPointer),\n-                PlaceBase::Local(local) => {\n-                    // Do not use the layout passed in as argument if the base we are looking at\n-                    // here is not the entire place.\n-                    // FIXME use place_projection.is_empty() when is available\n-                    let layout = if mir_place.projection.is_none() {\n-                        layout\n-                    } else {\n-                        None\n-                    };\n-\n-                    self.access_local(self.frame(), *local, layout)?\n-                }\n-                PlaceBase::Static(place_static) => {\n-                    self.eval_static_to_mplace(place_static)?.into()\n-                }\n-            };\n+        let mut op = match &place.base {\n+            PlaceBase::Local(mir::RETURN_PLACE) =>\n+                throw_unsup!(ReadFromReturnPointer),\n+            PlaceBase::Local(local) => {\n+                // Do not use the layout passed in as argument if the base we are looking at\n+                // here is not the entire place.\n+                // FIXME use place_projection.is_empty() when is available\n+                let layout = if place.projection.is_empty() {\n+                    layout\n+                } else {\n+                    None\n+                };\n \n-            for proj in place_projection {\n-                op = self.operand_projection(op, &proj.elem)?\n+                self.access_local(self.frame(), *local, layout)?\n+            }\n+            PlaceBase::Static(place_static) => {\n+                self.eval_static_to_mplace(&place_static)?.into()\n             }\n+        };\n \n-            trace!(\"eval_place_to_op: got {:?}\", *op);\n-            Ok(op)\n-        })\n+        for elem in place.projection.iter() {\n+            op = self.operand_projection(op, elem)?\n+        }\n+\n+        trace!(\"eval_place_to_op: got {:?}\", *op);\n+        Ok(op)\n     }\n \n     /// Evaluate the operand, returning a place where you can then find the data."}, {"sha": "1a28548618206a2afb95d0c6c182e9ff80765e3b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -629,45 +629,43 @@ where\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n-        mir_place: &mir::Place<'tcx>,\n+        place: &mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::PlaceBase;\n \n-        mir_place.iterate(|place_base, place_projection| {\n-            let mut place = match place_base {\n-                PlaceBase::Local(mir::RETURN_PLACE) => match self.frame().return_place {\n-                    Some(return_place) => {\n-                        // We use our layout to verify our assumption; caller will validate\n-                        // their layout on return.\n-                        PlaceTy {\n-                            place: *return_place,\n-                            layout: self.layout_of(\n-                                self.subst_from_frame_and_normalize_erasing_regions(\n-                                    self.frame().body.return_ty()\n-                                )\n-                            )?,\n-                        }\n+        let mut place_ty = match &place.base {\n+            PlaceBase::Local(mir::RETURN_PLACE) => match self.frame().return_place {\n+                Some(return_place) => {\n+                    // We use our layout to verify our assumption; caller will validate\n+                    // their layout on return.\n+                    PlaceTy {\n+                        place: *return_place,\n+                        layout: self.layout_of(\n+                            self.subst_from_frame_and_normalize_erasing_regions(\n+                                self.frame().body.return_ty()\n+                            )\n+                        )?,\n                     }\n-                    None => throw_unsup!(InvalidNullPointerUsage),\n-                },\n-                PlaceBase::Local(local) => PlaceTy {\n-                    // This works even for dead/uninitialized locals; we check further when writing\n-                    place: Place::Local {\n-                        frame: self.cur_frame(),\n-                        local: *local,\n-                    },\n-                    layout: self.layout_of_local(self.frame(), *local, None)?,\n+                }\n+                None => throw_unsup!(InvalidNullPointerUsage),\n+            },\n+            PlaceBase::Local(local) => PlaceTy {\n+                // This works even for dead/uninitialized locals; we check further when writing\n+                place: Place::Local {\n+                    frame: self.cur_frame(),\n+                    local: *local,\n                 },\n-                PlaceBase::Static(place_static) => self.eval_static_to_mplace(place_static)?.into(),\n-            };\n+                layout: self.layout_of_local(self.frame(), *local, None)?,\n+            },\n+            PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n+        };\n \n-            for proj in place_projection {\n-                place = self.place_projection(place, &proj.elem)?\n-            }\n+        for elem in place.projection.iter() {\n+            place_ty = self.place_projection(place_ty, elem)?\n+        }\n \n-            self.dump_place(place.place);\n-            Ok(place)\n-        })\n+        self.dump_place(place_ty.place);\n+        Ok(place_ty)\n     }\n \n     /// Write a scalar to a place"}, {"sha": "8310ef02f96692798446d5222fe862da2f257f8d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -391,7 +391,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n                         let callee_ret = self.eval_place(\n-                            &mir::Place::RETURN_PLACE\n+                            &mir::Place::return_place()\n                         )?;\n                         if !Self::check_argument_compat(\n                             rust_abi,"}, {"sha": "9086ae844dd520086a2c470ee5bc7748d8140a42", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -308,7 +308,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env, builder.span);\n \n-    let dest = Place::RETURN_PLACE;\n+    let dest = Place::return_place();\n     let src = Place::from(Local::new(1+0)).deref();\n \n     match self_ty.sty {\n@@ -415,7 +415,7 @@ impl CloneShimBuilder<'tcx> {\n         let rcvr = Place::from(Local::new(1+0)).deref();\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::RETURN_PLACE,\n+                Place::return_place(),\n                 box Rvalue::Use(Operand::Copy(rcvr))\n             )\n         );\n@@ -773,7 +773,7 @@ fn build_call_shim<'tcx>(\n     block(&mut blocks, statements, TerminatorKind::Call {\n         func: callee,\n         args,\n-        destination: Some((Place::RETURN_PLACE,\n+        destination: Some((Place::return_place(),\n                            BasicBlock::new(1))),\n         cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n             Some(BasicBlock::new(3))\n@@ -868,7 +868,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n     debug!(\"build_ctor: variant_index={:?}\", variant_index);\n \n     let statements = expand_aggregate(\n-        Place::RETURN_PLACE,\n+        Place::return_place(),\n         adt_def\n             .variants[variant_index]\n             .fields"}, {"sha": "466f6060827ec1d7b15f95538157982bfbb841e0", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -17,12 +17,11 @@ pub struct AddRetag;\n fn is_stable(\n     place: PlaceRef<'_, '_>,\n ) -> bool {\n-    if let Some(proj) = &place.projection {\n-        match proj.elem {\n+    place.projection.iter().all(|elem| {\n+        match elem {\n             // Which place this evaluates to can change with any memory write,\n             // so cannot assume this to be stable.\n-            ProjectionElem::Deref =>\n-                false,\n+            ProjectionElem::Deref => false,\n             // Array indices are intersting, but MIR building generates a *fresh*\n             // temporary for every array access, so the index cannot be changed as\n             // a side-effect.\n@@ -31,15 +30,9 @@ fn is_stable(\n             ProjectionElem::Field { .. } |\n             ProjectionElem::ConstantIndex { .. } |\n             ProjectionElem::Subslice { .. } |\n-            ProjectionElem::Downcast { .. } =>\n-                is_stable(PlaceRef {\n-                    base: place.base,\n-                    projection: &proj.base,\n-                }),\n+            ProjectionElem::Downcast { .. } => true,\n         }\n-    } else {\n-        true\n-    }\n+    })\n }\n \n /// Determine whether this type may be a reference (or box), and thus needs retagging."}, {"sha": "f8af9b9fcbee0c8da760767172501039a5d2d309", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 113, "deletions": 113, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -200,127 +200,127 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     place: &Place<'tcx>,\n                     context: PlaceContext,\n                     _location: Location) {\n-        place.iterate(|place_base, place_projections| {\n-            match place_base {\n-                PlaceBase::Local(..) => {\n-                    // Locals are safe.\n-                }\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n-                    bug!(\"unsafety checking should happen before promotion\")\n-                }\n-                PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n-                    if self.tcx.is_mutable_static(*def_id) {\n-                        self.require_unsafe(\"use of mutable static\",\n-                            \"mutable statics can be mutated by multiple threads: aliasing \\\n-                             violations or data races will cause undefined behavior\",\n-                             UnsafetyViolationKind::General);\n-                    } else if self.tcx.is_foreign_item(*def_id) {\n-                        let source_info = self.source_info;\n-                        let lint_root =\n-                            self.source_scope_local_data[source_info.scope].lint_root;\n-                        self.register_violations(&[UnsafetyViolation {\n-                            source_info,\n-                            description: InternedString::intern(\"use of extern static\"),\n-                            details: InternedString::intern(\n-                                \"extern statics are not controlled by the Rust type system: \\\n-                                invalid data, aliasing violations or data races will cause \\\n-                                undefined behavior\"),\n-                            kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                        }], &[]);\n-                    }\n+        match place.base {\n+            PlaceBase::Local(..) => {\n+                // Locals are safe.\n+            }\n+            PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n+                bug!(\"unsafety checking should happen before promotion\")\n+            }\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n+                if self.tcx.is_mutable_static(def_id) {\n+                    self.require_unsafe(\"use of mutable static\",\n+                        \"mutable statics can be mutated by multiple threads: aliasing \\\n+                         violations or data races will cause undefined behavior\",\n+                         UnsafetyViolationKind::General);\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.source_scope_local_data[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: InternedString::intern(\"use of extern static\"),\n+                        details: InternedString::intern(\n+                            \"extern statics are not controlled by the Rust type system: \\\n+                            invalid data, aliasing violations or data races will cause \\\n+                            undefined behavior\"),\n+                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n+                    }], &[]);\n                 }\n             }\n+        }\n \n-            for proj in place_projections {\n-                if context.is_borrow() {\n-                    if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n-                        let source_info = self.source_info;\n-                        let lint_root =\n-                            self.source_scope_local_data[source_info.scope].lint_root;\n-                        self.register_violations(&[UnsafetyViolation {\n-                            source_info,\n-                            description: InternedString::intern(\"borrow of packed field\"),\n-                            details: InternedString::intern(\n-                                \"fields of packed structs might be misaligned: dereferencing a \\\n-                                misaligned pointer or even just creating a misaligned reference \\\n-                                is undefined behavior\"),\n-                            kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n-                        }], &[]);\n-                    }\n+        for (i, elem) in place.projection.iter().enumerate() {\n+            let proj_base = &place.projection[..i];\n+\n+            if context.is_borrow() {\n+                if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.source_scope_local_data[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: InternedString::intern(\"borrow of packed field\"),\n+                        details: InternedString::intern(\n+                            \"fields of packed structs might be misaligned: dereferencing a \\\n+                            misaligned pointer or even just creating a misaligned reference \\\n+                            is undefined behavior\"),\n+                        kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n+                    }], &[]);\n                 }\n-                let is_borrow_of_interior_mut = context.is_borrow() &&\n-                    !Place::ty_from(&place.base, &proj.base, self.body, self.tcx)\n-                    .ty\n-                    .is_freeze(self.tcx, self.param_env, self.source_info.span);\n-                // prevent\n-                // * `&mut x.field`\n-                // * `x.field = y;`\n-                // * `&x.field` if `field`'s type has interior mutability\n-                // because either of these would allow modifying the layout constrained field and\n-                // insert values that violate the layout constraints.\n-                if context.is_mutating_use() || is_borrow_of_interior_mut {\n-                    self.check_mut_borrowing_layout_constrained_field(\n-                        place, context.is_mutating_use(),\n-                    );\n+            }\n+            let is_borrow_of_interior_mut = context.is_borrow() &&\n+                !Place::ty_from(&place.base, proj_base, self.body, self.tcx)\n+                .ty\n+                .is_freeze(self.tcx, self.param_env, self.source_info.span);\n+            // prevent\n+            // * `&mut x.field`\n+            // * `x.field = y;`\n+            // * `&x.field` if `field`'s type has interior mutability\n+            // because either of these would allow modifying the layout constrained field and\n+            // insert values that violate the layout constraints.\n+            if context.is_mutating_use() || is_borrow_of_interior_mut {\n+                self.check_mut_borrowing_layout_constrained_field(\n+                    place, context.is_mutating_use(),\n+                );\n+            }\n+            let old_source_info = self.source_info;\n+            if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n+                if self.body.local_decls[*local].internal {\n+                    // Internal locals are used in the `move_val_init` desugaring.\n+                    // We want to check unsafety against the source info of the\n+                    // desugaring, rather than the source info of the RHS.\n+                    self.source_info = self.body.local_decls[*local].source_info;\n                 }\n-                let old_source_info = self.source_info;\n-                if let (PlaceBase::Local(local), None) = (&place.base, &proj.base) {\n-                    if self.body.local_decls[*local].internal {\n-                        // Internal locals are used in the `move_val_init` desugaring.\n-                        // We want to check unsafety against the source info of the\n-                        // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[*local].source_info;\n-                    }\n+            }\n+            let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+            match base_ty.sty {\n+                ty::RawPtr(..) => {\n+                    self.require_unsafe(\"dereference of raw pointer\",\n+                        \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n+                         aliasing rules and cause data races: all of these are undefined \\\n+                         behavior\", UnsafetyViolationKind::General)\n                 }\n-                let base_ty = Place::ty_from(&place.base, &proj.base, self.body, self.tcx).ty;\n-                match base_ty.sty {\n-                    ty::RawPtr(..) => {\n-                        self.require_unsafe(\"dereference of raw pointer\",\n-                            \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n-                             aliasing rules and cause data races: all of these are undefined \\\n-                             behavior\", UnsafetyViolationKind::General)\n-                    }\n-                    ty::Adt(adt, _) => {\n-                        if adt.is_union() {\n-                            if context == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n-                                context == PlaceContext::MutatingUse(MutatingUseContext::Drop) ||\n-                                context == PlaceContext::MutatingUse(\n-                                    MutatingUseContext::AsmOutput\n-                                )\n-                            {\n-                                let elem_ty = match proj.elem {\n-                                    ProjectionElem::Field(_, ty) => ty,\n-                                    _ => span_bug!(\n-                                        self.source_info.span,\n-                                        \"non-field projection {:?} from union?\",\n-                                        place)\n-                                };\n-                                if !elem_ty.is_copy_modulo_regions(\n-                                    self.tcx,\n-                                    self.param_env,\n+                ty::Adt(adt, _) => {\n+                    if adt.is_union() {\n+                        if context == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n+                            context == PlaceContext::MutatingUse(MutatingUseContext::Drop) ||\n+                            context == PlaceContext::MutatingUse(\n+                                MutatingUseContext::AsmOutput\n+                            )\n+                        {\n+                            let elem_ty = match elem {\n+                                ProjectionElem::Field(_, ty) => ty,\n+                                _ => span_bug!(\n                                     self.source_info.span,\n-                                ) {\n-                                    self.require_unsafe(\n-                                        \"assignment to non-`Copy` union field\",\n-                                        \"the previous content of the field will be dropped, which \\\n-                                         causes undefined behavior if the field was not properly \\\n-                                         initialized\", UnsafetyViolationKind::General)\n-                                } else {\n-                                    // write to non-move union, safe\n-                                }\n+                                    \"non-field projection {:?} from union?\",\n+                                    place)\n+                            };\n+                            if !elem_ty.is_copy_modulo_regions(\n+                                self.tcx,\n+                                self.param_env,\n+                                self.source_info.span,\n+                            ) {\n+                                self.require_unsafe(\n+                                    \"assignment to non-`Copy` union field\",\n+                                    \"the previous content of the field will be dropped, which \\\n+                                     causes undefined behavior if the field was not properly \\\n+                                     initialized\", UnsafetyViolationKind::General)\n                             } else {\n-                                self.require_unsafe(\"access to union field\",\n-                                    \"the field may not be properly initialized: using \\\n-                                     uninitialized data will cause undefined behavior\",\n-                                     UnsafetyViolationKind::General)\n+                                // write to non-move union, safe\n                             }\n+                        } else {\n+                            self.require_unsafe(\"access to union field\",\n+                                \"the field may not be properly initialized: using \\\n+                                 uninitialized data will cause undefined behavior\",\n+                                 UnsafetyViolationKind::General)\n                         }\n                     }\n-                    _ => {}\n                 }\n-                self.source_info = old_source_info;\n+                _ => {}\n             }\n-        });\n+            self.source_info = old_source_info;\n+        }\n     }\n }\n \n@@ -407,12 +407,13 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         place: &Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        let mut projection = &place.projection;\n-        while let Some(proj) = projection {\n-            match proj.elem {\n+        for (i, elem) in place.projection.iter().enumerate().rev() {\n+            let proj_base = &place.projection[..i];\n+\n+            match elem {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n-                        Place::ty_from(&place.base, &proj.base, &self.body.local_decls, self.tcx)\n+                        Place::ty_from(&place.base, proj_base, &self.body.local_decls, self.tcx)\n                             .ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n@@ -447,7 +448,6 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 }\n                 _ => {}\n             }\n-            projection = &proj.base;\n         }\n     }\n }"}, {"sha": "2e91561f2eee1c1d1f3cf5fb7c52dbd59f799821", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -282,53 +282,53 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        place.iterate(|place_base, place_projection| {\n-            let mut eval = match place_base {\n-                PlaceBase::Local(loc) => self.get_const(*loc).clone()?,\n-                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted, _), ..}) => {\n-                    let generics = self.tcx.generics_of(self.source.def_id());\n-                    if generics.requires_monomorphization(self.tcx) {\n-                        // FIXME: can't handle code with generics\n-                        return None;\n-                    }\n-                    let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                    let instance = Instance::new(self.source.def_id(), substs);\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: Some(*promoted),\n-                    };\n-                    let res = self.use_ecx(source_info, |this| {\n-                        this.ecx.const_eval_raw(cid)\n+        let mut eval = match place.base {\n+            PlaceBase::Local(loc) => self.get_const(loc).clone()?,\n+            PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted, _), ..}) => {\n+                let generics = self.tcx.generics_of(self.source.def_id());\n+                if generics.requires_monomorphization(self.tcx) {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                let instance = Instance::new(self.source.def_id(), substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(promoted),\n+                };\n+                let res = self.use_ecx(source_info, |this| {\n+                    this.ecx.const_eval_raw(cid)\n+                })?;\n+                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                res.into()\n+            }\n+            _ => return None,\n+        };\n+\n+        for (i, elem) in place.projection.iter().enumerate() {\n+            let proj_base = &place.projection[..i];\n+\n+            match elem {\n+                ProjectionElem::Field(field, _) => {\n+                    trace!(\"field proj on {:?}\", proj_base);\n+                    eval = self.use_ecx(source_info, |this| {\n+                        this.ecx.operand_field(eval, field.index() as u64)\n                     })?;\n-                    trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                    res.into()\n+                },\n+                ProjectionElem::Deref => {\n+                    trace!(\"processing deref\");\n+                    eval = self.use_ecx(source_info, |this| {\n+                        this.ecx.deref_operand(eval)\n+                    })?.into();\n                 }\n+                // We could get more projections by using e.g., `operand_projection`,\n+                // but we do not even have the stack frame set up properly so\n+                // an `Index` projection would throw us off-track.\n                 _ => return None,\n-            };\n-\n-            for proj in place_projection {\n-                match proj.elem {\n-                    ProjectionElem::Field(field, _) => {\n-                        trace!(\"field proj on {:?}\", proj.base);\n-                        eval = self.use_ecx(source_info, |this| {\n-                            this.ecx.operand_field(eval, field.index() as u64)\n-                        })?;\n-                    },\n-                    ProjectionElem::Deref => {\n-                        trace!(\"processing deref\");\n-                        eval = self.use_ecx(source_info, |this| {\n-                            this.ecx.deref_operand(eval)\n-                        })?.into();\n-                    }\n-                    // We could get more projections by using e.g., `operand_projection`,\n-                    // but we do not even have the stack frame set up properly so\n-                    // an `Index` projection would throw us off-track.\n-                    _ => return None,\n-                }\n             }\n+        }\n \n-            Some(eval)\n-        })\n+        Some(eval)\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n@@ -673,7 +673,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n                     if let Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n+                        projection: box [],\n                     } = *place {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {"}, {"sha": "20bdb4b03f0813dfa94d85991f1b071ed6a741d6", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                         StatementKind::Assign(\n                             Place {\n                                 base: PlaceBase::Local(local),\n-                                projection: None,\n+                                projection: box [],\n                             },\n                             box Rvalue::Use(ref operand)\n                         ) if local == dest_local => {\n@@ -150,21 +150,21 @@ fn eliminate_self_assignments(\n                     StatementKind::Assign(\n                         Place {\n                             base: PlaceBase::Local(local),\n-                            projection: None,\n+                            projection: box [],\n                         },\n                         box Rvalue::Use(Operand::Copy(Place {\n                             base: PlaceBase::Local(src_local),\n-                            projection: None,\n+                            projection: box [],\n                         })),\n                     ) |\n                     StatementKind::Assign(\n                         Place {\n                             base: PlaceBase::Local(local),\n-                            projection: None,\n+                            projection: box [],\n                         },\n                         box Rvalue::Use(Operand::Move(Place {\n                             base: PlaceBase::Local(src_local),\n-                            projection: None,\n+                            projection: box [],\n                         })),\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n@@ -194,7 +194,7 @@ impl<'tcx> Action<'tcx> {\n         // The source must be a local.\n         let src_local = if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = *src_place {\n             local\n         } else {\n@@ -351,11 +351,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         match *operand {\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) |\n             Operand::Move(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) if local == self.dest_local => {}\n             _ => return,\n         }"}, {"sha": "47c7c2c5cb3196cbd21f4981674f791540e2ac9f", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -236,47 +236,37 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n \n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection {\n-                    elem: ProjectionElem::Field(idx, _), ..\n-                } => idx == field,\n-                _ => false\n-            }\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| match p {\n+            [.., ProjectionElem::Field(idx, _)] => *idx == field,\n+            _ => false,\n         })\n     }\n \n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection {\n-                    elem: ProjectionElem::ConstantIndex{offset, min_length: _, from_end: false}, ..\n-                } => offset == index,\n-                &Projection {\n-                    elem: ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true}, ..\n-                } => size - offset == index,\n-                _ => false\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| match p {\n+            [.., ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }] => {\n+                *offset == index\n+            }\n+            [.., ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }] => {\n+                size - offset == index\n             }\n+            _ => false,\n         })\n     }\n \n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n             match p {\n-                &Projection { elem: ProjectionElem::Deref, .. } => true,\n+                [.., ProjectionElem::Deref] => true,\n                 _ => false\n             }\n         })\n     }\n \n     fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection {\n-                    elem: ProjectionElem::Downcast(_, idx), ..\n-                } => idx == variant,\n-                _ => false\n-            }\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| match p {\n+            [.., ProjectionElem::Downcast(_, idx)] => *idx == variant,\n+            _ => false\n         })\n     }\n "}, {"sha": "cf899c64406bca8759e5275c306527ce987f6de9", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -107,10 +107,7 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n         if place.base == PlaceBase::Local(self_arg()) {\n             replace_base(place, Place {\n                 base: PlaceBase::Local(self_arg()),\n-                projection: Some(Box::new(Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                })),\n+                projection: Box::new([ProjectionElem::Deref]),\n             });\n         } else {\n             self.super_place(place, context, location);\n@@ -137,10 +134,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n         if place.base == PlaceBase::Local(self_arg()) {\n             replace_base(place, Place {\n                 base: PlaceBase::Local(self_arg()),\n-                projection: Some(Box::new(Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Field(Field::new(0), self.ref_gen_ty),\n-                })),\n+                projection: Box::new([ProjectionElem::Field(Field::new(0), self.ref_gen_ty)]),\n             });\n         } else {\n             self.super_place(place, context, location);\n@@ -149,13 +143,12 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n }\n \n fn replace_base(place: &mut Place<'tcx>, new_base: Place<'tcx>) {\n-    let mut projection = &mut place.projection;\n-    while let Some(box proj) = projection {\n-        projection = &mut proj.base;\n-    }\n-\n     place.base = new_base.base;\n-    *projection = new_base.projection;\n+\n+    let mut new_projection = new_base.projection.to_vec();\n+    new_projection.append(&mut place.projection.to_vec());\n+\n+    place.projection = new_projection.into_boxed_slice();\n }\n \n fn self_arg() -> Local {\n@@ -210,13 +203,12 @@ impl TransformVisitor<'tcx> {\n     fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n         let self_place = Place::from(self_arg());\n         let base = self_place.downcast_unnamed(variant_index);\n-        let field = Projection {\n-            base: base.projection,\n-            elem: ProjectionElem::Field(Field::new(idx), ty),\n-        };\n+        let mut projection = base.projection.to_vec();\n+        projection.push(ProjectionElem::Field(Field::new(idx), ty));\n+\n         Place {\n             base: base.base,\n-            projection: Some(Box::new(field)),\n+            projection: projection.into_boxed_slice(),\n         }\n     }\n \n@@ -296,7 +288,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n             // We must assign the value first in case it gets declared dead below\n             data.statements.push(Statement {\n                 source_info,\n-                kind: StatementKind::Assign(Place::RETURN_PLACE,\n+                kind: StatementKind::Assign(Place::return_place(),\n                                             box self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n@@ -848,7 +840,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n                 kind: TerminatorKind::Drop {\n                     location: Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n+                        projection: box [],\n                     },\n                     target,\n                     unwind"}, {"sha": "2b3c6d55f24ddd4ab69784bd2cf8dbf0192c2a34", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -425,22 +425,20 @@ impl Inliner<'tcx> {\n                 // writes to `i`. To prevent this we need to create a temporary\n                 // borrow of the place and pass the destination as `*temp` instead.\n                 fn dest_needs_borrow(place: &Place<'_>) -> bool {\n-                    place.iterate(|place_base, place_projection| {\n-                        for proj in place_projection {\n-                            match proj.elem {\n-                                ProjectionElem::Deref |\n-                                ProjectionElem::Index(_) => return true,\n-                                _ => {}\n-                            }\n+                    for elem in place.projection.iter() {\n+                        match elem {\n+                            ProjectionElem::Deref |\n+                            ProjectionElem::Index(_) => return true,\n+                            _ => {}\n                         }\n+                    }\n \n-                        match place_base {\n-                            // Static variables need a borrow because the callee\n-                            // might modify the same static.\n-                            PlaceBase::Static(_) => true,\n-                            _ => false\n-                        }\n-                    })\n+                    match place.base {\n+                        // Static variables need a borrow because the callee\n+                        // might modify the same static.\n+                        PlaceBase::Static(_) => true,\n+                        _ => false\n+                    }\n                 }\n \n                 let dest = if dest_needs_borrow(&destination.0) {\n@@ -591,7 +589,7 @@ impl Inliner<'tcx> {\n \n         if let Operand::Move(Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         }) = arg {\n             if caller_body.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n@@ -660,7 +658,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             match self.destination {\n                 Place {\n                     base: PlaceBase::Local(l),\n-                    projection: None,\n+                    projection: box [],\n                 } => {\n                     *local = l;\n                     return;\n@@ -684,7 +682,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         match place {\n             Place {\n                 base: PlaceBase::Local(RETURN_PLACE),\n-                projection: None,\n+                projection: box [],\n             } => {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();"}, {"sha": "b949e2f5ddd1d9f9d62f114df74b0c6147acb50e", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -43,12 +43,19 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n             let new_place = match *rvalue {\n                 Rvalue::Ref(_, _, Place {\n                     ref mut base,\n-                    projection: Some(ref mut projection),\n-                }) => Place {\n-                    // Replace with dummy\n-                    base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n-                    projection: projection.base.take(),\n-                },\n+                    projection: ref mut projection @ box [.., _],\n+                }) => {\n+                    let (proj_l, proj_r) = projection.split_at(projection.len() - 1);\n+\n+                    let place = Place {\n+                        // Replace with dummy\n+                        base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n+                        projection: proj_l.to_vec().into_boxed_slice(),\n+                    };\n+                    *projection = proj_r.to_vec().into_boxed_slice();\n+\n+                    place\n+                }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n             *rvalue = Rvalue::Use(Operand::Copy(new_place))\n@@ -83,12 +90,19 @@ impl OptimizationFinder<'b, 'tcx> {\n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place {\n-            ref base,\n-            projection: Some(ref projection),\n-        }) = *rvalue {\n-            if let ProjectionElem::Deref = projection.elem {\n-                if Place::ty_from(&base, &projection.base, self.body, self.tcx).ty.is_region_ptr() {\n-                    self.optimizations.and_stars.insert(location);\n+            base: _,\n+            projection: box [.., elem],\n+        }) = rvalue {\n+            if *elem == ProjectionElem::Deref {\n+                // FIXME remove this once we can use slices patterns\n+                if let Rvalue::Ref(_, _, Place {\n+                    base,\n+                    projection,\n+                }) = rvalue {\n+                    let proj_base = &projection[..projection.len() - 1];\n+                    if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                        self.optimizations.and_stars.insert(location);\n+                    }\n                 }\n             }\n         }"}, {"sha": "0723a0c992e8e2a4b5cbdef82bbcc641654e0524", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -318,7 +318,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ty,\n                         def_id,\n                     }),\n-                    projection: None,\n+                    projection: box [],\n                 }\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n@@ -334,9 +334,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             Operand::Move(Place {\n                                 base: mem::replace(\n                                     &mut place.base,\n-                                    promoted_place(ty, span).base\n+                                    promoted_place(ty, span).base,\n                                 ),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                         }\n                         _ => bug!()\n@@ -422,7 +422,7 @@ pub fn promote_candidates<'tcx>(\n                 match body[block].statements[statement_index].kind {\n                     StatementKind::Assign(Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n+                        projection: box [],\n                     }, _) => {\n                         if temps[local] == TempState::PromotedOut {\n                             // Already promoted.\n@@ -475,7 +475,7 @@ pub fn promote_candidates<'tcx>(\n             match statement.kind {\n                 StatementKind::Assign(Place {\n                     base: PlaceBase::Local(index),\n-                    projection: None,\n+                    projection: box [],\n                 }, _) |\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n@@ -488,7 +488,7 @@ pub fn promote_candidates<'tcx>(\n         match terminator.kind {\n             TerminatorKind::Drop { location: Place {\n                 base: PlaceBase::Local(index),\n-                projection: None,\n+                projection: box [],\n             }, target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {"}, {"sha": "27a46d345031712e541a298672712dc3e8c147a8", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 98, "deletions": 91, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -187,26 +187,27 @@ trait Qualif {\n         cx: &ConstCx<'_, 'tcx>,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n-        let proj = place.projection.as_ref().unwrap();\n+        let elem = &place.projection[place.projection.len() - 1];\n+        let proj_base = &place.projection[..place.projection.len() - 1];\n \n         let base_qualif = Self::in_place(cx, PlaceRef {\n             base: place.base,\n-            projection: &proj.base,\n+            projection: proj_base,\n         });\n         let qualif = base_qualif && Self::mask_for_ty(\n             cx,\n-            Place::ty_from(place.base, &proj.base, cx.body, cx.tcx)\n-                .projection_ty(cx.tcx, &proj.elem)\n+            Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n+                .projection_ty(cx.tcx, elem)\n                 .ty,\n         );\n-        match proj.elem {\n+        match elem {\n             ProjectionElem::Deref |\n             ProjectionElem::Subslice { .. } |\n             ProjectionElem::Field(..) |\n             ProjectionElem::ConstantIndex { .. } |\n             ProjectionElem::Downcast(..) => qualif,\n \n-            ProjectionElem::Index(local) => qualif || Self::in_local(cx, local),\n+            ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n         }\n     }\n \n@@ -221,24 +222,24 @@ trait Qualif {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => Self::in_local(cx, *local),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n             PlaceRef {\n                 base: PlaceBase::Static(static_),\n-                projection: None,\n+                projection: [],\n             } => {\n                 Self::in_static(cx, static_)\n             },\n             PlaceRef {\n                 base: _,\n-                projection: Some(_),\n+                projection: [.., _],\n             } => Self::in_projection(cx, place),\n         }\n     }\n@@ -289,13 +290,16 @@ trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let Some(ref proj) = place.projection {\n-                    if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = Place::ty_from(&place.base, &proj.base, cx.body, cx.tcx).ty;\n+                if !place.projection.is_empty() {\n+                    let elem = &place.projection[place.projection.len() - 1];\n+                    let proj_base = &place.projection[..place.projection.len() - 1];\n+\n+                    if ProjectionElem::Deref == *elem {\n+                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n                             return Self::in_place(cx, PlaceRef {\n                                 base: &place.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             });\n                         }\n                     }\n@@ -453,9 +457,10 @@ impl Qualif for IsNotPromotable {\n         cx: &ConstCx<'_, 'tcx>,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n-        let proj = place.projection.as_ref().unwrap();\n+        let elem = &place.projection[place.projection.len() - 1];\n+        let proj_base = &place.projection[..place.projection.len() - 1];\n \n-        match proj.elem {\n+        match elem {\n             ProjectionElem::Deref |\n             ProjectionElem::Downcast(..) => return true,\n \n@@ -465,7 +470,7 @@ impl Qualif for IsNotPromotable {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::NonConstFn {\n-                    let base_ty = Place::ty_from(place.base, &proj.base, cx.body, cx.tcx).ty;\n+                    let base_ty = Place::ty_from(place.base, proj_base, cx.body, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         // No promotion of union field accesses.\n                         if def.is_union() {\n@@ -806,23 +811,18 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     // We might have a candidate for promotion.\n                     let candidate = Candidate::Ref(location);\n                     // Start by traversing to the \"base\", with non-deref projections removed.\n-                    let mut place_projection = &place.projection;\n-                    while let Some(proj) = place_projection {\n-                        if proj.elem == ProjectionElem::Deref {\n-                            break;\n-                        }\n-                        place_projection = &proj.base;\n-                    }\n+                    let deref_proj =\n+                        place.projection.iter().rev().find(|&elem| *elem == ProjectionElem::Deref);\n \n                     debug!(\n                         \"qualify_consts: promotion candidate: place={:?} {:?}\",\n-                        place.base, place_projection\n+                        place.base, deref_proj\n                     );\n                     // We can only promote interior borrows of promotable temps (non-temps\n                     // don't get promoted anyway).\n                     // (If we bailed out of the loop due to a `Deref` above, we will definitely\n                     // not enter the conditional here.)\n-                    if let (PlaceBase::Local(local), None) = (&place.base, place_projection) {\n+                    if let (PlaceBase::Local(local), None) = (&place.base, deref_proj) {\n                         if self.body.local_kind(*local) == LocalKind::Temp {\n                             debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n                             // The borrowed place doesn't have `HasMutInterior`\n@@ -858,27 +858,29 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             _ => {},\n         }\n \n-        let mut dest_projection = &dest.projection;\n+        let mut dest_projection = &dest.projection[..];\n         let index = loop {\n             match (&dest.base, dest_projection) {\n                 // We treat all locals equal in constants\n-                (&PlaceBase::Local(index), None) => break index,\n+                (&PlaceBase::Local(index), []) => break index,\n                 // projections are transparent for assignments\n                 // we qualify the entire destination at once, even if just a field would have\n                 // stricter qualification\n-                (base, Some(proj)) => {\n+                (base, proj @ [.., _]) => {\n+                    let proj_base = &proj[..proj.len() - 1];\n+\n                     // Catch more errors in the destination. `visit_place` also checks various\n                     // projection rules like union field access and raw pointer deref\n                     let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n                     self.visit_place_base(base, context, location);\n                     self.visit_projection(base, proj, context, location);\n-                    dest_projection = &proj.base;\n+                    dest_projection = proj_base;\n                 },\n                 (&PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n                     ..\n-                }), None) => bug!(\"promoteds don't exist yet during promotion\"),\n-                (&PlaceBase::Static(box Static{ kind: _, .. }), None) => {\n+                }), []) => bug!(\"promoteds don't exist yet during promotion\"),\n+                (&PlaceBase::Static(box Static{ kind: _, .. }), []) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n                     let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n@@ -986,7 +988,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     if let StatementKind::Assign(_, box Rvalue::Repeat(\n                         Operand::Move(Place {\n                             base: PlaceBase::Local(index),\n-                            projection: None,\n+                            projection: box [],\n                         }),\n                         _\n                     )) = self.body[bb].statements[stmt_idx].kind {\n@@ -998,7 +1000,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                         _,\n                         box Rvalue::Ref(_, _, Place {\n                             base: PlaceBase::Local(index),\n-                            projection: None,\n+                            projection: box [],\n                         })\n                     ) = self.body[bb].statements[stmt_idx].kind {\n                         promoted_temps.insert(index);\n@@ -1084,7 +1086,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     fn visit_projection(\n         &mut self,\n         place_base: &PlaceBase<'tcx>,\n-        proj: &Projection<'tcx>,\n+        proj: &[PlaceElem<'tcx>],\n         context: PlaceContext,\n         location: Location,\n     ) {\n@@ -1093,62 +1095,68 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             proj, context, location,\n         );\n         self.super_projection(place_base, proj, context, location);\n-        match proj.elem {\n-            ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    // `not_const` errors out in const contexts\n-                    self.not_const()\n-                }\n-                let base_ty = Place::ty_from(place_base, &proj.base, self.body, self.tcx).ty;\n-                match self.mode {\n-                    Mode::NonConstFn => {},\n-                    _ => {\n-                        if let ty::RawPtr(_) = base_ty.sty {\n-                            if !self.tcx.features().const_raw_ptr_deref {\n-                                emit_feature_err(\n-                                    &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n-                                    self.span, GateIssue::Language,\n-                                    &format!(\n-                                        \"dereferencing raw pointers in {}s is unstable\",\n-                                        self.mode,\n-                                    ),\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n \n-            ProjectionElem::ConstantIndex {..} |\n-            ProjectionElem::Subslice {..} |\n-            ProjectionElem::Field(..) |\n-            ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, &proj.base, self.body, self.tcx).ty;\n-                if let Some(def) = base_ty.ty_adt_def() {\n-                    if def.is_union() {\n-                        match self.mode {\n-                            Mode::ConstFn => {\n-                                if !self.tcx.features().const_fn_union {\n+        if !proj.is_empty() {\n+            let elem = &proj[proj.len() - 1];\n+            let proj_base = &proj[..proj.len() - 1];\n+\n+            match elem {\n+                ProjectionElem::Deref => {\n+                    if context.is_mutating_use() {\n+                        // `not_const` errors out in const contexts\n+                        self.not_const()\n+                    }\n+                    let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                    match self.mode {\n+                        Mode::NonConstFn => {},\n+                        _ => {\n+                            if let ty::RawPtr(_) = base_ty.sty {\n+                                if !self.tcx.features().const_raw_ptr_deref {\n                                     emit_feature_err(\n-                                        &self.tcx.sess.parse_sess, sym::const_fn_union,\n+                                        &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                         self.span, GateIssue::Language,\n-                                        \"unions in const fn are unstable\",\n+                                        &format!(\n+                                            \"dereferencing raw pointers in {}s is unstable\",\n+                                            self.mode,\n+                                        ),\n                                     );\n                                 }\n-                            },\n+                            }\n+                        }\n+                    }\n+                }\n \n-                            | Mode::NonConstFn\n-                            | Mode::Static\n-                            | Mode::StaticMut\n-                            | Mode::Const\n-                            => {},\n+                ProjectionElem::ConstantIndex {..} |\n+                ProjectionElem::Subslice {..} |\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::Index(_) => {\n+                    let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                    if let Some(def) = base_ty.ty_adt_def() {\n+                        if def.is_union() {\n+                            match self.mode {\n+                                Mode::ConstFn => {\n+                                    if !self.tcx.features().const_fn_union {\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess, sym::const_fn_union,\n+                                            self.span, GateIssue::Language,\n+                                            \"unions in const fn are unstable\",\n+                                        );\n+                                    }\n+                                },\n+\n+                                | Mode::NonConstFn\n+                                | Mode::Static\n+                                | Mode::StaticMut\n+                                | Mode::Const\n+                                => {},\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            ProjectionElem::Downcast(..) => {\n-                self.not_const()\n+                ProjectionElem::Downcast(..) => {\n+                    self.not_const()\n+                }\n             }\n         }\n     }\n@@ -1162,7 +1170,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // Mark the consumed locals to indicate later drops are noops.\n                 if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = *place {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n@@ -1179,11 +1187,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n             let mut reborrow_place = None;\n-            if let Some(ref proj) = place.projection {\n-                if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = Place::ty_from(&place.base, &proj.base, self.body, self.tcx).ty;\n+            if let box [.., elem] = &place.projection {\n+                if *elem == ProjectionElem::Deref {\n+                    let proj_base = &place.projection[..place.projection.len() - 1];\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n-                        reborrow_place = Some(&proj.base);\n+                        reborrow_place = Some(proj_base);\n                     }\n                 }\n             }\n@@ -1204,9 +1213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     ),\n                 };\n                 self.visit_place_base(&place.base, ctx, location);\n-                if let Some(proj) = proj {\n-                    self.visit_projection(&place.base, proj, ctx, location);\n-                }\n+                self.visit_projection(&place.base, proj, ctx, location);\n             } else {\n                 self.super_rvalue(rvalue, location);\n             }\n@@ -1477,7 +1484,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = *place {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.body.local_decls[local].source_info.span)\n@@ -1727,7 +1734,7 @@ fn remove_drop_and_storage_dead_on_promoted_locals(\n             TerminatorKind::Drop {\n                 location: Place {\n                     base: PlaceBase::Local(index),\n-                    projection: None,\n+                    projection: box [],\n                 },\n                 target,\n                 .."}, {"sha": "cb2da1d5ff916009b30172bfaa390fcd10845d00", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -249,28 +249,26 @@ fn check_place(\n     place: &Place<'tcx>,\n     span: Span,\n ) -> McfResult {\n-    place.iterate(|place_base, place_projection| {\n-        for proj in place_projection {\n-            match proj.elem {\n-                ProjectionElem::Downcast(..) => {\n-                    return Err((span, \"`match` or `if let` in `const fn` is unstable\".into()));\n-                }\n-                ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Deref\n-                | ProjectionElem::Field(..)\n-                | ProjectionElem::Index(_) => {}\n+    for elem in place.projection.iter() {\n+        match elem {\n+            ProjectionElem::Downcast(..) => {\n+                return Err((span, \"`match` or `if let` in `const fn` is unstable\".into()));\n             }\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Deref\n+            | ProjectionElem::Field(..)\n+            | ProjectionElem::Index(_) => {}\n         }\n+    }\n \n-        match place_base {\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n-                Err((span, \"cannot access `static` items in const fn\".into()))\n-            }\n-            PlaceBase::Local(_)\n-            | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n+    match place.base {\n+        PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n+            Err((span, \"cannot access `static` items in const fn\".into()))\n         }\n-    })\n+        PlaceBase::Local(_)\n+        | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n+    }\n }\n \n fn check_terminator("}, {"sha": "07669e2c0c986c606ca678c581134cc4f36d9ed9", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -43,7 +43,7 @@ impl RemoveNoopLandingPads {\n \n                 StatementKind::Assign(Place {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: box [],\n                 }, box Rvalue::Use(_)) => {\n                     // Writing to a local (e.g., a drop flag) does not\n                     // turn a landing pad to a non-nop"}, {"sha": "208407bb9a5e088b84348b60f9769d57a921d79f", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -120,11 +120,11 @@ fn each_block<'tcx, O>(\n     let peek_arg_place = match args[0] {\n         mir::Operand::Copy(ref place @ mir::Place {\n             base: mir::PlaceBase::Local(_),\n-            projection: None,\n+            projection: box [],\n         }) |\n         mir::Operand::Move(ref place @ mir::Place {\n             base: mir::PlaceBase::Local(_),\n-            projection: None,\n+            projection: box [],\n         }) => Some(place),\n         _ => None,\n     };"}, {"sha": "318049a1ce0fe491d853c34e8d6efdcf439049fc", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 99, "deletions": 81, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -61,14 +61,16 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let Some(ref proj) = src_place.projection {\n+            if let box [.., elem] = &src_place.projection {\n+                let proj_base = &src_place.projection[..src_place.projection.len() - 1];\n+\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n-                                                     from_end: false} = proj.elem {\n+                                                     from_end: false} = elem {\n                     // no need to transformation\n                 } else {\n                     let place_ty =\n-                        Place::ty_from(&src_place.base, &proj.base, self.body, self.tcx).ty;\n+                        Place::ty_from(&src_place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.try_eval_usize(self.tcx, self.param_env) {\n                             assert!(size <= u32::max_value() as u64,\n@@ -78,7 +80,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                 location,\n                                 dst_place,\n                                 &src_place.base,\n-                                proj,\n+                                &src_place.projection,\n                                 item_ty,\n                                 size as u32,\n                             );\n@@ -97,73 +99,79 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                location: Location,\n                dst_place: &Place<'tcx>,\n                base: &PlaceBase<'tcx>,\n-               proj: &Projection<'tcx>,\n+               proj: &[PlaceElem<'tcx>],\n                item_ty: &'tcx ty::TyS<'tcx>,\n                size: u32) {\n-        match proj.elem {\n-            // uniforms statements like_10 = move _2[:-1];\n-            ProjectionElem::Subslice{from, to} => {\n-                self.patch.make_nop(location);\n-                let temps : Vec<_> = (from..(size-to)).map(|i| {\n-                    let temp = self.patch.new_temp(item_ty, self.body.source_info(location).span);\n-                    self.patch.add_statement(location, StatementKind::StorageLive(temp));\n+        if !proj.is_empty() {\n+            let elem = &proj[proj.len() - 1];\n+            let proj_base = &proj[..proj.len() - 1];\n+\n+            match elem {\n+                // uniforms statements like_10 = move _2[:-1];\n+                ProjectionElem::Subslice{from, to} => {\n+                    self.patch.make_nop(location);\n+                    let temps : Vec<_> = (*from..(size-*to)).map(|i| {\n+                        let temp =\n+                            self.patch.new_temp(item_ty, self.body.source_info(location).span);\n+                        self.patch.add_statement(location, StatementKind::StorageLive(temp));\n+\n+                        let mut projection = proj_base.to_vec();\n+                        projection.push(ProjectionElem::ConstantIndex {\n+                            offset: i,\n+                            min_length: size,\n+                            from_end: false,\n+                        });\n+                        self.patch.add_assign(location,\n+                                              Place::from(temp),\n+                                              Rvalue::Use(\n+                                                  Operand::Move(\n+                                                      Place {\n+                                                          base: base.clone(),\n+                                                          projection: projection.into_boxed_slice(),\n+                                                      }\n+                                                  )\n+                                              )\n+                        );\n+                        temp\n+                    }).collect();\n+                    self.patch.add_assign(\n+                        location,\n+                        dst_place.clone(),\n+                        Rvalue::Aggregate(\n+                            box AggregateKind::Array(item_ty),\n+                            temps.iter().map(\n+                                |x| Operand::Move(Place::from(*x))\n+                            ).collect()\n+                        )\n+                    );\n+                    for temp in temps {\n+                        self.patch.add_statement(location, StatementKind::StorageDead(temp));\n+                    }\n+                }\n+                // uniforms statements like _11 = move _2[-1 of 1];\n+                ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n+                    self.patch.make_nop(location);\n+\n+                    let mut projection = proj_base.to_vec();\n+                    projection.push(ProjectionElem::ConstantIndex {\n+                        offset: size - offset,\n+                        min_length: size,\n+                        from_end: false,\n+                    });\n                     self.patch.add_assign(location,\n-                                          Place::from(temp),\n+                                          dst_place.clone(),\n                                           Rvalue::Use(\n                                               Operand::Move(\n                                                   Place {\n                                                       base: base.clone(),\n-                                                      projection: Some(box Projection {\n-                                                          base: proj.base.clone(),\n-                                                          elem: ProjectionElem::ConstantIndex {\n-                                                              offset: i,\n-                                                              min_length: size,\n-                                                              from_end: false,\n-                                                          }\n-                                                      }),\n+                                                      projection: projection.into_boxed_slice(),\n                                                   }\n                                               )\n                                           )\n                     );\n-                    temp\n-                }).collect();\n-                self.patch.add_assign(\n-                    location,\n-                    dst_place.clone(),\n-                    Rvalue::Aggregate(\n-                        box AggregateKind::Array(item_ty),\n-                        temps.iter().map(\n-                            |x| Operand::Move(Place::from(*x))\n-                        ).collect()\n-                    )\n-                );\n-                for temp in temps {\n-                    self.patch.add_statement(location, StatementKind::StorageDead(temp));\n                 }\n+                _ => {}\n             }\n-            // uniforms statements like _11 = move _2[-1 of 1];\n-            ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n-                self.patch.make_nop(location);\n-                self.patch.add_assign(location,\n-                                      dst_place.clone(),\n-                                      Rvalue::Use(\n-                                          Operand::Move(\n-                                              Place {\n-                                                  base: base.clone(),\n-                                                  projection: Some(box Projection {\n-                                                      base: proj.base.clone(),\n-                                                      elem: ProjectionElem::ConstantIndex {\n-                                                          offset: size - offset,\n-                                                          min_length: size,\n-                                                          from_end: false,\n-                                                      },\n-                                                  }),\n-                                              }\n-                                          )\n-                                      )\n-                );\n-            }\n-            _ => {}\n         }\n     }\n }\n@@ -202,7 +210,7 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                         let items : Vec<_> = items.iter().map(|item| {\n                             if let Operand::Move(Place {\n                                 base: PlaceBase::Local(local),\n-                                projection: None,\n+                                projection: box [],\n                             }) = item {\n                                 let local_use = &visitor.locals_use[*local];\n                                 let opt_index_and_place =\n@@ -269,16 +277,17 @@ impl RestoreSubsliceArrayMoveOut {\n             }\n             patch.make_nop(candidate);\n             let size = opt_size.unwrap() as u32;\n-            patch.add_assign(candidate,\n-                             dst_place.clone(),\n-                             Rvalue::Use(\n-                                 Operand::Move(\n-                                     Place {\n-                                         base: src_place.base.clone(),\n-                                         projection: Some(box Projection {\n-                                             base: src_place.projection.clone(),\n-                                             elem: ProjectionElem::Subslice{\n-                                                 from: min, to: size - max - 1}})})));\n+\n+            let mut projection = src_place.projection.to_vec();\n+            projection.push(ProjectionElem::Subslice { from: min, to: size - max - 1 });\n+            patch.add_assign(\n+                candidate,\n+                dst_place.clone(),\n+                Rvalue::Use(Operand::Move(Place {\n+                    base: src_place.base.clone(),\n+                    projection: projection.into_boxed_slice(),\n+                })),\n+            );\n         }\n     }\n \n@@ -291,21 +300,30 @@ impl RestoreSubsliceArrayMoveOut {\n                 if let StatementKind::Assign(\n                     Place {\n                         base: PlaceBase::Local(_),\n-                        projection: None,\n+                        projection: box [],\n                     },\n                     box Rvalue::Use(Operand::Move(Place {\n-                        base,\n-                        projection: Some(box Projection {\n-                            base: proj_base,\n-                            elem: ProjectionElem::ConstantIndex {\n+                        base: _,\n+                        projection: box [.., ProjectionElem::ConstantIndex {\n                                 offset, min_length: _, from_end: false\n-                            }\n-                        }),\n-                    }))) = &statement.kind {\n-                    return Some((*offset, PlaceRef {\n-                        base,\n-                        projection: proj_base,\n-                    }))\n+                        }],\n+                    })),\n+                ) = &statement.kind {\n+                    // FIXME remove once we can use slices patterns\n+                    if let StatementKind::Assign(\n+                        _,\n+                        box Rvalue::Use(Operand::Move(Place {\n+                            base,\n+                            projection,\n+                        })),\n+                        ) = &statement.kind {\n+                        let proj_base = &projection[..projection.len() - 1];\n+\n+                        return Some((*offset, PlaceRef {\n+                            base,\n+                            projection: proj_base,\n+                        }))\n+                    }\n                 }\n             }\n         }"}, {"sha": "b4c97f91917324e1fdcb9e60587f497e54b595d4", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -38,14 +38,14 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut place_projection = &place.projection;\n+    for (i, elem) in place.projection.iter().enumerate().rev() {\n+        let proj_base = &place.projection[..i];\n \n-    while let Some(proj) = place_projection {\n-        match proj.elem {\n+        match elem {\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = Place::ty_from(&place.base, &proj.base, local_decls, tcx).ty;\n+                let ty = Place::ty_from(&place.base, proj_base, local_decls, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true\n@@ -55,7 +55,6 @@ where\n             }\n             _ => {}\n         }\n-        place_projection = &proj.base;\n     }\n \n     false"}, {"sha": "c60af70712d1b60c2bdb1b835295b08d667f8f30", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c41148c0c834d13d6f45bfd99c8f23781c5d31/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=e9c41148c0c834d13d6f45bfd99c8f23781c5d31", "patch": "@@ -586,10 +586,7 @@ where\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                 Place {\n                     base: PlaceBase::Local(cur),\n-                    projection: Some(Box::new(Projection {\n-                        base: None,\n-                        elem: ProjectionElem::Deref,\n-                    })),\n+                    projection: Box::new([ProjectionElem::Deref]),\n                 }\n              ),\n              Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))"}]}