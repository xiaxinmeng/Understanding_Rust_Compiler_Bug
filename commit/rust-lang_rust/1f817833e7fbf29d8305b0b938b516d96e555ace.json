{"sha": "1f817833e7fbf29d8305b0b938b516d96e555ace", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODE3ODMzZTdmYmYyOWQ4MzA1YjBiOTM4YjUxNmQ5NmU1NTVhY2U=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-30T14:56:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-30T14:56:50Z"}, "message": "Merge #9727\n\n9727: internal: Simplify extract_function assist r=Veykril a=Veykril\n\nalso fixes #7839(blocked on #9728)\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "5ae3385ba523036656fd0df3b157c38b178634f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ae3385ba523036656fd0df3b157c38b178634f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f817833e7fbf29d8305b0b938b516d96e555ace", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhBBMyCRBK7hj4Ov3rIwAAUmwIADW/hCSdp2E3401LQq3OX1R+\nzIpLXbgV+4HAVU0WdrhS7mUbvVpiwjlWGcUFw+mhi349UTs80KF6UbB8+/z6hpnm\npWJBUESWdkW4gfHJqEAVSFC6+O/6RLeTHDcMXfmCiXaJ3Wo6FwlijfXHF/b6tqKN\n5R6B+CmI4tDY0kzDe5e5na+FQ8FpmJ+CNavY0o9UysDafJ2mIw7igIIn/5FeA1ho\np7qvgxt8S+LLIjD8u7/KfOkMa765Na0OSvOO/KCu5bM+OyAEWQXoP8CKiE8Jkxdq\ndn7QZcdDEl9Nkt7PRxUat7AIer9uVTqe+Zv9W6cPBuyydIVXWv2t8Sy5G2BdH7M=\n=a7Ez\n-----END PGP SIGNATURE-----\n", "payload": "tree 5ae3385ba523036656fd0df3b157c38b178634f3\nparent 4cc961007f97705f85fc22580247b236d14cf37a\nparent 3e351cc0ba7b182a71e7955ca7231349b8396f9d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627657010 +0000\ncommitter GitHub <noreply@github.com> 1627657010 +0000\n\nMerge #9727\n\n9727: internal: Simplify extract_function assist r=Veykril a=Veykril\n\nalso fixes #7839(blocked on #9728)\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f817833e7fbf29d8305b0b938b516d96e555ace", "html_url": "https://github.com/rust-lang/rust/commit/1f817833e7fbf29d8305b0b938b516d96e555ace", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f817833e7fbf29d8305b0b938b516d96e555ace/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cc961007f97705f85fc22580247b236d14cf37a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc961007f97705f85fc22580247b236d14cf37a", "html_url": "https://github.com/rust-lang/rust/commit/4cc961007f97705f85fc22580247b236d14cf37a"}, {"sha": "3e351cc0ba7b182a71e7955ca7231349b8396f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e351cc0ba7b182a71e7955ca7231349b8396f9d", "html_url": "https://github.com/rust-lang/rust/commit/3e351cc0ba7b182a71e7955ca7231349b8396f9d"}], "stats": {"total": 945, "additions": 508, "deletions": 437}, "files": [{"sha": "33c439a85011857684f7a169b832e92826461952", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 390, "deletions": 336, "changes": 726, "blob_url": "https://github.com/rust-lang/rust/blob/1f817833e7fbf29d8305b0b938b516d96e555ace/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f817833e7fbf29d8305b0b938b516d96e555ace/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=1f817833e7fbf29d8305b0b938b516d96e555ace", "patch": "@@ -74,20 +74,12 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let (locals_used, has_await, self_param) = analyze_body(&ctx.sema, &body);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n-    let insert_after = scope_for_fn_insertion(&body, anchor)?;\n+    let insert_after = node_to_insert_after(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let vars_defined_in_body_and_outlive =\n-        vars_defined_in_body_and_outlive(ctx, &body, node.parent().as_ref().unwrap_or(&node));\n     let ret_ty = body_return_ty(ctx, &body)?;\n+    let ret_values = ret_values(ctx, &body, node.parent().as_ref().unwrap_or(&node));\n \n-    // FIXME: we compute variables that outlive here just to check `never!` condition\n-    //        this requires traversing whole `body` (cheap) and finding all references (expensive)\n-    //        maybe we can move this check to `edit` closure somehow?\n-    if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !ret_ty.is_unit()) {\n-        // We should not have variables that outlive body if we have expression block\n-        return None;\n-    }\n     let control_flow = external_control_flow(ctx, &body)?;\n \n     let target_range = body.text_range();\n@@ -97,22 +89,35 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n+            let ret_values: Vec<_> = ret_values.collect();\n+            if stdx::never!(!ret_values.is_empty() && !ret_ty.is_unit()) {\n+                // We should not have variables that outlive body if we have expression block\n+                return;\n+            }\n+\n             let params = extracted_function_params(ctx, &body, locals_used.iter().copied());\n \n+            let insert_comma = body\n+                .parent()\n+                .and_then(ast::MatchArm::cast)\n+                .map_or(false, |it| it.comma_token().is_none());\n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n-                self_param: self_param.map(|(_, pat)| pat),\n+                self_param,\n                 params,\n                 control_flow,\n                 ret_ty,\n                 body,\n-                vars_defined_in_body_and_outlive,\n+                vars_defined_in_body_and_outlive: ret_values,\n             };\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n             let old_indent = fun.body.indent_level();\n \n-            builder.replace(target_range, format_replacement(ctx, &fun, old_indent, has_await));\n+            builder.replace(target_range, make_call(ctx, &fun, old_indent, has_await));\n+            if insert_comma {\n+                builder.insert(target_range.end(), \",\");\n+            }\n \n             let fn_def = format_function(ctx, module, &fun, old_indent, new_indent, has_await);\n             let insert_offset = insert_after.text_range().end();\n@@ -123,135 +128,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         },\n     )\n }\n-\n-fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n-    let mut ret_expr = None;\n-    let mut try_expr = None;\n-    let mut break_expr = None;\n-    let mut continue_expr = None;\n-    let (syntax, text_range) = match body {\n-        FunctionBody::Expr(expr) => (expr.syntax(), expr.syntax().text_range()),\n-        FunctionBody::Span { parent, text_range } => (parent.syntax(), *text_range),\n-    };\n-\n-    let mut nested_loop = None;\n-    let mut nested_scope = None;\n-\n-    for e in syntax.preorder() {\n-        let e = match e {\n-            WalkEvent::Enter(e) => e,\n-            WalkEvent::Leave(e) => {\n-                if nested_loop.as_ref() == Some(&e) {\n-                    nested_loop = None;\n-                }\n-                if nested_scope.as_ref() == Some(&e) {\n-                    nested_scope = None;\n-                }\n-                continue;\n-            }\n-        };\n-        if nested_scope.is_some() {\n-            continue;\n-        }\n-        if !text_range.contains_range(e.text_range()) {\n-            continue;\n-        }\n-        match e.kind() {\n-            SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n-                if nested_loop.is_none() {\n-                    nested_loop = Some(e);\n-                }\n-            }\n-            SyntaxKind::FN\n-            | SyntaxKind::CONST\n-            | SyntaxKind::STATIC\n-            | SyntaxKind::IMPL\n-            | SyntaxKind::MODULE => {\n-                if nested_scope.is_none() {\n-                    nested_scope = Some(e);\n-                }\n-            }\n-            SyntaxKind::RETURN_EXPR => {\n-                ret_expr = Some(ast::ReturnExpr::cast(e).unwrap());\n-            }\n-            SyntaxKind::TRY_EXPR => {\n-                try_expr = Some(ast::TryExpr::cast(e).unwrap());\n-            }\n-            SyntaxKind::BREAK_EXPR if nested_loop.is_none() => {\n-                break_expr = Some(ast::BreakExpr::cast(e).unwrap());\n-            }\n-            SyntaxKind::CONTINUE_EXPR if nested_loop.is_none() => {\n-                continue_expr = Some(ast::ContinueExpr::cast(e).unwrap());\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n-        (Some(e), None, None, None) => {\n-            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n-            let def = ctx.sema.to_def(&func)?;\n-            let ret_ty = def.ret_type(ctx.db());\n-            let kind = try_kind_of_ty(ret_ty, ctx)?;\n-\n-            Some(FlowKind::Try { kind })\n-        }\n-        (Some(_), Some(r), None, None) => match r.expr() {\n-            Some(expr) => {\n-                if let Some(kind) = expr_err_kind(&expr, ctx) {\n-                    Some(FlowKind::TryReturn { expr, kind })\n-                } else {\n-                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n-                    return None;\n-                }\n-            }\n-            None => return None,\n-        },\n-        (Some(_), _, _, _) => {\n-            cov_mark::hit!(external_control_flow_try_and_bc);\n-            return None;\n-        }\n-        (None, Some(r), None, None) => match r.expr() {\n-            Some(expr) => Some(FlowKind::ReturnValue(expr)),\n-            None => Some(FlowKind::Return),\n-        },\n-        (None, Some(_), _, _) => {\n-            cov_mark::hit!(external_control_flow_return_and_bc);\n-            return None;\n-        }\n-        (None, None, Some(_), Some(_)) => {\n-            cov_mark::hit!(external_control_flow_break_and_continue);\n-            return None;\n-        }\n-        (None, None, Some(b), None) => match b.expr() {\n-            Some(expr) => Some(FlowKind::BreakValue(expr)),\n-            None => Some(FlowKind::Break),\n-        },\n-        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n-        (None, None, None, None) => None,\n-    };\n-\n-    Some(ControlFlow { kind })\n-}\n-\n-/// Checks is expr is `Err(_)` or `None`\n-fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n-    let func_name = match expr {\n-        ast::Expr::CallExpr(call_expr) => call_expr.expr()?,\n-        ast::Expr::PathExpr(_) => expr.clone(),\n-        _ => return None,\n-    };\n-    let text = func_name.syntax().text();\n-\n-    if text == \"Err\" {\n-        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n-    } else if text == \"None\" {\n-        Some(TryKind::Option)\n-    } else {\n-        None\n-    }\n-}\n-\n #[derive(Debug)]\n struct Function {\n     name: String,\n@@ -272,11 +148,6 @@ struct Param {\n     is_copy: bool,\n }\n \n-#[derive(Debug)]\n-struct ControlFlow {\n-    kind: Option<FlowKind>,\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ParamKind {\n     Value,\n@@ -292,6 +163,104 @@ enum FunType {\n     Tuple(Vec<hir::Type>),\n }\n \n+/// Where to put extracted function definition\n+#[derive(Debug)]\n+enum Anchor {\n+    /// Extract free function and put right after current top-level function\n+    Freestanding,\n+    /// Extract method and put right after current function in the impl-block\n+    Method,\n+}\n+\n+#[derive(Debug)]\n+struct ControlFlow {\n+    kind: Option<FlowKind>,\n+}\n+\n+/// Control flow that is exported from extracted function\n+///\n+/// E.g.:\n+/// ```rust,no_run\n+/// loop {\n+///     $0\n+///     if 42 == 42 {\n+///         break;\n+///     }\n+///     $0\n+/// }\n+/// ```\n+#[derive(Debug, Clone)]\n+enum FlowKind {\n+    /// Return with value (`return $expr;`)\n+    Return(Option<ast::Expr>),\n+    Try {\n+        kind: TryKind,\n+    },\n+    TryReturn {\n+        expr: ast::Expr,\n+        kind: TryKind,\n+    },\n+    /// Break with value (`break $expr;`)\n+    Break(Option<ast::Expr>),\n+    /// Continue\n+    Continue,\n+}\n+\n+#[derive(Debug, Clone)]\n+enum TryKind {\n+    Option,\n+    Result { ty: hir::Type },\n+}\n+\n+#[derive(Debug)]\n+enum RetType {\n+    Expr(hir::Type),\n+    Stmt,\n+}\n+\n+impl RetType {\n+    fn is_unit(&self) -> bool {\n+        match self {\n+            RetType::Expr(ty) => ty.is_unit(),\n+            RetType::Stmt => true,\n+        }\n+    }\n+}\n+\n+/// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n+/// This is the future function body, the part that is being extracted.\n+#[derive(Debug)]\n+enum FunctionBody {\n+    Expr(ast::Expr),\n+    Span { parent: ast::BlockExpr, text_range: TextRange },\n+}\n+\n+#[derive(Debug)]\n+struct OutlivedLocal {\n+    local: Local,\n+    mut_usage_outside_body: bool,\n+}\n+\n+/// Container of local variable usages\n+///\n+/// Semanticall same as `UsageSearchResult`, but provides more convenient interface\n+struct LocalUsages(ide_db::search::UsageSearchResult);\n+\n+impl LocalUsages {\n+    fn find(ctx: &AssistContext, var: Local) -> Self {\n+        Self(\n+            Definition::Local(var)\n+                .usages(&ctx.sema)\n+                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+                .all(),\n+        )\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n+        self.0.iter().flat_map(|(_, rs)| rs)\n+    }\n+}\n+\n impl Function {\n     fn return_type(&self, ctx: &AssistContext) -> FunType {\n         match &self.ret_ty {\n@@ -355,50 +324,11 @@ impl Param {\n     }\n }\n \n-/// Control flow that is exported from extracted function\n-///\n-/// E.g.:\n-/// ```rust,no_run\n-/// loop {\n-///     $0\n-///     if 42 == 42 {\n-///         break;\n-///     }\n-///     $0\n-/// }\n-/// ```\n-#[derive(Debug, Clone)]\n-enum FlowKind {\n-    /// Return without value (`return;`)\n-    Return,\n-    /// Return with value (`return $expr;`)\n-    ReturnValue(ast::Expr),\n-    Try {\n-        kind: TryKind,\n-    },\n-    TryReturn {\n-        expr: ast::Expr,\n-        kind: TryKind,\n-    },\n-    /// Break without value (`return;`)\n-    Break,\n-    /// Break with value (`break $expr;`)\n-    BreakValue(ast::Expr),\n-    /// Continue\n-    Continue,\n-}\n-\n-#[derive(Debug, Clone)]\n-enum TryKind {\n-    Option,\n-    Result { ty: hir::Type },\n-}\n-\n impl FlowKind {\n     fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n         match self {\n-            FlowKind::Return | FlowKind::ReturnValue(_) => make::expr_return(expr),\n-            FlowKind::Break | FlowKind::BreakValue(_) => make::expr_break(expr),\n+            FlowKind::Return(_) => make::expr_return(expr),\n+            FlowKind::Break(_) => make::expr_break(expr),\n             FlowKind::Try { .. } | FlowKind::TryReturn { .. } => {\n                 stdx::never!(\"cannot have result handler with try\");\n                 expr.unwrap_or_else(|| make::expr_return(None))\n@@ -412,14 +342,14 @@ impl FlowKind {\n \n     fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n         match self {\n-            FlowKind::ReturnValue(expr)\n-            | FlowKind::BreakValue(expr)\n+            FlowKind::Return(Some(expr))\n+            | FlowKind::Break(Some(expr))\n             | FlowKind::TryReturn { expr, .. } => ctx.sema.type_of_expr(expr),\n             FlowKind::Try { .. } => {\n                 stdx::never!(\"try does not have defined expr_ty\");\n                 None\n             }\n-            FlowKind::Return | FlowKind::Break | FlowKind::Continue => None,\n+            _ => None,\n         }\n     }\n }\n@@ -440,29 +370,14 @@ fn try_kind_of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n     }\n }\n \n-#[derive(Debug)]\n-enum RetType {\n-    Expr(hir::Type),\n-    Stmt,\n-}\n-\n-impl RetType {\n-    fn is_unit(&self) -> bool {\n+impl FunctionBody {\n+    fn parent(&self) -> Option<SyntaxNode> {\n         match self {\n-            RetType::Expr(ty) => ty.is_unit(),\n-            RetType::Stmt => true,\n+            FunctionBody::Expr(expr) => expr.syntax().parent(),\n+            FunctionBody::Span { parent, .. } => Some(parent.syntax().clone()),\n         }\n     }\n-}\n \n-/// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n-#[derive(Debug)]\n-enum FunctionBody {\n-    Expr(ast::Expr),\n-    Span { parent: ast::BlockExpr, text_range: TextRange },\n-}\n-\n-impl FunctionBody {\n     fn from_expr(expr: ast::Expr) -> Option<Self> {\n         match expr {\n             ast::Expr::BreakExpr(it) => it.expr().map(Self::Expr),\n@@ -488,18 +403,37 @@ impl FunctionBody {\n             FunctionBody::Expr(expr) => Some(expr.clone()),\n             FunctionBody::Span { parent, text_range } => {\n                 let tail_expr = parent.tail_expr()?;\n-                if text_range.contains_range(tail_expr.syntax().text_range()) {\n-                    Some(tail_expr)\n-                } else {\n-                    None\n+                text_range.contains_range(tail_expr.syntax().text_range()).then(|| tail_expr)\n+            }\n+        }\n+    }\n+\n+    fn walk_expr(&self, cb: &mut dyn FnMut(ast::Expr)) {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.walk(cb),\n+            FunctionBody::Span { parent, text_range } => {\n+                parent\n+                    .statements()\n+                    .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))\n+                    .filter_map(|stmt| match stmt {\n+                        ast::Stmt::ExprStmt(expr_stmt) => expr_stmt.expr(),\n+                        ast::Stmt::Item(_) => None,\n+                        ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                    })\n+                    .for_each(|expr| expr.walk(cb));\n+                if let Some(expr) = parent\n+                    .tail_expr()\n+                    .filter(|it| text_range.contains_range(it.syntax().text_range()))\n+                {\n+                    expr.walk(cb);\n                 }\n             }\n         }\n     }\n \n-    fn walk_expr(&self, cb: &mut dyn FnMut(ast::Expr)) {\n+    fn preorder_expr(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n         match self {\n-            FunctionBody::Expr(expr) => expr.walk(cb),\n+            FunctionBody::Expr(expr) => expr.preorder(cb),\n             FunctionBody::Span { parent, text_range } => {\n                 parent\n                     .statements()\n@@ -509,12 +443,12 @@ impl FunctionBody {\n                         ast::Stmt::Item(_) => None,\n                         ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n                     })\n-                    .for_each(|expr| expr.walk(cb));\n+                    .for_each(|expr| expr.preorder(cb));\n                 if let Some(expr) = parent\n                     .tail_expr()\n                     .filter(|it| text_range.contains_range(it.syntax().text_range()))\n                 {\n-                    expr.walk(cb);\n+                    expr.preorder(cb);\n                 }\n             }\n         }\n@@ -556,15 +490,15 @@ impl FunctionBody {\n     fn text_range(&self) -> TextRange {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-            FunctionBody::Span { parent: _, text_range } => *text_range,\n+            &FunctionBody::Span { text_range, .. } => text_range,\n         }\n     }\n \n     fn contains_range(&self, range: TextRange) -> bool {\n         self.text_range().contains_range(range)\n     }\n \n-    fn preceedes_range(&self, range: TextRange) -> bool {\n+    fn precedes_range(&self, range: TextRange) -> bool {\n         self.text_range().end() <= range.start()\n     }\n \n@@ -573,43 +507,6 @@ impl FunctionBody {\n     }\n }\n \n-impl HasTokenAtOffset for FunctionBody {\n-    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n-        match self {\n-            FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n-            FunctionBody::Span { parent, text_range } => {\n-                match parent.syntax().token_at_offset(offset) {\n-                    TokenAtOffset::None => TokenAtOffset::None,\n-                    TokenAtOffset::Single(t) => {\n-                        if text_range.contains_range(t.text_range()) {\n-                            TokenAtOffset::Single(t)\n-                        } else {\n-                            TokenAtOffset::None\n-                        }\n-                    }\n-                    TokenAtOffset::Between(a, b) => {\n-                        match (\n-                            text_range.contains_range(a.text_range()),\n-                            text_range.contains_range(b.text_range()),\n-                        ) {\n-                            (true, true) => TokenAtOffset::Between(a, b),\n-                            (true, false) => TokenAtOffset::Single(a),\n-                            (false, true) => TokenAtOffset::Single(b),\n-                            (false, false) => TokenAtOffset::None,\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct OutlivedLocal {\n-    local: Local,\n-    mut_usage_outside_body: bool,\n-}\n-\n /// Try to guess what user wants to extract\n ///\n /// We have basically have two cases:\n@@ -668,7 +565,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n fn analyze_body(\n     sema: &Semantics<RootDatabase>,\n     body: &FunctionBody,\n-) -> (FxIndexSet<Local>, bool, Option<(Local, ast::SelfParam)>) {\n+) -> (FxIndexSet<Local>, bool, Option<ast::SelfParam>) {\n     // FIXME: currently usages inside macros are not found\n     let mut has_await = false;\n     let mut self_param = None;\n@@ -692,7 +589,7 @@ fn analyze_body(\n                     match local_ref.source(sema.db).value {\n                         Either::Right(it) => {\n                             stdx::always!(\n-                                self_param.replace((local_ref, it)).is_none(),\n+                                self_param.replace(it).is_none(),\n                                 \"body references two different self params\"\n                             );\n                         }\n@@ -743,7 +640,7 @@ fn extracted_function_params(\n }\n \n fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n-    usages.iter().any(|reference| body.preceedes_range(reference.range))\n+    usages.iter().any(|reference| body.precedes_range(reference.range))\n }\n \n /// checks if relevant var is used with `&mut` access inside body\n@@ -812,26 +709,6 @@ fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Optio\n     Some(false)\n }\n \n-/// Container of local variable usages\n-///\n-/// Semanticall same as `UsageSearchResult`, but provides more convenient interface\n-struct LocalUsages(ide_db::search::UsageSearchResult);\n-\n-impl LocalUsages {\n-    fn find(ctx: &AssistContext, var: Local) -> Self {\n-        Self(\n-            Definition::Local(var)\n-                .usages(&ctx.sema)\n-                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-                .all(),\n-        )\n-    }\n-\n-    fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n-        self.0.iter().flat_map(|(_, rs)| rs.iter())\n-    }\n-}\n-\n trait HasTokenAtOffset {\n     fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken>;\n }\n@@ -842,6 +719,37 @@ impl HasTokenAtOffset for SyntaxNode {\n     }\n }\n \n+impl HasTokenAtOffset for FunctionBody {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n+            FunctionBody::Span { parent, text_range } => {\n+                match parent.syntax().token_at_offset(offset) {\n+                    TokenAtOffset::None => TokenAtOffset::None,\n+                    TokenAtOffset::Single(t) => {\n+                        if text_range.contains_range(t.text_range()) {\n+                            TokenAtOffset::Single(t)\n+                        } else {\n+                            TokenAtOffset::None\n+                        }\n+                    }\n+                    TokenAtOffset::Between(a, b) => {\n+                        match (\n+                            text_range.contains_range(a.text_range()),\n+                            text_range.contains_range(b.text_range()),\n+                        ) {\n+                            (true, true) => TokenAtOffset::Between(a, b),\n+                            (true, false) => TokenAtOffset::Single(a),\n+                            (false, true) => TokenAtOffset::Single(b),\n+                            (false, false) => TokenAtOffset::None,\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// find relevant `ast::Expr` for reference\n ///\n /// # Preconditions\n@@ -868,31 +776,59 @@ fn path_element_of_reference(\n }\n \n /// list local variables defined inside `body`\n-fn locals_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> FxIndexSet<Local> {\n+fn locals_defined_in_body(\n+    sema: &Semantics<RootDatabase>,\n+    body: &FunctionBody,\n+) -> FxIndexSet<Local> {\n     // FIXME: this doesn't work well with macros\n     //        see https://github.com/rust-analyzer/rust-analyzer/pull/7535#discussion_r570048550\n     let mut res = FxIndexSet::default();\n     body.walk_pat(&mut |pat| {\n         if let ast::Pat::IdentPat(pat) = pat {\n-            if let Some(local) = ctx.sema.to_def(&pat) {\n+            if let Some(local) = sema.to_def(&pat) {\n                 res.insert(local);\n             }\n         }\n     });\n     res\n }\n \n-/// list local variables defined inside `body` that should be returned from extracted function\n-fn vars_defined_in_body_and_outlive(\n-    ctx: &AssistContext,\n+/// Local variables defined inside `body` that are accessed outside of it\n+fn ret_values<'a>(\n+    ctx: &'a AssistContext,\n     body: &FunctionBody,\n     parent: &SyntaxNode,\n-) -> Vec<OutlivedLocal> {\n-    let vars_defined_in_body = locals_defined_in_body(body, ctx);\n-    vars_defined_in_body\n+) -> impl Iterator<Item = OutlivedLocal> + 'a {\n+    let parent = parent.clone();\n+    let range = body.text_range();\n+    locals_defined_in_body(&ctx.sema, body)\n         .into_iter()\n-        .filter_map(|var| var_outlives_body(ctx, body, var, parent))\n-        .collect()\n+        .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))\n+}\n+\n+/// Returns usage details if local variable is used after(outside of) body\n+fn local_outlives_body(\n+    ctx: &AssistContext,\n+    body_range: TextRange,\n+    local: Local,\n+    parent: &SyntaxNode,\n+) -> Option<OutlivedLocal> {\n+    let usages = LocalUsages::find(ctx, local);\n+    let mut has_mut_usages = false;\n+    let mut any_outlives = false;\n+    for usage in usages.iter() {\n+        if body_range.end() <= usage.range.start() {\n+            has_mut_usages |= reference_is_exclusive(usage, parent, ctx);\n+            any_outlives |= true;\n+            if has_mut_usages {\n+                break; // no need to check more elements we have all the info we wanted\n+            }\n+        }\n+    }\n+    if !any_outlives {\n+        return None;\n+    }\n+    Some(OutlivedLocal { local, mut_usage_outside_body: has_mut_usages })\n }\n \n /// checks if the relevant local was defined before(outside of) body\n@@ -912,25 +848,6 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-/// returns usage details if local variable is used after(outside of) body\n-fn var_outlives_body(\n-    ctx: &AssistContext,\n-    body: &FunctionBody,\n-    var: Local,\n-    parent: &SyntaxNode,\n-) -> Option<OutlivedLocal> {\n-    let usages = LocalUsages::find(ctx, var);\n-    let has_usages = usages.iter().any(|reference| body.preceedes_range(reference.range));\n-    if !has_usages {\n-        return None;\n-    }\n-    let has_mut_usages = usages\n-        .iter()\n-        .filter(|reference| body.preceedes_range(reference.range))\n-        .any(|reference| reference_is_exclusive(reference, parent, ctx));\n-    Some(OutlivedLocal { local: var, mut_usage_outside_body: has_mut_usages })\n-}\n-\n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n     match body.tail_expr() {\n         Some(expr) => {\n@@ -940,55 +857,142 @@ fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n         None => Some(RetType::Stmt),\n     }\n }\n-/// Where to put extracted function definition\n-#[derive(Debug)]\n-enum Anchor {\n-    /// Extract free function and put right after current top-level function\n-    Freestanding,\n-    /// Extract method and put right after current function in the impl-block\n-    Method,\n+\n+/// Analyses the function body for external control flow.\n+fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n+    let mut ret_expr = None;\n+    let mut try_expr = None;\n+    let mut break_expr = None;\n+    let mut continue_expr = None;\n+\n+    let mut loop_depth = 0;\n+\n+    body.preorder_expr(&mut |expr| {\n+        let expr = match expr {\n+            WalkEvent::Enter(e) => e,\n+            WalkEvent::Leave(\n+                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n+            ) => {\n+                loop_depth -= 1;\n+                return false;\n+            }\n+            WalkEvent::Leave(_) => return false,\n+        };\n+        match expr {\n+            ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n+                loop_depth += 1;\n+            }\n+            ast::Expr::ReturnExpr(it) => {\n+                ret_expr = Some(it);\n+            }\n+            ast::Expr::TryExpr(it) => {\n+                try_expr = Some(it);\n+            }\n+            ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n+                break_expr = Some(it);\n+            }\n+            ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n+                continue_expr = Some(it);\n+            }\n+            _ => {}\n+        }\n+        false\n+    });\n+\n+    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n+        (Some(e), None, None, None) => {\n+            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n+            let def = ctx.sema.to_def(&func)?;\n+            let ret_ty = def.ret_type(ctx.db());\n+            let kind = try_kind_of_ty(ret_ty, ctx)?;\n+\n+            Some(FlowKind::Try { kind })\n+        }\n+        (Some(_), Some(r), None, None) => match r.expr() {\n+            Some(expr) => {\n+                if let Some(kind) = expr_err_kind(&expr, ctx) {\n+                    Some(FlowKind::TryReturn { expr, kind })\n+                } else {\n+                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n+                    return None;\n+                }\n+            }\n+            None => return None,\n+        },\n+        (Some(_), _, _, _) => {\n+            cov_mark::hit!(external_control_flow_try_and_bc);\n+            return None;\n+        }\n+        (None, Some(r), None, None) => Some(FlowKind::Return(r.expr())),\n+        (None, Some(_), _, _) => {\n+            cov_mark::hit!(external_control_flow_return_and_bc);\n+            return None;\n+        }\n+        (None, None, Some(_), Some(_)) => {\n+            cov_mark::hit!(external_control_flow_break_and_continue);\n+            return None;\n+        }\n+        (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n+        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+        (None, None, None, None) => None,\n+    };\n+\n+    Some(ControlFlow { kind })\n }\n \n-/// find where to put extracted function definition\n-///\n-/// Function should be put right after returned node\n-fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n-    match body {\n-        FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n-        FunctionBody::Span { parent, .. } => scope_for_fn_insertion_node(parent.syntax(), anchor),\n+/// Checks is expr is `Err(_)` or `None`\n+fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n+    let func_name = match expr {\n+        ast::Expr::CallExpr(call_expr) => call_expr.expr()?,\n+        ast::Expr::PathExpr(_) => expr.clone(),\n+        _ => return None,\n+    };\n+    let text = func_name.syntax().text();\n+\n+    if text == \"Err\" {\n+        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n+    } else if text == \"None\" {\n+        Some(TryKind::Option)\n+    } else {\n+        None\n     }\n }\n \n-fn scope_for_fn_insertion_node(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNode> {\n+/// find where to put extracted function definition\n+///\n+/// Function should be put right after returned node\n+fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n+    let node = match body {\n+        FunctionBody::Expr(e) => e.syntax(),\n+        FunctionBody::Span { parent, .. } => parent.syntax(),\n+    };\n     let mut ancestors = node.ancestors().peekable();\n     let mut last_ancestor = None;\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::ITEM_LIST if !matches!(anchor, Anchor::Freestanding) => continue,\n             SyntaxKind::ITEM_LIST => {\n-                if !matches!(anchor, Anchor::Freestanding) {\n-                    continue;\n-                }\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n                     break;\n                 }\n             }\n+            SyntaxKind::ASSOC_ITEM_LIST if !matches!(anchor, Anchor::Method) => {\n+                continue;\n+            }\n             SyntaxKind::ASSOC_ITEM_LIST => {\n-                if !matches!(anchor, Anchor::Method) {\n-                    continue;\n-                }\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::IMPL) {\n                     break;\n                 }\n             }\n-            _ => {}\n+            _ => (),\n         }\n         last_ancestor = Some(next_ancestor);\n     }\n     last_ancestor\n }\n \n-fn format_replacement(\n+fn make_call(\n     ctx: &AssistContext,\n     fun: &Function,\n     indent: IndentLevel,\n@@ -1061,10 +1065,10 @@ impl FlowHandler {\n                 let action = flow_kind.clone();\n                 if *ret_ty == FunType::Unit {\n                     match flow_kind {\n-                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                        FlowKind::Return(None) | FlowKind::Break(None) | FlowKind::Continue => {\n                             FlowHandler::If { action }\n                         }\n-                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                        FlowKind::Return(_) | FlowKind::Break(_) => {\n                             FlowHandler::IfOption { action }\n                         }\n                         FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n@@ -1073,10 +1077,10 @@ impl FlowHandler {\n                     }\n                 } else {\n                     match flow_kind {\n-                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                        FlowKind::Return(None) | FlowKind::Break(None) | FlowKind::Continue => {\n                             FlowHandler::MatchOption { none: action }\n                         }\n-                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                        FlowKind::Return(_) | FlowKind::Break(_) => {\n                             FlowHandler::MatchResult { err: action }\n                         }\n                         FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n@@ -3777,6 +3781,56 @@ async fn some_function() {\n             extract_function,\n             r#\"\n fn main() $0{}$0\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_adds_comma_for_match_arm() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn main() {\n+    match 6 {\n+        100 => $0{ 100 }$0\n+        _ => 0,\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 6 {\n+        100 => fun_name(),\n+        _ => 0,\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    100\n+}\n+\"#,\n+        );\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn main() {\n+    match 6 {\n+        100 => $0{ 100 }$0,\n+        _ => 0,\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 6 {\n+        100 => fun_name(),\n+        _ => 0,\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    100\n+}\n \"#,\n         );\n     }"}, {"sha": "5307516ecb792dae8f31586372dd65ee0be2a5b0", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1f817833e7fbf29d8305b0b938b516d96e555ace/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f817833e7fbf29d8305b0b938b516d96e555ace/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=1f817833e7fbf29d8305b0b938b516d96e555ace", "patch": "@@ -1,5 +1,7 @@\n //! Various extension methods to ast Expr Nodes, which are hard to code-generate.\n \n+use rowan::WalkEvent;\n+\n use crate::{\n     ast::{self, support, AstChildren, AstNode},\n     AstToken,\n@@ -34,6 +36,122 @@ impl ast::Expr {\n         }\n         None\n     }\n+\n+    /// Preorder walk all the expression's child expressions.\n+    pub fn walk(&self, cb: &mut dyn FnMut(ast::Expr)) {\n+        self.preorder(&mut |ev| {\n+            if let WalkEvent::Enter(expr) = ev {\n+                cb(expr);\n+            }\n+            false\n+        })\n+    }\n+\n+    /// Preorder walk all the expression's child expressions preserving events.\n+    /// If the callback returns true the subtree of the expression will be skipped.\n+    /// Note that the subtree may already be skipped due to the context analysis this function does.\n+    pub fn preorder(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(node) => {\n+                    if let Some(expr) = ast::Expr::cast(node) {\n+                        cb(WalkEvent::Leave(expr));\n+                    }\n+                    continue;\n+                }\n+            };\n+            match ast::Stmt::cast(node.clone()) {\n+                // recursively walk the initializer, skipping potential const pat expressions\n+                // let statements aren't usually nested too deeply so this is fine to recurse on\n+                Some(ast::Stmt::LetStmt(l)) => {\n+                    if let Some(expr) = l.initializer() {\n+                        expr.preorder(cb);\n+                    }\n+                    preorder.skip_subtree();\n+                }\n+                // Don't skip subtree since we want to process the expression child next\n+                Some(ast::Stmt::ExprStmt(_)) => (),\n+                // skip inner items which might have their own expressions\n+                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+                None => {\n+                    // skip const args, those expressions are a different context\n+                    if ast::GenericArg::can_cast(node.kind()) {\n+                        preorder.skip_subtree();\n+                    } else if let Some(expr) = ast::Expr::cast(node) {\n+                        let is_different_context = match &expr {\n+                            ast::Expr::EffectExpr(effect) => {\n+                                matches!(\n+                                    effect.effect(),\n+                                    ast::Effect::Async(_)\n+                                        | ast::Effect::Try(_)\n+                                        | ast::Effect::Const(_)\n+                                )\n+                            }\n+                            ast::Expr::ClosureExpr(_) => true,\n+                            _ => false,\n+                        };\n+                        let skip = cb(WalkEvent::Enter(expr));\n+                        if skip || is_different_context {\n+                            preorder.skip_subtree();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Preorder walk all the expression's child patterns.\n+    pub fn walk_patterns(&self, cb: &mut dyn FnMut(ast::Pat)) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(_) => continue,\n+            };\n+            match ast::Stmt::cast(node.clone()) {\n+                Some(ast::Stmt::LetStmt(l)) => {\n+                    if let Some(pat) = l.pat() {\n+                        pat.walk(cb);\n+                    }\n+                    if let Some(expr) = l.initializer() {\n+                        expr.walk_patterns(cb);\n+                    }\n+                    preorder.skip_subtree();\n+                }\n+                // Don't skip subtree since we want to process the expression child next\n+                Some(ast::Stmt::ExprStmt(_)) => (),\n+                // skip inner items which might have their own patterns\n+                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+                None => {\n+                    // skip const args, those are a different context\n+                    if ast::GenericArg::can_cast(node.kind()) {\n+                        preorder.skip_subtree();\n+                    } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n+                        let is_different_context = match &expr {\n+                            ast::Expr::EffectExpr(effect) => {\n+                                matches!(\n+                                    effect.effect(),\n+                                    ast::Effect::Async(_)\n+                                        | ast::Effect::Try(_)\n+                                        | ast::Effect::Const(_)\n+                                )\n+                            }\n+                            ast::Expr::ClosureExpr(_) => true,\n+                            _ => false,\n+                        };\n+                        if is_different_context {\n+                            preorder.skip_subtree();\n+                        }\n+                    } else if let Some(pat) = ast::Pat::cast(node) {\n+                        preorder.skip_subtree();\n+                        pat.walk(cb);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "ea156087fff47bdda5091b5684702cb1a8e90281", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1f817833e7fbf29d8305b0b938b516d96e555ace/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f817833e7fbf29d8305b0b938b516d96e555ace/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=1f817833e7fbf29d8305b0b938b516d96e555ace", "patch": "@@ -55,107 +55,6 @@ impl ast::BlockExpr {\n     }\n }\n \n-impl ast::Expr {\n-    /// Preorder walk all the expression's child expressions.\n-    pub fn walk(&self, cb: &mut dyn FnMut(ast::Expr)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            match ast::Stmt::cast(node.clone()) {\n-                // recursively walk the initializer, skipping potential const pat expressions\n-                // let statements aren't usually nested too deeply so this is fine to recurse on\n-                Some(ast::Stmt::LetStmt(l)) => {\n-                    if let Some(expr) = l.initializer() {\n-                        expr.walk(cb);\n-                    }\n-                    preorder.skip_subtree();\n-                }\n-                // Don't skip subtree since we want to process the expression child next\n-                Some(ast::Stmt::ExprStmt(_)) => (),\n-                // skip inner items which might have their own expressions\n-                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-                None => {\n-                    // skip const args, those expressions are a different context\n-                    if ast::GenericArg::can_cast(node.kind()) {\n-                        preorder.skip_subtree();\n-                    } else if let Some(expr) = ast::Expr::cast(node) {\n-                        let is_different_context = match &expr {\n-                            ast::Expr::EffectExpr(effect) => {\n-                                matches!(\n-                                    effect.effect(),\n-                                    ast::Effect::Async(_)\n-                                        | ast::Effect::Try(_)\n-                                        | ast::Effect::Const(_)\n-                                )\n-                            }\n-                            ast::Expr::ClosureExpr(_) => true,\n-                            _ => false,\n-                        };\n-                        cb(expr);\n-                        if is_different_context {\n-                            preorder.skip_subtree();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Preorder walk all the expression's child patterns.\n-    pub fn walk_patterns(&self, cb: &mut dyn FnMut(ast::Pat)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            match ast::Stmt::cast(node.clone()) {\n-                Some(ast::Stmt::LetStmt(l)) => {\n-                    if let Some(pat) = l.pat() {\n-                        pat.walk(cb);\n-                    }\n-                    if let Some(expr) = l.initializer() {\n-                        expr.walk_patterns(cb);\n-                    }\n-                    preorder.skip_subtree();\n-                }\n-                // Don't skip subtree since we want to process the expression child next\n-                Some(ast::Stmt::ExprStmt(_)) => (),\n-                // skip inner items which might have their own patterns\n-                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-                None => {\n-                    // skip const args, those are a different context\n-                    if ast::GenericArg::can_cast(node.kind()) {\n-                        preorder.skip_subtree();\n-                    } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n-                        let is_different_context = match &expr {\n-                            ast::Expr::EffectExpr(effect) => {\n-                                matches!(\n-                                    effect.effect(),\n-                                    ast::Effect::Async(_)\n-                                        | ast::Effect::Try(_)\n-                                        | ast::Effect::Const(_)\n-                                )\n-                            }\n-                            ast::Expr::ClosureExpr(_) => true,\n-                            _ => false,\n-                        };\n-                        if is_different_context {\n-                            preorder.skip_subtree();\n-                        }\n-                    } else if let Some(pat) = ast::Pat::cast(node) {\n-                        preorder.skip_subtree();\n-                        pat.walk(cb);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl ast::Pat {\n     /// Preorder walk all the pattern's sub patterns.\n     pub fn walk(&self, cb: &mut dyn FnMut(ast::Pat)) {"}]}