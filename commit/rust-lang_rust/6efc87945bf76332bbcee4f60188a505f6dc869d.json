{"sha": "6efc87945bf76332bbcee4f60188a505f6dc869d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZmM4Nzk0NWJmNzYzMzJiYmNlZTRmNjAxODhhNTA1ZjZkYzg2OWQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T18:18:39Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T00:05:58Z"}, "message": "libgetops: remove unnecessary `as_slice()` calls", "tree": {"sha": "e6ff6e2976330179faaf772a9aa2abb28796dc40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6ff6e2976330179faaf772a9aa2abb28796dc40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6efc87945bf76332bbcee4f60188a505f6dc869d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6efc87945bf76332bbcee4f60188a505f6dc869d", "html_url": "https://github.com/rust-lang/rust/commit/6efc87945bf76332bbcee4f60188a505f6dc869d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6efc87945bf76332bbcee4f60188a505f6dc869d/comments", "author": null, "committer": null, "parents": [{"sha": "a7960136aca69d44bbe429a8690ca05391e5e349", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7960136aca69d44bbe429a8690ca05391e5e349", "html_url": "https://github.com/rust-lang/rust/commit/a7960136aca69d44bbe429a8690ca05391e5e349"}], "stats": {"total": 17, "additions": 8, "deletions": 9}, "files": [{"sha": "19af3f595b28648054f26594c9bbc26af6018e16", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6efc87945bf76332bbcee4f60188a505f6dc869d/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efc87945bf76332bbcee4f60188a505f6dc869d/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=6efc87945bf76332bbcee4f60188a505f6dc869d", "patch": "@@ -244,7 +244,7 @@ impl OptGroup {\n                 aliases: Vec::new()\n             },\n             (1,0) => Opt {\n-                name: Short(short_name.as_slice().char_at(0)),\n+                name: Short(short_name.char_at(0)),\n                 hasarg: hasarg,\n                 occur: occur,\n                 aliases: Vec::new()\n@@ -255,7 +255,7 @@ impl OptGroup {\n                 occur: occur,\n                 aliases: vec!(\n                     Opt {\n-                        name: Short(short_name.as_slice().char_at(0)),\n+                        name: Short(short_name.char_at(0)),\n                         hasarg: hasarg,\n                         occur:  occur,\n                         aliases: Vec::new()\n@@ -576,15 +576,15 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         let curlen = cur.len();\n         if !is_arg(cur.as_slice()) {\n             free.push(cur);\n-        } else if cur.as_slice() == \"--\" {\n+        } else if cur == \"--\" {\n             let mut j = i + 1;\n             while j < l { free.push(args[j].clone()); j += 1; }\n             break;\n         } else {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur.as_slice().slice(2, curlen);\n+                let tail = cur.slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -597,7 +597,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let mut j = 1;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let range = cur.as_slice().char_range_at(j);\n+                    let range = cur.char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -620,8 +620,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur.as_slice()\n-                                        .slice(range.next, curlen).to_string());\n+                        i_arg = Some(cur.slice(range.next, curlen).to_string());\n                         break;\n                     }\n \n@@ -736,7 +735,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // here we just need to indent the start of the description\n-        let rowlen = row.as_slice().char_len();\n+        let rowlen = row.char_len();\n         if rowlen < 24 {\n             for _ in range(0, 24 - rowlen) {\n                 row.push(' ');\n@@ -747,7 +746,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // Normalize desc to contain words separated by one space character\n         let mut desc_normalized_whitespace = String::new();\n-        for word in desc.as_slice().words() {\n+        for word in desc.words() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push(' ');\n         }"}]}