{"sha": "5dcaf108c2897b70b37052c0c466019f7d4499d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkY2FmMTA4YzI4OTdiNzBiMzcwNTJjMGM0NjYwMTlmN2Q0NDk5ZDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-16T02:15:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-16T02:15:44Z"}, "message": "Merge #4288\n\n4288: Add rename self to parameter and back. r=zbsz a=zbsz\n\nThis is a first stab at #3439\r\nI liked the idea to do this as a rename instead of separate assist, so I tried implementing that.\r\nIt mostly works, but I'm sure there are some cases that I missed, especially in regards to parameter type.\r\n\r\nNote: I'm playing with this this as a way to learn Rust and this project. So I'm sure it could be cleaner and put in better places`. Any suggestions?\n\nCo-authored-by: zbsz <zbigniewo@gmail.com>", "tree": {"sha": "66d466b0be0befaea9f5a40e48e9f833cd23fc85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66d466b0be0befaea9f5a40e48e9f833cd23fc85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dcaf108c2897b70b37052c0c466019f7d4499d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJev0zQCRBK7hj4Ov3rIwAAdHIIABfiy0/MJSnnaROoll2aJrPK\nLDIVwYJq+yRBSkUNOhnoTMwxZmxy4MnPrj4Zl7c61y5qJWNGXkVeXxSYb0fs2tIX\nIX6It8QTUMFapEclm9VaNXO4A3JG+IGvFYSbaW384r3pzLkxZ7+giZG5yI0AEvcz\n/98GEnTlLwML5L+uaIz2Rbz0h9r4yvkKSjQ9CVnGvyHQZbLQuHcW7Myxthc73wya\njau35zruqFPdrt7DDrS5GIlQThxEpFJ/gxyenuA2eJhWiAxVltHbtx3os99D7yGk\nvTUxHjp9E5EJ1lg0lQSJ4AwkMBiJXoXTX9bUhtr7hOvHabV4B+4Fu+H7ODe+YB4=\n=JsLk\n-----END PGP SIGNATURE-----\n", "payload": "tree 66d466b0be0befaea9f5a40e48e9f833cd23fc85\nparent cffa70be01d4353184f874fc4768b692e255dd30\nparent d7d8bfc472fcb009c605b2ffba56cf04c4bc73a2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589595344 +0000\ncommitter GitHub <noreply@github.com> 1589595344 +0000\n\nMerge #4288\n\n4288: Add rename self to parameter and back. r=zbsz a=zbsz\n\nThis is a first stab at #3439\r\nI liked the idea to do this as a rename instead of separate assist, so I tried implementing that.\r\nIt mostly works, but I'm sure there are some cases that I missed, especially in regards to parameter type.\r\n\r\nNote: I'm playing with this this as a way to learn Rust and this project. So I'm sure it could be cleaner and put in better places`. Any suggestions?\n\nCo-authored-by: zbsz <zbigniewo@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dcaf108c2897b70b37052c0c466019f7d4499d9", "html_url": "https://github.com/rust-lang/rust/commit/5dcaf108c2897b70b37052c0c466019f7d4499d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dcaf108c2897b70b37052c0c466019f7d4499d9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cffa70be01d4353184f874fc4768b692e255dd30", "url": "https://api.github.com/repos/rust-lang/rust/commits/cffa70be01d4353184f874fc4768b692e255dd30", "html_url": "https://github.com/rust-lang/rust/commit/cffa70be01d4353184f874fc4768b692e255dd30"}, {"sha": "d7d8bfc472fcb009c605b2ffba56cf04c4bc73a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d8bfc472fcb009c605b2ffba56cf04c4bc73a2", "html_url": "https://github.com/rust-lang/rust/commit/d7d8bfc472fcb009c605b2ffba56cf04c4bc73a2"}], "stats": {"total": 211, "additions": 206, "deletions": 5}, "files": [{"sha": "410dae75cb457561ab90628ed389fa4f8c7e802a", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 206, "deletions": 5, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/5dcaf108c2897b70b37052c0c466019f7d4499d9/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcaf108c2897b70b37052c0c466019f7d4499d9/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=5dcaf108c2897b70b37052c0c466019f7d4499d9", "patch": "@@ -4,14 +4,16 @@ use hir::{ModuleSource, Semantics};\n use ra_db::{RelativePath, RelativePathBuf, SourceDatabaseExt};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    algo::find_node_at_offset, ast, lex_single_valid_syntax_kind, AstNode, SyntaxKind, SyntaxNode,\n+    algo::find_node_at_offset, ast, ast::TypeAscriptionOwner, lex_single_valid_syntax_kind,\n+    AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n use ra_text_edit::TextEdit;\n+use std::convert::TryInto;\n use test_utils::tested_by;\n \n use crate::{\n     references::find_all_refs, FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind,\n-    SourceChange, SourceFileEdit, TextRange,\n+    SourceChange, SourceFileEdit, TextRange, TextSize,\n };\n \n pub(crate) fn rename(\n@@ -21,17 +23,21 @@ pub(crate) fn rename(\n ) -> Option<RangeInfo<SourceChange>> {\n     match lex_single_valid_syntax_kind(new_name)? {\n         SyntaxKind::IDENT | SyntaxKind::UNDERSCORE => (),\n+        SyntaxKind::SELF_KW => return rename_to_self(db, position),\n         _ => return None,\n     }\n \n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n-    if let Some((ast_name, ast_module)) =\n-        find_name_and_module_at_offset(source_file.syntax(), position)\n-    {\n+    let syntax = source_file.syntax();\n+    if let Some((ast_name, ast_module)) = find_name_and_module_at_offset(syntax, position) {\n         let range = ast_name.syntax().text_range();\n         rename_mod(&sema, &ast_name, &ast_module, position, new_name)\n             .map(|info| RangeInfo::new(range, info))\n+    } else if let Some(self_token) =\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+    {\n+        rename_self_to_param(db, position, self_token, new_name)\n     } else {\n         rename_reference(sema.db, position, new_name)\n     }\n@@ -125,6 +131,112 @@ fn rename_mod(\n     Some(SourceChange::from_edits(\"Rename\", source_file_edits, file_system_edits))\n }\n \n+fn rename_to_self(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<SourceChange>> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+    let syn = source_file.syntax();\n+\n+    let fn_def = find_node_at_offset::<ast::FnDef>(syn, position.offset)?;\n+    let params = fn_def.param_list()?;\n+    if params.self_param().is_some() {\n+        return None; // method already has self param\n+    }\n+    let first_param = params.params().next()?;\n+    let mutable = match first_param.ascribed_type() {\n+        Some(ast::TypeRef::ReferenceType(rt)) => rt.mut_token().is_some(),\n+        _ => return None, // not renaming other types\n+    };\n+\n+    let RangeInfo { range, info: refs } = find_all_refs(db, position, None)?;\n+\n+    let param_range = first_param.syntax().text_range();\n+    let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n+        .into_iter()\n+        .partition(|reference| param_range.intersect(reference.file_range.range).is_some());\n+\n+    if param_ref.is_empty() {\n+        return None;\n+    }\n+\n+    let mut edits = usages\n+        .into_iter()\n+        .map(|reference| source_edit_from_reference(reference, \"self\"))\n+        .collect::<Vec<_>>();\n+\n+    edits.push(SourceFileEdit {\n+        file_id: position.file_id,\n+        edit: TextEdit::replace(\n+            param_range,\n+            String::from(if mutable { \"&mut self\" } else { \"&self\" }),\n+        ),\n+    });\n+\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"Rename\", edits)))\n+}\n+\n+fn text_edit_from_self_param(\n+    syn: &SyntaxNode,\n+    self_param: &ast::SelfParam,\n+    new_name: &str,\n+) -> Option<TextEdit> {\n+    fn target_type_name(impl_def: &ast::ImplDef) -> Option<String> {\n+        if let Some(ast::TypeRef::PathType(p)) = impl_def.target_type() {\n+            return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n+        }\n+        None\n+    }\n+\n+    let impl_def =\n+        find_node_at_offset::<ast::ImplDef>(syn, self_param.syntax().text_range().start())?;\n+    let type_name = target_type_name(&impl_def)?;\n+\n+    let mut replacement_text = String::from(new_name);\n+    replacement_text.push_str(\": \");\n+    replacement_text.push_str(self_param.mut_token().map_or(\"&\", |_| \"&mut \"));\n+    replacement_text.push_str(type_name.as_str());\n+\n+    Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n+}\n+\n+fn rename_self_to_param(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    self_token: SyntaxToken,\n+    new_name: &str,\n+) -> Option<RangeInfo<SourceChange>> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+    let syn = source_file.syntax();\n+\n+    let text = db.file_text(position.file_id);\n+    let fn_def = find_node_at_offset::<ast::FnDef>(syn, position.offset)?;\n+    let search_range = fn_def.syntax().text_range();\n+\n+    let mut edits: Vec<SourceFileEdit> = vec![];\n+\n+    for (idx, _) in text.match_indices(\"self\") {\n+        let offset: TextSize = idx.try_into().unwrap();\n+        if !search_range.contains_inclusive(offset) {\n+            continue;\n+        }\n+        if let Some(ref usage) =\n+            syn.token_at_offset(offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+        {\n+            let edit = if let Some(ref self_param) = ast::SelfParam::cast(usage.parent()) {\n+                text_edit_from_self_param(syn, self_param, new_name)?\n+            } else {\n+                TextEdit::replace(usage.text_range(), String::from(new_name))\n+            };\n+            edits.push(SourceFileEdit { file_id: position.file_id, edit });\n+        }\n+    }\n+\n+    let range = ast::SelfParam::cast(self_token.parent())\n+        .map_or(self_token.text_range(), |p| p.syntax().text_range());\n+\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"Rename\", edits)))\n+}\n+\n fn rename_reference(\n     db: &RootDatabase,\n     position: FilePosition,\n@@ -774,6 +886,95 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_parameter_to_self() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(foo<|>: &mut Foo) -> i32 {\n+            foo.i\n+        }\n+    }\n+    \"#,\n+            \"self\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(&mut self) -> i32 {\n+            self.i\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_self_to_parameter() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(&mut <|>self) -> i32 {\n+            self.i\n+        }\n+    }\n+    \"#,\n+            \"foo\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(foo: &mut Foo) -> i32 {\n+            foo.i\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_self_in_path_to_parameter() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(&self) -> i32 {\n+            let self_var = 1;\n+            self<|>.i\n+        }\n+    }\n+    \"#,\n+            \"foo\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(foo: &Foo) -> i32 {\n+            let self_var = 1;\n+            foo.i\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n     fn test_rename(text: &str, new_name: &str, expected: &str) {\n         let (analysis, position) = single_file_with_position(text);\n         let source_change = analysis.rename(position, new_name).unwrap();"}]}