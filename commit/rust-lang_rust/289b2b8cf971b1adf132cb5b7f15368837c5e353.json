{"sha": "289b2b8cf971b1adf132cb5b7f15368837c5e353", "node_id": "C_kwDOAAsO6NoAKDI4OWIyYjhjZjk3MWIxYWRmMTMyY2I1YjdmMTUzNjg4MzdjNWUzNTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T13:40:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T13:40:59Z"}, "message": "Auto merge of #103398 - Dylan-DPC:rollup-cj6w00o, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102602 (Slightly tweak comments wrt `lint_overflowing_range_endpoint`)\n - #103190 (rustdoc: render bounds of cross-crate GAT params)\n - #103224 (Allow semicolon after closure within parentheses in macros)\n - #103280 ((#102929) Implement `String::leak` (attempt 2))\n - #103329 (Add a forgotten check for NonNull::new_unchecked's precondition)\n - #103346 (Adjust argument type for mutable with_metadata_of (#75091))\n - #103360 (Reduce false positives in msys2 detection)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7306de2ec1b0edf3e3f404061a6af2c75562786e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7306de2ec1b0edf3e3f404061a6af2c75562786e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/289b2b8cf971b1adf132cb5b7f15368837c5e353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/289b2b8cf971b1adf132cb5b7f15368837c5e353", "html_url": "https://github.com/rust-lang/rust/commit/289b2b8cf971b1adf132cb5b7f15368837c5e353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/289b2b8cf971b1adf132cb5b7f15368837c5e353/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8c86c82bfae6d4b90395d08af88e93d6cba5402", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c86c82bfae6d4b90395d08af88e93d6cba5402", "html_url": "https://github.com/rust-lang/rust/commit/f8c86c82bfae6d4b90395d08af88e93d6cba5402"}, {"sha": "b4536943e391cf175c149ffb72af3a8cce14e803", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4536943e391cf175c149ffb72af3a8cce14e803", "html_url": "https://github.com/rust-lang/rust/commit/b4536943e391cf175c149ffb72af3a8cce14e803"}], "stats": {"total": 220, "additions": 153, "deletions": 67}, "files": [{"sha": "3cdca2178657d78d910186e6848b480d9dcf0a65", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -116,8 +116,8 @@ impl TypeLimits {\n     }\n }\n \n-/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n-/// Returns `true` iff the lint was overridden.\n+/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint (`expr..MAX+1`).\n+/// Returns `true` iff the lint was emitted.\n fn lint_overflowing_range_endpoint<'tcx>(\n     cx: &LateContext<'tcx>,\n     lit: &hir::Lit,\n@@ -140,44 +140,46 @@ fn lint_overflowing_range_endpoint<'tcx>(\n         return false;\n     }\n \n-    let mut overwritten = false;\n     // We can suggest using an inclusive range\n     // (`..=`) instead only if it is the `end` that is\n     // overflowing and only by 1.\n-    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max\n-        && let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span)\n-    {\n-        cx.struct_span_lint(\n-            OVERFLOWING_LITERALS,\n-            struct_expr.span,\n-            fluent::lint::range_endpoint_out_of_range,\n-            |lint| {\n-                use ast::{LitIntType, LitKind};\n-\n-                lint.set_arg(\"ty\", ty);\n-\n-                // We need to preserve the literal's suffix,\n-                // as it may determine typing information.\n-                let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                    _ => bug!(),\n-                };\n-                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                lint.span_suggestion(\n-                    struct_expr.span,\n-                    fluent::lint::suggestion,\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n-                overwritten = true;\n+    if !(eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max) {\n+        return false;\n+    };\n+    let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n-                lint\n-            },\n-        );\n-    }\n-    overwritten\n+    cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        struct_expr.span,\n+        fluent::lint::range_endpoint_out_of_range,\n+        |lint| {\n+            use ast::{LitIntType, LitKind};\n+\n+            lint.set_arg(\"ty\", ty);\n+\n+            // We need to preserve the literal's suffix,\n+            // as it may determine typing information.\n+            let suffix = match lit.node {\n+                LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+                LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+                LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+                _ => bug!(),\n+            };\n+            let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+            lint.span_suggestion(\n+                struct_expr.span,\n+                fluent::lint::suggestion,\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+\n+            lint\n+        },\n+    );\n+\n+    // We've just emitted a lint, special cased for `(...)..MAX+1` ranges,\n+    // return `true` so the callers don't also emit a lint\n+    true\n }\n \n // For `isize` & `usize`, be conservative with the warnings, so that the\n@@ -358,7 +360,7 @@ fn lint_int_literal<'tcx>(\n         }\n \n         if lint_overflowing_range_endpoint(cx, lit, v, max, e, t.name_str()) {\n-            // The overflowing literal lint was overridden.\n+            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n             return;\n         }\n \n@@ -427,7 +429,7 @@ fn lint_uint_literal<'tcx>(\n             }\n         }\n         if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, t.name_str()) {\n-            // The overflowing literal lint was overridden.\n+            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n             return;\n         }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {"}, {"sha": "5b466cec8e15b089298bf245c4ab7976ae3c0c4e", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -2051,6 +2051,10 @@ impl<'a> Parser<'a> {\n \n         if self.token.kind == TokenKind::Semi\n             && matches!(self.token_cursor.frame.delim_sp, Some((Delimiter::Parenthesis, _)))\n+            // HACK: This is needed so we can detect whether we're inside a macro,\n+            // where regular assumptions about what tokens can follow other tokens\n+            // don't necessarily apply.\n+            && self.subparser_name.is_none()\n         {\n             // It is likely that the closure body is a block but where the\n             // braces have been removed. We will recover and eat the next"}, {"sha": "9c229665c7e91b4169e2976342df87e7b2356b90", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -1386,7 +1386,7 @@ impl<T: ?Sized> Rc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| mem.with_metadata_of(ptr as *mut RcBox<T>),\n+                |mem| mem.with_metadata_of(ptr as *const RcBox<T>),\n             )\n         }\n     }"}, {"sha": "209abfac6bbf9f92a64e1942079c3c60fb5582e9", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -67,7 +67,7 @@ use core::str::Utf8Chunks;\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::collections::TryReserveError;\n-use crate::str::{self, Chars, Utf8Error};\n+use crate::str::{self, from_utf8_unchecked_mut, Chars, Utf8Error};\n #[cfg(not(no_global_oom_handling))]\n use crate::str::{from_boxed_utf8_unchecked, FromStr};\n use crate::vec::Vec;\n@@ -1849,6 +1849,35 @@ impl String {\n         let slice = self.vec.into_boxed_slice();\n         unsafe { from_boxed_utf8_unchecked(slice) }\n     }\n+\n+    /// Consumes and leaks the `String`, returning a mutable reference to the contents,\n+    /// `&'a mut str`.\n+    ///\n+    /// This is mainly useful for data that lives for the remainder of\n+    /// the program's life. Dropping the returned reference will cause a memory\n+    /// leak.\n+    ///\n+    /// It does not reallocate or shrink the `String`,\n+    /// so the leaked allocation may include unused capacity that is not part\n+    /// of the returned slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple usage:\n+    ///\n+    /// ```\n+    /// #![feature(string_leak)]\n+    ///\n+    /// let x = String::from(\"bucket\");\n+    /// let static_ref: &'static mut str = x.leak();\n+    /// assert_eq!(static_ref, \"bucket\");\n+    /// ```\n+    #[unstable(feature = \"string_leak\", issue = \"102929\")]\n+    #[inline]\n+    pub fn leak(self) -> &'static mut str {\n+        let slice = self.vec.leak();\n+        unsafe { from_utf8_unchecked_mut(slice) }\n+    }\n }\n \n impl FromUtf8Error {"}, {"sha": "e8d9de4fb3ce505750a281a734ecd20a1505cea0", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -1204,7 +1204,7 @@ impl<T: ?Sized> Arc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| mem.with_metadata_of(ptr as *mut ArcInner<T>),\n+                |mem| mem.with_metadata_of(ptr as *const ArcInner<T>),\n             )\n         }\n     }"}, {"sha": "0bb2566fd4c98b32f91b5afc9a19cf2e127a0b24", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -80,10 +80,14 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline]\n-    pub fn with_metadata_of<U>(self, mut val: *mut U) -> *mut U\n+    pub fn with_metadata_of<U>(self, val: *const U) -> *mut U\n     where\n         U: ?Sized,\n     {\n+        // Prepare in the type system that we will replace the pointer value with a mutable\n+        // pointer, taking the mutable provenance from the `self` pointer.\n+        let mut val = val as *mut U;\n+        // Pointer to the pointer value within the value.\n         let target = &mut val as *mut *mut U as *mut *mut u8;\n         // SAFETY: In case of a thin pointer, this operations is identical\n         // to a simple assignment. In case of a fat pointer, with the current"}, {"sha": "7264d57ba6aed02a040518b404bd67d8d984bbb8", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -2,6 +2,7 @@ use crate::cmp::Ordering;\n use crate::convert::From;\n use crate::fmt;\n use crate::hash;\n+use crate::intrinsics::assert_unsafe_precondition;\n use crate::marker::Unsize;\n use crate::mem::{self, MaybeUninit};\n use crate::num::NonZeroUsize;\n@@ -195,7 +196,10 @@ impl<T: ?Sized> NonNull<T> {\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         // SAFETY: the caller must guarantee that `ptr` is non-null.\n-        unsafe { NonNull { pointer: ptr as _ } }\n+        unsafe {\n+            assert_unsafe_precondition!([T: ?Sized](ptr: *mut T) => !ptr.is_null());\n+            NonNull { pointer: ptr as _ }\n+        }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null."}, {"sha": "be6fc2ebb7a27f73ee3a076b9f19d5de0c58faab", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -129,6 +129,8 @@ pub const FIONBIO: c_ulong = 0x8004667e;\n \n pub const MAX_PATH: usize = 260;\n \n+pub const FILE_TYPE_PIPE: u32 = 3;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {\n@@ -1114,6 +1116,7 @@ extern \"system\" {\n         lpFileInformation: LPVOID,\n         dwBufferSize: DWORD,\n     ) -> BOOL;\n+    pub fn GetFileType(hfile: HANDLE) -> DWORD;\n     pub fn SleepConditionVariableSRW(\n         ConditionVariable: PCONDITION_VARIABLE,\n         SRWLock: PSRWLOCK,"}, {"sha": "2cc34c986b990e59002d37791593e1cc6ea65aef", "filename": "library/std/src/sys/windows/io.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -120,6 +120,11 @@ unsafe fn handle_is_console(handle: BorrowedHandle<'_>) -> bool {\n }\n \n unsafe fn msys_tty_on(handle: c::HANDLE) -> bool {\n+    // Early return if the handle is not a pipe.\n+    if c::GetFileType(handle) != c::FILE_TYPE_PIPE {\n+        return false;\n+    }\n+\n     const SIZE: usize = size_of::<c::FILE_NAME_INFO>() + c::MAX_PATH * size_of::<c::WCHAR>();\n     let mut name_info_bytes = Align8([0u8; SIZE]);\n     let res = c::GetFileInformationByHandleEx(\n@@ -137,11 +142,13 @@ unsafe fn msys_tty_on(handle: c::HANDLE) -> bool {\n     let name_ptr = name_info_bytes.0.as_ptr().offset(size_of::<c::DWORD>() as isize).cast::<u16>();\n     let s = core::slice::from_raw_parts(name_ptr, name_len);\n     let name = String::from_utf16_lossy(s);\n+    // Get the file name only.\n+    let name = name.rsplit('\\\\').next().unwrap_or(&name);\n     // This checks whether 'pty' exists in the file name, which indicates that\n     // a pseudo-terminal is attached. To mitigate against false positives\n     // (e.g., an actual file name that contains 'pty'), we also require that\n-    // either the strings 'msys-' or 'cygwin-' are in the file name as well.)\n-    let is_msys = name.contains(\"msys-\") || name.contains(\"cygwin-\");\n+    // the file name begins with either the strings 'msys-' or 'cygwin-'.)\n+    let is_msys = name.starts_with(\"msys-\") || name.starts_with(\"cygwin-\");\n     let is_pty = name.contains(\"-pty\");\n     is_msys && is_pty\n }"}, {"sha": "13d63ffa0ee3cc18163b9b6dd7fb8a5f71ae0712", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -1201,21 +1201,19 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n             }\n \n             if let ty::TraitContainer = assoc_item.container {\n-                // FIXME(fmease): `tcx.explicit_item_bounds` does not contain the bounds of GATs,\n-                //                e.g. the bounds `Copy`, `Display` & (implicitly) `Sized` in\n-                //                `type Assoc<T: Copy> where T: Display`. This also means that we\n-                //                later incorrectly render `where T: ?Sized`.\n-                //\n-                //                The result of `tcx.explicit_predicates_of` *does* contain them but\n-                //                it does not contain the other bounds / predicates we need.\n-                //                Either merge those two interned lists somehow or refactor\n-                //                `clean_ty_generics` to call `explicit_item_bounds` by itself.\n                 let bounds = tcx.explicit_item_bounds(assoc_item.def_id);\n-                let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                let mut generics =\n-                    clean_ty_generics(cx, tcx.generics_of(assoc_item.def_id), predicates);\n-                // Filter out the bounds that are (likely?) directly attached to the associated type,\n-                // as opposed to being located in the where clause.\n+                let predicates = tcx.explicit_predicates_of(assoc_item.def_id).predicates;\n+                let predicates =\n+                    tcx.arena.alloc_from_iter(bounds.into_iter().chain(predicates).copied());\n+                let mut generics = clean_ty_generics(\n+                    cx,\n+                    tcx.generics_of(assoc_item.def_id),\n+                    ty::GenericPredicates { parent: None, predicates },\n+                );\n+                // Move bounds that are (likely) directly attached to the associated type\n+                // from the where clause to the associated type.\n+                // There is no guarantee that this is what the user actually wrote but we have\n+                // no way of knowing.\n                 let mut bounds = generics\n                     .where_predicates\n                     .drain_filter(|pred| match *pred {\n@@ -1273,6 +1271,24 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                     }\n                     None => bounds.push(GenericBound::maybe_sized(cx)),\n                 }\n+                // Move bounds that are (likely) directly attached to the parameters of the\n+                // (generic) associated type from the where clause to the respective parameter.\n+                // There is no guarantee that this is what the user actually wrote but we have\n+                // no way of knowing.\n+                let mut where_predicates = Vec::new();\n+                for mut pred in generics.where_predicates {\n+                    if let WherePredicate::BoundPredicate { ty: Generic(arg), bounds, .. } = &mut pred\n+                    && let Some(GenericParamDef {\n+                        kind: GenericParamDefKind::Type { bounds: param_bounds, .. },\n+                        ..\n+                    }) = generics.params.iter_mut().find(|param| &param.name == arg)\n+                    {\n+                        param_bounds.extend(mem::take(bounds));\n+                    } else {\n+                        where_predicates.push(pred);\n+                    }\n+                }\n+                generics.where_predicates = where_predicates;\n \n                 if tcx.impl_defaultness(assoc_item.def_id).has_value() {\n                     AssocTypeItem("}, {"sha": "8934bc1ee339cb92742f33da4edeb3e2a088d148", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds.out0.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out0.html", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out0.html?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -0,0 +1 @@\n+<h4 class=\"code-header\">type <a href=\"#associatedtype.Out0\" class=\"associatedtype\">Out0</a>: <a class=\"trait\" href=\"../assoc_item_trait_bounds/trait.Support.html\" title=\"trait assoc_item_trait_bounds::Support\">Support</a>&lt;Item = <a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>&gt;</h4>\n\\ No newline at end of file"}, {"sha": "bf330670ed0fa596839ac4eafd6b6bd1725b9bca", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds.out2.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out2.html", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out2.html?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -0,0 +1 @@\n+<h4 class=\"code-header\">type <a href=\"#associatedtype.Out2\" class=\"associatedtype\">Out2</a>&lt;T&gt;: <a class=\"trait\" href=\"../assoc_item_trait_bounds/trait.Support.html\" title=\"trait assoc_item_trait_bounds::Support\">Support</a>&lt;Item = T&gt;</h4>\n\\ No newline at end of file"}, {"sha": "69d84e1b2c14e88ab373bb4989caa78b30f5d209", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds.out9.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out9.html", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out9.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.out9.html?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "previous_filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds_with_bindings.out9.html"}, {"sha": "5f4712aab5b19efd916b9d240885f7144346dda1", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -1,13 +1,10 @@\n // Regression test for issues #77763, #84579 and #102142.\n #![crate_name = \"main\"]\n \n-// aux-build:assoc_item_trait_bounds_with_bindings.rs\n+// aux-build:assoc_item_trait_bounds.rs\n // build-aux-docs\n // ignore-cross-compile\n-extern crate assoc_item_trait_bounds_with_bindings as aux;\n-\n-// FIXME(fmease): Don't render an incorrect `T: ?Sized` where-clause for parameters\n-//                of GATs like `Main::Out{2,4}`. Add a snapshot test once it's fixed.\n+extern crate assoc_item_trait_bounds as aux;\n \n // @has main/trait.Main.html\n // @has - '//*[@id=\"associatedtype.Out0\"]' 'type Out0: Support<Item = ()>'\n@@ -24,11 +21,15 @@ extern crate assoc_item_trait_bounds_with_bindings as aux;\n // @has - '//*[@id=\"associatedtype.Out11\"]' \"type Out11: for<'r, 's> Helper<A<'s> = &'s (), B<'r> = ()>\"\n // @has - '//*[@id=\"associatedtype.Out12\"]' \"type Out12: for<'w> Helper<B<'w> = Cow<'w, str>, A<'w> = bool>\"\n // @has - '//*[@id=\"associatedtype.Out13\"]' \"type Out13: for<'fst, 'snd> Aid<'snd, Result<'fst> = &'fst mut str>\"\n+// @has - '//*[@id=\"associatedtype.Out14\"]' \"type Out14<P: Copy + Eq, Q: ?Sized>\"\n //\n-// Snapshots: Check that we do not render any where-clauses for those associated types since all of\n-// the trait bounds contained within were moved to the bounds of the respective item.\n+// Snapshots:\n+// Check that we don't render any where-clauses for the following associated types since\n+// all corresponding projection equality predicates should have already been re-sugared\n+// to associated type bindings:\n //\n // @snapshot out0 - '//*[@id=\"associatedtype.Out0\"]/*[@class=\"code-header\"]'\n+// @snapshot out2 - '//*[@id=\"associatedtype.Out2\"]/*[@class=\"code-header\"]'\n // @snapshot out9 - '//*[@id=\"associatedtype.Out9\"]/*[@class=\"code-header\"]'\n //\n // @has - '//*[@id=\"tymethod.make\"]' \\", "previous_filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds_with_bindings.rs"}, {"sha": "927a1a42a1f784bf77870265537784d3c59284c2", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds_with_bindings.out0.html", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8c86c82bfae6d4b90395d08af88e93d6cba5402/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out0.html", "raw_url": "https://github.com/rust-lang/rust/raw/f8c86c82bfae6d4b90395d08af88e93d6cba5402/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out0.html?ref=f8c86c82bfae6d4b90395d08af88e93d6cba5402", "patch": "@@ -1 +0,0 @@\n-<h4 class=\"code-header\">type <a href=\"#associatedtype.Out0\" class=\"associatedtype\">Out0</a>: <a class=\"trait\" href=\"../assoc_item_trait_bounds_with_bindings/trait.Support.html\" title=\"trait assoc_item_trait_bounds_with_bindings::Support\">Support</a>&lt;Item = <a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>&gt;</h4>\n\\ No newline at end of file"}, {"sha": "d326e61daea2608c0835d8474e4d59c8bdec5a7c", "filename": "src/test/rustdoc/inline_cross/auxiliary/assoc_item_trait_bounds.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fassoc_item_trait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fassoc_item_trait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fassoc_item_trait_bounds.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -15,6 +15,7 @@ pub trait Main {\n     type Out11: for<'r, 's> Helper<A<'s> = &'s (), B<'r> = ()>;\n     type Out12: for<'w> Helper<B<'w> = std::borrow::Cow<'w, str>, A<'w> = bool>;\n     type Out13: for<'fst, 'snd> Aid<'snd, Result<'fst> = &'fst mut str>;\n+    type Out14<P: Copy + Eq, Q: ?Sized>;\n \n     fn make<F>(_: F, _: impl FnMut(&str) -> bool)\n     where", "previous_filename": "src/test/rustdoc/inline_cross/auxiliary/assoc_item_trait_bounds_with_bindings.rs"}, {"sha": "14efb6100b0a568a1ce4be674a56044e227ac1f5", "filename": "src/test/ui/parser/semi-after-closure-in-macro.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Fui%2Fparser%2Fsemi-after-closure-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b2b8cf971b1adf132cb5b7f15368837c5e353/src%2Ftest%2Fui%2Fparser%2Fsemi-after-closure-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fsemi-after-closure-in-macro.rs?ref=289b2b8cf971b1adf132cb5b7f15368837c5e353", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+// Checks that the fix in #103222 doesn't also disqualify semicolons after\n+// closures within parentheses *in macros*, where they're totally allowed.\n+\n+macro_rules! m {\n+    (($expr:expr ; )) => {\n+        $expr\n+    };\n+}\n+\n+fn main() {\n+    let x = m!(( ||() ; ));\n+}"}]}