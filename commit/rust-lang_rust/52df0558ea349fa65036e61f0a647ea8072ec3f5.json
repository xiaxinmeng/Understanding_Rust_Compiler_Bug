{"sha": "52df0558ea349fa65036e61f0a647ea8072ec3f5", "node_id": "C_kwDOAAsO6NoAKDUyZGYwNTU4ZWEzNDlmYTY1MDM2ZTYxZjBhNjQ3ZWE4MDcyZWMzZjU", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-03T06:15:23Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-05T00:41:35Z"}, "message": "Stop forcing `array::map` through an unnecessary `Result`", "tree": {"sha": "09e1c9880ea4b6787bf22e29ad262fc643ff7e35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09e1c9880ea4b6787bf22e29ad262fc643ff7e35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52df0558ea349fa65036e61f0a647ea8072ec3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52df0558ea349fa65036e61f0a647ea8072ec3f5", "html_url": "https://github.com/rust-lang/rust/commit/52df0558ea349fa65036e61f0a647ea8072ec3f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52df0558ea349fa65036e61f0a647ea8072ec3f5/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a7342c3dde43c96a71bc27995030896342761f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7342c3dde43c96a71bc27995030896342761f6", "html_url": "https://github.com/rust-lang/rust/commit/5a7342c3dde43c96a71bc27995030896342761f6"}], "stats": {"total": 131, "additions": 71, "deletions": 60}, "files": [{"sha": "45ec68e6e7aa3489d8f8a8f43893784c76998f9d", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/52df0558ea349fa65036e61f0a647ea8072ec3f5/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52df0558ea349fa65036e61f0a647ea8072ec3f5/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=52df0558ea349fa65036e61f0a647ea8072ec3f5", "patch": "@@ -825,14 +825,13 @@ impl<T, const N: usize> [T; N] {\n /// Pulls `N` items from `iter` and returns them as an array. If the iterator\n /// yields fewer than `N` items, this function exhibits undefined behavior.\n ///\n-/// See [`try_collect_into_array`] for more information.\n-///\n-///\n /// # Safety\n ///\n /// It is up to the caller to guarantee that `iter` yields at least `N` items.\n /// Violating this condition causes undefined behavior.\n-unsafe fn try_collect_into_array_unchecked<I, T, R, const N: usize>(iter: &mut I) -> R::TryType\n+unsafe fn try_collect_into_array_unchecked<I, T, R, const N: usize>(\n+    iter: &mut I,\n+) -> ChangeOutputType<I::Item, [T; N]>\n where\n     // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n     // internal function, so feel free to remove if this bound turns out to be a\n@@ -845,11 +844,21 @@ where\n     debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n     debug_assert!(N <= iter.size_hint().0);\n \n-    // SAFETY: covered by the function contract.\n-    unsafe { try_collect_into_array(iter).unwrap_unchecked() }\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    let cf = try_collect_into_array_erased(iter, &mut array);\n+    match cf {\n+        ControlFlow::Break(r) => FromResidual::from_residual(r),\n+        ControlFlow::Continue(initialized) => {\n+            debug_assert_eq!(initialized, N);\n+            // SAFETY: because of our function contract, all the elements\n+            // must have been initialized.\n+            let output = unsafe { MaybeUninit::array_assume_init(array) };\n+            Try::from_output(output)\n+        }\n+    }\n }\n \n-// Infallible version of `try_collect_into_array_unchecked`.\n+/// Infallible version of [`try_collect_into_array_unchecked`].\n unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n where\n     I: Iterator + TrustedLen,\n@@ -864,63 +873,48 @@ where\n     }\n }\n \n-/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n-/// yields fewer than `N` items, `Err` is returned containing an iterator over\n-/// the already yielded items.\n+/// Rather than *returning* the array, this fills in a passed-in buffer.\n+/// If any of the iterator elements short-circuit, it drops everything in the\n+/// buffer and return the error.  Otherwise it returns the number of items\n+/// which were initialized in the buffer.\n ///\n-/// Since the iterator is passed as a mutable reference and this function calls\n-/// `next` at most `N` times, the iterator can still be used afterwards to\n-/// retrieve the remaining items.\n+/// (The caller is responsible for dropping those items on success, but not\n+/// doing that is just a leak, not UB, so this function is itself safe.)\n ///\n-/// If `iter.next()` panicks, all items already yielded by the iterator are\n-/// dropped.\n+/// This means less monomorphization, but more importantly it means that the\n+/// returned array doesn't need to be copied into the `Result`, since returning\n+/// the result seemed (2023-01) to cause in an extra `N + 1`-length `alloca`\n+/// even if it's always `unwrap_unchecked` later.\n #[inline]\n-fn try_collect_into_array<I, T, R, const N: usize>(\n+fn try_collect_into_array_erased<I, T, R>(\n     iter: &mut I,\n-) -> Result<R::TryType, IntoIter<T, N>>\n+    buffer: &mut [MaybeUninit<T>],\n+) -> ControlFlow<R, usize>\n where\n     I: Iterator,\n     I::Item: Try<Output = T, Residual = R>,\n-    R: Residual<[T; N]>,\n {\n-    if N == 0 {\n-        // SAFETY: An empty array is always inhabited and has no validity invariants.\n-        return Ok(Try::from_output(unsafe { mem::zeroed() }));\n-    }\n-\n-    let mut array = MaybeUninit::uninit_array::<N>();\n-    let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n+    let n = buffer.len();\n+    let mut guard = Guard { array_mut: buffer, initialized: 0 };\n \n-    for _ in 0..N {\n+    for _ in 0..n {\n         match iter.next() {\n             Some(item_rslt) => {\n-                let item = match item_rslt.branch() {\n-                    ControlFlow::Break(r) => {\n-                        return Ok(FromResidual::from_residual(r));\n-                    }\n-                    ControlFlow::Continue(elem) => elem,\n-                };\n+                let item = item_rslt.branch()?;\n \n                 // SAFETY: `guard.initialized` starts at 0, which means push can be called\n-                // at most N times, which this loop does.\n+                // at most `n` times, which this loop does.\n                 unsafe {\n                     guard.push_unchecked(item);\n                 }\n             }\n-            None => {\n-                let alive = 0..guard.initialized;\n-                mem::forget(guard);\n-                // SAFETY: `array` was initialized with exactly `initialized`\n-                // number of elements.\n-                return Err(unsafe { IntoIter::new_unchecked(array, alive) });\n-            }\n+            None => break,\n         }\n     }\n \n+    let initialized = guard.initialized;\n     mem::forget(guard);\n-    // SAFETY: All elements of the array were populated in the loop above.\n-    let output = unsafe { array.transpose().assume_init() };\n-    Ok(Try::from_output(output))\n+    ControlFlow::Continue(initialized)\n }\n \n /// Panic guard for incremental initialization of arrays.\n@@ -934,14 +928,14 @@ where\n ///\n /// To minimize indirection fields are still pub but callers should at least use\n /// `push_unchecked` to signal that something unsafe is going on.\n-pub(crate) struct Guard<'a, T, const N: usize> {\n+pub(crate) struct Guard<'a, T> {\n     /// The array to be initialized.\n-    pub array_mut: &'a mut [MaybeUninit<T>; N],\n+    pub array_mut: &'a mut [MaybeUninit<T>],\n     /// The number of items that have been initialized so far.\n     pub initialized: usize,\n }\n \n-impl<T, const N: usize> Guard<'_, T, N> {\n+impl<T> Guard<'_, T> {\n     /// Adds an item to the array and updates the initialized item counter.\n     ///\n     /// # Safety\n@@ -959,9 +953,9 @@ impl<T, const N: usize> Guard<'_, T, N> {\n     }\n }\n \n-impl<T, const N: usize> Drop for Guard<'_, T, N> {\n+impl<T> Drop for Guard<'_, T> {\n     fn drop(&mut self) {\n-        debug_assert!(self.initialized <= N);\n+        debug_assert!(self.initialized <= self.array_mut.len());\n \n         // SAFETY: this slice will contain only initialized objects.\n         unsafe {\n@@ -972,15 +966,33 @@ impl<T, const N: usize> Drop for Guard<'_, T, N> {\n     }\n }\n \n-/// Returns the next chunk of `N` items from the iterator or errors with an\n-/// iterator over the remainder. Used for `Iterator::next_chunk`.\n+/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n+/// yields fewer than `N` items, `Err` is returned containing an iterator over\n+/// the already yielded items.\n+///\n+/// Since the iterator is passed as a mutable reference and this function calls\n+/// `next` at most `N` times, the iterator can still be used afterwards to\n+/// retrieve the remaining items.\n+///\n+/// If `iter.next()` panicks, all items already yielded by the iterator are\n+/// dropped.\n+///\n+/// Used for [`Iterator::next_chunk`].\n #[inline]\n-pub(crate) fn iter_next_chunk<I, const N: usize>(\n-    iter: &mut I,\n-) -> Result<[I::Item; N], IntoIter<I::Item, N>>\n-where\n-    I: Iterator,\n-{\n+pub(crate) fn iter_next_chunk<T, const N: usize>(\n+    iter: &mut impl Iterator<Item = T>,\n+) -> Result<[T; N], IntoIter<T, N>> {\n     let mut map = iter.map(NeverShortCircuit);\n-    try_collect_into_array(&mut map).map(|NeverShortCircuit(arr)| arr)\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    let ControlFlow::Continue(initialized) = try_collect_into_array_erased(&mut map, &mut array);\n+    if initialized == N {\n+        // SAFETY: All elements of the array were populated.\n+        let output = unsafe { MaybeUninit::array_assume_init(array) };\n+        Ok(output)\n+    } else {\n+        let alive = 0..initialized;\n+        // SAFETY: `array` was initialized with exactly `initialized`\n+        // number of elements.\n+        return Err(unsafe { IntoIter::new_unchecked(array, alive) });\n+    }\n }"}, {"sha": "1154659eea5411827f64c781280bafbe8992a430", "filename": "tests/codegen/array-map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52df0558ea349fa65036e61f0a647ea8072ec3f5/tests%2Fcodegen%2Farray-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52df0558ea349fa65036e61f0a647ea8072ec3f5/tests%2Fcodegen%2Farray-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-map.rs?ref=52df0558ea349fa65036e61f0a647ea8072ec3f5", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -C opt-level=3 -C target-cpu=x86-64-v3 -C llvm-args=-x86-asm-syntax=intel --emit=llvm-ir,asm\n+// compile-flags: -C opt-level=3 -C target-cpu=x86-64-v3\n // no-system-llvm\n // only-x86_64\n // ignore-debug (the extra assertions get in the way)\n@@ -40,8 +40,7 @@ pub fn short_integer_zip_map(x: [u32; 8], y: [u32; 8]) -> [u32; 8] {\n #[no_mangle]\n pub fn long_integer_map(x: [u32; 64]) -> [u32; 64] {\n     // CHECK: start:\n-    // CHECK-NEXT: alloca [{{64|65}} x i32]\n-    // CHECK-NEXT: alloca [{{64|65}} x i32]\n+    // CHECK-NEXT: alloca [64 x i32]\n     // CHECK-NEXT: alloca %\"core::mem::manually_drop::ManuallyDrop<[u32; 64]>\"\n     // CHECK-NOT: alloca\n     x.map(|x| 2 * x + 1)"}]}