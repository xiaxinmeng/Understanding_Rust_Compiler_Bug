{"sha": "28759b242d23e43b6d85714c18733120229e0881", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NzU5YjI0MmQyM2U0M2I2ZDg1NzE0YzE4NzMzMTIwMjI5ZTA4ODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-13T15:31:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-13T15:31:14Z"}, "message": "Auto merge of #6865 - Jarcho:explicit_deref_methods, r=llogiq\n\n`explicit_deref_methods` improvements\n\nBreaking up #6837\n\nchangelog: `explicit_deref_methods` will lint chained `deref` calls and ufcs style calls", "tree": {"sha": "00379039b67947a0b8c429ec2346bfb3c17200de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00379039b67947a0b8c429ec2346bfb3c17200de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28759b242d23e43b6d85714c18733120229e0881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28759b242d23e43b6d85714c18733120229e0881", "html_url": "https://github.com/rust-lang/rust/commit/28759b242d23e43b6d85714c18733120229e0881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28759b242d23e43b6d85714c18733120229e0881/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d046c9addea00de5b7cc0e33cffdec465dade8", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d046c9addea00de5b7cc0e33cffdec465dade8", "html_url": "https://github.com/rust-lang/rust/commit/65d046c9addea00de5b7cc0e33cffdec465dade8"}, {"sha": "2713ad43425bef040e3c7d55618d18035fe68c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2713ad43425bef040e3c7d55618d18035fe68c1a", "html_url": "https://github.com/rust-lang/rust/commit/2713ad43425bef040e3c7d55618d18035fe68c1a"}], "stats": {"total": 569, "additions": 402, "deletions": 167}, "files": [{"sha": "40ed6d8d1541e09bf9dc414bc658aabd641b2a9e", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 254, "deletions": 65, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -1,11 +1,11 @@\n-use crate::utils::{get_parent_expr, implements_trait, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX, PREC_PREFIX};\n+use crate::utils::{get_parent_node, in_macro, is_allowed, peel_mid_ty_refs, snippet_with_context, span_lint_and_sugg};\n+use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, MatchSource, Mutability, Node, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TyS, TypeckResults};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit `deref()` or `deref_mut()` method calls.\n@@ -34,76 +34,265 @@ declare_clippy_lint! {\n     \"Explicit use of deref or deref_mut method while not in a method chain.\"\n }\n \n-declare_lint_pass!(Dereferencing => [\n-    EXPLICIT_DEREF_METHODS\n+impl_lint_pass!(Dereferencing => [\n+    EXPLICIT_DEREF_METHODS,\n ]);\n \n+#[derive(Default)]\n+pub struct Dereferencing {\n+    state: Option<(State, StateData)>,\n+\n+    // While parsing a `deref` method call in ufcs form, the path to the function is itself an\n+    // expression. This is to store the id of that expression so it can be skipped when\n+    // `check_expr` is called for it.\n+    skip_expr: Option<HirId>,\n+}\n+\n+struct StateData {\n+    /// Span of the top level expression\n+    span: Span,\n+    /// The required mutability\n+    target_mut: Mutability,\n+}\n+\n+enum State {\n+    // Any number of deref method calls.\n+    DerefMethod {\n+        // The number of calls in a sequence which changed the referenced type\n+        ty_changed_count: usize,\n+        is_final_ufcs: bool,\n+    },\n+}\n+\n+// A reference operation considered by this lint pass\n+enum RefOp {\n+    Method(Mutability),\n+    Deref,\n+    AddrOf,\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if !expr.span.from_expansion();\n-            if let ExprKind::MethodCall(ref method_name, _, ref args, _) = &expr.kind;\n-            if args.len() == 1;\n-\n-            then {\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    // Check if we have the whole call chain here\n-                    if let ExprKind::MethodCall(..) = parent_expr.kind {\n-                        return;\n-                    }\n-                    // Check for Expr that we don't want to be linted\n-                    let precedence = parent_expr.precedence();\n-                    match precedence {\n-                        // Lint a Call is ok though\n-                        ExprPrecedence::Call | ExprPrecedence::AddrOf => (),\n-                        _ => {\n-                            if precedence.order() >= PREC_PREFIX && precedence.order() <= PREC_POSTFIX {\n-                                return;\n-                            }\n-                        }\n+        // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n+        if Some(expr.hir_id) == self.skip_expr.take() {\n+            return;\n+        }\n+\n+        // Stop processing sub expressions when a macro call is seen\n+        if in_macro(expr.span) {\n+            if let Some((state, data)) = self.state.take() {\n+                report(cx, expr, state, data);\n+            }\n+            return;\n+        }\n+\n+        let typeck = cx.typeck_results();\n+        let (kind, sub_expr) = if let Some(x) = try_parse_ref_op(cx.tcx, typeck, expr) {\n+            x\n+        } else {\n+            // The whole chain of reference operations has been seen\n+            if let Some((state, data)) = self.state.take() {\n+                report(cx, expr, state, data);\n+            }\n+            return;\n+        };\n+\n+        match (self.state.take(), kind) {\n+            (None, kind) => {\n+                let parent = get_parent_node(cx.tcx, expr.hir_id);\n+                let expr_ty = typeck.expr_ty(expr);\n+\n+                match kind {\n+                    RefOp::Method(target_mut)\n+                        if !is_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n+                            && is_linted_explicit_deref_position(parent, expr.hir_id, expr.span) =>\n+                    {\n+                        self.state = Some((\n+                            State::DerefMethod {\n+                                ty_changed_count: if deref_method_same_type(expr_ty, typeck.expr_ty(sub_expr)) {\n+                                    0\n+                                } else {\n+                                    1\n+                                },\n+                                is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n+                            },\n+                            StateData {\n+                                span: expr.span,\n+                                target_mut,\n+                            },\n+                        ));\n                     }\n+                    _ => (),\n                 }\n-                let name = method_name.ident.as_str();\n-                lint_deref(cx, &*name, &args[0], args[0].span, expr.span);\n-            }\n+            },\n+            (Some((State::DerefMethod { ty_changed_count, .. }, data)), RefOp::Method(_)) => {\n+                self.state = Some((\n+                    State::DerefMethod {\n+                        ty_changed_count: if deref_method_same_type(typeck.expr_ty(expr), typeck.expr_ty(sub_expr)) {\n+                            ty_changed_count\n+                        } else {\n+                            ty_changed_count + 1\n+                        },\n+                        is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n+                    },\n+                    data,\n+                ));\n+            },\n+\n+            (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n     }\n }\n \n-fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n-    match method_name {\n-        \"deref\" => {\n-            let impls_deref_trait = cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n-            });\n-            if impls_deref_trait {\n-                span_lint_and_sugg(\n-                    cx,\n-                    EXPLICIT_DEREF_METHODS,\n-                    expr_span,\n-                    \"explicit deref method call\",\n-                    \"try this\",\n-                    format!(\"&*{}\", &snippet(cx, var_span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+fn try_parse_ref_op(\n+    tcx: TyCtxt<'tcx>,\n+    typeck: &'tcx TypeckResults<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<(RefOp, &'tcx Expr<'tcx>)> {\n+    let (def_id, arg) = match expr.kind {\n+        ExprKind::MethodCall(_, _, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(path),\n+                hir_id,\n+                ..\n+            },\n+            [arg],\n+        ) => (typeck.qpath_res(path, *hir_id).opt_def_id()?, arg),\n+        ExprKind::Unary(UnOp::Deref, sub_expr) if !typeck.expr_ty(sub_expr).is_unsafe_ptr() => {\n+            return Some((RefOp::Deref, sub_expr));\n         },\n-        \"deref_mut\" => {\n-            let impls_deref_mut_trait = cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n-            });\n-            if impls_deref_mut_trait {\n-                span_lint_and_sugg(\n-                    cx,\n-                    EXPLICIT_DEREF_METHODS,\n-                    expr_span,\n-                    \"explicit deref_mut method call\",\n-                    \"try this\",\n-                    format!(\"&mut *{}\", &snippet(cx, var_span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+        ExprKind::AddrOf(BorrowKind::Ref, _, sub_expr) => return Some((RefOp::AddrOf, sub_expr)),\n+        _ => return None,\n+    };\n+    if tcx.is_diagnostic_item(sym::deref_method, def_id) {\n+        Some((RefOp::Method(Mutability::Not), arg))\n+    } else if tcx.trait_of_item(def_id)? == tcx.lang_items().deref_mut_trait()? {\n+        Some((RefOp::Method(Mutability::Mut), arg))\n+    } else {\n+        None\n+    }\n+}\n+\n+// Checks whether the type for a deref call actually changed the type, not just the mutability of\n+// the reference.\n+fn deref_method_same_type(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n+    match (result_ty.kind(), arg_ty.kind()) {\n+        (ty::Ref(_, result_ty, _), ty::Ref(_, arg_ty, _)) => TyS::same_type(result_ty, arg_ty),\n+\n+        // The result type for a deref method is always a reference\n+        // Not matching the previous pattern means the argument type is not a reference\n+        // This means that the type did change\n+        _ => false,\n+    }\n+}\n+\n+// Checks whether the parent node is a suitable context for switching from a deref method to the\n+// deref operator.\n+fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId, child_span: Span) -> bool {\n+    let parent = match parent {\n+        Some(Node::Expr(e)) if e.span.ctxt() == child_span.ctxt() => e,\n+        _ => return true,\n+    };\n+    match parent.kind {\n+        // Leave deref calls in the middle of a method chain.\n+        // e.g. x.deref().foo()\n+        ExprKind::MethodCall(_, _, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n+\n+        // Leave deref calls resulting in a called function\n+        // e.g. (x.deref())()\n+        ExprKind::Call(func_expr, _) if func_expr.hir_id == child_id => false,\n+\n+        // Makes an ugly suggestion\n+        // e.g. *x.deref() => *&*x\n+        ExprKind::Unary(UnOp::Deref, _)\n+        // Postfix expressions would require parens\n+        | ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+        | ExprKind::Field(..)\n+        | ExprKind::Index(..)\n+        | ExprKind::Err => false,\n+\n+        ExprKind::Box(..)\n+        | ExprKind::ConstBlock(..)\n+        | ExprKind::Array(_)\n+        | ExprKind::Call(..)\n+        | ExprKind::MethodCall(..)\n+        | ExprKind::Tup(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Lit(..)\n+        | ExprKind::Cast(..)\n+        | ExprKind::Type(..)\n+        | ExprKind::DropTemps(..)\n+        | ExprKind::If(..)\n+        | ExprKind::Loop(..)\n+        | ExprKind::Match(..)\n+        | ExprKind::Closure(..)\n+        | ExprKind::Block(..)\n+        | ExprKind::Assign(..)\n+        | ExprKind::AssignOp(..)\n+        | ExprKind::Path(..)\n+        | ExprKind::AddrOf(..)\n+        | ExprKind::Break(..)\n+        | ExprKind::Continue(..)\n+        | ExprKind::Ret(..)\n+        | ExprKind::InlineAsm(..)\n+        | ExprKind::LlvmInlineAsm(..)\n+        | ExprKind::Struct(..)\n+        | ExprKind::Repeat(..)\n+        | ExprKind::Yield(..) => true,\n+    }\n+}\n+\n+#[allow(clippy::needless_pass_by_value)]\n+fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n+    match state {\n+        State::DerefMethod {\n+            ty_changed_count,\n+            is_final_ufcs,\n+        } => {\n+            let mut app = Applicability::MachineApplicable;\n+            let (expr_str, expr_is_macro_call) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            let ty = cx.typeck_results().expr_ty(expr);\n+            let (_, ref_count) = peel_mid_ty_refs(ty);\n+            let deref_str = if ty_changed_count >= ref_count && ref_count != 0 {\n+                // a deref call changing &T -> &U requires two deref operators the first time\n+                // this occurs. One to remove the reference, a second to call the deref impl.\n+                \"*\".repeat(ty_changed_count + 1)\n+            } else {\n+                \"*\".repeat(ty_changed_count)\n+            };\n+            let addr_of_str = if ty_changed_count < ref_count {\n+                // Check if a reborrow from &mut T -> &T is required.\n+                if data.target_mut == Mutability::Not && matches!(ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    \"&*\"\n+                } else {\n+                    \"\"\n+                }\n+            } else if data.target_mut == Mutability::Mut {\n+                \"&mut \"\n+            } else {\n+                \"&\"\n+            };\n+\n+            let expr_str = if !expr_is_macro_call && is_final_ufcs && expr.precedence().order() < PREC_PREFIX {\n+                format!(\"({})\", expr_str)\n+            } else {\n+                expr_str.into_owned()\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                EXPLICIT_DEREF_METHODS,\n+                data.span,\n+                match data.target_mut {\n+                    Mutability::Not => \"explicit `deref` method call\",\n+                    Mutability::Mut => \"explicit `deref_mut` method call\",\n+                },\n+                \"try this\",\n+                format!(\"{}{}{}\", addr_of_str, deref_str, expr_str),\n+                app,\n+            );\n         },\n-        _ => (),\n     }\n }"}, {"sha": "bf5688aa95c8b943a47f70f0e26055702b7e6461", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -1241,7 +1241,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n-    store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box dereference::Dereferencing::default());\n     store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);"}, {"sha": "ea4cedc67545b725ad622fb917fe3fcb32e2786f", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -129,7 +129,7 @@ impl LateLintPass<'_> for ManualMap {\n             // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n             // it's being passed by value.\n             let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let scrutinee_str = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+            let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n             let scrutinee_str =\n                 if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n                     format!(\"({})\", scrutinee_str)\n@@ -160,16 +160,16 @@ impl LateLintPass<'_> for ManualMap {\n                             \"|{}{}| {}\",\n                             annotation,\n                             some_binding,\n-                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n                         )\n                     },\n                 }\n             } else if !is_wild_none && explicit_ref.is_none() {\n                 // TODO: handle explicit reference annotations.\n                 format!(\n                     \"|{}| {}\",\n-                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app),\n-                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n                 )\n             } else {\n                 // Refutable bindings and mixed reference annotations can't be handled by `map`."}, {"sha": "2ac2298ff7497eba9bc3ce69e044f27a16405273", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -61,11 +61,11 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::Node;\n use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, Item,\n-    ItemKind, LangItem, MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef,\n-    TyKind, Unsafety,\n+    def, Arm, Block, Body, Constness, CrateItem, Expr, ExprKind, FnDecl, ForeignItem, GenericArgs, GenericParam, HirId,\n+    Impl, ImplItem, ImplItemKind, Item, ItemKind, LangItem, Lifetime, Local, MacroDef, MatchSource, Node, Param, Pat,\n+    PatKind, Path, PathSegment, QPath, Stmt, StructField, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n+    Variant, Visibility,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -78,7 +78,7 @@ use rustc_session::Session;\n use rustc_span::hygiene::{self, ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{BytePos, Pos, Span, SyntaxContext, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -852,26 +852,31 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n /// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR node\n /// would result in `box []`. If given the context of the address of expression, this function will\n /// correctly get a snippet of `vec![]`.\n+///\n+/// This will also return whether or not the snippet is a macro call.\n pub fn snippet_with_context(\n     cx: &LateContext<'_>,\n     span: Span,\n     outer: SyntaxContext,\n     default: &'a str,\n     applicability: &mut Applicability,\n-) -> Cow<'a, str> {\n+) -> (Cow<'a, str>, bool) {\n     let outer_span = hygiene::walk_chain(span, outer);\n-    let span = if outer_span.ctxt() == outer {\n-        outer_span\n+    let (span, is_macro_call) = if outer_span.ctxt() == outer {\n+        (outer_span, span.ctxt() != outer)\n     } else {\n         // The span is from a macro argument, and the outer context is the macro using the argument\n         if *applicability != Applicability::Unspecified {\n             *applicability = Applicability::MaybeIncorrect;\n         }\n         // TODO: get the argument span.\n-        span\n+        (span, false)\n     };\n \n-    snippet_with_applicability(cx, span, default, applicability)\n+    (\n+        snippet_with_applicability(cx, span, default, applicability),\n+        is_macro_call,\n+    )\n }\n \n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n@@ -1013,21 +1018,52 @@ fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>,\n         .join(\"\\n\")\n }\n \n+/// Gets the span of the node, if there is one.\n+pub fn get_node_span(node: Node<'_>) -> Option<Span> {\n+    match node {\n+        Node::Param(Param { span, .. })\n+        | Node::Item(Item { span, .. })\n+        | Node::ForeignItem(ForeignItem { span, .. })\n+        | Node::TraitItem(TraitItem { span, .. })\n+        | Node::ImplItem(ImplItem { span, .. })\n+        | Node::Variant(Variant { span, .. })\n+        | Node::Field(StructField { span, .. })\n+        | Node::Expr(Expr { span, .. })\n+        | Node::Stmt(Stmt { span, .. })\n+        | Node::PathSegment(PathSegment {\n+            ident: Ident { span, .. },\n+            ..\n+        })\n+        | Node::Ty(hir::Ty { span, .. })\n+        | Node::TraitRef(TraitRef {\n+            path: Path { span, .. },\n+            ..\n+        })\n+        | Node::Binding(Pat { span, .. })\n+        | Node::Pat(Pat { span, .. })\n+        | Node::Arm(Arm { span, .. })\n+        | Node::Block(Block { span, .. })\n+        | Node::Local(Local { span, .. })\n+        | Node::MacroDef(MacroDef { span, .. })\n+        | Node::Lifetime(Lifetime { span, .. })\n+        | Node::GenericParam(GenericParam { span, .. })\n+        | Node::Visibility(Visibility { span, .. })\n+        | Node::Crate(CrateItem { span, .. }) => Some(*span),\n+        Node::Ctor(_) | Node::AnonConst(_) => None,\n+    }\n+}\n+\n+/// Gets the parent node, if any.\n+pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n+    tcx.hir().parent_iter(id).next().map(|(_, node)| node)\n+}\n+\n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    let map = &cx.tcx.hir();\n-    let hir_id = e.hir_id;\n-    let parent_id = map.get_parent_node(hir_id);\n-    if hir_id == parent_id {\n-        return None;\n-    }\n-    map.find(parent_id).and_then(|node| {\n-        if let Node::Expr(parent) = node {\n-            Some(parent)\n-        } else {\n-            None\n-        }\n-    })\n+    match get_parent_node(cx.tcx, e.hir_id) {\n+        Some(Node::Expr(parent)) => Some(parent),\n+        _ => None,\n+    }\n }\n \n pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {"}, {"sha": "d26b462a4336236b79472bc5dd8b001f99c08473", "filename": "tests/ui/dereference.stderr", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/65d046c9addea00de5b7cc0e33cffdec465dade8/tests%2Fui%2Fdereference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65d046c9addea00de5b7cc0e33cffdec465dade8/tests%2Fui%2Fdereference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdereference.stderr?ref=65d046c9addea00de5b7cc0e33cffdec465dade8", "patch": "@@ -1,70 +0,0 @@\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:30:19\n-   |\n-LL |     let b: &str = a.deref();\n-   |                   ^^^^^^^^^ help: try this: `&*a`\n-   |\n-   = note: `-D clippy::explicit-deref-methods` implied by `-D warnings`\n-\n-error: explicit deref_mut method call\n-  --> $DIR/dereference.rs:32:23\n-   |\n-LL |     let b: &mut str = a.deref_mut();\n-   |                       ^^^^^^^^^^^^^ help: try this: `&mut *a`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:35:39\n-   |\n-LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n-   |                                       ^^^^^^^^^ help: try this: `&*a`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:35:50\n-   |\n-LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n-   |                                                  ^^^^^^^^^ help: try this: `&*a`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:37:20\n-   |\n-LL |     println!(\"{}\", a.deref());\n-   |                    ^^^^^^^^^ help: try this: `&*a`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:40:11\n-   |\n-LL |     match a.deref() {\n-   |           ^^^^^^^^^ help: try this: `&*a`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:44:28\n-   |\n-LL |     let b: String = concat(a.deref());\n-   |                            ^^^^^^^^^ help: try this: `&*a`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:46:13\n-   |\n-LL |     let b = just_return(a).deref();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*just_return(a)`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:48:28\n-   |\n-LL |     let b: String = concat(just_return(a).deref());\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*just_return(a)`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:50:19\n-   |\n-LL |     let b: &str = a.deref().deref();\n-   |                   ^^^^^^^^^^^^^^^^^ help: try this: `&*a.deref()`\n-\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:53:13\n-   |\n-LL |     let b = opt_a.unwrap().deref();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*opt_a.unwrap()`\n-\n-error: aborting due to 11 previous errors\n-"}, {"sha": "51d0468e47ca41392103bb164d31ebf005e04154", "filename": "tests/ui/explicit_deref_methods.fixed", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/tests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/tests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.fixed?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -29,7 +29,7 @@ fn main() {\n \n     let b: &str = &*a;\n \n-    let b: &mut str = &mut *a;\n+    let b: &mut str = &mut **a;\n \n     // both derefs should get linted here\n     let b: String = format!(\"{}, {}\", &*a, &*a);\n@@ -43,11 +43,11 @@ fn main() {\n \n     let b: String = concat(&*a);\n \n-    let b = &*just_return(a);\n+    let b = just_return(a);\n \n-    let b: String = concat(&*just_return(a));\n+    let b: String = concat(just_return(a));\n \n-    let b: &str = &*a.deref();\n+    let b: &str = &**a;\n \n     let opt_a = Some(a.clone());\n     let b = &*opt_a.unwrap();\n@@ -76,6 +76,8 @@ fn main() {\n     }\n     let b: &str = expr_deref!(a);\n \n+    let b: &str = expr_deref!(&*a);\n+\n     // The struct does not implement Deref trait\n     #[derive(Copy, Clone)]\n     struct NoLint(u32);", "previous_filename": "tests/ui/dereference.fixed"}, {"sha": "680664bd4f6f26ac3facdd7efa2f10cd5e12c948", "filename": "tests/ui/explicit_deref_methods.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/tests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/tests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.rs?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -76,6 +76,8 @@ fn main() {\n     }\n     let b: &str = expr_deref!(a);\n \n+    let b: &str = expr_deref!(a.deref());\n+\n     // The struct does not implement Deref trait\n     #[derive(Copy, Clone)]\n     struct NoLint(u32);", "previous_filename": "tests/ui/dereference.rs"}, {"sha": "8035d77d18d5c8c333dfae8fc96bef73d371d476", "filename": "tests/ui/explicit_deref_methods.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/28759b242d23e43b6d85714c18733120229e0881/tests%2Fui%2Fexplicit_deref_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28759b242d23e43b6d85714c18733120229e0881/tests%2Fui%2Fexplicit_deref_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.stderr?ref=28759b242d23e43b6d85714c18733120229e0881", "patch": "@@ -0,0 +1,76 @@\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:30:19\n+   |\n+LL |     let b: &str = a.deref();\n+   |                   ^^^^^^^^^ help: try this: `&*a`\n+   |\n+   = note: `-D clippy::explicit-deref-methods` implied by `-D warnings`\n+\n+error: explicit `deref_mut` method call\n+  --> $DIR/explicit_deref_methods.rs:32:23\n+   |\n+LL |     let b: &mut str = a.deref_mut();\n+   |                       ^^^^^^^^^^^^^ help: try this: `&mut **a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:35:39\n+   |\n+LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n+   |                                       ^^^^^^^^^ help: try this: `&*a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:35:50\n+   |\n+LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n+   |                                                  ^^^^^^^^^ help: try this: `&*a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:37:20\n+   |\n+LL |     println!(\"{}\", a.deref());\n+   |                    ^^^^^^^^^ help: try this: `&*a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:40:11\n+   |\n+LL |     match a.deref() {\n+   |           ^^^^^^^^^ help: try this: `&*a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:44:28\n+   |\n+LL |     let b: String = concat(a.deref());\n+   |                            ^^^^^^^^^ help: try this: `&*a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:46:13\n+   |\n+LL |     let b = just_return(a).deref();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:48:28\n+   |\n+LL |     let b: String = concat(just_return(a).deref());\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:50:19\n+   |\n+LL |     let b: &str = a.deref().deref();\n+   |                   ^^^^^^^^^^^^^^^^^ help: try this: `&**a`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:53:13\n+   |\n+LL |     let b = opt_a.unwrap().deref();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*opt_a.unwrap()`\n+\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:79:31\n+   |\n+LL |     let b: &str = expr_deref!(a.deref());\n+   |                               ^^^^^^^^^ help: try this: `&*a`\n+\n+error: aborting due to 12 previous errors\n+"}]}