{"sha": "d7edf66a5a92f66672bc9e84d58db170b3ea2d9a", "node_id": "C_kwDOAAsO6NoAKGQ3ZWRmNjZhNWE5MmY2NjY3MmJjOWU4NGQ1OGRiMTcwYjNlYTJkOWE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T02:55:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T02:55:25Z"}, "message": "move Box mess handling into general visitor", "tree": {"sha": "fc6862db63204788e05ebd9481898acdc781b8f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc6862db63204788e05ebd9481898acdc781b8f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a", "html_url": "https://github.com/rust-lang/rust/commit/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fc77806d4f66819cf9d7ebd53a3338686c08b7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fc77806d4f66819cf9d7ebd53a3338686c08b7d", "html_url": "https://github.com/rust-lang/rust/commit/7fc77806d4f66819cf9d7ebd53a3338686c08b7d"}], "stats": {"total": 89, "additions": 55, "deletions": 34}, "files": [{"sha": "0bf78446e37fa0ff27573433cc9bac121a27337b", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d7edf66a5a92f66672bc9e84d58db170b3ea2d9a", "patch": "@@ -593,38 +593,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 self.check_safe_pointer(value, \"reference\")?;\n                 Ok(true)\n             }\n-            ty::Adt(def, ..) if def.is_box() => {\n-                // Box is special, very special. We carefully assert all the assumptions we make\n-                // here; if this needs to be adjusted, remember to also adjust all the other\n-                // visitors -- in particular the Stacked Borrows retagging visitor in Miri.\n-                // Did I mention that this is a gross hack? Anyway...\n-\n-                // `Box` has two fields: the pointer we care about, and the allocator.\n-                assert_eq!(value.layout.fields.count(), 2, \"`Box` must have exactly 2 fields\");\n-                let (unique_ptr, alloc) =\n-                    (self.ecx.operand_field(value, 0)?, self.ecx.operand_field(value, 1)?);\n-                // Unfortunately there is some type junk in the way here: `unique_ptr` is a `Unique`...\n-                // (which means another 2 fields, the second of which is a `PhantomData`)\n-                assert_eq!(unique_ptr.layout.fields.count(), 2);\n-                let (nonnull_ptr, phantom) = (\n-                    self.ecx.operand_field(&unique_ptr, 0)?,\n-                    self.ecx.operand_field(&unique_ptr, 1)?,\n-                );\n-                assert!(\n-                    phantom.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_phantom_data()),\n-                    \"2nd field of `Unique` should be PhantomData but is {:?}\",\n-                    phantom.layout.ty,\n-                );\n-                // ... that contains a `NonNull`... (gladly, only a single field here)\n-                assert_eq!(nonnull_ptr.layout.fields.count(), 1);\n-                let raw_ptr = self.ecx.operand_field(&nonnull_ptr, 0)?; // the actual raw ptr\n-                // ... whose only field finally is a raw ptr we can dereference.\n-                self.check_safe_pointer(&raw_ptr, \"box\")?;\n-                // The second `Box` field is the allocator, which we recursively check for validity\n-                // like in regular structs.\n-                self.walk_value(&alloc)?;\n-                Ok(true)\n-            }\n             ty::FnPtr(_sig) => {\n                 let value = try_validation!(\n                     self.ecx.read_scalar(value).and_then(|v| v.check_init()),\n@@ -835,6 +803,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         Ok(())\n     }\n \n+    #[inline]\n+    fn visit_box(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        self.check_safe_pointer(op, \"box\")?;\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n@@ -843,8 +817,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         if self.try_visit_primitive(op)? {\n             return Ok(());\n         }\n-        // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n-        assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Special check preventing `UnsafeCell` in the inner part of constants\n         if let Some(def) = op.layout.ty.ty_adt_def() {"}, {"sha": "ded4c6a557a402e77849078c053e1819502ebab3", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7edf66a5a92f66672bc9e84d58db170b3ea2d9a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=d7edf66a5a92f66672bc9e84d58db170b3ea2d9a", "patch": "@@ -151,6 +151,14 @@ macro_rules! make_value_visitor {\n             {\n                 Ok(())\n             }\n+            /// Visits the given value as the pointer of a `Box`. There is nothing to recurse into.\n+            /// The type of `v` will be a raw pointer, but this is a field of `Box<T>` and the\n+            /// pointee type is the actual `T`.\n+            #[inline(always)]\n+            fn visit_box(&mut self, _v: &Self::V) -> InterpResult<'tcx>\n+            {\n+                Ok(())\n+            }\n             /// Visits this value as an aggregate, you are getting an iterator yielding\n             /// all the fields (still in an `InterpResult`, you have to do error handling yourself).\n             /// Recurses into the fields.\n@@ -221,6 +229,47 @@ macro_rules! make_value_visitor {\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n                     // indirectly uses the metadata to determine the actual length.\n+\n+                    // However, `Box`... let's talk about `Box`.\n+                    ty::Adt(def, ..) if def.is_box() => {\n+                        // `Box` is a hybrid primitive-library-defined type that one the one hand is\n+                        // a dereferenceable pointer, on the other hand has *basically arbitrary\n+                        // user-defined layout* since the user controls the 'allocator' field. So it\n+                        // cannot be treated like a normal pointer, since it does not fit into an\n+                        // `Immediate`. Yeah, it is quite terrible. But many visitors want to do\n+                        // something with \"all boxed pointers\", so we handle this mess for them.\n+                        //\n+                        // When we hit a `Box`, we do not do the usual `visit_aggregate`; instead,\n+                        // we (a) call `visit_box` on the pointer value, and (b) recurse on the\n+                        // allocator field. We also assert tons of things to ensure we do not miss\n+                        // any other fields.\n+\n+                        // `Box` has two fields: the pointer we care about, and the allocator.\n+                        assert_eq!(v.layout().fields.count(), 2, \"`Box` must have exactly 2 fields\");\n+                        let (unique_ptr, alloc) =\n+                            (v.project_field(self.ecx(), 0)?, v.project_field(self.ecx(), 1)?);\n+                        // Unfortunately there is some type junk in the way here: `unique_ptr` is a `Unique`...\n+                        // (which means another 2 fields, the second of which is a `PhantomData`)\n+                        assert_eq!(unique_ptr.layout().fields.count(), 2);\n+                        let (nonnull_ptr, phantom) = (\n+                            unique_ptr.project_field(self.ecx(), 0)?,\n+                            unique_ptr.project_field(self.ecx(), 1)?,\n+                        );\n+                        assert!(\n+                            phantom.layout().ty.ty_adt_def().is_some_and(|adt| adt.is_phantom_data()),\n+                            \"2nd field of `Unique` should be PhantomData but is {:?}\",\n+                            phantom.layout().ty,\n+                        );\n+                        // ... that contains a `NonNull`... (gladly, only a single field here)\n+                        assert_eq!(nonnull_ptr.layout().fields.count(), 1);\n+                        let raw_ptr = nonnull_ptr.project_field(self.ecx(), 0)?; // the actual raw ptr\n+                        // ... whose only field finally is a raw ptr we can dereference.\n+                        self.visit_box(&raw_ptr)?;\n+\n+                        // The second `Box` field is the allocator, which we recursively check for validity\n+                        // like in regular structs.\n+                        self.visit_field(v, 1, &alloc)?;\n+                    }\n                     _ => {},\n                 };\n "}]}