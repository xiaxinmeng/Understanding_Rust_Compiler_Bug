{"sha": "8a6187fde1de7b209bbd2b49ea3c669006a0d154", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNjE4N2ZkZTFkZTdiMjA5YmJkMmI0OWVhM2M2NjkwMDZhMGQxNTQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-16T07:59:50Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-16T07:59:50Z"}, "message": "Refactor fields def_id and kind of Module into a single field def.\n\nChange build_reduced_graph.rs so the fields def and module of NsDef are never both Some unless the NsDef represents a duplicate definition (see issue 26421).", "tree": {"sha": "430b927ea67a00f6f5f31ee6d05bf67a1cd4570c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/430b927ea67a00f6f5f31ee6d05bf67a1cd4570c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a6187fde1de7b209bbd2b49ea3c669006a0d154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6187fde1de7b209bbd2b49ea3c669006a0d154", "html_url": "https://github.com/rust-lang/rust/commit/8a6187fde1de7b209bbd2b49ea3c669006a0d154", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a6187fde1de7b209bbd2b49ea3c669006a0d154/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceda8383c9956d1829f1e26315ad17d39323022c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceda8383c9956d1829f1e26315ad17d39323022c", "html_url": "https://github.com/rust-lang/rust/commit/ceda8383c9956d1829f1e26315ad17d39323022c"}], "stats": {"total": 310, "additions": 126, "deletions": 184}, "files": [{"sha": "b70349bfe94a10ab21d417fd345c1191da0488f9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 33, "deletions": 70, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8a6187fde1de7b209bbd2b49ea3c669006a0d154", "patch": "@@ -18,7 +18,6 @@ use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n use resolve_imports::ImportResolution;\n use Module;\n-use ModuleKind::*;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n use {names_to_string, module_to_string};\n@@ -395,8 +394,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n                     let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n+                                                              Some(DefMod(def_id)),\n                                                               false,\n                                                               true));\n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n@@ -436,13 +434,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n-                let def_id = self.ast_map.local_def_id(item.id);\n-                name_bindings.define_module(parent_link,\n-                                            Some(def_id),\n-                                            NormalModuleKind,\n-                                            false,\n-                                            is_public,\n-                                            sp);\n+                let def = DefMod(self.ast_map.local_def_id(item.id));\n+                name_bindings.define_module(parent_link, Some(def), false, is_public, sp);\n \n                 name_bindings.get_module()\n             }\n@@ -479,17 +472,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypesAndModules,\n                                                    sp);\n \n-                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false),\n-                                          sp,\n-                                          modifiers);\n-\n                 let parent_link = self.get_parent_link(parent, name);\n-                name_bindings.set_module_kind(parent_link,\n-                                              Some(self.ast_map.local_def_id(item.id)),\n-                                              TypeModuleKind,\n-                                              false,\n-                                              is_public,\n-                                              sp);\n+                let def = DefTy(self.ast_map.local_def_id(item.id), false);\n+                name_bindings.define_module(parent_link, Some(def), false, is_public, sp);\n                 parent.clone()\n             }\n \n@@ -499,17 +484,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypesAndModules,\n                                                    sp);\n \n-                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), true),\n-                                          sp,\n-                                          modifiers);\n-\n                 let parent_link = self.get_parent_link(parent, name);\n-                name_bindings.set_module_kind(parent_link,\n-                                              Some(self.ast_map.local_def_id(item.id)),\n-                                              EnumModuleKind,\n-                                              false,\n-                                              is_public,\n-                                              sp);\n+                let def = DefTy(self.ast_map.local_def_id(item.id), true);\n+                name_bindings.define_module(parent_link, Some(def), false, is_public, sp);\n \n                 let module = name_bindings.get_module();\n \n@@ -592,18 +569,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypesAndModules,\n                                                    sp);\n \n+                let def_id = self.ast_map.local_def_id(item.id);\n+\n                 // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent, name);\n-                name_bindings.define_module(parent_link,\n-                                            Some(self.ast_map.local_def_id(item.id)),\n-                                            TraitModuleKind,\n-                                            false,\n-                                            is_public,\n-                                            sp);\n+                let def = DefTrait(def_id);\n+                name_bindings.define_module(parent_link, Some(def), false, is_public, sp);\n                 let module_parent = name_bindings.get_module();\n \n-                let def_id = self.ast_map.local_def_id(item.id);\n-\n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n                     let name_bindings = self.add_child(trait_item.name,\n@@ -634,7 +607,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n                 }\n \n-                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n                 parent.clone()\n             }\n         }\n@@ -705,7 +677,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             let new_module = Rc::new(Module::new(BlockParentLink(Rc::downgrade(parent), block_id),\n                                                  None,\n-                                                 AnonymousModuleKind,\n                                                  false,\n                                                  false));\n             parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n@@ -732,37 +703,30 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n         let is_exported = is_public &&\n-                          match new_parent.def_id.get() {\n+                          match new_parent.def_id() {\n             None => true,\n             Some(did) => self.external_exports.contains(&did),\n         };\n         if is_exported {\n             self.external_exports.insert(def.def_id());\n         }\n \n-        let kind = match def {\n-            DefTy(_, true) => EnumModuleKind,\n-            DefTy(_, false) | DefStruct(..) => TypeModuleKind,\n-            _ => NormalModuleKind,\n-        };\n-\n         match def {\n-            DefMod(def_id) |\n-            DefForeignMod(def_id) |\n-            DefStruct(def_id) |\n-            DefTy(def_id, _) => {\n+            DefMod(_) |\n+            DefForeignMod(_) |\n+            DefStruct(_) |\n+            DefTy(..) => {\n                 if let Some(module_def) = child_name_bindings.type_ns.module() {\n                     debug!(\"(building reduced graph for external crate) already created module\");\n-                    module_def.def_id.set(Some(def_id));\n+                    module_def.def.set(Some(def));\n                 } else {\n                     debug!(\"(building reduced graph for external crate) building module {} {}\",\n                            final_ident,\n                            is_public);\n                     let parent_link = self.get_parent_link(new_parent, name);\n \n                     child_name_bindings.define_module(parent_link,\n-                                                      Some(def_id),\n-                                                      kind,\n+                                                      Some(def),\n                                                       true,\n                                                       is_public,\n                                                       DUMMY_SP);\n@@ -806,7 +770,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                      (def.modifiers & DefModifiers::IMPORTABLE),\n                     None => modifiers,\n                 };\n-                if new_parent.kind.get() != NormalModuleKind {\n+                if !new_parent.is_normal() {\n                     modifiers = modifiers & !DefModifiers::IMPORTABLE;\n                 }\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n@@ -835,33 +799,33 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-\n                 // Define a module if necessary.\n                 let parent_link = self.get_parent_link(new_parent, name);\n-                child_name_bindings.set_module_kind(parent_link,\n-                                                    Some(def_id),\n-                                                    TraitModuleKind,\n-                                                    true,\n-                                                    is_public,\n-                                                    DUMMY_SP)\n+                child_name_bindings.define_module(parent_link,\n+                                                  Some(def),\n+                                                  true,\n+                                                  is_public,\n+                                                  DUMMY_SP)\n             }\n             DefTy(..) | DefAssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\",\n                        final_ident);\n \n-                let modifiers = match new_parent.kind.get() {\n-                    NormalModuleKind => modifiers,\n+                let modifiers = match new_parent.is_normal() {\n+                    true => modifiers,\n                     _ => modifiers & !DefModifiers::IMPORTABLE,\n                 };\n \n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                if let DefTy(..) = def {\n+                    child_name_bindings.type_ns.set_modifiers(modifiers);\n+                } else {\n+                    child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                }\n             }\n             DefStruct(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type and value for \\\n                         {}\",\n                        final_ident);\n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                 let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n \n                 if fields.is_empty() {\n@@ -937,7 +901,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         debug!(\"(populating external module) attempting to populate {}\",\n                module_to_string(&**module));\n \n-        let def_id = match module.def_id.get() {\n+        let def_id = match module.def_id() {\n             None => {\n                 debug!(\"(populating external module) ... no def ID!\");\n                 return;\n@@ -971,8 +935,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n         csearch::each_top_level_item_of_crate(&self.session.cstore,\n-                                              root.def_id\n-                                                  .get()\n+                                              root.def_id()\n                                                   .unwrap()\n                                                   .krate,\n                                               |def_like, name, visibility| {"}, {"sha": "18e2b66d3fb2e8e863ff06c8264fde2d7b92db04", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 82, "deletions": 100, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8a6187fde1de7b209bbd2b49ea3c669006a0d154", "patch": "@@ -49,7 +49,6 @@ use self::AssocItemResolveResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n-use self::ModuleKind::*;\n use self::FallbackChecks::*;\n \n use rustc::front::map as hir_map;\n@@ -759,21 +758,10 @@ enum ParentLink {\n     BlockParentLink(Weak<Module>, NodeId),\n }\n \n-/// The type of module this is.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum ModuleKind {\n-    NormalModuleKind,\n-    TraitModuleKind,\n-    EnumModuleKind,\n-    TypeModuleKind,\n-    AnonymousModuleKind,\n-}\n-\n /// One node in the tree of modules.\n pub struct Module {\n     parent_link: ParentLink,\n-    def_id: Cell<Option<DefId>>,\n-    kind: Cell<ModuleKind>,\n+    def: Cell<Option<Def>>,\n     is_public: bool,\n \n     children: RefCell<HashMap<Name, NameBindings>>,\n@@ -822,15 +810,13 @@ pub struct Module {\n \n impl Module {\n     fn new(parent_link: ParentLink,\n-           def_id: Option<DefId>,\n-           kind: ModuleKind,\n+           def: Option<Def>,\n            external: bool,\n            is_public: bool)\n            -> Module {\n         Module {\n             parent_link: parent_link,\n-            def_id: Cell::new(def_id),\n-            kind: Cell::new(kind),\n+            def: Cell::new(def),\n             is_public: is_public,\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n@@ -845,6 +831,24 @@ impl Module {\n         }\n     }\n \n+    fn def_id(&self) -> Option<DefId> {\n+        self.def.get().as_ref().map(Def::def_id)\n+    }\n+\n+    fn is_normal(&self) -> bool {\n+        match self.def.get() {\n+            Some(DefMod(_)) | Some(DefForeignMod(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_trait(&self) -> bool {\n+        match self.def.get() {\n+            Some(DefTrait(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn all_imports_resolved(&self) -> bool {\n         if self.imports.borrow_state() == ::std::cell::BorrowState::Writing {\n             // it is currently being resolved ! so nope\n@@ -882,9 +886,8 @@ impl Module {\n impl fmt::Debug for Module {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,\n-               \"{:?}, kind: {:?}, {}\",\n-               self.def_id,\n-               self.kind,\n+               \"{:?}, {}\",\n+               self.def,\n                if self.is_public {\n                    \"public\"\n                } else {\n@@ -902,7 +905,9 @@ bitflags! {\n }\n \n // Records a possibly-private definition.\n-#[derive(Clone,Debug)]\n+// FIXME once #21546 is resolved, the def and module fields will never both be Some,\n+// so they can be refactored into something like Result<Def, Rc<Module>>.\n+#[derive(Debug)]\n struct NsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     def: Option<Def>,\n@@ -911,10 +916,20 @@ struct NsDef {\n }\n \n impl NsDef {\n+    fn create_from_module(module: Rc<Module>, span: Option<Span>) -> Self {\n+        let modifiers = if module.is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n+\n+        NsDef { modifiers: modifiers, def: None, module: Some(module), span: span }\n+    }\n+\n     fn def(&self) -> Option<Def> {\n         match (self.def, &self.module) {\n             (def @ Some(_), _) => def,\n-            (_, &Some(ref module)) => module.def_id.get().map(|def_id| DefMod(def_id)),\n+            (_, &Some(ref module)) => module.def.get(),\n             _ => panic!(\"NsDef has neither a Def nor a Module\"),\n         }\n     }\n@@ -930,17 +945,17 @@ impl NameBinding {\n     }\n \n     fn create_from_module(module: Rc<Module>) -> Self {\n-        NameBinding(Rc::new(RefCell::new(Some(NsDef {\n-            modifiers: DefModifiers::IMPORTABLE,\n-            def: None,\n-            module: Some(module),\n-            span: None,\n-        }))))\n+        NameBinding(Rc::new(RefCell::new(Some(NsDef::create_from_module(module, None)))))\n+    }\n+\n+    fn set(&self, ns_def: NsDef) {\n+        *self.0.borrow_mut() = Some(ns_def);\n     }\n \n-    fn set(&self, modifiers: DefModifiers, def: Option<Def>, mod_: Option<Rc<Module>>, sp: Span) {\n-        *self.0.borrow_mut() =\n-            Some(NsDef { modifiers: modifiers, def: def, module: mod_, span: Some(sp) });\n+    fn set_modifiers(&self, modifiers: DefModifiers) {\n+        if let Some(ref mut ns_def) = *self.0.borrow_mut() {\n+            ns_def.modifiers = modifiers\n+        }\n     }\n \n     fn and_then<T, F: Fn(&NsDef) -> Option<T>>(&self, f: F) -> Option<T> {\n@@ -1004,35 +1019,12 @@ impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n     fn define_module(&self,\n                      parent_link: ParentLink,\n-                     def_id: Option<DefId>,\n-                     kind: ModuleKind,\n+                     def: Option<Def>,\n                      external: bool,\n                      is_public: bool,\n                      sp: Span) {\n-        // Merges the module with the existing type def or creates a new one.\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n-\n-        let module_ = Rc::new(Module::new(parent_link, def_id, kind, external, is_public));\n-        self.type_ns.set(modifiers, self.type_ns.def(), Some(module_), sp);\n-    }\n-\n-    /// Sets the kind of the module, creating a new one if necessary.\n-    fn set_module_kind(&self,\n-                       parent_link: ParentLink,\n-                       def_id: Option<DefId>,\n-                       kind: ModuleKind,\n-                       external: bool,\n-                       is_public: bool,\n-                       _sp: Span) {\n-        if let Some(module) = self.type_ns.module() {\n-            module.kind.set(kind)\n-        } else {\n-            self.define_module(parent_link, def_id, kind, external, is_public, _sp)\n-        }\n+        let module = Module::new(parent_link, def, external, is_public);\n+        self.type_ns.set(NsDef::create_from_module(Rc::new(module), Some(sp)));\n     }\n \n     /// Records a type definition.\n@@ -1041,13 +1033,19 @@ impl NameBindings {\n                def,\n                modifiers);\n         // Merges the type with the existing type def or creates a new one.\n-        self.type_ns.set(modifiers, Some(def), self.type_ns.module(), sp);\n+        self.type_ns.set(NsDef {\n+            modifiers: modifiers, def: Some(def), module: self.type_ns.module(), span: Some(sp)\n+        });\n     }\n \n     /// Records a value definition.\n     fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n-        self.value_ns.set(modifiers, Some(def), None, sp);\n+        debug!(\"defining value for def {:?} with modifiers {:?}\",\n+               def,\n+               modifiers);\n+        self.value_ns.set(NsDef {\n+            modifiers: modifiers, def: Some(def), module: None, span: Some(sp)\n+        });\n     }\n \n     /// Returns the module node if applicable.\n@@ -1178,8 +1176,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n         graph_root.define_module(NoParentLink,\n-                                 Some(root_def_id),\n-                                 NormalModuleKind,\n+                                 Some(DefMod(root_def_id)),\n                                  false,\n                                  true,\n                                  crate_span);\n@@ -1358,7 +1355,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // so, whether there is a module within.\n                     if let Some(module_def) = target.binding.module() {\n                         // track extern crates for unused_extern_crate lint\n-                        if let Some(did) = module_def.def_id.get() {\n+                        if let Some(did) = module_def.def_id() {\n                             self.used_crates.insert(did.krate);\n                         }\n \n@@ -1367,7 +1364,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // Keep track of the closest private module used\n                         // when resolving this import chain.\n                         if !used_proxy && !search_module.is_public {\n-                            if let Some(did) = search_module.def_id.get() {\n+                            if let Some(did) = search_module.def_id() {\n                                 closest_private = LastMod(DependsOn(did));\n                             }\n                         }\n@@ -1466,8 +1463,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success(PrefixFound(ref containing_module, index)) => {\n                 search_module = containing_module.clone();\n                 start_index = index;\n-                last_private = LastMod(DependsOn(containing_module.def_id\n-                                                                  .get()\n+                last_private = LastMod(DependsOn(containing_module.def_id()\n                                                                   .unwrap()));\n             }\n         }\n@@ -1527,8 +1523,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let id = import_resolution.id(namespace);\n                     self.used_imports.insert((id, namespace));\n                     self.record_import_use(id, name);\n-                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n-                        self.used_crates.insert(kid);\n+                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n+                         self.used_crates.insert(kid);\n                     }\n                     return Success((target, false));\n                 }\n@@ -1558,19 +1554,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     return Failed(None);\n                 }\n                 ModuleParentLink(parent_module_node, _) => {\n-                    match search_module.kind.get() {\n-                        NormalModuleKind => {\n-                            // We stop the search here.\n-                            debug!(\"(resolving item in lexical scope) unresolved module: not \\\n-                                    searching through module parents\");\n+                    if search_module.is_normal() {\n+                        // We stop the search here.\n+                        debug!(\"(resolving item in lexical scope) unresolved module: not \\\n+                                searching through module parents\");\n                             return Failed(None);\n-                        }\n-                        TraitModuleKind |\n-                        EnumModuleKind |\n-                        TypeModuleKind |\n-                        AnonymousModuleKind => {\n-                            search_module = parent_module_node.upgrade().unwrap();\n-                        }\n+                    } else {\n+                        search_module = parent_module_node.upgrade().unwrap();\n                     }\n                 }\n                 BlockParentLink(ref parent_module_node, _) => {\n@@ -1642,13 +1632,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 ModuleParentLink(new_module, _) |\n                 BlockParentLink(new_module, _) => {\n                     let new_module = new_module.upgrade().unwrap();\n-                    match new_module.kind.get() {\n-                        NormalModuleKind => return Some(new_module),\n-                        TraitModuleKind |\n-                        EnumModuleKind |\n-                        TypeModuleKind |\n-                        AnonymousModuleKind => module_ = new_module,\n+                    if new_module.is_normal() {\n+                        return Some(new_module);\n                     }\n+                    module_ = new_module;\n                 }\n             }\n         }\n@@ -1657,17 +1644,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n     fn get_nearest_normal_module_parent_or_self(&mut self, module_: Rc<Module>) -> Rc<Module> {\n-        match module_.kind.get() {\n-            NormalModuleKind => return module_,\n-            TraitModuleKind |\n-            EnumModuleKind |\n-            TypeModuleKind |\n-            AnonymousModuleKind => {\n-                match self.get_nearest_normal_module_parent(module_.clone()) {\n-                    None => module_,\n-                    Some(new_module) => new_module,\n-                }\n-            }\n+        if module_.is_normal() {\n+            return module_;\n+        }\n+        match self.get_nearest_normal_module_parent(module_.clone()) {\n+            None => module_,\n+            Some(new_module) => new_module,\n         }\n     }\n \n@@ -1766,7 +1748,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let id = import_resolution.id(namespace);\n                         self.used_imports.insert((id, namespace));\n                         self.record_import_use(id, name);\n-                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n                             self.used_crates.insert(kid);\n                         }\n                         return Success((target, true));\n@@ -3109,7 +3091,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             _ => return None,\n         };\n-        if let Some(DefId{krate: kid, ..}) = containing_module.def_id.get() {\n+        if let Some(DefId{krate: kid, ..}) = containing_module.def_id() {\n             self.used_crates.insert(kid);\n         }\n         return Some(def);\n@@ -3696,7 +3678,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.used_imports.insert((id, TypeNS));\n                     let trait_name = self.get_trait_name(did);\n                     self.record_import_use(id, trait_name);\n-                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n                         self.used_crates.insert(kid);\n                     }\n                 }"}, {"sha": "6e8d2ac4ca5c6ad68c6a4db581c0c00a85867fe1", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=8a6187fde1de7b209bbd2b49ea3c669006a0d154", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         // If this isn't a local krate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n-        match module_.def_id.get() {\n+        match module_.def_id() {\n             Some(def_id) if def_id.is_local() => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording exports for local \\\n@@ -98,7 +98,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         let mut exports = Vec::new();\n \n         self.add_exports_for_module(&mut exports, module_);\n-        match module_.def_id.get() {\n+        match module_.def_id() {\n             Some(def_id) => {\n                 let node_id = self.ast_map.as_local_node_id(def_id).unwrap();\n                 self.export_map.insert(node_id, exports);"}, {"sha": "14f8287a5f875615e2f7b99826d7eea1a9cf7d4c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8a6187fde1de7b209bbd2b49ea3c669006a0d154", "patch": "@@ -12,7 +12,6 @@ use self::ImportDirectiveSubclass::*;\n \n use DefModifiers;\n use Module;\n-use ModuleKind;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBindings, NameBinding};\n use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n@@ -550,7 +549,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n                                     this.record_import_use(id, source);\n-                                    match target_module.def_id.get() {\n+                                    match target_module.def_id() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n                                         }\n@@ -592,7 +591,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         // In this case we continue as if we resolved the import and let the\n                         // check_for_conflicts_between_imports_and_items call below handle\n                         // the conflict\n-                        match (module_.def_id.get(), target_module.def_id.get()) {\n+                        match (module_.def_id(), target_module.def_id()) {\n                             (Some(id1), Some(id2)) if id1 == id2 => {\n                                 if value_result.is_unknown() {\n                                     value_result = UnboundResult;\n@@ -625,7 +624,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external module\");\n                         // track the module as used.\n-                        match module.def_id.get() {\n+                        match module.def_id() {\n                             Some(DefId{krate: kid, ..}) => {\n                                 self.resolver.used_crates.insert(kid);\n                             }\n@@ -864,7 +863,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = target_module.def_id.get() {\n+        if let Some(did) = target_module.def_id() {\n             self.resolver.def_map.borrow_mut().insert(id,\n                                                       PathResolution {\n                                                           base_def: DefMod(did),\n@@ -954,10 +953,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 let ns_word = match namespace {\n                     TypeNS => {\n                         match target.binding.module() {\n-                            Some(ref module) if module.kind.get() ==\n-                                                ModuleKind::NormalModuleKind => \"module\",\n-                            Some(ref module) if module.kind.get() ==\n-                                                ModuleKind::TraitModuleKind => \"trait\",\n+                            Some(ref module) if module.is_normal() => \"module\",\n+                            Some(ref module) if module.is_trait() => \"trait\",\n                             _ => \"type\",\n                         }\n                     }\n@@ -1043,9 +1040,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n                     let (what, note) = match ty.module.clone() {\n-                        Some(ref module) if module.kind.get() == ModuleKind::NormalModuleKind =>\n+                        Some(ref module) if module.is_normal() =>\n                             (\"existing submodule\", \"note conflicting module here\"),\n-                        Some(ref module) if module.kind.get() == ModuleKind::TraitModuleKind =>\n+                        Some(ref module) if module.is_trait() =>\n                             (\"trait in this module\", \"note conflicting trait here\"),\n                         _ => (\"type in this module\", \"note conflicting type here\"),\n                     };"}, {"sha": "67969616ca3c93215fda25ae8670a4aad10d33a7", "filename": "src/test/compile-fail/enum-and-module-in-same-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6187fde1de7b209bbd2b49ea3c669006a0d154/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs?ref=8a6187fde1de7b209bbd2b49ea3c669006a0d154", "patch": "@@ -13,7 +13,7 @@ mod Foo {\n }\n \n enum Foo {  //~ ERROR duplicate definition of type or module `Foo`\n-    X //~ ERROR duplicate definition of value `X`\n+    X\n }\n \n fn main() {}"}]}