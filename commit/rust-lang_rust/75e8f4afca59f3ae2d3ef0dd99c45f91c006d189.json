{"sha": "75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZThmNGFmY2E1OWYzYWUyZDNlZjBkZDk5YzQ1ZjkxYzAwNmQxODk=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-24T23:02:34Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-24T23:02:34Z"}, "message": "Properly translate unit structs in MIR", "tree": {"sha": "694ee5ae49746358f361577e43e3dfd1ccd71c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/694ee5ae49746358f361577e43e3dfd1ccd71c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "html_url": "https://github.com/rust-lang/rust/commit/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "html_url": "https://github.com/rust-lang/rust/commit/4ce1dafd1d58852a88f38a0f63cb11236a7470cb"}], "stats": {"total": 127, "additions": 73, "deletions": 54}, "files": [{"sha": "be6bb8689eefab0674e5e978cadec17f50887764", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "patch": "@@ -701,9 +701,9 @@ pub struct Constant<'tcx> {\n #[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum ItemKind {\n     Constant,\n+    /// This is any sort of callable (usually those that have a type of `fn(\u2026) -> \u2026`). This\n+    /// includes functions, constructors, but not methods which have their own ItemKind.\n     Function,\n-    Struct,\n-    Variant,\n     Method,\n }\n "}, {"sha": "46e6243c8bf30c205ecd21a0dbbf7edd556207e8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "patch": "@@ -519,51 +519,51 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n-    match def {\n-        def::DefVariant(_, def_id, false) |\n-        def::DefStruct(def_id) |\n-        def::DefFn(def_id, _) |\n-        def::DefMethod(def_id) => {\n-            let kind = match def {\n-                def::DefVariant(..) => ItemKind::Variant,\n-                def::DefStruct(..) => ItemKind::Struct,\n-                def::DefFn(..) => ItemKind::Function,\n-                def::DefMethod(..) => ItemKind::Method,\n-                _ => panic!()\n-            };\n-            ExprKind::Literal {\n-                literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n+    let (def_id, kind) = match def {\n+        // A variant constructor.\n+        def::DefVariant(_, def_id, false) => (def_id, ItemKind::Function),\n+        // A regular function.\n+        def::DefFn(def_id, _) => (def_id, ItemKind::Function),\n+        def::DefMethod(def_id) => (def_id, ItemKind::Method),\n+        def::DefStruct(def_id) => {\n+            match cx.tcx.node_id_to_type(expr.id).sty {\n+                // A tuple-struct constructor.\n+                ty::TyBareFn(..) => (def_id, ItemKind::Function),\n+                // This is a special case: a unit struct which is used as a value. We return a\n+                // completely different ExprKind here to account for this special case.\n+                ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: 0,\n+                    substs: substs,\n+                    fields: vec![],\n+                    base: None\n+                },\n+                ref sty => panic!(\"unexpected sty: {:?}\", sty)\n             }\n         },\n         def::DefConst(def_id) |\n         def::DefAssociatedConst(def_id) => {\n             if let Some(v) = cx.try_const_eval_literal(expr) {\n-                ExprKind::Literal { literal: v }\n+                return ExprKind::Literal { literal: v };\n             } else {\n-                ExprKind::Literal {\n-                    literal: Literal::Item {\n-                        def_id: def_id,\n-                        kind: ItemKind::Constant,\n-                        substs: substs\n-                    }\n-                }\n+                (def_id, ItemKind::Constant)\n             }\n         }\n \n-\n-        def::DefStatic(node_id, _) =>\n-            ExprKind::StaticRef {\n-                id: node_id,\n-            },\n+        def::DefStatic(node_id, _) => return ExprKind::StaticRef {\n+            id: node_id,\n+        },\n \n         def @ def::DefLocal(..) |\n-        def @ def::DefUpvar(..) =>\n-            convert_var(cx, expr, def),\n+        def @ def::DefUpvar(..) => return convert_var(cx, expr, def),\n \n         def =>\n             cx.tcx.sess.span_bug(\n                 expr.span,\n                 &format!(\"def `{:?}` not yet implemented\", def)),\n+    };\n+    ExprKind::Literal {\n+        literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n     }\n }\n "}, {"sha": "d4a7a7c8b48ff3234be80857dfae5c084e39d550", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "patch": "@@ -39,9 +39,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           did: DefId)\n                           -> OperandRef<'tcx> {\n         match kind {\n-            ItemKind::Function |\n-            ItemKind::Struct |\n-            ItemKind::Variant => self.trans_fn_ref(bcx, ty, substs, did),\n+            ItemKind::Function => self.trans_fn_ref(bcx, ty, substs, did),\n             ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n                 ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n                 ty::TraitContainer(tdid) => self.trans_static_method(bcx, ty, did, tdid, substs)"}, {"sha": "55a41201b2ba17c849236fbf26c55dd53bb2bee4", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "patch": "@@ -19,28 +19,30 @@ use trans::common::{self, Block, Result};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n+use trans::adt;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::tvec;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n+use super::lvalue::LvalueRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n                         bcx: Block<'bcx, 'tcx>,\n-                        lldest: ValueRef,\n+                        dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Block<'bcx, 'tcx>\n     {\n-        debug!(\"trans_rvalue(lldest={}, rvalue={:?})\",\n-               bcx.val_to_string(lldest),\n+        debug!(\"trans_rvalue(dest.llval={}, rvalue={:?})\",\n+               bcx.val_to_string(dest.llval),\n                rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                self.trans_operand_into(bcx, lldest, operand);\n+                self.trans_operand_into(bcx, dest.llval, operand);\n                 bcx\n             }\n \n@@ -49,7 +51,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(bcx, lldest, temp);\n+                    self.store_operand(bcx, dest.llval, temp);\n                     return bcx;\n                 }\n \n@@ -72,12 +74,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         base::store_ty(bcx, llval, lltemp, operand.ty);\n                         base::coerce_unsized_into(bcx,\n                                                   lltemp, operand.ty,\n-                                                  lldest, cast_ty);\n+                                                  dest.llval, cast_ty);\n                     }\n                     OperandValue::Ref(llref) => {\n                         base::coerce_unsized_into(bcx,\n                                                   llref, operand.ty,\n-                                                  lldest, cast_ty);\n+                                                  dest.llval, cast_ty);\n                     }\n                 }\n                 bcx\n@@ -86,20 +88,31 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let elem = self.trans_operand(bcx, elem);\n                 let size = self.trans_constant(bcx, count).immediate();\n-                let base = expr::get_dataptr(bcx, lldest);\n+                let base = expr::get_dataptr(bcx, dest.llval);\n                 tvec::iter_vec_raw(bcx, base, elem.ty, size, |bcx, llslot, _| {\n                     self.store_operand(bcx, llslot, elem);\n                     bcx\n                 })\n             }\n \n-            mir::Rvalue::Aggregate(_, ref operands) => {\n-                for (i, operand) in operands.iter().enumerate() {\n-                    // Note: perhaps this should be StructGep, but\n-                    // note that in some cases the values here will\n-                    // not be structs but arrays.\n-                    let lldest_i = build::GEPi(bcx, lldest, &[0, i]);\n-                    self.trans_operand_into(bcx, lldest_i, operand);\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                match *kind {\n+                    // Unit struct, which is translated very differently compared to any other\n+                    // aggregate\n+                    mir::AggregateKind::Adt(adt_def, 0, _)\n+                    if adt_def.struct_variant().kind() == ty::VariantKind::Unit => {\n+                        let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n+                        adt::trans_set_discr(bcx, &*repr, dest.llval, 0);\n+                    },\n+                    _ => {\n+                        for (i, operand) in operands.iter().enumerate() {\n+                            // Note: perhaps this should be StructGep, but\n+                            // note that in some cases the values here will\n+                            // not be structs but arrays.\n+                            let lldest_i = build::GEPi(bcx, dest.llval, &[0, i]);\n+                            self.trans_operand_into(bcx, lldest_i, operand);\n+                        }\n+                    }\n                 }\n                 bcx\n             }\n@@ -113,9 +126,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n                 let adj = common::C_uint(ccx, from_start + from_end);\n                 let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n-                let lladdrdest = expr::get_dataptr(bcx, lldest);\n+                let lladdrdest = expr::get_dataptr(bcx, dest.llval);\n                 build::Store(bcx, llbase1, lladdrdest);\n-                let llmetadest = expr::get_meta(bcx, lldest);\n+                let llmetadest = expr::get_meta(bcx, dest.llval);\n                 build::Store(bcx, lllen1, llmetadest);\n                 bcx\n             }\n@@ -127,7 +140,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(bcx, lldest, temp);\n+                self.store_operand(bcx, dest.llval, temp);\n                 bcx\n             }\n         }"}, {"sha": "dae0d3b55c0ba2bec9c3bfee01abd13aa2197929", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "patch": "@@ -31,7 +31,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let index = index as usize;\n                         match self.temps[index as usize] {\n                             TempRef::Lvalue(tr_dest) => {\n-                                self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                                self.trans_rvalue(bcx, tr_dest, rvalue)\n                             }\n                             TempRef::Operand(None) => {\n                                 let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n@@ -47,7 +47,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     _ => {\n                         let tr_dest = self.trans_lvalue(bcx, lvalue);\n-                        self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                        self.trans_rvalue(bcx, tr_dest, rvalue)\n                     }\n                 }\n             }"}, {"sha": "9b349c0e4e21bee0719deec86ea46e02501f3df1", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e8f4afca59f3ae2d3ef0dd99c45f91c006d189/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=75e8f4afca59f3ae2d3ef0dd99c45f91c006d189", "patch": "@@ -14,6 +14,8 @@\n extern crate mir_external_refs as ext;\n \n struct S(u8);\n+#[derive(Debug, PartialEq, Eq)]\n+struct Unit;\n \n impl S {\n     fn hey() -> u8 { 42 }\n@@ -175,6 +177,11 @@ fn t20() -> fn(u64, u32)->(u64, u32) {\n     <u32 as T<_, _>>::staticmeth\n }\n \n+#[rustc_mir]\n+fn t21() -> Unit {\n+    Unit\n+}\n+\n fn main(){\n     unsafe {\n         assert_eq!(t1()(), regular());\n@@ -214,5 +221,6 @@ fn main(){\n         assert_eq!(t18()(50u64, 5u64), F::f(50u64, 5u64));\n         assert_eq!(t19()(322u64, 2u32), F::f(322u64, 2u32));\n         assert_eq!(t20()(123u64, 38u32), <u32 as T<_, _>>::staticmeth(123, 38));\n+        assert_eq!(t21(), Unit);\n     }\n }"}]}