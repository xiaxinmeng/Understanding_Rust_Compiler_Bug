{"sha": "d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMzQ1NmRiNWM4YjNmZjhkY2ZjMzFiNDVkZGI0OWU2NmYzNGFiNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T02:30:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T02:30:35Z"}, "message": "Auto merge of #87338 - SparrowLii:MaybeTrait, r=wesleywiser\n\nSimplify the collecting of `? Trait` bounds in where clause\n\nThis PR fixes the FIXME about using less rightward drift and only one error reporting when collecting of `?Trait` bounds in where clause.\nChecking whether the path length of `bound_ty` is 1 can be replaced by whether `unresolved_segments` in the partial_res is 0.\nChecking whether the `param.kind` is `Type{...}` can also be omitted. One Fx hash calculation will be done for Const or Lifetime param, but the impact on efficiency should be small IMO", "tree": {"sha": "b2c412bfde29d3ba3692771aca0ae6086ec57808", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2c412bfde29d3ba3692771aca0ae6086ec57808"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47", "html_url": "https://github.com/rust-lang/rust/commit/d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b4a0dfc139872341a2b55ee9958f6fa8a9f1d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4a0dfc139872341a2b55ee9958f6fa8a9f1d64", "html_url": "https://github.com/rust-lang/rust/commit/3b4a0dfc139872341a2b55ee9958f6fa8a9f1d64"}, {"sha": "0f5bfc22423f8b0a313a19fef92fdeb872f8cd11", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5bfc22423f8b0a313a19fef92fdeb872f8cd11", "html_url": "https://github.com/rust-lang/rust/commit/0f5bfc22423f8b0a313a19fef92fdeb872f8cd11"}], "stats": {"total": 50, "additions": 17, "deletions": 33}, "files": [{"sha": "880692516e9ef3b5c327a8d4d2811d41ed24b619", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d03456db5c8b3ff8dcfc31b45ddb49e66f34ab47", "patch": "@@ -1373,50 +1373,34 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         itctx: ImplTraitContext<'_, 'hir>,\n     ) -> GenericsCtor<'hir> {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: this could probably be done with less rightward drift. It also looks like two\n-        // control paths where `report_error` is called are the only paths that advance to after the\n-        // match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n                 'next_bound: for bound in &bound_pred.bounds {\n                     if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n-                        let report_error = |this: &mut Self| {\n-                            this.diagnostic().span_err(\n-                                bound_pred.bounded_ty.span,\n-                                \"`?Trait` bounds are only permitted at the \\\n-                                 point where a type parameter is declared\",\n-                            );\n-                        };\n                         // Check if the where clause type is a plain type parameter.\n-                        match bound_pred.bounded_ty.kind {\n-                            TyKind::Path(None, ref path)\n-                                if path.segments.len() == 1\n-                                    && bound_pred.bound_generic_params.is_empty() =>\n+                        match self\n+                            .resolver\n+                            .get_partial_res(bound_pred.bounded_ty.id)\n+                            .map(|d| (d.base_res(), d.unresolved_segments()))\n+                        {\n+                            Some((Res::Def(DefKind::TyParam, def_id), 0))\n+                                if bound_pred.bound_generic_params.is_empty() =>\n                             {\n-                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self\n-                                    .resolver\n-                                    .get_partial_res(bound_pred.bounded_ty.id)\n-                                    .map(|d| d.base_res())\n-                                {\n-                                    if let Some(def_id) = def_id.as_local() {\n-                                        for param in &generics.params {\n-                                            if let GenericParamKind::Type { .. } = param.kind {\n-                                                if def_id == self.resolver.local_def_id(param.id) {\n-                                                    add_bounds\n-                                                        .entry(param.id)\n-                                                        .or_default()\n-                                                        .push(bound.clone());\n-                                                    continue 'next_bound;\n-                                                }\n-                                            }\n-                                        }\n+                                for param in &generics.params {\n+                                    if def_id == self.resolver.local_def_id(param.id).to_def_id() {\n+                                        add_bounds.entry(param.id).or_default().push(bound.clone());\n+                                        continue 'next_bound;\n                                     }\n                                 }\n-                                report_error(self)\n                             }\n-                            _ => report_error(self),\n+                            _ => {}\n                         }\n+                        self.diagnostic().span_err(\n+                            bound_pred.bounded_ty.span,\n+                            \"`?Trait` bounds are only permitted at the \\\n+                                 point where a type parameter is declared\",\n+                        );\n                     }\n                 }\n             }"}]}