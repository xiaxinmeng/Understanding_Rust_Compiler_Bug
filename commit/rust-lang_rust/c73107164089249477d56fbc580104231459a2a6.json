{"sha": "c73107164089249477d56fbc580104231459a2a6", "node_id": "C_kwDOAAsO6NoAKGM3MzEwNzE2NDA4OTI0OTQ3N2Q1NmZiYzU4MDEwNDIzMTQ1OWEyYTY", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-29T20:10:36Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:16:00Z"}, "message": "Give flag temp disabling race detector a better name", "tree": {"sha": "f7898ef5f643918766849495cac537114b7287b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7898ef5f643918766849495cac537114b7287b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c73107164089249477d56fbc580104231459a2a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRGAACgkQGBtJ+fOP\nM3SGkAv/S6sn9Fl/nZkQVFYFUAFhv0ZpkzC8yFFoIoKSTdJbi09H6AdOlITxCl+n\nB8mu/NMrY6kWYd7lgfTL0WuhRWUXRLXOOh+/rR+GdLkexy+fU1A7BIlFCAoSZ5oP\nMmO337b2+SCaCp5ANzLTnQcIUtrCxIGf4915MKgTXTsnRFfNaU5X7RdGm+GRW6BY\nOdW/F7GZOqz0AC7VoFCGMGdb093Ml5Dq6sGuNEEhHzVJFNoPcdiJX+MpnLlufsyJ\nezio08CJDQcATu568/JLbguv1lZGZWELZWH0yAFxj4Otty3aU8wTvDfdBV9U5LsC\nZIhgp18W7x/j2EIOgO3k7LWvUfNbWceV//M8hyX7YCYQ3rbJZkjsfPRTXopjjpvo\nPo803y3OS++TI3aeTKkI+0kOTMPPDPobFvhMuDM3CPJ6HG7/+a/52B+t1xbxMl4c\nAODi6bS7VCHa40dyyOErYa+GMwLr/z6BXlop4dQByvc/9u/xuiz6Crh9VYortF5r\n8EcSYOaF\n=XgMU\n-----END PGP SIGNATURE-----", "payload": "tree f7898ef5f643918766849495cac537114b7287b9\nparent 8215702d5a27c77197cf8d12e03caca6c3884783\nauthor Andy Wang <cbeuw.andy@gmail.com> 1653855036 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539360 +0100\n\nGive flag temp disabling race detector a better name\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c73107164089249477d56fbc580104231459a2a6", "html_url": "https://github.com/rust-lang/rust/commit/c73107164089249477d56fbc580104231459a2a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c73107164089249477d56fbc580104231459a2a6/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8215702d5a27c77197cf8d12e03caca6c3884783", "url": "https://api.github.com/repos/rust-lang/rust/commits/8215702d5a27c77197cf8d12e03caca6c3884783", "html_url": "https://github.com/rust-lang/rust/commit/8215702d5a27c77197cf8d12e03caca6c3884783"}], "stats": {"total": 31, "additions": 17, "deletions": 14}, "files": [{"sha": "f6f0ce528edb334aafc5e121fc8146d8e162920d", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c73107164089249477d56fbc580104231459a2a6/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73107164089249477d56fbc580104231459a2a6/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=c73107164089249477d56fbc580104231459a2a6", "patch": "@@ -455,11 +455,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n         let this = self.eval_context_ref();\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_atomic_access.set(true);\n+            data_race.ongoing_action_data_race_free.set(true);\n         }\n         let result = op(this);\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_atomic_access.set(false);\n+            data_race.ongoing_action_data_race_free.set(false);\n         }\n         result\n     }\n@@ -474,11 +474,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> R {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_atomic_access.set(true);\n+            data_race.ongoing_action_data_race_free.set(true);\n         }\n         let result = op(this);\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_atomic_access.set(false);\n+            data_race.ongoing_action_data_race_free.set(false);\n         }\n         result\n     }\n@@ -1151,8 +1151,9 @@ pub struct GlobalState {\n     multi_threaded: Cell<bool>,\n \n     /// A flag to mark we are currently performing\n-    /// an atomic access to supress data race detection\n-    ongoing_atomic_access: Cell<bool>,\n+    /// a data race free action (such as atomic access)\n+    /// to supress the race detector\n+    ongoing_action_data_race_free: Cell<bool>,\n \n     /// Mapping of a vector index to a known set of thread\n     /// clocks, this is not directly mapping from a thread id\n@@ -1205,7 +1206,7 @@ impl GlobalState {\n     pub fn new() -> Self {\n         let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n-            ongoing_atomic_access: Cell::new(false),\n+            ongoing_action_data_race_free: Cell::new(false),\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n             thread_info: RefCell::new(IndexVec::new()),\n@@ -1232,14 +1233,14 @@ impl GlobalState {\n     }\n \n     // We perform data race detection when there are more than 1 active thread\n-    // and we are not currently in the middle of an atomic acces where data race\n-    // is impossible\n+    // and we have not temporarily disabled race detection to perform something\n+    // data race free\n     fn race_detecting(&self) -> bool {\n-        self.multi_threaded.get() && !self.ongoing_atomic_access.get()\n+        self.multi_threaded.get() && !self.ongoing_action_data_race_free.get()\n     }\n \n-    pub fn ongoing_atomic_access(&self) -> bool {\n-        self.ongoing_atomic_access.get()\n+    pub fn ongoing_action_data_race_free(&self) -> bool {\n+        self.ongoing_action_data_race_free.get()\n     }\n \n     // Try to find vector index values that can potentially be re-used"}, {"sha": "dc32a3ddca41f0c06a2c6d950130b35ee1b0ba82", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c73107164089249477d56fbc580104231459a2a6/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73107164089249477d56fbc580104231459a2a6/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=c73107164089249477d56fbc580104231459a2a6", "patch": "@@ -139,7 +139,7 @@ impl StoreBufferAlloc {\n     /// after all the prior atomic accesses so the location no longer needs to exhibit\n     /// any weak memory behaviours until further atomic accesses.\n     pub fn memory_accessed<'tcx>(&self, range: AllocRange, global: &GlobalState) {\n-        if !global.ongoing_atomic_access() {\n+        if !global.ongoing_action_data_race_free() {\n             let mut buffers = self.store_buffers.borrow_mut();\n             let access_type = buffers.access_type(range);\n             match access_type {\n@@ -420,7 +420,9 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 && !alloc_clocks\n                     .race_free_with_atomic(range, this.machine.data_race.as_ref().unwrap())\n             {\n-                throw_ub_format!(\"racy imperfectly overlapping atomic access is not possible in the C++20 memory model\");\n+                throw_ub_format!(\n+                    \"racy imperfectly overlapping atomic access is not possible in the C++20 memory model\"\n+                );\n             }\n         }\n         Ok(())"}]}