{"sha": "ff86b27e7be1ffff9e00d80beb15560d5f301459", "node_id": "C_kwDOAAsO6NoAKGZmODZiMjdlN2JlMWZmZmY5ZTAwZDgwYmViMTU1NjBkNWYzMDE0NTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T05:12:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T05:12:40Z"}, "message": "Auto merge of #98178 - RalfJung:btree-alloc, r=thomcc\n\nbtree: avoid forcing the allocator to be a reference\n\nThe previous code forces the actual allocator used to be some `&A`. This generalizes the code to allow any `A: Copy`. If people truly want to use a reference, they can use `&A` themselves.\n\nFixes https://github.com/rust-lang/rust/issues/98176", "tree": {"sha": "177b022f938730423dd0364795e57b9756024123", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177b022f938730423dd0364795e57b9756024123"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff86b27e7be1ffff9e00d80beb15560d5f301459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff86b27e7be1ffff9e00d80beb15560d5f301459", "html_url": "https://github.com/rust-lang/rust/commit/ff86b27e7be1ffff9e00d80beb15560d5f301459", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff86b27e7be1ffff9e00d80beb15560d5f301459/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "529c4c71793fbf4305d65b1c4d826a5d0e748fb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/529c4c71793fbf4305d65b1c4d826a5d0e748fb3", "html_url": "https://github.com/rust-lang/rust/commit/529c4c71793fbf4305d65b1c4d826a5d0e748fb3"}, {"sha": "3a1e114120d3570b2b1b4dd4b0b1d31ce0382861", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1e114120d3570b2b1b4dd4b0b1d31ce0382861", "html_url": "https://github.com/rust-lang/rust/commit/3a1e114120d3570b2b1b4dd4b0b1d31ce0382861"}], "stats": {"total": 511, "additions": 270, "deletions": 241}, "files": [{"sha": "b6989afb6255d81747e36b30302155a581051154", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -15,12 +15,12 @@ impl<K, V> Root<K, V> {\n     /// a `BTreeMap`, both iterators should produce keys in strictly ascending\n     /// order, each greater than all keys in the tree, including any keys\n     /// already in the tree upon entry.\n-    pub fn append_from_sorted_iters<I, A: Allocator>(\n+    pub fn append_from_sorted_iters<I, A: Allocator + Clone>(\n         &mut self,\n         left: I,\n         right: I,\n         length: &mut usize,\n-        alloc: &A,\n+        alloc: A,\n     ) where\n         K: Ord,\n         I: Iterator<Item = (K, V)> + FusedIterator,\n@@ -35,7 +35,7 @@ impl<K, V> Root<K, V> {\n     /// Pushes all key-value pairs to the end of the tree, incrementing a\n     /// `length` variable along the way. The latter makes it easier for the\n     /// caller to avoid a leak when the iterator panicks.\n-    pub fn bulk_push<I, A: Allocator>(&mut self, iter: I, length: &mut usize, alloc: &A)\n+    pub fn bulk_push<I, A: Allocator + Clone>(&mut self, iter: I, length: &mut usize, alloc: A)\n     where\n         I: Iterator<Item = (K, V)>,\n     {\n@@ -64,17 +64,17 @@ impl<K, V> Root<K, V> {\n                         }\n                         Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = self.push_internal_level(alloc);\n+                            open_node = self.push_internal_level(alloc.clone());\n                             break;\n                         }\n                     }\n                 }\n \n                 // Push key-value pair and new right subtree.\n                 let tree_height = open_node.height() - 1;\n-                let mut right_tree = Root::new(alloc);\n+                let mut right_tree = Root::new(alloc.clone());\n                 for _ in 0..tree_height {\n-                    right_tree.push_internal_level(alloc);\n+                    right_tree.push_internal_level(alloc.clone());\n                 }\n                 open_node.push(key, value, right_tree);\n "}, {"sha": "91b61218005a6c88cd7ddccc9549ea7f4280b014", "filename": "library/alloc/src/collections/btree/fix.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -7,9 +7,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// sibling. If successful but at the cost of shrinking the parent node,\n     /// returns that shrunk parent node. Returns an `Err` if the node is\n     /// an empty root.\n-    fn fix_node_through_parent<A: Allocator>(\n+    fn fix_node_through_parent<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Result<Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>>, Self> {\n         let len = self.len();\n         if len >= MIN_LEN {\n@@ -54,9 +54,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     ///\n     /// This method does not expect ancestors to already be underfull upon entry\n     /// and panics if it encounters an empty ancestor.\n-    pub fn fix_node_and_affected_ancestors<A: Allocator>(mut self, alloc: &A) -> bool {\n+    pub fn fix_node_and_affected_ancestors<A: Allocator + Clone>(mut self, alloc: A) -> bool {\n         loop {\n-            match self.fix_node_through_parent(alloc) {\n+            match self.fix_node_through_parent(alloc.clone()) {\n                 Ok(Some(parent)) => self = parent.forget_type(),\n                 Ok(None) => return true,\n                 Err(_) => return false,\n@@ -67,28 +67,28 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n \n impl<K, V> Root<K, V> {\n     /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n-    pub fn fix_top<A: Allocator>(&mut self, alloc: &A) {\n+    pub fn fix_top<A: Allocator + Clone>(&mut self, alloc: A) {\n         while self.height() > 0 && self.len() == 0 {\n-            self.pop_internal_level(alloc);\n+            self.pop_internal_level(alloc.clone());\n         }\n     }\n \n     /// Stocks up or merge away any underfull nodes on the right border of the\n     /// tree. The other nodes, those that are not the root nor a rightmost edge,\n     /// must already have at least MIN_LEN elements.\n-    pub fn fix_right_border<A: Allocator>(&mut self, alloc: &A) {\n-        self.fix_top(alloc);\n+    pub fn fix_right_border<A: Allocator + Clone>(&mut self, alloc: A) {\n+        self.fix_top(alloc.clone());\n         if self.len() > 0 {\n-            self.borrow_mut().last_kv().fix_right_border_of_right_edge(alloc);\n+            self.borrow_mut().last_kv().fix_right_border_of_right_edge(alloc.clone());\n             self.fix_top(alloc);\n         }\n     }\n \n     /// The symmetric clone of `fix_right_border`.\n-    pub fn fix_left_border<A: Allocator>(&mut self, alloc: &A) {\n-        self.fix_top(alloc);\n+    pub fn fix_left_border<A: Allocator + Clone>(&mut self, alloc: A) {\n+        self.fix_top(alloc.clone());\n         if self.len() > 0 {\n-            self.borrow_mut().first_kv().fix_left_border_of_left_edge(alloc);\n+            self.borrow_mut().first_kv().fix_left_border_of_left_edge(alloc.clone());\n             self.fix_top(alloc);\n         }\n     }\n@@ -115,16 +115,16 @@ impl<K, V> Root<K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    fn fix_left_border_of_left_edge<A: Allocator>(mut self, alloc: &A) {\n+    fn fix_left_border_of_left_edge<A: Allocator + Clone>(mut self, alloc: A) {\n         while let Internal(internal_kv) = self.force() {\n-            self = internal_kv.fix_left_child(alloc).first_kv();\n+            self = internal_kv.fix_left_child(alloc.clone()).first_kv();\n             debug_assert!(self.reborrow().into_node().len() > MIN_LEN);\n         }\n     }\n \n-    fn fix_right_border_of_right_edge<A: Allocator>(mut self, alloc: &A) {\n+    fn fix_right_border_of_right_edge<A: Allocator + Clone>(mut self, alloc: A) {\n         while let Internal(internal_kv) = self.force() {\n-            self = internal_kv.fix_right_child(alloc).last_kv();\n+            self = internal_kv.fix_right_child(alloc.clone()).last_kv();\n             debug_assert!(self.reborrow().into_node().len() > MIN_LEN);\n         }\n     }\n@@ -135,9 +135,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// provisions an extra element to allow merging its children in turn\n     /// without becoming underfull.\n     /// Returns the left child.\n-    fn fix_left_child<A: Allocator>(\n+    fn fix_left_child<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let mut internal_kv = self.consider_for_balancing();\n         let left_len = internal_kv.left_child_len();\n@@ -158,9 +158,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// provisions an extra element to allow merging its children in turn\n     /// without becoming underfull.\n     /// Returns wherever the right child ended up.\n-    fn fix_right_child<A: Allocator>(\n+    fn fix_right_child<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let mut internal_kv = self.consider_for_balancing();\n         let right_len = internal_kv.right_child_len();"}, {"sha": "e1124a68750ae99d96ddcf5515a929ed96043577", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 110, "deletions": 92, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -171,26 +171,27 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n pub struct BTreeMap<\n     K,\n     V,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     root: Option<Root<K, V>>,\n     length: usize,\n+    /// `ManuallyDrop` to control drop order (needs to be dropped after all the nodes).\n     pub(super) alloc: ManuallyDrop<A>,\n }\n \n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-unsafe impl<#[may_dangle] K, #[may_dangle] V, A: Allocator> Drop for BTreeMap<K, V, A> {\n+unsafe impl<#[may_dangle] K, #[may_dangle] V, A: Allocator + Clone> Drop for BTreeMap<K, V, A> {\n     fn drop(&mut self) {\n         drop(unsafe { ptr::read(self) }.into_iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Clone, V: Clone, A: Clone + Allocator> Clone for BTreeMap<K, V, A> {\n+impl<K: Clone, V: Clone, A: Allocator + Clone> Clone for BTreeMap<K, V, A> {\n     fn clone(&self) -> BTreeMap<K, V, A> {\n-        fn clone_subtree<'a, K: Clone, V: Clone, A: Clone + Allocator>(\n+        fn clone_subtree<'a, K: Clone, V: Clone, A: Allocator + Clone>(\n             node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n-            alloc: &A,\n+            alloc: A,\n         ) -> BTreeMap<K, V, A>\n         where\n             K: 'a,\n@@ -199,9 +200,9 @@ impl<K: Clone, V: Clone, A: Clone + Allocator> Clone for BTreeMap<K, V, A> {\n             match node.force() {\n                 Leaf(leaf) => {\n                     let mut out_tree = BTreeMap {\n-                        root: Some(Root::new(alloc)),\n+                        root: Some(Root::new(alloc.clone())),\n                         length: 0,\n-                        alloc: ManuallyDrop::new((*alloc).clone()),\n+                        alloc: ManuallyDrop::new(alloc),\n                     };\n \n                     {\n@@ -224,19 +225,20 @@ impl<K: Clone, V: Clone, A: Clone + Allocator> Clone for BTreeMap<K, V, A> {\n                     out_tree\n                 }\n                 Internal(internal) => {\n-                    let mut out_tree = clone_subtree(internal.first_edge().descend(), alloc);\n+                    let mut out_tree =\n+                        clone_subtree(internal.first_edge().descend(), alloc.clone());\n \n                     {\n                         let out_root = out_tree.root.as_mut().unwrap();\n-                        let mut out_node = out_root.push_internal_level(alloc);\n+                        let mut out_node = out_root.push_internal_level(alloc.clone());\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n                             in_edge = kv.right_edge();\n \n                             let k = (*k).clone();\n                             let v = (*v).clone();\n-                            let subtree = clone_subtree(in_edge.descend(), alloc);\n+                            let subtree = clone_subtree(in_edge.descend(), alloc.clone());\n \n                             // We can't destructure subtree directly\n                             // because BTreeMap implements Drop\n@@ -247,7 +249,11 @@ impl<K: Clone, V: Clone, A: Clone + Allocator> Clone for BTreeMap<K, V, A> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot.unwrap_or_else(|| Root::new(alloc)));\n+                            out_node.push(\n+                                k,\n+                                v,\n+                                subroot.unwrap_or_else(|| Root::new(alloc.clone())),\n+                            );\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -258,14 +264,14 @@ impl<K: Clone, V: Clone, A: Clone + Allocator> Clone for BTreeMap<K, V, A> {\n         }\n \n         if self.is_empty() {\n-            BTreeMap::new_in(ManuallyDrop::into_inner(self.alloc.clone()))\n+            BTreeMap::new_in((*self.alloc).clone())\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().reborrow(), &*self.alloc) // unwrap succeeds because not empty\n+            clone_subtree(self.root.as_ref().unwrap().reborrow(), (*self.alloc).clone()) // unwrap succeeds because not empty\n         }\n     }\n }\n \n-impl<K, Q: ?Sized, A: Allocator> super::Recover<Q> for BTreeMap<K, (), A>\n+impl<K, Q: ?Sized, A: Allocator + Clone> super::Recover<Q> for BTreeMap<K, (), A>\n where\n     K: Borrow<Q> + Ord,\n     Q: Ord,\n@@ -285,25 +291,31 @@ where\n         let root_node = map.root.as_mut()?.borrow_mut();\n         match root_node.search_tree(key) {\n             Found(handle) => Some(\n-                OccupiedEntry { handle, dormant_map, alloc: &*map.alloc, _marker: PhantomData }\n-                    .remove_kv()\n-                    .0,\n+                OccupiedEntry {\n+                    handle,\n+                    dormant_map,\n+                    alloc: (*map.alloc).clone(),\n+                    _marker: PhantomData,\n+                }\n+                .remove_kv()\n+                .0,\n             ),\n             GoDown(_) => None,\n         }\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = map.root.get_or_insert_with(|| Root::new(&*map.alloc)).borrow_mut();\n+        let root_node =\n+            map.root.get_or_insert_with(|| Root::new((*map.alloc).clone())).borrow_mut();\n         match root_node.search_tree::<K>(&key) {\n             Found(mut kv) => Some(mem::replace(kv.key_mut(), key)),\n             GoDown(handle) => {\n                 VacantEntry {\n                     key,\n                     handle: Some(handle),\n                     dormant_map,\n-                    alloc: &*map.alloc,\n+                    alloc: (*map.alloc).clone(),\n                     _marker: PhantomData,\n                 }\n                 .insert(());\n@@ -369,14 +381,15 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut<'_, K, V> {\n pub struct IntoIter<\n     K,\n     V,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     range: LazyLeafRange<marker::Dying, K, V>,\n     length: usize,\n+    /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n     alloc: A,\n }\n \n-impl<K, V, A: Allocator> IntoIter<K, V, A> {\n+impl<K, V, A: Allocator + Clone> IntoIter<K, V, A> {\n     /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Iter<'_, K, V> {\n@@ -385,7 +398,7 @@ impl<K, V, A: Allocator> IntoIter<K, V, A> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<K: Debug, V: Debug, A: Allocator> Debug for IntoIter<K, V, A> {\n+impl<K: Debug, V: Debug, A: Allocator + Clone> Debug for IntoIter<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.iter()).finish()\n     }\n@@ -456,12 +469,12 @@ impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n /// [`into_keys`]: BTreeMap::into_keys\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-pub struct IntoKeys<K, V, A: Allocator = Global> {\n+pub struct IntoKeys<K, V, A: Allocator + Clone = Global> {\n     inner: IntoIter<K, V, A>,\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K: fmt::Debug, V, A: Allocator> fmt::Debug for IntoKeys<K, V, A> {\n+impl<K: fmt::Debug, V, A: Allocator + Clone> fmt::Debug for IntoKeys<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.inner.iter().map(|(key, _)| key)).finish()\n     }\n@@ -478,13 +491,13 @@ impl<K: fmt::Debug, V, A: Allocator> fmt::Debug for IntoKeys<K, V, A> {\n pub struct IntoValues<\n     K,\n     V,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     inner: IntoIter<K, V, A>,\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V: fmt::Debug, A: Allocator> fmt::Debug for IntoValues<K, V, A> {\n+impl<K, V: fmt::Debug, A: Allocator + Clone> fmt::Debug for IntoValues<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n     }\n@@ -557,7 +570,7 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n+impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// Clears the map, removing all elements.\n     ///\n     /// # Examples\n@@ -578,7 +591,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         mem::drop(BTreeMap {\n             root: mem::replace(&mut self.root, None),\n             length: mem::replace(&mut self.length, 0),\n-            alloc: ManuallyDrop::new(&*self.alloc),\n+            alloc: self.alloc.clone(),\n         });\n     }\n \n@@ -605,7 +618,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n     }\n }\n \n-impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n+impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n@@ -721,7 +734,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         Some(OccupiedEntry {\n             handle: kv.forget_node_type(),\n             dormant_map,\n-            alloc: &*map.alloc,\n+            alloc: (*map.alloc).clone(),\n             _marker: PhantomData,\n         })\n     }\n@@ -809,7 +822,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         Some(OccupiedEntry {\n             handle: kv.forget_node_type(),\n             dormant_map,\n-            alloc: &*map.alloc,\n+            alloc: (*map.alloc).clone(),\n             _marker: PhantomData,\n         })\n     }\n@@ -1029,8 +1042,13 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         let root_node = map.root.as_mut()?.borrow_mut();\n         match root_node.search_tree(key) {\n             Found(handle) => Some(\n-                OccupiedEntry { handle, dormant_map, alloc: &*map.alloc, _marker: PhantomData }\n-                    .remove_entry(),\n+                OccupiedEntry {\n+                    handle,\n+                    dormant_map,\n+                    alloc: (*map.alloc).clone(),\n+                    _marker: PhantomData,\n+                }\n+                .remove_entry(),\n             ),\n             GoDown(_) => None,\n         }\n@@ -1106,14 +1124,15 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n             return;\n         }\n \n-        let self_iter =\n-            mem::replace(self, Self::new_in(ManuallyDrop::into_inner(self.alloc.clone())))\n-                .into_iter();\n-        let other_iter =\n-            mem::replace(other, Self::new_in(ManuallyDrop::into_inner(self.alloc.clone())))\n-                .into_iter();\n-        let root = self.root.get_or_insert_with(|| Root::new(&*self.alloc));\n-        root.append_from_sorted_iters(self_iter, other_iter, &mut self.length, &*self.alloc)\n+        let self_iter = mem::replace(self, Self::new_in((*self.alloc).clone())).into_iter();\n+        let other_iter = mem::replace(other, Self::new_in((*self.alloc).clone())).into_iter();\n+        let root = self.root.get_or_insert_with(|| Root::new((*self.alloc).clone()));\n+        root.append_from_sorted_iters(\n+            self_iter,\n+            other_iter,\n+            &mut self.length,\n+            (*self.alloc).clone(),\n+        )\n     }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the map.\n@@ -1232,21 +1251,21 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n                 key,\n                 handle: None,\n                 dormant_map,\n-                alloc: &*map.alloc,\n+                alloc: (*map.alloc).clone(),\n                 _marker: PhantomData,\n             }),\n             Some(ref mut root) => match root.borrow_mut().search_tree(&key) {\n                 Found(handle) => Occupied(OccupiedEntry {\n                     handle,\n                     dormant_map,\n-                    alloc: &*map.alloc,\n+                    alloc: (*map.alloc).clone(),\n                     _marker: PhantomData,\n                 }),\n                 GoDown(handle) => Vacant(VacantEntry {\n                     key,\n                     handle: Some(handle),\n                     dormant_map,\n-                    alloc: &*map.alloc,\n+                    alloc: (*map.alloc).clone(),\n                     _marker: PhantomData,\n                 }),\n             },\n@@ -1289,22 +1308,18 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         A: Clone,\n     {\n         if self.is_empty() {\n-            return Self::new_in(ManuallyDrop::into_inner(self.alloc.clone()));\n+            return Self::new_in((*self.alloc).clone());\n         }\n \n         let total_num = self.len();\n         let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n \n-        let right_root = left_root.split_off(key, &*self.alloc);\n+        let right_root = left_root.split_off(key, (*self.alloc).clone());\n \n         let (new_left_len, right_len) = Root::calc_split_length(total_num, &left_root, &right_root);\n         self.length = new_left_len;\n \n-        BTreeMap {\n-            root: Some(right_root),\n-            length: right_len,\n-            alloc: ManuallyDrop::new((*self.alloc).clone()),\n-        }\n+        BTreeMap { root: Some(right_root), length: right_len, alloc: self.alloc.clone() }\n     }\n \n     /// Creates an iterator that visits all elements (key-value pairs) in\n@@ -1340,7 +1355,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n     /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), [1, 3, 5, 7]);\n     /// ```\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F, &A>\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F, A>\n     where\n         K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n@@ -1349,7 +1364,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         DrainFilter { pred, inner, alloc }\n     }\n \n-    pub(super) fn drain_filter_inner(&mut self) -> (DrainFilterInner<'_, K, V>, &A)\n+    pub(super) fn drain_filter_inner(&mut self) -> (DrainFilterInner<'_, K, V>, A)\n     where\n         K: Ord,\n     {\n@@ -1362,7 +1377,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n                     dormant_root: Some(dormant_root),\n                     cur_leaf_edge: Some(front),\n                 },\n-                &*self.alloc,\n+                (*self.alloc).clone(),\n             )\n         } else {\n             (\n@@ -1371,7 +1386,7 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n                     dormant_root: None,\n                     cur_leaf_edge: None,\n                 },\n-                &*self.alloc,\n+                (*self.alloc).clone(),\n             )\n         }\n     }\n@@ -1426,15 +1441,15 @@ impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n         K: Ord,\n         I: IntoIterator<Item = (K, V)>,\n     {\n-        let mut root = Root::new(&alloc);\n+        let mut root = Root::new(alloc.clone());\n         let mut length = 0;\n-        root.bulk_push(DedupSortedIter::new(iter.into_iter()), &mut length, &alloc);\n+        root.bulk_push(DedupSortedIter::new(iter.into_iter()), &mut length, alloc.clone());\n         BTreeMap { root: Some(root), length, alloc: ManuallyDrop::new(alloc) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, A: Allocator> IntoIterator for &'a BTreeMap<K, V, A> {\n+impl<'a, K, V, A: Allocator + Clone> IntoIterator for &'a BTreeMap<K, V, A> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -1503,7 +1518,7 @@ impl<K, V> Clone for Iter<'_, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, A: Allocator> IntoIterator for &'a mut BTreeMap<K, V, A> {\n+impl<'a, K, V, A: Allocator + Clone> IntoIterator for &'a mut BTreeMap<K, V, A> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n@@ -1573,7 +1588,7 @@ impl<'a, K, V> IterMut<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, A: Allocator> IntoIterator for BTreeMap<K, V, A> {\n+impl<K, V, A: Allocator + Clone> IntoIterator for BTreeMap<K, V, A> {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V, A>;\n \n@@ -1598,11 +1613,11 @@ impl<K, V, A: Allocator> IntoIterator for BTreeMap<K, V, A> {\n }\n \n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-impl<K, V, A: Allocator> Drop for IntoIter<K, V, A> {\n+impl<K, V, A: Allocator + Clone> Drop for IntoIter<K, V, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'a, K, V, A: Allocator>(&'a mut IntoIter<K, V, A>);\n+        struct DropGuard<'a, K, V, A: Allocator + Clone>(&'a mut IntoIter<K, V, A>);\n \n-        impl<'a, K, V, A: Allocator> Drop for DropGuard<'a, K, V, A> {\n+        impl<'a, K, V, A: Allocator + Clone> Drop for DropGuard<'a, K, V, A> {\n             fn drop(&mut self) {\n                 // Continue the same loop we perform below. This only runs when unwinding, so we\n                 // don't have to care about panics this time (they'll abort).\n@@ -1622,7 +1637,7 @@ impl<K, V, A: Allocator> Drop for IntoIter<K, V, A> {\n     }\n }\n \n-impl<K, V, A: Allocator> IntoIter<K, V, A> {\n+impl<K, V, A: Allocator + Clone> IntoIter<K, V, A> {\n     /// Core of a `next` method returning a dying KV handle,\n     /// invalidated by further calls to this function and some others.\n     fn dying_next(\n@@ -1653,7 +1668,7 @@ impl<K, V, A: Allocator> IntoIter<K, V, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, A: Allocator> Iterator for IntoIter<K, V, A> {\n+impl<K, V, A: Allocator + Clone> Iterator for IntoIter<K, V, A> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> {\n@@ -1667,22 +1682,22 @@ impl<K, V, A: Allocator> Iterator for IntoIter<K, V, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, A: Allocator> DoubleEndedIterator for IntoIter<K, V, A> {\n+impl<K, V, A: Allocator + Clone> DoubleEndedIterator for IntoIter<K, V, A> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n         // SAFETY: we consume the dying handle immediately.\n         self.dying_next_back().map(unsafe { |kv| kv.into_key_val() })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, A: Allocator> ExactSizeIterator for IntoIter<K, V, A> {\n+impl<K, V, A: Allocator + Clone> ExactSizeIterator for IntoIter<K, V, A> {\n     fn len(&self) -> usize {\n         self.length\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<K, V, A: Allocator> FusedIterator for IntoIter<K, V, A> {}\n+impl<K, V, A: Allocator + Clone> FusedIterator for IntoIter<K, V, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n@@ -1781,12 +1796,13 @@ pub struct DrainFilter<\n     K,\n     V,\n     F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > where\n     F: 'a + FnMut(&K, &mut V) -> bool,\n {\n     pred: F,\n     inner: DrainFilterInner<'a, K, V>,\n+    /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n     alloc: A,\n }\n /// Most of the implementation of DrainFilter are generic over the type\n@@ -1804,7 +1820,7 @@ pub(super) struct DrainFilterInner<'a, K, V> {\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F, A: Allocator> Drop for DrainFilter<'_, K, V, F, A>\n+impl<K, V, F, A: Allocator + Clone> Drop for DrainFilter<'_, K, V, F, A>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n@@ -1826,7 +1842,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F, A: Allocator> Iterator for DrainFilter<'_, K, V, F, A>\n+impl<K, V, F, A: Allocator + Clone> Iterator for DrainFilter<'_, K, V, F, A>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n@@ -1849,7 +1865,7 @@ impl<'a, K, V> DrainFilterInner<'a, K, V> {\n     }\n \n     /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n-    pub(super) fn next<F, A: Allocator>(&mut self, pred: &mut F, alloc: &A) -> Option<(K, V)>\n+    pub(super) fn next<F, A: Allocator + Clone>(&mut self, pred: &mut F, alloc: A) -> Option<(K, V)>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n@@ -1862,10 +1878,10 @@ impl<'a, K, V> DrainFilterInner<'a, K, V> {\n                         // SAFETY: we will touch the root in a way that will not\n                         // invalidate the position returned.\n                         let root = unsafe { self.dormant_root.take().unwrap().awaken() };\n-                        root.pop_internal_level(alloc);\n+                        root.pop_internal_level(alloc.clone());\n                         self.dormant_root = Some(DormantMutRef::new(root).1);\n                     },\n-                    alloc,\n+                    alloc.clone(),\n                 );\n                 self.cur_leaf_edge = Some(pos);\n                 return Some(kv);\n@@ -1944,7 +1960,7 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> Iterator for IntoKeys<K, V, A> {\n+impl<K, V, A: Allocator + Clone> Iterator for IntoKeys<K, V, A> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> {\n@@ -1969,24 +1985,24 @@ impl<K, V, A: Allocator> Iterator for IntoKeys<K, V, A> {\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> DoubleEndedIterator for IntoKeys<K, V, A> {\n+impl<K, V, A: Allocator + Clone> DoubleEndedIterator for IntoKeys<K, V, A> {\n     fn next_back(&mut self) -> Option<K> {\n         self.inner.next_back().map(|(k, _)| k)\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> ExactSizeIterator for IntoKeys<K, V, A> {\n+impl<K, V, A: Allocator + Clone> ExactSizeIterator for IntoKeys<K, V, A> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> FusedIterator for IntoKeys<K, V, A> {}\n+impl<K, V, A: Allocator + Clone> FusedIterator for IntoKeys<K, V, A> {}\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> Iterator for IntoValues<K, V, A> {\n+impl<K, V, A: Allocator + Clone> Iterator for IntoValues<K, V, A> {\n     type Item = V;\n \n     fn next(&mut self) -> Option<V> {\n@@ -2003,21 +2019,21 @@ impl<K, V, A: Allocator> Iterator for IntoValues<K, V, A> {\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> DoubleEndedIterator for IntoValues<K, V, A> {\n+impl<K, V, A: Allocator + Clone> DoubleEndedIterator for IntoValues<K, V, A> {\n     fn next_back(&mut self) -> Option<V> {\n         self.inner.next_back().map(|(_, v)| v)\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> ExactSizeIterator for IntoValues<K, V, A> {\n+impl<K, V, A: Allocator + Clone> ExactSizeIterator for IntoValues<K, V, A> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n-impl<K, V, A: Allocator> FusedIterator for IntoValues<K, V, A> {}\n+impl<K, V, A: Allocator + Clone> FusedIterator for IntoValues<K, V, A> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n@@ -2083,7 +2099,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V, A: Allocator> Extend<(K, V)> for BTreeMap<K, V, A> {\n+impl<K: Ord, V, A: Allocator + Clone> Extend<(K, V)> for BTreeMap<K, V, A> {\n     #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         iter.into_iter().for_each(move |(k, v)| {\n@@ -2098,7 +2114,9 @@ impl<K: Ord, V, A: Allocator> Extend<(K, V)> for BTreeMap<K, V, A> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, K: Ord + Copy, V: Copy, A: Allocator> Extend<(&'a K, &'a V)> for BTreeMap<K, V, A> {\n+impl<'a, K: Ord + Copy, V: Copy, A: Allocator + Clone> Extend<(&'a K, &'a V)>\n+    for BTreeMap<K, V, A>\n+{\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n@@ -2110,7 +2128,7 @@ impl<'a, K: Ord + Copy, V: Copy, A: Allocator> Extend<(&'a K, &'a V)> for BTreeM\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Hash, V: Hash, A: Allocator> Hash for BTreeMap<K, V, A> {\n+impl<K: Hash, V: Hash, A: Allocator + Clone> Hash for BTreeMap<K, V, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         state.write_length_prefix(self.len());\n         for elt in self {\n@@ -2128,40 +2146,40 @@ impl<K, V> Default for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: PartialEq, V: PartialEq, A: Allocator> PartialEq for BTreeMap<K, V, A> {\n+impl<K: PartialEq, V: PartialEq, A: Allocator + Clone> PartialEq for BTreeMap<K, V, A> {\n     fn eq(&self, other: &BTreeMap<K, V, A>) -> bool {\n         self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Eq, V: Eq, A: Allocator> Eq for BTreeMap<K, V, A> {}\n+impl<K: Eq, V: Eq, A: Allocator + Clone> Eq for BTreeMap<K, V, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: PartialOrd, V: PartialOrd, A: Allocator> PartialOrd for BTreeMap<K, V, A> {\n+impl<K: PartialOrd, V: PartialOrd, A: Allocator + Clone> PartialOrd for BTreeMap<K, V, A> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V, A>) -> Option<Ordering> {\n         self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V: Ord, A: Allocator> Ord for BTreeMap<K, V, A> {\n+impl<K: Ord, V: Ord, A: Allocator + Clone> Ord for BTreeMap<K, V, A> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V, A>) -> Ordering {\n         self.iter().cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Debug, V: Debug, A: Allocator> Debug for BTreeMap<K, V, A> {\n+impl<K: Debug, V: Debug, A: Allocator + Clone> Debug for BTreeMap<K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, A: Allocator> Index<&Q> for BTreeMap<K, V, A>\n+impl<K, Q: ?Sized, V, A: Allocator + Clone> Index<&Q> for BTreeMap<K, V, A>\n where\n     K: Borrow<Q> + Ord,\n     Q: Ord,\n@@ -2201,7 +2219,7 @@ impl<K: Ord, V, const N: usize> From<[(K, V); N]> for BTreeMap<K, V> {\n     }\n }\n \n-impl<K, V, A: Allocator> BTreeMap<K, V, A> {\n+impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n     /// # Examples"}, {"sha": "b6eecf9b0e95266550fd5e391b1352383aec45f0", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -21,7 +21,7 @@ pub enum Entry<\n     'a,\n     K: 'a,\n     V: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     /// A vacant entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -33,7 +33,7 @@ pub enum Entry<\n }\n \n #[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for Entry<'_, K, V, A> {\n+impl<K: Debug + Ord, V: Debug, A: Allocator + Clone> Debug for Entry<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n@@ -49,21 +49,22 @@ pub struct VacantEntry<\n     'a,\n     K,\n     V,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     pub(super) key: K,\n     /// `None` for a (empty) map without root\n     pub(super) handle: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n     pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V, A>>,\n \n-    pub(super) alloc: &'a A,\n+    /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n+    pub(super) alloc: A,\n \n     // Be invariant in `K` and `V`\n     pub(super) _marker: PhantomData<&'a mut (K, V)>,\n }\n \n #[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V, A: Allocator> Debug for VacantEntry<'_, K, V, A> {\n+impl<K: Debug + Ord, V, A: Allocator + Clone> Debug for VacantEntry<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n     }\n@@ -76,19 +77,20 @@ pub struct OccupiedEntry<\n     'a,\n     K,\n     V,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n     pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V, A>>,\n \n-    pub(super) alloc: &'a A,\n+    /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n+    pub(super) alloc: A,\n \n     // Be invariant in `K` and `V`\n     pub(super) _marker: PhantomData<&'a mut (K, V)>,\n }\n \n #[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for OccupiedEntry<'_, K, V, A> {\n+impl<K: Debug + Ord, V: Debug, A: Allocator + Clone> Debug for OccupiedEntry<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n     }\n@@ -98,15 +100,15 @@ impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for OccupiedEntry<'_, K, V, A\n ///\n /// Contains the occupied entry, and the value that was not inserted.\n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-pub struct OccupiedError<'a, K: 'a, V: 'a, A: Allocator = Global> {\n+pub struct OccupiedError<'a, K: 'a, V: 'a, A: Allocator + Clone = Global> {\n     /// The entry in the map that was already occupied.\n     pub entry: OccupiedEntry<'a, K, V, A>,\n     /// The value which was not inserted, because the entry was already occupied.\n     pub value: V,\n }\n \n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for OccupiedError<'_, K, V, A> {\n+impl<K: Debug + Ord, V: Debug, A: Allocator + Clone> Debug for OccupiedError<'_, K, V, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OccupiedError\")\n             .field(\"key\", self.entry.key())\n@@ -117,7 +119,9 @@ impl<K: Debug + Ord, V: Debug, A: Allocator> Debug for OccupiedError<'_, K, V, A\n }\n \n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n-impl<'a, K: Debug + Ord, V: Debug, A: Allocator> fmt::Display for OccupiedError<'a, K, V, A> {\n+impl<'a, K: Debug + Ord, V: Debug, A: Allocator + Clone> fmt::Display\n+    for OccupiedError<'a, K, V, A>\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -129,7 +133,7 @@ impl<'a, K: Debug + Ord, V: Debug, A: Allocator> fmt::Display for OccupiedError<\n     }\n }\n \n-impl<'a, K: Ord, V, A: Allocator> Entry<'a, K, V, A> {\n+impl<'a, K: Ord, V, A: Allocator + Clone> Entry<'a, K, V, A> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n     ///\n@@ -257,7 +261,7 @@ impl<'a, K: Ord, V, A: Allocator> Entry<'a, K, V, A> {\n     }\n }\n \n-impl<'a, K: Ord, V: Default, A: Allocator> Entry<'a, K, V, A> {\n+impl<'a, K: Ord, V: Default, A: Allocator + Clone> Entry<'a, K, V, A> {\n     #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n     /// Ensures a value is in the entry by inserting the default value if empty,\n     /// and returns a mutable reference to the value in the entry.\n@@ -280,7 +284,7 @@ impl<'a, K: Ord, V: Default, A: Allocator> Entry<'a, K, V, A> {\n     }\n }\n \n-impl<'a, K: Ord, V, A: Allocator> VacantEntry<'a, K, V, A> {\n+impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n     ///\n@@ -338,13 +342,13 @@ impl<'a, K: Ord, V, A: Allocator> VacantEntry<'a, K, V, A> {\n             None => {\n                 // SAFETY: There is no tree yet so no reference to it exists.\n                 let map = unsafe { self.dormant_map.awaken() };\n-                let mut root = NodeRef::new_leaf(self.alloc);\n+                let mut root = NodeRef::new_leaf(self.alloc.clone());\n                 let val_ptr = root.borrow_mut().push(self.key, value) as *mut V;\n                 map.root = Some(root.forget_type());\n                 map.length = 1;\n                 val_ptr\n             }\n-            Some(handle) => match handle.insert_recursing(self.key, value, self.alloc) {\n+            Some(handle) => match handle.insert_recursing(self.key, value, self.alloc.clone()) {\n                 (None, val_ptr) => {\n                     // SAFETY: We have consumed self.handle.\n                     let map = unsafe { self.dormant_map.awaken() };\n@@ -369,7 +373,7 @@ impl<'a, K: Ord, V, A: Allocator> VacantEntry<'a, K, V, A> {\n     }\n }\n \n-impl<'a, K: Ord, V, A: Allocator> OccupiedEntry<'a, K, V, A> {\n+impl<'a, K: Ord, V, A: Allocator + Clone> OccupiedEntry<'a, K, V, A> {\n     /// Gets a reference to the key in the entry.\n     ///\n     /// # Examples\n@@ -538,13 +542,13 @@ impl<'a, K: Ord, V, A: Allocator> OccupiedEntry<'a, K, V, A> {\n     pub(super) fn remove_kv(self) -> (K, V) {\n         let mut emptied_internal_root = false;\n         let (old_kv, _) =\n-            self.handle.remove_kv_tracking(|| emptied_internal_root = true, self.alloc);\n+            self.handle.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n         // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n         let map = unsafe { self.dormant_map.awaken() };\n         map.length -= 1;\n         if emptied_internal_root {\n             let root = map.root.as_mut().unwrap();\n-            root.pop_internal_level(&*self.alloc);\n+            root.pop_internal_level(self.alloc);\n         }\n         old_kv\n     }"}, {"sha": "5504959c34d8709e97ed089761c43f97b488d0fa", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -116,11 +116,7 @@ impl<K, V> BTreeMap<K, V> {\n     {\n         let iter = mem::take(self).into_iter();\n         if !iter.is_empty() {\n-            self.root.insert(Root::new(&*self.alloc)).bulk_push(\n-                iter,\n-                &mut self.length,\n-                &*self.alloc,\n-            );\n+            self.root.insert(Root::new(*self.alloc)).bulk_push(iter, &mut self.length, *self.alloc);\n         }\n     }\n }"}, {"sha": "1e33c1e64d66e085a09cc51b86210556d92f4b11", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -178,27 +178,27 @@ impl<K, V> LazyLeafRange<marker::Dying, K, V> {\n     }\n \n     #[inline]\n-    pub unsafe fn deallocating_next_unchecked<A: Allocator>(\n+    pub unsafe fn deallocating_next_unchecked<A: Allocator + Clone>(\n         &mut self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         debug_assert!(self.front.is_some());\n         let front = self.init_front().unwrap();\n         unsafe { front.deallocating_next_unchecked(alloc) }\n     }\n \n     #[inline]\n-    pub unsafe fn deallocating_next_back_unchecked<A: Allocator>(\n+    pub unsafe fn deallocating_next_back_unchecked<A: Allocator + Clone>(\n         &mut self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         debug_assert!(self.back.is_some());\n         let back = self.init_back().unwrap();\n         unsafe { back.deallocating_next_back_unchecked(alloc) }\n     }\n \n     #[inline]\n-    pub fn deallocating_end<A: Allocator>(&mut self, alloc: &A) {\n+    pub fn deallocating_end<A: Allocator + Clone>(&mut self, alloc: A) {\n         if let Some(front) = self.take_front() {\n             front.deallocating_end(alloc)\n         }\n@@ -444,17 +444,17 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///   `deallocating_next_back`.\n     /// - The returned KV handle is only valid to access the key and value,\n     ///   and only valid until the next call to a `deallocating_` method.\n-    unsafe fn deallocating_next<A: Allocator>(\n+    unsafe fn deallocating_next<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n     {\n         let mut edge = self.forget_node_type();\n         loop {\n             edge = match edge.right_kv() {\n                 Ok(kv) => return Some((unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)),\n                 Err(last_edge) => {\n-                    match unsafe { last_edge.into_node().deallocate_and_ascend(alloc) } {\n+                    match unsafe { last_edge.into_node().deallocate_and_ascend(alloc.clone()) } {\n                         Some(parent_edge) => parent_edge.forget_node_type(),\n                         None => return None,\n                     }\n@@ -476,17 +476,17 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///   `deallocating_next`.\n     /// - The returned KV handle is only valid to access the key and value,\n     ///   and only valid until the next call to a `deallocating_` method.\n-    unsafe fn deallocating_next_back<A: Allocator>(\n+    unsafe fn deallocating_next_back<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n     {\n         let mut edge = self.forget_node_type();\n         loop {\n             edge = match edge.left_kv() {\n                 Ok(kv) => return Some((unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)),\n                 Err(last_edge) => {\n-                    match unsafe { last_edge.into_node().deallocate_and_ascend(alloc) } {\n+                    match unsafe { last_edge.into_node().deallocate_and_ascend(alloc.clone()) } {\n                         Some(parent_edge) => parent_edge.forget_node_type(),\n                         None => return None,\n                     }\n@@ -501,9 +501,11 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// both sides of the tree, and have hit the same edge. As it is intended\n     /// only to be called when all keys and values have been returned,\n     /// no cleanup is done on any of the keys or values.\n-    fn deallocating_end<A: Allocator>(self, alloc: &A) {\n+    fn deallocating_end<A: Allocator + Clone>(self, alloc: A) {\n         let mut edge = self.forget_node_type();\n-        while let Some(parent_edge) = unsafe { edge.into_node().deallocate_and_ascend(alloc) } {\n+        while let Some(parent_edge) =\n+            unsafe { edge.into_node().deallocate_and_ascend(alloc.clone()) }\n+        {\n             edge = parent_edge.forget_node_type();\n         }\n     }\n@@ -578,9 +580,9 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// or call this method or counterpart `deallocating_next_back_unchecked` again.\n-    unsafe fn deallocating_next_unchecked<A: Allocator>(\n+    unsafe fn deallocating_next_unchecked<A: Allocator + Clone>(\n         &mut self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe {\n             leaf_edge.deallocating_next(alloc).unwrap()\n@@ -599,9 +601,9 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// or call this method or counterpart `deallocating_next_unchecked` again.\n-    unsafe fn deallocating_next_back_unchecked<A: Allocator>(\n+    unsafe fn deallocating_next_back_unchecked<A: Allocator + Clone>(\n         &mut self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe {\n             leaf_edge.deallocating_next_back(alloc).unwrap()"}, {"sha": "d831161bcb6862d810b401fbaa2545f77d047e19", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -78,7 +78,7 @@ impl<K, V> LeafNode<K, V> {\n     }\n \n     /// Creates a new boxed `LeafNode`.\n-    fn new<A: Allocator>(alloc: &A) -> Box<Self, &A> {\n+    fn new<A: Allocator + Clone>(alloc: A) -> Box<Self, A> {\n         unsafe {\n             let mut leaf = Box::new_uninit_in(alloc);\n             LeafNode::init(leaf.as_mut_ptr());\n@@ -110,7 +110,7 @@ impl<K, V> InternalNode<K, V> {\n     /// An invariant of internal nodes is that they have at least one\n     /// initialized and valid edge. This function does not set up\n     /// such an edge.\n-    unsafe fn new<A: Allocator>(alloc: &A) -> Box<Self, &A> {\n+    unsafe fn new<A: Allocator + Clone>(alloc: A) -> Box<Self, A> {\n         unsafe {\n             let mut node = Box::<Self, _>::new_uninit_in(alloc);\n             // We only need to initialize the data; the edges are MaybeUninit.\n@@ -213,25 +213,25 @@ unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type>\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Dying, K, V, Type> {}\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    pub fn new_leaf<A: Allocator>(alloc: &A) -> Self {\n+    pub fn new_leaf<A: Allocator + Clone>(alloc: A) -> Self {\n         Self::from_new_leaf(LeafNode::new(alloc))\n     }\n \n-    fn from_new_leaf<A: Allocator>(leaf: Box<LeafNode<K, V>, A>) -> Self {\n+    fn from_new_leaf<A: Allocator + Clone>(leaf: Box<LeafNode<K, V>, A>) -> Self {\n         NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }\n     }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n-    fn new_internal<A: Allocator>(child: Root<K, V>, alloc: &A) -> Self {\n+    fn new_internal<A: Allocator + Clone>(child: Root<K, V>, alloc: A) -> Self {\n         let mut new_node = unsafe { InternalNode::new(alloc) };\n         new_node.edges[0].write(child.node);\n         unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }\n     }\n \n     /// # Safety\n     /// `height` must not be zero.\n-    unsafe fn from_new_internal<A: Allocator>(\n+    unsafe fn from_new_internal<A: Allocator + Clone>(\n         internal: Box<InternalNode<K, V>, A>,\n         height: usize,\n     ) -> Self {\n@@ -390,9 +390,9 @@ impl<K, V> NodeRef<marker::Dying, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocates the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n-    pub unsafe fn deallocate_and_ascend<A: Allocator>(\n+    pub unsafe fn deallocate_and_ascend<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Internal>, marker::Edge>> {\n         let height = self.height;\n         let node = self.node;\n@@ -559,16 +559,16 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Returns a new owned tree, with its own root node that is initially empty.\n-    pub fn new<A: Allocator>(alloc: &A) -> Self {\n+    pub fn new<A: Allocator + Clone>(alloc: A) -> Self {\n         NodeRef::new_leaf(alloc).forget_type()\n     }\n \n     /// Adds a new internal node with a single edge pointing to the previous root node,\n     /// make that new node the root node, and return it. This increases the height by 1\n     /// and is the opposite of `pop_internal_level`.\n-    pub fn push_internal_level<A: Allocator>(\n+    pub fn push_internal_level<A: Allocator + Clone>(\n         &mut self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         super::mem::take_mut(self, |old_root| NodeRef::new_internal(old_root, alloc).forget_type());\n \n@@ -585,7 +585,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// it will not invalidate other handles or references to the root node.\n     ///\n     /// Panics if there is no internal level, i.e., if the root node is a leaf.\n-    pub fn pop_internal_level<A: Allocator>(&mut self, alloc: &A) {\n+    pub fn pop_internal_level<A: Allocator + Clone>(&mut self, alloc: A) {\n         assert!(self.height > 0);\n \n         let top = self.node;\n@@ -869,11 +869,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n     /// The returned pointer points to the inserted value.\n-    fn insert<A: Allocator>(\n+    fn insert<A: Allocator + Clone>(\n         mut self,\n         key: K,\n         val: V,\n-        alloc: &A,\n+        alloc: A,\n     ) -> (Option<SplitResult<'a, K, V, marker::Leaf>>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let val_ptr = self.insert_fit(key, val);\n@@ -930,12 +930,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// Inserts a new key-value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key-value pair to the right of this edge. This method splits\n     /// the node if there isn't enough room.\n-    fn insert<A: Allocator>(\n+    fn insert<A: Allocator + Clone>(\n         mut self,\n         key: K,\n         val: V,\n         edge: Root<K, V>,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Option<SplitResult<'a, K, V, marker::Internal>> {\n         assert!(edge.height == self.node.height - 1);\n \n@@ -968,23 +968,25 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// If the returned result is some `SplitResult`, the `left` field will be the root node.\n     /// The returned pointer points to the inserted value, which in the case of `SplitResult`\n     /// is in the `left` or `right` tree.\n-    pub fn insert_recursing<A: Allocator>(\n+    pub fn insert_recursing<A: Allocator + Clone>(\n         self,\n         key: K,\n         value: V,\n-        alloc: &A,\n+        alloc: A,\n     ) -> (Option<SplitResult<'a, K, V, marker::LeafOrInternal>>, *mut V) {\n-        let (mut split, val_ptr) = match self.insert(key, value, alloc) {\n+        let (mut split, val_ptr) = match self.insert(key, value, alloc.clone()) {\n             (None, val_ptr) => return (None, val_ptr),\n             (Some(split), val_ptr) => (split.forget_node_type(), val_ptr),\n         };\n \n         loop {\n             split = match split.left.ascend() {\n-                Ok(parent) => match parent.insert(split.kv.0, split.kv.1, split.right, alloc) {\n-                    None => return (None, val_ptr),\n-                    Some(split) => split.forget_node_type(),\n-                },\n+                Ok(parent) => {\n+                    match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {\n+                        None => return (None, val_ptr),\n+                        Some(split) => split.forget_node_type(),\n+                    }\n+                }\n                 Err(root) => return (Some(SplitResult { left: root, ..split }), val_ptr),\n             };\n         }\n@@ -1126,7 +1128,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the key-value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n-    pub fn split<A: Allocator>(mut self, alloc: &A) -> SplitResult<'a, K, V, marker::Leaf> {\n+    pub fn split<A: Allocator + Clone>(mut self, alloc: A) -> SplitResult<'a, K, V, marker::Leaf> {\n         let mut new_node = LeafNode::new(alloc);\n \n         let kv = self.split_leaf_data(&mut new_node);\n@@ -1158,7 +1160,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the edges and key-value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n-    pub fn split<A: Allocator>(mut self, alloc: &A) -> SplitResult<'a, K, V, marker::Internal> {\n+    pub fn split<A: Allocator + Clone>(\n+        mut self,\n+        alloc: A,\n+    ) -> SplitResult<'a, K, V, marker::Internal> {\n         let old_len = self.node.len();\n         unsafe {\n             let mut new_node = InternalNode::new(alloc);\n@@ -1270,7 +1275,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     >(\n         self,\n         result: F,\n-        alloc: &A,\n+        alloc: A,\n     ) -> R {\n         let Handle { node: mut parent_node, idx: parent_idx, _marker } = self.parent;\n         let old_parent_len = parent_node.len();\n@@ -1327,9 +1332,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     /// the left child node and returns the shrunk parent node.\n     ///\n     /// Panics unless we `.can_merge()`.\n-    pub fn merge_tracking_parent<A: Allocator>(\n+    pub fn merge_tracking_parent<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         self.do_merge(|parent, _child| parent, alloc)\n     }\n@@ -1338,9 +1343,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     /// the left child node and returns that child node.\n     ///\n     /// Panics unless we `.can_merge()`.\n-    pub fn merge_tracking_child<A: Allocator>(\n+    pub fn merge_tracking_child<A: Allocator + Clone>(\n         self,\n-        alloc: &A,\n+        alloc: A,\n     ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         self.do_merge(|_parent, child| child, alloc)\n     }\n@@ -1350,10 +1355,10 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     /// where the tracked child edge ended up,\n     ///\n     /// Panics unless we `.can_merge()`.\n-    pub fn merge_tracking_child_edge<A: Allocator>(\n+    pub fn merge_tracking_child_edge<A: Allocator + Clone>(\n         self,\n         track_edge_idx: LeftOrRight<usize>,\n-        alloc: &A,\n+        alloc: A,\n     ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n         let old_left_len = self.left_child.len();\n         let right_len = self.right_child.len();"}, {"sha": "0904299254f0a3312c83aaf310fd50a27682b7fa", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -7,10 +7,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n     /// the leaf edge corresponding to that former pair. It's possible this empties\n     /// a root node that is internal, which the caller should pop from the map\n     /// holding the tree. The caller should also decrement the map's length.\n-    pub fn remove_kv_tracking<F: FnOnce(), A: Allocator>(\n+    pub fn remove_kv_tracking<F: FnOnce(), A: Allocator + Clone>(\n         self,\n         handle_emptied_internal_root: F,\n-        alloc: &A,\n+        alloc: A,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         match self.force() {\n             Leaf(node) => node.remove_leaf_kv(handle_emptied_internal_root, alloc),\n@@ -20,10 +20,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n-    fn remove_leaf_kv<F: FnOnce(), A: Allocator>(\n+    fn remove_leaf_kv<F: FnOnce(), A: Allocator + Clone>(\n         self,\n         handle_emptied_internal_root: F,\n-        alloc: &A,\n+        alloc: A,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         let (old_kv, mut pos) = self.remove();\n         let len = pos.reborrow().into_node().len();\n@@ -35,7 +35,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n                 Ok(Left(left_parent_kv)) => {\n                     debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n                     if left_parent_kv.can_merge() {\n-                        left_parent_kv.merge_tracking_child_edge(Right(idx), alloc)\n+                        left_parent_kv.merge_tracking_child_edge(Right(idx), alloc.clone())\n                     } else {\n                         debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n                         left_parent_kv.steal_left(idx)\n@@ -44,7 +44,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n                 Ok(Right(right_parent_kv)) => {\n                     debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n                     if right_parent_kv.can_merge() {\n-                        right_parent_kv.merge_tracking_child_edge(Left(idx), alloc)\n+                        right_parent_kv.merge_tracking_child_edge(Left(idx), alloc.clone())\n                     } else {\n                         debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n                         right_parent_kv.steal_right(idx)\n@@ -73,10 +73,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n-    fn remove_internal_kv<F: FnOnce(), A: Allocator>(\n+    fn remove_internal_kv<F: FnOnce(), A: Allocator + Clone>(\n         self,\n         handle_emptied_internal_root: F,\n-        alloc: &A,\n+        alloc: A,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         // Remove an adjacent KV from its leaf and then put it back in place of\n         // the element we were asked to remove. Prefer the left adjacent KV,"}, {"sha": "bec3b9675254c1b24add6f6e9442aa599944b5a9", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -79,37 +79,37 @@ use crate::alloc::{Allocator, Global};\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeSet\")]\n pub struct BTreeSet<\n     T,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     map: BTreeMap<T, (), A>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash, A: Allocator> Hash for BTreeSet<T, A> {\n+impl<T: Hash, A: Allocator + Clone> Hash for BTreeSet<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.map.hash(state)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq, A: Allocator> PartialEq for BTreeSet<T, A> {\n+impl<T: PartialEq, A: Allocator + Clone> PartialEq for BTreeSet<T, A> {\n     fn eq(&self, other: &BTreeSet<T, A>) -> bool {\n         self.map.eq(&other.map)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq, A: Allocator> Eq for BTreeSet<T, A> {}\n+impl<T: Eq, A: Allocator + Clone> Eq for BTreeSet<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd, A: Allocator> PartialOrd for BTreeSet<T, A> {\n+impl<T: PartialOrd, A: Allocator + Clone> PartialOrd for BTreeSet<T, A> {\n     fn partial_cmp(&self, other: &BTreeSet<T, A>) -> Option<Ordering> {\n         self.map.partial_cmp(&other.map)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord, A: Allocator> Ord for BTreeSet<T, A> {\n+impl<T: Ord, A: Allocator + Clone> Ord for BTreeSet<T, A> {\n     fn cmp(&self, other: &BTreeSet<T, A>) -> Ordering {\n         self.map.cmp(&other.map)\n     }\n@@ -156,7 +156,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n #[derive(Debug)]\n pub struct IntoIter<\n     T,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     iter: super::map::IntoIter<T, (), A>,\n }\n@@ -186,11 +186,11 @@ pub struct Range<'a, T: 'a> {\n pub struct Difference<\n     'a,\n     T: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     inner: DifferenceInner<'a, T, A>,\n }\n-enum DifferenceInner<'a, T: 'a, A: Allocator> {\n+enum DifferenceInner<'a, T: 'a, A: Allocator + Clone> {\n     Stitch {\n         // iterate all of `self` and some of `other`, spotting matches along the way\n         self_iter: Iter<'a, T>,\n@@ -205,7 +205,7 @@ enum DifferenceInner<'a, T: 'a, A: Allocator> {\n }\n \n // Explicit Debug impl necessary because of issue #26925\n-impl<T: Debug, A: Allocator> Debug for DifferenceInner<'_, T, A> {\n+impl<T: Debug, A: Allocator + Clone> Debug for DifferenceInner<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             DifferenceInner::Stitch { self_iter, other_iter } => f\n@@ -224,7 +224,7 @@ impl<T: Debug, A: Allocator> Debug for DifferenceInner<'_, T, A> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for Difference<'_, T, A> {\n+impl<T: fmt::Debug, A: Allocator + Clone> fmt::Debug for Difference<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n@@ -260,11 +260,11 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n pub struct Intersection<\n     'a,\n     T: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n     inner: IntersectionInner<'a, T, A>,\n }\n-enum IntersectionInner<'a, T: 'a, A: Allocator> {\n+enum IntersectionInner<'a, T: 'a, A: Allocator + Clone> {\n     Stitch {\n         // iterate similarly sized sets jointly, spotting matches along the way\n         a: Iter<'a, T>,\n@@ -279,7 +279,7 @@ enum IntersectionInner<'a, T: 'a, A: Allocator> {\n }\n \n // Explicit Debug impl necessary because of issue #26925\n-impl<T: Debug, A: Allocator> Debug for IntersectionInner<'_, T, A> {\n+impl<T: Debug, A: Allocator + Clone> Debug for IntersectionInner<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             IntersectionInner::Stitch { a, b } => {\n@@ -296,7 +296,7 @@ impl<T: Debug, A: Allocator> Debug for IntersectionInner<'_, T, A> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: Debug, A: Allocator> Debug for Intersection<'_, T, A> {\n+impl<T: Debug, A: Allocator + Clone> Debug for Intersection<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n@@ -349,7 +349,7 @@ impl<T> BTreeSet<T> {\n     }\n }\n \n-impl<T, A: Allocator> BTreeSet<T, A> {\n+impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// Makes a new `BTreeSet` with a reasonable choice of B.\n     ///\n     /// # Examples\n@@ -1208,7 +1208,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n-impl<T: Ord, A: Allocator> BTreeSet<T, A> {\n+impl<T: Ord, A: Allocator + Clone> BTreeSet<T, A> {\n     fn from_sorted_iter<I: Iterator<Item = T>>(iter: I, alloc: A) -> BTreeSet<T, A> {\n         let iter = iter.map(|k| (k, ()));\n         let map = BTreeMap::bulk_build_from_sorted_iter(iter, alloc);\n@@ -1241,7 +1241,7 @@ impl<T: Ord, const N: usize> From<[T; N]> for BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> IntoIterator for BTreeSet<T, A> {\n+impl<T, A: Allocator + Clone> IntoIterator for BTreeSet<T, A> {\n     type Item = T;\n     type IntoIter = IntoIter<T, A>;\n \n@@ -1263,7 +1263,7 @@ impl<T, A: Allocator> IntoIterator for BTreeSet<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, A: Allocator> IntoIterator for &'a BTreeSet<T, A> {\n+impl<'a, T, A: Allocator + Clone> IntoIterator for &'a BTreeSet<T, A> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1278,18 +1278,19 @@ pub struct DrainFilter<\n     'a,\n     T,\n     F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > where\n     T: 'a,\n     F: 'a + FnMut(&T) -> bool,\n {\n     pred: F,\n     inner: super::map::DrainFilterInner<'a, T, ()>,\n-    alloc: &'a A,\n+    /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n+    alloc: A,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n+impl<T, F, A: Allocator + Clone> Drop for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&T) -> bool,\n {\n@@ -1299,7 +1300,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator> fmt::Debug for DrainFilter<'_, T, F, A>\n+impl<T, F, A: Allocator + Clone> fmt::Debug for DrainFilter<'_, T, F, A>\n where\n     T: fmt::Debug,\n     F: FnMut(&T) -> bool,\n@@ -1310,7 +1311,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n+impl<'a, T, F, A: Allocator + Clone> Iterator for DrainFilter<'_, T, F, A>\n where\n     F: 'a + FnMut(&T) -> bool,\n {\n@@ -1328,10 +1329,13 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator> FusedIterator for DrainFilter<'_, T, F, A> where F: FnMut(&T) -> bool {}\n+impl<T, F, A: Allocator + Clone> FusedIterator for DrainFilter<'_, T, F, A> where\n+    F: FnMut(&T) -> bool\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord, A: Allocator> Extend<T> for BTreeSet<T, A> {\n+impl<T: Ord, A: Allocator + Clone> Extend<T> for BTreeSet<T, A> {\n     #[inline]\n     fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {\n         iter.into_iter().for_each(move |elem| {\n@@ -1346,7 +1350,7 @@ impl<T: Ord, A: Allocator> Extend<T> for BTreeSet<T, A> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Ord + Copy, A: Allocator> Extend<&'a T> for BTreeSet<T, A> {\n+impl<'a, T: 'a + Ord + Copy, A: Allocator + Clone> Extend<&'a T> for BTreeSet<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n@@ -1466,7 +1470,7 @@ impl<T: Ord + Clone, A: Allocator + Clone> BitOr<&BTreeSet<T, A>> for &BTreeSet<\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Debug, A: Allocator> Debug for BTreeSet<T, A> {\n+impl<T: Debug, A: Allocator + Clone> Debug for BTreeSet<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_set().entries(self.iter()).finish()\n     }\n@@ -1519,7 +1523,7 @@ impl<T> ExactSizeIterator for Iter<'_, T> {\n impl<T> FusedIterator for Iter<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n+impl<T, A: Allocator + Clone> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n@@ -1531,20 +1535,20 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n+impl<T, A: Allocator + Clone> DoubleEndedIterator for IntoIter<T, A> {\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|(k, _)| k)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+impl<T, A: Allocator + Clone> ExactSizeIterator for IntoIter<T, A> {\n     fn len(&self) -> usize {\n         self.iter.len()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n+impl<T, A: Allocator + Clone> FusedIterator for IntoIter<T, A> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<T> Clone for Range<'_, T> {\n@@ -1602,7 +1606,7 @@ impl<T, A: Allocator + Clone> Clone for Difference<'_, T, A> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Ord, A: Allocator> Iterator for Difference<'a, T, A> {\n+impl<'a, T: Ord, A: Allocator + Clone> Iterator for Difference<'a, T, A> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n@@ -1649,7 +1653,7 @@ impl<'a, T: Ord, A: Allocator> Iterator for Difference<'a, T, A> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T: Ord, A: Allocator> FusedIterator for Difference<'_, T, A> {}\n+impl<T: Ord, A: Allocator + Clone> FusedIterator for Difference<'_, T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n@@ -1703,7 +1707,7 @@ impl<T, A: Allocator + Clone> Clone for Intersection<'_, T, A> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Ord, A: Allocator> Iterator for Intersection<'a, T, A> {\n+impl<'a, T: Ord, A: Allocator + Clone> Iterator for Intersection<'a, T, A> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n@@ -1744,7 +1748,7 @@ impl<'a, T: Ord, A: Allocator> Iterator for Intersection<'a, T, A> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T: Ord, A: Allocator> FusedIterator for Intersection<'_, T, A> {}\n+impl<T: Ord, A: Allocator + Clone> FusedIterator for Intersection<'_, T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {"}, {"sha": "638dc98fc3e41b10a7c83190d1552c4c23cad60b", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff86b27e7be1ffff9e00d80beb15560d5f301459/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=ff86b27e7be1ffff9e00d80beb15560d5f301459", "patch": "@@ -29,12 +29,12 @@ impl<K, V> Root<K, V> {\n     /// and if the ordering of `Q` corresponds to that of `K`.\n     /// If `self` respects all `BTreeMap` tree invariants, then both\n     /// `self` and the returned tree will respect those invariants.\n-    pub fn split_off<Q: ?Sized + Ord, A: Allocator>(&mut self, key: &Q, alloc: &A) -> Self\n+    pub fn split_off<Q: ?Sized + Ord, A: Allocator + Clone>(&mut self, key: &Q, alloc: A) -> Self\n     where\n         K: Borrow<Q>,\n     {\n         let left_root = self;\n-        let mut right_root = Root::new_pillar(left_root.height(), alloc);\n+        let mut right_root = Root::new_pillar(left_root.height(), alloc.clone());\n         let mut left_node = left_root.borrow_mut();\n         let mut right_node = right_root.borrow_mut();\n \n@@ -57,16 +57,16 @@ impl<K, V> Root<K, V> {\n             }\n         }\n \n-        left_root.fix_right_border(alloc);\n+        left_root.fix_right_border(alloc.clone());\n         right_root.fix_left_border(alloc);\n         right_root\n     }\n \n     /// Creates a tree consisting of empty nodes.\n-    fn new_pillar<A: Allocator>(height: usize, alloc: &A) -> Self {\n-        let mut root = Root::new(alloc);\n+    fn new_pillar<A: Allocator + Clone>(height: usize, alloc: A) -> Self {\n+        let mut root = Root::new(alloc.clone());\n         for _ in 0..height {\n-            root.push_internal_level(alloc);\n+            root.push_internal_level(alloc.clone());\n         }\n         root\n     }"}]}