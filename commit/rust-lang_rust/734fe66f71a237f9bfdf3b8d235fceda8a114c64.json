{"sha": "734fe66f71a237f9bfdf3b8d235fceda8a114c64", "node_id": "C_kwDOAAsO6NoAKDczNGZlNjZmNzFhMjM3ZjliZmRmM2I4ZDIzNWZjZWRhOGExMTRjNjQ", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2023-04-26T21:07:06Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2023-04-26T21:07:06Z"}, "message": "Handle nested types in `unwrap_result_return_type` assist", "tree": {"sha": "0080da29111323087227cfe695041491295cce4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0080da29111323087227cfe695041491295cce4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/734fe66f71a237f9bfdf3b8d235fceda8a114c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/734fe66f71a237f9bfdf3b8d235fceda8a114c64", "html_url": "https://github.com/rust-lang/rust/commit/734fe66f71a237f9bfdf3b8d235fceda8a114c64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/734fe66f71a237f9bfdf3b8d235fceda8a114c64/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "797c2f1dde0905afa24f567160ed23ba2bc79a81", "url": "https://api.github.com/repos/rust-lang/rust/commits/797c2f1dde0905afa24f567160ed23ba2bc79a81", "html_url": "https://github.com/rust-lang/rust/commit/797c2f1dde0905afa24f567160ed23ba2bc79a81"}], "stats": {"total": 122, "additions": 99, "deletions": 23}, "files": [{"sha": "8b6c614219d934be7cb98c5793fb023cb9651702", "filename": "crates/ide-assists/src/handlers/unwrap_result_return_type.rs", "status": "modified", "additions": 99, "deletions": 23, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/734fe66f71a237f9bfdf3b8d235fceda8a114c64/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734fe66f71a237f9bfdf3b8d235fceda8a114c64/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs?ref=734fe66f71a237f9bfdf3b8d235fceda8a114c64", "patch": "@@ -5,7 +5,7 @@ use ide_db::{\n use itertools::Itertools;\n use syntax::{\n     ast::{self, Expr},\n-    match_ast, AstNode, TextRange, TextSize,\n+    match_ast, AstNode, NodeOrToken, SyntaxKind, TextRange, TextSize,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -38,14 +38,15 @@ pub(crate) fn unwrap_result_return_type(acc: &mut Assists, ctx: &AssistContext<'\n     };\n \n     let type_ref = &ret_type.ty()?;\n-    let ty = ctx.sema.resolve_type(type_ref)?.as_adt();\n+    let Some(hir::Adt::Enum(ret_enum)) = ctx.sema.resolve_type(type_ref)?.as_adt() else { return None; };\n     let result_enum =\n         FamousDefs(&ctx.sema, ctx.sema.scope(type_ref.syntax())?.krate()).core_result_Result()?;\n-\n-    if !matches!(ty, Some(hir::Adt::Enum(ret_type)) if ret_type == result_enum) {\n+    if ret_enum != result_enum {\n         return None;\n     }\n \n+    let Some(ok_type) = unwrap_result_type(type_ref) else { return None; };\n+\n     acc.add(\n         AssistId(\"unwrap_result_return_type\", AssistKind::RefactorRewrite),\n         \"Unwrap Result return type\",\n@@ -64,26 +65,22 @@ pub(crate) fn unwrap_result_return_type(acc: &mut Assists, ctx: &AssistContext<'\n             });\n             for_each_tail_expr(&body, tail_cb);\n \n-            let mut is_unit_type = false;\n-            if let Some((_, inner_type)) = type_ref.to_string().split_once('<') {\n-                let inner_type = match inner_type.split_once(',') {\n-                    Some((success_inner_type, _)) => success_inner_type,\n-                    None => inner_type,\n-                };\n-                let new_ret_type = inner_type.strip_suffix('>').unwrap_or(inner_type);\n-                if new_ret_type == \"()\" {\n-                    is_unit_type = true;\n-                    let text_range = TextRange::new(\n-                        ret_type.syntax().text_range().start(),\n-                        ret_type.syntax().text_range().end() + TextSize::from(1u32),\n-                    );\n-                    builder.delete(text_range)\n-                } else {\n-                    builder.replace(\n-                        type_ref.syntax().text_range(),\n-                        inner_type.strip_suffix('>').unwrap_or(inner_type),\n-                    )\n+            let is_unit_type = is_unit_type(&ok_type);\n+            if is_unit_type {\n+                let mut text_range = ret_type.syntax().text_range();\n+\n+                if let Some(NodeOrToken::Token(token)) = ret_type.syntax().next_sibling_or_token() {\n+                    if token.kind() == SyntaxKind::WHITESPACE {\n+                        text_range = TextRange::new(\n+                            text_range.start(),\n+                            text_range.end() + TextSize::from(1u32),\n+                        );\n+                    }\n                 }\n+\n+                builder.delete(text_range);\n+            } else {\n+                builder.replace(type_ref.syntax().text_range(), ok_type.syntax().text());\n             }\n \n             for ret_expr_arg in exprs_to_unwrap {\n@@ -134,6 +131,22 @@ fn tail_cb_impl(acc: &mut Vec<ast::Expr>, e: &ast::Expr) {\n     }\n }\n \n+// Tries to extract `T` from `Result<T, E>`.\n+fn unwrap_result_type(ty: &ast::Type) -> Option<ast::Type> {\n+    let ast::Type::PathType(path_ty) = ty else { return None; };\n+    let Some(path) = path_ty.path() else { return None; };\n+    let Some(segment) = path.first_segment() else { return None; };\n+    let Some(generic_arg_list) = segment.generic_arg_list() else { return None; };\n+    let generic_args: Vec<_> = generic_arg_list.generic_args().collect();\n+    let Some(ast::GenericArg::TypeArg(ok_type)) = generic_args.first() else { return None; };\n+    ok_type.ty()\n+}\n+\n+fn is_unit_type(ty: &ast::Type) -> bool {\n+    let ast::Type::TupleType(tuple) = ty else { return false };\n+    tuple.fields().next().is_none()\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -173,6 +186,21 @@ fn foo() -> Result<(), Box<dyn Error$0>> {\n             r#\"\n fn foo() {\n }\n+\"#,\n+        );\n+\n+        // Unformatted return type\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<(), Box<dyn Error$0>>{\n+    Ok(())\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+}\n \"#,\n         );\n     }\n@@ -1014,6 +1042,54 @@ fn foo(the_field: u32) -> u32 {\n     }\n     the_field\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_nested_type() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result, option\n+fn foo() -> Result<Option<i32$0>, ()> {\n+    Ok(Some(42))\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Option<i32> {\n+    Some(42)\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result, option\n+fn foo() -> Result<Option<Result<i32$0, ()>>, ()> {\n+    Ok(None)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Option<Result<i32, ()>> {\n+    None\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result, option, iterators\n+fn foo() -> Result<impl Iterator<Item = i32>$0, ()> {\n+    Ok(Some(42).into_iter())\n+}\n+\"#,\n+            r#\"\n+fn foo() -> impl Iterator<Item = i32> {\n+    Some(42).into_iter()\n+}\n \"#,\n         );\n     }"}]}