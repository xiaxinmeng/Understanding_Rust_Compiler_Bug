{"sha": "e3f96480968a7c91738414158a61e4f44b402797", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZjk2NDgwOTY4YTdjOTE3Mzg0MTQxNThhNjFlNGY0NGI0MDI3OTc=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-27T00:59:43Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-27T21:41:08Z"}, "message": "Some cleanup in trans.", "tree": {"sha": "6f721b67f5ae64955b5c22a5213e9544935d96fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f721b67f5ae64955b5c22a5213e9544935d96fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f96480968a7c91738414158a61e4f44b402797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f96480968a7c91738414158a61e4f44b402797", "html_url": "https://github.com/rust-lang/rust/commit/e3f96480968a7c91738414158a61e4f44b402797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f96480968a7c91738414158a61e4f44b402797/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c612ebdcc7ec7efc79c80085d54b06505018a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c612ebdcc7ec7efc79c80085d54b06505018a41", "html_url": "https://github.com/rust-lang/rust/commit/1c612ebdcc7ec7efc79c80085d54b06505018a41"}], "stats": {"total": 47, "additions": 21, "deletions": 26}, "files": [{"sha": "cecbe9eb75fbcebaacc9e8bd3affba2d8d7a2fa0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e3f96480968a7c91738414158a61e4f44b402797/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f96480968a7c91738414158a61e4f44b402797/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e3f96480968a7c91738414158a61e4f44b402797", "patch": "@@ -163,6 +163,16 @@ fn type_of_fn(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n     ret type_of_fn_full(cx, sp, proto, false, inputs, output, ty_param_count);\n }\n \n+// Given a function type and a count of ty params, construct an llvm type\n+fn type_of_fn_from_ty(cx: &@crate_ctxt, sp: &span,\n+                      fty: &ty::t, ty_param_count: uint) -> TypeRef {\n+    ret type_of_fn(cx, sp,\n+                   ty::ty_fn_proto(cx.tcx, fty),\n+                   ty::ty_fn_args(cx.tcx, fty),\n+                   ty::ty_fn_ret(cx.tcx, fty),\n+                   ty_param_count);\n+}\n+\n fn type_of_native_fn(cx: &@crate_ctxt, sp: &span, abi: ast::native_abi,\n                      inputs: &ty::arg[], output: &ty::t, ty_param_count: uint)\n    -> TypeRef {\n@@ -231,8 +241,8 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n         }\n         llty = T_struct(tys);\n       }\n-      ty::ty_fn(proto, args, out, _, _) {\n-        llty = T_fn_pair(*cx, type_of_fn(cx, sp, proto, args, out, 0u));\n+      ty::ty_fn(_, _, _, _, _) {\n+        llty = T_fn_pair(*cx, type_of_fn_from_ty(cx, sp, t, 0u));\n       }\n       ty::ty_native_fn(abi, args, out) {\n         let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n@@ -276,7 +286,6 @@ fn type_of_arg(cx: @local_ctxt, sp: &span, arg: &ty::arg) -> TypeRef {\n       }\n       _ {\n         // fall through\n-\n       }\n     }\n     let typ;\n@@ -289,14 +298,12 @@ fn type_of_arg(cx: @local_ctxt, sp: &span, arg: &ty::arg) -> TypeRef {\n fn type_of_ty_param_count_and_ty(lcx: @local_ctxt, sp: &span,\n                                  tpt: &ty::ty_param_count_and_ty) -> TypeRef {\n     alt ty::struct(lcx.ccx.tcx, tpt.ty) {\n-      ty::ty_fn(proto, inputs, output, _, _) {\n-        let llfnty =\n-            type_of_fn(lcx.ccx, sp, proto, inputs, output, tpt.count);\n+      ty::ty_fn(_, _, _, _, _) {\n+        let llfnty = type_of_fn_from_ty(lcx.ccx, sp, tpt.ty, tpt.count);\n         ret T_fn_pair(*lcx.ccx, llfnty);\n       }\n       _ {\n         // fall through\n-\n       }\n     }\n     ret type_of(lcx.ccx, sp, tpt.ty);\n@@ -3967,9 +3974,7 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_count_and_ty,\n             tydescs += ~[td.val];\n         }\n         let gen = {item_type: tpt.ty, static_tis: tis, tydescs: tydescs};\n-        lv =\n-            {res: rslt(bcx, lv.res.val), generic: some[generic_info](gen)\n-                with lv};\n+        lv = {res: rslt(bcx, lv.res.val), generic: some(gen) with lv};\n     }\n     ret lv;\n }\n@@ -4512,9 +4517,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     // Cast the outgoing function to the appropriate type (see the comments in\n     // trans_bind below for why this is necessary).\n     let lltargetty =\n-        type_of_fn(bcx_ccx(bcx), sp,\n-                   ty::ty_fn_proto(bcx_tcx(bcx), outgoing_fty), outgoing_args,\n-                   outgoing_ret_ty, ty_param_count);\n+        type_of_fn_from_ty(bcx_ccx(bcx), sp, outgoing_fty, ty_param_count);\n     lltargetfn = bcx.build.PointerCast(lltargetfn, T_ptr(T_ptr(lltargetty)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n     bcx.build.FastCall(lltargetfn, llargs);\n@@ -4575,7 +4578,6 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     // First, synthesize a tuple type containing the types of all the\n     // bound expressions.\n     // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n-\n     let bindings_ty: ty::t = ty::mk_imm_tup(bcx_tcx(cx), bound_tys);\n \n     // NB: keep this in sync with T_closure_ptr; we're making\n@@ -4629,11 +4631,8 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     // specifically, we know how many type descriptors the outgoing\n     // function has, which type_of() doesn't, as only we know which\n     // item the function refers to.\n-    let llfnty =\n-        type_of_fn(bcx_ccx(bcx), cx.sp,\n-                   ty::ty_fn_proto(bcx_tcx(bcx), outgoing_fty),\n-                   ty::ty_fn_args(bcx_tcx(bcx), outgoing_fty),\n-                   ty::ty_fn_ret(bcx_tcx(bcx), outgoing_fty), ty_param_count);\n+    let llfnty = type_of_fn_from_ty(bcx_ccx(bcx), cx.sp,\n+                                    outgoing_fty, ty_param_count);\n     let llclosurety = T_ptr(T_fn_pair(*bcx_ccx(bcx), llfnty));\n \n     // Store thunk-target.\n@@ -4658,7 +4657,6 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     alt f_res.generic {\n       none. {/* nothing to do */ }\n       some(ginfo) {\n-        lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n         let ty_params_slot =\n             bcx.build.GEP(closure,\n                           ~[C_int(0), C_int(abi::closure_elt_ty_params)]);\n@@ -5163,11 +5161,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       ast::expr_fn(f) {\n         let ccx = bcx_ccx(cx);\n         let llfnty: TypeRef =\n-            alt ty::struct(ccx.tcx, node_id_type(ccx, e.id)) {\n-              ty::ty_fn(proto, inputs, output, _, _) {\n-                type_of_fn_full(ccx, e.span, proto, false, inputs, output, 0u)\n-              }\n-            };\n+            type_of_fn_from_ty(ccx, e.span, node_id_type(ccx, e.id), 0u);\n         let sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n         let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n         let llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n@@ -7362,7 +7356,8 @@ fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[], flav: str,\n fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &str[],\n                          flav: str, ty_params: &ast::ty_param[],\n                          node_id: ast::node_id, node_type: ty::t) {\n-    let llfty;\n+    let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n+                                   std::ivec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n       ty::ty_fn(proto, inputs, output, _, _) {\n         llfty ="}]}