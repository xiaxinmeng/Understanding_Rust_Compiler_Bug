{"sha": "066ca17eaae239a666579fc80fe9047aaac0599d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NmNhMTdlYWFlMjM5YTY2NjU3OWZjODBmZTkwNDdhYWFjMDU5OWQ=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-15T18:13:41Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T23:37:09Z"}, "message": "an attempt at a singleton pausible idle callback for each scheduler. suffers from nondeterministic deadlock and also pending scheduler messages on scheduler shutdown.", "tree": {"sha": "1f8fac52d7e580e9bc2eafcb5366d31146aa43f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f8fac52d7e580e9bc2eafcb5366d31146aa43f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066ca17eaae239a666579fc80fe9047aaac0599d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066ca17eaae239a666579fc80fe9047aaac0599d", "html_url": "https://github.com/rust-lang/rust/commit/066ca17eaae239a666579fc80fe9047aaac0599d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066ca17eaae239a666579fc80fe9047aaac0599d/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680eb71564ebba5e76ce1e1a8287b30042332cc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/680eb71564ebba5e76ce1e1a8287b30042332cc5", "html_url": "https://github.com/rust-lang/rust/commit/680eb71564ebba5e76ce1e1a8287b30042332cc5"}], "stats": {"total": 102, "additions": 83, "deletions": 19}, "files": [{"sha": "58e1676b42427ae05c2fbf30cee8b8f389617cfa", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/066ca17eaae239a666579fc80fe9047aaac0599d/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066ca17eaae239a666579fc80fe9047aaac0599d/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=066ca17eaae239a666579fc80fe9047aaac0599d", "patch": "@@ -30,6 +30,7 @@ use cell::Cell;\n use rand::{XorShiftRng, RngUtil};\n use iterator::{range};\n use vec::{OwnedVector};\n+use rt::uv::idle::IdleWatcher;\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -76,8 +77,11 @@ pub struct Scheduler {\n     /// them to.\n     friend_handle: Option<SchedHandle>,\n     /// A fast XorShift rng for scheduler use\n-    rng: XorShiftRng\n-\n+    rng: XorShiftRng,\n+    /// An IdleWatcher\n+    idle_watcher: IdleWatcher,\n+    /// A flag to indicate whether or not the idle callback is active.\n+    idle_flag: bool\n }\n \n pub struct SchedHandle {\n@@ -124,6 +128,9 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n+        let mut event_loop = event_loop;\n+        let idle_watcher = IdleWatcher::new(event_loop.uvio.uv_loop());\n+\n         Scheduler {\n             sleeper_list: sleeper_list,\n             message_queue: MessageQueue::new(),\n@@ -138,7 +145,9 @@ impl Scheduler {\n             metrics: SchedMetrics::new(),\n             run_anything: run_anything,\n             friend_handle: friend,\n-            rng: XorShiftRng::new()\n+            rng: XorShiftRng::new(),\n+            idle_watcher: idle_watcher,\n+            idle_flag: true\n         }\n     }\n \n@@ -151,6 +160,8 @@ impl Scheduler {\n     // scheduler task and bootstrap into it.\n     pub fn bootstrap(~self, task: ~Task) {\n \n+        let mut this = self;\n+\n         // Initialize the TLS key.\n         local_ptr::init_tls_key();\n \n@@ -161,10 +172,17 @@ impl Scheduler {\n         // task, put it in TLS.\n         Local::put::(sched_task);\n \n+        // Before starting our first task, make sure the idle callback\n+        // is active. As we do not start in the sleep state this is\n+        // important.\n+        do this.idle_watcher.start |_idle_watcher, _status| {\n+            Scheduler::run_sched_once();\n+        }\n+\n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n         // scheduler and resume the provided task.\n-        self.resume_task_immediately(task);\n+        this.resume_task_immediately(task);\n \n         // Now we are back in the scheduler context, having\n         // successfully run the input task. Start by running the\n@@ -201,7 +219,7 @@ impl Scheduler {\n         // Always run through the scheduler loop at least once so that\n         // we enter the sleep state and can then be woken up by other\n         // schedulers.\n-        self_sched.event_loop.callback(Scheduler::run_sched_once);\n+//        self_sched.event_loop.callback(Scheduler::run_sched_once);\n \n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n@@ -235,7 +253,11 @@ impl Scheduler {\n         // already have a scheduler stored in our local task, so we\n         // start off by taking it. This is the only path through the\n         // scheduler where we get the scheduler this way.\n-        let sched = Local::take::<Scheduler>();\n+        let mut sched = Local::take::<Scheduler>();\n+\n+        // Assume that we need to continue idling unless we reach the\n+        // end of this function without performing an action.\n+        sched.activate_idle();\n \n         // Our first task is to read mail to see if we have important\n         // messages.\n@@ -282,15 +304,40 @@ impl Scheduler {\n             sched.sleepy = true;\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n+            // Since we are sleeping, deactivate the idle callback.\n+            sched.pause_idle();\n         } else {\n             rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n+            // We may not be sleeping, but we still need to deactivate\n+            // the idle callback.\n+            sched.pause_idle();\n         }\n \n         // Finished a cycle without using the Scheduler. Place it back\n         // in TLS.\n         Local::put(sched);\n     }\n \n+    fn activate_idle(&mut self) {        \n+        if self.idle_flag {\n+            rtdebug!(\"idle flag already set, not reactivating idle watcher\");\n+        } else {\n+            rtdebug!(\"idle flag was false, reactivating idle watcher\");\n+            self.idle_flag = true;\n+            self.idle_watcher.restart();\n+        }            \n+    }\n+\n+    fn pause_idle(&mut self) {\n+        if !self.idle_flag {\n+            rtdebug!(\"idle flag false, not stopping idle watcher\");\n+        } else {\n+            rtdebug!(\"idle flag true, stopping idle watcher\");\n+            self.idle_flag = false;\n+            self.idle_watcher.stop();\n+        }\n+    }\n+\n     pub fn make_handle(&mut self) -> SchedHandle {\n         let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n \n@@ -312,7 +359,7 @@ impl Scheduler {\n \n         // We push the task onto our local queue clone.\n         this.work_queue.push(task);\n-        this.event_loop.callback(Scheduler::run_sched_once);\n+//        this.event_loop.callback(Scheduler::run_sched_once);\n \n         // We've made work available. Notify a\n         // sleeping scheduler.\n@@ -346,30 +393,34 @@ impl Scheduler {\n     // * Scheduler-context operations\n \n     // This function returns None if the scheduler is \"used\", or it\n-    // returns the still-available scheduler.\n+    // returns the still-available scheduler. Note: currently\n+    // considers *any* message receive a use and returns None.\n     fn interpret_message_queue(~self) -> Option<~Scheduler> {\n \n         let mut this = self;\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n+//                this.event_loop.callback(Scheduler::run_sched_once);\n                 let mut task = task;\n                 task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n+//                this.event_loop.callback(Scheduler::run_sched_once);\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                return this.sched_schedule_task(task);\n+                this.sched_schedule_task(task).map_move(Local::put);\n+                return None;\n             }\n             Some(Wake) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n+//                this.event_loop.callback(Scheduler::run_sched_once);\n                 this.sleepy = false;\n-                return Some(this);\n+                Local::put(this);\n+                return None;\n+//                return Some(this);\n             }\n             Some(Shutdown) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n+//                this.event_loop.callback(Scheduler::run_sched_once);\n                 if this.sleepy {\n                     // There may be an outstanding handle on the\n                     // sleeper list.  Pop them all to make sure that's\n@@ -388,11 +439,10 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 this.no_sleep = true;\n                 this.sleepy = false;\n-                // YYY: Does a shutdown count as a \"use\" of the\n-                // scheduler? This seems to work - so I'm leaving it\n-                // this way despite not having a solid rational for\n-                // why I should return the scheduler here.\n-                return Some(this);\n+\n+                Local::put(this);\n+                return None;\n+//                return Some(this);\n             }\n             None => {\n                 return Some(this);"}, {"sha": "a21146620ca823ec8643adfdb84c00f31a391b38", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/066ca17eaae239a666579fc80fe9047aaac0599d/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066ca17eaae239a666579fc80fe9047aaac0599d/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=066ca17eaae239a666579fc80fe9047aaac0599d", "patch": "@@ -48,6 +48,20 @@ impl IdleWatcher {\n         }\n     }\n \n+    pub fn restart(&mut self) {\n+        unsafe {\n+            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let data = idle_watcher.get_watcher_data();\n+            let cb: &IdleCallback = data.idle_cb.get_ref();\n+            let status = status_to_maybe_uv_error(idle_watcher, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n     pub fn stop(&mut self) {\n         // NB: Not resetting the Rust idle_cb to None here because `stop` is\n         // likely called from *within* the idle callback, causing a use after"}]}