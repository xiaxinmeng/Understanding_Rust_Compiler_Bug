{"sha": "4f921d7a8d8dee7b511e4956e06a80f550003afc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOTIxZDdhOGQ4ZGVlN2I1MTFlNDk1NmUwNmE4MGY1NTAwMDNhZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-13T22:40:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-13T22:40:35Z"}, "message": "Auto merge of #54168 - kennytm:rollup, r=kennytm\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #53371 (Do not emit E0277 on incorrect tuple destructured binding)\n - #53829 (Add rustc SHA to released DWARF debuginfo)\n - #53950 (Allow for opting out of ThinLTO and clean up LTO related cli flag handling.)\n - #53976 (Replace unwrap calls in example by expect)\n - #54070 (Add Error::description soft-deprecation to RELEASES)\n - #54076 (miri loop detector hashing)\n - #54119 (Add some unit tests for find_best_match_for_name)\n - #54147 (Add a test that tries to modify static memory at compile-time)\n - #54150 (Updated 1.29 release notes with --document-private-items flag)\n - #54163 (Update stage 0 to latest beta)\n - #54170 (COMPILER_TESTS.md has been moved)", "tree": {"sha": "2669f8223a1f824c967e590624e285a31c1f6e49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2669f8223a1f824c967e590624e285a31c1f6e49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f921d7a8d8dee7b511e4956e06a80f550003afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f921d7a8d8dee7b511e4956e06a80f550003afc", "html_url": "https://github.com/rust-lang/rust/commit/4f921d7a8d8dee7b511e4956e06a80f550003afc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f921d7a8d8dee7b511e4956e06a80f550003afc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90d36fb5905bbe5004f5b465ea14b53d10dae260", "url": "https://api.github.com/repos/rust-lang/rust/commits/90d36fb5905bbe5004f5b465ea14b53d10dae260", "html_url": "https://github.com/rust-lang/rust/commit/90d36fb5905bbe5004f5b465ea14b53d10dae260"}, {"sha": "07dc4b3759f3cc0e97777fe944dbc54c967424fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/07dc4b3759f3cc0e97777fe944dbc54c967424fd", "html_url": "https://github.com/rust-lang/rust/commit/07dc4b3759f3cc0e97777fe944dbc54c967424fd"}], "stats": {"total": 511, "additions": 398, "deletions": 113}, "files": [{"sha": "2e51a786f46826a52e936179dd612fad91357657", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -368,8 +368,7 @@ will run all the tests on every platform we support. If it all works out,\n [merge-queue]: https://buildbot2.rust-lang.org/homu/queue/rust\n \n Speaking of tests, Rust has a comprehensive test suite. More information about\n-it can be found\n-[here](https://github.com/rust-lang/rust/blob/master/src/test/COMPILER_TESTS.md).\n+it can be found [here][rctd].\n \n ### External Dependencies\n [external-dependencies]: #external-dependencies\n@@ -654,5 +653,5 @@ are:\n [rustforge]: https://forge.rust-lang.org/\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n-[rctd]: ./src/test/COMPILER_TESTS.md\n+[rctd]: https://rust-lang-nursery.github.io/rustc-guide/tests/intro.html\n [cheatsheet]: https://buildbot2.rust-lang.org/homu/"}, {"sha": "819c9184364fdd773bd8b59432e7e2ebdc0c1685", "filename": "RELEASES.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -31,6 +31,8 @@ Cargo\n   using `--target`][cargo/5614]\n - [Added the `cargo-fix` subcommand to automatically move project code from\n   2015 edition to 2018.][cargo/5723]\n+- [`cargo doc` can now optionally document private types using the\n+  `--document-private-items` flag.][cargo/5543]\n \n Misc\n ----\n@@ -68,6 +70,7 @@ Compatibility Notes\n [51178]: https://github.com/rust-lang/rust/pull/51178/\n [51122]: https://github.com/rust-lang/rust/pull/51122\n [50494]: https://github.com/rust-lang/rust/pull/50494/\n+[cargo/5543]: https://github.com/rust-lang/cargo/pull/5543\n [cargo/5614]: https://github.com/rust-lang/cargo/pull/5614/\n [cargo/5723]: https://github.com/rust-lang/cargo/pull/5723/\n [cargo/5831]: https://github.com/rust-lang/cargo/pull/5831/\n@@ -370,6 +373,8 @@ Compatibility Notes\n - [The maximum number for `repr(align(N))` is now 2\u00b2\u2079.][50378] Previously you\n   could enter higher numbers but they were not supported by LLVM. Up to 512MB\n   alignment should cover all use cases.\n+- The `.description()` method on the `std::error::Error` trait\n+  [has been soft-deprecated][50163]. It is no longer required to implement it.\n \n [48553]: https://github.com/rust-lang/rust/pull/48553/\n [48851]: https://github.com/rust-lang/rust/pull/48851/\n@@ -383,6 +388,7 @@ Compatibility Notes\n [49719]: https://github.com/rust-lang/rust/pull/49719/\n [49896]: https://github.com/rust-lang/rust/pull/49896/\n [49968]: https://github.com/rust-lang/rust/pull/49968/\n+[50163]: https://github.com/rust-lang/rust/pull/50163\n [50177]: https://github.com/rust-lang/rust/pull/50177/\n [50378]: https://github.com/rust-lang/rust/pull/50378/\n [50398]: https://github.com/rust-lang/rust/pull/50398/"}, {"sha": "3159c19528af5083495dc0e31670c547b6e9cd4a", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -377,6 +377,10 @@\n # Whether to verify generated LLVM IR\n #verify-llvm-ir = false\n \n+# Map all debuginfo paths for libstd and crates to `/rust/$sha/$crate/...`,\n+# generally only set for releases\n+#remap-debuginfo = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "f30f34acf5c6c74642ea685e8f6ea1fc0422e1e6", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -263,6 +263,10 @@ fn main() {\n         if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n             cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n         }\n+\n+        if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n+            cmd.arg(\"--remap-path-prefix\").arg(&map);\n+        }\n     } else {\n         // Override linker if necessary.\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {"}, {"sha": "2f7f3058b04735bfb97b33af9e53291a7783ae8d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -32,7 +32,7 @@ use native;\n use test;\n use tool;\n use util::{add_lib_path, exe, libdir};\n-use {Build, DocTests, Mode};\n+use {Build, DocTests, Mode, GitRepo};\n \n pub use Compiler;\n \n@@ -876,6 +876,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n         }\n \n+        if let Some(map) = self.build.debuginfo_map(GitRepo::Rustc) {\n+            cargo.env(\"RUSTC_DEBUGINFO_MAP\", map);\n+        }\n+\n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         self.add_rust_test_threads(&mut cargo);\n@@ -964,7 +968,7 @@ impl<'a> Builder<'a> {\n             let cc = ccacheify(&self.cc(target));\n             cargo.env(format!(\"CC_{}\", target), &cc).env(\"CC\", &cc);\n \n-            let cflags = self.cflags(target).join(\" \");\n+            let cflags = self.cflags(target, GitRepo::Rustc).join(\" \");\n             cargo\n                 .env(format!(\"CFLAGS_{}\", target), cflags.clone())\n                 .env(\"CFLAGS\", cflags.clone());"}, {"sha": "d5da0cabec84aa7d5fc61cb3f65011831ca91761", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -39,7 +39,7 @@ use std::process::Command;\n use build_helper::output;\n use cc;\n \n-use Build;\n+use {Build, GitRepo};\n use config::Target;\n use cache::Interned;\n \n@@ -107,7 +107,7 @@ pub fn find(build: &mut Build) {\n \n         build.cc.insert(target, compiler);\n         build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n-        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, build.cflags(target)));\n+        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, build.cflags(target, GitRepo::Rustc)));\n         if let Some(ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n             build.ar.insert(target, ar);"}, {"sha": "c0661a773e3a71d900504f640025d69fd0ed2024", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -30,7 +30,7 @@ use filetime::FileTime;\n use serde_json;\n \n use util::{exe, libdir, is_dylib, CiEnv};\n-use {Compiler, Mode};\n+use {Compiler, Mode, GitRepo};\n use native;\n use tool;\n \n@@ -895,7 +895,7 @@ pub fn compiler_file(builder: &Builder,\n                  target: Interned<String>,\n                  file: &str) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n-    cmd.args(builder.cflags(target));\n+    cmd.args(builder.cflags(target, GitRepo::Rustc));\n     cmd.arg(format!(\"-print-file-name={}\", file));\n     let out = output(&mut cmd);\n     PathBuf::from(out.trim())"}, {"sha": "cc6d76c76f2f235781eeac7ac708c0c7cfc5de1c", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -109,6 +109,7 @@ pub struct Config {\n     pub rust_codegen_backends: Vec<Interned<String>>,\n     pub rust_codegen_backends_dir: String,\n     pub rust_verify_llvm_ir: bool,\n+    pub rust_remap_debuginfo: bool,\n \n     pub build: Interned<String>,\n     pub hosts: Vec<Interned<String>>,\n@@ -321,6 +322,7 @@ struct Rust {\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n+    remap_debuginfo: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -557,6 +559,7 @@ impl Config {\n             set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n+            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n \n             if let Some(ref backends) = rust.codegen_backends {\n                 config.rust_codegen_backends = backends.iter()"}, {"sha": "ed6a5f94d0d95fa1eb0adc2dd7a6d5a61066dbe4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -237,6 +237,11 @@ pub enum DocTests {\n     Only,\n }\n \n+pub enum GitRepo {\n+    Rustc,\n+    Llvm,\n+}\n+\n /// Global configuration for the build system.\n ///\n /// This structure transitively contains all configuration for the build system.\n@@ -738,14 +743,29 @@ impl Build {\n         self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n+    fn debuginfo_map(&self, which: GitRepo) -> Option<String> {\n+        if !self.config.rust_remap_debuginfo {\n+            return None\n+        }\n+\n+        let path = match which {\n+            GitRepo::Rustc => {\n+                let sha = self.rust_info.sha().expect(\"failed to find sha\");\n+                format!(\"/rustc/{}\", sha)\n+            }\n+            GitRepo::Llvm => format!(\"/rustc/llvm\"),\n+        };\n+        Some(format!(\"{}={}\", self.src.display(), path))\n+    }\n+\n     /// Returns the path to the C compiler for the target specified.\n     fn cc(&self, target: Interned<String>) -> &Path {\n         self.cc[&target].path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n-    fn cflags(&self, target: Interned<String>) -> Vec<String> {\n+    fn cflags(&self, target: Interned<String>, which: GitRepo) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n         let mut base = self.cc[&target].args().iter()\n@@ -767,6 +787,16 @@ impl Build {\n         if &*target == \"i686-pc-windows-gnu\" {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n+\n+        if let Some(map) = self.debuginfo_map(which) {\n+        let cc = self.cc(target);\n+            if cc.ends_with(\"clang\") || cc.ends_with(\"gcc\") {\n+                base.push(format!(\"-fdebug-prefix-map={}\", map).into());\n+            } else if cc.ends_with(\"clang-cl.exe\") {\n+                base.push(\"-Xclang\".into());\n+                base.push(format!(\"-fdebug-prefix-map={}\", map).into());\n+            }\n+        }\n         base\n     }\n "}, {"sha": "424264647f0be4d501e9d399e2a736a03e05eda5", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -33,6 +33,7 @@ use util::{self, exe};\n use build_helper::up_to_date;\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use cache::Interned;\n+use GitRepo;\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n@@ -373,8 +374,8 @@ fn configure_cmake(builder: &Builder,\n     }\n \n     cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n-    cfg.define(\"CMAKE_C_FLAGS\", builder.cflags(target).join(\" \"));\n-    let mut cxxflags = builder.cflags(target).join(\" \");\n+    cfg.define(\"CMAKE_C_FLAGS\", builder.cflags(target, GitRepo::Llvm).join(\" \"));\n+    let mut cxxflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n     if building_dist_binaries {\n         if builder.config.llvm_static_stdcpp && !target.contains(\"windows\") {\n             cxxflags.push_str(\" -static-libstdc++\");\n@@ -680,7 +681,7 @@ impl Step for Openssl {\n         };\n         configure.arg(os);\n         configure.env(\"CC\", builder.cc(target));\n-        for flag in builder.cflags(target) {\n+        for flag in builder.cflags(target, GitRepo::Rustc) {\n             configure.arg(flag);\n         }\n         // There is no specific os target for android aarch64 or x86_64,"}, {"sha": "92665c09f72aa7bef15f0984ad7dd3b2fb32f4f5", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -34,7 +34,7 @@ use tool::{self, Tool, SourceType};\n use toolstate::ToolState;\n use util::{self, dylib_path, dylib_path_var};\n use Crate as CargoCrate;\n-use {DocTests, Mode};\n+use {DocTests, Mode, GitRepo};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -1142,7 +1142,7 @@ impl Step for Compiletest {\n                     .arg(\"--cxx\")\n                     .arg(builder.cxx(target).unwrap())\n                     .arg(\"--cflags\")\n-                    .arg(builder.cflags(target).join(\" \"))\n+                    .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"))\n                     .arg(\"--llvm-components\")\n                     .arg(llvm_components.trim())\n                     .arg(\"--llvm-cxxflags\")"}, {"sha": "6a571bfad135d51bbd9a9f8ff7c328e6f1ab2f80", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -55,6 +55,7 @@ export RUST_RELEASE_CHANNEL=nightly\n if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=$RUST_RELEASE_CHANNEL\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n+  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.remap-debuginfo\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\""}, {"sha": "2a9732bf02c98616acee6bf36ba8baadf1f387a3", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -68,15 +68,13 @@ pub enum OptLevel {\n     SizeMin,    // -Oz\n }\n \n+/// This is what the `LtoCli` values get mapped to after resolving defaults and\n+/// and taking other command line options into account.\n #[derive(Clone, Copy, PartialEq, Hash, Debug)]\n pub enum Lto {\n     /// Don't do any LTO whatsoever\n     No,\n \n-    /// Do a full crate graph LTO. The flavor is determined by the compiler\n-    /// (currently the default is \"fat\").\n-    Yes,\n-\n     /// Do a full crate graph LTO with ThinLTO\n     Thin,\n \n@@ -88,6 +86,23 @@ pub enum Lto {\n     Fat,\n }\n \n+/// The different settings that the `-C lto` flag can have.\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum LtoCli {\n+    /// `-C lto=no`\n+    No,\n+    /// `-C lto=yes`\n+    Yes,\n+    /// `-C lto`\n+    NoParam,\n+    /// `-C lto=thin`\n+    Thin,\n+    /// `-C lto=fat`\n+    Fat,\n+    /// No `-C lto` flag passed\n+    Unspecified,\n+}\n+\n #[derive(Clone, PartialEq, Hash)]\n pub enum CrossLangLto {\n     LinkerPlugin(PathBuf),\n@@ -801,15 +816,16 @@ macro_rules! options {\n         pub const parse_unpretty: Option<&'static str> =\n             Some(\"`string` or `string=string`\");\n         pub const parse_lto: Option<&'static str> =\n-            Some(\"one of `thin`, `fat`, or omitted\");\n+            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n+                  `fat`, or omitted\");\n         pub const parse_cross_lang_lto: Option<&'static str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, Lto, CrossLangLto};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, CrossLangLto};\n         use rustc_target::spec::{LinkerFlavor, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n \n@@ -1002,11 +1018,23 @@ macro_rules! options {\n             }\n         }\n \n-        fn parse_lto(slot: &mut Lto, v: Option<&str>) -> bool {\n+        fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        LtoCli::Yes\n+                    } else {\n+                        LtoCli::No\n+                    };\n+                    return true\n+                }\n+            }\n+\n             *slot = match v {\n-                None => Lto::Yes,\n-                Some(\"thin\") => Lto::Thin,\n-                Some(\"fat\") => Lto::Fat,\n+                None => LtoCli::NoParam,\n+                Some(\"thin\") => LtoCli::Thin,\n+                Some(\"fat\") => LtoCli::Fat,\n                 Some(_) => return false,\n             };\n             true\n@@ -1047,7 +1075,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"extra arguments to append to the linker invocation (space separated)\"),\n     link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n         \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: Lto = (Lto::No, parse_lto, [TRACKED],\n+    lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n     target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (rustc --print target-cpus for details)\"),\n@@ -2384,8 +2412,8 @@ mod dep_tracking {\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n-    use super::{CrateType, DebugInfo, ErrorOutputType, Lto, OptLevel, OutputTypes,\n-                Passes, Sanitizer, CrossLangLto};\n+    use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n+                Passes, Sanitizer, LtoCli, CrossLangLto};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2440,7 +2468,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(RelroLevel);\n     impl_dep_tracking_hash_via_hash!(Passes);\n     impl_dep_tracking_hash_via_hash!(OptLevel);\n-    impl_dep_tracking_hash_via_hash!(Lto);\n+    impl_dep_tracking_hash_via_hash!(LtoCli);\n     impl_dep_tracking_hash_via_hash!(DebugInfo);\n     impl_dep_tracking_hash_via_hash!(UnstableFeatures);\n     impl_dep_tracking_hash_via_hash!(OutputTypes);\n@@ -2514,7 +2542,7 @@ mod tests {\n     use lint;\n     use middle::cstore;\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n-    use session::config::{Lto, CrossLangLto};\n+    use session::config::{LtoCli, CrossLangLto};\n     use session::build_session;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n@@ -2948,7 +2976,7 @@ mod tests {\n \n         // Make sure changing a [TRACKED] option changes the hash\n         opts = reference.clone();\n-        opts.cg.lto = Lto::Fat;\n+        opts.cg.lto = LtoCli::Fat;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "619262abb0bf5f5c749840bfbe481960a4701dff", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -550,9 +550,27 @@ impl Session {\n         // lto` and we've for whatever reason forced off ThinLTO via the CLI,\n         // then ensure we can't use a ThinLTO.\n         match self.opts.cg.lto {\n-            config::Lto::No => {}\n-            config::Lto::Yes if self.opts.cli_forced_thinlto_off => return config::Lto::Fat,\n-            other => return other,\n+            config::LtoCli::Unspecified => {\n+                // The compiler was invoked without the `-Clto` flag. Fall\n+                // through to the default handling\n+            }\n+            config::LtoCli::No => {\n+                // The user explicitly opted out of any kind of LTO\n+                return config::Lto::No;\n+            }\n+            config::LtoCli::Yes |\n+            config::LtoCli::Fat |\n+            config::LtoCli::NoParam => {\n+                // All of these mean fat LTO\n+                return config::Lto::Fat;\n+            }\n+            config::LtoCli::Thin => {\n+                return if self.opts.cli_forced_thinlto_off {\n+                    config::Lto::Fat\n+                } else {\n+                    config::Lto::Thin\n+                };\n+            }\n         }\n \n         // Ok at this point the target doesn't require anything and the user\n@@ -1178,7 +1196,6 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n \n     if sess.opts.incremental.is_some() {\n         match sess.lto() {\n-            Lto::Yes |\n             Lto::Thin |\n             Lto::Fat => {\n                 sess.err(\"can't perform LTO when compiling incrementally\");"}, {"sha": "8248385c12764949641b6be46c4a9dabb303b2da", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -1666,7 +1666,6 @@ fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n \n fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n     match sess.lto() {\n-        Lto::Yes |\n         Lto::Fat => true,\n         Lto::Thin => {\n             // If we defer LTO to the linker, we haven't run LTO ourselves, so"}, {"sha": "95be2d82123a7c619be090ffabb789dbc4973235", "filename": "src/librustc_codegen_llvm/back/linker.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -205,13 +205,12 @@ impl<'a> GccLinker<'a> {\n         self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n         self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", llvm_util::target_cpu(self.sess)));\n \n-        match self.sess.opts.cg.lto {\n+        match self.sess.lto() {\n             config::Lto::Thin |\n             config::Lto::ThinLocal => {\n                 self.linker_arg(\"-plugin-opt=thin\");\n             }\n             config::Lto::Fat |\n-            config::Lto::Yes |\n             config::Lto::No => {\n                 // default to regular LTO\n             }"}, {"sha": "364b469738fc983e712e7db4561c2ca94987f434", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -118,7 +118,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::ThinLocal => SymbolExportLevel::Rust,\n \n         // We're doing LTO for the entire crate graph\n-        Lto::Yes | Lto::Fat | Lto::Thin => {\n+        Lto::Fat | Lto::Thin => {\n             symbol_export::crates_export_threshold(&cgcx.crate_types)\n         }\n \n@@ -201,7 +201,6 @@ pub(crate) fn run(cgcx: &CodegenContext,\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n     match cgcx.lto {\n-        Lto::Yes | // `-C lto` == fat LTO by default\n         Lto::Fat => {\n             assert!(cached_modules.is_empty());\n             let opt_jobs = fat_lto(cgcx,"}, {"sha": "7b78d4fb4ffa9267722c9ea7221c636d62155749", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -937,7 +937,6 @@ fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n     }\n \n     match sess.lto() {\n-        Lto::Yes |\n         Lto::Fat |\n         Lto::No => false,\n         Lto::Thin |\n@@ -1372,7 +1371,7 @@ fn execute_optimize_work_item(cgcx: &CodegenContext,\n         // require LTO so the request for LTO is always unconditionally\n         // passed down to the backend, but we don't actually want to do\n         // anything about it yet until we've got a final product.\n-        Lto::Yes | Lto::Fat | Lto::Thin => {\n+        Lto::Fat | Lto::Thin => {\n             cgcx.crate_types.len() != 1 ||\n                 cgcx.crate_types[0] != config::CrateType::Rlib\n         }\n@@ -1552,7 +1551,7 @@ fn start_executing_work(tcx: TyCtxt,\n                 exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n                 Some(Arc::new(exported_symbols))\n             }\n-            Lto::Yes | Lto::Fat | Lto::Thin => {\n+            Lto::Fat | Lto::Thin => {\n                 exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n                 for &cnum in tcx.crates().iter() {\n                     exported_symbols.insert(cnum, copy_symbols(cnum));"}, {"sha": "82cc1b7f66166a848597ea814a7f99be8bce9dbd", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -239,6 +239,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     type MemoryKinds = !;\n \n     const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n+    const DETECT_LOOPS: bool = true;\n \n     fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,"}, {"sha": "740d4e038df7ebadf771e2feb0b17652cf361d2d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -65,6 +65,8 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// detector period.\n     pub(super) steps_since_detector_enabled: isize,\n \n+    /// Extra state to detect loops.\n+    /// FIXME: Move this to the CTFE machine's state, out of the general miri engine.\n     pub(super) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n@@ -110,6 +112,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n+// Not using the macro because that does not support types depending on 'tcx\n impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -144,11 +147,14 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n+// Can't use the macro here because that does not support named enum fields.\n impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>) {\n+        hasher: &mut StableHasher<W>)\n+    {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n             StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n             StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),"}, {"sha": "f33cb4791029a8ae9afb3f1259626964e5336868", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -12,29 +12,29 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use std::hash::Hash;\n-\n use rustc::hir::def_id::DefId;\n-use rustc::ich::StableHashingContext;\n use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n use rustc::mir;\n use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n-use rustc_data_structures::stable_hasher::HashStable;\n \n use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash + for<'a> HashStable<StableHashingContext<'a>> {\n+pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData: Clone + Eq + Hash + for<'a> HashStable<StableHashingContext<'a>>;\n+    type MemoryData: Clone + Eq;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash;\n+    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq;\n \n     /// The memory kind to use for mutated statics -- or None if those are not supported.\n     const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// Whether to attempt to detect infinite loops (any kind of infinite\n+    /// execution, really).\n+    const DETECT_LOOPS: bool;\n+\n     /// Entry point to all function calls.\n     ///\n     /// Returns either the mir to use for the call, or `None` if execution should"}, {"sha": "64e0aeaaab7f042249f2717a6794a3ae91e0364f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -13,6 +13,7 @@\n //! All high-level functions to write to memory work on places as destinations.\n \n use std::convert::TryFrom;\n+use std::mem;\n \n use rustc::ich::StableHashingContext;\n use rustc::mir;\n@@ -57,11 +58,13 @@ pub enum Place<Id=AllocId> {\n     },\n }\n \n+// Can't use the macro here because that does not support named enum fields.\n impl<'a> HashStable<StableHashingContext<'a>> for Place {\n     fn hash_stable<W: StableHasherResult>(\n         &self, hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>) {\n-\n+        hasher: &mut StableHasher<W>)\n+    {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n             Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n "}, {"sha": "0e8466905eb767ccc54164dd35770dcfc937f265", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -62,14 +62,13 @@ impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n     pub fn observe_and_analyze(\n         &mut self,\n         tcx: &TyCtxt<'b, 'tcx, 'tcx>,\n-        machine: &M,\n         memory: &Memory<'a, 'mir, 'tcx, M>,\n         stack: &[Frame<'mir, 'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n \n         let mut hcx = tcx.get_stable_hashing_context();\n         let mut hasher = StableHasher::<u64>::new();\n-        (machine, stack).hash_stable(&mut hcx, &mut hasher);\n+        stack.hash_stable(&mut hcx, &mut hasher);\n         let hash = hasher.finish();\n \n         if self.hashes.insert(hash) {\n@@ -79,7 +78,7 @@ impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n \n         info!(\"snapshotting the state of the interpreter\");\n \n-        if self.snapshots.insert(EvalSnapshot::new(machine, memory, stack)) {\n+        if self.snapshots.insert(EvalSnapshot::new(memory, stack)) {\n             // Spurious collision or first cycle\n             return Ok(())\n         }\n@@ -345,7 +344,6 @@ impl<'a, 'b, 'mir, 'tcx, M> SnapshotContext<'b> for Memory<'a, 'mir, 'tcx, M>\n \n /// The virtual machine state during const-evaluation at a given point in time.\n struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    machine: M,\n     memory: Memory<'a, 'mir, 'tcx, M>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n@@ -354,21 +352,20 @@ impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n {\n     fn new(\n-        machine: &M,\n         memory: &Memory<'a, 'mir, 'tcx, M>,\n-        stack: &[Frame<'mir, 'tcx>]) -> Self {\n-\n+        stack: &[Frame<'mir, 'tcx>]\n+    ) -> Self {\n         EvalSnapshot {\n-            machine: machine.clone(),\n             memory: memory.clone(),\n             stack: stack.into(),\n         }\n     }\n \n     fn snapshot<'b: 'a>(&'b self)\n-        -> (&'b M, MemorySnapshot<'b, 'mir, 'tcx, M>, Vec<FrameSnapshot<'a, 'tcx>>) {\n-        let EvalSnapshot{ machine, memory, stack } = self;\n-        (&machine, memory.snapshot(), stack.iter().map(|frame| frame.snapshot(memory)).collect())\n+        -> (MemorySnapshot<'b, 'mir, 'tcx, M>, Vec<FrameSnapshot<'a, 'tcx>>)\n+    {\n+        let EvalSnapshot{ memory, stack } = self;\n+        (memory.snapshot(), stack.iter().map(|frame| frame.snapshot(memory)).collect())\n     }\n }\n \n@@ -384,17 +381,19 @@ impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n     }\n }\n \n+// Not using the macro because we need special handling for `memory`, which the macro\n+// does not support at the same time as the extra bounds on the type.\n impl<'a, 'b, 'mir, 'tcx, M> HashStable<StableHashingContext<'b>>\n     for EvalSnapshot<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'b>,\n-        hasher: &mut StableHasher<W>) {\n-\n-        let EvalSnapshot{ machine, memory, stack } = self;\n-        (machine, &memory.data, stack).hash_stable(hcx, hasher);\n+        hasher: &mut StableHasher<W>)\n+    {\n+        let EvalSnapshot{ memory: _, stack } = self;\n+        stack.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "5bdaf6ba729632d6fb440e8c8020ee46ec98418a", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -65,6 +65,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n+        if !M::DETECT_LOOPS {\n+            return Ok(());\n+        }\n+\n         if self.loop_detector.is_empty() {\n             // First run of the loop detector\n \n@@ -75,7 +79,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         self.loop_detector.observe_and_analyze(\n             &self.tcx,\n-            &self.machine,\n             &self.memory,\n             &self.stack[..],\n         )"}, {"sha": "7f65a5f0b5a6303205aa6c86cc1aad9a6d50250a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -298,11 +298,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-                self.demand_eqtype(pat.span, expected, pat_ty);\n-                for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                    self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n+                if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n+                    err.emit();\n+                    // Walk subpatterns with an expected type of `err` in this case to silence\n+                    // further errors being emitted when using the bindings. #50333\n+                    let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+                    for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                        self.check_pat_walk(elem, &tcx.types.err, def_bm, true);\n+                    }\n+                    tcx.mk_tup(element_tys_iter)\n+                } else {\n+                    for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                        self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n+                    }\n+                    pat_ty\n                 }\n-                pat_ty\n             }\n             PatKind::Box(ref inner) => {\n                 let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));"}, {"sha": "0831e29bdddbffe8c4dda533af2266cb881b141d", "filename": "src/libstd/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -97,6 +97,10 @@ fn build_libbacktrace(target: &str) -> Result<(), ()> {\n         .file(\"../libbacktrace/sort.c\")\n         .file(\"../libbacktrace/state.c\");\n \n+    let any_debug = env::var(\"RUSTC_DEBUGINFO\").unwrap_or(String::new()) == \"true\" ||\n+        env::var(\"RUSTC_DEBUGINFO_LINES\").unwrap_or(String::new()) == \"true\";\n+    build.debug(any_debug);\n+\n     if target.contains(\"darwin\") {\n         build.file(\"../libbacktrace/macho.c\");\n     } else if target.contains(\"windows\") {"}, {"sha": "63dd12f782fda49fe21de6eee08300cac2d00120", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -102,8 +102,8 @@ use sys;\n /// }\n ///\n /// // We are certain that our string doesn't have 0 bytes in the middle,\n-/// // so we can .unwrap()\n-/// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n+/// // so we can .expect()\n+/// let c_to_print = CString::new(\"Hello, world!\").expect(\"CString::new failed\");\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n /// }\n@@ -175,7 +175,7 @@ pub struct CString {\n ///     unsafe { work_with(data.as_ptr()) }\n /// }\n ///\n-/// let s = CString::new(\"data data data data\").unwrap();\n+/// let s = CString::new(\"data data data data\").expect(\"CString::new failed\");\n /// work(&s);\n /// ```\n ///\n@@ -314,7 +314,7 @@ impl CString {\n     ///\n     /// extern { fn puts(s: *const c_char); }\n     ///\n-    /// let to_print = CString::new(\"Hello!\").unwrap();\n+    /// let to_print = CString::new(\"Hello!\").expect(\"CString::new failed\");\n     /// unsafe {\n     ///     puts(to_print.as_ptr());\n     /// }\n@@ -398,7 +398,7 @@ impl CString {\n     ///     fn some_extern_function(s: *mut c_char);\n     /// }\n     ///\n-    /// let c_string = CString::new(\"Hello!\").unwrap();\n+    /// let c_string = CString::new(\"Hello!\").expect(\"CString::new failed\");\n     /// let raw = c_string.into_raw();\n     /// unsafe {\n     ///     some_extern_function(raw);\n@@ -428,7 +428,7 @@ impl CString {\n     /// ```\n     /// use std::ffi::CString;\n     ///\n-    /// let c_string = CString::new(\"foo\").unwrap();\n+    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n     ///\n     /// let ptr = c_string.into_raw();\n     ///\n@@ -460,12 +460,12 @@ impl CString {\n     /// use std::ffi::CString;\n     ///\n     /// let valid_utf8 = vec![b'f', b'o', b'o'];\n-    /// let cstring = CString::new(valid_utf8).unwrap();\n-    /// assert_eq!(cstring.into_string().unwrap(), \"foo\");\n+    /// let cstring = CString::new(valid_utf8).expect(\"CString::new failed\");\n+    /// assert_eq!(cstring.into_string().expect(\"into_string() call failed\"), \"foo\");\n     ///\n     /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n-    /// let cstring = CString::new(invalid_utf8).unwrap();\n-    /// let err = cstring.into_string().err().unwrap();\n+    /// let cstring = CString::new(invalid_utf8).expect(\"CString::new failed\");\n+    /// let err = cstring.into_string().err().expect(\"into_string().err() failed\");\n     /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n     /// ```\n \n@@ -489,7 +489,7 @@ impl CString {\n     /// ```\n     /// use std::ffi::CString;\n     ///\n-    /// let c_string = CString::new(\"foo\").unwrap();\n+    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n     /// let bytes = c_string.into_bytes();\n     /// assert_eq!(bytes, vec![b'f', b'o', b'o']);\n     /// ```\n@@ -511,7 +511,7 @@ impl CString {\n     /// ```\n     /// use std::ffi::CString;\n     ///\n-    /// let c_string = CString::new(\"foo\").unwrap();\n+    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n     /// let bytes = c_string.into_bytes_with_nul();\n     /// assert_eq!(bytes, vec![b'f', b'o', b'o', b'\\0']);\n     /// ```\n@@ -534,7 +534,7 @@ impl CString {\n     /// ```\n     /// use std::ffi::CString;\n     ///\n-    /// let c_string = CString::new(\"foo\").unwrap();\n+    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n     /// let bytes = c_string.as_bytes();\n     /// assert_eq!(bytes, &[b'f', b'o', b'o']);\n     /// ```\n@@ -554,7 +554,7 @@ impl CString {\n     /// ```\n     /// use std::ffi::CString;\n     ///\n-    /// let c_string = CString::new(\"foo\").unwrap();\n+    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n     /// let bytes = c_string.as_bytes_with_nul();\n     /// assert_eq!(bytes, &[b'f', b'o', b'o', b'\\0']);\n     /// ```\n@@ -573,9 +573,10 @@ impl CString {\n     /// ```\n     /// use std::ffi::{CString, CStr};\n     ///\n-    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n     /// let c_str = c_string.as_c_str();\n-    /// assert_eq!(c_str, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n+    /// assert_eq!(c_str,\n+    ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n     /// ```\n     #[inline]\n     #[stable(feature = \"as_c_str\", since = \"1.20.0\")]\n@@ -592,16 +593,17 @@ impl CString {\n     /// ```\n     /// use std::ffi::{CString, CStr};\n     ///\n-    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n     /// let boxed = c_string.into_boxed_c_str();\n-    /// assert_eq!(&*boxed, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n+    /// assert_eq!(&*boxed,\n+    ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n     /// ```\n     #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n     pub fn into_boxed_c_str(self) -> Box<CStr> {\n         unsafe { Box::from_raw(Box::into_raw(self.into_inner()) as *mut CStr) }\n     }\n \n-    // Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n+    /// Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n     ///\n     /// [`Drop`]: ../ops/trait.Drop.html\n     fn into_inner(self) -> Box<[u8]> {\n@@ -1031,7 +1033,7 @@ impl CStr {\n     /// use std::ffi::{CStr, CString};\n     ///\n     /// unsafe {\n-    ///     let cstring = CString::new(\"hello\").unwrap();\n+    ///     let cstring = CString::new(\"hello\").expect(\"CString::new failed\");\n     ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n     ///     assert_eq!(cstr, &*cstring);\n     /// }\n@@ -1058,7 +1060,7 @@ impl CStr {\n     /// # #![allow(unused_must_use)]\n     /// use std::ffi::{CString};\n     ///\n-    /// let ptr = CString::new(\"Hello\").unwrap().as_ptr();\n+    /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n     /// unsafe {\n     ///     // `ptr` is dangling\n     ///     *ptr;\n@@ -1067,14 +1069,14 @@ impl CStr {\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n     /// lifetime information and the [`CString`] is deallocated immediately after\n-    /// the `CString::new(\"Hello\").unwrap().as_ptr()` expression is evaluated.\n+    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` expression is evaluated.\n     /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n     /// # #![allow(unused_must_use)]\n     /// use std::ffi::{CString};\n     ///\n-    /// let hello = CString::new(\"Hello\").unwrap();\n+    /// let hello = CString::new(\"Hello\").expect(\"CString::new failed\");\n     /// let ptr = hello.as_ptr();\n     /// unsafe {\n     ///     // `ptr` is valid because `hello` is in scope\n@@ -1106,7 +1108,7 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(c_str.to_bytes(), b\"foo\");\n     /// ```\n     #[inline]\n@@ -1132,7 +1134,7 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");\n     /// ```\n     #[inline]\n@@ -1159,7 +1161,7 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(c_str.to_str(), Ok(\"foo\"));\n     /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n@@ -1200,7 +1202,8 @@ impl CStr {\n     /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\").unwrap();\n+    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n+    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n     /// ```\n     ///\n@@ -1210,7 +1213,8 @@ impl CStr {\n     /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\").unwrap();\n+    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n+    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(\n     ///     c_str.to_string_lossy(),\n     ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<str>\n@@ -1231,9 +1235,9 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CString;\n     ///\n-    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n     /// let boxed = c_string.into_boxed_c_str();\n-    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").unwrap());\n+    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").expect(\"CString::new failed\"));\n     /// ```\n     #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n     pub fn into_c_string(self: Box<CStr>) -> CString {"}, {"sha": "feee2422cb662030fadf96215346af3ed8ee312c", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -11,7 +11,7 @@\n use std::cmp;\n use symbol::Symbol;\n \n-/// To find the Levenshtein distance between two strings\n+/// Find the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {\n     // cases which don't require further computation\n     if a.is_empty() {\n@@ -41,10 +41,12 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n     } dcol[t_last + 1]\n }\n \n-/// To find the best match for a given string from an iterator of names\n+/// Find the best match for a given word in the given iterator\n+///\n /// As a loose rule to avoid the obviously incorrect suggestions, it takes\n /// an optional limit for the maximum allowable edit distance, which defaults\n /// to one-third of the given word.\n+///\n /// Besides Levenshtein, we use case insensitive comparison to improve accuracy on an edge case with\n /// a lower(upper)case letters mismatch.\n pub fn find_best_match_for_name<'a, T>(iter_names: T,\n@@ -105,3 +107,39 @@ fn test_lev_distance() {\n     assert_eq!(lev_distance(b, c), 1);\n     assert_eq!(lev_distance(c, b), 1);\n }\n+\n+#[test]\n+fn test_find_best_match_for_name() {\n+    use with_globals;\n+    with_globals(|| {\n+        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"aaaa\", None),\n+            Some(Symbol::intern(\"aaab\"))\n+        );\n+\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"1111111111\", None),\n+            None\n+        );\n+\n+        let input = vec![Symbol::intern(\"aAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"AAAA\", None),\n+            Some(Symbol::intern(\"aAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        // Returns None because `lev_distance > max_dist / 3`\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"aaaa\", None),\n+            None\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"aaaa\", Some(4)),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+    })\n+}"}, {"sha": "69e8140cdf19d64fdedce5e756e269a84d8d7515", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2018-08-01\n+date: 2018-09-11\n rustc: beta\n cargo: beta\n "}, {"sha": "39e9a9bdd6b684493da1400d21413eb55fb59423", "filename": "src/test/run-make-fulldeps/codegen-options-parsing/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Frun-make-fulldeps%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Frun-make-fulldeps%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcodegen-options-parsing%2FMakefile?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -16,11 +16,11 @@ all:\n \t$(RUSTC) -C extra-filename=foo dummy.rs 2>&1\n \t#Option taking no argument\n \t$(RUSTC) -C lto= dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n+\t\t$(CGREP) 'codegen option `lto` - either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted'\n \t$(RUSTC) -C lto=1 dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n+\t\t$(CGREP) 'codegen option `lto` - either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted'\n \t$(RUSTC) -C lto=foo dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n+\t\t$(CGREP) 'codegen option `lto` - either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted'\n \t$(RUSTC) -C lto dummy.rs\n \n \t# Should not link dead code..."}, {"sha": "9b1dc2550b21b7531777e9319da1e402a2170d4d", "filename": "src/test/run-make-fulldeps/lto-smoke/Makefile", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Frun-make-fulldeps%2Flto-smoke%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Frun-make-fulldeps%2Flto-smoke%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-smoke%2FMakefile?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -1,6 +1,30 @@\n -include ../tools.mk\n \n-all:\n+all: noparam bool_true bool_false thin fat\n+\n+noparam:\n \t$(RUSTC) lib.rs\n \t$(RUSTC) main.rs -C lto\n \t$(call RUN,main)\n+\n+bool_true:\n+\t$(RUSTC) lib.rs\n+\t$(RUSTC) main.rs -C lto=yes\n+\t$(call RUN,main)\n+\n+\n+bool_false:\n+\t$(RUSTC) lib.rs\n+\t$(RUSTC) main.rs -C lto=off\n+\t$(call RUN,main)\n+\n+thin:\n+\t$(RUSTC) lib.rs\n+\t$(RUSTC) main.rs -C lto=thin\n+\t$(call RUN,main)\n+\n+fat:\n+\t$(RUSTC) lib.rs\n+\t$(RUSTC) main.rs -C lto=fat\n+\t$(call RUN,main)\n+"}, {"sha": "d6ffca09e96d84a2717d443efac48cd384ed76e9", "filename": "src/test/ui/consts/const-eval/mod-static-with-const-fn.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// New test for #53818: modifying static memory at compile-time is not allowed.\n+// The test should never succeed.\n+\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_let)]\n+\n+use std::cell::UnsafeCell;\n+\n+struct Foo(UnsafeCell<u32>);\n+\n+unsafe impl Send for Foo {}\n+unsafe impl Sync for Foo {}\n+\n+static FOO: Foo = Foo(UnsafeCell::new(42));\n+\n+static BAR: () = unsafe {\n+    *FOO.0.get() = 5;\n+    //~^ ERROR calls in statics are limited to constant functions, tuple structs and tuple variants\n+\n+    // This error is caused by a separate bug that the feature gate error is reported\n+    // even though the feature gate \"const_let\" is active.\n+    //~| statements in statics are unstable (see issue #48821)\n+};\n+\n+fn main() {\n+    println!(\"{}\", unsafe { *FOO.0.get() });\n+}"}, {"sha": "8eaed1dcab116b099a8d952bd4475e17c0ec73f7", "filename": "src/test/ui/consts/const-eval/mod-static-with-const-fn.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.stderr?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -0,0 +1,18 @@\n+error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/mod-static-with-const-fn.rs:27:6\n+   |\n+LL |     *FOO.0.get() = 5;\n+   |      ^^^^^^^^^^^\n+\n+error[E0658]: statements in statics are unstable (see issue #48821)\n+  --> $DIR/mod-static-with-const-fn.rs:27:5\n+   |\n+LL |     *FOO.0.get() = 5;\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0015, E0658.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "1ea7b973c465be969fb873d44d5519b4ca975183", "filename": "src/test/ui/consts/const-size_of-cycle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-musl\n+// ignore-x86\n // error-pattern: cycle detected\n \n struct Foo {"}, {"sha": "68e579788bca1e063e7c2e69d053b483a3ddc4a7", "filename": "src/test/ui/elide-errors-on-mismatched-tuple.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Hide irrelevant E0277 errors (#50333)\n+\n+trait T {}\n+\n+struct A;\n+impl T for A {}\n+impl A {\n+    fn new() -> Self {\n+        Self {}\n+    }\n+}\n+\n+fn main() {\n+    let (a, b, c) = (A::new(), A::new()); // This tuple is 2 elements, should be three\n+    //~^ ERROR mismatched types\n+    let ts: Vec<&T> = vec![&a, &b, &c];\n+    // There is no E0277 error above, as `a`, `b` and `c` are `TyErr`\n+}"}, {"sha": "b901175d53450b0bccf81719aabdb6931f49bdee", "filename": "src/test/ui/elide-errors-on-mismatched-tuple.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/elide-errors-on-mismatched-tuple.rs:24:9\n+   |\n+LL |     let (a, b, c) = (A::new(), A::new()); // This tuple is 2 elements, should be three\n+   |         ^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n+   |\n+   = note: expected type `(A, A)`\n+              found type `(_, _, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "6cf8000f6ad2763198673cdaad1288999d503ff4", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.rs?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-musl\n+// ignore-x86\n+\n use std::fmt::Debug;\n \n trait Foo {"}, {"sha": "d777779a881e04556b06ab81bea89abc3fac2cff", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f921d7a8d8dee7b511e4956e06a80f550003afc/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr?ref=4f921d7a8d8dee7b511e4956e06a80f550003afc", "patch": "@@ -1,5 +1,5 @@\n error[E0643]: method `foo` has incompatible signature for trait\n-  --> $DIR/impl-generic-mismatch.rs:18:12\n+  --> $DIR/impl-generic-mismatch.rs:21:12\n    |\n LL |     fn foo(&self, _: &impl Debug);\n    |                       ---------- declaration in trait here\n@@ -12,7 +12,7 @@ LL |     fn foo(&self, _: &impl Debug) { }\n    |          --           ^^^^^^^^^^\n \n error[E0643]: method `bar` has incompatible signature for trait\n-  --> $DIR/impl-generic-mismatch.rs:27:23\n+  --> $DIR/impl-generic-mismatch.rs:30:23\n    |\n LL |     fn bar<U: Debug>(&self, _: &U);\n    |            - declaration in trait here\n@@ -25,7 +25,7 @@ LL |     fn bar<U: Debug>(&self, _: &U) { }\n    |           ^^^^^^^^^^            ^\n \n error[E0643]: method `hash` has incompatible signature for trait\n-  --> $DIR/impl-generic-mismatch.rs:38:33\n+  --> $DIR/impl-generic-mismatch.rs:41:33\n    |\n LL |     fn hash(&self, hasher: &mut impl Hasher) {}\n    |                                 ^^^^^^^^^^^ expected generic parameter, found `impl Trait`"}]}