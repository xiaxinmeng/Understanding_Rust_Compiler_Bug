{"sha": "532439faa17bea59a5574e4c8379d2aad37d9967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMjQzOWZhYTE3YmVhNTlhNTU3NGU0YzgzNzlkMmFhZDM3ZDk5Njc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-29T09:28:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T18:01:37Z"}, "message": "add a README describing the whole design", "tree": {"sha": "5e80e1fd87b1eaab6b4b1b5a68ed3cdda48a4f5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e80e1fd87b1eaab6b4b1b5a68ed3cdda48a4f5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532439faa17bea59a5574e4c8379d2aad37d9967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532439faa17bea59a5574e4c8379d2aad37d9967", "html_url": "https://github.com/rust-lang/rust/commit/532439faa17bea59a5574e4c8379d2aad37d9967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532439faa17bea59a5574e4c8379d2aad37d9967/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9c8a2b54b2eca0aaf9a0642b89a0ba1af6d8d78", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c8a2b54b2eca0aaf9a0642b89a0ba1af6d8d78", "html_url": "https://github.com/rust-lang/rust/commit/d9c8a2b54b2eca0aaf9a0642b89a0ba1af6d8d78"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "143e6e70a82b36abda762c01e1f609ebd57cdfe0", "filename": "src/librustc/mir/README.md", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=532439faa17bea59a5574e4c8379d2aad37d9967", "patch": "@@ -0,0 +1,142 @@\n+# MIR definition and pass system\n+\n+This file contains the definition of the MIR datatypes along with the\n+various types for the \"MIR Pass\" system, which lets you easily\n+register and define new MIR transformations and analyses.\n+\n+Most of the code that operates on MIR can be found in the\n+`librustc_mir` crate or other crates. The code found here in\n+`librustc` is just the datatype definitions, alonging the functions\n+which operate on MIR to be placed everywhere else.\n+\n+## MIR Data Types and visitor\n+\n+The main MIR data type is `rustc::mir::Mir`, defined in `mod.rs`.\n+There is also the MIR visitor (in `visit.rs`) which allows you to walk\n+the MIR and override what actions will be taken at various points (you\n+can visit in either shared or mutable mode; the latter allows changing\n+the MIR in place). Finally `traverse.rs` contains various traversal\n+routines for visiting the MIR CFG in [different standard orders][traversal]\n+(e.g. pre-order, reverse post-order, and so forth).\n+\n+[traversal]: https://en.wikipedia.org/wiki/Tree_traversal\n+\n+## MIR pass suites and their integration into the query system\n+\n+As a MIR *consumer*, you are expected to use one of the queries that\n+returns a \"final MIR\". As of the time of this writing, there is only\n+one: `optimized_mir(def_id)`, but more are expected to come in the\n+future. For foreign def-ids, we simply read the MIR from the other\n+crate's metadata. But for local query, this query will construct the\n+MIR and then iteratively optimize it by putting it through various\n+pipeline stages. This section describes those pipeline stages and how\n+you can extend them.\n+\n+Here is a diagram showing the various MIR queries involved in producing\n+the final `optimized_mir()` for a single def-id `D`. The arrows here\n+indicate how data flows from query to query.\n+\n+```\n+mir_build(D)\n+  -> mir_pass((0,0,D))              ---+ each suite consists of many passes\n+    -> ...                             |\n+      -> mir_pass((0,N,D))             |\n+        -> mir_suite((0,D))         ---+ ---+ there are several suites\n+          -> ...                            |\n+            -> mir_suite((M,D))          ---+\n+              -> mir_optimized(D)\n+```\n+\n+The MIR transformation pipeline is organized into **suites**.  When\n+you ask for `mir_optimized(D)`, it will turn around and request the\n+result from the final **suite** of MIR passes\n+(`mir_suite((M,D))`). This will in turn (eventually) trigger the MIR\n+to be build and then passes through each of the optimization suites.\n+Each suite internally triggers one query for each of its passes\n+(`mir_pass(...)`).\n+\n+The reason for the suites is that they represent points in the MIR\n+transformation pipeline where other bits of code are interested in\n+observing. For example, the `MIR_CONST` suite defines the point where\n+analysis for constant rvalues and expressions can take\n+place. `MIR_OPTIMIZED` naturally represents the point where we\n+actually generate machine code. Nobody should ever request the result\n+of an individual *pass*, at least outside of the transformation\n+pipeline: this allows us to add passes into the appropriate suite\n+without having to modify anything else in the compiler.\n+\n+### Stealing\n+\n+Each of these intermediate queries yields up a `&'tcx\n+Steal<Mir<'tcx>>`, allocated using `tcx.alloc_steal_mir()`. This\n+indicates that the result may be **stolen** by the next pass -- this\n+is an optimization to avoid cloning the MIR. Attempting to use a\n+stolen result will cause a panic in the compiler. Therefore, it is\n+important that you not read directly from these intermediate queries\n+except as part of the MIR processing pipeline.\n+\n+Because of this stealing mechanism, some care must also be taken to\n+ensure that, before the MIR at a particular phase in the processing\n+pipeline is stolen, anyone who may want to read from it has already\n+done so. Sometimes this requires **forcing** queries\n+(`ty::queries::foo::force(...)`) during an optimization pass -- this\n+will force a query to execute even though you don't directly require\n+its result. The query can then read the MIR it needs, and -- once it\n+is complete -- you can steal it.\n+\n+As an example, consider MIR const qualification. It wants to read the\n+result produced by the `MIR_CONST` suite. However, that result will be\n+**stolen** by the first pass in the next suite (that pass performs\n+const promotion):\n+\n+```\n+mir_suite((MIR_CONST,D)) --read-by--> mir_const_qualif(D)\n+            |\n+        stolen-by\n+            |\n+            v\n+mir_pass((MIR_VALIDATED,0,D))\n+```\n+\n+Therefore, the const promotion pass (the `mir_pass()` in the diagram)\n+will **force** `mir_const_qualif` before it actually steals, thus\n+ensuring that the reads have already happened (and the final result is\n+cached).\n+\n+### Implementing and registering a pass\n+\n+To create a new MIR pass, you have to implement one of the MIR pass\n+traits. There are several traits, and you want to pick the most\n+specific one that applies to your pass. They are described here in\n+order of preference. Once you have implemented a trait for your type\n+`Foo`, you then have to insert `Foo` into one of the suites; this is\n+done in `librustc_driver/driver.rs` by invoking `push_pass()` with the\n+appropriate suite.\n+\n+**The `MirPass` trait.** For the most part, a MIR pass works by taking\n+as input the MIR for a single function and mutating it imperatively to\n+perform an optimization. To write such a pass, you can implement the\n+`MirPass` trait, which has a single callback that takes an `&mut Mir`.\n+\n+**The `DefIdPass` trait.** When a `MirPass` trait is executed, the\n+system will automatically steal the result of the previous pass and\n+supply it to you. (See the section on queries and stealing below.)\n+Sometimes you don't want to steal the result of the previous pass\n+right away. In such cases, you can define a `DefIdPass`, which simply\n+gets a callback and lets you decide when to steal the previous result.\n+\n+**The `Pass` trait.** The most primitive but flexible trait is `Pass`.\n+Unlike the other pass types, it returns a `Multi` result, which means\n+it scan be used for interprocedural passes which mutate more than one\n+MIR at a time (e.g., `inline`).\n+\n+### The MIR Context\n+\n+All of the passes when invoked take a `MirCtxt` object. This contains\n+various methods to find out (e.g.) the current pass suite and pass\n+index, the def-id you are operating on, and so forth. You can also\n+access the MIR for the current def-id using `read_previous_mir()`; the\n+\"previous\" refers to the fact that this will be the MIR that was\n+output by the previous pass. Finally, you can `steal_previous_mir()`\n+to steal the output of the current pass (in which case you get\n+ownership of the MIR)."}, {"sha": "b517ebabbe767622e9b4ab7e1b1e099a328bf3f1", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=532439faa17bea59a5574e4c8379d2aad37d9967", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! MIR datatypes and passes. See [the README](README.md) for details.\n+\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};"}, {"sha": "69dc83f6dcc84e5eb0bb659713adb54e7b2ea908", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=532439faa17bea59a5574e4c8379d2aad37d9967", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! See [the README](README.md) for details on writing your own pass.\n+\n use hir;\n use hir::def_id::DefId;\n use hir::map::DefPathData;"}, {"sha": "b37dbc6411baf82ce6e4319d08e757dff8d09c31", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532439faa17bea59a5574e4c8379d2aad37d9967/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=532439faa17bea59a5574e4c8379d2aad37d9967", "patch": "@@ -801,17 +801,23 @@ define_maps! { <'tcx>\n     /// Performs the initial MIR construction. You almost certainly do not\n     /// want to use this query, because its output is intended to be stolen\n     /// immediately by the MIR passes below. Consider `optimized_mir` instead.\n+    ///\n+    /// See the README for the `mir` module for details.\n     [] mir_build: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// Fetch the MIR for a given def-id after the given set of passes has ben\n     /// applied to it. This is mostly an \"intermediate\" query. Normally, you would\n     /// prefer to use `optimized_mir(def_id)`, which will fetch the MIR after all\n     /// optimizations and so forth.\n+    ///\n+    /// See the README for the `mir` module for details.\n     [] mir_suite: mir_suite((MirSuite, DefId)) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// Fetch the MIR for a given def-id after a given pass has been executed. This is\n     /// **only** intended to be used by the `mir_suite` provider -- if you are using it\n     /// manually, you're doing it wrong.\n+    ///\n+    /// See the README for the `mir` module for details.\n     [multi] mir_pass: mir_pass((MirSuite, MirPassIndex, DefId)) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready"}]}