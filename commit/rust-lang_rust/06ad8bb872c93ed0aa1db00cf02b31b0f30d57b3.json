{"sha": "06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YWQ4YmI4NzJjOTNlZDBhYTFkYjAwY2YwMmIzMWIwZjMwZDU3YjM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-13T23:49:17Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-14T00:08:20Z"}, "message": "Implement suggestions for traits to import.\n\nFor a call like `foo.bar()` where the method `bar` can't be resolved,\nthe compiler will search for traits that have methods with name `bar` to\ngive a more informative error, providing a list of possibilities.\n\nCloses #7643.", "tree": {"sha": "7c55ea21e2f425158bff62cbddd16313b11b90b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c55ea21e2f425158bff62cbddd16313b11b90b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "html_url": "https://github.com/rust-lang/rust/commit/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af506fa5d15b892c2fa6df442e106e1afcb7abca", "url": "https://api.github.com/repos/rust-lang/rust/commits/af506fa5d15b892c2fa6df442e106e1afcb7abca", "html_url": "https://github.com/rust-lang/rust/commit/af506fa5d15b892c2fa6df442e106e1afcb7abca"}], "stats": {"total": 251, "additions": 249, "deletions": 2}, "files": [{"sha": "8a7c7b38287ecf4e2fb09b0b18bed0131daf4089", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -174,6 +174,9 @@ impl Session {\n     pub fn fileline_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().fileline_note(sp, msg)\n     }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.diagnostic().fileline_help(sp, msg)\n+    }\n     pub fn note(&self, msg: &str) {\n         self.diagnostic().handler().note(msg)\n     }"}, {"sha": "a28b4ac34753b5317227c19973a9f8b65dbca473", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -29,7 +29,7 @@ use syntax::codemap::Span;\n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n \n-pub use self::suggest::report_error;\n+pub use self::suggest::{report_error, AllTraitsVec};\n \n mod confirm;\n mod doc;"}, {"sha": "aab1fa2a958171bf214977e75ac6a0b27e6b15af", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 166, "deletions": 1, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -11,14 +11,21 @@\n //! Give useful errors and suggestions to users when a method can't be\n //! found or is otherwise invalid.\n \n+use CrateCtxt;\n+\n use astconv::AstConv;\n use check::{self, FnCtxt};\n use middle::ty::{self, Ty};\n+use middle::def;\n+use metadata::{csearch, cstore, decoder};\n use util::ppaux::UserString;\n \n-use syntax::ast;\n+use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n \n+use std::cell;\n+use std::cmp::Ordering;\n+\n use super::{MethodError, CandidateSource, impl_method, trait_method};\n \n pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -67,6 +74,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                 report_candidates(fcx, span, method_name, static_sources);\n             }\n+\n+            suggest_traits_to_import(fcx, span, rcvr_ty, method_name)\n         }\n \n         MethodError::Ambiguity(sources) => {\n@@ -120,3 +129,159 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n }\n+\n+\n+pub type AllTraitsVec = Vec<TraitInfo>;\n+\n+fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      span: Span,\n+                                      _rcvr_ty: Ty<'tcx>,\n+                                      method_name: ast::Name)\n+{\n+    let tcx = fcx.tcx();\n+\n+    let mut candidates = all_traits(fcx.ccx)\n+        .filter(|info| trait_method(tcx, info.def_id, method_name).is_some())\n+        .collect::<Vec<_>>();\n+\n+    if candidates.len() > 0 {\n+        // sort from most relevant to least relevant\n+        candidates.sort_by(|a, b| a.cmp(b).reverse());\n+\n+        let method_ustring = method_name.user_string(tcx);\n+\n+        span_help!(fcx.sess(), span,\n+                   \"methods from traits can only be called if the trait is implemented \\\n+                    and in scope; the following trait{s} define{inv_s} a method `{name}`:\",\n+                   s = if candidates.len() == 1 {\"\"} else {\"s\"},\n+                   inv_s = if candidates.len() == 1 {\"s\"} else {\"\"},\n+                   name = method_ustring);\n+\n+        for (i, trait_info) in candidates.iter().enumerate() {\n+            // provide a good-as-possible span; the span of\n+            // the trait if it is local, or the span of the\n+            // method call itself if not\n+            let trait_span = fcx.tcx().map.def_id_span(trait_info.def_id, span);\n+\n+            fcx.sess().fileline_help(trait_span,\n+                                     &*format!(\"candidate #{}: `{}`\",\n+                                               i + 1,\n+                                               ty::item_path_str(fcx.tcx(), trait_info.def_id)))\n+        }\n+    }\n+}\n+\n+#[derive(Copy)]\n+pub struct TraitInfo {\n+    def_id: ast::DefId,\n+}\n+\n+impl TraitInfo {\n+    fn new(def_id: ast::DefId) -> TraitInfo {\n+        TraitInfo {\n+            def_id: def_id,\n+        }\n+    }\n+}\n+impl PartialEq for TraitInfo {\n+    fn eq(&self, other: &TraitInfo) -> bool {\n+        self.cmp(other) == Ordering::Equal\n+    }\n+}\n+impl Eq for TraitInfo {}\n+impl PartialOrd for TraitInfo {\n+    fn partial_cmp(&self, other: &TraitInfo) -> Option<Ordering> { Some(self.cmp(other)) }\n+}\n+impl Ord for TraitInfo {\n+    fn cmp(&self, other: &TraitInfo) -> Ordering {\n+        // accessible traits are more important/relevant than\n+        // inaccessible ones, local crates are more important than\n+        // remote ones (local: cnum == 0), and NodeIds just for\n+        // totality.\n+\n+        let lhs = (other.def_id.krate, other.def_id.node);\n+        let rhs = (self.def_id.krate, self.def_id.node);\n+        lhs.cmp(&rhs)\n+    }\n+}\n+\n+/// Retrieve all traits in this crate and any dependent crates.\n+fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n+    if ccx.all_traits.borrow().is_none() {\n+        use syntax::visit;\n+\n+        let mut traits = vec![];\n+\n+        // Crate-local:\n+        //\n+        // meh.\n+        struct Visitor<'a, 'b: 'a, 'tcx: 'a + 'b> {\n+            traits: &'a mut AllTraitsVec,\n+        }\n+        impl<'v,'a, 'b, 'tcx> visit::Visitor<'v> for Visitor<'a, 'b, 'tcx> {\n+            fn visit_item(&mut self, i: &'v ast::Item) {\n+                match i.node {\n+                    ast::ItemTrait(..) => {\n+                        self.traits.push(TraitInfo::new(ast_util::local_def(i.id)));\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_item(self, i)\n+            }\n+        }\n+        visit::walk_crate(&mut Visitor {\n+            traits: &mut traits\n+        }, ccx.tcx.map.krate());\n+\n+        // Cross-crate:\n+        fn handle_external_def(traits: &mut AllTraitsVec,\n+                               ccx: &CrateCtxt,\n+                               cstore: &cstore::CStore,\n+                               dl: decoder::DefLike) {\n+            match dl {\n+                decoder::DlDef(def::DefTrait(did)) => {\n+                    traits.push(TraitInfo::new(did));\n+                }\n+                decoder::DlDef(def::DefMod(did)) => {\n+                    csearch::each_child_of_item(cstore, did, |dl, _, _| {\n+                        handle_external_def(traits, ccx, cstore, dl)\n+                    })\n+                }\n+                _ => {}\n+            }\n+        }\n+        let cstore = &ccx.tcx.sess.cstore;\n+        cstore.iter_crate_data(|&mut: cnum, _| {\n+            csearch::each_top_level_item_of_crate(cstore, cnum, |dl, _, _| {\n+                handle_external_def(&mut traits, ccx, cstore, dl)\n+            })\n+        });\n+\n+        *ccx.all_traits.borrow_mut() = Some(traits);\n+    }\n+\n+    let borrow = ccx.all_traits.borrow();\n+    assert!(borrow.is_some());\n+    AllTraits {\n+        borrow: borrow,\n+        idx: 0\n+    }\n+}\n+\n+struct AllTraits<'a> {\n+    borrow: cell::Ref<'a Option<AllTraitsVec>>,\n+    idx: usize\n+}\n+\n+impl<'a> Iterator for AllTraits<'a> {\n+    type Item = TraitInfo;\n+\n+    fn next(&mut self) -> Option<TraitInfo> {\n+        let AllTraits { ref borrow, ref mut idx } = *self;\n+        // ugh.\n+        borrow.as_ref().unwrap().get(*idx).map(|info| {\n+            *idx += 1;\n+            *info\n+        })\n+    }\n+}"}, {"sha": "88fe88bf2654052346aff8a87763b075df8b5f61", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -108,6 +108,8 @@ use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n use syntax::ast_util::local_def;\n \n+use std::cell::RefCell;\n+\n mod check;\n mod rscope;\n mod astconv;\n@@ -123,6 +125,11 @@ struct TypeAndSubsts<'tcx> {\n struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: ty::TraitMap,\n+    /// A vector of every trait accessible in the whole crate\n+    /// (i.e. including those from subcrates). This is used only for\n+    /// error reporting, and so is lazily initialised and generally\n+    /// shouldn't taint the common path (hence the RefCell).\n+    all_traits: RefCell<Option<check::method::AllTraitsVec>>,\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n@@ -320,6 +327,7 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n+        all_traits: RefCell::new(None),\n         tcx: tcx\n     };\n "}, {"sha": "36058b694eac4e56cecd5c3abd727f4a1daadae5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -118,6 +118,9 @@ impl SpanHandler {\n     pub fn fileline_note(&self, sp: Span, msg: &str) {\n         self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n     }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Help);\n+    }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n         panic!(ExplicitBug);"}, {"sha": "fdeace00d4ca2277da72e02cdd50cd627ec81183", "filename": "src/test/auxiliary/no_method_suggested_traits.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use reexport::Reexported;\n+\n+pub mod foo {\n+    pub trait PubPub {\n+        fn method(&self);\n+    }\n+}\n+pub mod bar {\n+    trait PubPriv {\n+        fn method(&self);\n+    }\n+}\n+mod qux {\n+    pub trait PrivPub {\n+        fn method(&self);\n+    }\n+}\n+mod quz {\n+    trait PrivPriv {\n+        fn method(&self);\n+    }\n+}\n+\n+mod reexport {\n+    pub trait Reexported {\n+        fn method(&self);\n+    }\n+}"}, {"sha": "2565d2b7302672b9b67ee536374465eab2d7eefa", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:no_method_suggested_traits.rs\n+\n+extern crate no_method_suggested_traits;\n+\n+mod foo {\n+    trait Bar { //~ HELP `foo::Bar`\n+        fn method(&self);\n+    }\n+}\n+\n+fn main() {\n+    1u32.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following traits define a method `method`\n+    //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+    //~^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n+    //~^^^^^ HELP `no_method_suggested_traits::bar::PubPriv`\n+    //~^^^^^^ HELP `no_method_suggested_traits::qux::PrivPub`\n+    //~^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n+}"}]}