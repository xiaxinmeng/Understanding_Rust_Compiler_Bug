{"sha": "86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "node_id": "C_kwDOAAsO6NoAKDg2YzZlYmVlOGZhMGE1YWQxZTE4ZTM3NTExM2IwNmJkMjg0OWI2MzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-16T21:10:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-16T21:10:08Z"}, "message": "Auto merge of #100644 - TaKO8Ki:rollup-n0o6a1t, r=TaKO8Ki\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #100243 (Remove opt_remap_env_constness from rustc_query_impl)\n - #100625 (Add `IpDisplayBuffer` helper struct.)\n - #100629 (Use `merged_ty` method instead of rewriting it every time)\n - #100630 (rustdoc JSON: Fix ICE with `pub extern crate self as <self_crate_name>`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "445eb9f6c6bb0e986182a532f34f7385ab11cb59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/445eb9f6c6bb0e986182a532f34f7385ab11cb59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "html_url": "https://github.com/rust-lang/rust/commit/86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5746c752f4e3f294cd252f7dd611a1908b12dd8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5746c752f4e3f294cd252f7dd611a1908b12dd8e", "html_url": "https://github.com/rust-lang/rust/commit/5746c752f4e3f294cd252f7dd611a1908b12dd8e"}, {"sha": "af74e7232f4213a69f1662beb8d309884a66def5", "url": "https://api.github.com/repos/rust-lang/rust/commits/af74e7232f4213a69f1662beb8d309884a66def5", "html_url": "https://github.com/rust-lang/rust/commit/af74e7232f4213a69f1662beb8d309884a66def5"}], "stats": {"total": 125, "additions": 78, "deletions": 47}, "files": [{"sha": "339683cf68958191ca697e8c0501eed59b465cc7", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -233,21 +233,10 @@ macro_rules! get_provider {\n     };\n }\n \n-macro_rules! opt_remap_env_constness {\n-    ([][$name:ident]) => {};\n-    ([(remap_env_constness) $($rest:tt)*][$name:ident]) => {\n-        let $name = $name.without_const();\n-    };\n-    ([$other:tt $($modifiers:tt)*][$name:ident]) => {\n-        opt_remap_env_constness!([$($modifiers)*][$name])\n-    };\n-}\n-\n macro_rules! define_queries {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n         [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-\n         define_queries_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n@@ -259,7 +248,6 @@ macro_rules! define_queries {\n             // Create an eponymous constructor for each query.\n             $(#[allow(nonstandard_style)] $(#[$attr])*\n             pub fn $name<$tcx>(tcx: QueryCtxt<$tcx>, key: query_keys::$name<$tcx>) -> QueryStackFrame {\n-                opt_remap_env_constness!([$($modifiers)*][key]);\n                 let kind = dep_graph::DepKind::$name;\n                 let name = stringify!($name);\n                 // Disable visible paths printing for performance reasons.\n@@ -549,7 +537,6 @@ macro_rules! define_queries_struct {\n                 key: query_keys::$name<$tcx>,\n                 mode: QueryMode,\n             ) -> Option<query_stored::$name<$tcx>> {\n-                opt_remap_env_constness!([$($modifiers)*][key]);\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 get_query::<queries::$name<$tcx>, _>(qcx, span, key, mode)\n             })*"}, {"sha": "def592c46c2e514a4614813094b79fe193deaf3c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -1488,14 +1488,14 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     // `break`, we want to call the `()` \"expected\"\n                     // since it is implied by the syntax.\n                     // (Note: not all force-units work this way.)\"\n-                    (expression_ty, self.final_ty.unwrap_or(self.expected_ty))\n+                    (expression_ty, self.merged_ty())\n                 } else {\n                     // Otherwise, the \"expected\" type for error\n                     // reporting is the current unification type,\n                     // which is basically the LUB of the expressions\n                     // we've seen so far (combined with the expected\n                     // type)\n-                    (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n+                    (self.merged_ty(), expression_ty)\n                 };\n                 let (expected, found) = fcx.resolve_vars_if_possible((expected, found));\n "}, {"sha": "a8d6645794ae5d5fcd06ef2bca51018cb620aa10", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -294,6 +294,8 @@\n #![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(strict_provenance)]\n+#![feature(maybe_uninit_uninit_array)]\n+#![feature(const_maybe_uninit_uninit_array)]\n //\n // Library features (alloc):\n #![feature(alloc_layout_extra)]"}, {"sha": "189754a161e71860dba0614ad0e150fa040a8599", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -3,12 +3,14 @@\n mod tests;\n \n use crate::cmp::Ordering;\n-use crate::fmt::{self, Write as FmtWrite};\n-use crate::io::Write as IoWrite;\n+use crate::fmt::{self, Write};\n use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{FromInner, IntoInner};\n \n+mod display_buffer;\n+use display_buffer::IpDisplayBuffer;\n+\n /// An IP address, either IPv4 or IPv6.\n ///\n /// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n@@ -991,21 +993,19 @@ impl From<Ipv6Addr> for IpAddr {\n impl fmt::Display for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let octets = self.octets();\n-        // Fast Path: if there's no alignment stuff, write directly to the buffer\n+\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if fmt.precision().is_none() && fmt.width().is_none() {\n             write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n         } else {\n-            const IPV4_BUF_LEN: usize = 15; // Long enough for the longest possible IPv4 address\n-            let mut buf = [0u8; IPV4_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n+            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n \n-            // Note: The call to write should never fail, hence the unwrap\n-            write!(buf_slice, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n-            let len = IPV4_BUF_LEN - buf_slice.len();\n+            let mut buf = IpDisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n+            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n \n-            // This unsafe is OK because we know what is being written to the buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            fmt.pad(buf)\n+            fmt.pad(buf.as_str())\n         }\n     }\n }\n@@ -1708,8 +1708,8 @@ impl Ipv6Addr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write out the IP address to\n-        // f. Otherwise, write it to a local buffer, then use f.pad.\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if f.precision().is_none() && f.width().is_none() {\n             let segments = self.segments();\n \n@@ -1780,22 +1780,13 @@ impl fmt::Display for Ipv6Addr {\n                 }\n             }\n         } else {\n-            // Slow path: write the address to a local buffer, then use f.pad.\n-            // Defined recursively by using the fast path to write to the\n-            // buffer.\n-\n-            // This is the largest possible size of an IPv6 address\n-            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n-            let mut buf = [0u8; IPV6_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n-\n-            // Note: This call to write should never fail, so unwrap is okay.\n-            write!(buf_slice, \"{}\", self).unwrap();\n-            let len = IPV6_BUF_LEN - buf_slice.len();\n-\n-            // This is safe because we know exactly what can be in this buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            f.pad(buf)\n+            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n+\n+            let mut buf = IpDisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n+            write!(buf, \"{}\", self).unwrap();\n+\n+            f.pad(buf.as_str())\n         }\n     }\n }"}, {"sha": "bd852d5da8ec5eca87defa2b346e4e6b90ff9651", "filename": "library/std/src/net/ip/display_buffer.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/library%2Fstd%2Fsrc%2Fnet%2Fip%2Fdisplay_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/library%2Fstd%2Fsrc%2Fnet%2Fip%2Fdisplay_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Fdisplay_buffer.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -0,0 +1,40 @@\n+use crate::fmt;\n+use crate::mem::MaybeUninit;\n+use crate::str;\n+\n+/// Used for slow path in `Display` implementations when alignment is required.\n+pub struct IpDisplayBuffer<const SIZE: usize> {\n+    buf: [MaybeUninit<u8>; SIZE],\n+    len: usize,\n+}\n+\n+impl<const SIZE: usize> IpDisplayBuffer<SIZE> {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { buf: MaybeUninit::uninit_array(), len: 0 }\n+    }\n+\n+    #[inline]\n+    pub fn as_str(&self) -> &str {\n+        // SAFETY: `buf` is only written to by the `fmt::Write::write_str` implementation\n+        // which writes a valid UTF-8 string to `buf` and correctly sets `len`.\n+        unsafe {\n+            let s = MaybeUninit::slice_assume_init_ref(&self.buf[..self.len]);\n+            str::from_utf8_unchecked(s)\n+        }\n+    }\n+}\n+\n+impl<const SIZE: usize> fmt::Write for IpDisplayBuffer<SIZE> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        let bytes = s.as_bytes();\n+\n+        if let Some(buf) = self.buf.get_mut(self.len..(self.len + bytes.len())) {\n+            MaybeUninit::write_slice(buf, bytes);\n+            self.len += bytes.len();\n+            Ok(())\n+        } else {\n+            Err(fmt::Error)\n+        }\n+    }\n+}"}, {"sha": "7b1b059e14dcb6cca8bd5aeef59392ca5eeb7212", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -209,11 +209,11 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 }\n \n                 types::ItemEnum::Method(_)\n+                | types::ItemEnum::Module(_)\n                 | types::ItemEnum::AssocConst { .. }\n                 | types::ItemEnum::AssocType { .. }\n                 | types::ItemEnum::PrimitiveType(_) => true,\n-                types::ItemEnum::Module(_)\n-                | types::ItemEnum::ExternCrate { .. }\n+                types::ItemEnum::ExternCrate { .. }\n                 | types::ItemEnum::Import(_)\n                 | types::ItemEnum::StructField(_)\n                 | types::ItemEnum::Variant(_)"}, {"sha": "fda38056a094a97cff8a31215d1e45eafcc4a0e9", "filename": "src/test/rustdoc-json/reexport/export_extern_crate_as_self.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/src%2Ftest%2Frustdoc-json%2Freexport%2Fexport_extern_crate_as_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c6ebee8fa0a5ad1e18e375113b06bd2849b634/src%2Ftest%2Frustdoc-json%2Freexport%2Fexport_extern_crate_as_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fexport_extern_crate_as_self.rs?ref=86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "patch": "@@ -0,0 +1,11 @@\n+//! Regression test for <https://github.com/rust-lang/rust/issues/100531>\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+#![crate_name = \"export_extern_crate_as_self\"]\n+\n+// ignore-tidy-linelength\n+\n+// @is export_extern_crate_as_self.json \"$.index[*][?(@.kind=='module')].name\" \\\"export_extern_crate_as_self\\\"\n+pub extern crate self as export_extern_crate_as_self; // Must be the same name as the crate already has"}]}