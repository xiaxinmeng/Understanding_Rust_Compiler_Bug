{"sha": "8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0", "node_id": "C_kwDOAAsO6NoAKDhjNjBmNDQ4NzczM2ZiOGZkYmUyY2ZjMmJiZGI5ZGFiNzM2NDIzZjA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-10T11:10:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-10T11:10:02Z"}, "message": "Rollup merge of #93843 - solid-rs:fix-kmc-solid-condvar, r=m-ou-se\n\nkmc-solid: Fix wait queue manipulation errors in the `Condvar` implementation\n\nThis PR fixes a number of bugs in the `Condvar` wait queue implementation used by the [`*-kmc-solid_*`](https://doc.rust-lang.org/nightly/rustc/platform-support/kmc-solid.html) Tier 3 targets. These bugs can occur when there are multiple threads waiting on the same `Condvar` and sometimes manifest as an `unwrap` failure.", "tree": {"sha": "12a64fb2b34aac646f821cedbb38195b84c9cf50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12a64fb2b34aac646f821cedbb38195b84c9cf50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBPKLCRBK7hj4Ov3rIwAArXUIAI3OO9pm1oajRl1WGXbDU1/E\nUFTkPojsxPjexQHPvE7v3nMV2fCphiBeeXpizEB6YhdnCfvQSGuApc4rF64is3xo\nb50h/QZgQp/DQvC6Wl1RhNrTVQcM2zivNzR5S2MDOX7vosOfYCGESp2PTDb7GNBs\nIodnZWSWf0ONjocjqVSCo+ne4Z/l7Slytgt4qIoOkKv4fp753Y95DwaMT177N+1V\nF81L6HCclIPAUufo8j9o+H16p2wD8npIwvlBbgKqX2e0ragqglbQCtiLxSP28rD6\nEDBPLDmURILOn12iUqosw4I4nk8m2cRCkohk3H50fSwoPR4GjS1glCPG8I6SlHg=\n=vZyB\n-----END PGP SIGNATURE-----\n", "payload": "tree 12a64fb2b34aac646f821cedbb38195b84c9cf50\nparent 4256165411393e9f16ac60cbaa1b5e9f3876cbd0\nparent 1d180caf1a14b3316652fa856499e44abec393b2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644491402 +0100\ncommitter GitHub <noreply@github.com> 1644491402 +0100\n\nRollup merge of #93843 - solid-rs:fix-kmc-solid-condvar, r=m-ou-se\n\nkmc-solid: Fix wait queue manipulation errors in the `Condvar` implementation\n\nThis PR fixes a number of bugs in the `Condvar` wait queue implementation used by the [`*-kmc-solid_*`](https://doc.rust-lang.org/nightly/rustc/platform-support/kmc-solid.html) Tier 3 targets. These bugs can occur when there are multiple threads waiting on the same `Condvar` and sometimes manifest as an `unwrap` failure.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0", "html_url": "https://github.com/rust-lang/rust/commit/8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4256165411393e9f16ac60cbaa1b5e9f3876cbd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4256165411393e9f16ac60cbaa1b5e9f3876cbd0", "html_url": "https://github.com/rust-lang/rust/commit/4256165411393e9f16ac60cbaa1b5e9f3876cbd0"}, {"sha": "1d180caf1a14b3316652fa856499e44abec393b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d180caf1a14b3316652fa856499e44abec393b2", "html_url": "https://github.com/rust-lang/rust/commit/1d180caf1a14b3316652fa856499e44abec393b2"}], "stats": {"total": 13, "additions": 9, "deletions": 4}, "files": [{"sha": "2992a6a542901ccd5fc0d521368344bdbc8fd437", "filename": "library/std/src/sys/itron/condvar.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs?ref=8c60f4487733fb8fdbe2cfc2bbdb9dab736423f0", "patch": "@@ -15,10 +15,12 @@ unsafe impl Sync for Condvar {}\n pub type MovableCondvar = Condvar;\n \n impl Condvar {\n+    #[inline]\n     pub const fn new() -> Condvar {\n         Condvar { waiters: SpinMutex::new(waiter_queue::WaiterQueue::new()) }\n     }\n \n+    #[inline]\n     pub unsafe fn init(&mut self) {}\n \n     pub unsafe fn notify_one(&self) {\n@@ -190,7 +192,7 @@ mod waiter_queue {\n                     let insert_after = {\n                         let mut cursor = head.last;\n                         loop {\n-                            if waiter.priority <= cursor.as_ref().priority {\n+                            if waiter.priority >= cursor.as_ref().priority {\n                                 // `cursor` and all previous waiters have the same or higher\n                                 // priority than `current_task_priority`. Insert the new\n                                 // waiter right after `cursor`.\n@@ -206,14 +208,16 @@ mod waiter_queue {\n \n                     if let Some(mut insert_after) = insert_after {\n                         // Insert `waiter` after `insert_after`\n-                        let insert_before = insert_after.as_ref().prev;\n+                        let insert_before = insert_after.as_ref().next;\n \n                         waiter.prev = Some(insert_after);\n                         insert_after.as_mut().next = Some(waiter_ptr);\n \n                         waiter.next = insert_before;\n                         if let Some(mut insert_before) = insert_before {\n                             insert_before.as_mut().prev = Some(waiter_ptr);\n+                        } else {\n+                            head.last = waiter_ptr;\n                         }\n                     } else {\n                         // Insert `waiter` to the front\n@@ -240,11 +244,11 @@ mod waiter_queue {\n                     match (waiter.prev, waiter.next) {\n                         (Some(mut prev), Some(mut next)) => {\n                             prev.as_mut().next = Some(next);\n-                            next.as_mut().next = Some(prev);\n+                            next.as_mut().prev = Some(prev);\n                         }\n                         (None, Some(mut next)) => {\n                             head.first = next;\n-                            next.as_mut().next = None;\n+                            next.as_mut().prev = None;\n                         }\n                         (Some(mut prev), None) => {\n                             prev.as_mut().next = None;\n@@ -271,6 +275,7 @@ mod waiter_queue {\n             unsafe { waiter.as_ref().task != 0 }\n         }\n \n+        #[inline]\n         pub fn pop_front(&mut self) -> Option<abi::ID> {\n             unsafe {\n                 let head = self.head.as_mut()?;"}]}