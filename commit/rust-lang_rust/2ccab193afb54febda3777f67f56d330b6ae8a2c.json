{"sha": "2ccab193afb54febda3777f67f56d330b6ae8a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjY2FiMTkzYWZiNTRmZWJkYTM3NzdmNjdmNTZkMzMwYjZhZThhMmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T09:24:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T12:11:47Z"}, "message": "Introduce a CollectCtxt and impl AstConv on *that*. Also make all fns\nin collect private except the public entry point.", "tree": {"sha": "7e3b766aca54960d48bb05ab6ba9db675c951996", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e3b766aca54960d48bb05ab6ba9db675c951996"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ccab193afb54febda3777f67f56d330b6ae8a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ccab193afb54febda3777f67f56d330b6ae8a2c", "html_url": "https://github.com/rust-lang/rust/commit/2ccab193afb54febda3777f67f56d330b6ae8a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ccab193afb54febda3777f67f56d330b6ae8a2c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95ee339bd1785ca1918f332c77ed5804b69588c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ee339bd1785ca1918f332c77ed5804b69588c8", "html_url": "https://github.com/rust-lang/rust/commit/95ee339bd1785ca1918f332c77ed5804b69588c8"}], "stats": {"total": 128, "additions": 70, "deletions": 58}, "files": [{"sha": "8b62c55ba31eb31a7e8899618fbdadd50d7dcbed", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccab193afb54febda3777f67f56d330b6ae8a2c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccab193afb54febda3777f67f56d330b6ae8a2c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2ccab193afb54febda3777f67f56d330b6ae8a2c", "patch": "@@ -4939,7 +4939,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 Some(i) => {\n                     span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    span_note!(ccx.tcx.sess, ccx.tcx().map.span(variants[i].id.node),\n+                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].id.node),\n                         \"conflicting discriminant here\")\n                 }\n                 None => {}"}, {"sha": "6f5eccfa198a03b53f584213a2c1b47b1ec16406", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 67, "deletions": 55, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2ccab193afb54febda3777f67f56d330b6ae8a2c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccab193afb54febda3777f67f56d330b6ae8a2c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2ccab193afb54febda3777f67f56d330b6ae8a2c", "patch": "@@ -40,11 +40,12 @@ use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitCont\n use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n+use no_params;\n use rscope::*;\n-use {CrateCtxt, no_params, write_ty_to_tcx};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n+use write_ty_to_tcx;\n \n use std::rc::Rc;\n \n@@ -61,13 +62,8 @@ use syntax::visit;\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-pub fn collect_item_types(ccx: &CrateCtxt) {\n-    fn collect_intrinsic_type(ccx: &CrateCtxt,\n-                              lang_item: ast::DefId) {\n-        let ty::TypeScheme { ty, .. } =\n-            ccx.get_item_type_scheme(lang_item);\n-        ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n-    }\n+pub fn collect_item_types(tcx: &ty::ctxt) {\n+    let ccx = &CollectCtxt { tcx: tcx };\n \n     match ccx.tcx.lang_items.ty_desc() {\n         Some(id) => { collect_intrinsic_type(ccx, id); }\n@@ -85,13 +81,29 @@ pub fn collect_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+\n+struct CollectCtxt<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Zeroth phase: collect types of intrinsics\n+\n+fn collect_intrinsic_type(ccx: &CollectCtxt,\n+                          lang_item: ast::DefId) {\n+    let ty::TypeScheme { ty, .. } =\n+        ccx.get_item_type_scheme(lang_item);\n+    ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // First phase: just collect *trait definitions* -- basically, the set\n // of type parameters and supertraits. This is information we need to\n // know later when parsing field defs.\n \n struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n+    ccx: &'a CollectCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n@@ -112,7 +124,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n // Second phase: collection proper.\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n+    ccx: &'a CollectCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n@@ -133,13 +145,13 @@ pub trait ToTy<'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n+impl<'a,'tcx> ToTy<'tcx> for CollectCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n@@ -181,7 +193,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                         enum_ty: Ty<'tcx>,\n                                         variants: &[P<ast::Variant>],\n                                         generics: &ast::Generics) {\n@@ -226,7 +238,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    trait_def: &ty::TraitDef<'tcx>) {\n     let tcx = ccx.tcx;\n@@ -322,15 +334,15 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n+    fn make_method_ty<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n             TypeScheme {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n     }\n \n-    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n                                            _trait_items: &[ast::TraitItem],\n@@ -372,7 +384,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                 struct_generics: &ty::Generics<'tcx>,\n                                 v: &ast::StructField,\n                                 origin: ast::DefId) -> ty::field_ty {\n@@ -405,7 +417,7 @@ pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n                                      associated_type: &ast::AssociatedType)\n {\n@@ -422,7 +434,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                ty::TypeTraitItem(associated_type));\n }\n \n-fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n                                  mut ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n@@ -469,7 +481,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n-    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn ty_of_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n@@ -506,7 +518,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n+fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n                                  span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n@@ -535,7 +547,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n+fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n@@ -706,7 +718,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                 struct_def: &ast::StructDef,\n                                 scheme: ty::TypeScheme<'tcx>,\n                                 id: ast::NodeId) {\n@@ -773,7 +785,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n+fn convert_foreign(ccx: &CollectCtxt, i: &ast::ForeignItem) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -790,7 +802,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), scheme);\n }\n \n-fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                            trait_id: ast::DefId)\n                            -> Rc<ty::TraitDef<'tcx>> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n@@ -806,7 +818,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    it: &ast::Item)\n                                    -> Rc<ty::TraitDef<'tcx>>\n {\n@@ -872,7 +884,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     return trait_def;\n \n-    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn mk_trait_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n@@ -903,7 +915,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n+fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n                             -> ty::TypeScheme<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -985,7 +997,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     }\n }\n \n-pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_of_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     it: &ast::ForeignItem,\n                                     abi: abi::Abi) -> ty::TypeScheme<'tcx>\n {\n@@ -1006,7 +1018,7 @@ pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n@@ -1017,7 +1029,7 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 &generics.where_clause)\n }\n \n-fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n@@ -1077,7 +1089,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     return generics;\n \n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n                                                  trait_items: &[ast::TraitItem])\n                                                  -> Vec<ty::Predicate<'tcx>>\n@@ -1108,7 +1120,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                          generics: &ast::Generics,\n                                          base_generics: ty::Generics<'tcx>)\n                                          -> ty::Generics<'tcx>\n@@ -1123,7 +1135,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                               bounds: &mut ty::BuiltinBounds,\n                               ast_bounds: &[ast::TyParamBound],\n                               span: Span)\n@@ -1168,7 +1180,7 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n@@ -1290,7 +1302,7 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n                                              index: u32)\n@@ -1347,7 +1359,7 @@ enum SizedByDefault { Yes, No }\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                            param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n                            sized_by_default: SizedByDefault,\n@@ -1400,7 +1412,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-fn conv_param_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n@@ -1435,7 +1447,7 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                        decl: &ast::FnDecl,\n                                        def_id: ast::DefId,\n                                        ast_generics: &ast::Generics,\n@@ -1487,9 +1499,9 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     return scheme;\n }\n \n-pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                ty_generics: &ty::Generics<'tcx>)\n-                                -> subst::Substs<'tcx>\n+fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                            ty_generics: &ty::Generics<'tcx>)\n+                            -> subst::Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -1509,14 +1521,14 @@ pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// comes back to check after the fact that explicit type the user\n /// wrote actually matches what the pre-defined option said.\n fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n-    crate_context: &CrateCtxt<'a, 'tcx>,\n+    ccx: &CollectCtxt<'a, 'tcx>,\n     rs: &RS,\n     required_type: Ty<'tcx>,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n-        let typ = crate_context.to_ty(rs, &**ast_type);\n+        let typ = ccx.to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n             ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n             ty::ty_uniq(typ) => typ,\n@@ -1532,35 +1544,35 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let required_type_free =\n             liberate_early_bound_regions(\n-                crate_context.tcx, body_scope,\n+                ccx.tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::Binder(required_type)));\n+                    ccx.tcx, body_scope, &ty::Binder(required_type)));\n \n         // The \"base type\" comes from the impl. It too may have late-bound\n         // regions from the method.\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n             liberate_early_bound_regions(\n-                crate_context.tcx, body_scope,\n+                ccx.tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::Binder(base_type)));\n+                    ccx.tcx, body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\",\n-               required_type.repr(crate_context.tcx),\n-               required_type_free.repr(crate_context.tcx),\n-               base_type.repr(crate_context.tcx),\n-               base_type_free.repr(crate_context.tcx));\n-        let infcx = infer::new_infer_ctxt(crate_context.tcx);\n-        drop(::require_same_types(crate_context.tcx,\n+               required_type.repr(ccx.tcx),\n+               required_type_free.repr(ccx.tcx),\n+               base_type.repr(ccx.tcx),\n+               base_type_free.repr(ccx.tcx));\n+        let infcx = infer::new_infer_ctxt(ccx.tcx);\n+        drop(::require_same_types(ccx.tcx,\n                                   Some(&infcx),\n                                   false,\n                                   explicit_self.span,\n                                   base_type_free,\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                        ppaux::ty_to_string(crate_context.tcx, required_type))\n+                        ppaux::ty_to_string(ccx.tcx, required_type))\n         }));\n         infcx.resolve_regions_and_report_errors(body_id);\n     }"}, {"sha": "3146a1181396b439ca00885e59d85d340940d110", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccab193afb54febda3777f67f56d330b6ae8a2c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccab193afb54febda3777f67f56d330b6ae8a2c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=2ccab193afb54febda3777f67f56d330b6ae8a2c", "patch": "@@ -119,7 +119,7 @@ struct TypeAndSubsts<'tcx> {\n struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: ty::TraitMap,\n-    tcx: &'a ty::ctxt<'tcx>\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n // Functions that write types into the node type table\n@@ -320,7 +320,7 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(&ccx));\n+         collect::collect_item_types(tcx));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error"}]}