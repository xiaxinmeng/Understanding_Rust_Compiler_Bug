{"sha": "f411b94ce1b3d4b6751093beeb7d9674e45db0d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MTFiOTRjZTFiM2Q0YjY3NTEwOTNiZWViN2Q5Njc0ZTQ1ZGIwZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-10T22:01:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-10T22:01:34Z"}, "message": "auto merge of #11448 : c-a/rust/u64_from_be_bytes, r=alexcrichton\n\nInstead of reading a byte at a time in a loop we hardcode how to read each size.\r\nWe also try to do as few reads as possible by reading as big primitive types as\r\npossible. For example if size is eight we do a single read of a u64 value and\r\nif size is seven we read it as [u32|u16|u8].\r\n\r\nTimings on a Intel(R) Core(TM) i5-3570K CPU @ 3.40GHz\r\n\r\n-- Before --\r\nrunning 7 tests\r\ntest io::extensions::test::test_u64_from_be_bytes ... ok\r\ntest io::extensions::bench::u64_from_be_bytes_4_aligned         ... bench:       386 ns/iter (+/- 5)\r\ntest io::extensions::bench::u64_from_be_bytes_4_unaligned       ... bench:       387 ns/iter (+/- 2)\r\ntest io::extensions::bench::u64_from_be_bytes_7_aligned         ... bench:       628 ns/iter (+/- 1)\r\ntest io::extensions::bench::u64_from_be_bytes_7_unaligned       ... bench:       637 ns/iter (+/- 3)\r\ntest io::extensions::bench::u64_from_be_bytes_8_aligned         ... bench:       727 ns/iter (+/- 18)\r\ntest io::extensions::bench::u64_from_be_bytes_8_unaligned       ... bench:       723 ns/iter (+/- 22)\r\n\r\ncallgrind rustc -S  rust/src/test/bench/sudoku.rs\r\n    u64_from_be_bytes self: 4.37%\r\n\r\n-- After --\r\nrunning 7 tests\r\ntest io::extensions::test::test_u64_from_be_bytes ... ok\r\ntest io::extensions::bench::u64_from_be_bytes_4_aligned         ... bench:       162 ns/iter (+/- 7)\r\ntest io::extensions::bench::u64_from_be_bytes_4_unaligned       ... bench:       164 ns/iter (+/- 7)\r\ntest io::extensions::bench::u64_from_be_bytes_7_aligned         ... bench:       201 ns/iter (+/- 7)\r\ntest io::extensions::bench::u64_from_be_bytes_7_unaligned       ... bench:       210 ns/iter (+/- 9)\r\ntest io::extensions::bench::u64_from_be_bytes_8_aligned         ... bench:       163 ns/iter (+/- 7)\r\ntest io::extensions::bench::u64_from_be_bytes_8_unaligned       ... bench:       163 ns/iter (+/- 10)\r\n\r\ncallgrind rustc -S  rust/src/test/bench/sudoku.rs\r\n    u64_from_be_bytes self: 1.78%", "tree": {"sha": "7a3977d15b9a6bfef4a0c23598000cd1b8369d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a3977d15b9a6bfef4a0c23598000cd1b8369d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f411b94ce1b3d4b6751093beeb7d9674e45db0d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f411b94ce1b3d4b6751093beeb7d9674e45db0d3", "html_url": "https://github.com/rust-lang/rust/commit/f411b94ce1b3d4b6751093beeb7d9674e45db0d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f411b94ce1b3d4b6751093beeb7d9674e45db0d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e866339126df3806f9cae95f2b91d38abaab32", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e866339126df3806f9cae95f2b91d38abaab32", "html_url": "https://github.com/rust-lang/rust/commit/33e866339126df3806f9cae95f2b91d38abaab32"}, {"sha": "0b3311c260812cef6c35b7e99e93516cfc7a3561", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3311c260812cef6c35b7e99e93516cfc7a3561", "html_url": "https://github.com/rust-lang/rust/commit/0b3311c260812cef6c35b7e99e93516cfc7a3561"}], "stats": {"total": 112, "additions": 101, "deletions": 11}, "files": [{"sha": "066dc883597e82d98473ffac71eeba2a2cbd54be", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 101, "deletions": 11, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f411b94ce1b3d4b6751093beeb7d9674e45db0d3/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f411b94ce1b3d4b6751093beeb7d9674e45db0d3/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=f411b94ce1b3d4b6751093beeb7d9674e45db0d3", "patch": "@@ -13,10 +13,11 @@\n // XXX: Not sure how this should be structured\n // XXX: Iteration should probably be considered separately\n \n+use container::Container;\n use iter::Iterator;\n use option::Option;\n use io::Reader;\n-use vec::OwnedVector;\n+use vec::{OwnedVector, ImmutableVector};\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `None`.\n@@ -117,16 +118,23 @@ pub fn u64_from_be_bytes(data: &[u8],\n                          start: uint,\n                          size: uint)\n                       -> u64 {\n-    let mut sz = size;\n-    assert!((sz <= 8u));\n-    let mut val = 0_u64;\n-    let mut pos = start;\n-    while sz > 0u {\n-        sz -= 1u;\n-        val += (data[pos] as u64) << ((sz * 8u) as u64);\n-        pos += 1u;\n-    }\n-    return val;\n+    use ptr::{copy_nonoverlapping_memory, offset, mut_offset};\n+    use unstable::intrinsics::from_be64;\n+    use vec::MutableVector;\n+\n+    assert!(size <= 8u);\n+\n+    if data.len() - start < size {\n+        fail!(\"index out of bounds\");\n+    }\n+\n+    let mut buf = [0u8, ..8];\n+    unsafe {\n+        let ptr = offset(data.as_ptr(), start as int);\n+        let out = buf.as_mut_ptr();\n+        copy_nonoverlapping_memory(mut_offset(out, (8 - size) as int), ptr, size);\n+        from_be64(*(out as *i64)) as u64\n+    }\n }\n \n #[cfg(test)]\n@@ -465,4 +473,86 @@ mod test {\n         assert!(reader.read_le_f32() == 8.1250);\n     }\n \n+    #[test]\n+    fn test_u64_from_be_bytes() {\n+        use super::u64_from_be_bytes;\n+\n+        let buf = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09];\n+\n+        // Aligned access\n+        assert_eq!(u64_from_be_bytes(buf, 0, 0), 0);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 1), 0x01);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 2), 0x0102);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 3), 0x010203);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 4), 0x01020304);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 5), 0x0102030405);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 6), 0x010203040506);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 7), 0x01020304050607);\n+        assert_eq!(u64_from_be_bytes(buf, 0, 8), 0x0102030405060708);\n+\n+        // Unaligned access\n+        assert_eq!(u64_from_be_bytes(buf, 1, 0), 0);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 1), 0x02);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 2), 0x0203);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 3), 0x020304);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 4), 0x02030405);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 5), 0x0203040506);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 6), 0x020304050607);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 7), 0x02030405060708);\n+        assert_eq!(u64_from_be_bytes(buf, 1, 8), 0x0203040506070809);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use container::Container;\n+\n+    macro_rules! u64_from_be_bytes_bench_impl(\n+        ($size:expr, $stride:expr, $start_index:expr) =>\n+        ({\n+            use vec;\n+            use super::u64_from_be_bytes;\n+\n+            let data = vec::from_fn($stride*100+$start_index, |i| i as u8);\n+            let mut sum = 0u64;\n+            bh.iter(|| {\n+                let mut i = $start_index;\n+                while (i < data.len()) {\n+                    sum += u64_from_be_bytes(data, i, $size);\n+                    i += $stride;\n+                }\n+            });\n+        })\n+    )\n+\n+    #[bench]\n+    fn u64_from_be_bytes_4_aligned(bh: &mut BenchHarness) {\n+        u64_from_be_bytes_bench_impl!(4, 4, 0);\n+    }\n+\n+    #[bench]\n+    fn u64_from_be_bytes_4_unaligned(bh: &mut BenchHarness) {\n+        u64_from_be_bytes_bench_impl!(4, 4, 1);\n+    }\n+\n+    #[bench]\n+    fn u64_from_be_bytes_7_aligned(bh: &mut BenchHarness) {\n+        u64_from_be_bytes_bench_impl!(7, 8, 0);\n+    }\n+\n+    #[bench]\n+    fn u64_from_be_bytes_7_unaligned(bh: &mut BenchHarness) {\n+        u64_from_be_bytes_bench_impl!(7, 8, 1);\n+    }\n+\n+    #[bench]\n+    fn u64_from_be_bytes_8_aligned(bh: &mut BenchHarness) {\n+        u64_from_be_bytes_bench_impl!(8, 8, 0);\n+    }\n+\n+    #[bench]\n+    fn u64_from_be_bytes_8_unaligned(bh: &mut BenchHarness) {\n+        u64_from_be_bytes_bench_impl!(8, 8, 1);\n+    }\n }"}]}