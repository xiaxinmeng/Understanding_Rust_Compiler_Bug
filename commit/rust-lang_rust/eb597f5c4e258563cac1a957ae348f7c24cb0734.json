{"sha": "eb597f5c4e258563cac1a957ae348f7c24cb0734", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNTk3ZjVjNGUyNTg1NjNjYWMxYTk1N2FlMzQ4ZjdjMjRjYjA3MzQ=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2020-10-30T22:12:24Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2020-11-08T17:07:45Z"}, "message": "Remove recursion from sccc walking\n\nThis allows constructing the sccc for large that visit many nodes before\nfinding a single cycle of sccc, for example lists. When used to find\ndependencies in borrow checking the list case is what occurs in very\nlong functions.", "tree": {"sha": "160852acc754c6ba6b4bb18c383d0d8112bc18d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/160852acc754c6ba6b4bb18c383d0d8112bc18d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb597f5c4e258563cac1a957ae348f7c24cb0734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb597f5c4e258563cac1a957ae348f7c24cb0734", "html_url": "https://github.com/rust-lang/rust/commit/eb597f5c4e258563cac1a957ae348f7c24cb0734", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb597f5c4e258563cac1a957ae348f7c24cb0734/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "355904dca086675b1c3dac25e8c0410f27f80a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/355904dca086675b1c3dac25e8c0410f27f80a6d", "html_url": "https://github.com/rust-lang/rust/commit/355904dca086675b1c3dac25e8c0410f27f80a6d"}], "stats": {"total": 255, "additions": 182, "deletions": 73}, "files": [{"sha": "5b3d8233f3da3b960c1c2cef55edacfd49b52128", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 182, "deletions": 73, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/eb597f5c4e258563cac1a957ae348f7c24cb0734/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb597f5c4e258563cac1a957ae348f7c24cb0734/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=eb597f5c4e258563cac1a957ae348f7c24cb0734", "patch": "@@ -231,20 +231,30 @@ where\n \n         let scc_indices = (0..num_nodes)\n             .map(G::Node::new)\n-            .map(|node| match this.walk_node(0, node) {\n+            .map(|node| match this.start_walk_from(node) {\n                 WalkReturn::Complete { scc_index } => scc_index,\n-                WalkReturn::Cycle { min_depth } => {\n-                    panic!(\"`walk_node(0, {:?})` returned cycle with depth {:?}\", node, min_depth)\n-                }\n+                WalkReturn::Cycle { min_depth } => panic!(\n+                    \"`start_walk_node({:?})` returned cycle with depth {:?}\",\n+                    node, min_depth\n+                ),\n             })\n             .collect();\n \n         Sccs { scc_indices, scc_data: this.scc_data }\n     }\n \n-    /// Visits a node during the DFS. We first examine its current\n-    /// state -- if it is not yet visited (`NotVisited`), we can push\n-    /// it onto the stack and start walking its successors.\n+    fn start_walk_from(&mut self, node: G::Node) -> WalkReturn<S> {\n+        if let Some(result) = self.inspect_node(node) {\n+            result\n+        } else {\n+            self.walk_unvisited_node(node)\n+        }\n+    }\n+\n+    /// Inspect a node during the DFS. We first examine its current\n+    /// state -- if it is not yet visited (`NotVisited`), return `None` so\n+    /// that the caller might push it onto the stack and start walking its\n+    /// successors.\n     ///\n     /// If it is already on the DFS stack it will be in the state\n     /// `BeingVisited`. In that case, we have found a cycle and we\n@@ -253,20 +263,19 @@ where\n     /// Otherwise, we are looking at a node that has already been\n     /// completely visited. We therefore return `WalkReturn::Complete`\n     /// with its associated SCC index.\n-    fn walk_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n-        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, node);\n-        match self.find_state(node) {\n+    fn inspect_node(&mut self, node: G::Node) -> Option<WalkReturn<S>> {\n+        Some(match self.find_state(node) {\n             NodeState::InCycle { scc_index } => WalkReturn::Complete { scc_index },\n \n             NodeState::BeingVisited { depth: min_depth } => WalkReturn::Cycle { min_depth },\n \n-            NodeState::NotVisited => self.walk_unvisited_node(depth, node),\n+            NodeState::NotVisited => return None,\n \n             NodeState::InCycleWith { parent } => panic!(\n                 \"`find_state` returned `InCycleWith({:?})`, which ought to be impossible\",\n                 parent\n             ),\n-        }\n+        })\n     }\n \n     /// Fetches the state of the node `r`. If `r` is recorded as being\n@@ -392,74 +401,174 @@ where\n     }\n \n     /// Walks a node that has never been visited before.\n-    fn walk_unvisited_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n-        debug!(\"walk_unvisited_node(depth = {:?}, node = {:?})\", depth, node);\n-\n-        debug_assert!(matches!(self.node_states[node], NodeState::NotVisited));\n-\n-        // Push `node` onto the stack.\n-        self.node_states[node] = NodeState::BeingVisited { depth };\n-        self.node_stack.push(node);\n-\n-        // Walk each successor of the node, looking to see if any of\n-        // them can reach a node that is presently on the stack. If\n-        // so, that means they can also reach us.\n-        let mut min_depth = depth;\n-        let mut min_cycle_root = node;\n-        let successors_len = self.successors_stack.len();\n-        for successor_node in self.graph.successors(node) {\n-            debug!(\"walk_unvisited_node: node = {:?} successor_ode = {:?}\", node, successor_node);\n-            match self.walk_node(depth + 1, successor_node) {\n-                WalkReturn::Cycle { min_depth: successor_min_depth } => {\n-                    // Track the minimum depth we can reach.\n-                    assert!(successor_min_depth <= depth);\n-                    if successor_min_depth < min_depth {\n+    ///\n+    /// Call this method when `inspect_node` has returned `None`. Having the\n+    /// caller decide avoids mutual recursion between the two methods and allows\n+    /// us to maintain an allocated stack for nodes on the path between calls.\n+    fn walk_unvisited_node(&mut self, initial: G::Node) -> WalkReturn<S> {\n+        struct VisitingNodeFrame<G: DirectedGraph, Successors> {\n+            node: G::Node,\n+            iter: Option<Successors>,\n+            depth: usize,\n+            min_depth: usize,\n+            successors_len: usize,\n+            min_cycle_root: G::Node,\n+            successor_node: G::Node,\n+        }\n+\n+        // Move the stack to a local variable. We want to utilize the existing allocation and\n+        // mutably borrow it without borrowing self at the same time.\n+        let mut successors_stack = core::mem::take(&mut self.successors_stack);\n+        debug_assert_eq!(successors_stack.len(), 0);\n+\n+        let mut stack: Vec<VisitingNodeFrame<G, _>> = vec![VisitingNodeFrame {\n+            node: initial,\n+            depth: 0,\n+            min_depth: 0,\n+            iter: None,\n+            successors_len: 0,\n+            min_cycle_root: initial,\n+            successor_node: initial,\n+        }];\n+\n+        let mut return_value = None;\n+\n+        'recurse: while let Some(frame) = stack.last_mut() {\n+            let VisitingNodeFrame {\n+                node,\n+                depth,\n+                iter,\n+                successors_len,\n+                min_depth,\n+                min_cycle_root,\n+                successor_node,\n+            } = frame;\n+\n+            let node = *node;\n+            let depth = *depth;\n+\n+            let successors = match iter {\n+                Some(iter) => iter,\n+                None => {\n+                    // This None marks that we still have the initialize this node's frame.\n+                    debug!(\"walk_unvisited_node(depth = {:?}, node = {:?})\", depth, node);\n+\n+                    debug_assert!(matches!(self.node_states[node], NodeState::NotVisited));\n+\n+                    // Push `node` onto the stack.\n+                    self.node_states[node] = NodeState::BeingVisited { depth };\n+                    self.node_stack.push(node);\n+\n+                    // Walk each successor of the node, looking to see if any of\n+                    // them can reach a node that is presently on the stack. If\n+                    // so, that means they can also reach us.\n+                    *successors_len = successors_stack.len();\n+                    // Set and return a reference, this is currently empty.\n+                    iter.get_or_insert(self.graph.successors(node))\n+                }\n+            };\n+\n+            // Now that iter is initialized, this is a constant for this frame.\n+            let successors_len = *successors_len;\n+\n+            // Construct iterators for the nodes and walk results. There are two cases:\n+            // * The walk of a successor node returned.\n+            // * The remaining successor nodes.\n+            let returned_walk =\n+                return_value.take().into_iter().map(|walk| (*successor_node, Some(walk)));\n+\n+            let successor_walk = successors.by_ref().map(|successor_node| {\n+                debug!(\n+                    \"walk_unvisited_node: node = {:?} successor_ode = {:?}\",\n+                    node, successor_node\n+                );\n+                (successor_node, self.inspect_node(successor_node))\n+            });\n+\n+            for (successor_node, walk) in returned_walk.chain(successor_walk) {\n+                match walk {\n+                    Some(WalkReturn::Cycle { min_depth: successor_min_depth }) => {\n+                        // Track the minimum depth we can reach.\n+                        assert!(successor_min_depth <= depth);\n+                        if successor_min_depth < *min_depth {\n+                            debug!(\n+                                \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n+                                node, successor_min_depth\n+                            );\n+                            *min_depth = successor_min_depth;\n+                            *min_cycle_root = successor_node;\n+                        }\n+                    }\n+\n+                    Some(WalkReturn::Complete { scc_index: successor_scc_index }) => {\n+                        // Push the completed SCC indices onto\n+                        // the `successors_stack` for later.\n                         debug!(\n-                            \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n-                            node, successor_min_depth\n+                            \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n+                            node, successor_scc_index\n                         );\n-                        min_depth = successor_min_depth;\n-                        min_cycle_root = successor_node;\n+                        successors_stack.push(successor_scc_index);\n                     }\n-                }\n \n-                WalkReturn::Complete { scc_index: successor_scc_index } => {\n-                    // Push the completed SCC indices onto\n-                    // the `successors_stack` for later.\n-                    debug!(\n-                        \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n-                        node, successor_scc_index\n-                    );\n-                    self.successors_stack.push(successor_scc_index);\n+                    None => {\n+                        let depth = depth + 1;\n+                        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, successor_node);\n+                        // Remember which node the return value will come from.\n+                        frame.successor_node = successor_node;\n+                        // Start a new stack frame the step into it.\n+                        stack.push(VisitingNodeFrame {\n+                            node: successor_node,\n+                            depth,\n+                            iter: None,\n+                            successors_len: 0,\n+                            min_depth: depth,\n+                            min_cycle_root: successor_node,\n+                            successor_node: successor_node,\n+                        });\n+                        continue 'recurse;\n+                    }\n                 }\n             }\n-        }\n \n-        // Completed walk, remove `node` from the stack.\n-        let r = self.node_stack.pop();\n-        debug_assert_eq!(r, Some(node));\n-\n-        // If `min_depth == depth`, then we are the root of the\n-        // cycle: we can't reach anyone further down the stack.\n-        if min_depth == depth {\n-            // Note that successor stack may have duplicates, so we\n-            // want to remove those:\n-            let deduplicated_successors = {\n-                let duplicate_set = &mut self.duplicate_set;\n-                duplicate_set.clear();\n-                self.successors_stack\n-                    .drain(successors_len..)\n-                    .filter(move |&i| duplicate_set.insert(i))\n-            };\n-            let scc_index = self.scc_data.create_scc(deduplicated_successors);\n-            self.node_states[node] = NodeState::InCycle { scc_index };\n-            WalkReturn::Complete { scc_index }\n-        } else {\n-            // We are not the head of the cycle. Return back to our\n-            // caller. They will take ownership of the\n-            // `self.successors` data that we pushed.\n-            self.node_states[node] = NodeState::InCycleWith { parent: min_cycle_root };\n-            WalkReturn::Cycle { min_depth }\n+            // Completed walk, remove `node` from the stack.\n+            let r = self.node_stack.pop();\n+            debug_assert_eq!(r, Some(node));\n+\n+            // Remove the frame, it's done.\n+            let frame = stack.pop().unwrap();\n+\n+            // If `min_depth == depth`, then we are the root of the\n+            // cycle: we can't reach anyone further down the stack.\n+\n+            // Pass the 'return value' down the stack.\n+            // We return one frame at a time so there can't be another return value.\n+            debug_assert!(return_value.is_none());\n+            return_value = Some(if frame.min_depth == depth {\n+                // Note that successor stack may have duplicates, so we\n+                // want to remove those:\n+                let deduplicated_successors = {\n+                    let duplicate_set = &mut self.duplicate_set;\n+                    duplicate_set.clear();\n+                    successors_stack\n+                        .drain(successors_len..)\n+                        .filter(move |&i| duplicate_set.insert(i))\n+                };\n+                let scc_index = self.scc_data.create_scc(deduplicated_successors);\n+                self.node_states[node] = NodeState::InCycle { scc_index };\n+                WalkReturn::Complete { scc_index }\n+            } else {\n+                // We are not the head of the cycle. Return back to our\n+                // caller. They will take ownership of the\n+                // `self.successors` data that we pushed.\n+                self.node_states[node] = NodeState::InCycleWith { parent: frame.min_cycle_root };\n+                WalkReturn::Cycle { min_depth: frame.min_depth }\n+            });\n         }\n+\n+        // Keep the allocation we used for successors_stack.\n+        self.successors_stack = successors_stack;\n+        debug_assert_eq!(self.successors_stack.len(), 0);\n+\n+        return_value.unwrap()\n     }\n }"}]}