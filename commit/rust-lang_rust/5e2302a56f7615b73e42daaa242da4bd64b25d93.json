{"sha": "5e2302a56f7615b73e42daaa242da4bd64b25d93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMjMwMmE1NmY3NjE1YjczZTQyZGFhYTI0MmRhNGJkNjRiMjVkOTM=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-23T05:45:49Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:37:28Z"}, "message": "Convert type_of to use trans::adt.", "tree": {"sha": "360a54d87642d5edb00b407f2c290fcf82e337b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/360a54d87642d5edb00b407f2c290fcf82e337b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e2302a56f7615b73e42daaa242da4bd64b25d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2302a56f7615b73e42daaa242da4bd64b25d93", "html_url": "https://github.com/rust-lang/rust/commit/5e2302a56f7615b73e42daaa242da4bd64b25d93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e2302a56f7615b73e42daaa242da4bd64b25d93/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4682dcabedaa5451d377aedfb9167f4f299e5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4682dcabedaa5451d377aedfb9167f4f299e5e5", "html_url": "https://github.com/rust-lang/rust/commit/c4682dcabedaa5451d377aedfb9167f4f299e5e5"}], "stats": {"total": 99, "additions": 11, "deletions": 88}, "files": [{"sha": "1f14a24b0ae3adc9e156dd1c641d11d1d5982de9", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 88, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5e2302a56f7615b73e42daaa242da4bd64b25d93/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2302a56f7615b73e42daaa242da4bd64b25d93/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5e2302a56f7615b73e42daaa242da4bd64b25d93", "patch": "@@ -11,6 +11,7 @@\n \n use lib::llvm::llvm;\n use lib::llvm::{TypeRef};\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::common;\n@@ -143,32 +144,12 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n \n-        ty::ty_tup(ref elems) => {\n-            T_struct(elems.map(|&t| sizing_type_of(cx, t)))\n+        ty::ty_tup(*) | ty::ty_rec(*) | ty::ty_struct(*)\n+        | ty::ty_enum(*) => {\n+            let repr = adt::represent_type(cx, t);\n+            T_struct(adt::sizing_fields_of(cx, &repr))\n         }\n \n-        ty::ty_rec(ref fields) => {\n-            T_struct(fields.map(|f| sizing_type_of(cx, f.mt.ty)))\n-        }\n-\n-        ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let lltype = T_struct(fields.map(|field| {\n-                let field_type = ty::lookup_field_type(cx.tcx,\n-                                                       def_id,\n-                                                       field.id,\n-                                                       substs);\n-                sizing_type_of(cx, field_type)\n-            }));\n-            if ty::ty_dtor(cx.tcx, def_id).is_present() {\n-                T_struct(~[lltype, T_i8()])\n-            } else {\n-                lltype\n-            }\n-        }\n-\n-        ty::ty_enum(def_id, _) => T_struct(enum_body_types(cx, def_id, t)),\n-\n         ty::ty_self | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n             cx.tcx.sess.bug(\n                 fmt!(\"fictitious type %? in sizing_type_of()\",\n@@ -257,28 +238,13 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         T_array(type_of(cx, mt.ty), n)\n       }\n \n-      ty::ty_rec(fields) => {\n-        let mut tys: ~[TypeRef] = ~[];\n-        for vec::each(fields) |f| {\n-            let mt_ty = f.mt.ty;\n-            tys.push(type_of(cx, mt_ty));\n-        }\n-\n-        // n.b.: introduce an extra layer of indirection to match\n-        // structs\n-        T_struct(~[T_struct(tys)])\n-      }\n-\n       ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n       ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n-      ty::ty_tup(elts) => {\n-        let mut tys = ~[];\n-        for vec::each(elts) |elt| {\n-            tys.push(type_of(cx, *elt));\n-        }\n-        T_struct(tys)\n+      ty::ty_tup(*) | ty::ty_rec(*) => {\n+          let repr = adt::represent_type(cx, t);\n+          T_struct(adt::fields_of(cx, &repr))\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n       ty::ty_struct(did, ref substs) => {\n@@ -301,59 +267,16 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-      ty::ty_enum(did, _) => {\n-        fill_type_of_enum(cx, did, t, llty);\n-      }\n-      ty::ty_struct(did, ref substs) => {\n-        // Only instance vars are record fields at runtime.\n-        let fields = ty::lookup_struct_fields(cx.tcx, did);\n-        let mut tys = do vec::map(fields) |f| {\n-            let t = ty::lookup_field_type(cx.tcx, did, f.id, substs);\n-            type_of(cx, t)\n-        };\n-\n-        // include a byte flag if there is a dtor so that we know when we've\n-        // been dropped\n-        if ty::ty_dtor(cx.tcx, did).is_present() {\n-            common::set_struct_body(llty, ~[T_struct(tys), T_i8()]);\n-        } else {\n-            common::set_struct_body(llty, ~[T_struct(tys)]);\n-        }\n+      ty::ty_enum(*) | ty::ty_struct(*) => {\n+          let repr = adt::represent_type(cx, t);\n+          common::set_struct_body(llty, adt::fields_of(cx, &repr));\n       }\n       _ => ()\n     }\n \n     return llty;\n }\n \n-pub fn enum_body_types(cx: @CrateContext, did: ast::def_id, t: ty::t)\n-                    -> ~[TypeRef] {\n-    let univar = ty::enum_is_univariant(cx.tcx, did);\n-    if !univar {\n-        let size = machine::static_size_of_enum(cx, t);\n-        ~[T_enum_discrim(cx), T_array(T_i8(), size)]\n-    }\n-    else {\n-        // Use the actual fields, so we get the alignment right.\n-        match ty::get(t).sty {\n-            ty::ty_enum(_, ref substs) => {\n-                do ty::enum_variants(cx.tcx, did)[0].args.map |&field_ty| {\n-                    sizing_type_of(cx, ty::subst(cx.tcx, substs, field_ty))\n-                }\n-            }\n-            _ => cx.sess.bug(~\"enum is not an enum\")\n-        }\n-    }\n-}\n-\n-pub fn fill_type_of_enum(cx: @CrateContext,\n-                         did: ast::def_id,\n-                         t: ty::t,\n-                         llty: TypeRef) {\n-    debug!(\"type_of_enum %?: %?\", t, ty::get(t));\n-    common::set_struct_body(llty, enum_body_types(cx, did, t));\n-}\n-\n // Want refinements! (Or case classes, I guess\n pub enum named_ty { a_struct, an_enum }\n "}]}