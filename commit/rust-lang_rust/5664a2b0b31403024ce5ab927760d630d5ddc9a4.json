{"sha": "5664a2b0b31403024ce5ab927760d630d5ddc9a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NjRhMmIwYjMxNDAzMDI0Y2U1YWI5Mjc3NjBkNjMwZDVkZGM5YTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-08T22:30:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-08T22:30:37Z"}, "message": "Merge #9814\n\n9814: Generate default impl when converting `#[derive(Debug)]` to manual impl r=yoshuawuyts a=yoshuawuyts\n\nThis patch makes it so when you convert `#[derive(Debug)]` to a manual impl, a default body is provided that's equivalent to the original output of `#[derive(Debug)]`. This should make it drastically easier to write custom `Debug` impls, especially when all you want to do is quickly omit a single field which is `!Debug`.\r\n\r\nThis is implemented for enums, record structs, tuple structs, empty structs - and it sets us up to implement variations on this in the future for other traits (like `PartialEq` and `Hash`).\r\n\r\nThanks!\r\n\r\n## Codegen diff\r\nThis is the difference in codegen for record structs with this patch:\r\n```diff\r\nstruct Foo {\r\n    bar: String,\r\n}\r\n\r\nimpl fmt::Debug for Foo {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n-        todo!();\r\n+        f.debug_struct(\"Foo\").field(\"bar\", &self.bar).finish()\r\n    }\r\n}\r\n```\n\nCo-authored-by: Irina Shestak <shestak.irina@gmail.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts+github@gmail.com>", "tree": {"sha": "c460fe4d703963cc82b888704532ea2022ec96cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c460fe4d703963cc82b888704532ea2022ec96cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5664a2b0b31403024ce5ab927760d630d5ddc9a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhEFsNCRBK7hj4Ov3rIwAA9D8IAEimYPX6H9Eg9RGMUt5pPAZY\nOk9M2kc0FbOyzG2kLjWNtUJzC8w4XRK0UkEm+1CFp7oAPUMHiPMWZC+JD2SSNYhX\nIc5cDuQBD6KQIfjPxXrAZd3+kKGz7+CQgZcFgaURccuaGtQS1CyV8seA5H6JA2Tz\n/fy5Jk1CDKubfVkNX/mNahSLw3M8wJinVEk0y+fPrG/PedCFcil7b7/zxgeJE3iP\nnDjQzAiPCfu4BJYrjHMAabI5S5LWSwN0X6TFPKhgh3IKtACPXHbqp80CqehKoyFa\nMc7Bxhp1qa4qSn+D7nEoZjwAeMJNkSVo85wjpZiN8mPdS4DIWPItR/JXasDAgfQ=\n=uOLD\n-----END PGP SIGNATURE-----\n", "payload": "tree c460fe4d703963cc82b888704532ea2022ec96cb\nparent 044d99e162bd8c1780b5288e0e5cf13fc0bdac51\nparent 59cdb51ef3865582588f2735dc5479e9c205ddb6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628461837 +0000\ncommitter GitHub <noreply@github.com> 1628461837 +0000\n\nMerge #9814\n\n9814: Generate default impl when converting `#[derive(Debug)]` to manual impl r=yoshuawuyts a=yoshuawuyts\n\nThis patch makes it so when you convert `#[derive(Debug)]` to a manual impl, a default body is provided that's equivalent to the original output of `#[derive(Debug)]`. This should make it drastically easier to write custom `Debug` impls, especially when all you want to do is quickly omit a single field which is `!Debug`.\r\n\r\nThis is implemented for enums, record structs, tuple structs, empty structs - and it sets us up to implement variations on this in the future for other traits (like `PartialEq` and `Hash`).\r\n\r\nThanks!\r\n\r\n## Codegen diff\r\nThis is the difference in codegen for record structs with this patch:\r\n```diff\r\nstruct Foo {\r\n    bar: String,\r\n}\r\n\r\nimpl fmt::Debug for Foo {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n-        todo!();\r\n+        f.debug_struct(\"Foo\").field(\"bar\", &self.bar).finish()\r\n    }\r\n}\r\n```\n\nCo-authored-by: Irina Shestak <shestak.irina@gmail.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts+github@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5664a2b0b31403024ce5ab927760d630d5ddc9a4", "html_url": "https://github.com/rust-lang/rust/commit/5664a2b0b31403024ce5ab927760d630d5ddc9a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5664a2b0b31403024ce5ab927760d630d5ddc9a4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "044d99e162bd8c1780b5288e0e5cf13fc0bdac51", "url": "https://api.github.com/repos/rust-lang/rust/commits/044d99e162bd8c1780b5288e0e5cf13fc0bdac51", "html_url": "https://github.com/rust-lang/rust/commit/044d99e162bd8c1780b5288e0e5cf13fc0bdac51"}, {"sha": "59cdb51ef3865582588f2735dc5479e9c205ddb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/59cdb51ef3865582588f2735dc5479e9c205ddb6", "html_url": "https://github.com/rust-lang/rust/commit/59cdb51ef3865582588f2735dc5479e9c205ddb6"}], "stats": {"total": 237, "additions": 209, "deletions": 28}, "files": [{"sha": "a9e2b52639448137c4689d65a091c3fe65a19a88", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=5664a2b0b31403024ce5ab927760d630d5ddc9a4", "patch": "@@ -2732,8 +2732,8 @@ fn foo() {\n                                     file_id: FileId(\n                                         1,\n                                     ),\n-                                    full_range: 251..433,\n-                                    focus_range: 290..296,\n+                                    full_range: 252..434,\n+                                    focus_range: 291..297,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "9da25b926c541b472a844024a929ebc18a5c7f74", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 185, "deletions": 24, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=5664a2b0b31403024ce5ab927760d630d5ddc9a4", "patch": "@@ -2,6 +2,8 @@ use hir::ModuleDef;\n use ide_db::helpers::{import_assets::NameToImport, mod_path_to_ast};\n use ide_db::items_locator;\n use itertools::Itertools;\n+use syntax::ast::edit::AstNodeEdit;\n+use syntax::ted;\n use syntax::{\n     ast::{self, make, AstNode, NameOwner},\n     SyntaxKind::{IDENT, WHITESPACE},\n@@ -32,8 +34,8 @@ use crate::{\n // struct S;\n //\n // impl Debug for S {\n-//     fn fmt(&self, f: &mut Formatter) -> Result<()> {\n-//         ${0:todo!()}\n+//     $0fn fmt(&self, f: &mut Formatter) -> Result<()> {\n+//         f.debug_struct(\"S\").finish()\n //     }\n // }\n // ```\n@@ -111,7 +113,7 @@ fn add_assist(\n         |builder| {\n             let insert_pos = adt.syntax().text_range().end();\n             let impl_def_with_items =\n-                impl_def_from_trait(&ctx.sema, &annotated_name, trait_, trait_path);\n+                impl_def_from_trait(&ctx.sema, adt, &annotated_name, trait_, trait_path);\n             update_attribute(builder, input, &trait_name, attr);\n             let trait_path = format!(\"{}\", trait_path);\n             match (ctx.config.snippet_cap, impl_def_with_items) {\n@@ -149,6 +151,7 @@ fn add_assist(\n \n fn impl_def_from_trait(\n     sema: &hir::Semantics<ide_db::RootDatabase>,\n+    adt: &ast::Adt,\n     annotated_name: &ast::Name,\n     trait_: Option<hir::Trait>,\n     trait_path: &ast::Path,\n@@ -163,9 +166,116 @@ fn impl_def_from_trait(\n         make::impl_trait(trait_path.clone(), make::ext::ident_path(&annotated_name.text()));\n     let (impl_def, first_assoc_item) =\n         add_trait_assoc_items_to_impl(sema, trait_items, trait_, impl_def, target_scope);\n+\n+    // Generate a default `impl` function body for the derived trait.\n+    if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n+        let _ = gen_default_impl(func, trait_path, adt, annotated_name);\n+    };\n+\n     Some((impl_def, first_assoc_item))\n }\n \n+/// Generate custom trait bodies where possible.\n+///\n+/// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n+/// `None` means that generating a custom trait body failed, and the body will remain\n+/// as `todo!` instead.\n+fn gen_default_impl(\n+    func: &ast::Fn,\n+    trait_path: &ast::Path,\n+    adt: &ast::Adt,\n+    annotated_name: &ast::Name,\n+) -> Option<()> {\n+    match trait_path.segment()?.name_ref()?.text().as_str() {\n+        \"Debug\" => gen_debug_impl(adt, func, annotated_name),\n+        _ => Some(()),\n+    }\n+}\n+\n+/// Generate a `Debug` impl based on the fields and members of the target type.\n+fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) -> Option<()> {\n+    match adt {\n+        // `Debug` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => Some(()),\n+\n+        // => match self { Self::Variant => write!(f, \"Variant\") }\n+        ast::Adt::Enum(enum_) => {\n+            let list = enum_.variant_list()?;\n+            let mut arms = vec![];\n+            for variant in list.variants() {\n+                let name = variant.name()?;\n+                let left = make::ext::ident_path(\"Self\");\n+                let right = make::ext::ident_path(&format!(\"{}\", name));\n+                let variant_name = make::path_pat(make::path_concat(left, right));\n+\n+                let target = make::expr_path(make::ext::ident_path(\"f\").into());\n+                let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                let args = make::arg_list(vec![target, fmt_string]);\n+                let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n+                let macro_call = make::expr_macro_call(macro_name, args);\n+\n+                arms.push(make::match_arm(Some(variant_name.into()), None, macro_call.into()));\n+            }\n+\n+            let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n+            let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+            let match_expr = make::expr_match(match_target, list);\n+\n+            let body = make::block_expr(None, Some(match_expr));\n+            let body = body.indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n+        }\n+\n+        ast::Adt::Struct(strukt) => {\n+            let name = format!(\"\\\"{}\\\"\", annotated_name);\n+            let args = make::arg_list(Some(make::expr_literal(&name).into()));\n+            let target = make::expr_path(make::ext::ident_path(\"f\"));\n+\n+            let expr = match strukt.field_list() {\n+                // => f.debug_struct(\"Name\").finish()\n+                None => make::expr_method_call(target, make::name_ref(\"debug_struct\"), args),\n+\n+                // => f.debug_struct(\"Name\").field(\"foo\", &self.foo).finish()\n+                Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    let method = make::name_ref(\"debug_struct\");\n+                    let mut expr = make::expr_method_call(target, method, args);\n+                    for field in field_list.fields() {\n+                        let name = field.name()?;\n+                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let f_path = make::expr_ref(f_path, false);\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n+                        let args = make::arg_list(vec![f_name, f_path]);\n+                        expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n+                    }\n+                    expr\n+                }\n+\n+                // => f.debug_tuple(\"Name\").field(self.0).finish()\n+                Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    let method = make::name_ref(\"debug_tuple\");\n+                    let mut expr = make::expr_method_call(target, method, args);\n+                    for (idx, _) in field_list.fields().enumerate() {\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let f_path = make::expr_ref(f_path, false);\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n+                        let method = make::name_ref(\"field\");\n+                        expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n+                    }\n+                    expr\n+                }\n+            };\n+\n+            let method = make::name_ref(\"finish\");\n+            let expr = make::expr_method_call(expr, method, make::arg_list(None));\n+            let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n+        }\n+    }\n+}\n+\n fn update_attribute(\n     builder: &mut AssistBuilder,\n     input: &ast::TokenTree,\n@@ -207,41 +317,92 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn add_custom_impl_debug() {\n+    fn add_custom_impl_debug_record_struct() {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-mod fmt {\n-    pub struct Error;\n-    pub type Result = Result<(), Error>;\n-    pub struct Formatter<'a>;\n-    pub trait Debug {\n-        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n-    }\n-}\n-\n+//- minicore: fmt\n #[derive(Debu$0g)]\n struct Foo {\n     bar: String,\n }\n \"#,\n             r#\"\n-mod fmt {\n-    pub struct Error;\n-    pub type Result = Result<(), Error>;\n-    pub struct Formatter<'a>;\n-    pub trait Debug {\n-        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+struct Foo {\n+    bar: String,\n+}\n+\n+impl core::fmt::Debug for Foo {\n+    $0fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        f.debug_struct(\"Foo\").field(\"bar\", &self.bar).finish()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+    #[test]\n+    fn add_custom_impl_debug_tuple_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: fmt\n+#[derive(Debu$0g)]\n+struct Foo(String, usize);\n+\"#,\n+            r#\"struct Foo(String, usize);\n+\n+impl core::fmt::Debug for Foo {\n+    $0fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        f.debug_tuple(\"Foo\").field(&self.0).field(&self.1).finish()\n     }\n }\n+\"#,\n+        )\n+    }\n+    #[test]\n+    fn add_custom_impl_debug_empty_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: fmt\n+#[derive(Debu$0g)]\n+struct Foo;\n+\"#,\n+            r#\"\n+struct Foo;\n \n-struct Foo {\n-    bar: String,\n+impl core::fmt::Debug for Foo {\n+    $0fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        f.debug_struct(\"Foo\").finish()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+    #[test]\n+    fn add_custom_impl_debug_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: fmt\n+#[derive(Debu$0g)]\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n }\n \n-impl fmt::Debug for Foo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ${0:todo!()}\n+impl core::fmt::Debug for Foo {\n+    $0fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        match self {\n+            Self::Bar => write!(f, \"Bar\"),\n+            Self::Baz => write!(f, \"Baz\"),\n+        }\n     }\n }\n \"#,"}, {"sha": "bda28510d0e9ae0ec64ffe93a1d1f64a36aa4f27", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=5664a2b0b31403024ce5ab927760d630d5ddc9a4", "patch": "@@ -1385,8 +1385,8 @@ trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n struct S;\n \n impl Debug for S {\n-    fn fmt(&self, f: &mut Formatter) -> Result<()> {\n-        ${0:todo!()}\n+    $0fn fmt(&self, f: &mut Formatter) -> Result<()> {\n+        f.debug_struct(\"S\").finish()\n     }\n }\n \"#####,"}, {"sha": "4c3ff31533f2e9fe23d1aec6e608e3facd66eafb", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=5664a2b0b31403024ce5ab927760d630d5ddc9a4", "patch": "@@ -274,11 +274,13 @@ fn check_todo(path: &Path, text: &str) {\n         \"handlers/add_turbo_fish.rs\",\n         \"handlers/generate_function.rs\",\n         \"handlers/fill_match_arms.rs\",\n+        \"handlers/replace_derive_with_manual_impl.rs\",\n         // To support generating `todo!()` in assists, we have `expr_todo()` in\n         // `ast::make`.\n         \"ast/make.rs\",\n         // The documentation in string literals may contain anything for its own purposes\n         \"ide_db/src/helpers/generated_lints.rs\",\n+        \"ide_assists/src/tests/generated.rs\",\n     ];\n     if need_todo.iter().any(|p| path.ends_with(p)) {\n         return;"}, {"sha": "87faac0aa324506760a71cd89c356d81d9b8dba8", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=5664a2b0b31403024ce5ab927760d630d5ddc9a4", "patch": "@@ -311,13 +311,19 @@ pub fn expr_method_call(\n ) -> ast::Expr {\n     expr_from_text(&format!(\"{}.{}{}\", receiver, method, arg_list))\n }\n+pub fn expr_macro_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n+    expr_from_text(&format!(\"{}!{}\", f, arg_list))\n+}\n pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n     expr_from_text(&if exclusive { format!(\"&mut {}\", expr) } else { format!(\"&{}\", expr) })\n }\n pub fn expr_closure(pats: impl IntoIterator<Item = ast::Param>, expr: ast::Expr) -> ast::Expr {\n     let params = pats.into_iter().join(\", \");\n     expr_from_text(&format!(\"|{}| {}\", params, expr))\n }\n+pub fn expr_field(receiver: ast::Expr, field: &str) -> ast::Expr {\n+    expr_from_text(&format!(\"{}.{}\", receiver, field))\n+}\n pub fn expr_paren(expr: ast::Expr) -> ast::Expr {\n     expr_from_text(&format!(\"({})\", expr))\n }"}, {"sha": "c37a0aa1efb0eea6b497f104150056c477fddf59", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5664a2b0b31403024ce5ab927760d630d5ddc9a4/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=5664a2b0b31403024ce5ab927760d630d5ddc9a4", "patch": "@@ -31,6 +31,7 @@\n //!     eq: sized\n //!     ord: eq, option\n //!     derive:\n+//!     fmt: result\n \n pub mod marker {\n     // region:sized\n@@ -334,6 +335,17 @@ pub mod cmp {\n }\n // endregion:eq\n \n+// region:fmt\n+pub mod fmt {\n+    pub struct Error;\n+    pub type Result = Result<(), Error>;\n+    pub struct Formatter<'a>;\n+    pub trait Debug {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+    }\n+}\n+// endregion:fmt\n+\n // region:slice\n pub mod slice {\n     #[lang = \"slice\"]"}]}