{"sha": "d8064d7d49073ff9962369a40678c934d700f7e0", "node_id": "C_kwDOAAsO6NoAKGQ4MDY0ZDdkNDkwNzNmZjk5NjIzNjlhNDA2NzhjOTM0ZDcwMGY3ZTA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-02-25T00:38:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-02-25T00:52:54Z"}, "message": "Miri fn ptr check: don't use conservative null check", "tree": {"sha": "abf3f2484cae6a1e5e6fb27b97457c3d803e0757", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abf3f2484cae6a1e5e6fb27b97457c3d803e0757"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8064d7d49073ff9962369a40678c934d700f7e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8064d7d49073ff9962369a40678c934d700f7e0", "html_url": "https://github.com/rust-lang/rust/commit/d8064d7d49073ff9962369a40678c934d700f7e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8064d7d49073ff9962369a40678c934d700f7e0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d127e2040b57157936f5f24e114a8b4c9a505ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d127e2040b57157936f5f24e114a8b4c9a505ef", "html_url": "https://github.com/rust-lang/rust/commit/3d127e2040b57157936f5f24e114a8b4c9a505ef"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "99888992bc86aef53944c184b90edb73e82559c2", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -217,8 +217,9 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Int(int), Scalar::Ptr(ptr, _)) | (Scalar::Ptr(ptr, _), Scalar::Int(int)) => {\n-                int.is_null() && !self.memory.ptr_may_be_null(ptr.into())\n+            (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n+            | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n+                int.is_null() && !self.scalar_may_be_null(ptr)\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time."}, {"sha": "45ac3cd1f84a60315ebd5df0d3cd519631eb1a69", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -22,9 +22,9 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n-    AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n-    MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance, Scalar,\n-    ScalarMaybeUninit, StackPopJump,\n+    AllocCheck, AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine,\n+    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance,\n+    Scalar, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -440,6 +440,29 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.memory.scalar_to_ptr(scalar)\n     }\n \n+    /// Test if this value might be null.\n+    /// If the machine does not support ptr-to-int casts, this is conservative.\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n+        match scalar.try_to_int() {\n+            Ok(int) => int.is_null(),\n+            Err(_) => {\n+                let ptr = self.scalar_to_ptr(scalar);\n+                match self.memory.ptr_try_get_alloc(ptr) {\n+                    Ok((alloc_id, offset, _)) => {\n+                        let (size, _align) = self\n+                            .memory\n+                            .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n+                            .expect(\"alloc info with MaybeDead cannot fail\");\n+                        // If the pointer is out-of-bounds, it may be null.\n+                        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n+                        offset > size\n+                    }\n+                    Err(offset) => offset == 0,\n+                }\n+            }\n+        }\n+    }\n+\n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n     /// the machine pointer to the allocation.  Must never be used\n     /// for any other pointers, nor for TLS statics."}, {"sha": "04a6209990ccf72795e45716ae4f89f30db87675", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -483,21 +483,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         })\n     }\n-\n-    /// Test if the pointer might be null.\n-    pub fn ptr_may_be_null(&self, ptr: Pointer<Option<M::PointerTag>>) -> bool {\n-        match self.ptr_try_get_alloc(ptr) {\n-            Ok((alloc_id, offset, _)) => {\n-                let (size, _align) = self\n-                    .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\");\n-                // If the pointer is out-of-bounds, it may be null.\n-                // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n-                offset > size\n-            }\n-            Err(offset) => offset == 0,\n-        }\n-    }\n }\n \n /// Allocation accessors"}, {"sha": "eba5c2bbe5aaff06c0e8ae80976e75efa2c0f8f3", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -720,12 +720,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Err(dbg_val) => {\n                         // So this is a pointer then, and casting to an int failed.\n                         // Can only happen during CTFE.\n-                        let ptr = self.scalar_to_ptr(tag_val);\n                         // The niche must be just 0, and the ptr not null, then we know this is\n                         // okay. Everything else, we conservatively reject.\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n-                            && !self.memory.ptr_may_be_null(ptr);\n+                            && !self.scalar_may_be_null(tag_val);\n                         if !ptr_valid {\n                             throw_ub!(InvalidTag(dbg_val))\n                         }"}, {"sha": "5cacab823866ad81dc7804e103ae69a625e2b183", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -572,21 +572,25 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n                     err_ub!(InvalidUninitBytes(None)) => { \"uninitialized bytes\" } expected { \"a proper pointer or integer value\" },\n                 );\n-                let ptr = self.ecx.scalar_to_ptr(value);\n-                // Ensure the pointer is non-null.\n-                if self.ecx.memory.ptr_may_be_null(ptr) {\n-                    throw_validation_failure!(self.path, { \"a potentially null function pointer\" });\n-                }\n+\n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n+                    let ptr = self.ecx.scalar_to_ptr(value);\n                     let _fn = try_validation!(\n                         self.ecx.memory.get_fn(ptr),\n                         self.path,\n+                        err_ub!(DanglingIntPointer(0, _)) =>\n+                            { \"a null function pointer\" },\n                         err_ub!(DanglingIntPointer(..)) |\n                         err_ub!(InvalidFunctionPointer(..)) =>\n                             { \"{:x}\", value } expected { \"a function pointer\" },\n                     );\n                     // FIXME: Check if the signature matches\n+                } else {\n+                    // Otherwise (for standalone Miri), we have to still check it to be non-null.\n+                    if self.ecx.scalar_may_be_null(value) {\n+                        throw_validation_failure!(self.path, { \"a null function pointer\" });\n+                    }\n                 }\n                 Ok(true)\n             }\n@@ -644,10 +648,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n-                let ptr = self.ecx.scalar_to_ptr(value);\n                 if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.memory.ptr_may_be_null(ptr) {\n+                    if self.ecx.scalar_may_be_null(value) {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {\n@@ -758,7 +761,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n-        // Check primitive types -- the leafs of our recursive descend.\n+        // Check primitive types -- the leaves of our recursive descent.\n         if self.try_visit_primitive(op)? {\n             return Ok(());\n         }"}, {"sha": "f6f2432f2d71d8fa94a7bb6e11930f0c25d0420b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -112,7 +112,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:49:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a potentially null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "28bd040e2232c3f812ec966d822ef81efcd21b8b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8064d7d49073ff9962369a40678c934d700f7e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8064d7d49073ff9962369a40678c934d700f7e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=d8064d7d49073ff9962369a40678c934d700f7e0", "patch": "@@ -112,7 +112,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:49:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a potentially null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}]}