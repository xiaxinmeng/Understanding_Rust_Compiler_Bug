{"sha": "5eff2645335e86f714a92a592f81936fead1f6a4", "node_id": "C_kwDOAAsO6NoAKDVlZmYyNjQ1MzM1ZTg2ZjcxNGE5MmE1OTJmODE5MzZmZWFkMWY2YTQ", "commit": {"author": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2023-01-23T08:12:25Z"}, "committer": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2023-01-23T08:12:25Z"}, "message": "Document missing unsafe blocks", "tree": {"sha": "d1395595810125aa75fa4bb51b0c6b78604fd15a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1395595810125aa75fa4bb51b0c6b78604fd15a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eff2645335e86f714a92a592f81936fead1f6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eff2645335e86f714a92a592f81936fead1f6a4", "html_url": "https://github.com/rust-lang/rust/commit/5eff2645335e86f714a92a592f81936fead1f6a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eff2645335e86f714a92a592f81936fead1f6a4/comments", "author": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f297afa0c91243b17283be17864f2c48f91127d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f297afa0c91243b17283be17864f2c48f91127d9", "html_url": "https://github.com/rust-lang/rust/commit/f297afa0c91243b17283be17864f2c48f91127d9"}], "stats": {"total": 16, "additions": 12, "deletions": 4}, "files": [{"sha": "fc35c46d5830095ebcb0bb3624dc4182c03716e8", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5eff2645335e86f714a92a592f81936fead1f6a4/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eff2645335e86f714a92a592f81936fead1f6a4/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=5eff2645335e86f714a92a592f81936fead1f6a4", "patch": "@@ -21,6 +21,9 @@ struct InsertionHole<T> {\n \n impl<T> Drop for InsertionHole<T> {\n     fn drop(&mut self) {\n+        // SAFETY: This is a helper class. Please refer to its usage for correctness. Namely, one\n+        // must be sure that `src` and `dst` does not overlap as required by\n+        // `ptr::copy_nonoverlapping` and are both valid for writes.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }\n@@ -88,6 +91,7 @@ where\n {\n     debug_assert!(v.len() >= 2);\n \n+    // SAFETY: caller must ensure v is at least len 2.\n     unsafe {\n         if is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n             let arr_ptr = v.as_mut_ptr();\n@@ -153,7 +157,8 @@ where\n     // Shift each element of the unsorted region v[i..] as far left as is needed to make v sorted.\n     for i in offset..len {\n         // SAFETY: we tested that `offset` must be at least 1, so this loop is only entered if len\n-        // >= 2.\n+        // >= 2. The range is exclusive and we know `i` must be at least 1 so this slice has at\n+        // >least len 2.\n         unsafe {\n             insert_tail(&mut v[..=i], is_less);\n         }\n@@ -176,9 +181,10 @@ where\n \n     // Shift each element of the unsorted region v[..i] as far left as is needed to make v sorted.\n     for i in (0..offset).rev() {\n-        // We ensured that the slice length is always at least 2 long.\n-        // We know that start_found will be at least one less than end,\n-        // and the range is exclusive. Which gives us i always <= (end - 2).\n+        // SAFETY: we tested that `offset` must be at least 1, so this loop is only entered if len\n+        // >= 2.We ensured that the slice length is always at least 2 long. We know that start_found\n+        // will be at least one less than end, and the range is exclusive. Which gives us i always\n+        // <= (end - 2).\n         unsafe {\n             insert_head(&mut v[i..len], is_less);\n         }\n@@ -1222,6 +1228,8 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             let left = runs[r];\n             let right = runs[r + 1];\n             let merge_slice = &mut v[left.start..right.start + right.len];\n+            // SAFETY: `buf_ptr` must hold enough capacity for the shorter of the two sides, and\n+            // neither side may be on length 0.\n             unsafe {\n                 merge(merge_slice, left.len, buf_ptr, is_less);\n             }"}]}