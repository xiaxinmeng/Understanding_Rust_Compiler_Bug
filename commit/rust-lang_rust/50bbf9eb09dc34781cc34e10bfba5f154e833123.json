{"sha": "50bbf9eb09dc34781cc34e10bfba5f154e833123", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYmJmOWViMDlkYzM0NzgxY2MzNGUxMGJmYmE1ZjE1NGU4MzMxMjM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-05T12:21:00Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-11T14:21:20Z"}, "message": "Handle where clauses in trait solving", "tree": {"sha": "6ed1ff97c8923ddeea085c75d417d5185493ef11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ed1ff97c8923ddeea085c75d417d5185493ef11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50bbf9eb09dc34781cc34e10bfba5f154e833123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50bbf9eb09dc34781cc34e10bfba5f154e833123", "html_url": "https://github.com/rust-lang/rust/commit/50bbf9eb09dc34781cc34e10bfba5f154e833123", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50bbf9eb09dc34781cc34e10bfba5f154e833123/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "940c538ecf42a53e5a0e0e9ebad7267c1fe843ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/940c538ecf42a53e5a0e0e9ebad7267c1fe843ca", "html_url": "https://github.com/rust-lang/rust/commit/940c538ecf42a53e5a0e0e9ebad7267c1fe843ca"}], "stats": {"total": 217, "additions": 188, "deletions": 29}, "files": [{"sha": "8f98ca3a5a9f5bd85955dd481357389d570cc3e6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=50bbf9eb09dc34781cc34e10bfba5f154e833123", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     DefWithBody, Trait,\n     ids,\n     nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig, TypeCtor},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig, TypeCtor, GenericPredicate},\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap, ImplBlock},\n     generics::{GenericParams, GenericDef},\n@@ -138,6 +138,9 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n \n+    #[salsa::invoke(crate::ty::generic_predicates)]\n+    fn generic_predicates(&self, def: GenericDef) -> Arc<[GenericPredicate]>;\n+\n     #[salsa::invoke(crate::expr::body_with_source_map_query)]\n     fn body_with_source_map(\n         &self,"}, {"sha": "826117ba5ee53742e76a4cddea5b9e50829ec528", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=50bbf9eb09dc34781cc34e10bfba5f154e833123", "patch": "@@ -8,7 +8,7 @@ use std::sync::Arc;\n use ra_syntax::ast::{self, NameOwner, TypeParamsOwner, TypeBoundsOwner};\n \n use crate::{\n-    db::DefDatabase,\n+    db::{ HirDatabase, DefDatabase},\n     Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef, AdtDef\n };\n \n@@ -32,8 +32,8 @@ pub struct GenericParams {\n /// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n-    type_ref: TypeRef,\n-    trait_ref: Path,\n+    pub(crate) type_ref: TypeRef,\n+    pub(crate) trait_ref: Path,\n }\n \n // FIXME: consts can have type parameters from their parents (i.e. associated consts of traits)\n@@ -148,6 +148,19 @@ impl GenericParams {\n     }\n }\n \n+impl GenericDef {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> crate::Resolver {\n+        match self {\n+            GenericDef::Function(inner) => inner.resolver(db),\n+            GenericDef::Struct(inner) => inner.resolver(db),\n+            GenericDef::Enum(inner) => inner.resolver(db),\n+            GenericDef::Trait(inner) => inner.resolver(db),\n+            GenericDef::TypeAlias(inner) => inner.resolver(db),\n+            GenericDef::ImplBlock(inner) => inner.resolver(db),\n+        }\n+    }\n+}\n+\n impl From<Container> for GenericDef {\n     fn from(c: Container) -> Self {\n         match c {"}, {"sha": "cfe07156b091505cacc0378ac494669f23f22d6a", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=50bbf9eb09dc34781cc34e10bfba5f154e833123", "patch": "@@ -19,7 +19,7 @@ use std::{fmt, mem};\n use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait, GenericParams};\n use display::{HirDisplay, HirFormatter};\n \n-pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig};\n+pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig, generic_predicates};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n pub use lower::CallableDef;\n \n@@ -234,6 +234,35 @@ impl TraitRef {\n     }\n }\n \n+/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n+/// parameters of a generic item.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericPredicate {\n+    /// The given trait needs to be implemented for its type parameters.\n+    Implemented(TraitRef),\n+    /// We couldn't resolve the trait reference. (If some type parameters can't\n+    /// be resolved, they will just be Unknown).\n+    Error,\n+}\n+\n+impl GenericPredicate {\n+    pub fn is_error(&self) -> bool {\n+        match self {\n+            GenericPredicate::Error => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn subst(self, substs: &Substs) -> GenericPredicate {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                GenericPredicate::Implemented(trait_ref.subst(substs))\n+            }\n+            GenericPredicate::Error => self,\n+        }\n+    }\n+}\n+\n /// Basically a claim (currently not validated / checked) that the contained\n /// type / trait ref contains no inference variables; any inference variables it\n /// contained have been replaced by bound variables, and `num_vars` tells us how"}, {"sha": "09d26ce5ad4df7379a42c9bf271e7288c0a426a0", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=50bbf9eb09dc34781cc34e10bfba5f154e833123", "patch": "@@ -5,6 +5,7 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n+use std::sync::Arc;\n use std::iter;\n \n use crate::{\n@@ -18,9 +19,9 @@ use crate::{\n     resolve::{Resolver, Resolution},\n     path::{PathSegment, GenericArg},\n     generics::{GenericParams, HasGenericParams},\n-    adt::VariantDef, Trait\n+    adt::VariantDef, Trait, generics::{ WherePredicate, GenericDef}\n };\n-use super::{Ty, primitive, FnSig, Substs, TypeCtor, TraitRef};\n+use super::{Ty, primitive, FnSig, Substs, TypeCtor, TraitRef, GenericPredicate};\n \n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n@@ -208,16 +209,12 @@ pub(super) fn substs_from_path_segment(\n }\n \n impl TraitRef {\n-    pub(crate) fn from_hir(\n+    pub(crate) fn from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        type_ref: &TypeRef,\n+        path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let path = match type_ref {\n-            TypeRef::Path(path) => path,\n-            _ => return None,\n-        };\n         let resolved = match resolver.resolve_path(db, &path).take_types()? {\n             Resolution::Def(ModuleDef::Trait(tr)) => tr,\n             _ => return None,\n@@ -232,6 +229,19 @@ impl TraitRef {\n         Some(TraitRef { trait_: resolved, substs })\n     }\n \n+    pub(crate) fn from_hir(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        type_ref: &TypeRef,\n+        explicit_self_ty: Option<Ty>,\n+    ) -> Option<Self> {\n+        let path = match type_ref {\n+            TypeRef::Path(path) => path,\n+            _ => return None,\n+        };\n+        TraitRef::from_path(db, resolver, path, explicit_self_ty)\n+    }\n+\n     fn substs_from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -246,6 +256,15 @@ impl TraitRef {\n         let substs = Substs::identity(&trait_.generic_params(db));\n         TraitRef { trait_, substs }\n     }\n+\n+    pub(crate) fn for_where_predicate(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        pred: &WherePredicate,\n+    ) -> Option<TraitRef> {\n+        let self_ty = Ty::from_hir(db, resolver, &pred.type_ref);\n+        TraitRef::from_path(db, resolver, &pred.trait_ref, Some(self_ty))\n+    }\n }\n \n /// Build the declared type of an item. This depends on the namespace; e.g. for\n@@ -294,6 +313,24 @@ pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     Ty::from_hir(db, &resolver, type_ref)\n }\n \n+/// Resolve the where clause(s) of an item with generics.\n+pub(crate) fn generic_predicates(\n+    db: &impl HirDatabase,\n+    def: GenericDef,\n+) -> Arc<[GenericPredicate]> {\n+    let resolver = def.resolver(db);\n+    let generic_params = def.generic_params(db);\n+    let predicates = generic_params\n+        .where_predicates\n+        .iter()\n+        .map(|pred| {\n+            TraitRef::for_where_predicate(db, &resolver, pred)\n+                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+        })\n+        .collect::<Vec<_>>();\n+    predicates.into()\n+}\n+\n fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n     let signature = def.signature(db);\n     let resolver = def.resolver(db);"}, {"sha": "c3edf42b1bafb663979e75c9635c2e21f94fd324", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=50bbf9eb09dc34781cc34e10bfba5f154e833123", "patch": "@@ -2510,12 +2510,47 @@ fn method_resolution_where_clause_not_met() {\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n-impl S { fn foo(self) -> i8 { 0 } }\n-impl<T> Trait for T where T: Clone { fn foo(self) -> u128 { 0 } }\n+impl<T> Trait for T where T: Clone {}\n fn test() { (&S).foo()<|>; }\n \"#,\n     );\n-    assert_eq!(t, \"i8\");\n+    // This is also to make sure that we don't resolve to the foo method just\n+    // because that's the only method named foo we can find, which would make\n+    // the below tests not work\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {};\n+impl<T> Trait for T where T: Clone {}\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {};\n+impl<T, U> Into<U> for T where U: From<T> {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"S1\");\n }\n \n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {"}, {"sha": "2772a043251ffc8bd71eae38333c7e460e20cb0f", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50bbf9eb09dc34781cc34e10bfba5f154e833123/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=50bbf9eb09dc34781cc34e10bfba5f154e833123", "patch": "@@ -11,7 +11,7 @@ use ra_db::salsa::{InternId, InternKey};\n use crate::{\n     Trait, HasGenericParams, ImplBlock,\n     db::HirDatabase,\n-    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs},\n+    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, GenericPredicate}, generics::GenericDef,\n };\n use super::ChalkContext;\n \n@@ -146,13 +146,53 @@ impl ToChalk for ImplBlock {\n     }\n }\n \n+impl ToChalk for GenericPredicate {\n+    type Chalk = chalk_ir::QuantifiedWhereClause;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n+            }\n+            GenericPredicate::Error => panic!(\"Trying to pass errored where clause to Chalk\"),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        _db: &impl HirDatabase,\n+        _where_clause: chalk_ir::QuantifiedWhereClause,\n+    ) -> GenericPredicate {\n+        // This should never need to be called\n+        unimplemented!()\n+    }\n+}\n+\n fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n     chalk_ir::Binders {\n         value,\n         binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n     }\n }\n \n+fn convert_where_clauses(\n+    db: &impl HirDatabase,\n+    def: GenericDef,\n+    substs: &Substs,\n+) -> (Vec<chalk_ir::QuantifiedWhereClause>, bool) {\n+    let generic_predicates = db.generic_predicates(def);\n+    let mut result = Vec::with_capacity(generic_predicates.len());\n+    let mut has_error = false;\n+    for pred in generic_predicates.iter() {\n+        // FIXME: it would probably be nicer if we could just convert errored predicates to a where clause that is never true...\n+        if pred.is_error() {\n+            has_error = true;\n+        } else {\n+            result.push(pred.clone().subst(substs).to_chalk(db));\n+        }\n+    }\n+    (result, has_error)\n+}\n+\n impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n@@ -173,7 +213,7 @@ where\n             upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n             fundamental: false,\n         };\n-        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let (where_clauses, _) = convert_where_clauses(self.db, trait_.into(), &bound_vars);\n         let associated_ty_ids = Vec::new(); // FIXME add associated tys\n         let trait_datum_bound =\n             chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n@@ -185,21 +225,26 @@ where\n         let type_ctor = from_chalk(self.db, struct_id);\n         // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n         // FIXME extract this to a method on Ty\n-        let (num_params, upstream) = match type_ctor {\n+        let (num_params, where_clauses, upstream) = match type_ctor {\n             TypeCtor::Bool\n             | TypeCtor::Char\n             | TypeCtor::Int(_)\n             | TypeCtor::Float(_)\n             | TypeCtor::Never\n-            | TypeCtor::Str => (0, true),\n-            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => (1, true),\n-            TypeCtor::FnPtr { num_args } => (num_args as usize + 1, true),\n-            TypeCtor::Tuple { cardinality } => (cardinality as usize, true),\n+            | TypeCtor::Str => (0, vec![], true),\n+            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => {\n+                (1, vec![], true)\n+            }\n+            TypeCtor::FnPtr { num_args } => (num_args as usize + 1, vec![], true),\n+            TypeCtor::Tuple { cardinality } => (cardinality as usize, vec![], true),\n             TypeCtor::FnDef(_) => unimplemented!(),\n             TypeCtor::Adt(adt) => {\n                 let generic_params = adt.generic_params(self.db);\n+                let bound_vars = Substs::bound_vars(&generic_params);\n+                let (where_clauses, _) = convert_where_clauses(self.db, adt.into(), &bound_vars);\n                 (\n                     generic_params.count_params_including_parent(),\n+                    where_clauses,\n                     adt.krate(self.db) != Some(self.krate),\n                 )\n             }\n@@ -209,7 +254,6 @@ where\n             // FIXME set fundamental flag correctly\n             fundamental: false,\n         };\n-        let where_clauses = Vec::new(); // FIXME add where clauses\n         let self_ty = chalk_ir::ApplicationTy {\n             name: TypeName::TypeKindId(type_ctor.to_chalk(self.db).into()),\n             parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n@@ -237,10 +281,12 @@ where\n         } else {\n             chalk_rust_ir::ImplType::External\n         };\n+        let (where_clauses, where_clause_error) =\n+            convert_where_clauses(self.db, impl_block.into(), &bound_vars);\n         let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n             // FIXME handle negative impls (impl !Sync for Foo)\n             trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n-            where_clauses: Vec::new(),        // FIXME add where clauses\n+            where_clauses,\n             associated_ty_values: Vec::new(), // FIXME add associated type values\n             impl_type,\n         };\n@@ -253,10 +299,6 @@ where\n         self.db\n             .impls_for_trait(self.krate, trait_)\n             .iter()\n-            // FIXME temporary hack -- as long as we're not lowering where clauses\n-            // correctly, ignore impls with them completely so as to not treat\n-            // impl<T> Trait for T where T: ... as a blanket impl on all types\n-            .filter(|impl_block| impl_block.generic_params(self.db).where_predicates.is_empty())\n             .map(|impl_block| impl_block.to_chalk(self.db))\n             .collect()\n     }"}]}