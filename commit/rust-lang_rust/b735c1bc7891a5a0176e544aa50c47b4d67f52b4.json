{"sha": "b735c1bc7891a5a0176e544aa50c47b4d67f52b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MzVjMWJjNzg5MWE1YTAxNzZlNTQ0YWE1MGM0N2I0ZDY3ZjUyYjQ=", "commit": {"author": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2016-09-11T22:09:05Z"}, "committer": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2016-09-15T19:31:17Z"}, "message": "Tweak std::marker docs\n\nFixes #29361.", "tree": {"sha": "38eae2920cd13d57cf33ceb66d3f9e1275eec5bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38eae2920cd13d57cf33ceb66d3f9e1275eec5bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b735c1bc7891a5a0176e544aa50c47b4d67f52b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b735c1bc7891a5a0176e544aa50c47b4d67f52b4", "html_url": "https://github.com/rust-lang/rust/commit/b735c1bc7891a5a0176e544aa50c47b4d67f52b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b735c1bc7891a5a0176e544aa50c47b4d67f52b4/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "html_url": "https://github.com/rust-lang/rust/commit/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae"}], "stats": {"total": 423, "additions": 268, "deletions": 155}, "files": [{"sha": "5a1a034a36358d9d1098f537517fe2d26c7d8839", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 268, "deletions": 155, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/b735c1bc7891a5a0176e544aa50c47b4d67f52b4/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b735c1bc7891a5a0176e544aa50c47b4d67f52b4/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b735c1bc7891a5a0176e544aa50c47b4d67f52b4", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Primitive traits and marker types representing basic 'kinds' of types.\n+//! Primitive traits and types representing basic properties of types.\n //!\n //! Rust types can be classified in various useful ways according to\n-//! intrinsic properties of the type. These classifications, often called\n-//! 'kinds', are represented as traits.\n+//! their intrinsic properties. These classifications are represented\n+//! as traits.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -22,7 +22,21 @@ use hash::Hasher;\n \n /// Types that can be transferred across thread boundaries.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// This trait is automatically implemented when the compiler determines it's\n+/// appropriate.\n+///\n+/// An example of a non-`Send` type is the reference-counting pointer\n+/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// reference-counted value, they might try to update the reference count at the\n+/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n+/// some overhead) and thus is `Send`.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n@@ -38,10 +52,10 @@ impl<T: ?Sized> !Send for *const T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Send for *mut T { }\n \n-/// Types with a constant size known at compile-time.\n+/// Types with a constant size known at compile time.\n ///\n-/// All type parameters which can be bounded have an implicit bound of `Sized`. The special syntax\n-/// `?Sized` can be used to remove this bound if it is not appropriate.\n+/// All type parameters have an implicit bound of `Sized`. The special syntax\n+/// `?Sized` can be used to remove this bound if it's not appropriate.\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -51,6 +65,26 @@ impl<T: ?Sized> !Send for *mut T { }\n /// // struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]\n /// struct BarUse(Bar<[i32]>); // OK\n /// ```\n+///\n+/// The one exception is the implicit `Self` type of a trait, which does not\n+/// get an implicit `Sized` bound. This is because a `Sized` bound prevents\n+/// the trait from being used to form a [trait object]:\n+///\n+/// ```\n+/// # #![allow(unused_variables)]\n+/// trait Foo { }\n+/// trait Bar: Sized { }\n+///\n+/// struct Impl;\n+/// impl Foo for Impl { }\n+/// impl Bar for Impl { }\n+///\n+/// let x: &Foo = &Impl;    // OK\n+/// // let y: &Bar = &Impl; // error: the trait `Bar` cannot\n+///                         // be made into an object\n+/// ```\n+///\n+/// [trait object]: ../../book/trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n@@ -59,14 +93,27 @@ pub trait Sized {\n     // Empty.\n }\n \n-/// Types that can be \"unsized\" to a dynamically sized type.\n+/// Types that can be \"unsized\" to a dynamically-sized type.\n+///\n+/// For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and\n+/// `Unsize<fmt::Debug>`.\n+///\n+/// All implementations of `Unsize` are provided automatically by the compiler.\n+///\n+/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n+/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n+/// types. See the [DST coercion RFC][RFC982] for more details.\n+///\n+/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n-/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+/// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n /// words:\n@@ -87,7 +134,8 @@ pub trait Unsize<T: ?Sized> {\n /// However, if a type implements `Copy`, it instead has 'copy semantics':\n ///\n /// ```\n-/// // we can just derive a `Copy` implementation\n+/// // We can derive a `Copy` implementation. `Clone` is also required, as it's\n+/// // a supertrait of `Copy`.\n /// #[derive(Debug, Copy, Clone)]\n /// struct Foo;\n ///\n@@ -100,13 +148,59 @@ pub trait Unsize<T: ?Sized> {\n /// println!(\"{:?}\", x); // A-OK!\n /// ```\n ///\n-/// It's important to note that in these two examples, the only difference is if you are allowed to\n-/// access `x` after the assignment: a move is also a bitwise copy under the hood.\n+/// It's important to note that in these two examples, the only difference is whether you\n+/// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n+/// can result in bits being copied in memory, although this is sometimes optimized away.\n+///\n+/// ## How can I implement `Copy`?\n+///\n+/// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct MyStruct;\n+/// ```\n+///\n+/// You can also implement `Copy` and `Clone` manually:\n+///\n+/// ```\n+/// struct MyStruct;\n+///\n+/// impl Copy for MyStruct { }\n+///\n+/// impl Clone for MyStruct {\n+///     fn clone(&self) -> MyStruct {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n+/// bound on type parameters, which isn't always desired.\n+///\n+/// ## What's the difference between `Copy` and `Clone`?\n+///\n+/// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n+/// `Copy` is not overloadable; it is always a simple bit-wise copy.\n+///\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// provide any type-specific behavior necessary to duplicate values safely. For example,\n+/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// but not `Copy`.\n+///\n+/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// (see the example above).\n+///\n+/// [clone]: ../clone/trait.Clone.html\n+/// [string]: ../../std/string/struct.String.html\n ///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n-/// `struct` can be `Copy`:\n+/// struct can be `Copy`:\n ///\n /// ```\n /// # #[allow(dead_code)]\n@@ -116,7 +210,8 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// By contrast, consider\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -126,57 +221,35 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// The `PointList` `struct` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n+/// The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n /// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n /// ```\n ///\n-/// ## When can my type _not_ be `Copy`?\n+/// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying [`String`] would result in two attempts to free the same buffer.\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n+/// buffer, leading to a double free.\n ///\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n-/// ## What if I derive `Copy` on a type that can't?\n-///\n-/// If you try to derive `Copy` on a struct or enum, you will get a compile-time error.\n-/// Specifically, with structs you'll get [E0204](https://doc.rust-lang.org/error-index.html#E0204)\n-/// and with enums you'll get [E0205](https://doc.rust-lang.org/error-index.html#E0205).\n-///\n-/// ## When should my type be `Copy`?\n-///\n-/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n-/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n-/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n-/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n+/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get a\n+/// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n+/// [E0205].\n ///\n-/// ## Derivable\n+/// [E0204]: https://doc.rust-lang.org/error-index.html#E0204\n+/// [E0205]: https://doc.rust-lang.org/error-index.html#E0205\n ///\n-/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type.\n+/// ## When *should* my type be `Copy`?\n ///\n-/// ## How can I implement `Copy`?\n-///\n-/// There are two ways to implement `Copy` on your type:\n-///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct MyStruct;\n-/// ```\n-///\n-/// and\n-///\n-/// ```\n-/// struct MyStruct;\n-/// impl Copy for MyStruct {}\n-/// impl Clone for MyStruct { fn clone(&self) -> MyStruct { *self } }\n-/// ```\n-///\n-/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n-/// bound on type parameters, which isn't always desired.\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,\n+/// that implementing `Copy` is part of the public API of your type. If the type might become\n+/// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n+/// avoid a breaking API change.\n ///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n@@ -188,64 +261,74 @@ pub trait Copy : Clone {\n     // Empty.\n }\n \n-/// Types that can be safely shared between threads when aliased.\n+/// Types for which it is safe to share references between threads.\n+///\n+/// This trait is automatically implemented when the compiler determines\n+/// it's appropriate.\n ///\n /// The precise definition is: a type `T` is `Sync` if `&T` is\n-/// thread-safe. In other words, there is no possibility of data races\n-/// when passing `&T` references between threads.\n-///\n-/// As one would expect, primitive types like [`u8`] and [`f64`] are all\n-/// `Sync`, and so are simple aggregate types containing them (like\n-/// tuples, structs and enums). More instances of basic `Sync` types\n-/// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as [`Box<T>`], [`Vec<T>`] and most other\n-/// collection types. (Generic parameters need to be `Sync` for their\n-/// container to be `Sync`.)\n-///\n-/// A somewhat surprising consequence of the definition is `&mut T` is\n-/// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronized mutation. The trick is a mutable reference\n-/// stored in an aliasable reference (that is, `& &mut T`) becomes\n-/// read-only, as if it were a `& &T`, hence there is no risk of a data\n-/// race.\n+/// [`Send`][send]. In other words, if there is no possibility of\n+/// [undefined behavior][ub] (including data races) when passing\n+/// `&T` references between threads.\n+///\n+/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n+/// are all `Sync`, and so are simple aggregate types containing them,\n+/// like tuples, structs and enums. More examples of basic `Sync`\n+/// types include \"immutable\" types like `&T`, and those with simple\n+/// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n+/// most other collection types. (Generic parameters need to be `Sync`\n+/// for their container to be `Sync`.)\n+///\n+/// A somewhat surprising consequence of the definition is that `&mut T`\n+/// is `Sync` (if `T` is `Sync`) even though it seems like that might\n+/// provide unsynchronized mutation. The trick is that a mutable\n+/// reference behind a shared reference (that is, `& &mut T`)\n+/// becomes read-only, as if it were a `& &T`. Hence there is no risk\n+/// of a data race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as [`Cell`] and [`RefCell`]\n-/// in [`std::cell`]. These types allow for mutation of their contents\n-/// even when in an immutable, aliasable slot, e.g. the contents of\n-/// [`&Cell<T>`][`Cell`] can be [`.set`], and do not ensure data races are\n-/// impossible, hence they cannot be `Sync`. A higher level example\n-/// of a non-`Sync` type is the reference counted pointer\n-/// [`std::rc::Rc`][`Rc`], because any reference [`&Rc<T>`][`Rc`] can clone a new\n-/// reference, which modifies the reference counts in a non-atomic\n-/// way.\n-///\n-/// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in [`std::sync`][`sync`] and [`Mutex`] / [`RwLock`] in\n-/// the [`sync`] crate do ensure that any mutation cannot cause data\n-/// races.  Hence these types are `Sync`.\n-///\n-/// Any types with interior mutability must also use the [`std::cell::UnsafeCell`]\n-/// wrapper around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behavior (for example,\n-/// [`transmute`]-ing from `&T` to `&mut T` is invalid).\n+/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n+/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n+/// their contents even through an immutable, shared reference. For\n+/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n+/// only a shared reference `&Cell<T>`. The method performs no\n+/// synchronization, thus `Cell` cannot be `Sync`.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// Another example of a non-`Sync` type is the reference-counting\n+/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n+/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n ///\n-/// [`u8`]: ../../std/primitive.u8.html\n-/// [`f64`]: ../../std/primitive.f64.html\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`std::cell`]: ../../std/cell/index.html\n-/// [`.set`]: ../../std/cell/struct.Cell.html#method.set\n-/// [`Rc`]: ../../std/rc/struct.Rc.html\n-/// [`sync`]: ../../std/sync/index.html\n-/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n-/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n-/// [`std::cell::UnsafeCell`]: ../../std/cell/struct.UnsafeCell.html\n-/// [`transmute`]: ../../std/mem/fn.transmute.html\n+/// For cases when one does need thread-safe interior mutability,\n+/// Rust provides [atomic data types], as well as explicit locking via\n+/// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n+/// ensure that any mutation cannot cause data races, hence the types\n+/// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n+/// analogue of `Rc`.\n+///\n+/// Any types with interior mutability must also use the\n+/// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which\n+/// can be mutated through a shared reference. Failing to doing this is\n+/// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n+/// from `&T` to `&mut T` is invalid.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n+/// details about `Sync`.\n+///\n+/// [send]: trait.Send.html\n+/// [u8]: ../../std/primitive.u8.html\n+/// [f64]: ../../std/primitive.f64.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [vec]: ../../std/vec/struct.Vec.html\n+/// [cell]: ../cell/struct.Cell.html\n+/// [refcell]: ../cell/struct.RefCell.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [atomic data types]: ../sync/atomic/index.html\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [unsafecell]: ../cell/struct.UnsafeCell.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n@@ -314,29 +397,30 @@ macro_rules! impls{\n         )\n }\n \n-/// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n-/// even though it does not. This allows you to inform the compiler about certain safety properties\n-/// of your code.\n+/// Zero-sized type used to mark things that \"act like\" they own a `T`.\n ///\n-/// For a more in-depth explanation of how to use `PhantomData<T>`, please see [the Nomicon].\n+/// Adding a `PhantomData<T>` field to your type tells the compiler that your\n+/// type acts as though it stores a value of type `T`, even though it doesn't\n+/// really. This information is used when computing certain safety properties.\n ///\n-/// [the Nomicon]: ../../nomicon/phantom-data.html\n+/// For a more in-depth explanation of how to use `PhantomData<T>`, please see\n+/// [the Nomicon](../../nomicon/phantom-data.html).\n ///\n /// # A ghastly note \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n ///\n-/// Though they both have scary names, `PhantomData<T>` and 'phantom types' are related, but not\n-/// identical. Phantom types are a more general concept that don't require `PhantomData<T>` to\n-/// implement, but `PhantomData<T>` is the most common way to implement them in a correct manner.\n+/// Though they both have scary names, `PhantomData` and 'phantom types' are\n+/// related, but not identical. A phantom type parameter is simply a type\n+/// parameter which is never used. In Rust, this often causes the compiler to\n+/// complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.\n ///\n /// # Examples\n ///\n-/// ## Unused lifetime parameter\n+/// ## Unused lifetime parameters\n ///\n-/// Perhaps the most common time that `PhantomData` is required is\n-/// with a struct that has an unused lifetime parameter, typically as\n-/// part of some unsafe code. For example, here is a struct `Slice`\n-/// that has two pointers of type `*const T`, presumably pointing into\n-/// an array somewhere:\n+/// Perhaps the most common use case for `PhantomData` is a struct that has an\n+/// unused lifetime parameter, typically as part of some unsafe code. For\n+/// example, here is a struct `Slice` that has two pointers of type `*const T`,\n+/// presumably pointing into an array somewhere:\n ///\n /// ```ignore\n /// struct Slice<'a, T> {\n@@ -350,7 +434,7 @@ macro_rules! impls{\n /// intent is not expressed in the code, since there are no uses of\n /// the lifetime `'a` and hence it is not clear what data it applies\n /// to. We can correct this by telling the compiler to act *as if* the\n-/// `Slice` struct contained a borrowed reference `&'a T`:\n+/// `Slice` struct contained a reference `&'a T`:\n ///\n /// ```\n /// use std::marker::PhantomData;\n@@ -359,29 +443,53 @@ macro_rules! impls{\n /// struct Slice<'a, T: 'a> {\n ///     start: *const T,\n ///     end: *const T,\n-///     phantom: PhantomData<&'a T>\n+///     phantom: PhantomData<&'a T>,\n /// }\n /// ```\n ///\n-/// This also in turn requires that we annotate `T:'a`, indicating\n-/// that `T` is a type that can be borrowed for the lifetime `'a`.\n+/// This also in turn requires the annotation `T: 'a`, indicating\n+/// that any references in `T` are valid over the lifetime `'a`.\n+///\n+/// When initializing a `Slice` you simply provide the value\n+/// `PhantomData` for the field `phantom`:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// # use std::marker::PhantomData;\n+/// # struct Slice<'a, T: 'a> {\n+/// #     start: *const T,\n+/// #     end: *const T,\n+/// #     phantom: PhantomData<&'a T>,\n+/// # }\n+/// fn borrow_vec<'a, T>(vec: &'a Vec<T>) -> Slice<'a, T> {\n+///     let ptr = vec.as_ptr();\n+///     Slice {\n+///         start: ptr,\n+///         end: unsafe { ptr.offset(vec.len() as isize) },\n+///         phantom: PhantomData,\n+///     }\n+/// }\n+/// ```\n ///\n /// ## Unused type parameters\n ///\n-/// It sometimes happens that there are unused type parameters that\n+/// It sometimes happens that you have unused type parameters which\n /// indicate what type of data a struct is \"tied\" to, even though that\n /// data is not actually found in the struct itself. Here is an\n-/// example where this arises when handling external resources over a\n-/// foreign function interface. `PhantomData<T>` can prevent\n-/// mismatches by enforcing types in the method implementations:\n+/// example where this arises with [FFI]. The foreign interface uses\n+/// handles of type `*mut ()` to refer to Rust values of different\n+/// types. We track the Rust type using a phantom type parameter on\n+/// the struct `ExternalResource` which wraps a handle.\n+///\n+/// [FFI]: ../../book/ffi.html\n ///\n /// ```\n /// # #![allow(dead_code)]\n-/// # trait ResType { fn foo(&self); }\n+/// # trait ResType { }\n /// # struct ParamType;\n /// # mod foreign_lib {\n-/// # pub fn new(_: usize) -> *mut () { 42 as *mut () }\n-/// # pub fn do_stuff(_: *mut (), _: usize) {}\n+/// #     pub fn new(_: usize) -> *mut () { 42 as *mut () }\n+/// #     pub fn do_stuff(_: *mut (), _: usize) {}\n /// # }\n /// # fn convert_params(_: ParamType) -> usize { 42 }\n /// use std::marker::PhantomData;\n@@ -408,21 +516,20 @@ macro_rules! impls{\n /// }\n /// ```\n ///\n-/// ## Indicating ownership\n+/// ## Ownership and the drop check\n ///\n-/// Adding a field of type `PhantomData<T>` also indicates that your\n-/// struct owns data of type `T`. This in turn implies that when your\n-/// struct is dropped, it may in turn drop one or more instances of\n-/// the type `T`, though that may not be apparent from the other\n-/// structure of the type itself. This is commonly necessary if the\n-/// structure is using a raw pointer like `*mut T` whose referent\n-/// may be dropped when the type is dropped, as a `*mut T` is\n-/// otherwise not treated as owned.\n+/// Adding a field of type `PhantomData<T>` indicates that your\n+/// type owns data of type `T`. This in turn implies that when your\n+/// type is dropped, it may drop one or more instances of the type\n+/// `T`. This has bearing on the Rust compiler's [drop check]\n+/// analysis.\n ///\n /// If your struct does not in fact *own* the data of type `T`, it is\n /// better to use a reference type, like `PhantomData<&'a T>`\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n+///\n+/// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n@@ -438,10 +545,13 @@ mod impls {\n \n /// Types that can be reflected over.\n ///\n-/// This trait is implemented for all types. Its purpose is to ensure\n-/// that when you write a generic function that will employ\n-/// reflection, that must be reflected (no pun intended) in the\n-/// generic bounds of that function. Here is an example:\n+/// By \"reflection\" we mean use of the [`Any`][any] trait, or related\n+/// machinery such as [`TypeId`][typeid].\n+///\n+/// `Reflect` is implemented for all types. Its purpose is to ensure\n+/// that when you write a generic function that will employ reflection,\n+/// that must be reflected (no pun intended) in the generic bounds of\n+/// that function.\n ///\n /// ```\n /// #![feature(reflect_marker)]\n@@ -455,21 +565,24 @@ mod impls {\n /// }\n /// ```\n ///\n-/// Without the declaration `T: Reflect`, `foo` would not type check\n-/// (note: as a matter of style, it would be preferable to write\n-/// `T: Any`, because `T: Any` implies `T: Reflect` and `T: 'static`, but\n-/// we use `Reflect` here to show how it works). The `Reflect` bound\n-/// thus serves to alert `foo`'s caller to the fact that `foo` may\n-/// behave differently depending on whether `T = u32` or not. In\n-/// particular, thanks to the `Reflect` bound, callers know that a\n-/// function declared like `fn bar<T>(...)` will always act in\n-/// precisely the same way no matter what type `T` is supplied,\n-/// because there are no bounds declared on `T`. (The ability for a\n-/// caller to reason about what a function may do based solely on what\n-/// generic bounds are declared is often called the [\"parametricity\n-/// property\"][1].)\n-///\n-/// [1]: http://en.wikipedia.org/wiki/Parametricity\n+/// Without the bound `T: Reflect`, `foo` would not typecheck. (As\n+/// a matter of style, it would be preferable to write `T: Any`,\n+/// because `T: Any` implies `T: Reflect` and `T: 'static`, but we\n+/// use `Reflect` here for illustrative purposes.)\n+///\n+/// The `Reflect` bound serves to alert `foo`'s caller to the\n+/// fact that `foo` may behave differently depending on whether\n+/// `T` is `u32` or not. The ability for a caller to reason about what\n+/// a function may do based solely on what generic bounds are declared\n+/// is often called the \"[parametricity property][param]\". Despite the\n+/// use of `Reflect`, Rust lacks true parametricity because a generic\n+/// function can, at the very least, call [`mem::size_of`][size_of]\n+/// without employing any trait bounds whatsoever.\n+///\n+/// [any]: ../any/trait.Any.html\n+/// [typeid]: ../any/struct.TypeId.html\n+/// [param]: http://en.wikipedia.org/wiki/Parametricity\n+/// [size_of]: ../mem/fn.size_of.html\n #[rustc_reflect_like]\n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\","}]}