{"sha": "0886419524c5baf61d6f3980e81ba4e0429ac402", "node_id": "C_kwDOAAsO6NoAKDA4ODY0MTk1MjRjNWJhZjYxZDZmMzk4MGU4MWJhNGUwNDI5YWM0MDI", "commit": {"author": {"name": "Tavian Barnes", "email": "tavianator@tavianator.com", "date": "2022-02-22T22:06:05Z"}, "committer": {"name": "Tavian Barnes", "email": "tavianator@tavianator.com", "date": "2022-03-07T21:19:03Z"}, "message": "Implement a readdir64() shim for Linux\n\nPartial fix for #1966.", "tree": {"sha": "9c1999c9c3b811df1e849831a026033cc98e7cda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1999c9c3b811df1e849831a026033cc98e7cda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0886419524c5baf61d6f3980e81ba4e0429ac402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0886419524c5baf61d6f3980e81ba4e0429ac402", "html_url": "https://github.com/rust-lang/rust/commit/0886419524c5baf61d6f3980e81ba4e0429ac402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0886419524c5baf61d6f3980e81ba4e0429ac402/comments", "author": {"login": "tavianator", "id": 1692591, "node_id": "MDQ6VXNlcjE2OTI1OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1692591?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavianator", "html_url": "https://github.com/tavianator", "followers_url": "https://api.github.com/users/tavianator/followers", "following_url": "https://api.github.com/users/tavianator/following{/other_user}", "gists_url": "https://api.github.com/users/tavianator/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavianator/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavianator/subscriptions", "organizations_url": "https://api.github.com/users/tavianator/orgs", "repos_url": "https://api.github.com/users/tavianator/repos", "events_url": "https://api.github.com/users/tavianator/events{/privacy}", "received_events_url": "https://api.github.com/users/tavianator/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tavianator", "id": 1692591, "node_id": "MDQ6VXNlcjE2OTI1OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1692591?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavianator", "html_url": "https://github.com/tavianator", "followers_url": "https://api.github.com/users/tavianator/followers", "following_url": "https://api.github.com/users/tavianator/following{/other_user}", "gists_url": "https://api.github.com/users/tavianator/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavianator/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavianator/subscriptions", "organizations_url": "https://api.github.com/users/tavianator/orgs", "repos_url": "https://api.github.com/users/tavianator/repos", "events_url": "https://api.github.com/users/tavianator/events{/privacy}", "received_events_url": "https://api.github.com/users/tavianator/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0088715411c2fcb3ea36cdbb969fb9966d722320", "url": "https://api.github.com/repos/rust-lang/rust/commits/0088715411c2fcb3ea36cdbb969fb9966d722320", "html_url": "https://github.com/rust-lang/rust/commit/0088715411c2fcb3ea36cdbb969fb9966d722320"}], "stats": {"total": 140, "additions": 76, "deletions": 64}, "files": [{"sha": "300e3c514b37598546a197ad771c433aab30c4cb", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0886419524c5baf61d6f3980e81ba4e0429ac402/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0886419524c5baf61d6f3980e81ba4e0429ac402/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=0886419524c5baf61d6f3980e81ba4e0429ac402", "patch": "@@ -16,6 +16,7 @@ use rustc_target::abi::{Align, Size};\n \n use crate::*;\n use helpers::{check_arg_count, immty_from_int_checked, immty_from_uint_checked};\n+use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n@@ -421,6 +422,22 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n     }\n }\n \n+/// An open directory, tracked by DirHandler.\n+#[derive(Debug)]\n+pub struct OpenDir {\n+    /// The directory reader on the host.\n+    read_dir: ReadDir,\n+    /// The most recent entry returned by readdir()\n+    entry: Pointer<Option<Tag>>,\n+}\n+\n+impl OpenDir {\n+    fn new(read_dir: ReadDir) -> Self {\n+        // We rely on `free` being a NOP on null pointers.\n+        Self { read_dir, entry: Pointer::null() }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct DirHandler {\n     /// Directory iterators used to emulate libc \"directory streams\", as used in opendir, readdir,\n@@ -432,7 +449,7 @@ pub struct DirHandler {\n     /// the corresponding ReadDir iterator from this map, and information from the next\n     /// directory entry is returned. When closedir is called, the ReadDir iterator is removed from\n     /// the map.\n-    streams: FxHashMap<u64, ReadDir>,\n+    streams: FxHashMap<u64, OpenDir>,\n     /// ID number to be used by the next call to opendir\n     next_id: u64,\n }\n@@ -441,7 +458,7 @@ impl DirHandler {\n     fn insert_new(&mut self, read_dir: ReadDir) -> u64 {\n         let id = self.next_id;\n         self.next_id += 1;\n-        self.streams.try_insert(id, read_dir).unwrap();\n+        self.streams.try_insert(id, OpenDir::new(read_dir)).unwrap();\n         id\n     }\n }\n@@ -1207,32 +1224,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn linux_readdir64_r(\n-        &mut self,\n-        dirp_op: &OpTy<'tcx, Tag>,\n-        entry_op: &OpTy<'tcx, Tag>,\n-        result_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n+    fn linux_readdir64(&mut self, dirp_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n \n-        this.assert_target_os(\"linux\", \"readdir64_r\");\n+        this.assert_target_os(\"linux\", \"readdir64\");\n \n         let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n-            this.reject_in_isolation(\"`readdir64_r`\", reject_with)?;\n-            // Set error code as \"EBADF\" (bad fd)\n-            return this.handle_not_found();\n+            this.reject_in_isolation(\"`readdir`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EBADF\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(Scalar::null_ptr(this));\n         }\n \n-        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n-            err_unsup_format!(\"the DIR pointer passed to readdir64_r did not come from opendir\")\n+        let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+            err_unsup_format!(\"the DIR pointer passed to readdir64 did not come from opendir\")\n         })?;\n-        match dir_iter.next() {\n+\n+        let entry = match open_dir.read_dir.next() {\n             Some(Ok(dir_entry)) => {\n-                // Write into entry, write pointer to result, return 0 on success.\n-                // The name is written with write_os_str_to_c_str, while the rest of the\n+                // Write the directory entry into a newly allocated buffer.\n+                // The name is written with write_bytes, while the rest of the\n                 // dirent64 struct is written using write_packed_immediates.\n \n                 // For reference:\n@@ -1244,22 +1258,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 //     pub d_name: [c_char; 256],\n                 // }\n \n-                let entry_place = this.deref_operand(entry_op)?;\n-                let name_place = this.mplace_field(&entry_place, 4)?;\n+                let mut name = dir_entry.file_name(); // not a Path as there are no separators!\n+                name.push(\"\\0\"); // Add a NUL terminator\n+                let name_bytes = os_str_to_bytes(&name)?;\n+                let name_len = u64::try_from(name_bytes.len()).unwrap();\n \n-                let file_name = dir_entry.file_name(); // not a Path as there are no separators!\n-                let (name_fits, _) = this.write_os_str_to_c_str(\n-                    &file_name,\n-                    name_place.ptr,\n-                    name_place.layout.size.bytes(),\n-                )?;\n-                if !name_fits {\n-                    throw_unsup_format!(\n-                        \"a directory entry had a name too large to fit in libc::dirent64\"\n-                    );\n-                }\n+                let dirent64_layout = this.libc_ty_layout(\"dirent64\")?;\n+                let d_name_offset = dirent64_layout.fields.offset(4 /* d_name */).bytes();\n+                let size = d_name_offset.checked_add(name_len).unwrap();\n \n-                let entry_place = this.deref_operand(entry_op)?;\n+                let entry =\n+                    this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::Runtime)?;\n+\n+                // FIXME: make use of dirent64_layout\n                 let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n                 let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n                 let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n@@ -1277,33 +1288,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let imms = [\n                     immty_from_uint_checked(ino, ino64_t_layout)?, // d_ino\n                     immty_from_uint_checked(0u128, off64_t_layout)?, // d_off\n-                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                    immty_from_uint_checked(size, c_ushort_layout)?, // d_reclen\n                     immty_from_int_checked(file_type, c_uchar_layout)?, // d_type\n                 ];\n+                let entry_layout = this.layout_of(this.tcx.mk_array(this.tcx.types.u8, size))?;\n+                let entry_place = MPlaceTy::from_aligned_ptr(entry, entry_layout);\n                 this.write_packed_immediates(&entry_place, &imms)?;\n \n-                let result_place = this.deref_operand(result_op)?;\n-                this.write_scalar(this.read_scalar(entry_op)?, &result_place.into())?;\n+                let name_ptr = entry.offset(Size::from_bytes(d_name_offset), this)?;\n+                this.memory.write_bytes(name_ptr, name_bytes.iter().copied())?;\n \n-                Ok(0)\n+                entry\n             }\n             None => {\n-                // end of stream: return 0, assign *result=NULL\n-                this.write_null(&this.deref_operand(result_op)?.into())?;\n-                Ok(0)\n+                // end of stream: return NULL\n+                Pointer::null()\n             }\n-            Some(Err(e)) =>\n-                match e.raw_os_error() {\n-                    // return positive error number on error\n-                    Some(error) => Ok(error),\n-                    None => {\n-                        throw_unsup_format!(\n-                            \"the error {} couldn't be converted to a return value\",\n-                            e\n-                        )\n-                    }\n-                },\n-        }\n+            Some(Err(e)) => {\n+                this.set_last_error_from_io_error(e.kind())?;\n+                Pointer::null()\n+            }\n+        };\n+\n+        let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).unwrap();\n+        let old_entry = std::mem::replace(&mut open_dir.entry, entry);\n+        this.free(old_entry, MiriMemoryKind::Runtime)?;\n+\n+        Ok(Scalar::from_maybe_pointer(entry, this))\n     }\n \n     fn macos_readdir_r(\n@@ -1325,10 +1336,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return this.handle_not_found();\n         }\n \n-        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+        let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n             err_unsup_format!(\"the DIR pointer passed to readdir_r did not come from opendir\")\n         })?;\n-        match dir_iter.next() {\n+        match open_dir.read_dir.next() {\n             Some(Ok(dir_entry)) => {\n                 // Write into entry, write pointer to result, return 0 on success.\n                 // The name is written with write_os_str_to_c_str, while the rest of the\n@@ -1419,8 +1430,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return this.handle_not_found();\n         }\n \n-        if let Some(dir_iter) = this.machine.dir_handler.streams.remove(&dirp) {\n-            drop(dir_iter);\n+        if let Some(open_dir) = this.machine.dir_handler.streams.remove(&dirp) {\n+            this.free(open_dir.entry, MiriMemoryKind::Runtime)?;\n+            drop(open_dir);\n             Ok(0)\n         } else {\n             this.handle_not_found()"}, {"sha": "280f24e9ea49629e1ac849a87f5b994a29d10a41", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0886419524c5baf61d6f3980e81ba4e0429ac402/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0886419524c5baf61d6f3980e81ba4e0429ac402/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=0886419524c5baf61d6f3980e81ba4e0429ac402", "patch": "@@ -43,11 +43,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n-            \"readdir64_r\" => {\n-                let &[ref dirp, ref entry, ref result] =\n+            \"readdir64\" => {\n+                let &[ref dirp] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let result = this.linux_readdir64_r(dirp, entry, result)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                let result = this.linux_readdir64(dirp)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"ftruncate64\" => {\n                 let &[ref fd, ref length] ="}, {"sha": "be680131f84ab106563aa7cff391ee38e5029638", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0886419524c5baf61d6f3980e81ba4e0429ac402/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0886419524c5baf61d6f3980e81ba4e0429ac402/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=0886419524c5baf61d6f3980e81ba4e0429ac402", "patch": "@@ -6,7 +6,9 @@\n extern crate libc;\n \n use std::ffi::CString;\n-use std::fs::{create_dir, remove_dir, remove_dir_all, remove_file, rename, File, OpenOptions};\n+use std::fs::{\n+    create_dir, read_dir, remove_dir, remove_dir_all, remove_file, rename, File, OpenOptions,\n+};\n use std::io::{Error, ErrorKind, Read, Result, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n \n@@ -374,19 +376,17 @@ fn test_directory() {\n     let path_2 = dir_path.join(\"test_file_2\");\n     drop(File::create(&path_2).unwrap());\n     // Test that the files are present inside the directory\n-    /* FIXME(1966) disabled due to missing readdir support\n     let dir_iter = read_dir(&dir_path).unwrap();\n     let mut file_names = dir_iter.map(|e| e.unwrap().file_name()).collect::<Vec<_>>();\n     file_names.sort_unstable();\n-    assert_eq!(file_names, vec![\"test_file_1\", \"test_file_2\"]); */\n+    assert_eq!(file_names, vec![\"test_file_1\", \"test_file_2\"]);\n     // Clean up the files in the directory\n     remove_file(&path_1).unwrap();\n     remove_file(&path_2).unwrap();\n     // Now there should be nothing left in the directory.\n-    /* FIXME(1966) disabled due to missing readdir support\n-    dir_iter = read_dir(&dir_path).unwrap();\n+    let dir_iter = read_dir(&dir_path).unwrap();\n     let file_names = dir_iter.map(|e| e.unwrap().file_name()).collect::<Vec<_>>();\n-    assert!(file_names.is_empty());*/\n+    assert!(file_names.is_empty());\n \n     // Deleting the directory should succeed.\n     remove_dir(&dir_path).unwrap();"}]}