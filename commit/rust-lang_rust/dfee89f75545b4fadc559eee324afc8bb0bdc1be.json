{"sha": "dfee89f75545b4fadc559eee324afc8bb0bdc1be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZWU4OWY3NTU0NWI0ZmFkYzU1OWVlZTMyNGFmYzhiYjBiZGMxYmU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-02-12T22:44:43Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-02-13T19:30:07Z"}, "message": "Make ProjectionTy::trait_ref truncate substs again\n\nAlso make sure that type arguments of associated types are printed in\nsome error messages.", "tree": {"sha": "486a81d0f0a7613b0c65f3fac233b4d0ed00bcf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/486a81d0f0a7613b0c65f3fac233b4d0ed00bcf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfee89f75545b4fadc559eee324afc8bb0bdc1be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfee89f75545b4fadc559eee324afc8bb0bdc1be", "html_url": "https://github.com/rust-lang/rust/commit/dfee89f75545b4fadc559eee324afc8bb0bdc1be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfee89f75545b4fadc559eee324afc8bb0bdc1be/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "html_url": "https://github.com/rust-lang/rust/commit/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88"}], "stats": {"total": 265, "additions": 216, "deletions": 49}, "files": [{"sha": "ff95524492409099521da20e7aae4e440e69297b", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -1,5 +1,6 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n+use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, DiagnosticBuilder};\n@@ -400,14 +401,22 @@ impl<'tcx> TyCtxt<'tcx> {\n                         {\n                             // Synthesize the associated type restriction `Add<Output = Expected>`.\n                             // FIXME: extract this logic for use in other diagnostics.\n-                            let trait_ref = proj.trait_ref(self);\n+                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n                             let path =\n                                 self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n                             let item_name = self.item_name(proj.item_def_id);\n+                            let item_args = self.format_generic_args(assoc_substs);\n+\n                             let path = if path.ends_with('>') {\n-                                format!(\"{}, {} = {}>\", &path[..path.len() - 1], item_name, p)\n+                                format!(\n+                                    \"{}, {}{} = {}>\",\n+                                    &path[..path.len() - 1],\n+                                    item_name,\n+                                    item_args,\n+                                    p\n+                                )\n                             } else {\n-                                format!(\"{}<{} = {}>\", path, item_name, p)\n+                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n                             };\n                             note = !suggest_constraining_type_param(\n                                 self,\n@@ -556,7 +565,7 @@ impl<T> Trait<T> for X {\n         ty: Ty<'tcx>,\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n-        let trait_ref = proj_ty.trait_ref(self);\n+        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n                 // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n@@ -590,6 +599,7 @@ impl<T> Trait<T> for X {\n                             &trait_ref,\n                             pred.bounds,\n                             &assoc,\n+                            assoc_substs,\n                             ty,\n                             msg,\n                         ) {\n@@ -607,6 +617,7 @@ impl<T> Trait<T> for X {\n                             &trait_ref,\n                             param.bounds,\n                             &assoc,\n+                            assoc_substs,\n                             ty,\n                             msg,\n                         );\n@@ -692,6 +703,7 @@ impl<T> Trait<T> for X {\n                 db,\n                 self.def_span(def_id),\n                 &assoc,\n+                proj_ty.trait_ref_and_own_substs(self).1,\n                 values.found,\n                 &msg,\n             ) {\n@@ -856,6 +868,7 @@ fn foo(&self) -> Self::T { String::new() }\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n         assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n     ) -> bool {\n@@ -865,7 +878,12 @@ fn foo(&self) -> Self::T { String::new() }\n                 // Relate the type param against `T` in `<A as T>::Foo`.\n                 ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n                     && self.constrain_associated_type_structured_suggestion(\n-                        db, ptr.span, assoc, ty, msg,\n+                        db,\n+                        ptr.span,\n+                        assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n                     )\n             }\n             _ => false,\n@@ -879,6 +897,7 @@ fn foo(&self) -> Self::T { String::new() }\n         db: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n     ) -> bool {\n@@ -890,11 +909,20 @@ fn foo(&self) -> Self::T { String::new() }\n                 let span = Span::new(pos, pos, span.ctxt());\n                 (span, format!(\", {} = {}\", assoc.ident, ty))\n             } else {\n-                (span.shrink_to_hi(), format!(\"<{} = {}>\", assoc.ident, ty))\n+                let item_args = self.format_generic_args(assoc_substs);\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident, item_args, ty))\n             };\n             db.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n             return true;\n         }\n         false\n     }\n+\n+    fn format_generic_args(self, args: &[ty::GenericArg<'tcx>]) -> String {\n+        let mut item_args = String::new();\n+        FmtPrinter::new(self, &mut item_args, hir::def::Namespace::TypeNS)\n+            .path_generic_args(Ok, args)\n+            .expect(\"could not write to `String`.\");\n+        item_args\n+    }\n }"}, {"sha": "b7f62437fa5a86379a79f1728eb076100a914599", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -1289,8 +1289,22 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n+    /// Returns the `DefId` of the trait of the associated item being projected.\n     #[inline]\n-    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n+    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.skip_binder().projection_ty.trait_def_id(tcx)\n+    }\n+\n+    #[inline]\n+    pub fn projection_self_ty(&self) -> Binder<Ty<'tcx>> {\n+        self.map_bound(|predicate| predicate.projection_ty.self_ty())\n+    }\n+\n+    /// Get the [PolyTraitRef] required for this projection to be well formed.\n+    /// Note that for generic associated types the predicates of the associated\n+    /// type also need to be checked.\n+    #[inline]\n+    pub fn required_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our"}, {"sha": "754108ea3c58afdcd598ffaf381a315e67df061b", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -17,7 +17,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n@@ -1112,20 +1112,35 @@ pub struct ProjectionTy<'tcx> {\n }\n \n impl<'tcx> ProjectionTy<'tcx> {\n+    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        tcx.associated_item(self.item_def_id).container.id()\n+    }\n+\n+    /// Extracts the underlying trait reference and own substs from this projection.\n+    /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n+    /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n+    pub fn trait_ref_and_own_substs(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n+        let def_id = tcx.associated_item(self.item_def_id).container.id();\n+        let trait_generics = tcx.generics_of(def_id);\n+        (\n+            ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, trait_generics) },\n+            &self.substs[trait_generics.count()..],\n+        )\n+    }\n+\n     /// Extracts the underlying trait reference from this projection.\n     /// For example, if this is a projection of `<T as Iterator>::Item`,\n     /// then this function would return a `T: Iterator` trait reference.\n+    ///\n+    /// WARNING: This will drop the substs for generic associated types\n+    /// consider calling [Self::trait_ref_and_own_substs] to get those\n+    /// as well.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n-        // FIXME: This method probably shouldn't exist at all, since it's not\n-        // clear what this method really intends to do. Be careful when\n-        // using this method since the resulting TraitRef additionally\n-        // contains the substs for the assoc_item, which strictly speaking\n-        // is not correct\n-        let def_id = tcx.associated_item(self.item_def_id).container.id();\n-        // Include substitutions for generic arguments of associated types\n-        let assoc_item = tcx.associated_item(self.item_def_id);\n-        let substs_assoc_item = self.substs.truncate_to(tcx, tcx.generics_of(assoc_item.def_id));\n-        ty::TraitRef { def_id, substs: substs_assoc_item }\n+        let def_id = self.trait_def_id(tcx);\n+        ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, tcx.generics_of(def_id)) }\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {"}, {"sha": "e9aaa65256419773b1b91c922c3184cc18683e3e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -1589,8 +1589,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), vec![], ErrorCode::E0282)\n             }\n             ty::PredicateKind::Projection(data) => {\n-                let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n-                let self_ty = trait_ref.skip_binder().self_ty();\n+                let self_ty = data.projection_ty.self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {\n                     return;"}, {"sha": "fdf5f697e61178910b203811739878a5ad88f265", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -779,14 +779,11 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>> {\n-        let trait_ref = self.projection_ty.trait_ref(interner.tcx);\n+        let (trait_ref, own_substs) = self.projection_ty.trait_ref_and_own_substs(interner.tcx);\n         chalk_solve::rust_ir::AliasEqBound {\n             trait_bound: trait_ref.lower_into(interner),\n             associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n-            parameters: self.projection_ty.substs[trait_ref.substs.len()..]\n-                .iter()\n-                .map(|arg| arg.lower_into(interner))\n-                .collect(),\n+            parameters: own_substs.iter().map(|arg| arg.lower_into(interner)).collect(),\n             value: self.ty.lower_into(interner),\n         }\n     }"}, {"sha": "431e6d70ff35c7815db140bc3275daf8b7977626", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         // Even if we can't infer the full signature, we may be able to\n-        // infer the kind. This can occur if there is a trait-reference\n+        // infer the kind. This can occur when we elaborate a predicate\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n@@ -234,11 +234,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n \n-        let trait_ref = projection.to_poly_trait_ref(tcx);\n+        let trait_def_id = projection.trait_def_id(tcx);\n \n-        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n-        let is_gen = gen_trait == trait_ref.def_id();\n+        let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");\n             return None;\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let input_tys = if is_fn {\n-            let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n+            let arg_param_ty = projection.skip_binder().projection_ty.substs.type_at(1);\n             let arg_param_ty = self.resolve_vars_if_possible(arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n@@ -662,9 +662,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Check that this is a projection from the `Future` trait.\n-        let trait_ref = predicate.projection_ty.trait_ref(self.tcx);\n+        let trait_def_id = predicate.projection_ty.trait_def_id(self.tcx);\n         let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(cause_span));\n-        if trait_ref.def_id != future_trait {\n+        if trait_def_id != future_trait {\n             debug!(\"deduce_future_output_from_projection: not a future\");\n             return None;\n         }"}, {"sha": "75c73e0b67c07d55b46bfbf90f8073957064f410", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -769,9 +769,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .filter_map(move |obligation| {\n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(self.tcx), obligation))\n-                    }\n+                    ty::PredicateKind::Projection(data) => Some((\n+                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n+                        obligation,\n+                    )),\n                     ty::PredicateKind::Trait(data, _) => {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }"}, {"sha": "14d019fa01a74f167ae80207103246fd1d121f2b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -24,6 +24,7 @@ use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n \n use std::cmp::Ordering;\n+use std::iter;\n \n use super::probe::Mode;\n use super::{CandidateSource, MethodError, NoMatchData};\n@@ -649,21 +650,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::PredicateKind::Projection(pred) => {\n                                 let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n-                                let trait_ref =\n-                                    pred.skip_binder().projection_ty.trait_ref(self.tcx);\n-                                let assoc = self\n-                                    .tcx\n-                                    .associated_item(pred.skip_binder().projection_ty.item_def_id);\n-                                let ty = pred.skip_binder().ty;\n-                                let obligation = format!(\"{}::{} = {}\", trait_ref, assoc.ident, ty);\n-                                let quiet = format!(\n-                                    \"<_ as {}>::{} = {}\",\n-                                    trait_ref.print_only_trait_path(),\n-                                    assoc.ident,\n-                                    ty\n+                                let projection_ty = pred.skip_binder().projection_ty;\n+\n+                                let substs_with_infer_self = tcx.mk_substs(\n+                                    iter::once(tcx.mk_ty_var(ty::TyVid { index: 0 }).into())\n+                                        .chain(projection_ty.substs.iter().skip(1)),\n                                 );\n-                                bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n-                                Some((obligation, trait_ref.self_ty()))\n+\n+                                let quiet_projection_ty = ty::ProjectionTy {\n+                                    substs: substs_with_infer_self,\n+                                    item_def_id: projection_ty.item_def_id,\n+                                };\n+\n+                                let ty = pred.skip_binder().ty;\n+\n+                                let obligation = format!(\"{} = {}\", projection_ty, ty);\n+                                let quiet = format!(\"{} = {}\", quiet_projection_ty, ty);\n+\n+                                bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                                Some((obligation, projection_ty.self_ty()))\n                             }\n                             ty::PredicateKind::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.trait_ref;"}, {"sha": "36db3d1bb9e4793da39e538383a55ea570befdc4", "filename": "src/test/ui/generic-associated-types/constraint-assoc-type-suggestion.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -0,0 +1,17 @@\n+// Test that correct syntax is used in suggestion to constrain associated type\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+\n+trait X {\n+    type Y<T>;\n+}\n+\n+fn f<T: X>(a: T::Y<i32>) {\n+    //~^ HELP consider constraining the associated type `<T as X>::Y<i32>` to `Vec<i32>`\n+    //~| SUGGESTION Y<i32> = Vec<i32>>\n+    let b: Vec<i32> = a;\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "ecf559d9e94a1867d2b6a993e049deb76a24c860", "filename": "src/test/ui/generic-associated-types/constraint-assoc-type-suggestion.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/constraint-assoc-type-suggestion.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0308]: mismatched types\n+  --> $DIR/constraint-assoc-type-suggestion.rs:13:23\n+   |\n+LL |     let b: Vec<i32> = a;\n+   |            --------   ^ expected struct `Vec`, found associated type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:       expected struct `Vec<i32>`\n+           found associated type `<T as X>::Y<i32>`\n+help: consider constraining the associated type `<T as X>::Y<i32>` to `Vec<i32>`\n+   |\n+LL | fn f<T: X<Y<i32> = Vec<i32>>>(a: T::Y<i32>) {\n+   |          ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2de4c7b8492a34244977ccc8ec7618220b47ca92", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -0,0 +1,35 @@\n+// Test that the predicate printed in an unresolved method error prints the\n+// generics for a generic associated type.\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+//~| NOTE `#[warn(incomplete_features)]` on by default\n+//~| NOTE see issue #44265\n+\n+trait X {\n+    type Y<T>;\n+}\n+\n+trait M {\n+    fn f(&self) {}\n+}\n+\n+impl<T: X<Y<i32> = i32>> M for T {}\n+\n+struct S;\n+//~^ NOTE method `f` not found for this\n+//~| NOTE doesn't satisfy `<S as X>::Y<i32> = i32`\n+//~| NOTE doesn't satisfy `S: M`\n+\n+impl X for S {\n+    type Y<T> = bool;\n+}\n+\n+fn f(a: S) {\n+    a.f();\n+    //~^ ERROR the method `f` exists for struct `S`, but its trait bounds were not satisfied\n+    //~| NOTE method cannot be called on `S` due to unsatisfied trait bounds\n+    //~| NOTE the following trait bounds were not satisfied:\n+}\n+\n+fn main() {}"}, {"sha": "c94155d13c344a78f3889f4a2d5cf3a645883a4e", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfee89f75545b4fadc559eee324afc8bb0bdc1be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr?ref=dfee89f75545b4fadc559eee324afc8bb0bdc1be", "patch": "@@ -0,0 +1,29 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:4:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0599]: the method `f` exists for struct `S`, but its trait bounds were not satisfied\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:29:7\n+   |\n+LL | struct S;\n+   | ---------\n+   | |\n+   | method `f` not found for this\n+   | doesn't satisfy `<S as X>::Y<i32> = i32`\n+   | doesn't satisfy `S: M`\n+...\n+LL |     a.f();\n+   |       ^ method cannot be called on `S` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `<S as X>::Y<i32> = i32`\n+           which is required by `S: M`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0599`."}]}