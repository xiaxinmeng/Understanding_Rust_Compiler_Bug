{"sha": "e57396bc5212137b95e29664917f4383f8ca123f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NzM5NmJjNTIxMjEzN2I5NWUyOTY2NDkxN2Y0MzgzZjhjYTEyM2Y=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2014-12-25T23:54:44Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2014-12-25T23:54:44Z"}, "message": "Remove namespacing", "tree": {"sha": "47b6aa77bc739d126c33dca6342562cdc8e6cf92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47b6aa77bc739d126c33dca6342562cdc8e6cf92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e57396bc5212137b95e29664917f4383f8ca123f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e57396bc5212137b95e29664917f4383f8ca123f", "html_url": "https://github.com/rust-lang/rust/commit/e57396bc5212137b95e29664917f4383f8ca123f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e57396bc5212137b95e29664917f4383f8ca123f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccf996c348a9b591aad7f0b484dd02ac15a37b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf996c348a9b591aad7f0b484dd02ac15a37b43", "html_url": "https://github.com/rust-lang/rust/commit/ccf996c348a9b591aad7f0b484dd02ac15a37b43"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "3b556ff2c63bd97f30f3fd885f38bfa85fdf1aa2", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e57396bc5212137b95e29664917f4383f8ca123f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57396bc5212137b95e29664917f4383f8ca123f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e57396bc5212137b95e29664917f4383f8ca123f", "patch": "@@ -22,7 +22,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box misc::MiscPass as LintPassObject);\n     reg.register_lint_pass(box misc::StrToStringPass as LintPassObject);\n     reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n-    reg.register_lint_group(\"clippy\", vec![types::CLIPPY_BOX_VEC, types::CLIPPY_DLIST,\n-                                           misc::CLIPPY_SINGLE_MATCH, misc::CLIPPY_STR_TO_STRING,\n-                                           misc::CLIPPY_TOPLEVEL_REF_ARG]);\n+    reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::DLIST,\n+                                           misc::SINGLE_MATCH, misc::STR_TO_STRING,\n+                                           misc::TOPLEVEL_REF_ARG]);\n }"}, {"sha": "d69a7db0f55f243df1f75df27df88aeee0b6f92c", "filename": "src/misc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e57396bc5212137b95e29664917f4383f8ca123f/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57396bc5212137b95e29664917f4383f8ca123f/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=e57396bc5212137b95e29664917f4383f8ca123f", "patch": "@@ -14,12 +14,12 @@ use types::span_note_and_lint;\n pub struct MiscPass;\n \n \n-declare_lint!(pub CLIPPY_SINGLE_MATCH, Warn,\n+declare_lint!(pub SINGLE_MATCH, Warn,\n               \"Warn on usage of matches with a single nontrivial arm\");\n \n impl LintPass for MiscPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CLIPPY_SINGLE_MATCH)\n+        lint_array!(SINGLE_MATCH)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -35,7 +35,7 @@ impl LintPass for MiscPass {\n                     // an enum is extended. So we only consider cases where a `_` wildcard is used\n                     if arms[1].pats[0].node == PatWild(PatWildSingle) && arms[0].pats.len() == 1 {\n                         let map = cx.sess().codemap();\n-                        span_note_and_lint(cx, CLIPPY_SINGLE_MATCH, expr.span,\n+                        span_note_and_lint(cx, SINGLE_MATCH, expr.span,\n                               \"You seem to be trying to use match for destructuring a single type. Did you mean to use `if let`?\",\n                               format!(\"Try if let {} = {} {{ ... }}\",\n                                       map.span_to_snippet(arms[0].pats[0].span).unwrap_or(\"..\".to_string()),\n@@ -49,22 +49,22 @@ impl LintPass for MiscPass {\n }\n \n \n-declare_lint!(pub CLIPPY_STR_TO_STRING, Warn, \"Warn when a String could use into_string() instead of to_string()\");\n+declare_lint!(pub STR_TO_STRING, Warn, \"Warn when a String could use into_string() instead of to_string()\");\n \n #[allow(missing_copy_implementations)]\n pub struct StrToStringPass;\n \n impl LintPass for StrToStringPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CLIPPY_STR_TO_STRING)\n+        lint_array!(STR_TO_STRING)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprMethodCall(ref method, _, ref args)\n                 if method.node.as_str() == \"to_string\"\n                 && is_str(cx, &*args[0]) => {\n-                cx.span_lint(CLIPPY_STR_TO_STRING, expr.span, \"str.into_string() is faster\");\n+                cx.span_lint(STR_TO_STRING, expr.span, \"str.into_string() is faster\");\n             },\n             _ => ()\n         }\n@@ -86,21 +86,21 @@ impl LintPass for StrToStringPass {\n }\n \n \n-declare_lint!(pub CLIPPY_TOPLEVEL_REF_ARG, Warn, \"Warn about pattern matches with top-level `ref` bindings\");\n+declare_lint!(pub TOPLEVEL_REF_ARG, Warn, \"Warn about pattern matches with top-level `ref` bindings\");\n \n #[allow(missing_copy_implementations)]\n pub struct TopLevelRefPass;\n \n impl LintPass for TopLevelRefPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CLIPPY_TOPLEVEL_REF_ARG)\n+        lint_array!(TOPLEVEL_REF_ARG)\n     }\n \n     fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         for ref arg in decl.inputs.iter() {\n             if let PatIdent(BindByRef(_), _, _) = arg.pat.node {\n                 cx.span_lint(\n-                    CLIPPY_TOPLEVEL_REF_ARG,\n+                    TOPLEVEL_REF_ARG,\n                     arg.pat.span,\n                     \"`ref` directly on a function argument is ignored. Have you considered using a reference type instead?\"\n                 );"}, {"sha": "8754c1348b146d96e7546257b9b1709666f9c7d5", "filename": "src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e57396bc5212137b95e29664917f4383f8ca123f/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57396bc5212137b95e29664917f4383f8ca123f/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e57396bc5212137b95e29664917f4383f8ca123f", "patch": "@@ -10,9 +10,9 @@ use syntax::codemap::Span;\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n \n-declare_lint!(pub CLIPPY_BOX_VEC, Warn,\n+declare_lint!(pub BOX_VEC, Warn,\n               \"Warn on usage of Box<Vec<T>>\");\n-declare_lint!(pub CLIPPY_DLIST, Warn,\n+declare_lint!(pub DLIST, Warn,\n               \"Warn on usage of DList\");\n \n /// Matches a type with a provided string, and returns its type parameters if successful\n@@ -48,7 +48,7 @@ pub fn span_note_and_lint(cx: &Context, lint: &'static Lint, span: Span, msg: &s\n \n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CLIPPY_BOX_VEC, CLIPPY_DLIST)\n+        lint_array!(BOX_VEC, DLIST)\n     }\n \n     fn check_ty(&mut self, cx: &Context, ty: &ast::Ty) {\n@@ -60,7 +60,7 @@ impl LintPass for TypePass {\n         match_ty_unwrap(ty, &[\"std\", \"boxed\", \"Box\"]).and_then(|t| t.head())\n           .map(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n           .map(|_| {\n-            span_note_and_lint(cx, CLIPPY_BOX_VEC, ty.span,\n+            span_note_and_lint(cx, BOX_VEC, ty.span,\n                               \"You seem to be trying to use Box<Vec<T>>. Did you mean to use Vec<T>?\",\n                               \"Vec<T> is already on the heap, Box<Vec<T>> makes an extra allocation\");\n           });\n@@ -75,7 +75,7 @@ impl LintPass for TypePass {\n                       vec![\"collections\",\"dlist\",\"DList\"]];\n         for path in dlists.iter() {\n             if match_ty_unwrap(ty, path.as_slice()).is_some() {\n-                span_note_and_lint(cx, CLIPPY_DLIST, ty.span,\n+                span_note_and_lint(cx, DLIST, ty.span,\n                                    \"I see you're using a DList! Perhaps you meant some other data structure?\",\n                                    \"A RingBuf might work.\");\n                 return;"}]}