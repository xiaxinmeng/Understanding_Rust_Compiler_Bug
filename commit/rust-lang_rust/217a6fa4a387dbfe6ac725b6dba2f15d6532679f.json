{"sha": "217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxN2E2ZmE0YTM4N2RiZmU2YWM3MjViNmRiYTJmMTVkNjUzMjY3OWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-05T15:59:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-05T15:59:22Z"}, "message": "Merge #2480\n\n2480: New from sorce infra r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "de4f1deb1cbf454662371e55f5827521ad62b471", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de4f1deb1cbf454662371e55f5827521ad62b471"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6SlaCRBK7hj4Ov3rIwAAdHIIAERbk+lw4m8vYmTSMKn8ObeR\n4N5eL4IRvrl5bQ62YaWS1R2Olk37Ycqski1+6AD2KcOqfdBDcagbMxkXIsA/mT6L\n6Hz9HmTq+y9J4hluDExi/uBrgEq5KjSkLkml0O8wd1Yofr9B+Pzl4pvetEDtOW26\n9PmrSsllrXqkeyDAa1ugag1uS9WXxRrSkfwwX3/JdF0TRaPqJIlgUWZxbuVOrx6Q\nw/LKoLKqHNXi6KAbECqhmkYUqv1ZfxloV7xG93lOZLjYPKn6QJjnd+7Xc8zwm7S+\nKyqnXYHZfxLENZP0d/IV/SDZBSFfmv5uWhLkMp8BTkOjGwqbdg+Ek+EYGbp0XrQ=\n=K7Yr\n-----END PGP SIGNATURE-----\n", "payload": "tree de4f1deb1cbf454662371e55f5827521ad62b471\nparent 4c0bd068da39e74c66104206e27c270454e3562e\nparent 1a567f5ca28b40c1cd744c9123a59695fab351de\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575561562 +0000\ncommitter GitHub <noreply@github.com> 1575561562 +0000\n\nMerge #2480\n\n2480: New from sorce infra r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "html_url": "https://github.com/rust-lang/rust/commit/217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0bd068da39e74c66104206e27c270454e3562e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0bd068da39e74c66104206e27c270454e3562e", "html_url": "https://github.com/rust-lang/rust/commit/4c0bd068da39e74c66104206e27c270454e3562e"}, {"sha": "1a567f5ca28b40c1cd744c9123a59695fab351de", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a567f5ca28b40c1cd744c9123a59695fab351de", "html_url": "https://github.com/rust-lang/rust/commit/1a567f5ca28b40c1cd744c9123a59695fab351de"}], "stats": {"total": 424, "additions": 325, "deletions": 99}, "files": [{"sha": "6fa947759174c7114bbc5aeae3377ca8ff665f82", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 48, "deletions": 99, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "patch": "@@ -1,17 +1,20 @@\n //! FIXME: write short doc here\n+use either::Either;\n \n-use hir_def::{nameres::ModuleSource, AstItemDef, LocationCtx, ModuleId};\n+use hir_def::{\n+    child_from_source::ChildFromSource, nameres::ModuleSource, AstItemDef, EnumVariantId, ImplId,\n+    LocationCtx, ModuleId, TraitId, VariantId,\n+};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    match_ast, AstPtr, SyntaxNode,\n+    match_ast, SyntaxNode,\n };\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n-    InFile, Local, MacroDef, Module, ModuleDef, Static, Struct, StructField, Trait, TypeAlias,\n-    Union, VariantDef,\n+    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, ImplBlock, InFile, Local,\n+    MacroDef, Module, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n pub trait FromSource: Sized {\n@@ -50,98 +53,36 @@ impl FromSource for Trait {\n impl FromSource for Function {\n     type Ast = ast::FnDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::Function(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::Function(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?\n+            .child_from_source(db, src)\n+            .map(Function::from)\n     }\n }\n \n impl FromSource for Const {\n     type Ast = ast::ConstDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::Const(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::Const(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?\n+            .child_from_source(db, src)\n+            .map(Const::from)\n     }\n }\n impl FromSource for Static {\n     type Ast = ast::StaticDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let module = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Module(it) => it,\n-            Container::Trait(_) | Container::ImplBlock(_) => return None,\n-        };\n-        module\n-            .declarations(db)\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                ModuleDef::Static(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Module(it) => it.id.child_from_source(db, src).map(Static::from),\n+            Container::Trait(_) | Container::ImplBlock(_) => None,\n+        }\n     }\n }\n \n impl FromSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n-            Container::Trait(it) => it.items(db),\n-            Container::ImplBlock(it) => it.items(db),\n-            Container::Module(m) => {\n-                return m\n-                    .declarations(db)\n-                    .into_iter()\n-                    .filter_map(|it| match it {\n-                        ModuleDef::TypeAlias(it) => Some(it),\n-                        _ => None,\n-                    })\n-                    .find(|it| same_source(&it.source(db), &src))\n-            }\n-        };\n-        items\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                AssocItem::TypeAlias(it) => Some(it),\n-                _ => None,\n-            })\n-            .find(|it| same_source(&it.source(db), &src))\n+        Container::find(db, src.as_ref().map(|it| it.syntax()))?\n+            .child_from_source(db, src)\n+            .map(TypeAlias::from)\n     }\n }\n \n@@ -174,34 +115,33 @@ impl FromSource for EnumVariant {\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n         let parent_enum = src.value.parent_enum();\n         let src_enum = InFile { file_id: src.file_id, value: parent_enum };\n-        let variants = Enum::from_source(db, src_enum)?.variants(db);\n-        variants.into_iter().find(|v| same_source(&v.source(db), &src))\n+        let parent_enum = Enum::from_source(db, src_enum)?;\n+        parent_enum.id.child_from_source(db, src).map(EnumVariant::from)\n     }\n }\n \n impl FromSource for StructField {\n     type Ast = FieldSource;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: InFile<Self::Ast>) -> Option<Self> {\n-        let variant_def: VariantDef = match src.value {\n+        let variant_id: VariantId = match src.value {\n             FieldSource::Named(ref field) => {\n                 let value = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n                 let src = InFile { file_id: src.file_id, value };\n                 let def = Struct::from_source(db, src)?;\n-                VariantDef::from(def)\n+                def.id.into()\n             }\n             FieldSource::Pos(ref field) => {\n                 let value = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n                 let src = InFile { file_id: src.file_id, value };\n                 let def = EnumVariant::from_source(db, src)?;\n-                VariantDef::from(def)\n+                EnumVariantId::from(def).into()\n             }\n         };\n-        variant_def\n-            .variant_data(db)\n-            .fields()\n-            .iter()\n-            .map(|(id, _)| StructField { parent: variant_def, id })\n-            .find(|f| f.source(db) == src)\n+        let src = src.map(|field_source| match field_source {\n+            FieldSource::Pos(it) => Either::Left(it),\n+            FieldSource::Named(it) => Either::Right(it),\n+        });\n+        variant_id.child_from_source(db, src).map(StructField::from)\n     }\n }\n \n@@ -315,12 +255,21 @@ impl Container {\n     }\n }\n \n-/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n-/// equal if they point to exactly the same object.\n-///\n-/// In general, we do not guarantee that we have exactly one instance of a\n-/// syntax tree for each file. We probably should add such guarantee, but, for\n-/// the time being, we will use identity-less AstPtr comparison.\n-fn same_source<N: AstNode>(s1: &InFile<N>, s2: &InFile<N>) -> bool {\n-    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n+impl<CHILD, SOURCE> ChildFromSource<CHILD, SOURCE> for Container\n+where\n+    TraitId: ChildFromSource<CHILD, SOURCE>,\n+    ImplId: ChildFromSource<CHILD, SOURCE>,\n+    ModuleId: ChildFromSource<CHILD, SOURCE>,\n+{\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<SOURCE>,\n+    ) -> Option<CHILD> {\n+        match self {\n+            Container::Trait(it) => it.id.child_from_source(db, child_source),\n+            Container::ImplBlock(it) => it.id.child_from_source(db, child_source),\n+            Container::Module(it) => it.id.child_from_source(db, child_source),\n+        }\n+    }\n }"}, {"sha": "37d4b787066bc75e9d49194e2be57dab5fb184af", "filename": "crates/ra_hir_def/src/child_from_source.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_from_source.rs?ref=217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "patch": "@@ -0,0 +1,276 @@\n+//! When *constructing* `hir`, we start at some parent syntax node and recursively\n+//! lower the children.\n+//!\n+//! This modules allows one to go in the opposite direction: start with a syntax\n+//! node for a *child*, and get its hir.\n+\n+use either::Either;\n+use hir_expand::InFile;\n+use ra_syntax::{ast, AstNode, AstPtr};\n+\n+use crate::{\n+    db::DefDatabase,\n+    src::{HasChildSource, HasSource},\n+    AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, ImplId, Lookup, ModuleDefId, ModuleId,\n+    StaticId, StructFieldId, TraitId, TypeAliasId, VariantId,\n+};\n+\n+pub trait ChildFromSource<CHILD, SOURCE> {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<SOURCE>,\n+    ) -> Option<CHILD>;\n+}\n+\n+impl ChildFromSource<FunctionId, ast::FnDef> for TraitId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::FnDef>,\n+    ) -> Option<FunctionId> {\n+        let data = db.trait_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|(_, item)| match item {\n+                AssocItemId::FunctionId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<FunctionId, ast::FnDef> for ImplId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::FnDef>,\n+    ) -> Option<FunctionId> {\n+        let data = db.impl_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|item| match item {\n+                AssocItemId::FunctionId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<FunctionId, ast::FnDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::FnDef>,\n+    ) -> Option<FunctionId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::FunctionId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<ConstId, ast::ConstDef> for TraitId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::ConstDef>,\n+    ) -> Option<ConstId> {\n+        let data = db.trait_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|(_, item)| match item {\n+                AssocItemId::ConstId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<ConstId, ast::ConstDef> for ImplId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::ConstDef>,\n+    ) -> Option<ConstId> {\n+        let data = db.impl_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|item| match item {\n+                AssocItemId::ConstId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<ConstId, ast::ConstDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::ConstDef>,\n+    ) -> Option<ConstId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::ConstId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for TraitId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        let data = db.trait_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|(_, item)| match item {\n+                AssocItemId::TypeAliasId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for ImplId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        let data = db.impl_data(*self);\n+        data.items\n+            .iter()\n+            .filter_map(|item| match item {\n+                AssocItemId::TypeAliasId(it) => Some(*it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            })\n+    }\n+}\n+\n+impl ChildFromSource<TypeAliasId, ast::TypeAliasDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::TypeAliasId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<StaticId, ast::StaticDef> for ModuleId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::StaticDef>,\n+    ) -> Option<StaticId> {\n+        let crate_def_map = db.crate_def_map(self.krate);\n+        let res = crate_def_map[self.local_id]\n+            .scope\n+            .declarations()\n+            .filter_map(|item| match item {\n+                ModuleDefId::StaticId(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|func| {\n+                let source = func.lookup(db).source(db);\n+                same_source(&source, &child_source)\n+            });\n+        res\n+    }\n+}\n+\n+impl ChildFromSource<StructFieldId, Either<ast::TupleFieldDef, ast::RecordFieldDef>> for VariantId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n+    ) -> Option<StructFieldId> {\n+        let arena_map = self.child_source(db);\n+        let (local_id, _) = arena_map.as_ref().value.iter().find(|(_local_id, source)| {\n+            child_source.file_id == arena_map.file_id\n+                && match (source, &child_source.value) {\n+                    (Either::Left(a), Either::Left(b)) => AstPtr::new(a) == AstPtr::new(b),\n+                    (Either::Right(a), Either::Right(b)) => AstPtr::new(a) == AstPtr::new(b),\n+                    _ => false,\n+                }\n+        })?;\n+        Some(StructFieldId { parent: *self, local_id })\n+    }\n+}\n+\n+impl ChildFromSource<EnumVariantId, ast::EnumVariant> for EnumId {\n+    fn child_from_source(\n+        &self,\n+        db: &impl DefDatabase,\n+        child_source: InFile<ast::EnumVariant>,\n+    ) -> Option<EnumVariantId> {\n+        let arena_map = self.child_source(db);\n+        let (local_id, _) = arena_map.as_ref().value.iter().find(|(_local_id, source)| {\n+            child_source.file_id == arena_map.file_id\n+                && AstPtr::new(*source) == AstPtr::new(&child_source.value)\n+        })?;\n+        Some(EnumVariantId { parent: *self, local_id })\n+    }\n+}\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guarantee, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+fn same_source<N: AstNode>(s1: &InFile<N>, s2: &InFile<N>) -> bool {\n+    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n+}"}, {"sha": "e02622f62efc3c69923a5805e4c627794b658f0f", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a6fa4a387dbfe6ac725b6dba2f15d6532679f/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=217a6fa4a387dbfe6ac725b6dba2f15d6532679f", "patch": "@@ -30,6 +30,7 @@ mod trace;\n pub mod nameres;\n \n pub mod src;\n+pub mod child_from_source;\n \n #[cfg(test)]\n mod test_db;"}]}