{"sha": "063df5a4823a98c69d47f825d1741da13fe3beed", "node_id": "C_kwDOAAsO6NoAKDA2M2RmNWE0ODIzYTk4YzY5ZDQ3ZjgyNWQxNzQxZGExM2ZlM2JlZWQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-21T08:34:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-21T08:34:51Z"}, "message": "Merge #10301\n\n10301: minor: Merge iter_for_each_to_for and for_to_iter_for_each assists modules r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "38e7e0aac55768e75fe155722aba004f67b84c8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38e7e0aac55768e75fe155722aba004f67b84c8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/063df5a4823a98c69d47f825d1741da13fe3beed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhSZkrCRBK7hj4Ov3rIwAALAIIACTTLKc/HpSfT6iEwDV7bSTf\n8kIxBEsn9qkCts9U2Z58syhEtHA0aFUkGwZ6Qi8r1mkLq25ASox/riidqTxTNcgR\nx4YZ2oAZkP7ZlBYDSyKtbobx52MGyWuvT1NR6lJmRbzUCIBFdVtK/SUkJveHWFxV\n1h6XoCkO1vwuNHMBJ3L0Xo0wvuZNXLlMBpfJGm+EO0ewTzIcQUIRwV7njZUgFbgf\nJJ16IHbPnxoWMQAlMv5Dv1hs0TSggxrYWQE3uaLhVtejNElvingwBvgZe8M4SUpu\nOjNZGpvo2+zcj9qR9tD0PQuBJmEc/cL1MWoFnJcMwS+OfTqmM5INKRvAEahwDMQ=\n=esyh\n-----END PGP SIGNATURE-----\n", "payload": "tree 38e7e0aac55768e75fe155722aba004f67b84c8f\nparent 6a98383fa5fb307f657edf92143608179fab8734\nparent 8b1e8197fe93d8f48ca60df4d6e083cb1b5797ac\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632213291 +0000\ncommitter GitHub <noreply@github.com> 1632213291 +0000\n\nMerge #10301\n\n10301: minor: Merge iter_for_each_to_for and for_to_iter_for_each assists modules r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/063df5a4823a98c69d47f825d1741da13fe3beed", "html_url": "https://github.com/rust-lang/rust/commit/063df5a4823a98c69d47f825d1741da13fe3beed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/063df5a4823a98c69d47f825d1741da13fe3beed/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a98383fa5fb307f657edf92143608179fab8734", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a98383fa5fb307f657edf92143608179fab8734", "html_url": "https://github.com/rust-lang/rust/commit/6a98383fa5fb307f657edf92143608179fab8734"}, {"sha": "8b1e8197fe93d8f48ca60df4d6e083cb1b5797ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b1e8197fe93d8f48ca60df4d6e083cb1b5797ac", "html_url": "https://github.com/rust-lang/rust/commit/8b1e8197fe93d8f48ca60df4d6e083cb1b5797ac"}], "stats": {"total": 802, "additions": 404, "deletions": 398}, "files": [{"sha": "07d4acb15224f76a5c24e0ec915fade9c3cf4bd2", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 361, "deletions": 1, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=063df5a4823a98c69d47f825d1741da13fe3beed", "patch": "@@ -1,6 +1,8 @@\n+use hir::known;\n use ide_db::helpers::FamousDefs;\n+use stdx::format_to;\n use syntax::{\n-    ast::{self, edit_in_place::Indent, make, ArgListOwner},\n+    ast::{self, edit_in_place::Indent, make, ArgListOwner, LoopBodyOwner},\n     AstNode,\n };\n \n@@ -69,6 +71,130 @@ pub(crate) fn convert_iter_for_each_to_for(acc: &mut Assists, ctx: &AssistContex\n     )\n }\n \n+// Assist: convert_for_loop_with_for_each\n+//\n+// Converts a for loop into a for_each loop on the Iterator.\n+//\n+// ```\n+// fn main() {\n+//     let x = vec![1, 2, 3];\n+//     for$0 v in x {\n+//         let y = v * 2;\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let x = vec![1, 2, 3];\n+//     x.into_iter().for_each(|v| {\n+//         let y = v * 2;\n+//     });\n+// }\n+// ```\n+pub(crate) fn convert_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let for_loop = ctx.find_node_at_offset::<ast::ForExpr>()?;\n+    let iterable = for_loop.iterable()?;\n+    let pat = for_loop.pat()?;\n+    let body = for_loop.loop_body()?;\n+    if body.syntax().text_range().start() < ctx.offset() {\n+        cov_mark::hit!(not_available_in_body);\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"convert_for_loop_with_for_each\", AssistKind::RefactorRewrite),\n+        \"Replace this for loop with `Iterator::for_each`\",\n+        for_loop.syntax().text_range(),\n+        |builder| {\n+            let mut buf = String::new();\n+\n+            if let Some((expr_behind_ref, method)) =\n+                is_ref_and_impls_iter_method(&ctx.sema, &iterable)\n+            {\n+                // We have either \"for x in &col\" and col implements a method called iter\n+                //             or \"for x in &mut col\" and col implements a method called iter_mut\n+                format_to!(buf, \"{}.{}()\", expr_behind_ref, method);\n+            } else if let ast::Expr::RangeExpr(..) = iterable {\n+                // range expressions need to be parenthesized for the syntax to be correct\n+                format_to!(buf, \"({})\", iterable);\n+            } else if impls_core_iter(&ctx.sema, &iterable) {\n+                format_to!(buf, \"{}\", iterable);\n+            } else if let ast::Expr::RefExpr(_) = iterable {\n+                format_to!(buf, \"({}).into_iter()\", iterable);\n+            } else {\n+                format_to!(buf, \"{}.into_iter()\", iterable);\n+            }\n+\n+            format_to!(buf, \".for_each(|{}| {});\", pat, body);\n+\n+            builder.replace(for_loop.syntax().text_range(), buf)\n+        },\n+    )\n+}\n+\n+/// If iterable is a reference where the expression behind the reference implements a method\n+/// returning an Iterator called iter or iter_mut (depending on the type of reference) then return\n+/// the expression behind the reference and the method name\n+fn is_ref_and_impls_iter_method(\n+    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    iterable: &ast::Expr,\n+) -> Option<(ast::Expr, hir::Name)> {\n+    let ref_expr = match iterable {\n+        ast::Expr::RefExpr(r) => r,\n+        _ => return None,\n+    };\n+    let wanted_method = if ref_expr.mut_token().is_some() { known::iter_mut } else { known::iter };\n+    let expr_behind_ref = ref_expr.expr()?;\n+    let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n+    let scope = sema.scope(iterable.syntax());\n+    let krate = scope.module()?.krate();\n+    let traits_in_scope = scope.traits_in_scope();\n+    let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n+\n+    let has_wanted_method = ty\n+        .iterate_method_candidates(\n+            sema.db,\n+            krate,\n+            &traits_in_scope,\n+            Some(&wanted_method),\n+            |_, func| {\n+                if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n+                    return Some(());\n+                }\n+                None\n+            },\n+        )\n+        .is_some();\n+    if !has_wanted_method {\n+        return None;\n+    }\n+\n+    Some((expr_behind_ref, wanted_method))\n+}\n+\n+/// Whether iterable implements core::Iterator\n+fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n+    let it_typ = match sema.type_of_expr(iterable) {\n+        Some(it) => it.adjusted(),\n+        None => return false,\n+    };\n+\n+    let module = match sema.scope(iterable.syntax()).module() {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+\n+    let krate = module.krate();\n+    match FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n+        Some(iter_trait) => {\n+            cov_mark::hit!(test_already_impls_iterator);\n+            it_typ.impls_trait(sema.db, iter_trait, &[])\n+        }\n+        None => false,\n+    }\n+}\n+\n fn validate_method_call_expr(\n     ctx: &AssistContext,\n     expr: ast::MethodCallExpr,\n@@ -195,4 +321,238 @@ fn main() {\n }\"#,\n         )\n     }\n+\n+    #[test]\n+    fn each_to_for_not_for() {\n+        check_assist_not_applicable(\n+            convert_for_loop_with_for_each,\n+            r\"\n+let mut x = vec![1, 2, 3];\n+x.iter_mut().$0for_each(|v| *v *= 2);\n+        \",\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_simple_for() {\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    for $0v in x {\n+        v *= 2;\n+    }\n+}\",\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    x.into_iter().for_each(|v| {\n+        v *= 2;\n+    });\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_for_in_range() {\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r#\"\n+//- minicore: range, iterators\n+impl<T> core::iter::Iterator for core::ops::Range<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    for $0x in 0..92 {\n+        print!(\"{}\", x);\n+    }\n+}\"#,\n+            r#\"\n+impl<T> core::iter::Iterator for core::ops::Range<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    (0..92).for_each(|x| {\n+        print!(\"{}\", x);\n+    });\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_not_available_in_body() {\n+        cov_mark::check!(not_available_in_body);\n+        check_assist_not_applicable(\n+            convert_for_loop_with_for_each,\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    for v in x {\n+        $0v *= 2;\n+    }\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_for_borrowed() {\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r#\"\n+//- minicore: iterators\n+use core::iter::{Repeat, repeat};\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Repeat<i32> { repeat(92) }\n+    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n+}\n+\n+fn main() {\n+    let x = S;\n+    for $0v in &x {\n+        let a = v * 2;\n+    }\n+}\n+\"#,\n+            r#\"\n+use core::iter::{Repeat, repeat};\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Repeat<i32> { repeat(92) }\n+    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n+}\n+\n+fn main() {\n+    let x = S;\n+    x.iter().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_for_borrowed_no_iter_method() {\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r\"\n+struct NoIterMethod;\n+fn main() {\n+    let x = NoIterMethod;\n+    for $0v in &x {\n+        let a = v * 2;\n+    }\n+}\n+\",\n+            r\"\n+struct NoIterMethod;\n+fn main() {\n+    let x = NoIterMethod;\n+    (&x).into_iter().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_for_borrowed_mut() {\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r#\"\n+//- minicore: iterators\n+use core::iter::{Repeat, repeat};\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Repeat<i32> { repeat(92) }\n+    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n+}\n+\n+fn main() {\n+    let x = S;\n+    for $0v in &mut x {\n+        let a = v * 2;\n+    }\n+}\n+\"#,\n+            r#\"\n+use core::iter::{Repeat, repeat};\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Repeat<i32> { repeat(92) }\n+    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n+}\n+\n+fn main() {\n+    let x = S;\n+    x.iter_mut().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_for_borrowed_mut_behind_var() {\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    let y = &mut x;\n+    for $0v in y {\n+        *v *= 2;\n+    }\n+}\",\n+            r\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    let y = &mut x;\n+    y.into_iter().for_each(|v| {\n+        *v *= 2;\n+    });\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn each_to_for_already_impls_iterator() {\n+        cov_mark::check!(test_already_impls_iterator);\n+        check_assist(\n+            convert_for_loop_with_for_each,\n+            r#\"\n+//- minicore: iterators\n+fn main() {\n+    for$0 a in core::iter::repeat(92).take(1) {\n+        println!(\"{}\", a);\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    core::iter::repeat(92).take(1).for_each(|a| {\n+        println!(\"{}\", a);\n+    });\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "d7e7c363af622513592bd6a7043acc902524eb0e", "filename": "crates/ide_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=063df5a4823a98c69d47f825d1741da13fe3beed", "patch": "@@ -35,6 +35,10 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n+    if ctx.offset() > guard.syntax().text_range().end() {\n+        cov_mark::hit!(move_guard_unapplicable_in_arm_body);\n+        return None;\n+    }\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n \n     // FIXME: support `if let` guards too\n@@ -155,6 +159,21 @@ mod tests {\n \n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n+    #[test]\n+    fn move_guard_to_arm_body_range() {\n+        cov_mark::check!(move_guard_unapplicable_in_arm_body);\n+        check_assist_not_applicable(\n+            move_guard_to_arm_body,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        x if x > 10 => $0false,\n+        _ => true\n+    }\n+}\n+\"#,\n+        );\n+    }\n     #[test]\n     fn move_guard_to_arm_body_target() {\n         check_assist_target("}, {"sha": "fcf7973bd0ba8ecc1bd8dea8b688a23eeae9022a", "filename": "crates/ide_assists/src/handlers/replace_for_loop_with_for_each.rs", "status": "removed", "additions": 0, "deletions": 372, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/6a98383fa5fb307f657edf92143608179fab8734/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a98383fa5fb307f657edf92143608179fab8734/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs?ref=6a98383fa5fb307f657edf92143608179fab8734", "patch": "@@ -1,372 +0,0 @@\n-use ast::LoopBodyOwner;\n-use hir::known;\n-use ide_db::helpers::FamousDefs;\n-use stdx::format_to;\n-use syntax::{ast, AstNode};\n-\n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n-\n-// Assist: replace_for_loop_with_for_each\n-//\n-// Converts a for loop into a for_each loop on the Iterator.\n-//\n-// ```\n-// fn main() {\n-//     let x = vec![1, 2, 3];\n-//     for$0 v in x {\n-//         let y = v * 2;\n-//     }\n-// }\n-// ```\n-// ->\n-// ```\n-// fn main() {\n-//     let x = vec![1, 2, 3];\n-//     x.into_iter().for_each(|v| {\n-//         let y = v * 2;\n-//     });\n-// }\n-// ```\n-pub(crate) fn replace_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let for_loop = ctx.find_node_at_offset::<ast::ForExpr>()?;\n-    let iterable = for_loop.iterable()?;\n-    let pat = for_loop.pat()?;\n-    let body = for_loop.loop_body()?;\n-    if body.syntax().text_range().start() < ctx.offset() {\n-        cov_mark::hit!(not_available_in_body);\n-        return None;\n-    }\n-\n-    acc.add(\n-        AssistId(\"replace_for_loop_with_for_each\", AssistKind::RefactorRewrite),\n-        \"Replace this for loop with `Iterator::for_each`\",\n-        for_loop.syntax().text_range(),\n-        |builder| {\n-            let mut buf = String::new();\n-\n-            if let Some((expr_behind_ref, method)) =\n-                is_ref_and_impls_iter_method(&ctx.sema, &iterable)\n-            {\n-                // We have either \"for x in &col\" and col implements a method called iter\n-                //             or \"for x in &mut col\" and col implements a method called iter_mut\n-                format_to!(buf, \"{}.{}()\", expr_behind_ref, method);\n-            } else if let ast::Expr::RangeExpr(..) = iterable {\n-                // range expressions need to be parenthesized for the syntax to be correct\n-                format_to!(buf, \"({})\", iterable);\n-            } else if impls_core_iter(&ctx.sema, &iterable) {\n-                format_to!(buf, \"{}\", iterable);\n-            } else if let ast::Expr::RefExpr(_) = iterable {\n-                format_to!(buf, \"({}).into_iter()\", iterable);\n-            } else {\n-                format_to!(buf, \"{}.into_iter()\", iterable);\n-            }\n-\n-            format_to!(buf, \".for_each(|{}| {});\", pat, body);\n-\n-            builder.replace(for_loop.syntax().text_range(), buf)\n-        },\n-    )\n-}\n-\n-/// If iterable is a reference where the expression behind the reference implements a method\n-/// returning an Iterator called iter or iter_mut (depending on the type of reference) then return\n-/// the expression behind the reference and the method name\n-fn is_ref_and_impls_iter_method(\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    iterable: &ast::Expr,\n-) -> Option<(ast::Expr, hir::Name)> {\n-    let ref_expr = match iterable {\n-        ast::Expr::RefExpr(r) => r,\n-        _ => return None,\n-    };\n-    let wanted_method = if ref_expr.mut_token().is_some() { known::iter_mut } else { known::iter };\n-    let expr_behind_ref = ref_expr.expr()?;\n-    let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n-    let scope = sema.scope(iterable.syntax());\n-    let krate = scope.module()?.krate();\n-    let traits_in_scope = scope.traits_in_scope();\n-    let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n-\n-    let has_wanted_method = ty\n-        .iterate_method_candidates(\n-            sema.db,\n-            krate,\n-            &traits_in_scope,\n-            Some(&wanted_method),\n-            |_, func| {\n-                if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n-                    return Some(());\n-                }\n-                None\n-            },\n-        )\n-        .is_some();\n-    if !has_wanted_method {\n-        return None;\n-    }\n-\n-    Some((expr_behind_ref, wanted_method))\n-}\n-\n-/// Whether iterable implements core::Iterator\n-fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n-    let it_typ = match sema.type_of_expr(iterable) {\n-        Some(it) => it.adjusted(),\n-        None => return false,\n-    };\n-\n-    let module = match sema.scope(iterable.syntax()).module() {\n-        Some(it) => it,\n-        None => return false,\n-    };\n-\n-    let krate = module.krate();\n-    match FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n-        Some(iter_trait) => {\n-            cov_mark::hit!(test_already_impls_iterator);\n-            it_typ.impls_trait(sema.db, iter_trait, &[])\n-        }\n-        None => false,\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn test_not_for() {\n-        check_assist_not_applicable(\n-            replace_for_loop_with_for_each,\n-            r\"\n-let mut x = vec![1, 2, 3];\n-x.iter_mut().$0for_each(|v| *v *= 2);\n-        \",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_simple_for() {\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    for $0v in x {\n-        v *= 2;\n-    }\n-}\",\n-            r\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    x.into_iter().for_each(|v| {\n-        v *= 2;\n-    });\n-}\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_for_in_range() {\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r#\"\n-//- minicore: range, iterators\n-impl<T> core::iter::Iterator for core::ops::Range<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n-    }\n-}\n-\n-fn main() {\n-    for $0x in 0..92 {\n-        print!(\"{}\", x);\n-    }\n-}\"#,\n-            r#\"\n-impl<T> core::iter::Iterator for core::ops::Range<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n-    }\n-}\n-\n-fn main() {\n-    (0..92).for_each(|x| {\n-        print!(\"{}\", x);\n-    });\n-}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn not_available_in_body() {\n-        cov_mark::check!(not_available_in_body);\n-        check_assist_not_applicable(\n-            replace_for_loop_with_for_each,\n-            r\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    for v in x {\n-        $0v *= 2;\n-    }\n-}\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_for_borrowed() {\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r#\"\n-//- minicore: iterators\n-use core::iter::{Repeat, repeat};\n-\n-struct S;\n-impl S {\n-    fn iter(&self) -> Repeat<i32> { repeat(92) }\n-    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n-}\n-\n-fn main() {\n-    let x = S;\n-    for $0v in &x {\n-        let a = v * 2;\n-    }\n-}\n-\"#,\n-            r#\"\n-use core::iter::{Repeat, repeat};\n-\n-struct S;\n-impl S {\n-    fn iter(&self) -> Repeat<i32> { repeat(92) }\n-    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n-}\n-\n-fn main() {\n-    let x = S;\n-    x.iter().for_each(|v| {\n-        let a = v * 2;\n-    });\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_for_borrowed_no_iter_method() {\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r\"\n-struct NoIterMethod;\n-fn main() {\n-    let x = NoIterMethod;\n-    for $0v in &x {\n-        let a = v * 2;\n-    }\n-}\n-\",\n-            r\"\n-struct NoIterMethod;\n-fn main() {\n-    let x = NoIterMethod;\n-    (&x).into_iter().for_each(|v| {\n-        let a = v * 2;\n-    });\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_for_borrowed_mut() {\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r#\"\n-//- minicore: iterators\n-use core::iter::{Repeat, repeat};\n-\n-struct S;\n-impl S {\n-    fn iter(&self) -> Repeat<i32> { repeat(92) }\n-    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n-}\n-\n-fn main() {\n-    let x = S;\n-    for $0v in &mut x {\n-        let a = v * 2;\n-    }\n-}\n-\"#,\n-            r#\"\n-use core::iter::{Repeat, repeat};\n-\n-struct S;\n-impl S {\n-    fn iter(&self) -> Repeat<i32> { repeat(92) }\n-    fn iter_mut(&mut self) -> Repeat<i32> { repeat(92) }\n-}\n-\n-fn main() {\n-    let x = S;\n-    x.iter_mut().for_each(|v| {\n-        let a = v * 2;\n-    });\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_for_borrowed_mut_behind_var() {\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    let y = &mut x;\n-    for $0v in y {\n-        *v *= 2;\n-    }\n-}\",\n-            r\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    let y = &mut x;\n-    y.into_iter().for_each(|v| {\n-        *v *= 2;\n-    });\n-}\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_already_impls_iterator() {\n-        cov_mark::check!(test_already_impls_iterator);\n-        check_assist(\n-            replace_for_loop_with_for_each,\n-            r#\"\n-//- minicore: iterators\n-fn main() {\n-    for$0 a in core::iter::repeat(92).take(1) {\n-        println!(\"{}\", a);\n-    }\n-}\n-\"#,\n-            r#\"\n-fn main() {\n-    core::iter::repeat(92).take(1).for_each(|a| {\n-        println!(\"{}\", a);\n-    });\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "b2c8cd76941b405e34507471edbec72360ebd068", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=063df5a4823a98c69d47f825d1741da13fe3beed", "patch": "@@ -162,7 +162,6 @@ mod handlers {\n     mod reorder_fields;\n     mod reorder_impl;\n     mod replace_derive_with_manual_impl;\n-    mod replace_for_loop_with_for_each;\n     mod replace_if_let_with_match;\n     mod introduce_named_generic;\n     mod replace_let_with_if_let;\n@@ -192,6 +191,7 @@ mod handlers {\n             convert_integer_literal::convert_integer_literal,\n             convert_into_to_from::convert_into_to_from,\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n+            convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_while_to_loop::convert_while_to_loop,\n@@ -237,7 +237,6 @@ mod handlers {\n             reorder_fields::reorder_fields,\n             reorder_impl::reorder_impl,\n             replace_derive_with_manual_impl::replace_derive_with_manual_impl,\n-            replace_for_loop_with_for_each::replace_for_loop_with_for_each,\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_if_let_with_match::replace_match_with_if_let,\n             replace_let_with_if_let::replace_let_with_if_let,"}, {"sha": "95a68ca9893e67688636495bafe353a266cfaaeb", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063df5a4823a98c69d47f825d1741da13fe3beed/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=063df5a4823a98c69d47f825d1741da13fe3beed", "patch": "@@ -252,6 +252,29 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_for_loop_with_for_each() {\n+    check_doc_test(\n+        \"convert_for_loop_with_for_each\",\n+        r#####\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    for$0 v in x {\n+        let y = v * 2;\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    x.into_iter().for_each(|v| {\n+        let y = v * 2;\n+    });\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_if_to_bool_then() {\n     check_doc_test(\n@@ -1490,29 +1513,6 @@ impl Debug for S {\n     )\n }\n \n-#[test]\n-fn doctest_replace_for_loop_with_for_each() {\n-    check_doc_test(\n-        \"replace_for_loop_with_for_each\",\n-        r#####\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    for$0 v in x {\n-        let y = v * 2;\n-    }\n-}\n-\"#####,\n-        r#####\"\n-fn main() {\n-    let x = vec![1, 2, 3];\n-    x.into_iter().for_each(|v| {\n-        let y = v * 2;\n-    });\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_replace_if_let_with_match() {\n     check_doc_test("}]}