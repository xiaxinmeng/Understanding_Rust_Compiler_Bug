{"sha": "a5249289519300553d183ef9fa3844b947015e77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MjQ5Mjg5NTE5MzAwNTUzZDE4M2VmOWZhMzg0NGI5NDcwMTVlNzc=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-24T12:08:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-24T14:26:31Z"}, "message": "Document TrieSet and TrieMap methods.", "tree": {"sha": "562a9f4a75153630ac2e1b8ea3c269efeb6f2332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/562a9f4a75153630ac2e1b8ea3c269efeb6f2332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5249289519300553d183ef9fa3844b947015e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5249289519300553d183ef9fa3844b947015e77", "html_url": "https://github.com/rust-lang/rust/commit/a5249289519300553d183ef9fa3844b947015e77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5249289519300553d183ef9fa3844b947015e77/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237738fa3ea266fb33f5a0c774347bf73bb20825", "url": "https://api.github.com/repos/rust-lang/rust/commits/237738fa3ea266fb33f5a0c774347bf73bb20825", "html_url": "https://github.com/rust-lang/rust/commit/237738fa3ea266fb33f5a0c774347bf73bb20825"}], "stats": {"total": 207, "additions": 191, "deletions": 16}, "files": [{"sha": "fd0e0971b15eb507d2eac25af53d101e9e28174d", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 191, "deletions": 16, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/a5249289519300553d183ef9fa3844b947015e77/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5249289519300553d183ef9fa3844b947015e77/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=a5249289519300553d183ef9fa3844b947015e77", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Ordered containers with integer keys, implemented as radix tries (`TrieSet` and `TrieMap` types)\n+//! Ordered containers with unsigned integer keys,\n+//! implemented as radix tries (`TrieSet` and `TrieMap` types).\n \n use core::prelude::*;\n \n@@ -35,7 +36,7 @@ enum Child<T> {\n     Nothing\n }\n \n-#[allow(missing_doc)]\n+/// A map as a radix trie.\n pub struct TrieMap<T> {\n     root: TrieNode<T>,\n     length: uint\n@@ -51,7 +52,7 @@ impl<T: PartialEq> PartialEq for TrieMap<T> {\n impl<T: Eq> Eq for TrieMap<T> {}\n \n impl<T> Collection for TrieMap<T> {\n-    /// Return the number of elements in the map\n+    /// Return the number of elements in the map.\n     #[inline]\n     fn len(&self) -> uint { self.length }\n }\n@@ -66,7 +67,7 @@ impl<T> Mutable for TrieMap<T> {\n }\n \n impl<T> Map<uint, T> for TrieMap<T> {\n-    /// Return a reference to the value corresponding to the key\n+    /// Return a reference to the value corresponding to the key.\n     #[inline]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n@@ -89,7 +90,7 @@ impl<T> Map<uint, T> for TrieMap<T> {\n }\n \n impl<T> MutableMap<uint, T> for TrieMap<T> {\n-    /// Return a mutable reference to the value corresponding to the key\n+    /// Return a mutable reference to the value corresponding to the key.\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n@@ -122,19 +123,54 @@ impl<T> Default for TrieMap<T> {\n }\n \n impl<T> TrieMap<T> {\n-    /// Create an empty TrieMap\n+    /// Create an empty TrieMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<&str> = TrieMap::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n-    /// Visit all key-value pairs in reverse order\n+    /// Visit all key-value pairs in reverse order. Abort traversal when f returns false.\n+    /// Return true if f returns true for all elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(true, map.each_reverse(|&key, &value| { vec.push((key, value)); true }));\n+    /// assert_eq!(vec, vec![(3, \"c\"), (2, \"b\"), (1, \"a\")]);\n+    ///\n+    /// // Stop when we reach 2\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(false, map.each_reverse(|&key, &value| { vec.push(value); key != 2 }));\n+    /// assert_eq!(vec, vec![\"c\", \"b\"]);\n+    /// ```\n     #[inline]\n     pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n-    /// Get an iterator over the key-value pairs in the map\n+    /// Get an iterator over the key-value pairs in the map, ordered by keys.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(3, \"c\"), (1, \"a\"), (2, \"b\")].iter().map(|&x| x).collect();\n+    ///\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Entries<'a, T> {\n         let mut iter = unsafe {Entries::new()};\n         iter.stack[0] = self.root.children.iter();\n@@ -147,6 +183,21 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<int> = [(1, 2), (2, 4), (3, 6)].iter().map(|&x| x).collect();\n+    ///\n+    /// for (key, value) in map.mut_iter() {\n+    ///     *value = -(key as int);\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&1), Some(&-1));\n+    /// assert_eq!(map.find(&2), Some(&-2));\n+    /// assert_eq!(map.find(&3), Some(&-3));\n+    /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> {\n         let mut iter = unsafe {MutEntries::new()};\n         iter.stack[0] = self.root.children.mut_iter();\n@@ -255,12 +306,34 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.lower_bound(4).next(), Some((4, &\"b\")));\n+    /// assert_eq!(map.lower_bound(5).next(), Some((6, &\"c\")));\n+    /// assert_eq!(map.lower_bound(10).next(), None);\n+    /// ```\n     pub fn lower_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n         self.bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.upper_bound(4).next(), Some((6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(5).next(), Some((6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(10).next(), None);\n+    /// ```\n     pub fn upper_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n         self.bound(key, true)\n     }\n@@ -275,12 +348,50 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.mut_lower_bound(4).next(), Some((4, &mut \"b\")));\n+    /// assert_eq!(map.mut_lower_bound(5).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.mut_lower_bound(10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_lower_bound(4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.mut_bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.mut_upper_bound(4).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(5).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_upper_bound(4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"b\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.mut_bound(key, true)\n     }\n@@ -310,14 +421,14 @@ impl<S: Writer, T: Hash<S>> Hash<S> for TrieMap<T> {\n     }\n }\n \n-#[allow(missing_doc)]\n+/// A set as a radix trie.\n #[deriving(Hash, PartialEq, Eq)]\n pub struct TrieSet {\n     map: TrieMap<()>\n }\n \n impl Collection for TrieSet {\n-    /// Return the number of elements in the set\n+    /// Return the number of elements in the set.\n     #[inline]\n     fn len(&self) -> uint { self.map.len() }\n }\n@@ -368,32 +479,96 @@ impl Default for TrieSet {\n }\n \n impl TrieSet {\n-    /// Create an empty TrieSet\n+    /// Create an empty TrieSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    /// let mut set = TrieSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n-    /// Visit all values in reverse order\n+    /// Visit all values in reverse order. Abort traversal when `f` returns false.\n+    /// Return `true` if `f` returns `true` for all elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n+    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n+    ///\n+    /// // Stop when we reach 3\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n+    /// assert_eq!(vec, vec![5, 4, 3]);\n+    /// ```\n     #[inline]\n     pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n         self.map.each_reverse(|k, _| f(k))\n     }\n \n-    /// Get an iterator over the values in the set\n+    /// Get an iterator over the values in the set, in sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    /// set.insert(3);\n+    /// set.insert(2);\n+    /// set.insert(1);\n+    /// set.insert(2);\n+    ///\n+    /// // Print 1, 2, 3\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> SetItems<'a> {\n         SetItems{iter: self.map.iter()}\n     }\n \n     /// Get an iterator pointing to the first value that is not less than `val`.\n     /// If all values in the set are less than `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n+    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n+    /// assert_eq!(set.lower_bound(10).next(), None);\n+    /// ```\n     pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n         SetItems{iter: self.map.lower_bound(val)}\n     }\n \n     /// Get an iterator pointing to the first value that key is greater than `val`.\n-    /// If all values in the set are not greater than `val` an empty iterator is returned.\n+    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(10).next(), None);\n+    /// ```\n     pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n         SetItems{iter: self.map.upper_bound(val)}\n     }\n@@ -526,7 +701,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n     return ret;\n }\n \n-/// Forward iterator over a map\n+/// Forward iterator over a map.\n pub struct Entries<'a, T> {\n     stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n     length: uint,\n@@ -660,7 +835,7 @@ macro_rules! iterator_impl {\n iterator_impl! { Entries, iter = iter, mutability = }\n iterator_impl! { MutEntries, iter = mut_iter, mutability = mut }\n \n-/// Forward iterator over a set\n+/// Forward iterator over a set.\n pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n }"}]}