{"sha": "e6908a66ecabaca6e7adf4e847afe228f5d9f257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2OTA4YTY2ZWNhYmFjYTZlN2FkZjRlODQ3YWZlMjI4ZjVkOWYyNTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-16T19:11:48Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-16T19:12:45Z"}, "message": "rustc: Infer the types of type-parametric functions", "tree": {"sha": "f1fd99a9410bf19e70dc795fe041f904ead38ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1fd99a9410bf19e70dc795fe041f904ead38ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6908a66ecabaca6e7adf4e847afe228f5d9f257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6908a66ecabaca6e7adf4e847afe228f5d9f257", "html_url": "https://github.com/rust-lang/rust/commit/e6908a66ecabaca6e7adf4e847afe228f5d9f257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6908a66ecabaca6e7adf4e847afe228f5d9f257/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9759d1e08ad288f84a262257242bfd167d2492e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9759d1e08ad288f84a262257242bfd167d2492e8", "html_url": "https://github.com/rust-lang/rust/commit/9759d1e08ad288f84a262257242bfd167d2492e8"}], "stats": {"total": 76, "additions": 76, "deletions": 0}, "files": [{"sha": "332c893e8414dda21c427f67a444426d6fdfbe99", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e6908a66ecabaca6e7adf4e847afe228f5d9f257/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6908a66ecabaca6e7adf4e847afe228f5d9f257/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e6908a66ecabaca6e7adf4e847afe228f5d9f257", "patch": "@@ -259,6 +259,79 @@ fn ty_to_str(&@ty typ) -> str {\n     ret s;\n }\n \n+// Replaces parameter types inside a type with type variables.\n+fn generalize_ty(@crate_ctxt cx, @ty t) -> @ty {\n+    fn rewrap(@ty orig, &sty new) -> @ty {\n+        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n+    }\n+\n+    fn recur(@crate_ctxt cx, @ty t,\n+             &hashmap[ast.def_id,@ty] ty_params_to_ty_vars) -> @ty {\n+        alt (t.struct) {\n+            case (ty_box(?subty)) {\n+                auto new_subty = recur(cx, subty, ty_params_to_ty_vars);\n+                ret rewrap(t, ty_box(new_subty));\n+            }\n+            case (ty_vec(?subty)) {\n+                auto new_subty = recur(cx, subty, ty_params_to_ty_vars);\n+                ret rewrap(t, ty_vec(new_subty));\n+            }\n+            case (ty_tup(?subtys)) {\n+                let vec[@ty] new_subtys = vec();\n+                for (@ty subty in subtys) {\n+                    new_subtys += vec(recur(cx, subty, ty_params_to_ty_vars));\n+                }\n+                ret rewrap(t, ty_tup(new_subtys));\n+            }\n+            case (ty_rec(?fields)) {\n+                let vec[field] new_fields = vec();\n+                for (field fld in fields) {\n+                    auto new_ty = recur(cx, fld.ty, ty_params_to_ty_vars);\n+                    new_fields += vec(rec(ident=fld.ident, ty=new_ty));\n+                }\n+                ret rewrap(t, ty_rec(new_fields));\n+            }\n+            case (ty_fn(?args, ?ret_ty)) {\n+                let vec[arg] new_args = vec();\n+                for (arg a in args) {\n+                    auto new_ty = recur(cx, a.ty, ty_params_to_ty_vars);\n+                    new_args += vec(rec(mode=a.mode, ty=new_ty));\n+                }\n+                auto new_ret_ty = recur(cx, ret_ty, ty_params_to_ty_vars);\n+                ret rewrap(t, ty_fn(new_args, new_ret_ty));\n+            }\n+            case (ty_obj(?methods)) {\n+                let vec[method] new_methods = vec();\n+                for (method m in methods) {\n+                    let vec[arg] new_args = vec();\n+                    for (arg a in m.inputs) {\n+                        auto new_ty = recur(cx, a.ty, ty_params_to_ty_vars);\n+                        new_args += vec(rec(mode=a.mode, ty=new_ty));\n+                    }\n+                    auto new_rty = recur(cx, m.output, ty_params_to_ty_vars);\n+                    new_methods += vec(rec(ident=m.ident, inputs=new_args,\n+                                           output=new_rty));\n+                }\n+                ret rewrap(t, ty_obj(new_methods));\n+            }\n+            case (ty_param(?pid)) {\n+                if (ty_params_to_ty_vars.contains_key(pid)) {\n+                    ret ty_params_to_ty_vars.get(pid);\n+                }\n+                auto var_ty = next_ty_var(cx);\n+                ty_params_to_ty_vars.insert(pid, var_ty);\n+                ret var_ty;\n+            }\n+            case (_) { /* fall through */ }\n+        }\n+\n+        ret t;\n+    }\n+\n+    auto ty_params_to_ty_vars = common.new_def_hash[@ty]();\n+    ret recur(cx, t, ty_params_to_ty_vars);\n+}\n+\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n@@ -1720,6 +1793,9 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     fail;\n                 }\n             }\n+\n+            t = generalize_ty(fcx.ccx, t); \n+\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_name(name, defopt,\n                                                       ast.ann_type(t)));"}]}