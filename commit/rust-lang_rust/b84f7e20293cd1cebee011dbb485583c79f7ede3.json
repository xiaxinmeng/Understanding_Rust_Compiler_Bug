{"sha": "b84f7e20293cd1cebee011dbb485583c79f7ede3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NGY3ZTIwMjkzY2QxY2ViZWUwMTFkYmI0ODU1ODNjNzlmN2VkZTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-16T09:21:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-16T16:35:27Z"}, "message": "add Borrow tag to pointers; remove old locking code", "tree": {"sha": "bdf7f025dee9318dac8500309ba8624218c75499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdf7f025dee9318dac8500309ba8624218c75499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b84f7e20293cd1cebee011dbb485583c79f7ede3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b84f7e20293cd1cebee011dbb485583c79f7ede3", "html_url": "https://github.com/rust-lang/rust/commit/b84f7e20293cd1cebee011dbb485583c79f7ede3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b84f7e20293cd1cebee011dbb485583c79f7ede3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ed191d28f5e8e92254ba58d79ed09dd04b7f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ed191d28f5e8e92254ba58d79ed09dd04b7f92", "html_url": "https://github.com/rust-lang/rust/commit/38ed191d28f5e8e92254ba58d79ed09dd04b7f92"}], "stats": {"total": 290, "additions": 119, "deletions": 171}, "files": [{"sha": "280cc2bdea589451f95fcc526590e6ac4653fd44", "filename": "src/fn_call.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -14,8 +14,8 @@ pub trait EvalContextExt<'tcx, 'mir> {\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n         ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n@@ -28,28 +28,28 @@ pub trait EvalContextExt<'tcx, 'mir> {\n     fn emulate_missing_fn(\n         &mut self,\n         path: String,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx>;\n \n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx>;\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n@@ -108,8 +108,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n         ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n         let attrs = self.tcx.get_attrs(def_id);\n@@ -675,8 +675,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n     fn emulate_missing_fn(\n         &mut self,\n         path: String,\n-        _args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        _args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx> {\n         // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n@@ -724,7 +724,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n         Ok(())\n     }\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx> {\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx> {\n         self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n }"}, {"sha": "de787145e22c76328b140011c74a1825aa9625d9", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -7,7 +7,7 @@ pub trait FalibleScalarExt {\n     fn to_bytes(self) -> EvalResult<'static, u128>;\n }\n \n-impl FalibleScalarExt for Scalar {\n+impl<Tag> FalibleScalarExt for Scalar<Tag> {\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -19,7 +19,7 @@ impl FalibleScalarExt for Scalar {\n     }\n }\n \n-impl FalibleScalarExt for ScalarMaybeUndef {\n+impl<Tag> FalibleScalarExt for ScalarMaybeUndef<Tag> {\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         self.not_undef()?.to_bytes()\n     }"}, {"sha": "11c0bd7907c150de7fd9b8bc51e05ee4ffb0b6f5", "filename": "src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -6,25 +6,25 @@ use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n use rustc_mir::interpret::{EvalContext, PlaceTy, OpTy};\n \n use super::{\n-    Value, Scalar, ScalarMaybeUndef,\n+    Value, Scalar, ScalarMaybeUndef, Borrow,\n     FalibleScalarExt, OperatorEvalContextExt\n };\n \n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         if self.emulate_intrinsic(instance, args, dest)? {\n             return Ok(());"}, {"sha": "9ac703e2675b1c7da368f886df8090b2f0a3f047", "filename": "src/lib.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -21,11 +21,9 @@ use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n-use syntax::ast::Mutability;\n use syntax::attr;\n \n \n-pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n pub use rustc_mir::interpret::{self, AllocMap}; // resolve ambiguity\n \n@@ -34,9 +32,9 @@ mod operator;\n mod intrinsic;\n mod helpers;\n mod tls;\n-mod locks;\n mod range_map;\n mod mono_hash_map;\n+mod stacked_borrows;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n@@ -45,6 +43,7 @@ use tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n use mono_hash_map::MonoHashMap;\n+use stacked_borrows::Borrow;\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -56,7 +55,6 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(validate),\n-        Default::default(),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n@@ -118,9 +116,9 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let foo = ecx.memory.allocate_static_bytes(b\"foo\\0\");\n         let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n         let foo_layout = ecx.layout_of(foo_ty)?;\n-        let foo_place = ecx.allocate(foo_layout, MemoryKind::Stack)?; // will be interned in just a second\n+        let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n         ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-        ecx.memory.intern_static(foo_place.to_ptr()?.alloc_id, Mutability::Immutable)?;\n+        ecx.memory.mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n         ecx.write_scalar(foo_place.ptr, dest)?;\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n@@ -227,7 +225,7 @@ impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Borrow>>,\n \n     /// TLS state\n     pub(crate) tls: TlsData<'tcx>,\n@@ -247,11 +245,11 @@ impl<'tcx> Evaluator<'tcx> {\n }\n \n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryData = ();\n     type MemoryKinds = MiriMemoryKind;\n-    type PointerTag = (); // still WIP\n+    type AllocExtra = ();\n+    type PointerTag = Borrow;\n \n-    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<()>)>;\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Borrow, Self::AllocExtra>)>;\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n \n@@ -282,8 +280,8 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         ecx.find_fn(instance, args, dest, ret)\n@@ -292,26 +290,26 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn call_intrinsic(\n         ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n     fn ptr_op(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Borrow>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Borrow>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n         ecx.ptr_op(bin_op, left, left_layout, right, right_layout)\n     }\n \n     fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx>,\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n         // Call the `exchange_malloc` lang item\n@@ -351,7 +349,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Borrow, Self::AllocExtra>>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             Some(name) => name.as_str(),\n@@ -371,16 +369,6 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(Cow::Owned(alloc))\n     }\n \n-    fn validation_op(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _op: ::rustc::mir::ValidationOp,\n-        _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n-    ) -> EvalResult<'tcx> {\n-        // FIXME: prevent this from ICEing\n-        //ecx.validation_op(op, operand)\n-        Ok(())\n-    }\n-\n     fn before_terminator(_ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>\n     {\n         // We are not interested in detecting loops\n@@ -389,8 +377,19 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     fn static_with_default_tag(\n         alloc: &'_ Allocation\n-    ) -> Cow<'_, Allocation<Self::PointerTag>> {\n-        let alloc = alloc.clone();\n+    ) -> Cow<'_, Allocation<Borrow, Self::AllocExtra>> {\n+        let alloc: Allocation<Borrow, Self::AllocExtra> = Allocation {\n+            bytes: alloc.bytes.clone(),\n+            relocations: Relocations::from_presorted(\n+                alloc.relocations.iter()\n+                    .map(|&(offset, ((), alloc))| (offset, (Borrow::default(), alloc)))\n+                    .collect()\n+            ),\n+            undef_mask: alloc.undef_mask.clone(),\n+            align: alloc.align,\n+            mutability: alloc.mutability,\n+            extra: Self::AllocExtra::default(),\n+        };\n         Cow::Owned(alloc)\n     }\n }"}, {"sha": "a87ff6367e3ad89c398360e87013b3d994586d22", "filename": "src/locks.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/38ed191d28f5e8e92254ba58d79ed09dd04b7f92/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ed191d28f5e8e92254ba58d79ed09dd04b7f92/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=38ed191d28f5e8e92254ba58d79ed09dd04b7f92", "patch": "@@ -1,94 +0,0 @@\n-#![allow(unused)]\n-\n-use super::*;\n-use rustc::middle::region;\n-use rustc::ty::layout::Size;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Locks\n-////////////////////////////////////////////////////////////////////////////////\n-\n-// Just some dummy to keep this compiling; I think some of this will be useful later\n-type AbsPlace<'tcx> = ::rustc::ty::Ty<'tcx>;\n-\n-/// Information about a lock that is currently held.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct LockInfo<'tcx> {\n-    /// Stores for which lifetimes (of the original write lock) we got\n-    /// which suspensions.\n-    suspended: HashMap<WriteLockId<'tcx>, Vec<region::Scope>>,\n-    /// The current state of the lock that's actually effective.\n-    pub active: Lock,\n-}\n-\n-/// Write locks are identified by a stack frame and an \"abstract\" (untyped) place.\n-/// It may be tempting to use the lifetime as identifier, but that does not work\n-/// for two reasons:\n-/// * First of all, due to subtyping, the same lock may be referred to with different\n-///   lifetimes.\n-/// * Secondly, different write locks may actually have the same lifetime.  See `test2`\n-///   in `run-pass/many_shr_bor.rs`.\n-/// The Id is \"captured\" when the lock is first suspended; at that point, the borrow checker\n-/// considers the path frozen and hence the Id remains stable.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct WriteLockId<'tcx> {\n-    frame: usize,\n-    path: AbsPlace<'tcx>,\n-}\n-\n-\n-use rustc::mir::interpret::Lock::*;\n-use rustc::mir::interpret::Lock;\n-\n-impl<'tcx> Default for LockInfo<'tcx> {\n-    fn default() -> Self {\n-        LockInfo::new(NoLock)\n-    }\n-}\n-\n-impl<'tcx> LockInfo<'tcx> {\n-    fn new(lock: Lock) -> LockInfo<'tcx> {\n-        LockInfo {\n-            suspended: HashMap::new(),\n-            active: lock,\n-        }\n-    }\n-\n-    fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n-        use super::AccessKind::*;\n-        match (&self.active, access) {\n-            (&NoLock, _) => true,\n-            (&ReadLock(ref lfts), Read) => {\n-                assert!(!lfts.is_empty(), \"Someone left an empty read lock behind.\");\n-                // Read access to read-locked region is okay, no matter who's holding the read lock.\n-                true\n-            }\n-            (&WriteLock(ref lft), _) => {\n-                // All access is okay if we are the ones holding it\n-                Some(lft.frame) == frame\n-            }\n-            _ => false, // Nothing else is okay.\n-        }\n-    }\n-}\n-\n-impl<'tcx> RangeMap<LockInfo<'tcx>> {\n-    pub fn check(\n-        &self,\n-        frame: Option<usize>,\n-        offset: u64,\n-        len: u64,\n-        access: AccessKind,\n-    ) -> Result<(), LockInfo<'tcx>> {\n-        if len == 0 {\n-            return Ok(());\n-        }\n-        for lock in self.iter(offset, len) {\n-            // Check if the lock is in conflict with the access.\n-            if !lock.access_permitted(frame, access) {\n-                return Err(lock.clone());\n-            }\n-        }\n-        Ok(())\n-    }\n-}"}, {"sha": "dd79f293134f150ec2d3fe0737c0932c01d2b349", "filename": "src/operator.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -7,44 +7,44 @@ pub trait EvalContextExt<'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Borrow>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Borrow>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n+        left: Pointer<Borrow>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)>;\n \n     fn ptr_eq(\n         &self,\n-        left: Scalar,\n-        right: Scalar,\n+        left: Scalar<Borrow>,\n+        right: Scalar<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx, bool>;\n \n     fn pointer_offset_inbounds(\n         &self,\n-        ptr: Scalar,\n+        ptr: Scalar<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar>;\n+    ) -> EvalResult<'tcx, Scalar<Borrow>>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Borrow>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Borrow>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", left, bin_op, right);\n@@ -124,8 +124,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n     fn ptr_eq(\n         &self,\n-        left: Scalar,\n-        right: Scalar,\n+        left: Scalar<Borrow>,\n+        right: Scalar<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx, bool> {\n         Ok(match (left, right) {\n@@ -203,13 +203,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n+        left: Pointer<Borrow>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over): (Pointer, bool)) -> (Scalar, bool) {\n+        fn map_to_primval((res, over): (Pointer<Borrow>, bool)) -> (Scalar<Borrow>, bool) {\n             (Scalar::Ptr(res), over)\n         }\n \n@@ -237,7 +237,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n                     let offset = (left.offset.bytes() as u128 & right) as u64;\n-                    (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(offset))), false)\n+                    (\n+                        Scalar::Ptr(Pointer::new_with_tag(\n+                            left.alloc_id,\n+                            Size::from_bytes(offset),\n+                            left.tag,\n+                        )),\n+                        false,\n+                    )\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n                     (Scalar::Bits { bits: (left.offset.bytes() as u128) & right, size: ptr_size }, false)\n@@ -277,10 +284,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     /// allocation.\n     fn pointer_offset_inbounds(\n         &self,\n-        ptr: Scalar,\n+        ptr: Scalar<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset.checked_mul(pointee_size).ok_or_else(|| EvalErrorKind::Overflow(mir::BinOp::Mul))?;"}, {"sha": "dd9f1b370890d85cbe21d23a1d8ecd14e05fa629", "filename": "src/stacked_borrows.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -0,0 +1,36 @@\n+use super::RangeMap;\n+\n+pub type Timestamp = u64;\n+\n+/// Information about a potentially mutable borrow\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Mut {\n+  /// A unique, mutable reference\n+  Uniq(Timestamp),\n+  /// Any raw pointer, or a shared borrow with interior mutability\n+  Raw,\n+}\n+\n+/// Information about any kind of borrow\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Borrow {\n+  /// A mutable borrow, a raw pointer, or a shared borrow with interior mutability\n+  Mut(Mut),\n+  /// A shared borrow without interior mutability\n+  Frz(Timestamp)\n+}\n+\n+/// An item in the borrow stack\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum BorStackItem {\n+  /// Defines which references are permitted to mutate *if* the location is not frozen\n+  Mut(Mut),\n+  /// A barrier, tracking the function it belongs to by its index on the call stack\n+  FnBarrier(usize)\n+}\n+\n+impl Default for Borrow {\n+    fn default() -> Self {\n+        Borrow::Mut(Mut::Raw)\n+    }\n+}"}, {"sha": "c5d119ec7f5bffde232dec7a329df54f44d89c05", "filename": "src/tls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84f7e20293cd1cebee011dbb485583c79f7ede3/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=b84f7e20293cd1cebee011dbb485583c79f7ede3", "patch": "@@ -5,14 +5,14 @@ use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n use super::{\n     EvalResult, EvalErrorKind, StackPopCleanup, EvalContext, Evaluator,\n-    MPlaceTy, Scalar,\n+    MPlaceTy, Scalar, Borrow,\n };\n \n pub type TlsKey = u128;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct TlsEntry<'tcx> {\n-    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) data: Scalar<Borrow>, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n     pub(crate) dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -67,7 +67,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n+    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar<Borrow>> {\n         match self.keys.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -77,7 +77,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n+    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Borrow>) -> EvalResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -110,7 +110,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: Option<TlsKey>,\n         cx: impl HasDataLayout,\n-    ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)> {\n+    ) -> Option<(ty::Instance<'tcx>, Scalar<Borrow>, TlsKey)> {\n         use std::collections::Bound::*;\n \n         let thread_local = &mut self.keys;"}]}