{"sha": "96064eb61dc703c289fae61bdf90593d3e7b2449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MDY0ZWI2MWRjNzAzYzI4OWZhZTYxYmRmOTA1OTNkM2U3YjI0NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T18:49:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T18:49:46Z"}, "message": "Auto merge of #54487 - RalfJung:ctfe-backtrace, r=oli-obk\n\nDelayed CTFE backtraces\n\nThis renames the env var that controls CTFE backtraces from `MIRI_BACKTRACE` to `RUST_CTFE_BACKTRACE` so that we can use `MIRI_BACKTRACE` in the miri tool to only show backtraces of the main miri execution.\n\nIt also makes `RUST_CTFE_BACKTRACE` only show backtraces that actually get rendered as errors, instead of showing them eagerly when the `Err` happens. The current behavior is near useless in miri because it shows about one gazillion backtraces for errors that we later catch and do not care about. However, @oli-obk likes the current behavior for rustc CTFE work so it is still available via `RUST_CTFE_BACKTRACE=immediate`.\n\nNOTE: This is based on top of https://github.com/rust-lang/rust/pull/53821. Only [the last three commits](https://github.com/oli-obk/rust/compare/sanity_query...RalfJung:ctfe-backtrace) are new.\n\nFixes https://github.com/rust-lang/rust/issues/53355", "tree": {"sha": "6c3428593dbec23a6ccf36984d478f154c17e6cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c3428593dbec23a6ccf36984d478f154c17e6cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96064eb61dc703c289fae61bdf90593d3e7b2449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96064eb61dc703c289fae61bdf90593d3e7b2449", "html_url": "https://github.com/rust-lang/rust/commit/96064eb61dc703c289fae61bdf90593d3e7b2449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96064eb61dc703c289fae61bdf90593d3e7b2449/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d492c6792c4fa24fb542bf457667f45b55b7c093", "url": "https://api.github.com/repos/rust-lang/rust/commits/d492c6792c4fa24fb542bf457667f45b55b7c093", "html_url": "https://github.com/rust-lang/rust/commit/d492c6792c4fa24fb542bf457667f45b55b7c093"}, {"sha": "5903fdb28184d465c01cd6247d0e8ce0c4128211", "url": "https://api.github.com/repos/rust-lang/rust/commits/5903fdb28184d465c01cd6247d0e8ce0c4128211", "html_url": "https://github.com/rust-lang/rust/commit/5903fdb28184d465c01cd6247d0e8ce0c4128211"}], "stats": {"total": 240, "additions": 88, "deletions": 152}, "files": [{"sha": "8f837327ddb151d5dbf2891fa8c7f0abeb8f83a9", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=96064eb61dc703c289fae61bdf90593d3e7b2449", "patch": "@@ -597,48 +597,6 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n                 required.hash_stable(hcx, hasher);\n                 has.hash_stable(hcx, hasher)\n             },\n-            MemoryLockViolation {\n-                ptr,\n-                len,\n-                frame,\n-                access,\n-                ref lock,\n-            } =>  {\n-                ptr.hash_stable(hcx, hasher);\n-                len.hash_stable(hcx, hasher);\n-                frame.hash_stable(hcx, hasher);\n-                access.hash_stable(hcx, hasher);\n-                lock.hash_stable(hcx, hasher)\n-            },\n-            MemoryAcquireConflict {\n-                ptr,\n-                len,\n-                kind,\n-                ref lock,\n-            } =>  {\n-                ptr.hash_stable(hcx, hasher);\n-                len.hash_stable(hcx, hasher);\n-                kind.hash_stable(hcx, hasher);\n-                lock.hash_stable(hcx, hasher)\n-            },\n-            InvalidMemoryLockRelease {\n-                ptr,\n-                len,\n-                frame,\n-                ref lock,\n-            } =>  {\n-                ptr.hash_stable(hcx, hasher);\n-                len.hash_stable(hcx, hasher);\n-                frame.hash_stable(hcx, hasher);\n-                lock.hash_stable(hcx, hasher)\n-            },\n-            DeallocatedLockedMemory {\n-                ptr,\n-                ref lock,\n-            } => {\n-                ptr.hash_stable(hcx, hasher);\n-                lock.hash_stable(hcx, hasher)\n-            },\n             ValidationFailure(ref s) => s.hash_stable(hcx, hasher),\n             TypeNotPrimitive(ty) => ty.hash_stable(hcx, hasher),\n             ReallocatedWrongMemoryKind(ref a, ref b) => {"}, {"sha": "8e025f0d029b72f41237e1b1a5f6a6133c3fbd54", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 67, "deletions": 86, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=96064eb61dc703c289fae61bdf90593d3e7b2449", "patch": "@@ -15,9 +15,7 @@ use ty::{Ty, layout};\n use ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n-use super::{\n-    Pointer, Lock, AccessKind\n-};\n+use super::Pointer;\n \n use backtrace::Backtrace;\n \n@@ -53,7 +51,7 @@ pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub error: ::mir::interpret::EvalError<'tcx>,\n+    pub error: ::mir::interpret::EvalErrorKind<'tcx, u64>,\n     pub stacktrace: Vec<FrameInfo>,\n }\n \n@@ -112,7 +110,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         message: &str,\n         lint_root: Option<ast::NodeId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n-        match self.error.kind {\n+        match self.error {\n             EvalErrorKind::Layout(LayoutError::Unknown(_)) |\n             EvalErrorKind::TooGeneric => return Err(ErrorHandled::TooGeneric),\n             EvalErrorKind::Layout(LayoutError::SizeOverflow(_)) |\n@@ -151,50 +149,74 @@ pub fn struct_error<'a, 'gcx, 'tcx>(\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n \n-#[derive(Debug, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Clone)]\n pub struct EvalError<'tcx> {\n     pub kind: EvalErrorKind<'tcx, u64>,\n+    pub backtrace: Option<Box<Backtrace>>,\n+}\n+\n+impl<'tcx> EvalError<'tcx> {\n+    pub fn print_backtrace(&mut self) {\n+        if let Some(ref mut backtrace) = self.backtrace {\n+            eprintln!(\"{}\", print_backtrace(&mut *backtrace));\n+        }\n+    }\n+}\n+\n+fn print_backtrace(backtrace: &mut Backtrace) -> String {\n+    use std::fmt::Write;\n+\n+    backtrace.resolve();\n+\n+    let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n+    write!(trace_text, \"backtrace frames: {}\\n\", backtrace.frames().len()).unwrap();\n+    'frames: for (i, frame) in backtrace.frames().iter().enumerate() {\n+        if frame.symbols().is_empty() {\n+            write!(trace_text, \"{}: no symbols\\n\", i).unwrap();\n+        }\n+        for symbol in frame.symbols() {\n+            write!(trace_text, \"{}: \", i).unwrap();\n+            if let Some(name) = symbol.name() {\n+                write!(trace_text, \"{}\\n\", name).unwrap();\n+            } else {\n+                write!(trace_text, \"<unknown>\\n\").unwrap();\n+            }\n+            write!(trace_text, \"\\tat \").unwrap();\n+            if let Some(file_path) = symbol.filename() {\n+                write!(trace_text, \"{}\", file_path.display()).unwrap();\n+            } else {\n+                write!(trace_text, \"<unknown_file>\").unwrap();\n+            }\n+            if let Some(line) = symbol.lineno() {\n+                write!(trace_text, \":{}\\n\", line).unwrap();\n+            } else {\n+                write!(trace_text, \"\\n\").unwrap();\n+            }\n+        }\n+    }\n+    trace_text\n }\n \n impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n     fn from(kind: EvalErrorKind<'tcx, u64>) -> Self {\n-        match env::var(\"MIRI_BACKTRACE\") {\n-            Ok(ref val) if !val.is_empty() => {\n-                let backtrace = Backtrace::new();\n+        let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n+            // matching RUST_BACKTRACE, we treat \"0\" the same as \"not present\".\n+            Ok(ref val) if val != \"0\" => {\n+                let mut backtrace = Backtrace::new_unresolved();\n \n-                use std::fmt::Write;\n-                let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n-                write!(trace_text, \"backtrace frames: {}\\n\", backtrace.frames().len()).unwrap();\n-                'frames: for (i, frame) in backtrace.frames().iter().enumerate() {\n-                    if frame.symbols().is_empty() {\n-                        write!(trace_text, \"{}: no symbols\\n\", i).unwrap();\n-                    }\n-                    for symbol in frame.symbols() {\n-                        write!(trace_text, \"{}: \", i).unwrap();\n-                        if let Some(name) = symbol.name() {\n-                            write!(trace_text, \"{}\\n\", name).unwrap();\n-                        } else {\n-                            write!(trace_text, \"<unknown>\\n\").unwrap();\n-                        }\n-                        write!(trace_text, \"\\tat \").unwrap();\n-                        if let Some(file_path) = symbol.filename() {\n-                            write!(trace_text, \"{}\", file_path.display()).unwrap();\n-                        } else {\n-                            write!(trace_text, \"<unknown_file>\").unwrap();\n-                        }\n-                        if let Some(line) = symbol.lineno() {\n-                            write!(trace_text, \":{}\\n\", line).unwrap();\n-                        } else {\n-                            write!(trace_text, \"\\n\").unwrap();\n-                        }\n-                    }\n+                if val == \"immediate\" {\n+                    // Print it now\n+                    eprintln!(\"{}\", print_backtrace(&mut backtrace));\n+                    None\n+                } else {\n+                    Some(Box::new(backtrace))\n                 }\n-                error!(\"{}\", trace_text);\n             },\n-            _ => {},\n-        }\n+            _ => None,\n+        };\n         EvalError {\n             kind,\n+            backtrace,\n         }\n     }\n }\n@@ -250,29 +272,6 @@ pub enum EvalErrorKind<'tcx, O> {\n         required: Align,\n         has: Align,\n     },\n-    MemoryLockViolation {\n-        ptr: Pointer,\n-        len: u64,\n-        frame: usize,\n-        access: AccessKind,\n-        lock: Lock,\n-    },\n-    MemoryAcquireConflict {\n-        ptr: Pointer,\n-        len: u64,\n-        kind: AccessKind,\n-        lock: Lock,\n-    },\n-    InvalidMemoryLockRelease {\n-        ptr: Pointer,\n-        len: u64,\n-        frame: usize,\n-        lock: Lock,\n-    },\n-    DeallocatedLockedMemory {\n-        ptr: Pointer,\n-        lock: Lock,\n-    },\n     ValidationFailure(String),\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n@@ -336,16 +335,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n                 \"pointer offset outside bounds of allocation\",\n             InvalidNullPointerUsage =>\n                 \"invalid use of NULL pointer\",\n-            MemoryLockViolation { .. } =>\n-                \"memory access conflicts with lock\",\n-            MemoryAcquireConflict { .. } =>\n-                \"new memory lock conflicts with existing lock\",\n             ValidationFailure(..) =>\n                 \"type validation failed\",\n-            InvalidMemoryLockRelease { .. } =>\n-                \"invalid attempt to release write lock\",\n-            DeallocatedLockedMemory { .. } =>\n-                \"tried to deallocate memory in conflict with a lock\",\n             ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             ReadBytesAsPointer =>\n@@ -452,7 +443,13 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.kind)\n+        write!(f, \"{}\", self.kind)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for EvalErrorKind<'tcx, u64> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self)\n     }\n }\n \n@@ -465,22 +462,6 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                        if access { \"memory access\" } else { \"pointer computed\" },\n                        ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n-            MemoryLockViolation { ptr, len, frame, access, ref lock } => {\n-                write!(f, \"{:?} access by frame {} at {:?}, size {}, is in conflict with lock {:?}\",\n-                       access, frame, ptr, len, lock)\n-            }\n-            MemoryAcquireConflict { ptr, len, kind, ref lock } => {\n-                write!(f, \"new {:?} lock at {:?}, size {}, is in conflict with lock {:?}\",\n-                       kind, ptr, len, lock)\n-            }\n-            InvalidMemoryLockRelease { ptr, len, frame, ref lock } => {\n-                write!(f, \"frame {} tried to release memory write lock at {:?}, size {}, but \\\n-                       cannot release lock {:?}\", frame, ptr, len, lock)\n-            }\n-            DeallocatedLockedMemory { ptr, ref lock } => {\n-                write!(f, \"tried to deallocate memory at {:?} in conflict with lock {:?}\",\n-                       ptr, lock)\n-            }\n             ValidationFailure(ref err) => {\n                 write!(f, \"type validation failed: {}\", err)\n             }"}, {"sha": "73cb203809419a3d313d384285a010508ba4ff6e", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=96064eb61dc703c289fae61bdf90593d3e7b2449", "patch": "@@ -513,8 +513,7 @@ pub fn const_field<'a, 'tcx>(\n         op_to_const(&ecx, field, true)\n     })();\n     result.map_err(|error| {\n-        let stacktrace = ecx.generate_stacktrace(None);\n-        let err = ::rustc::mir::interpret::ConstEvalErr { error, stacktrace, span: ecx.tcx.span };\n+        let err = error_to_const_error(&ecx, error);\n         err.report_as_error(ecx.tcx, \"could not access field of constant\");\n         ErrorHandled::Reported\n     })\n@@ -532,6 +531,15 @@ pub fn const_variant_index<'a, 'tcx>(\n     Ok(ecx.read_discriminant(op)?.1)\n }\n \n+pub fn error_to_const_error<'a, 'mir, 'tcx>(\n+    ecx: &EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    mut error: EvalError<'tcx>\n+) -> ConstEvalErr<'tcx> {\n+    error.print_backtrace();\n+    let stacktrace = ecx.generate_stacktrace(None);\n+    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+}\n+\n fn validate_const<'a, 'tcx>(\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     constant: &'tcx ty::Const<'tcx>,\n@@ -554,8 +562,7 @@ fn validate_const<'a, 'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let stacktrace = ecx.generate_stacktrace(None);\n-        let err = ::rustc::mir::interpret::ConstEvalErr { error, stacktrace, span: ecx.tcx.span };\n+        let err = error_to_const_error(&ecx, error);\n         match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n             Ok(mut diag) => {\n                 diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n@@ -654,8 +661,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n         }\n         op_to_const(&ecx, op, normalize)\n     }).map_err(|error| {\n-        let stacktrace = ecx.generate_stacktrace(None);\n-        let err = ConstEvalErr { error, stacktrace, span: ecx.tcx.span };\n+        let err = error_to_const_error(&ecx, error);\n         // errors in statics are always emitted as fatal errors\n         if tcx.is_static(def_id).is_some() {\n             let err = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n@@ -685,7 +691,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // any other kind of error will be reported to the user as a deny-by-default lint\n                 _ => if let Some(p) = cid.promoted {\n                     let span = tcx.optimized_mir(def_id).promoted[p].span;\n-                    if let EvalErrorKind::ReferencedConstant = err.error.kind {\n+                    if let EvalErrorKind::ReferencedConstant = err.error {\n                         err.report_as_error(\n                             tcx.at(span),\n                             \"evaluation of constant expression failed\","}, {"sha": "8ee009db023f0beb304ebedb23e43130aa31b587", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96064eb61dc703c289fae61bdf90593d3e7b2449/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=96064eb61dc703c289fae61bdf90593d3e7b2449", "patch": "@@ -17,13 +17,8 @@ use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n-use rustc::mir::interpret::{\n-    ConstEvalErr, EvalErrorKind, Scalar, GlobalId, EvalResult,\n-};\n+use rustc::mir::interpret::{EvalErrorKind, Scalar, GlobalId, EvalResult};\n use rustc::ty::{TyCtxt, self, Instance};\n-use interpret::{self, EvalContext, Value, OpTy, MemoryKind, ScalarMaybeUndef};\n-use const_eval::{CompileTimeInterpreter, eval_promoted, mk_borrowck_eval_cx};\n-use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -33,6 +28,10 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n+use interpret::{self, EvalContext, ScalarMaybeUndef, Value, OpTy, MemoryKind};\n+use const_eval::{CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx};\n+use transform::{MirPass, MirSource};\n+\n pub struct ConstProp;\n \n impl MirPass for ConstProp {\n@@ -154,10 +153,9 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                let stacktrace = self.ecx.generate_stacktrace(None);\n-                let diagnostic = ConstEvalErr { span: source_info.span, error, stacktrace };\n+                let diagnostic = error_to_const_error(&self.ecx, error);\n                 use rustc::mir::interpret::EvalErrorKind::*;\n-                match diagnostic.error.kind {\n+                match diagnostic.error {\n                     // don't report these, they make no sense in a const prop context\n                     | MachineError(_)\n                     // at runtime these transformations might make sense\n@@ -185,11 +183,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     | InvalidDiscriminant(..)\n                     | PointerOutOfBounds { .. }\n                     | InvalidNullPointerUsage\n-                    | MemoryLockViolation { .. }\n-                    | MemoryAcquireConflict { .. }\n                     | ValidationFailure(..)\n-                    | InvalidMemoryLockRelease { .. }\n-                    | DeallocatedLockedMemory { .. }\n                     | InvalidPointerMath\n                     | ReadUndefBytes(_)\n                     | DeadLocal\n@@ -273,10 +267,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 Some((op, c.span))\n             },\n             Err(error) => {\n-                let stacktrace = self.ecx.generate_stacktrace(None);\n-                let err = ::rustc::mir::interpret::ConstEvalErr {\n-                    error, stacktrace, span: source_info.span,\n-                };\n+                let err = error_to_const_error(&self.ecx, error);\n                 err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n                 None\n             },"}]}