{"sha": "14caf00c92b40e3f62094db54f325196c8a05d5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0Y2FmMDBjOTJiNDBlM2Y2MjA5NGRiNTRmMzI1MTk2YzhhMDVkNWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-14T00:56:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:53Z"}, "message": "rustuv: Write homing tests with SchedPool\n\nUse the previous commit's new scheduler pool abstraction in libgreen to write\nsome homing tests which force an I/O handle to be homed from one event loop to\nanother.", "tree": {"sha": "0b44af85b516274a99d19098eb7506a9d92ca4ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b44af85b516274a99d19098eb7506a9d92ca4ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14caf00c92b40e3f62094db54f325196c8a05d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14caf00c92b40e3f62094db54f325196c8a05d5a", "html_url": "https://github.com/rust-lang/rust/commit/14caf00c92b40e3f62094db54f325196c8a05d5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14caf00c92b40e3f62094db54f325196c8a05d5a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3893716390f2c4857b7e8b1705a6344f96b85bb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3893716390f2c4857b7e8b1705a6344f96b85bb6", "html_url": "https://github.com/rust-lang/rust/commit/3893716390f2c4857b7e8b1705a6344f96b85bb6"}], "stats": {"total": 230, "additions": 84, "deletions": 146}, "files": [{"sha": "9a3f27f7dbc4c2ab0af6d169ed87fd40a7a245a3", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=14caf00c92b40e3f62094db54f325196c8a05d5a", "patch": "@@ -35,7 +35,6 @@ use std::os;\n use std::rt::thread::Thread;\n use std::rt;\n use std::rt::crate_map;\n-use std::rt::task::Task;\n use std::rt::rtio;\n use std::sync::deque;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n@@ -105,32 +104,32 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n /// This function will not return until all schedulers in the associated pool\n /// have returned.\n pub fn run(main: proc()) -> int {\n-    let mut pool = Pool::new(Config::new());\n+    let mut pool = SchedPool::new(PoolConfig::new());\n     pool.spawn(TaskOpts::new(), main);\n     unsafe { stdtask::wait_for_completion(); }\n     pool.shutdown();\n     os::get_exit_status()\n }\n \n /// Configuration of how an M:N pool of schedulers is spawned.\n-pub struct Config {\n+pub struct PoolConfig {\n     /// The number of schedulers (OS threads) to spawn into this M:N pool.\n     threads: uint,\n }\n \n-impl Config {\n+impl PoolConfig {\n     /// Returns the default configuration, as determined the the environment\n     /// variables of this process.\n-    pub fn new() -> Config {\n-        Config {\n+    pub fn new() -> PoolConfig {\n+        PoolConfig {\n             threads: rt::default_sched_threads(),\n         }\n     }\n }\n \n /// A structure representing a handle to a pool of schedulers. This handle is\n /// used to keep the pool alive and also reap the status from the pool.\n-pub struct Pool {\n+pub struct SchedPool {\n     priv id: uint,\n     priv threads: ~[Thread<()>],\n     priv handles: ~[SchedHandle],\n@@ -141,19 +140,19 @@ pub struct Pool {\n     priv sleepers: SleeperList,\n }\n \n-impl Pool {\n+impl SchedPool {\n     /// Execute the main function in a pool of M:N schedulers.\n     ///\n     /// This will configure the pool according to the `config` parameter, and\n     /// initially run `main` inside the pool of schedulers.\n-    pub fn new(config: Config) -> Pool {\n+    pub fn new(config: PoolConfig) -> SchedPool {\n         static mut POOL_ID: AtomicUint = INIT_ATOMIC_UINT;\n \n-        let Config { threads: nscheds } = config;\n+        let PoolConfig { threads: nscheds } = config;\n         assert!(nscheds > 0);\n \n         // The pool of schedulers that will be returned from this function\n-        let mut pool = Pool {\n+        let mut pool = SchedPool {\n             threads: ~[],\n             handles: ~[],\n             stealers: ~[],\n@@ -185,30 +184,22 @@ impl Pool {\n             let sched = sched;\n             pool.threads.push(do Thread::start {\n                 let mut sched = sched;\n-                let mut task = do GreenTask::new(&mut sched.stack_pool, None) {\n+                let task = do GreenTask::new(&mut sched.stack_pool, None) {\n                     rtdebug!(\"boostraping a non-primary scheduler\");\n                 };\n-                task.put_task(~Task::new());\n                 sched.bootstrap(task);\n             });\n         }\n \n         return pool;\n     }\n \n-    pub fn shutdown(mut self) {\n-        self.stealers = ~[];\n-\n-        for mut handle in util::replace(&mut self.handles, ~[]).move_iter() {\n-            handle.send(Shutdown);\n-        }\n-        for thread in util::replace(&mut self.threads, ~[]).move_iter() {\n-            thread.join();\n-        }\n+    pub fn task(&mut self, opts: TaskOpts, f: proc()) -> ~GreenTask {\n+        GreenTask::configure(&mut self.stack_pool, opts, f)\n     }\n \n     pub fn spawn(&mut self, opts: TaskOpts, f: proc()) {\n-        let task = GreenTask::configure(&mut self.stack_pool, opts, f);\n+        let task = self.task(opts, f);\n \n         // Figure out someone to send this task to\n         let idx = self.next_friend;\n@@ -250,18 +241,28 @@ impl Pool {\n         let sched = sched;\n         self.threads.push(do Thread::start {\n             let mut sched = sched;\n-            let mut task = do GreenTask::new(&mut sched.stack_pool, None) {\n+            let task = do GreenTask::new(&mut sched.stack_pool, None) {\n                 rtdebug!(\"boostraping a non-primary scheduler\");\n             };\n-            task.put_task(~Task::new());\n             sched.bootstrap(task);\n         });\n \n         return ret;\n     }\n+\n+    pub fn shutdown(mut self) {\n+        self.stealers = ~[];\n+\n+        for mut handle in util::replace(&mut self.handles, ~[]).move_iter() {\n+            handle.send(Shutdown);\n+        }\n+        for thread in util::replace(&mut self.threads, ~[]).move_iter() {\n+            thread.join();\n+        }\n+    }\n }\n \n-impl Drop for Pool {\n+impl Drop for SchedPool {\n     fn drop(&mut self) {\n         if self.threads.len() > 0 {\n             fail!(\"dropping a M:N scheduler pool that wasn't shut down\");"}, {"sha": "70fd6768c8baa7ea1f21e8620138ccf55bb613cc", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=14caf00c92b40e3f62094db54f325196c8a05d5a", "patch": "@@ -178,9 +178,8 @@ impl Scheduler {\n         self.idle_callback = Some(self.event_loop.pausable_idle_callback(cb));\n \n         // Create a task for the scheduler with an empty context.\n-        let mut sched_task = GreenTask::new_typed(Some(Coroutine::empty()),\n-                                                  TypeSched);\n-        sched_task.put_task(~Task::new());\n+        let sched_task = GreenTask::new_typed(Some(Coroutine::empty()),\n+                                              TypeSched);\n \n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is"}, {"sha": "d37ab8bba57d94e08aec3a063e9f573986c8652b", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=14caf00c92b40e3f62094db54f325196c8a05d5a", "patch": "@@ -85,7 +85,7 @@ impl GreenTask {\n             sched: None,\n             handle: None,\n             nasty_deschedule_lock: unsafe { Mutex::new() },\n-            task: None,\n+            task: Some(~Task::new()),\n         }\n     }\n \n@@ -101,16 +101,17 @@ impl GreenTask {\n         } = opts;\n \n         let mut green = GreenTask::new(pool, stack_size, f);\n-        let mut task = ~Task::new();\n-        task.name = name;\n-        match notify_chan {\n-            Some(chan) => {\n-                let on_exit = proc(task_result) { chan.send(task_result) };\n-                task.death.on_exit = Some(on_exit);\n+        {\n+            let task = green.task.get_mut_ref();\n+            task.name = name;\n+            match notify_chan {\n+                Some(chan) => {\n+                    let on_exit = proc(task_result) { chan.send(task_result) };\n+                    task.death.on_exit = Some(on_exit);\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n-        green.put_task(task);\n         return green;\n     }\n "}, {"sha": "1f9e3831e205711b5c4639af5fe28ca0e7578541", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 45, "deletions": 108, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14caf00c92b40e3f62094db54f325196c8a05d5a/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=14caf00c92b40e3f62094db54f325196c8a05d5a", "patch": "@@ -145,121 +145,58 @@ impl Drop for HomingMissile {\n \n #[cfg(test)]\n mod test {\n+    use green::sched;\n+    use green::{SchedPool, PoolConfig};\n+    use std::rt::rtio::RtioUdpSocket;\n+    use std::io::test::next_test_ip4;\n+    use std::task::TaskOpts;\n+\n+    use net::UdpWatcher;\n+    use super::super::local_loop;\n+\n     // On one thread, create a udp socket. Then send that socket to another\n     // thread and destroy the socket on the remote thread. This should make sure\n     // that homing kicks in for the socket to go back home to the original\n     // thread, close itself, and then come back to the last thread.\n-    //#[test]\n-    //fn test_homing_closes_correctly() {\n-    //    let (port, chan) = Chan::new();\n-\n-    //    do task::spawn_sched(task::SingleThreaded) {\n-    //        let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n-    //        chan.send(listener);\n-    //    }\n-\n-    //    do task::spawn_sched(task::SingleThreaded) {\n-    //        port.recv();\n-    //    }\n-    //}\n-\n-    // This is a bit of a crufty old test, but it has its uses.\n-    //#[test]\n-    //fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n-    //    use std::cast;\n-    //    use std::rt::local::Local;\n-    //    use std::rt::rtio::{EventLoop, IoFactory};\n-    //    use std::rt::sched::Scheduler;\n-    //    use std::rt::sched::{Shutdown, TaskFromFriend};\n-    //    use std::rt::sleeper_list::SleeperList;\n-    //    use std::rt::task::Task;\n-    //    use std::rt::task::UnwindResult;\n-    //    use std::rt::thread::Thread;\n-    //    use std::rt::deque::BufferPool;\n-    //    use std::unstable::run_in_bare_thread;\n-    //    use uvio::UvEventLoop;\n-\n-    //    do run_in_bare_thread {\n-    //        let sleepers = SleeperList::new();\n-    //        let mut pool = BufferPool::new();\n-    //        let (worker1, stealer1) = pool.deque();\n-    //        let (worker2, stealer2) = pool.deque();\n-    //        let queues = ~[stealer1, stealer2];\n-\n-    //        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-    //        let mut sched1 = ~Scheduler::new(loop1, worker1, queues.clone(),\n-    //                                         sleepers.clone());\n-    //        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-    //        let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n-    //                                         sleepers.clone());\n-\n-    //        let handle1 = sched1.make_handle();\n-    //        let handle2 = sched2.make_handle();\n-    //        let tasksFriendHandle = sched2.make_handle();\n-\n-    //        let on_exit: proc(UnwindResult) = proc(exit_status) {\n-    //            let mut handle1 = handle1;\n-    //            let mut handle2 = handle2;\n-    //            handle1.send(Shutdown);\n-    //            handle2.send(Shutdown);\n-    //            assert!(exit_status.is_success());\n-    //        };\n-\n-    //        unsafe fn local_io() -> &'static mut IoFactory {\n-    //            let mut sched = Local::borrow(None::<Scheduler>);\n-    //            let io = sched.get().event_loop.io();\n-    //            cast::transmute(io.unwrap())\n-    //        }\n-\n-    //        let test_function: proc() = proc() {\n-    //            let io = unsafe { local_io() };\n-    //            let addr = next_test_ip4();\n-    //            let maybe_socket = io.udp_bind(addr);\n-    //            // this socket is bound to this event loop\n-    //            assert!(maybe_socket.is_ok());\n-\n-    //            // block self on sched1\n-    //            let scheduler: ~Scheduler = Local::take();\n-    //            let mut tasksFriendHandle = Some(tasksFriendHandle);\n-    //            scheduler.deschedule_running_task_and_then(|_, task| {\n-    //                // unblock task\n-    //                task.wake().map(|task| {\n-    //                    // send self to sched2\n-    //                    tasksFriendHandle.take_unwrap()\n-    //                                     .send(TaskFromFriend(task));\n-    //                });\n-    //                // sched1 should now sleep since it has nothing else to do\n-    //            })\n-    //            // sched2 will wake up and get the task as we do nothing else,\n-    //            // the function ends and the socket goes out of scope sched2\n-    //            // will start to run the destructor the destructor will first\n-    //            // block the task, set it's home as sched1, then enqueue it\n-    //            // sched2 will dequeue the task, see that it has a home, and\n-    //            // send it to sched1 sched1 will wake up, exec the close\n-    //            // function on the correct loop, and then we're done\n-    //        };\n+    #[test]\n+    fn test_homing_closes_correctly() {\n+        let (port, chan) = Chan::new();\n+        let mut pool = SchedPool::new(PoolConfig { threads: 1 });\n+\n+        do pool.spawn(TaskOpts::new()) {\n+            let listener = UdpWatcher::bind(local_loop(), next_test_ip4());\n+            chan.send(listener.unwrap());\n+        }\n \n-    //        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n-    //                                            test_function);\n-    //        main_task.death.on_exit = Some(on_exit);\n+        let task = do pool.task(TaskOpts::new()) {\n+            port.recv();\n+        };\n+        pool.spawn_sched().send(sched::TaskFromFriend(task));\n \n-    //        let null_task = ~do Task::new_root(&mut sched2.stack_pool, None) {\n-    //            // nothing\n-    //        };\n+        pool.shutdown();\n+    }\n \n-    //        let main_task = main_task;\n-    //        let sched1 = sched1;\n-    //        let thread1 = do Thread::start {\n-    //            sched1.bootstrap(main_task);\n-    //        };\n+    #[test]\n+    fn test_homing_read() {\n+        let (port, chan) = Chan::new();\n+        let mut pool = SchedPool::new(PoolConfig { threads: 1 });\n+\n+        do pool.spawn(TaskOpts::new()) {\n+            let addr1 = next_test_ip4();\n+            let addr2 = next_test_ip4();\n+            let listener = UdpWatcher::bind(local_loop(), addr2);\n+            chan.send((listener.unwrap(), addr1));\n+            let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n+            listener.sendto([1, 2, 3, 4], addr2);\n+        }\n \n-    //        let sched2 = sched2;\n-    //        let thread2 = do Thread::start {\n-    //            sched2.bootstrap(null_task);\n-    //        };\n+        let task = do pool.task(TaskOpts::new()) {\n+            let (mut watcher, addr) = port.recv();\n+            let mut buf = [0, ..10];\n+            assert_eq!(watcher.recvfrom(buf).unwrap(), (4, addr));\n+        };\n+        pool.spawn_sched().send(sched::TaskFromFriend(task));\n \n-    //        thread1.join();\n-    //        thread2.join();\n-    //    }\n-    //}\n+        pool.shutdown();\n+    }\n }"}]}