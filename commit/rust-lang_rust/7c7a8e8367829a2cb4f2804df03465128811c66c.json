{"sha": "7c7a8e8367829a2cb4f2804df03465128811c66c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjN2E4ZTgzNjc4MjlhMmNiNGYyODA0ZGYwMzQ2NTEyODgxMWM2NmM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-15T09:36:06Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-15T09:36:23Z"}, "message": "Workaround for missing icmp{,_imm}.i128 legalizations\n\nFixes #667", "tree": {"sha": "15cbdb5c5fb3d538b5687795899b4c4fd1a684f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15cbdb5c5fb3d538b5687795899b4c4fd1a684f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c7a8e8367829a2cb4f2804df03465128811c66c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7a8e8367829a2cb4f2804df03465128811c66c", "html_url": "https://github.com/rust-lang/rust/commit/7c7a8e8367829a2cb4f2804df03465128811c66c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c7a8e8367829a2cb4f2804df03465128811c66c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9505d60a249b23044e7054684388fd4993ba1a32", "url": "https://api.github.com/repos/rust-lang/rust/commits/9505d60a249b23044e7054684388fd4993ba1a32", "html_url": "https://github.com/rust-lang/rust/commit/9505d60a249b23044e7054684388fd4993ba1a32"}], "stats": {"total": 263, "additions": 103, "deletions": 160}, "files": [{"sha": "0e663c0482b65c1e08610cd3d2e2781f79c4e870", "filename": "patches/0002-Disable-u128-and-i128-in-libcore.patch", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9505d60a249b23044e7054684388fd4993ba1a32/patches%2F0002-Disable-u128-and-i128-in-libcore.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9505d60a249b23044e7054684388fd4993ba1a32/patches%2F0002-Disable-u128-and-i128-in-libcore.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0002-Disable-u128-and-i128-in-libcore.patch?ref=9505d60a249b23044e7054684388fd4993ba1a32", "patch": "@@ -1,112 +0,0 @@\n-From e87977477e8507a5749e64ea49ee503e706d7178 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Fri, 1 Mar 2019 18:36:21 +0100\n-Subject: [PATCH] Disable u128 and i128 in libcore\n-\n----\n- src/libcore/sync/atomic.rs       |  32 --------\n- src/libcore/time.rs              | 123 -------------------------------\n- src/libstd/num.rs                |   2 +-\n- src/libstd/panic.rs              |   6 --\n- 20 files changed, 63 insertions(+), 363 deletions(-)\n-\n-diff --git a/src/libcore/num/mod.rs b/src/libcore/num/mod.rs\n-index 6b657b1..5add3f3 100644\n---- a/src/libcore/num/mod.rs\n-+++ b/src/libcore/num/mod.rs\n-@@ -127,8 +127,8 @@ macro_rules! from_str_radix_nzint_impl {\n-     )*}\n- }\n- \n--from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n--                             NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n-+from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroUsize\n-+                             NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroIsize }\n- \n- /// Provides intentionally-wrapped arithmetic on `T`.\n- ///\n-diff --git a/src/libcore/sync/atomic.rs b/src/libcore/sync/atomic.rs\n-index d0ee5fa..d02c454 100644\n---- a/src/libcore/sync/atomic.rs\n-+++ b/src/libcore/sync/atomic.rs\n-@@ -2012,38 +2012,6 @@ atomic_int! {\n-     \"AtomicU64::new(0)\",\n-     u64 AtomicU64 ATOMIC_U64_INIT\n- }\n--#[cfg(target_has_atomic = \"128\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"i128\", \"../../../std/primitive.i128.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_min, atomic_max,\n--    16,\n--    \"AtomicI128::new(0)\",\n--    i128 AtomicI128 ATOMIC_I128_INIT\n--}\n--#[cfg(target_has_atomic = \"128\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"u128\", \"../../../std/primitive.u128.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_umin, atomic_umax,\n--    16,\n--    \"AtomicU128::new(0)\",\n--    u128 AtomicU128 ATOMIC_U128_INIT\n--}\n- #[cfg(target_pointer_width = \"16\")]\n- macro_rules! ptr_width {\n-     () => { 2 }\n-diff --git a/src/libstd/num.rs b/src/libstd/num.rs\n-index 828d572..bc04fb1 100644\n---- a/src/libstd/num.rs\n-+++ b/src/libstd/num.rs\n-@@ -12,7 +12,7 @@ pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError}\n- pub use core::num::Wrapping;\n- \n- #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n--pub use core::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize};\n-+pub use core::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroUsize};\n- #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n--pub use core::num::{NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize};\n-+pub use core::num::{NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroIsize};\n- \n- #[cfg(test)] use crate::fmt;\n- #[cfg(test)] use crate::ops::{Add, Sub, Mul, Div, Rem};\n-diff --git a/src/libstd/panic.rs b/src/libstd/panic.rs\n-index 6a16414..f027102 100644\n---- a/src/libstd/panic.rs\n-+++ b/src/libstd/panic.rs\n-@@ -254,9 +254,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}\n- #[cfg(target_has_atomic = \"64\")]\n- #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n- impl RefUnwindSafe for atomic::AtomicI64 {}\n--#[cfg(target_has_atomic = \"128\")]\n--#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n--impl RefUnwindSafe for atomic::AtomicI128 {}\n- \n- #[cfg(target_has_atomic = \"ptr\")]\n- #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-@@ -273,9 +270,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}\n- #[cfg(target_has_atomic = \"64\")]\n- #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n- impl RefUnwindSafe for atomic::AtomicU64 {}\n--#[cfg(target_has_atomic = \"128\")]\n--#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n--impl RefUnwindSafe for atomic::AtomicU128 {}\n- \n- #[cfg(target_has_atomic = \"8\")]\n- #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n--- \n-2.17.2 (Apple Git-113)"}, {"sha": "cfe5ce5918f74c506a1d040c9b80c07bbdf97279", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=7c7a8e8367829a2cb4f2804df03465128811c66c", "patch": "@@ -73,39 +73,7 @@ pub fn maybe_codegen<'a, 'tcx>(\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n             assert!(!checked);\n-            let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n-            let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs_val);\n-\n-            let res = match bin_op {\n-                BinOp::Eq => {\n-                    let lsb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_lsb, rhs_lsb);\n-                    let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n-                    fx.bcx.ins().band(lsb_eq, msb_eq)\n-                }\n-                BinOp::Ne => {\n-                    let lsb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n-                    let msb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_msb, rhs_msb);\n-                    fx.bcx.ins().bor(lsb_ne, msb_ne)\n-                }\n-                _ => {\n-                    // if msb_eq {\n-                    //     lsb_cc\n-                    // } else {\n-                    //     msb_cc\n-                    // }\n-                    let cc = crate::num::bin_op_to_intcc(bin_op, is_signed).unwrap();\n-\n-                    let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n-                    let lsb_cc = fx.bcx.ins().icmp(cc, lhs_lsb, rhs_lsb);\n-                    let msb_cc = fx.bcx.ins().icmp(cc, lhs_msb, rhs_msb);\n-\n-                    fx.bcx.ins().select(msb_eq, lsb_cc, msb_cc)\n-                }\n-            };\n-\n-            let res = fx.bcx.ins().bint(types::I8, res);\n-            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.bool));\n-            return Some(res);\n+            return None;\n         }\n         BinOp::Shl | BinOp::Shr => {\n             let is_overflow = if checked {"}, {"sha": "bbfee005a628001e7b2e1d16c9c51227f3eb2a71", "filename": "src/common.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=7c7a8e8367829a2cb4f2804df03465128811c66c", "patch": "@@ -73,6 +73,95 @@ pub fn codegen_select(bcx: &mut FunctionBuilder, cond: Value, lhs: Value, rhs: V\n     }\n }\n \n+pub fn codegen_icmp<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    intcc: IntCC,\n+    lhs: Value,\n+    rhs: Value,\n+) -> Value {\n+    let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+    let rhs_ty = fx.bcx.func.dfg.value_type(rhs);\n+    assert_eq!(lhs_ty, rhs_ty);\n+    if lhs_ty == types::I128 {\n+        // FIXME legalize `icmp.i128` in Cranelift\n+\n+        let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs);\n+        let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs);\n+\n+        match intcc {\n+            IntCC::Equal => {\n+                let lsb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_lsb, rhs_lsb);\n+                let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n+                fx.bcx.ins().band(lsb_eq, msb_eq)\n+            }\n+            IntCC::NotEqual => {\n+                let lsb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n+                let msb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_msb, rhs_msb);\n+                fx.bcx.ins().bor(lsb_ne, msb_ne)\n+            }\n+            _ => {\n+                // if msb_eq {\n+                //     lsb_cc\n+                // } else {\n+                //     msb_cc\n+                // }\n+\n+                let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n+                let lsb_cc = fx.bcx.ins().icmp(intcc, lhs_lsb, rhs_lsb);\n+                let msb_cc = fx.bcx.ins().icmp(intcc, lhs_msb, rhs_msb);\n+\n+                fx.bcx.ins().select(msb_eq, lsb_cc, msb_cc)\n+            }\n+        }\n+    } else {\n+        fx.bcx.ins().icmp(intcc, lhs, rhs)\n+    }\n+}\n+\n+pub fn codegen_icmp_imm<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    intcc: IntCC,\n+    lhs: Value,\n+    rhs: i128,\n+) -> Value {\n+    let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+    if lhs_ty == types::I128 {\n+        // FIXME legalize `icmp_imm.i128` in Cranelift\n+\n+        let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs);\n+        let (rhs_lsb, rhs_msb) = (rhs as u128 as u64 as i64, (rhs as u128 >> 64) as u64 as i64);\n+\n+        match intcc {\n+            IntCC::Equal => {\n+                let lsb_eq = fx.bcx.ins().icmp_imm(IntCC::Equal, lhs_lsb, rhs_lsb);\n+                let msb_eq = fx.bcx.ins().icmp_imm(IntCC::Equal, lhs_msb, rhs_msb);\n+                fx.bcx.ins().band(lsb_eq, msb_eq)\n+            }\n+            IntCC::NotEqual => {\n+                let lsb_ne = fx.bcx.ins().icmp_imm(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n+                let msb_ne = fx.bcx.ins().icmp_imm(IntCC::NotEqual, lhs_msb, rhs_msb);\n+                fx.bcx.ins().bor(lsb_ne, msb_ne)\n+            }\n+            _ => {\n+                // if msb_eq {\n+                //     lsb_cc\n+                // } else {\n+                //     msb_cc\n+                // }\n+\n+                let msb_eq = fx.bcx.ins().icmp_imm(IntCC::Equal, lhs_msb, rhs_msb);\n+                let lsb_cc = fx.bcx.ins().icmp_imm(intcc, lhs_lsb, rhs_lsb);\n+                let msb_cc = fx.bcx.ins().icmp_imm(intcc, lhs_msb, rhs_msb);\n+\n+                fx.bcx.ins().select(msb_eq, lsb_cc, msb_cc)\n+            }\n+        }\n+    } else {\n+        let rhs = i64::try_from(rhs).expect(\"codegen_icmp_imm rhs out of range for <128bit int\");\n+        fx.bcx.ins().icmp_imm(intcc, lhs, rhs)\n+    }\n+}\n+\n fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n     if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n         if let InstructionData::UnaryImm {"}, {"sha": "1a83b39fb09d918c4e49616d30c5d45ddca3326d", "filename": "src/discriminant.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=7c7a8e8367829a2cb4f2804df03465128811c66c", "patch": "@@ -102,10 +102,7 @@ pub fn codegen_get_discriminant<'tcx>(\n             let niche_llty = fx.clif_type(discr_ty).unwrap();\n             let dest_clif_ty = fx.clif_type(dest_layout.ty).unwrap();\n             if niche_variants.start() == niche_variants.end() {\n-                let b = fx\n-                    .bcx\n-                    .ins()\n-                    .icmp_imm(IntCC::Equal, lldiscr, *niche_start as u64 as i64);\n+                let b = codegen_icmp_imm(fx, IntCC::Equal, lldiscr, *niche_start as i128);\n                 let if_true = fx\n                     .bcx\n                     .ins()\n@@ -121,10 +118,11 @@ pub fn codegen_get_discriminant<'tcx>(\n                 let delta = niche_start.wrapping_sub(niche_variants.start().as_u32() as u128);\n                 let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n                 let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n-                let b = fx.bcx.ins().icmp_imm(\n+                let b = codegen_icmp_imm(\n+                    fx,\n                     IntCC::UnsignedLessThanOrEqual,\n                     lldiscr,\n-                    niche_variants.end().as_u32() as i64,\n+                    i128::from(niche_variants.end().as_u32()),\n                 );\n                 let if_true =\n                     clif_intcast(fx, lldiscr, fx.clif_type(dest_layout.ty).unwrap(), false);"}, {"sha": "8b4d596285699537bd7802a6b9971f48fcc9c72e", "filename": "src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=7c7a8e8367829a2cb4f2804df03465128811c66c", "patch": "@@ -119,8 +119,8 @@ macro_rules! atomic_minmax {\n         let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n \n         // Compare\n-        let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n-        let new = crate::common::codegen_select(&mut $fx.bcx, is_eq, old, $src);\n+        let is_eq = codegen_icmp($fx, IntCC::SignedGreaterThan, old, $src);\n+        let new = codegen_select(&mut $fx.bcx, is_eq, old, $src);\n \n         // Write new\n         $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n@@ -198,7 +198,7 @@ macro_rules! simd_cmp {\n     ($fx:expr, $intrinsic:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n             let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n+                ty::Uint(_) | ty::Int(_) => codegen_icmp(fx, IntCC::$cc, x_lane, y_lane),\n                 _ => unreachable!(\"{:?}\", lane_layout.ty),\n             };\n             bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n@@ -207,8 +207,8 @@ macro_rules! simd_cmp {\n     ($fx:expr, $intrinsic:expr, $cc_u:ident|$cc_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n         simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n             let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n-                ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n+                ty::Uint(_) => codegen_icmp(fx, IntCC::$cc_u, x_lane, y_lane),\n+                ty::Int(_) => codegen_icmp(fx, IntCC::$cc_s, x_lane, y_lane),\n                 _ => unreachable!(\"{:?}\", lane_layout.ty),\n             };\n             bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n@@ -791,7 +791,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n \n             // Compare\n-            let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n+            let is_eq = codegen_icmp(fx, IntCC::Equal, old, test_old);\n             let new = crate::common::codegen_select(&mut fx.bcx, is_eq, new, old); // Keep old if not equal to test_old\n \n             // Write new"}, {"sha": "1e8329007f9c8c856b818f002a204f0c25d51d0a", "filename": "src/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7a8e8367829a2cb4f2804df03465128811c66c/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=7c7a8e8367829a2cb4f2804df03465128811c66c", "patch": "@@ -21,7 +21,8 @@ fn codegen_compare_bin_op<'tcx>(\n     lhs: Value,\n     rhs: Value,\n ) -> CValue<'tcx> {\n-    let val = fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, signed).unwrap(), lhs, rhs);\n+    let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n+    let val = codegen_icmp(fx, intcc, lhs, rhs);\n     let val = fx.bcx.ins().bint(types::I8, val);\n     CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n }\n@@ -35,7 +36,6 @@ pub fn codegen_binop<'tcx>(\n     match bin_op {\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n             match in_lhs.layout().ty.sty {\n-                ref sty if *sty == fx.tcx.types.u128.sty || *sty == fx.tcx.types.i128.sty => {}\n                 ty::Bool | ty::Uint(_) | ty::Int(_) | ty::Char => {\n                     let signed = type_sign(in_lhs.layout().ty);\n                     let lhs = in_lhs.load_scalar(fx);\n@@ -310,7 +310,7 @@ pub fn trans_ptr_binop<'a, 'tcx: 'a>(\n                 let lhs = in_lhs.load_scalar(fx);\n                 let rhs = in_rhs.load_scalar(fx);\n \n-                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);\n+                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);;\n             }\n             BinOp::Offset => {\n                 let (base, offset) = (in_lhs, in_rhs.load_scalar(fx));"}]}