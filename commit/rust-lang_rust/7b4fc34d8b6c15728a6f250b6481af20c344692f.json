{"sha": "7b4fc34d8b6c15728a6f250b6481af20c344692f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNGZjMzRkOGI2YzE1NzI4YTZmMjUwYjY0ODFhZjIwYzM0NDY5MmY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-25T18:49:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-25T18:49:07Z"}, "message": "Merge pull request #842 from bjorn3/real_simd\n\nCodegen simd intrinsics as simd clif instructions", "tree": {"sha": "9b65688c6d728f3fbe49e51598d823acb86765f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b65688c6d728f3fbe49e51598d823acb86765f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b4fc34d8b6c15728a6f250b6481af20c344692f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeA68jCRBK7hj4Ov3rIwAAdHIIAAUVkKMfDF+iLFNEOOrvNwMp\nbsoRjj6S6VsyU1MI891iD1doz46x0Ac6ToIb8v2T45V1lA/GDTO6PXBuq2RCyCkz\nvYl9wIjZFTCnyINfnoiSSy6ZQEvz6expqemuK7uobodcJ/dCiQO59yN1mYZZ3RaM\nrMWJuvIolQgGs+/ZYI/S3PELQEXtFvockP5zij6Uvwj3cABWTgRDb14CUHaGmSHz\nmCDa9UUWUccAjyV6DpNwwRZBRIW7M5ckD/wcx/GWKGmIEkEk5CiMNqxcg/swtYlU\ntYVj0dyrkb+GmmKUVsidWQyCZJxC2KXZnb+y5pIdIxXLImTAIYvNUOQZMhbmVnQ=\n=MO3u\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b65688c6d728f3fbe49e51598d823acb86765f2\nparent c3daf6d220e5751e2de592b94141cef9d1cca055\nparent 30a760dda293b6c7d7266252e22fc0887eb26ed7\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1577299747 +0100\ncommitter GitHub <noreply@github.com> 1577299747 +0100\n\nMerge pull request #842 from bjorn3/real_simd\n\nCodegen simd intrinsics as simd clif instructions"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4fc34d8b6c15728a6f250b6481af20c344692f", "html_url": "https://github.com/rust-lang/rust/commit/7b4fc34d8b6c15728a6f250b6481af20c344692f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b4fc34d8b6c15728a6f250b6481af20c344692f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3daf6d220e5751e2de592b94141cef9d1cca055", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3daf6d220e5751e2de592b94141cef9d1cca055", "html_url": "https://github.com/rust-lang/rust/commit/c3daf6d220e5751e2de592b94141cef9d1cca055"}, {"sha": "30a760dda293b6c7d7266252e22fc0887eb26ed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a760dda293b6c7d7266252e22fc0887eb26ed7", "html_url": "https://github.com/rust-lang/rust/commit/30a760dda293b6c7d7266252e22fc0887eb26ed7"}], "stats": {"total": 246, "additions": 122, "deletions": 124}, "files": [{"sha": "3e7c99a9ab602153d642620c5c165b90acbdd841", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=7b4fc34d8b6c15728a6f250b6481af20c344692f", "patch": "@@ -86,7 +86,7 @@ pub fn codegen_llvm_intrinsic_call<'tcx>(\n                 kind => unreachable!(\"kind {:?}\", kind),\n             };\n \n-            simd_for_each_lane(fx, intrinsic, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+            simd_pair_for_each_lane(fx, intrinsic, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n                 let res_lane = match lane_layout.ty.kind {\n                     ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n                     _ => unreachable!(\"{:?}\", lane_layout.ty),"}, {"sha": "4ba1ae5061677ae5e3db5e581416d474058538e8", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 67, "deletions": 81, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=7b4fc34d8b6c15728a6f250b6481af20c344692f", "patch": "@@ -144,6 +144,34 @@ pub fn lane_type_and_count<'tcx>(\n }\n \n fn simd_for_each_lane<'tcx, B: Backend>(\n+    fx: &mut FunctionCx<'_, 'tcx, B>,\n+    intrinsic: &str,\n+    val: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: impl Fn(\n+        &mut FunctionCx<'_, 'tcx, B>,\n+        TyLayout<'tcx>,\n+        TyLayout<'tcx>,\n+        Value,\n+    ) -> CValue<'tcx>,\n+) {\n+    let layout = val.layout();\n+\n+    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane_idx in 0..lane_count {\n+        let lane_idx = mir::Field::new(lane_idx.try_into().unwrap());\n+        let lane = val.value_field(fx, lane_idx).load_scalar(fx);\n+\n+        let res_lane = f(fx, lane_layout, ret_lane_layout, lane);\n+\n+        ret.place_field(fx, lane_idx).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n+fn simd_pair_for_each_lane<'tcx, B: Backend>(\n     fx: &mut FunctionCx<'_, 'tcx, B>,\n     intrinsic: &str,\n     x: CValue<'tcx>,\n@@ -204,7 +232,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n \n macro simd_cmp {\n     ($fx:expr, $intrinsic:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n+        simd_pair_for_each_lane(\n             $fx,\n             $intrinsic,\n             $x,\n@@ -220,7 +248,7 @@ macro simd_cmp {\n         );\n     },\n     ($fx:expr, $intrinsic:expr, $cc_u:ident|$cc_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n+        simd_pair_for_each_lane(\n             $fx,\n             $intrinsic,\n             $x,\n@@ -239,94 +267,52 @@ macro simd_cmp {\n }\n \n macro simd_int_binop {\n-    ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n-            $fx,\n-            $intrinsic,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n-                    ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n+    ($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_int_binop!($fx, $op|$op($x, $y) -> $ret);\n     },\n-    ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n-            $fx,\n-            $intrinsic,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n-                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n+    ($fx:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        let (lane_layout, lane_count) = lane_type_and_count($fx.tcx, $x.layout());\n+        let x_val = $x.load_scalar($fx);\n+        let y_val = $y.load_scalar($fx);\n+\n+        let res = match lane_layout.ty.kind {\n+            ty::Uint(_) => $fx.bcx.ins().$op_u(x_val, y_val),\n+            ty::Int(_) => $fx.bcx.ins().$op_s(x_val, y_val),\n+            _ => unreachable!(\"{:?}\", lane_layout.ty),\n+        };\n+        $ret.write_cvalue($fx, CValue::by_val(res, $ret.layout()));\n     },\n }\n \n macro simd_int_flt_binop {\n-    ($fx:expr, $intrinsic:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n-            $fx,\n-            $intrinsic,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n-                    ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                    ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n+    ($fx:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_int_flt_binop!($fx, $op|$op|$op_f($x, $y) -> $ret);\n     },\n-    ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane(\n-            $fx,\n-            $intrinsic,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n-                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-                    ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n+    ($fx:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        let (lane_layout, lane_count) = lane_type_and_count($fx.tcx, $x.layout());\n+        let x_val = $x.load_scalar($fx);\n+        let y_val = $y.load_scalar($fx);\n+\n+        let res = match lane_layout.ty.kind {\n+            ty::Uint(_) => $fx.bcx.ins().$op_u(x_val, y_val),\n+            ty::Int(_) => $fx.bcx.ins().$op_s(x_val, y_val),\n+            ty::Float(_) => $fx.bcx.ins().$op_f(x_val, y_val),\n+            _ => unreachable!(\"{:?}\", lane_layout.ty),\n+        };\n+        $ret.write_cvalue($fx, CValue::by_val(res, $ret.layout()));\n     },\n }\n \n-macro simd_flt_binop($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n-    simd_for_each_lane(\n-        $fx,\n-        $intrinsic,\n-        $x,\n-        $y,\n-        $ret,\n-        |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.kind {\n-                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        },\n-    );\n+macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n+    let (lane_layout, lane_count) = lane_type_and_count($fx.tcx, $x.layout());\n+    let x_val = $x.load_scalar($fx);\n+    let y_val = $y.load_scalar($fx);\n+\n+    let res = match lane_layout.ty.kind {\n+        ty::Float(_) => $fx.bcx.ins().$op(x_val, y_val),\n+        _ => unreachable!(\"{:?}\", lane_layout.ty),\n+    };\n+    $ret.write_cvalue($fx, CValue::by_val(res, $ret.layout()));\n }\n \n pub fn codegen_intrinsic_call<'tcx>("}, {"sha": "1870192e2241a41bd3a4515b5e0e86259a48fc67", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=7b4fc34d8b6c15728a6f250b6481af20c344692f", "patch": "@@ -21,22 +21,15 @@ pub fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_cast, (c a) {\n-            let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, a.layout());\n-            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n-            assert_eq!(lane_count, ret_lane_count);\n+            simd_for_each_lane(fx, intrinsic, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n+                let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n \n-            let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n+                let from_signed = type_sign(lane_layout.ty);\n+                let to_signed = type_sign(ret_lane_layout.ty);\n \n-            let from_signed = type_sign(lane_layout.ty);\n-            let to_signed = type_sign(ret_lane_layout.ty);\n-\n-            for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.try_into().unwrap());\n-\n-                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n-                let res = clif_int_or_float_cast(fx, a_lane, from_signed, ret_lane_ty, to_signed);\n-                ret.place_field(fx, lane).write_cvalue(fx, CValue::by_val(res, ret_lane_layout));\n-            }\n+                let ret_lane = clif_int_or_float_cast(fx, lane, from_signed, ret_lane_ty, to_signed);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n         };\n \n         simd_eq, (c x, c y) {\n@@ -134,38 +127,38 @@ pub fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_add, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, iadd|fadd(x, y) -> ret);\n+            simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n         };\n         simd_sub, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, isub|fsub(x, y) -> ret);\n+            simd_int_flt_binop!(fx, isub|fsub(x, y) -> ret);\n         };\n         simd_mul, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, imul|fmul(x, y) -> ret);\n+            simd_int_flt_binop!(fx, imul|fmul(x, y) -> ret);\n         };\n         simd_div, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, udiv|sdiv|fdiv(x, y) -> ret);\n+            simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n         };\n         simd_shl, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, ishl(x, y) -> ret);\n+            simd_int_binop!(fx, ishl(x, y) -> ret);\n         };\n         simd_shr, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n+            simd_int_binop!(fx, ushr|sshr(x, y) -> ret);\n         };\n         simd_and, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, band(x, y) -> ret);\n+            simd_int_binop!(fx, band(x, y) -> ret);\n         };\n         simd_or, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, bor(x, y) -> ret);\n+            simd_int_binop!(fx, bor(x, y) -> ret);\n         };\n         simd_xor, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, bxor(x, y) -> ret);\n+            simd_int_binop!(fx, bxor(x, y) -> ret);\n         };\n \n         simd_fmin, (c x, c y) {\n-            simd_flt_binop!(fx, intrinsic, fmin(x, y) -> ret);\n+            simd_flt_binop!(fx, fmin(x, y) -> ret);\n         };\n         simd_fmax, (c x, c y) {\n-            simd_flt_binop!(fx, intrinsic, fmax(x, y) -> ret);\n+            simd_flt_binop!(fx, fmax(x, y) -> ret);\n         };\n     }\n }"}, {"sha": "8ba9582f554689bfb371a9d4cf63a3ede08f42aa", "filename": "src/pointer.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=7b4fc34d8b6c15728a6f250b6481af20c344692f", "patch": "@@ -126,8 +126,8 @@ impl Pointer {\n     ) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n-            PointerBase::Stack(stack_slot) => if ty == types::I128 {\n-                // WORKAROUND for stack_load.i128 not being implemented\n+            PointerBase::Stack(stack_slot) => if ty == types::I128 || ty.is_vector() {\n+                // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n                 let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n                 fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n             } else {\n@@ -146,12 +146,15 @@ impl Pointer {\n             PointerBase::Addr(base_addr) => {\n                 fx.bcx.ins().store(flags, value, base_addr, self.offset);\n             }\n-            PointerBase::Stack(stack_slot) => if fx.bcx.func.dfg.value_type(value) == types::I128 {\n-                // WORKAROUND for stack_load.i128 not being implemented\n-                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                fx.bcx.ins().store(flags, value, base_addr, self.offset);\n-            } else {\n-                fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n+            PointerBase::Stack(stack_slot) => {\n+                let val_ty = fx.bcx.func.dfg.value_type(value);\n+                if val_ty == types::I128 || val_ty.is_vector() {\n+                    // WORKAROUND for stack_store.i128 and stack_store.iXxY not being implemented\n+                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                    fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+                } else {\n+                    fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n+                }\n             }\n         }\n     }"}, {"sha": "cb23c814b5d2d6bd038c6821a85da12de075e2eb", "filename": "src/value_and_place.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4fc34d8b6c15728a6f250b6481af20c344692f/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=7b4fc34d8b6c15728a6f250b6481af20c344692f", "patch": "@@ -122,11 +122,14 @@ impl<'tcx> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr) => {\n-                let scalar = match layout.abi {\n-                    layout::Abi::Scalar(ref scalar) => scalar.clone(),\n+                let clif_ty = match layout.abi {\n+                    layout::Abi::Scalar(ref scalar) => scalar_to_clif_type(fx.tcx, scalar.clone()),\n+                    layout::Abi::Vector { ref element, count } => {\n+                        scalar_to_clif_type(fx.tcx, element.clone())\n+                            .by(u16::try_from(count).unwrap()).unwrap()\n+                    }\n                     _ => unreachable!(),\n                 };\n-                let clif_ty = scalar_to_clif_type(fx.tcx, scalar);\n                 ptr.load(fx, clif_ty, MemFlags::new())\n             }\n             CValueInner::ByVal(value) => value,\n@@ -164,13 +167,26 @@ impl<'tcx> CValue<'tcx> {\n         field: mir::Field,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n-        let ptr = match self.0 {\n-            CValueInner::ByRef(ptr) => ptr,\n+        match self.0 {\n+            CValueInner::ByVal(val) => {\n+                match layout.abi {\n+                    layout::Abi::Vector { element: _, count } => {\n+                        let count = u8::try_from(count).expect(\"SIMD type with more than 255 lanes???\");\n+                        let field = u8::try_from(field.index()).unwrap();\n+                        assert!(field < count);\n+                        let lane = fx.bcx.ins().extractlane(val, field);\n+                        let field_layout = layout.field(&*fx, usize::from(field));\n+                        CValue::by_val(lane, field_layout)\n+                    }\n+                    _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n+                }\n+            }\n+            CValueInner::ByRef(ptr) => {\n+                let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n+                CValue::by_ref(field_ptr, field_layout)\n+            }\n             _ => bug!(\"place_field for {:?}\", self),\n-        };\n-\n-        let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n-        CValue::by_ref(field_ptr, field_layout)\n+        }\n     }\n \n     pub fn unsize_value<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, dest: CPlace<'tcx>) {"}]}