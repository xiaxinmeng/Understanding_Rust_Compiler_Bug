{"sha": "1fa9133b76ec4641e5470cbea8a8f95ec32f9563", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYTkxMzNiNzZlYzQ2NDFlNTQ3MGNiZWE4YThmOTVlYzMyZjk1NjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-16T01:02:25Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-16T01:03:25Z"}, "message": "rustc: Implement interior vector concatenation", "tree": {"sha": "8a68257ab21f39cba2609989e09f1735a91830ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a68257ab21f39cba2609989e09f1735a91830ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fa9133b76ec4641e5470cbea8a8f95ec32f9563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa9133b76ec4641e5470cbea8a8f95ec32f9563", "html_url": "https://github.com/rust-lang/rust/commit/1fa9133b76ec4641e5470cbea8a8f95ec32f9563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fa9133b76ec4641e5470cbea8a8f95ec32f9563/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260aa408f390cf457eb19507fc80ec388a039f8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/260aa408f390cf457eb19507fc80ec388a039f8e", "html_url": "https://github.com/rust-lang/rust/commit/260aa408f390cf457eb19507fc80ec388a039f8e"}], "stats": {"total": 183, "additions": 174, "deletions": 9}, "files": [{"sha": "c677e7ae5a3b64f55c4f5d4dc323c8c1184642db", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 174, "deletions": 9, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/1fa9133b76ec4641e5470cbea8a8f95ec32f9563/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa9133b76ec4641e5470cbea8a8f95ec32f9563/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1fa9133b76ec4641e5470cbea8a8f95ec32f9563", "patch": "@@ -3499,6 +3499,172 @@ mod ivec {\n         post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n         ret res(next_cx, C_nil());\n     }\n+\n+    fn alloc(&@block_ctxt bcx, ty::t unit_ty, ValueRef llalen) -> ValueRef {\n+        auto llunitty = type_of_or_i8(bcx, unit_ty);\n+        if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n+            auto llarraysz = bcx.build.Add(llsize_of(T_opaque_ivec()),\n+                                           llalen);\n+            auto llvecptr = array_alloca(bcx, T_i8(), llarraysz);\n+            ret bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n+        }\n+\n+        ret alloca(bcx, T_ivec(llunitty));\n+    }\n+\n+    fn trans_add(&@block_ctxt cx, ty::t vec_ty, ValueRef lhs, ValueRef rhs)\n+            -> result {\n+        auto bcx = cx;\n+\n+        auto unit_ty = ty::sequence_element_type(bcx.fcx.lcx.ccx.tcx, vec_ty);\n+\n+        auto rslt = size_of(bcx, unit_ty);\n+        auto unit_sz = rslt.val;\n+\n+        auto llalen = bcx.build.Mul(unit_sz,\n+                                    C_uint(abi::ivec_default_length));\n+        auto llvecptr = alloc(bcx, unit_ty, llalen);\n+        auto llunitty = type_of_or_i8(bcx, unit_ty);\n+        auto llheappartty = T_ivec_heap_part(llunitty);\n+\n+        auto lhs_len_and_data = get_len_and_data(bcx, lhs, unit_ty);\n+        auto lhs_len = lhs_len_and_data._0;\n+        auto lhs_data = lhs_len_and_data._1;\n+        bcx = lhs_len_and_data._2;\n+\n+        auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n+        auto rhs_len = rhs_len_and_data._0;\n+        auto rhs_data = rhs_len_and_data._1;\n+        bcx = rhs_len_and_data._2;\n+\n+        auto lllen = bcx.build.Add(lhs_len, rhs_len);\n+\n+        // We have three cases to handle here:\n+        // (1) Length is zero ([] + []).\n+        // (2) Copy onto stack.\n+        // (3) Allocate on heap and copy there.\n+\n+        auto len_is_zero = bcx.build.ICmp(lib::llvm::LLVMIntEQ, lllen,\n+                                          C_int(0));\n+        auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n+        auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+        bcx.build.CondBr(len_is_zero, zero_len_cx.llbb, nonzero_len_cx.llbb);\n+\n+        // Case (1): Length is zero.\n+        auto stub_ptr_zero = zero_len_cx.build.PointerCast(llvecptr,\n+            T_ptr(T_ivec_heap(llunitty)));\n+        zero_len_cx.build.Store(C_int(0), zero_len_cx.build.InBoundsGEP(\n+            stub_ptr_zero, [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)]));\n+        zero_len_cx.build.Store(llalen, zero_len_cx.build.InBoundsGEP(\n+            stub_ptr_zero, [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n+        zero_len_cx.build.Store(C_null(T_ptr(llheappartty)),\n+            zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+                [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+        auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+        zero_len_cx.build.Br(next_cx.llbb);\n+\n+        // Determine whether we need to spill to the heap.\n+        auto on_stack = nonzero_len_cx.build.ICmp(lib::llvm::LLVMIntULE,\n+                                                  lllen, llalen);\n+        auto stack_cx = new_sub_block_ctxt(bcx, \"stack\");\n+        auto heap_cx = new_sub_block_ctxt(bcx, \"heap\");\n+        nonzero_len_cx.build.CondBr(on_stack, stack_cx.llbb, heap_cx.llbb);\n+\n+        // Case (2): Copy onto stack.\n+        stack_cx.build.Store(lllen, stack_cx.build.InBoundsGEP(llvecptr,\n+            [C_int(0), C_uint(abi::ivec_elt_len)]));\n+        stack_cx.build.Store(llalen, stack_cx.build.InBoundsGEP(llvecptr,\n+            [C_int(0), C_uint(abi::ivec_elt_alen)]));\n+        auto dest_ptr_stack = stack_cx.build.InBoundsGEP(llvecptr,\n+            [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n+        auto copy_cx = new_sub_block_ctxt(bcx, \"copy\");\n+        stack_cx.build.Br(copy_cx.llbb);\n+\n+        // Case (3): Allocate on heap and copy there.\n+        auto stub_ptr_heap = heap_cx.build.PointerCast(llvecptr,\n+            T_ptr(T_ivec_heap(llunitty)));\n+        heap_cx.build.Store(C_int(0), heap_cx.build.InBoundsGEP(\n+            stub_ptr_heap, [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)]));\n+        heap_cx.build.Store(lllen, heap_cx.build.InBoundsGEP(\n+            stub_ptr_heap, [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n+\n+        auto heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n+\n+        rslt = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n+        auto heap_part = rslt.val;\n+        heap_cx = rslt.bcx;\n+\n+        heap_cx.build.Store(heap_part, heap_cx.build.InBoundsGEP(\n+            stub_ptr_heap, [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+        heap_cx.build.Store(lllen, heap_cx.build.InBoundsGEP(heap_part,\n+            [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n+        auto dest_ptr_heap = heap_cx.build.InBoundsGEP(heap_part,\n+            [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+        heap_cx.build.Br(copy_cx.llbb);\n+\n+        // Emit the copy loop.\n+        auto first_dest_ptr = copy_cx.build.Phi(T_ptr(llunitty),\n+            [dest_ptr_stack, dest_ptr_heap], [stack_cx.llbb, heap_cx.llbb]);\n+\n+        auto lhs_len_unscaled = copy_cx.build.UDiv(lhs_len, unit_sz);\n+        auto lhs_end_ptr = copy_cx.build.InBoundsGEP(lhs_data,\n+                                                     [lhs_len_unscaled]);\n+        auto rhs_len_unscaled = copy_cx.build.UDiv(rhs_len, unit_sz);\n+        auto rhs_end_ptr = copy_cx.build.InBoundsGEP(rhs_data,\n+                                                     [rhs_len_unscaled]);\n+\n+        auto dest_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n+        copy_cx.build.Store(first_dest_ptr, dest_ptr_ptr);\n+        auto lhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n+        copy_cx.build.Store(lhs_data, lhs_ptr_ptr);\n+        auto rhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n+        copy_cx.build.Store(rhs_data, rhs_ptr_ptr);\n+\n+        auto lhs_copy_cx = new_sub_block_ctxt(bcx, \"lhs_copy\");\n+        copy_cx.build.Br(lhs_copy_cx.llbb);\n+\n+        // Copy in elements from the LHS.\n+        auto lhs_ptr = lhs_copy_cx.build.Load(lhs_ptr_ptr);\n+        auto not_at_end_lhs = lhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE,\n+                                                     lhs_ptr, lhs_end_ptr);\n+        auto lhs_do_copy_cx = new_sub_block_ctxt(bcx, \"lhs_do_copy\");\n+        auto rhs_copy_cx = new_sub_block_ctxt(bcx, \"rhs_copy\");\n+        lhs_copy_cx.build.CondBr(not_at_end_lhs, lhs_do_copy_cx.llbb,\n+                                 rhs_copy_cx.llbb);\n+\n+        auto dest_ptr_lhs_copy = lhs_do_copy_cx.build.Load(dest_ptr_ptr);\n+        auto lhs_val = load_if_immediate(lhs_do_copy_cx, lhs_ptr, unit_ty);\n+        rslt = copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy, lhs_val,\n+                        unit_ty);\n+        lhs_do_copy_cx = rslt.bcx;\n+        lhs_do_copy_cx.build.Store(lhs_do_copy_cx.build.InBoundsGEP(\n+            dest_ptr_lhs_copy, [C_int(1)]), dest_ptr_ptr);\n+        lhs_do_copy_cx.build.Store(lhs_do_copy_cx.build.InBoundsGEP(\n+            lhs_ptr, [C_int(1)]), lhs_ptr_ptr);\n+        lhs_do_copy_cx.build.Br(lhs_copy_cx.llbb);\n+\n+        // Copy in elements from the RHS.\n+        auto rhs_ptr = rhs_copy_cx.build.Load(rhs_ptr_ptr);\n+        auto not_at_end_rhs = rhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE,\n+                                                     rhs_ptr, rhs_end_ptr);\n+        auto rhs_do_copy_cx = new_sub_block_ctxt(bcx, \"rhs_do_copy\");\n+        rhs_copy_cx.build.CondBr(not_at_end_rhs, rhs_do_copy_cx.llbb,\n+                                 next_cx.llbb);\n+\n+        auto dest_ptr_rhs_copy = rhs_do_copy_cx.build.Load(dest_ptr_ptr);\n+        auto rhs_val = load_if_immediate(rhs_do_copy_cx, rhs_ptr, unit_ty);\n+        rslt = copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy, rhs_val,\n+                        unit_ty);\n+        rhs_do_copy_cx = rslt.bcx;\n+        rhs_do_copy_cx.build.Store(rhs_do_copy_cx.build.InBoundsGEP(\n+            dest_ptr_rhs_copy, [C_int(1)]), dest_ptr_ptr);\n+        rhs_do_copy_cx.build.Store(rhs_do_copy_cx.build.InBoundsGEP(\n+            rhs_ptr, [C_int(1)]), rhs_ptr_ptr);\n+        rhs_do_copy_cx.build.Br(rhs_copy_cx.llbb);\n+\n+        // Finally done!\n+        ret res(next_cx, llvecptr);\n+    }\n }\n \n \n@@ -3523,6 +3689,9 @@ fn trans_eager_binop(&@block_ctxt cx, ast::binop op, &ty::t intype,\n     alt (op) {\n         case (ast::add) {\n             if (ty::type_is_sequence(cx.fcx.lcx.ccx.tcx, intype)) {\n+                if (ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, intype)) {\n+                    ret ivec::trans_add(cx, intype, lhs, rhs);\n+                }\n                 ret trans_vec_add(cx, intype, lhs, rhs);\n             }\n             if (is_float) {\n@@ -5170,6 +5339,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, &ast::ann ann) ->\n     ret res(bcx, vec_val);\n }\n \n+// TODO: Move me to ivec::\n fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n         result {\n     auto typ = node_ann_type(bcx.fcx.lcx.ccx, ann);\n@@ -5183,17 +5353,12 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n     bcx = rslt.bcx;\n     auto llalen = bcx.build.Mul(unit_sz, C_uint(abi::ivec_default_length));\n     auto llunitty = type_of_or_i8(bcx, unit_ty);\n-    auto llvecptr;\n-    if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n-        auto array_size = bcx.build.Add(llsize_of(T_opaque_ivec()), llalen);\n-        llvecptr = array_alloca(bcx, T_i8(), array_size);\n-        llvecptr = bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n-    } else { llvecptr = alloca(bcx, T_ivec(llunitty)); }\n+    auto llvecptr = ivec::alloc(bcx, unit_ty, llalen);\n     auto lllen = bcx.build.Mul(C_uint(vec::len(args)), unit_sz);\n     // Allocate the vector pieces and store length and allocated length.\n \n     auto llfirsteltptr;\n-    if (vec::len(args) > 0u && vec::len(args) < abi::ivec_default_length) {\n+    if (vec::len(args) > 0u && vec::len(args) <= abi::ivec_default_length) {\n         // Interior case.\n \n         bcx.build.Store(lllen,\n@@ -5222,7 +5387,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n                         bcx.build.InBoundsGEP(llstubptr, stub_z));\n         bcx.build.Store(lllen,\n                         bcx.build.InBoundsGEP(llstubptr, stub_a));\n-        auto llheapty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+        auto llheapty = T_ivec_heap_part(llunitty);\n         if (vec::len(args) == 0u) {\n             // Null heap pointer indicates a zero-length vector.\n \n@@ -5236,7 +5401,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n             auto llheapptr = rslt.val;\n             bcx.build.Store(llheapptr,\n                             bcx.build.InBoundsGEP(llstubptr, stub_p));\n-            auto heap_l = [C_uint(abi::ivec_heap_elt_len)];\n+            auto heap_l = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n             bcx.build.Store(lllen,\n                             bcx.build.InBoundsGEP(llheapptr, heap_l));\n             llfirsteltptr ="}]}