{"sha": "654f43f34edded48a55fef2b515b4a7d0304c38e", "node_id": "C_kwDOAAsO6NoAKDY1NGY0M2YzNGVkZGVkNDhhNTVmZWYyYjUxNWI0YTdkMDMwNGMzOGU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-08T19:25:21Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-09T17:22:39Z"}, "message": "Move winnowing to assembly", "tree": {"sha": "512671c7e32a7fa0faf24273147d1d96786a984d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/512671c7e32a7fa0faf24273147d1d96786a984d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/654f43f34edded48a55fef2b515b4a7d0304c38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/654f43f34edded48a55fef2b515b4a7d0304c38e", "html_url": "https://github.com/rust-lang/rust/commit/654f43f34edded48a55fef2b515b4a7d0304c38e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/654f43f34edded48a55fef2b515b4a7d0304c38e/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8987e68247ed6df47624f9eeb35430fc92d54f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/8987e68247ed6df47624f9eeb35430fc92d54f15", "html_url": "https://github.com/rust-lang/rust/commit/8987e68247ed6df47624f9eeb35430fc92d54f15"}], "stats": {"total": 221, "additions": 81, "deletions": 140}, "files": [{"sha": "775974d8e9a608aaefbcc5cb6c0bee561a3b4dfe", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/654f43f34edded48a55fef2b515b4a7d0304c38e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654f43f34edded48a55fef2b515b4a7d0304c38e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=654f43f34edded48a55fef2b515b4a7d0304c38e", "patch": "@@ -3,7 +3,7 @@\n use super::infcx_ext::InferCtxtExt;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -459,4 +459,78 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn merge_candidates_and_discard_reservation_impls(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.trait_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                i += 1;\n+            }\n+\n+            // If there are *STILL* multiple candidates, give up\n+            // and report ambiguity.\n+            if candidates.len() > 1 {\n+                let certainty = if candidates.iter().all(|x| {\n+                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n+                }) {\n+                    Certainty::Maybe(MaybeCause::Overflow)\n+                } else {\n+                    Certainty::AMBIGUOUS\n+                };\n+                return self.make_canonical_response(certainty);\n+            }\n+        }\n+\n+        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+    }\n+\n+    fn trait_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::AliasBound, _)\n+            | (CandidateSource::BuiltinImpl, _) => false,\n+        }\n+    }\n+\n+    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+        if let CandidateSource::Impl(def_id) = candidate.source {\n+            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n+                debug!(\"Selected reservation impl\");\n+                // We assemble all candidates inside of a probe so by\n+                // making a new canonical response here our result will\n+                // have no constraints.\n+                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+            }\n+        }\n+\n+        candidate\n+    }\n }"}, {"sha": "4fea49893a6c6c2b86de4d31e832f5310253d453", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/654f43f34edded48a55fef2b515b4a7d0304c38e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654f43f34edded48a55fef2b515b4a7d0304c38e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=654f43f34edded48a55fef2b515b4a7d0304c38e", "patch": "@@ -1,9 +1,9 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::assembly::{self, Candidate, CandidateSource};\n+use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n-use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -34,7 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_project_candidates(candidates)\n+            self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = match predicate.term.unpack() {\n@@ -153,65 +153,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n     }\n-\n-    fn merge_project_candidates(\n-        &mut self,\n-        mut candidates: Vec<Candidate<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n-        }\n-\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.project_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n-                    }\n-                }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                // If there are *STILL* multiple candidates, give up\n-                // and report ambiguity.\n-                i += 1;\n-            }\n-\n-            if candidates.len() > 1 {\n-                let certainty = if candidates.iter().all(|x| {\n-                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n-                }) {\n-                    Certainty::Maybe(MaybeCause::Overflow)\n-                } else {\n-                    Certainty::AMBIGUOUS\n-                };\n-                return self.make_canonical_response(certainty);\n-            }\n-        }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn project_candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::BuiltinImpl, _)\n-            | (CandidateSource::AliasBound, _) => false,\n-        }\n-    }\n }\n \n impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {"}, {"sha": "abb69476caefb537cd93d88394ffce389743335a", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/654f43f34edded48a55fef2b515b4a7d0304c38e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654f43f34edded48a55fef2b515b4a7d0304c38e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=654f43f34edded48a55fef2b515b4a7d0304c38e", "patch": "@@ -2,9 +2,9 @@\n \n use std::iter;\n \n-use super::assembly::{self, Candidate, CandidateSource};\n+use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n@@ -479,80 +479,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_trait_candidates_discard_reservation_impls(candidates)\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn merge_trait_candidates_discard_reservation_impls(\n-        &mut self,\n-        mut candidates: Vec<Candidate<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n-            _ => {}\n-        }\n-\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.trait_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n-                    }\n-                }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                // If there are *STILL* multiple candidates, give up\n-                // and report ambiguity.\n-                i += 1;\n-            }\n-\n-            if candidates.len() > 1 {\n-                let certainty = if candidates.iter().all(|x| {\n-                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n-                }) {\n-                    Certainty::Maybe(MaybeCause::Overflow)\n-                } else {\n-                    Certainty::AMBIGUOUS\n-                };\n-                return self.make_canonical_response(certainty);\n-            }\n-        }\n-\n-        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n-    }\n-\n-    fn trait_candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => false,\n-        }\n-    }\n-\n-    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n-        if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n-                debug!(\"Selected reservation impl\");\n-                // We assemble all candidates inside of a probe so by\n-                // making a new canonical response here our result will\n-                // have no constraints.\n-                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n-            }\n-        }\n-\n-        candidate\n+        self.merge_candidates_and_discard_reservation_impls(candidates)\n     }\n }"}]}