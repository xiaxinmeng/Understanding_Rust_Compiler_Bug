{"sha": "10e71dfdb819ce9c2acee0b49c452b805c141041", "node_id": "C_kwDOAAsO6NoAKDEwZTcxZGZkYjgxOWNlOWMyYWNlZTBiNDljNDUyYjgwNWMxNDEwNDE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-15T09:58:27Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-21T10:54:26Z"}, "message": "Also validate types before inlining.", "tree": {"sha": "aaa9309762b5e1115a2fae5e21bd960b7b0d747d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaa9309762b5e1115a2fae5e21bd960b7b0d747d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10e71dfdb819ce9c2acee0b49c452b805c141041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10e71dfdb819ce9c2acee0b49c452b805c141041", "html_url": "https://github.com/rust-lang/rust/commit/10e71dfdb819ce9c2acee0b49c452b805c141041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10e71dfdb819ce9c2acee0b49c452b805c141041/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb", "html_url": "https://github.com/rust-lang/rust/commit/e4fd2bd7214dc2d3f8ec6a876b1687c9f3cf7beb"}], "stats": {"total": 130, "additions": 114, "deletions": 16}, "files": [{"sha": "1a14cd79fa0690a8cb618e702ca40e61548bca1a", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10e71dfdb819ce9c2acee0b49c452b805c141041/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e71dfdb819ce9c2acee0b49c452b805c141041/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=10e71dfdb819ce9c2acee0b49c452b805c141041", "patch": "@@ -89,22 +89,20 @@ pub fn equal_up_to_regions<'tcx>(\n \n     // Normalize lifetimes away on both sides, then compare.\n     let normalize = |ty: Ty<'tcx>| {\n-        tcx.normalize_erasing_regions(\n-            param_env,\n-            ty.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-                // since one may have an `impl SomeTrait for fn(&32)` and\n-                // `impl SomeTrait for fn(&'static u32)` at the same time which\n-                // specify distinct values for Assoc. (See also #56105)\n-                lt_op: |_| tcx.lifetimes.re_erased,\n-                // Leave consts and types unchanged.\n-                ct_op: |ct| ct,\n-                ty_op: |ty| ty,\n-            }),\n-        )\n+        let ty = ty.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n+            // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n+            // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n+            // since one may have an `impl SomeTrait for fn(&32)` and\n+            // `impl SomeTrait for fn(&'static u32)` at the same time which\n+            // specify distinct values for Assoc. (See also #56105)\n+            lt_op: |_| tcx.lifetimes.re_erased,\n+            // Leave consts and types unchanged.\n+            ct_op: |ct| ct,\n+            ty_op: |ty| ty,\n+        });\n+        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty)\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n }"}, {"sha": "b454d70d05dad0a9637ac228dd35193073f1d226", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/10e71dfdb819ce9c2acee0b49c452b805c141041/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e71dfdb819ce9c2acee0b49c452b805c141041/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=10e71dfdb819ce9c2acee0b49c452b805c141041", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n+use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n@@ -423,6 +424,7 @@ impl<'tcx> Inliner<'tcx> {\n             instance: callsite.callee,\n             callee_body,\n             cost: 0,\n+            validation: Ok(()),\n         };\n \n         // Traverse the MIR manually so we can account for the effects of inlining on the CFG.\n@@ -458,6 +460,9 @@ impl<'tcx> Inliner<'tcx> {\n             checker.visit_local_decl(v, &callee_body.local_decls[v]);\n         }\n \n+        // Abort if type validation found anything fishy.\n+        checker.validation?;\n+\n         let cost = checker.cost;\n         if let InlineAttr::Always = callee_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n@@ -738,6 +743,7 @@ struct CostChecker<'b, 'tcx> {\n     cost: usize,\n     callee_body: &'b Body<'tcx>,\n     instance: ty::Instance<'tcx>,\n+    validation: Result<(), &'static str>,\n }\n \n impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n@@ -818,6 +824,100 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n \n         self.super_local_decl(local, local_decl)\n     }\n+\n+    /// This method duplicates code from MIR validation in an attempt to detect type mismatches due\n+    /// to normalization failure.\n+    fn visit_projection_elem(\n+        &mut self,\n+        local: Local,\n+        proj_base: &[PlaceElem<'tcx>],\n+        elem: PlaceElem<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        if let ProjectionElem::Field(f, ty) = elem {\n+            let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n+            let parent_ty = parent.ty(&self.callee_body.local_decls, self.tcx);\n+            let check_equal = |this: &mut Self, f_ty| {\n+                if !equal_up_to_regions(this.tcx, this.param_env, ty, f_ty) {\n+                    trace!(?ty, ?f_ty);\n+                    this.validation = Err(\"failed to normalize projection type\");\n+                    return;\n+                }\n+            };\n+\n+            let kind = match parent_ty.ty.kind() {\n+                &ty::Opaque(def_id, substs) => {\n+                    self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n+                }\n+                kind => kind,\n+            };\n+\n+            match kind {\n+                ty::Tuple(fields) => {\n+                    let Some(f_ty) = fields.get(f.as_usize()) else {\n+                        self.validation = Err(\"malformed MIR\");\n+                        return;\n+                    };\n+                    check_equal(self, *f_ty);\n+                }\n+                ty::Adt(adt_def, substs) => {\n+                    let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n+                    let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n+                        self.validation = Err(\"malformed MIR\");\n+                        return;\n+                    };\n+                    check_equal(self, field.ty(self.tcx, substs));\n+                }\n+                ty::Closure(_, substs) => {\n+                    let substs = substs.as_closure();\n+                    let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n+                        self.validation = Err(\"malformed MIR\");\n+                        return;\n+                    };\n+                    check_equal(self, f_ty);\n+                }\n+                &ty::Generator(def_id, substs, _) => {\n+                    let f_ty = if let Some(var) = parent_ty.variant_index {\n+                        let gen_body = if def_id == self.callee_body.source.def_id() {\n+                            self.callee_body\n+                        } else {\n+                            self.tcx.optimized_mir(def_id)\n+                        };\n+\n+                        let Some(layout) = gen_body.generator_layout() else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        let Some(&local) = layout.variant_fields[var].get(f) else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        let Some(&f_ty) = layout.field_tys.get(local) else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        f_ty\n+                    } else {\n+                        let Some(f_ty) = substs.as_generator().prefix_tys().nth(f.index()) else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        f_ty\n+                    };\n+\n+                    check_equal(self, f_ty);\n+                }\n+                _ => self.validation = Err(\"malformed MIR\"),\n+            }\n+        }\n+\n+        self.super_projection_elem(local, proj_base, elem, context, location);\n+    }\n }\n \n /**"}]}