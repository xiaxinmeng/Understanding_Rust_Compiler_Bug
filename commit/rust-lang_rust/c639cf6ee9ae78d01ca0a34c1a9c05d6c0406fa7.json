{"sha": "c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MzljZjZlZTlhZTc4ZDAxY2EwYTM0YzFhOWMwNWQ2YzA0MDZmYTc=", "commit": {"author": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2014-12-16T20:40:43Z"}, "committer": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2014-12-24T17:18:27Z"}, "message": "rustdoc: Use unboxed closure sugar\n\nThis unfortunately leaves sugaring Fn/FnMut/FnOnce on cross-crate\nre-exports for future work.\n\ncc #19909", "tree": {"sha": "da3bc63e4b9604f42b5768f3ee8b04db9d4056cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da3bc63e4b9604f42b5768f3ee8b04db9d4056cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7", "html_url": "https://github.com/rust-lang/rust/commit/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7/comments", "author": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37225288be1f29ce15ad24855cdbbf06ba5890c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/37225288be1f29ce15ad24855cdbbf06ba5890c8", "html_url": "https://github.com/rust-lang/rust/commit/37225288be1f29ce15ad24855cdbbf06ba5890c8"}], "stats": {"total": 156, "additions": 98, "deletions": 58}, "files": [{"sha": "8dae353c64f61fe5732478512115886133ca5df0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7", "patch": "@@ -526,8 +526,10 @@ fn external_path(cx: &DocContext, name: &str, substs: &subst::Substs) -> Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            lifetimes: lifetimes,\n-            types: types,\n+            params: PathParameters::AngleBracketed {\n+                lifetimes: lifetimes,\n+                types: types,\n+            }\n         }],\n     }\n }\n@@ -1744,31 +1746,48 @@ impl Clean<Path> for ast::Path {\n }\n \n #[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n-pub struct PathSegment {\n-    pub name: String,\n-    pub lifetimes: Vec<Lifetime>,\n-    pub types: Vec<Type>,\n+pub enum PathParameters {\n+    AngleBracketed {\n+        lifetimes: Vec<Lifetime>,\n+        types: Vec<Type>,\n+    },\n+    Parenthesized {\n+        inputs: Vec<Type>,\n+        output: Option<Type>\n+    }\n }\n \n-impl Clean<PathSegment> for ast::PathSegment {\n-    fn clean(&self, cx: &DocContext) -> PathSegment {\n-        let (lifetimes, types) = match self.parameters {\n+impl Clean<PathParameters> for ast::PathParameters {\n+    fn clean(&self, cx: &DocContext) -> PathParameters {\n+        match *self {\n             ast::AngleBracketedParameters(ref data) => {\n-                (data.lifetimes.clean(cx), data.types.clean(cx))\n+                PathParameters::AngleBracketed {\n+                    lifetimes: data.lifetimes.clean(cx),\n+                    types: data.types.clean(cx)\n+                }\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n-                // FIXME -- rustdoc should be taught about Foo() notation\n-                let inputs = Tuple(data.inputs.clean(cx));\n-                let output = data.output.as_ref().map(|t| t.clean(cx)).unwrap_or(Tuple(Vec::new()));\n-                (Vec::new(), vec![inputs, output])\n+                PathParameters::Parenthesized {\n+                    inputs: data.inputs.clean(cx),\n+                    output: data.output.clean(cx)\n+                }\n             }\n-        };\n+        }\n+    }\n+}\n \n+#[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+pub struct PathSegment {\n+    pub name: String,\n+    pub params: PathParameters\n+}\n+\n+impl Clean<PathSegment> for ast::PathSegment {\n+    fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n             name: self.identifier.clean(cx),\n-            lifetimes: lifetimes,\n-            types: types,\n+            params: self.parameters.clean(cx)\n         }\n     }\n }\n@@ -2399,8 +2418,10 @@ fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n             global: false,\n             segments: vec![PathSegment {\n                 name: name.to_string(),\n-                lifetimes: vec![],\n-                types: vec![t.clean(cx)],\n+                params: PathParameters::AngleBracketed {\n+                    lifetimes: vec![],\n+                    types: vec![t.clean(cx)],\n+                }\n             }],\n         },\n     }"}, {"sha": "841588e401261d7d01fa73a1e0cfd2eaf885e1ed", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c639cf6ee9ae78d01ca0a34c1a9c05d6c0406fa7", "patch": "@@ -171,37 +171,69 @@ impl fmt::Show for clean::TyParamBound {\n     }\n }\n \n-impl fmt::Show for clean::Path {\n+impl fmt::Show for clean::PathParameters {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.global {\n-            try!(f.write(\"::\".as_bytes()))\n-        }\n-\n-        for (i, seg) in self.segments.iter().enumerate() {\n-            if i > 0 {\n-                try!(f.write(\"::\".as_bytes()))\n-            }\n-            try!(f.write(seg.name.as_bytes()));\n-\n-            if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                try!(f.write(\"&lt;\".as_bytes()));\n-                let mut comma = false;\n-                for lifetime in seg.lifetimes.iter() {\n-                    if comma {\n-                        try!(f.write(\", \".as_bytes()));\n+        match *self {\n+            clean::PathParameters::AngleBracketed { ref lifetimes, ref types } => {\n+                if lifetimes.len() > 0 || types.len() > 0 {\n+                    try!(f.write(\"&lt;\".as_bytes()));\n+                    let mut comma = false;\n+                    for lifetime in lifetimes.iter() {\n+                        if comma {\n+                            try!(f.write(\", \".as_bytes()));\n+                        }\n+                        comma = true;\n+                        try!(write!(f, \"{}\", *lifetime));\n                     }\n-                    comma = true;\n-                    try!(write!(f, \"{}\", *lifetime));\n+                    for ty in types.iter() {\n+                        if comma {\n+                            try!(f.write(\", \".as_bytes()));\n+                        }\n+                        comma = true;\n+                        try!(write!(f, \"{}\", *ty));\n+                    }\n+                    try!(f.write(\"&gt;\".as_bytes()));\n                 }\n-                for ty in seg.types.iter() {\n+            }\n+            clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n+                try!(f.write(\"(\".as_bytes()));\n+                let mut comma = false;\n+                for ty in inputs.iter() {\n                     if comma {\n                         try!(f.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n                     try!(write!(f, \"{}\", *ty));\n                 }\n-                try!(f.write(\"&gt;\".as_bytes()));\n+                try!(f.write(\")\".as_bytes()));\n+                if let Some(ref ty) = *output {\n+                    try!(f.write(\" -&gt; \".as_bytes()));\n+                    try!(write!(f, \"{}\", ty));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Show for clean::PathSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(f.write(self.name.as_bytes()));\n+        write!(f, \"{}\", self.params)\n+    }\n+}\n+\n+impl fmt::Show for clean::Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.global {\n+            try!(f.write(\"::\".as_bytes()))\n+        }\n+\n+        for (i, seg) in self.segments.iter().enumerate() {\n+            if i > 0 {\n+                try!(f.write(\"::\".as_bytes()))\n             }\n+            try!(write!(f, \"{}\", seg));\n         }\n         Ok(())\n     }\n@@ -243,23 +275,8 @@ fn path<F, G>(w: &mut fmt::Formatter,\n     G: FnOnce(&render::Cache) -> Option<(Vec<String>, ItemType)>,\n {\n     // The generics will get written to both the title and link\n-    let mut generics = String::new();\n     let last = path.segments.last().unwrap();\n-    if last.lifetimes.len() > 0 || last.types.len() > 0 {\n-        let mut counter = 0u;\n-        generics.push_str(\"&lt;\");\n-        for lifetime in last.lifetimes.iter() {\n-            if counter > 0 { generics.push_str(\", \"); }\n-            counter += 1;\n-            generics.push_str(format!(\"{}\", *lifetime).as_slice());\n-        }\n-        for ty in last.types.iter() {\n-            if counter > 0 { generics.push_str(\", \"); }\n-            counter += 1;\n-            generics.push_str(format!(\"{}\", *ty).as_slice());\n-        }\n-        generics.push_str(\"&gt;\");\n-    }\n+    let generics = format!(\"{}\", last.params);\n \n     let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n     let cache = cache();\n@@ -660,8 +677,10 @@ impl fmt::Show for clean::ViewListIdent {\n                     global: false,\n                     segments: vec!(clean::PathSegment {\n                         name: self.name.clone(),\n-                        lifetimes: Vec::new(),\n-                        types: Vec::new(),\n+                        params: clean::PathParameters::AngleBracketed {\n+                            lifetimes: Vec::new(),\n+                            types: Vec::new(),\n+                        }\n                     })\n                 };\n                 resolved_path(f, did, &path, false)"}]}