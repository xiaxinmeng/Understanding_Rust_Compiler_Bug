{"sha": "e244f103c9622ef0d13b138ec6f8425840201def", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNDRmMTAzYzk2MjJlZjBkMTNiMTM4ZWM2Zjg0MjU4NDAyMDFkZWY=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@mozilla.com", "date": "2013-02-15T09:15:53Z"}, "committer": {"name": "Luqman Aden", "email": "laden@mozilla.com", "date": "2013-02-15T10:49:55Z"}, "message": "libsyntax: Get rid of uses of `move` and don't parse it.", "tree": {"sha": "90dfaa8da5f602e30f05597a12be1d6f81e6f512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90dfaa8da5f602e30f05597a12be1d6f81e6f512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e244f103c9622ef0d13b138ec6f8425840201def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e244f103c9622ef0d13b138ec6f8425840201def", "html_url": "https://github.com/rust-lang/rust/commit/e244f103c9622ef0d13b138ec6f8425840201def", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e244f103c9622ef0d13b138ec6f8425840201def/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99b3c07b4e788d7120c2754f69613f760a6efd0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/99b3c07b4e788d7120c2754f69613f760a6efd0a", "html_url": "https://github.com/rust-lang/rust/commit/99b3c07b4e788d7120c2754f69613f760a6efd0a"}], "stats": {"total": 253, "additions": 123, "deletions": 130}, "files": [{"sha": "893647ca9ad82a4058bc78d11a3df26edc204412", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -270,7 +270,7 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     // This is sort of stupid here, converting to a vec of mutables and back\n     let mut v: ~[@ast::meta_item] = items;\n     std::sort::quick_sort(v, lteq);\n-    move v\n+    v\n }\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->"}, {"sha": "3c61e834af6f2a33c48108a710a4a6bc31b858ce", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -152,15 +152,15 @@ pub impl<D: Decoder> span: Decodable<D> {\n }\n \n pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n-    respan(mk_sp(lo, hi), move t)\n+    respan(mk_sp(lo, hi), t)\n }\n \n pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n-    respan(dummy_sp(), move t)\n+    respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */"}, {"sha": "33eaaaae35b3e8f7b0652553d7191a89642e3034", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -281,7 +281,7 @@ pub fn mk_ctxt(parse_sess: parse::parse_sess,\n         mod_path: ~[],\n         trace_mac: false\n     };\n-    move ((move imp) as @ext_ctxt)\n+    ((imp) as @ext_ctxt)\n }\n \n pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {"}, {"sha": "963ea5bfe3329879adf68133620603bed6c82da4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -73,7 +73,7 @@ pub fn mk_raw_path_(sp: span,\n                  global: false,\n                  idents: idents,\n                  rp: None,\n-                 types: move types }\n+                 types: types }\n }\n pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::path {\n     @ast::path { span: sp,\n@@ -156,7 +156,7 @@ pub fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n }\n pub fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}])\n               -> ~[ast::field] {\n-    move fields.map(|f| mk_field(sp, f))\n+    fields.map(|f| mk_field(sp, f))\n }\n pub fn mk_rec_e(cx: ext_ctxt,\n                 sp: span,\n@@ -288,41 +288,41 @@ pub fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n                                       bm: ast::binding_mode) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);\n     let pat = ast::pat_ident(bm, path, None);\n-    mk_pat(cx, span, move pat)\n+    mk_pat(cx, span, pat)\n }\n pub fn mk_pat_enum(cx: ext_ctxt,\n                    span: span,\n                    path: @ast::path,\n                    +subpats: ~[@ast::pat])\n                 -> @ast::pat {\n-    let pat = ast::pat_enum(path, Some(move subpats));\n-    mk_pat(cx, span, move pat)\n+    let pat = ast::pat_enum(path, Some(subpats));\n+    mk_pat(cx, span, pat)\n }\n pub fn mk_pat_struct(cx: ext_ctxt,\n                      span: span,\n                      path: @ast::path,\n                      +field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n-    let pat = ast::pat_struct(path, move field_pats, false);\n-    mk_pat(cx, span, move pat)\n+    let pat = ast::pat_struct(path, field_pats, false);\n+    mk_pat(cx, span, pat)\n }\n pub fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@codemap::spanned {\n         node: ast::lit_bool(value),\n         span: span });\n-    build::mk_expr(cx, span, move lit_expr)\n+    build::mk_expr(cx, span, lit_expr)\n }\n pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @codemap::spanned { node: move stmt_, span: span }\n+    @codemap::spanned { node: stmt_, span: span }\n }\n pub fn mk_ty_path(cx: ext_ctxt,\n                   span: span,\n                   idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n+    let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n pub fn mk_ty_path_global(cx: ext_ctxt,\n@@ -331,7 +331,7 @@ pub fn mk_ty_path_global(cx: ext_ctxt,\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n+    let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n pub fn mk_simple_ty_path(cx: ext_ctxt,"}, {"sha": "1aa1d8ca9a07eeaedb1620075a02fb5b5f6f7bf7", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -95,27 +95,27 @@ fn expand_deriving(cx: ext_ctxt,\n                                                        span,\n                                                        struct_def,\n                                                        item.ident,\n-                                                       move ty_params));\n+                                                       ty_params));\n             }\n             item_enum(ref enum_definition, copy ty_params) => {\n                 result.push(expand_deriving_enum_def(cx,\n                                                      span,\n                                                      enum_definition,\n                                                      item.ident,\n-                                                     move ty_params));\n+                                                     ty_params));\n             }\n             _ => ()\n         }\n     }\n-    dvec::unwrap(move result)\n+    dvec::unwrap(result)\n }\n \n fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n     @ast::item {\n         ident: clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: move item,\n+        node: item,\n         vis: public,\n         span: span,\n     }\n@@ -161,7 +161,7 @@ fn create_eq_method(cx: ext_ctxt,\n     };\n \n     // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[ move arg ], output_type);\n+    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n \n     // Create the body block.\n     let body_block = build::mk_simple_block(cx, span, body);\n@@ -174,8 +174,8 @@ fn create_eq_method(cx: ext_ctxt,\n         tps: ~[],\n         self_ty: self_ty,\n         purity: pure_fn,\n-        decl: move fn_decl,\n-        body: move body_block,\n+        decl: fn_decl,\n+        body: body_block,\n         id: cx.next_id(),\n         span: span,\n         self_id: cx.next_id(),\n@@ -194,14 +194,14 @@ fn create_self_type_with_params(cx: ext_ctxt,\n         let self_ty_param = build::mk_simple_ty_path(cx,\n                                                      span,\n                                                      ty_param.ident);\n-        self_ty_params.push(move self_ty_param);\n+        self_ty_params.push(self_ty_param);\n     }\n-    let self_ty_params = dvec::unwrap(move self_ty_params);\n+    let self_ty_params = dvec::unwrap(self_ty_params);\n \n     // Create the type of `self`.\n     let self_type = build::mk_raw_path_(span,\n                                         ~[ type_ident ],\n-                                        move self_ty_params);\n+                                        self_ty_params);\n     let self_type = ty_path(self_type, cx.next_id());\n     @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n }\n@@ -221,9 +221,9 @@ fn create_derived_impl(cx: ext_ctxt,\n                                              trait_path.map(|x| *x));\n         let bounds = @~[ TraitTyParamBound(bound) ];\n         let impl_ty_param = build::mk_ty_param(cx, ty_param.ident, bounds);\n-        impl_ty_params.push(move impl_ty_param);\n+        impl_ty_params.push(impl_ty_param);\n     }\n-    let impl_ty_params = dvec::unwrap(move impl_ty_params);\n+    let impl_ty_params = dvec::unwrap(impl_ty_params);\n \n     // Create the reference to the trait.\n     let trait_path = ast::path {\n@@ -233,12 +233,12 @@ fn create_derived_impl(cx: ext_ctxt,\n         rp: None,\n         types: ~[]\n     };\n-    let trait_path = @move trait_path;\n+    let trait_path = @trait_path;\n     let trait_ref = ast::trait_ref {\n         path: trait_path,\n         ref_id: cx.next_id()\n     };\n-    let trait_ref = @move trait_ref;\n+    let trait_ref = @trait_ref;\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n@@ -247,11 +247,11 @@ fn create_derived_impl(cx: ext_ctxt,\n                                                  ty_params);\n \n     // Create the impl item.\n-    let impl_item = item_impl(move impl_ty_params,\n+    let impl_item = item_impl(impl_ty_params,\n                               Some(trait_ref),\n                               self_type,\n                               methods.map(|x| *x));\n-    return create_impl_item(cx, span, move impl_item);\n+    return create_impl_item(cx, span, impl_item);\n }\n \n fn create_derived_eq_impl(cx: ext_ctxt,\n@@ -310,11 +310,11 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n \n     // Create the function declaration.\n-    let inputs = ~[ move lsb0_arg, move f_arg ];\n-    let fn_decl = build::mk_fn_decl(move inputs, output_type);\n+    let inputs = ~[ lsb0_arg, f_arg ];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = build::mk_block_(cx, span, move statements);\n+    let body_block = build::mk_block_(cx, span, statements);\n \n     // Create the method.\n     let self_ty = spanned { node: sty_region(m_imm), span: span };\n@@ -325,8 +325,8 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n         tps: ~[],\n         self_ty: self_ty,\n         purity: pure_fn,\n-        decl: move fn_decl,\n-        body: move body_block,\n+        decl: fn_decl,\n+        body: body_block,\n         id: cx.next_id(),\n         span: span,\n         self_id: cx.next_id(),\n@@ -348,10 +348,10 @@ fn create_subpatterns(cx: ext_ctxt,\n         // Create the subpattern.\n         let subpath = build::mk_raw_path(span, ~[ ident ]);\n         let subpat = pat_ident(bind_by_ref(m_imm), subpath, None);\n-        let subpat = build::mk_pat(cx, span, move subpat);\n+        let subpat = build::mk_pat(cx, span, subpat);\n         subpats.push(subpat);\n     }\n-    return dvec::unwrap(move subpats);\n+    return dvec::unwrap(subpats);\n }\n \n fn create_enum_variant_pattern(cx: ext_ctxt,\n@@ -373,7 +373,7 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n                                              prefix,\n                                              variant_args.len());\n \n-            return build::mk_pat_enum(cx, span, matching_path, move subpats);\n+            return build::mk_pat_enum(cx, span, matching_path, subpats);\n         }\n         struct_variant_kind(struct_def) => {\n             let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n@@ -508,7 +508,7 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  move ty_params,\n+                                  ty_params,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -541,7 +541,7 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  move ty_params,\n+                                  ty_params,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -561,7 +561,7 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          move ty_params,\n+                                          ty_params,\n                                           method);\n }\n \n@@ -580,7 +580,7 @@ fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          move ty_params,\n+                                          ty_params,\n                                           method);\n }\n \n@@ -671,8 +671,8 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     }\n \n     // Create the method itself.\n-    let statements = dvec::unwrap(move statements);\n-    return create_iter_bytes_method(cx, span, move statements);\n+    let statements = dvec::unwrap(statements);\n+    return create_iter_bytes_method(cx, span, statements);\n }\n \n fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n@@ -738,9 +738,9 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         let matching_arm = ast::arm {\n             pats: ~[ matching_pat ],\n             guard: None,\n-            body: move matching_body_block\n+            body: matching_body_block\n         };\n-        other_arms.push(move matching_arm);\n+        other_arms.push(matching_arm);\n \n         // Maybe generate a non-matching case. If there is only one\n         // variant then there will always be a match.\n@@ -777,11 +777,11 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         // Create the self pattern body.\n         let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n         let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_arms = dvec::unwrap(move other_arms);\n-        let other_match_expr = expr_match(other_expr, move other_arms);\n+        let other_arms = dvec::unwrap(other_arms);\n+        let other_match_expr = expr_match(other_expr, other_arms);\n         let other_match_expr = build::mk_expr(cx,\n                                               span,\n-                                              move other_match_expr);\n+                                              other_match_expr);\n         let other_match_body_block = build::mk_simple_block(cx,\n                                                             span,\n                                                             other_match_expr);\n@@ -792,15 +792,15 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n             guard: None,\n             body: other_match_body_block,\n         };\n-        self_arms.push(move self_arm);\n+        self_arms.push(self_arm);\n     }\n \n     // Create the method body.\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_arms = dvec::unwrap(move self_arms);\n-    let self_match_expr = expr_match(self_expr, move self_arms);\n-    let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n+    let self_arms = dvec::unwrap(self_arms);\n+    let self_match_expr = expr_match(self_expr, self_arms);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n \n     // Create the method.\n     return create_eq_method(cx,\n@@ -848,8 +848,8 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         }\n \n         // Create the pattern body.\n-        let stmts = dvec::unwrap(move stmts);\n-        let match_body_block = build::mk_block_(cx, span, move stmts);\n+        let stmts = dvec::unwrap(stmts);\n+        let match_body_block = build::mk_block_(cx, span, stmts);\n \n         // Create the arm.\n         ast::arm {"}, {"sha": "c690c89c025f2fb8b6c34c710f12ced4600b9ac5", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -53,7 +53,7 @@ pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }\n-        move bv\n+        bv\n     };\n \n     let mut i = 0;"}, {"sha": "0f596e661583dae323d60b260641dcb76ba8b8a0", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -73,10 +73,10 @@ pub impl message: gen_send {\n \n             if this.proto.is_bounded() {\n                 let (sp, rp) = match (this.dir, next.dir) {\n-                  (send, send) => (~\"move c\", ~\"move s\"),\n+                  (send, send) => (~\"c\", ~\"s\"),\n                   (send, recv) => (~\"s\", ~\"c\"),\n                   (recv, send) => (~\"s\", ~\"c\"),\n-                  (recv, recv) => (~\"move c\", ~\"move s\")\n+                  (recv, recv) => (~\"c\", ~\"s\")\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n@@ -89,28 +89,28 @@ pub impl message: gen_send {\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n-                  (send, send) => \"(move c, move s)\",\n+                  (send, send) => \"(c, s)\",\n                   (send, recv) => \"(s, c)\",\n                   (recv, send) => \"(s, c)\",\n-                  (recv, recv) => \"(move c, move s)\"\n+                  (recv, recv) => \"(c, s)\"\n                 };\n \n                 body += fmt!(\"let %s = ::pipes::entangle();\\n\", pat);\n             }\n             body += fmt!(\"let message = %s(%s);\\n\",\n                          self.name(),\n                          str::connect(vec::append_one(\n-                           arg_names.map(|x| ~\"move \" + cx.str_of(*x)),\n-                             ~\"move s\"), ~\", \"));\n+                           arg_names.map(|x| cx.str_of(*x)),\n+                             ~\"s\"), ~\", \"));\n \n             if !try {\n-                body += fmt!(\"::pipes::send(move pipe, move message);\\n\");\n+                body += fmt!(\"::pipes::send(pipe, message);\\n\");\n                 // return the new channel\n-                body += ~\"move c }\";\n+                body += ~\"c }\";\n             }\n             else {\n-                body += fmt!(\"if ::pipes::send(move pipe, move message) {\\n \\\n-                                  ::pipes::rt::make_some(move c) \\\n+                body += fmt!(\"if ::pipes::send(pipe, message) {\\n \\\n+                                  ::pipes::rt::make_some(c) \\\n                               } else { ::pipes::rt::make_none() } }\");\n             }\n \n@@ -153,7 +153,7 @@ pub impl message: gen_send {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| ~\"move \" + *x),\n+                    ~\"(\" + str::connect(arg_names.map(|x| *x),\n                                         ~\", \") + ~\")\"\n                 };\n \n@@ -164,10 +164,10 @@ pub impl message: gen_send {\n                              message_args);\n \n                 if !try {\n-                    body += fmt!(\"::pipes::send(move pipe, move message);\\n\");\n+                    body += fmt!(\"::pipes::send(pipe, message);\\n\");\n                     body += ~\" }\";\n                 } else {\n-                    body += fmt!(\"if ::pipes::send(move pipe, move message) \\\n+                    body += fmt!(\"if ::pipes::send(pipe, message) \\\n                                         { \\\n                                       ::pipes::rt::make_some(()) \\\n                                   } else { \\\n@@ -319,7 +319,7 @@ pub impl protocol: gen_init {\n               recv => {\n                 quote_expr!({\n                     let (s, c) = ::pipes::entangle();\n-                    (move c, move s)\n+                    (c, s)\n                 })\n               }\n             }\n@@ -331,7 +331,7 @@ pub impl protocol: gen_init {\n               recv => {\n                   quote_expr!({\n                       let (s, c) = $body;\n-                      (move c, move s)\n+                      (c, s)\n                   })\n               }\n             }\n@@ -375,7 +375,7 @@ pub impl protocol: gen_init {\n \n         quote_expr!({\n             let buffer = $buffer;\n-            do ::pipes::entangle_buffer(move buffer) |buffer, data| {\n+            do ::pipes::entangle_buffer(buffer) |buffer, data| {\n                 $entangle_body\n             }\n         })"}, {"sha": "1d6534aef3464703d022885e12748c60b0d3e24c", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -207,7 +207,7 @@ pub impl protocol {\n             span: self.span,\n             dir: dir,\n             ty_params: ty_params,\n-            messages: move messages,\n+            messages: messages,\n             proto: self\n         });\n "}, {"sha": "df10f15c709cb6cf2be2b8b327fa6101eb1ead4a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -279,7 +279,7 @@ pub fn parse(sess: parse_sess,\n                         }\n \n                         new_pos.idx += 1;\n-                        cur_eis.push(move new_pos);\n+                        cur_eis.push(new_pos);\n                     }\n \n                     // can we go around again?\n@@ -288,19 +288,19 @@ pub fn parse(sess: parse_sess,\n                     match copy ei.sep {\n                       Some(ref t) if idx == len => { // we need a separator\n                         if tok == (*t) { //pass the separator\n-                            let ei_t = move ei;\n+                            let ei_t = ei;\n                             ei_t.idx += 1;\n-                            next_eis.push(move ei_t);\n+                            next_eis.push(ei_t);\n                         }\n                       }\n                       _ => { // we don't need a separator\n-                        let ei_t = move ei;\n+                        let ei_t = ei;\n                         ei_t.idx = 0;\n-                        cur_eis.push(move ei_t);\n+                        cur_eis.push(ei_t);\n                       }\n                     }\n                 } else {\n-                    eof_eis.push(move ei);\n+                    eof_eis.push(ei);\n                 }\n             } else {\n                 match copy ei.elts[idx].node {\n@@ -315,26 +315,26 @@ pub fn parse(sess: parse_sess,\n                             new_ei.matches[idx].push(@matched_seq(~[], sp));\n                         }\n \n-                        cur_eis.push(move new_ei);\n+                        cur_eis.push(new_ei);\n                     }\n \n                     let matches = vec::map(ei.matches, // fresh, same size:\n                                            |_m| DVec::<@named_match>());\n-                    let ei_t = move ei;\n+                    let ei_t = ei;\n                     cur_eis.push(~{\n                         elts: (*matchers), sep: (*sep), mut idx: 0u,\n-                        mut up: matcher_pos_up(Some(move ei_t)),\n-                        matches: move matches,\n+                        mut up: matcher_pos_up(Some(ei_t)),\n+                        matches: matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n                     });\n                   }\n-                  match_nonterminal(_,_,_) => { bb_eis.push(move ei) }\n+                  match_nonterminal(_,_,_) => { bb_eis.push(ei) }\n                   match_tok(ref t) => {\n-                    let ei_t = move ei;\n+                    let ei_t = ei;\n                     if (*t) == tok {\n                         ei_t.idx += 1;\n-                        next_eis.push(move ei_t);\n+                        next_eis.push(ei_t);\n                     }\n                   }\n                 }\n@@ -388,7 +388,7 @@ pub fn parse(sess: parse_sess,\n                   }\n                   _ => fail!()\n                 }\n-                cur_eis.push(move ei);\n+                cur_eis.push(ei);\n \n                 for rust_parser.tokens_consumed.times() || {\n                     rdr.next_token();"}, {"sha": "ff9a353ee92bbe3f396af0bd7a6df968aa7effaf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -252,7 +252,7 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               };\n             item_trait(fold_ty_params(tps, fld),\n                        vec::map(traits, |p| fold_trait_ref(*p, fld)),\n-                       move methods)\n+                       methods)\n           }\n       item_mac(ref m) => {\n         // FIXME #2888: we might actually want to do something here."}, {"sha": "82c1697bf72b01497886fc07ced61102c19c8734", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -151,7 +151,7 @@ pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n     p.abort_if_errors();\n-    move r\n+    r\n }\n \n pub fn next_node_id(sess: parse_sess) -> node_id {\n@@ -177,16 +177,16 @@ pub fn new_parser_from_file(sess: parse_sess,\n                             path: &Path)\n                          -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n-      result::Ok(move src) => {\n+      result::Ok(src) => {\n \n-          let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n+          let filemap = sess.cm.new_filemap(path.to_str(), @src);\n           let srdr = lexer::new_string_reader(sess.span_diagnostic,\n                                               filemap,\n                                               sess.interner);\n           Ok(Parser(sess, cfg, srdr as reader))\n \n       }\n-      result::Err(move e) => Err(move e)\n+      result::Err(e) => Err(e)\n     }\n }\n \n@@ -195,8 +195,8 @@ pub fn new_parser_from_file(sess: parse_sess,\n pub fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                               path: &Path) -> Parser {\n     match new_parser_from_file(sess, cfg, path) {\n-        Ok(move parser) => move parser,\n-        Err(move e) => {\n+        Ok(parser) => parser,\n+        Err(e) => {\n             sess.span_diagnostic.handler().fatal(e)\n         }\n     }\n@@ -207,8 +207,8 @@ pub fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n pub fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                             path: &Path, sp: span) -> Parser {\n     match new_parser_from_file(sess, cfg, path) {\n-        Ok(move parser) => move parser,\n-        Err(move e) => {\n+        Ok(parser) => parser,\n+        Err(e) => {\n             sess.span_diagnostic.span_fatal(sp, e)\n         }\n     }"}, {"sha": "f6fd894192e77a2adbdf74a25a5d2b489157a369", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -190,8 +190,8 @@ pub fn Parser(sess: parse_sess\n     let interner = rdr.interner();\n \n     Parser {\n-        reader: move rdr,\n-        interner: move interner,\n+        reader: rdr,\n+        interner: interner,\n         sess: sess,\n         cfg: cfg,\n         token: tok0.tok,\n@@ -1083,9 +1083,6 @@ pub impl Parser {\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n-        } else if self.eat_keyword(~\"move\") {\n-            // XXX move keyword is no longer important, remove after snapshot\n-            return self.parse_expr();\n         } else if self.token == token::MOD_SEP ||\n             is_ident(self.token) && !self.is_keyword(~\"true\") &&\n             !self.is_keyword(~\"false\") {\n@@ -1197,7 +1194,7 @@ pub impl Parser {\n                             hi = self.span.hi;\n \n                             let nd = expr_method_call(e, i, tys, es, NoSugar);\n-                            e = self.mk_expr(lo, hi, move nd);\n+                            e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n                             e = self.mk_expr(lo, hi, expr_field(e, i, tys));\n@@ -2099,10 +2096,6 @@ pub impl Parser {\n             } else if self.eat_keyword(~\"copy\") {\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n-                if self.eat_keyword(~\"move\") {\n-                    /* XXX---remove move keyword */\n-                }\n-\n                 // XXX---refutable match bindings should work same as let\n                 let binding_mode =\n                     if refutable {bind_infer} else {bind_by_copy};\n@@ -2372,7 +2365,7 @@ pub impl Parser {\n             self.obsolete(copy self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(token::LBRACE);\n-        let {inner: move inner, next: move next} =\n+        let {inner: inner, next: next} =\n             maybe_parse_inner_attrs_and_next(self, parse_attrs);\n         return (inner, self.parse_block_tail_(lo, default_blk, next));\n     }\n@@ -2397,8 +2390,8 @@ pub impl Parser {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n-        let {attrs_remaining: move attrs_remaining,\n-             view_items: move view_items,\n+        let {attrs_remaining: attrs_remaining,\n+             view_items: view_items,\n              items: items, _} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                             IMPORTS_AND_ITEMS_ALLOWED, false);\n@@ -2570,7 +2563,7 @@ pub impl Parser {\n                 }\n             }\n         }\n-        return @move bounds;\n+        return @bounds;\n     }\n \n     fn parse_ty_param() -> ty_param {\n@@ -3083,13 +3076,13 @@ pub impl Parser {\n     fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining: move attrs_remaining,\n-             view_items: move view_items,\n+        let {attrs_remaining: attrs_remaining,\n+             view_items: view_items,\n              items: starting_items, _} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                             VIEW_ITEMS_AND_ITEMS_ALLOWED,\n                                             true);\n-        let mut items: ~[@item] = move starting_items;\n+        let mut items: ~[@item] = starting_items;\n \n         let mut first = true;\n         while self.token != term {\n@@ -3140,7 +3133,7 @@ pub impl Parser {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n             let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n-            (id, m, Some(move attrs))\n+            (id, m, Some(attrs))\n         } else {\n             self.push_mod_path(id, outer_attrs);\n             self.expect(token::LBRACE);\n@@ -3300,9 +3293,9 @@ pub impl Parser {\n     fn parse_foreign_item(+attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n         if self.is_keyword(~\"const\") {\n-            self.parse_item_foreign_const(vis, move attrs)\n+            self.parse_item_foreign_const(vis, attrs)\n         } else {\n-            self.parse_item_foreign_fn( move attrs)\n+            self.parse_item_foreign_fn(attrs)\n         }\n     }\n \n@@ -3311,15 +3304,15 @@ pub impl Parser {\n                                +first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining: move attrs_remaining,\n-             view_items: move view_items,\n+        let {attrs_remaining: attrs_remaining,\n+             view_items: view_items,\n              items: _,\n-             foreign_items: move foreign_items} =\n+             foreign_items: foreign_items} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                          VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n                                             true);\n \n-        let mut items: ~[@foreign_item] = move foreign_items;\n+        let mut items: ~[@foreign_item] = foreign_items;\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n             let attrs = vec::append(initial_attrs,\n@@ -3329,7 +3322,7 @@ pub impl Parser {\n         }\n         ast::foreign_mod {\n             sort: sort,\n-            abi: move abi,\n+            abi: abi,\n             view_items: view_items,\n             items: items\n         }\n@@ -3382,14 +3375,14 @@ pub impl Parser {\n         // extern mod { ... }\n         if items_allowed && self.eat(token::LBRACE) {\n             let abi;\n-            match move abi_opt {\n-                Some(move found_abi) => abi = move found_abi,\n+            match abi_opt {\n+                Some(found_abi) => abi = found_abi,\n                 None => abi = special_idents::c_abi,\n             }\n \n             let extra_attrs = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(sort,\n-                                                 move abi,\n+                                                 abi,\n                                                  extra_attrs.next);\n             self.expect(token::RBRACE);\n \n@@ -3513,7 +3506,7 @@ pub impl Parser {\n                 ident = self.parse_ident();\n                 self.expect(token::LBRACE);\n                 let nested_enum_def = self.parse_enum_def(ty_params);\n-                kind = enum_variant_kind(move nested_enum_def);\n+                kind = enum_variant_kind(nested_enum_def);\n                 needs_comma = false;\n             } else {\n                 ident = self.parse_value_ident();"}, {"sha": "a30447d968e1de57a8cafdae450b1d5301499981", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -147,11 +147,11 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n         space: linewidth as int,\n         left: 0,\n         right: 0,\n-        token: move token,\n-        size: move size,\n+        token: token,\n+        size: size,\n         left_total: 0,\n         right_total: 0,\n-        scan_stack: move scan_stack,\n+        scan_stack: scan_stack,\n         scan_stack_empty: true,\n         top: 0,\n         bottom: 0,"}, {"sha": "0677e25a3fedf380c54f7bf297050f0bbb0c56f3", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e244f103c9622ef0d13b138ec6f8425840201def/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e244f103c9622ef0d13b138ec6f8425840201def", "patch": "@@ -24,7 +24,7 @@ pub fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n     let m = oldmap::HashMap::<T, uint>();\n     let hi: hash_interner<T> =\n         {map: m, vect: DVec()};\n-    move ((move hi) as Interner::<T>)\n+    ((hi) as Interner::<T>)\n }\n \n pub fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: &[T]) -> Interner<T> {"}]}