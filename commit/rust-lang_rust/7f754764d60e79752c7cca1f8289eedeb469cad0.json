{"sha": "7f754764d60e79752c7cca1f8289eedeb469cad0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNzU0NzY0ZDYwZTc5NzUyYzdjY2ExZjgyODllZWRlYjQ2OWNhZDA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-14T15:27:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-01-18T00:54:11Z"}, "message": "replace treemap with a balanced tree", "tree": {"sha": "4b4964329ea14d1de4f117c5dc7413896fb75154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b4964329ea14d1de4f117c5dc7413896fb75154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f754764d60e79752c7cca1f8289eedeb469cad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f754764d60e79752c7cca1f8289eedeb469cad0", "html_url": "https://github.com/rust-lang/rust/commit/7f754764d60e79752c7cca1f8289eedeb469cad0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f754764d60e79752c7cca1f8289eedeb469cad0/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f7514bfaeef44077c5ecb78fb8571e6f0979ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f7514bfaeef44077c5ecb78fb8571e6f0979ece", "html_url": "https://github.com/rust-lang/rust/commit/9f7514bfaeef44077c5ecb78fb8571e6f0979ece"}], "stats": {"total": 794, "additions": 667, "deletions": 127}, "files": [{"sha": "35a6be135c70a1ce0c974be6743d28e26d60a168", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 667, "deletions": 127, "changes": 794, "blob_url": "https://github.com/rust-lang/rust/blob/7f754764d60e79752c7cca1f8289eedeb469cad0/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f754764d60e79752c7cca1f8289eedeb469cad0/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=7f754764d60e79752c7cca1f8289eedeb469cad0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,187 +8,727 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * A key,value store that works on anything.\n- *\n- * This works using a binary search tree. In the first version, it's a\n- * very naive algorithm, but it will probably be updated to be a\n- * red-black tree or something else.\n- */\n+//! An ordered map and set implemented as self-balancing binary search\n+//! trees. The only requirement for the types is that the key implements\n+//! `Ord`, and that the `lt` method provides a total ordering.\n+\n #[forbid(deprecated_mode)];\n \n use core::cmp::{Eq, Ord};\n use core::option::{Option, Some, None};\n use core::prelude::*;\n \n-pub type TreeMap<K: Copy Eq Ord, V: Copy> = @mut TreeEdge<K, V>;\n+// This is implemented as an AA tree, which is a simplified variation of\n+// a red-black tree where where red (horizontal) nodes can only be added\n+// as a right child. The time complexity is the same, and re-balancing\n+// operations are more frequent but also cheaper.\n \n-type TreeEdge<K: Copy Eq Ord, V: Copy> = Option<@TreeNode<K, V>>;\n+// TODO: lazy iteration, for O(n) Eq and set operations instead of O(n*log(m))\n \n-struct TreeNode<K: Copy Eq Ord, V: Copy> {\n-    key: K,\n-    mut value: V,\n-    mut left: TreeEdge<K, V>,\n-    mut right: TreeEdge<K, V>\n-}\n-\n-/// Create a treemap\n-pub fn TreeMap<K: Copy Eq Ord, V: Copy>() -> TreeMap<K, V> { @mut None }\n-\n-/// Insert a value into the map\n-pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, k: K, v: V) {\n-    match copy *m {\n-      None => {\n-        *m = Some(@TreeNode {key: k,\n-                             mut value: v,\n-                             mut left: None,\n-                             mut right: None});\n-        return;\n-      }\n-      Some(node) => {\n-        if k == node.key {\n-            node.value = v;\n-        } else if k < node.key {\n-            insert(&mut node.left, k, v);\n-        } else {\n-            insert(&mut node.right, k, v);\n+// TODO: implement Ord for TreeSet\n+// could be superset/subset-based or in-order lexicographic comparison... but\n+// there are methods for is_superset/is_subset so lexicographic is more useful\n+\n+// TODO: (possibly) implement the overloads Python does for sets:\n+//   * union: |\n+//   * intersection: &\n+//   * difference: -\n+//   * symmetric difference: ^\n+// These would be convenient since the methods will work like `each`\n+\n+pub struct TreeMap<K: Ord, V> {\n+    priv root: Option<~TreeNode<K, V>>,\n+    priv length: uint\n+}\n+\n+// FIXME: this is a naive O(n*log(m)) implementation, could be O(n)\n+impl <K: Ord, V: Eq> TreeMap<K, V>: Eq {\n+    pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n+        if self.len() != other.len() {\n+            return false\n         }\n-      }\n-    };\n+        for self.each |x, y| {\n+            match other.find(x) {\n+                Some(z) => if z != y { return false },\n+                None => return false\n+            }\n+        }\n+        true\n+    }\n+    pure fn ne(&self, other: &TreeMap<K, V>) -> bool {\n+        !self.eq(other)\n+    }\n }\n \n-/// Find a value based on the key\n-pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, k: K)\n-                              -> Option<V> {\n-    match copy *m {\n-      None => None,\n+impl <K: Ord, V> TreeMap<K, V> {\n+    /// Create an empty TreeMap\n+    static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-      // FIXME (#2808): was that an optimization?\n-      Some(node) => {\n-        if k == node.key {\n-            Some(node.value)\n-        } else if k < node.key {\n-            find(&const node.left, k)\n-        } else {\n-            find(&const node.right, k)\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint { self.length }\n+\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.root.is_none() }\n+\n+    /// Return true if the map contains some elements\n+    pure fn is_not_empty(&self) -> bool { self.root.is_some() }\n+\n+    /// Visit all key-value pairs in order\n+    pure fn each(&self, f: fn(&K, &V) -> bool) { each(&self.root, f) }\n+\n+    /// Visit all keys in order\n+    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|k, _| f(k)) }\n+\n+    /// Visit all values in order\n+    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|_, v| f(v)) }\n+\n+    /// Visit all key-value pairs in reverse order\n+    pure fn each_reverse(&self, f: fn(&K, &V) -> bool) {\n+        each_reverse(&self.root, f);\n+    }\n+\n+    /// Visit all keys in reverse order\n+    pure fn each_key_reverse(&self, f: fn(&K) -> bool) {\n+        self.each_reverse(|k, _| f(k))\n+    }\n+\n+    /// Visit all values in reverse order\n+    pure fn each_value_reverse(&self, f: fn(&V) -> bool) {\n+        self.each_reverse(|_, v| f(v))\n+    }\n+\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &K) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Return the value corresponding to the key in the map\n+    pure fn find(&self, key: &K) -> Option<&self/V> {\n+        let mut current: &self/Option<~TreeNode<K, V>> = &self.root;\n+        loop {\n+            match *current {\n+              Some(ref r) => {\n+                let r: &self/~TreeNode<K, V> = r; // FIXME: #3148\n+                if *key < r.key {\n+                    current = &r.left;\n+                } else if r.key < *key {\n+                    current = &r.right;\n+                } else {\n+                    return Some(&r.value);\n+                }\n+              }\n+              None => return None\n+            }\n         }\n-      }\n+    }\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool {\n+        let ret = insert(&mut self.root, key, value);\n+        if ret { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool {\n+        let ret = remove(&mut self.root, key);\n+        if ret { self.length -= 1 }\n+        ret\n     }\n }\n \n-/// Visit all pairs in the map in order.\n-pub fn traverse<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>,\n-                                         f: fn((&K), (&V))) {\n-    match copy *m {\n-      None => (),\n-      Some(node) => {\n-        traverse(&const node.left, f);\n-        // copy of value is req'd as f() requires an immutable ptr\n-        f(&node.key, &copy node.value);\n-        traverse(&const node.right, f);\n-      }\n+pub struct TreeSet<T: Ord> {\n+    priv map: TreeMap<T, ()>\n+}\n+\n+impl <T: Ord> TreeSet<T>: iter::BaseIter<T> {\n+    /// Visit all values in order\n+    pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl <T: Ord> TreeSet<T>: Eq {\n+    pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n+    pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n+}\n+\n+impl <T: Ord> TreeSet<T> {\n+    /// Create an empty TreeSet\n+    static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+\n+    /// Return the number of elements in the set\n+    pure fn len(&self) -> uint { self.map.len() }\n+\n+    /// Return true if the set contains no elements\n+    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+\n+    /// Return true if the set contains some elements\n+    pure fn is_not_empty(&self) -> bool { self.map.is_not_empty() }\n+\n+    /// Visit all values in reverse order\n+    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n+        self.map.each_key_reverse(f)\n+    }\n+\n+    /// Return true if the set contains a value\n+    pure fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+\n+    /// Add a value to the set. Return true if the value was not\n+    /// already present in the set.\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+\n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    pure fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+        // FIXME: this is a naive O(n*log(m)) implementation, could be O(n)\n+        !iter::any(self, |x| other.contains(x))\n+    }\n+\n+    /// Check of the set is a subset of another\n+    pure fn is_subset(&self, other: &TreeSet<T>) -> bool {\n+        // FIXME: this is a naive O(n*log(m)) implementation, could be O(n)\n+        !iter::any(self, |x| !other.contains(x))\n+    }\n+\n+    /// Check of the set is a superset of another\n+    pure fn is_superset(&self, other: &TreeSet<T>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Visit the values (in-order) representing the difference\n+    pure fn difference(&self, _other: &TreeSet<T>,\n+                       _f: fn(&T) -> bool) {\n+        fail ~\"not yet implemented\" // TODO\n+    }\n+\n+    /// Visit the values (in-order) representing the symmetric difference\n+    pure fn symmetric_difference(&self, _other: &TreeSet<T>,\n+                                 _f: fn(&T) -> bool) {\n+        fail ~\"not yet implemented\" // TODO\n+    }\n+\n+    /// Visit the values (in-order) representing the intersection\n+    pure fn intersection(&self, other: &TreeSet<T>,\n+                         f: fn(&T) -> bool) {\n+        // FIXME: this is a naive O(n*log(m)) implementation, could be O(n)\n+        for self.each |x| {\n+            if other.contains(x) {\n+                if !f(x) { break }\n+            }\n+        }\n+    }\n+\n+    /// Visit the values (in-order) representing the union\n+    pure fn union(&self, _other: &TreeSet<T>, _f: fn(&T) -> bool) -> TreeSet<T> {\n+        fail ~\"not yet implemented\" // TODO\n     }\n }\n \n-/// Compare two treemaps and return true iff\n-/// they contain same keys and values\n-pub fn equals<K: Copy Eq Ord, V: Copy Eq>(t1: &const TreeEdge<K, V>,\n-                                          t2: &const TreeEdge<K, V>)\n-                                        -> bool {\n-    let mut v1 = ~[];\n-    let mut v2 = ~[];\n-    traverse(t1, |k,v| { v1.push((copy *k, copy *v)) });\n-    traverse(t2, |k,v| { v2.push((copy *k, copy *v)) });\n-    return v1 == v2;\n+// Nodes keep track of their level in the tree, starting at 1 in the\n+// leaves and with a red child sharing the level of the parent.\n+struct TreeNode<K: Ord, V> {\n+    key: K,\n+    value: V,\n+    left: Option<~TreeNode<K, V>>,\n+    right: Option<~TreeNode<K, V>>,\n+    level: uint\n }\n \n+impl <K: Ord, V> TreeNode<K, V> {\n+    #[inline(always)]\n+    static pure fn new(key: K, value: V) -> TreeNode<K, V> {\n+        TreeNode{key: key, value: value, left: None, right: None, level: 1}\n+    }\n+}\n \n-#[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n+pure fn each<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n+                        f: fn(&K, &V) -> bool) {\n+    do node.map |x| {\n+        each(&x.left, f);\n+        if f(&x.key, &x.value) { each(&x.right, f) }\n+    };\n+}\n+\n+pure fn each_reverse<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n+                                f: fn(&K, &V) -> bool) {\n+    do node.map |x| {\n+        each_reverse(&x.right, f);\n+        if f(&x.key, &x.value) { each_reverse(&x.left, f) }\n+    };\n+}\n+\n+// Remove left horizontal link by rotating right\n+fn skew<K: Ord, V>(node: ~TreeNode<K, V>) -> ~TreeNode<K, V> {\n+    if node.left.map_default(false, |x| x.level == node.level) {\n+        let mut node = node;\n+        let mut save = node.left.swap_unwrap();\n+        node.left <-> save.right; // save.right now None\n+        save.right = Some(node);\n+        save\n+    } else {\n+        node // nothing to do\n+    }\n+}\n+\n+// Remove dual horizontal link by rotating left and increasing level of\n+// the parent\n+fn split<K: Ord, V>(node: ~TreeNode<K, V>) -> ~TreeNode<K, V> {\n+    if node.right.map_default(false, |x| x.right.map_default(false, |y| y.level == node.level)) {\n+        let mut node = node;\n+        let mut save = node.right.swap_unwrap();\n+        node.right <-> save.left; // save.left now None\n+        save.left = Some(node);\n+        save.level += 1;\n+        save\n+    } else {\n+        node // nothing to do\n+    }\n+}\n+\n+fn insert<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n+                     value: V) -> bool {\n+    if node.is_none() {\n+        *node = Some(~TreeNode::new(key, value));\n+        true\n+    } else {\n+        let mut save = node.swap_unwrap();\n+        if key < save.key {\n+            let inserted = insert(&mut save.left, key, value);\n+            *node = Some(split(skew(save))); // re-balance, if necessary\n+            inserted\n+        } else if save.key < key {\n+            let inserted = insert(&mut save.right, key, value);\n+            *node = Some(split(skew(save))); // re-balance, if necessary\n+            inserted\n+        } else {\n+            save.key = key;\n+            save.value = value;\n+            *node = Some(save);\n+            false\n+        }\n+    }\n+}\n+\n+fn remove<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n+    fn heir_swap<K: Ord, V>(node: &mut TreeNode<K, V>,\n+                            child: &mut Option<~TreeNode<K, V>>) {\n+        // *could* be done without recursion, but it won't borrow check\n+        do child.mutate |child| {\n+            let mut child = child;\n+            if child.right.is_some() {\n+                heir_swap(node, &mut child.right);\n+            } else {\n+                node.key <-> child.key;\n+                node.value <-> child.value;\n+            }\n+            child\n+        }\n+    }\n+\n+    if node.is_none() {\n+        return false // bottom of tree\n+    } else {\n+        let mut save = node.swap_unwrap();\n+\n+        let removed = if save.key < *key {\n+            remove(&mut save.right, key)\n+        } else if *key < save.key {\n+            remove(&mut save.left, key)\n+        } else {\n+            if save.left.is_some() {\n+                if save.right.is_some() {\n+                    let mut left = save.left.swap_unwrap();\n+                    if left.right.is_some() {\n+                        heir_swap(save, &mut left.right);\n+                        save.left = Some(left);\n+                        remove(&mut save.left, key);\n+                    } else {\n+                        save.key <-> left.key;\n+                        save.value <-> left.value;\n+                        save.left = Some(left);\n+                        remove(&mut save.left, key);\n+                    }\n+                } else {\n+                    let mut rm = save.left.swap_unwrap();\n+                    save.key <-> rm.key;\n+                    save.value <-> rm.value;\n+                    save.level <-> rm.level; // FIXME: may not be needed\n+                    save.left <-> rm.left; // FIXME: may not be needed\n+                    save.right <-> rm.right; // FIXME: may not be needed\n+                }\n+            } else if save.right.is_some() {\n+                let mut rm = save.right.swap_unwrap();\n+                save.key <-> rm.key;\n+                save.value <-> rm.value;\n+                save.level <-> rm.level; // FIXME: may not be needed\n+                save.left <-> rm.left; // FIXME: may not be needed\n+                save.right <-> rm.right; // FIXME: may not be needed\n+            } else {\n+                return true // leaf\n+            }\n+            true\n+        };\n+\n+        let left_level = save.left.map_default(0, |x| x.level);\n+        let right_level = save.right.map_default(0, |x| x.level);\n+\n+        // re-balance, if necessary\n+        if left_level < save.level - 1 || right_level < save.level - 1 {\n+            save.level -= 1;\n+\n+            if right_level > save.level {\n+                do save.right.mutate |x| {\n+                    let mut x = x; x.level = save.level; x\n+                }\n+            }\n+\n+            save = skew(save);\n+\n+            do save.right.mutate |right| {\n+                let mut right = skew(right);\n+                right.right.mutate(skew);\n+                right\n+            }\n+            save = split(save);\n+            save.right.mutate(split);\n+        }\n \n-    use treemap::*;\n+        *node = Some(save);\n+        removed\n+    }\n+}\n \n-    use core::option::{None, Option, Some};\n+#[cfg(test)]\n+mod test_treemap {\n+    use super::*;\n     use core::str;\n \n     #[test]\n-    fn init_treemap() { let _m = TreeMap::<int, int>(); }\n+    fn find_empty() {\n+        let m = TreeMap::new::<int, int>(); assert m.find(&5) == None;\n+    }\n \n     #[test]\n-    fn insert_one() { let m = TreeMap(); insert(m, 1, 2); }\n+    fn find_not_found() {\n+        let mut m = TreeMap::new();\n+        assert m.insert(1, 2);\n+        assert m.insert(5, 3);\n+        assert m.insert(9, 3);\n+        assert m.find(&2) == None;\n+    }\n \n     #[test]\n-    fn insert_two() { let m = TreeMap(); insert(m, 1, 2); insert(m, 3, 4); }\n+    fn insert_replace() {\n+        let mut m = TreeMap::new();\n+        assert m.insert(5, 2);\n+        assert m.insert(2, 9);\n+        assert !m.insert(2, 11);\n+        assert m.find(&2).unwrap() == &11;\n+    }\n \n     #[test]\n-    fn insert_find() {\n-        let m = TreeMap();\n-        insert(m, 1, 2);\n-        assert (find(m, 1) == Some(2));\n+    fn u8_map() {\n+        let mut m = TreeMap::new();\n+\n+        let k1 = str::to_bytes(~\"foo\");\n+        let k2 = str::to_bytes(~\"bar\");\n+        let v1 = str::to_bytes(~\"baz\");\n+        let v2 = str::to_bytes(~\"foobar\");\n+\n+        m.insert(k1, v1);\n+        m.insert(k2, v2);\n+\n+        assert m.find(&k2) == Some(&v2);\n+        assert m.find(&k1) == Some(&v1);\n+    }\n+\n+    fn check_equal<K: Eq Ord, V: Eq>(ctrl: &[(K, V)], map: &TreeMap<K, V>) {\n+        assert ctrl.is_empty() == map.is_empty();\n+        assert ctrl.is_not_empty() == map.is_not_empty();\n+        for ctrl.each |x| {\n+            let &(k, v) = x;\n+            assert map.find(&k).unwrap() == &v\n+        }\n+        for map.each |map_k, map_v| {\n+            let mut found = false;\n+            for ctrl.each |x| {\n+                let &(ctrl_k, ctrl_v) = x;\n+                if *map_k == ctrl_k {\n+                    assert *map_v == ctrl_v;\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            assert found;\n+        }\n+    }\n+\n+    fn check_left<K: Ord, V>(node: &Option<~TreeNode<K, V>>, parent: &~TreeNode<K, V>) {\n+        match *node {\n+          Some(ref r) => {\n+            assert r.key < parent.key;\n+            assert r.level == parent.level - 1; // left is black\n+            check_left(&r.left, r);\n+            check_right(&r.right, r, false);\n+          }\n+          None => assert parent.level == 1 // parent is leaf\n+        }\n+    }\n+\n+    fn check_right<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n+                              parent: &~TreeNode<K, V>, parent_red: bool) {\n+        match *node {\n+          Some(ref r) => {\n+            assert r.key > parent.key;\n+            let red = r.level == parent.level;\n+            if parent_red { assert !red } // no dual horizontal links\n+            assert red || r.level == parent.level - 1; // right is red or black\n+            check_left(&r.left, r);\n+            check_right(&r.right, r, red);\n+          }\n+          None => assert parent.level == 1 // parent is leaf\n+        }\n+    }\n+\n+    fn check_structure<K: Ord, V>(map: &TreeMap<K, V>) {\n+        match map.root {\n+          Some(ref r) => {\n+            check_left(&r.left, r);\n+            check_right(&r.right, r, false);\n+          }\n+          None => ()\n+        }\n     }\n \n     #[test]\n-    fn find_empty() {\n-        let m = TreeMap::<int, int>(); assert (find(m, 1) == None);\n+    fn test_rand_int() {\n+        let mut map = TreeMap::new::<int, int>();\n+        let mut ctrl = ~[];\n+\n+        check_equal(ctrl, &map);\n+        assert map.find(&5).is_none();\n+\n+        let rng = rand::seeded_rng(&~[42]);\n+\n+        for 3.times {\n+            for 90.times {\n+                let k = rng.gen_int();\n+                let v = rng.gen_int();\n+                if !ctrl.contains(&(k, v)) {\n+                    assert map.insert(k, v);\n+                    ctrl.push((k, v));\n+                    check_structure(&map);\n+                    check_equal(ctrl, &map);\n+                }\n+            }\n+\n+            for 30.times {\n+                let r = rng.gen_uint_range(0, ctrl.len());\n+                let (key, _) = vec::remove(&mut ctrl, r);\n+                assert map.remove(&key);\n+                check_structure(&map);\n+                check_equal(ctrl, &map);\n+            }\n+        }\n     }\n \n     #[test]\n-    fn find_not_found() {\n-        let m = TreeMap();\n-        insert(m, 1, 2);\n-        assert (find(m, 2) == None);\n+    fn test_len() {\n+        let mut m = TreeMap::new();\n+        assert m.insert(3, 6);\n+        assert m.len() == 1;\n+        assert m.insert(0, 0);\n+        assert m.len() == 2;\n+        assert m.insert(4, 8);\n+        assert m.len() == 3;\n+        assert m.remove(&3);\n+        assert m.len() == 2;\n+        assert !m.remove(&5);\n+        assert m.len() == 2;\n+        assert m.insert(2, 4);\n+        assert m.len() == 3;\n+        assert m.insert(1, 2);\n+        assert m.len() == 4;\n+    }\n+\n+    #[test]\n+    fn test_each() {\n+        let mut m = TreeMap::new();\n+\n+        assert m.insert(3, 6);\n+        assert m.insert(0, 0);\n+        assert m.insert(4, 8);\n+        assert m.insert(2, 4);\n+        assert m.insert(1, 2);\n+\n+        let mut n = 0;\n+        for m.each |k, v| {\n+            assert *k == n;\n+            assert *v == n * 2;\n+            n += 1;\n+        }\n     }\n \n     #[test]\n-    fn traverse_in_order() {\n-        let m = TreeMap();\n-        insert(m, 3, ());\n-        insert(m, 0, ());\n-        insert(m, 4, ());\n-        insert(m, 2, ());\n-        insert(m, 1, ());\n+    fn test_each_reverse() {\n+        let mut m = TreeMap::new();\n+\n+        assert m.insert(3, 6);\n+        assert m.insert(0, 0);\n+        assert m.insert(4, 8);\n+        assert m.insert(2, 4);\n+        assert m.insert(1, 2);\n \n-        let n = @mut 0;\n-        fn t(n: @mut int, k: int, _v: ()) {\n-            assert (*n == k); *n += 1;\n+        let mut n = 4;\n+        for m.each_reverse |k, v| {\n+            assert *k == n;\n+            assert *v == n * 2;\n+            n -= 1;\n         }\n-        traverse(m, |x,y| t(n, *x, *y));\n     }\n \n     #[test]\n-    fn equality() {\n-        let m1 = TreeMap();\n-        insert(m1, 3, ());\n-        insert(m1, 0, ());\n-        insert(m1, 4, ());\n-        insert(m1, 2, ());\n-        insert(m1, 1, ());\n-        let m2 = TreeMap();\n-        insert(m2, 2, ());\n-        insert(m2, 1, ());\n-        insert(m2, 3, ());\n-        insert(m2, 0, ());\n-        insert(m2, 4, ());\n+    fn test_eq() {\n+        let mut a = TreeMap::new();\n+        let mut b = TreeMap::new();\n \n-        assert equals(m1, m2);\n+        assert a == b;\n+        assert a.insert(0, 5);\n+        assert a != b;\n+        assert b.insert(0, 4);\n+        assert a != b;\n+        assert a.insert(5, 19);\n+        assert a != b;\n+        assert !b.insert(0, 5);\n+        assert a != b;\n+        assert b.insert(5, 19);\n+        assert a == b;\n+    }\n+}\n \n-        let m3 = TreeMap();\n-        assert !equals(m1,m3);\n+#[cfg(test)]\n+mod test_set {\n+    use super::*;\n \n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = TreeSet::new();\n+        let mut ys = TreeSet::new();\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert xs.insert(5);\n+        assert ys.insert(11);\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert xs.insert(7);\n+        assert xs.insert(19);\n+        assert xs.insert(4);\n+        assert ys.insert(2);\n+        assert ys.insert(-11);\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert ys.insert(7);\n+        assert !xs.is_disjoint(&ys);\n+        assert !ys.is_disjoint(&xs);\n     }\n \n     #[test]\n-    fn u8_map() {\n-        let m = TreeMap();\n+    fn test_subset_and_superset() {\n+        let mut a = TreeSet::new();\n+        assert a.insert(0);\n+        assert a.insert(5);\n+        assert a.insert(11);\n+        assert a.insert(7);\n \n-        let k1 = str::to_bytes(~\"foo\");\n-        let k2 = str::to_bytes(~\"bar\");\n+        let mut b = TreeSet::new();\n+        assert b.insert(0);\n+        assert b.insert(7);\n+        assert b.insert(19);\n+        assert b.insert(250);\n+        assert b.insert(11);\n+        assert b.insert(200);\n+\n+        assert !a.is_subset(&b);\n+        assert !a.is_superset(&b);\n+        assert !b.is_subset(&a);\n+        assert !b.is_superset(&a);\n \n-        insert(m, k1, ~\"foo\");\n-        insert(m, k2, ~\"bar\");\n+        assert b.insert(5);\n \n-        assert (find(m, k2) == Some(~\"bar\"));\n-        assert (find(m, k1) == Some(~\"foo\"));\n+        assert a.is_subset(&b);\n+        assert !a.is_superset(&b);\n+        assert !b.is_subset(&a);\n+        assert b.is_superset(&a);\n+    }\n+\n+    #[test]\n+    fn test_each() {\n+        let mut m = TreeSet::new();\n+\n+        assert m.insert(3);\n+        assert m.insert(0);\n+        assert m.insert(4);\n+        assert m.insert(2);\n+        assert m.insert(1);\n+\n+        let mut n = 0;\n+        for m.each |x| {\n+            assert *x == n;\n+            n += 1\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_reverse() {\n+        let mut m = TreeSet::new();\n+\n+        assert m.insert(3);\n+        assert m.insert(0);\n+        assert m.insert(4);\n+        assert m.insert(2);\n+        assert m.insert(1);\n+\n+        let mut n = 4;\n+        for m.each_reverse |x| {\n+            assert *x == n;\n+            n -= 1\n+        }\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        let mut a = TreeSet::new();\n+        let mut b = TreeSet::new();\n+\n+        a.insert(11);\n+        a.insert(1);\n+        a.insert(3);\n+        a.insert(77);\n+        a.insert(103);\n+        a.insert(5);\n+        a.insert(-5);\n+\n+        b.insert(2);\n+        b.insert(11);\n+        b.insert(77);\n+        b.insert(-9);\n+        b.insert(-42);\n+        b.insert(5);\n+        b.insert(3);\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for a.intersection(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n     }\n }"}]}