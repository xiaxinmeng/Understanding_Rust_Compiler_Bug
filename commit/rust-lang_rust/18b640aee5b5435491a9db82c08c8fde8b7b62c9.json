{"sha": "18b640aee5b5435491a9db82c08c8fde8b7b62c9", "node_id": "C_kwDOAAsO6NoAKDE4YjY0MGFlZTViNTQzNTQ5MWE5ZGI4MmMwOGM4ZmRlOGI3YjYyYzk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-28T01:08:24Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-28T01:08:24Z"}, "message": "Suggest calling when operator types mismatch", "tree": {"sha": "cbb091caffb0e8320c006ba446598c395afebdd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb091caffb0e8320c006ba446598c395afebdd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18b640aee5b5435491a9db82c08c8fde8b7b62c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18b640aee5b5435491a9db82c08c8fde8b7b62c9", "html_url": "https://github.com/rust-lang/rust/commit/18b640aee5b5435491a9db82c08c8fde8b7b62c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18b640aee5b5435491a9db82c08c8fde8b7b62c9/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f78dd15a6f29894e5876582cc84e8a5faa539c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f78dd15a6f29894e5876582cc84e8a5faa539c1", "html_url": "https://github.com/rust-lang/rust/commit/2f78dd15a6f29894e5876582cc84e8a5faa539c1"}], "stats": {"total": 363, "additions": 199, "deletions": 164}, "files": [{"sha": "b21e9c2c96cbcdce7047e447f97e6c011a38d415", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -1248,9 +1248,13 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags\n-            .treat_err_as_bug\n-            .map_or(false, |c| self.err_count() + self.lint_err_count >= c.get())\n+        self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                >= c.get()\n+        })\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n@@ -1406,7 +1410,14 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() + 1 >= c.get()) {\n+        if self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                + 1\n+                >= c.get()\n+        }) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n         }"}, {"sha": "9c6530c8a08438e8afc2eaddced942affe1df3db", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -41,7 +41,8 @@ macro_rules! pluralize {\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n /// to determine whether it should be automatically applied or if the user should be consulted\n /// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable, Serialize, Deserialize)]\n+#[derive(Copy, Clone, Debug, Hash, Encodable, Decodable, Serialize, Deserialize)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub enum Applicability {\n     /// The suggestion is definitely what the user intended, or maintains the exact meaning of the code.\n     /// This suggestion should be automatically applied."}, {"sha": "96901b5330312202bdb33fd5fc2c338d40a9d521", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 126, "deletions": 47, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -76,10 +76,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        enum DefIdOrName {\n-            DefId(DefId),\n-            Name(&'static str),\n+        let Some((def_id_or_name, output, num_inputs)) = self.extract_callable_info(expr, found)\n+            else { return false; };\n+        if can_satisfy(output) {\n+            let (sugg_call, mut applicability) = match num_inputs {\n+                0 => (\"\".to_string(), Applicability::MachineApplicable),\n+                1..=4 => (\n+                    (0..num_inputs).map(|_| \"_\").collect::<Vec<_>>().join(\", \"),\n+                    Applicability::MachineApplicable,\n+                ),\n+                _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n+            };\n+\n+            let msg = match def_id_or_name {\n+                DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n+                    DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\".to_string(),\n+                    DefKind::Ctor(CtorOf::Variant, _) => {\n+                        \"instantiate this tuple variant\".to_string()\n+                    }\n+                    kind => format!(\"call this {}\", kind.descr(def_id)),\n+                },\n+                DefIdOrName::Name(name) => format!(\"call this {name}\"),\n+            };\n+\n+            let sugg = match expr.kind {\n+                hir::ExprKind::Call(..)\n+                | hir::ExprKind::Path(..)\n+                | hir::ExprKind::Index(..)\n+                | hir::ExprKind::Lit(..) => {\n+                    vec![(expr.span.shrink_to_hi(), format!(\"({sugg_call})\"))]\n+                }\n+                hir::ExprKind::Closure { .. } => {\n+                    // Might be `{ expr } || { bool }`\n+                    applicability = Applicability::MaybeIncorrect;\n+                    vec![\n+                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                    ]\n+                }\n+                _ => {\n+                    vec![\n+                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                    ]\n+                }\n+            };\n+\n+            err.multipart_suggestion_verbose(\n+                format!(\"use parentheses to {msg}\"),\n+                sugg,\n+                applicability,\n+            );\n+\n+            return true;\n         }\n+        false\n+    }\n+\n+    fn extract_callable_info(\n+        &self,\n+        expr: &Expr<'_>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, usize)> {\n         // Autoderef is useful here because sometimes we box callables, etc.\n         let Some((def_id_or_name, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n             match *found.kind() {\n@@ -148,67 +206,83 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 _ => None,\n             }\n-        }) else { return false; };\n+        }) else { return None; };\n \n         let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n+\n         // We don't want to register any extra obligations, which should be\n         // implied by wf, but also because that would possibly result in\n         // erroneous errors later on.\n         let infer::InferOk { value: output, obligations: _ } =\n             self.normalize_associated_types_in_as_infer_ok(expr.span, output);\n-        if !output.is_ty_var() && can_satisfy(output) {\n-            let (sugg_call, mut applicability) = match inputs {\n-                0 => (\"\".to_string(), Applicability::MachineApplicable),\n-                1..=4 => (\n-                    (0..inputs).map(|_| \"_\").collect::<Vec<_>>().join(\", \"),\n-                    Applicability::MachineApplicable,\n-                ),\n-                _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n-            };\n \n-            let msg = match def_id_or_name {\n-                DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n-                    DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\".to_string(),\n-                    DefKind::Ctor(CtorOf::Variant, _) => {\n-                        \"instantiate this tuple variant\".to_string()\n-                    }\n-                    kind => format!(\"call this {}\", kind.descr(def_id)),\n-                },\n-                DefIdOrName::Name(name) => format!(\"call this {name}\"),\n-            };\n+        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+    }\n \n-            let sugg = match expr.kind {\n-                hir::ExprKind::Call(..)\n-                | hir::ExprKind::Path(..)\n-                | hir::ExprKind::Index(..)\n-                | hir::ExprKind::Lit(..) => {\n-                    vec![(expr.span.shrink_to_hi(), format!(\"({sugg_call})\"))]\n-                }\n-                hir::ExprKind::Closure { .. } => {\n-                    // Might be `{ expr } || { bool }`\n-                    applicability = Applicability::MaybeIncorrect;\n-                    vec![\n-                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                        (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n-                    ]\n-                }\n-                _ => {\n-                    vec![\n-                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                        (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n-                    ]\n+    pub fn suggest_two_fn_call(\n+        &self,\n+        err: &mut Diagnostic,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_ty: Ty<'tcx>,\n+        can_satisfy: impl FnOnce(Ty<'tcx>, Ty<'tcx>) -> bool,\n+    ) -> bool {\n+        let Some((_, lhs_output_ty, num_lhs_inputs)) = self.extract_callable_info(lhs_expr, lhs_ty)\n+            else { return false; };\n+        let Some((_, rhs_output_ty, num_rhs_inputs)) = self.extract_callable_info(rhs_expr, rhs_ty)\n+            else { return false; };\n+\n+        if can_satisfy(lhs_output_ty, rhs_output_ty) {\n+            let mut sugg = vec![];\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            for (expr, num_inputs) in [(lhs_expr, num_lhs_inputs), (rhs_expr, num_rhs_inputs)] {\n+                let (sugg_call, this_applicability) = match num_inputs {\n+                    0 => (\"\".to_string(), Applicability::MachineApplicable),\n+                    1..=4 => (\n+                        (0..num_inputs).map(|_| \"_\").collect::<Vec<_>>().join(\", \"),\n+                        Applicability::MachineApplicable,\n+                    ),\n+                    _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n+                };\n+\n+                applicability = applicability.max(this_applicability);\n+\n+                match expr.kind {\n+                    hir::ExprKind::Call(..)\n+                    | hir::ExprKind::Path(..)\n+                    | hir::ExprKind::Index(..)\n+                    | hir::ExprKind::Lit(..) => {\n+                        sugg.extend([(expr.span.shrink_to_hi(), format!(\"({sugg_call})\"))]);\n+                    }\n+                    hir::ExprKind::Closure { .. } => {\n+                        // Might be `{ expr } || { bool }`\n+                        applicability = Applicability::MaybeIncorrect;\n+                        sugg.extend([\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                        ]);\n+                    }\n+                    _ => {\n+                        sugg.extend([\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                        ]);\n+                    }\n                 }\n-            };\n+            }\n \n             err.multipart_suggestion_verbose(\n-                format!(\"use parentheses to {msg}\"),\n+                format!(\"use parentheses to call these\"),\n                 sugg,\n                 applicability,\n             );\n \n-            return true;\n+            true\n+        } else {\n+            false\n         }\n-        false\n     }\n \n     pub fn suggest_deref_ref_or_into(\n@@ -959,3 +1033,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+enum DefIdOrName {\n+    DefId(DefId),\n+    Name(&'static str),\n+}"}, {"sha": "952086e898fc70011fa22d1a19402c0bfab75bb5", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 40, "deletions": 88, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -410,26 +410,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n-                            self.add_type_neq_err_label(\n-                                &mut err,\n-                                lhs_expr.span,\n-                                lhs_ty,\n-                                rhs_ty,\n-                                rhs_expr,\n-                                op,\n-                                is_assign,\n-                                expected,\n-                            );\n-                            self.add_type_neq_err_label(\n-                                &mut err,\n-                                rhs_expr.span,\n-                                rhs_ty,\n-                                lhs_ty,\n-                                lhs_expr,\n-                                op,\n-                                is_assign,\n-                                expected,\n-                            );\n+                            err.span_label(lhs_expr.span, lhs_ty.to_string());\n+                            err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n                         (err, missing_trait, use_output)\n@@ -468,17 +450,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n \n+                let is_compatible = |lhs_ty, rhs_ty| {\n+                    self.lookup_op_method(\n+                        lhs_ty,\n+                        Some(rhs_ty),\n+                        Some(rhs_expr),\n+                        Op::Binary(op, is_assign),\n+                        expected,\n+                    )\n+                    .is_ok()\n+                };\n+\n                 // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n                 // `a += b` => `*a += b` if a is a mut ref.\n-                if is_assign == IsAssign::Yes\n-                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n-                        suggest_deref_binop(lhs_deref_ty);\n+                if !op.span.can_be_used_for_suggestions() {\n+                    // Suppress suggestions when lhs and rhs are not in the same span as the error\n+                } else if is_assign == IsAssign::Yes\n+                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty)\n+                {\n+                    suggest_deref_binop(lhs_deref_ty);\n                 } else if is_assign == IsAssign::No\n-                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n-                    if self.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind()\n+                {\n+                    if self.type_is_copy_modulo_regions(\n+                        self.param_env,\n+                        *lhs_deref_ty,\n+                        lhs_expr.span,\n+                    ) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n+                } else if self.suggest_fn_call(&mut err, lhs_expr, lhs_ty, |lhs_ty| {\n+                    is_compatible(lhs_ty, rhs_ty)\n+                }) || self.suggest_fn_call(&mut err, rhs_expr, rhs_ty, |rhs_ty| {\n+                    is_compatible(lhs_ty, rhs_ty)\n+                }) || self.suggest_two_fn_call(\n+                    &mut err,\n+                    rhs_expr,\n+                    rhs_ty,\n+                    lhs_expr,\n+                    lhs_ty,\n+                    |lhs_ty, rhs_ty| is_compatible(lhs_ty, rhs_ty),\n+                ) {\n+                    // Cool\n                 }\n+\n                 if let Some(missing_trait) = missing_trait {\n                     let mut visitor = TypeParamVisitor(vec![]);\n                     visitor.visit_ty(lhs_ty);\n@@ -548,69 +563,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (lhs_ty, rhs_ty, return_ty)\n     }\n \n-    /// If one of the types is an uncalled function and calling it would yield the other type,\n-    /// suggest calling the function. Returns `true` if suggestion would apply (even if not given).\n-    fn add_type_neq_err_label(\n-        &self,\n-        err: &mut Diagnostic,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-        other_ty: Ty<'tcx>,\n-        other_expr: &'tcx hir::Expr<'tcx>,\n-        op: hir::BinOp,\n-        is_assign: IsAssign,\n-        expected: Expectation<'tcx>,\n-    ) -> bool /* did we suggest to call a function because of missing parentheses? */ {\n-        err.span_label(span, ty.to_string());\n-        if let FnDef(def_id, _) = *ty.kind() {\n-            if !self.tcx.has_typeck_results(def_id) {\n-                return false;\n-            }\n-            // FIXME: Instead of exiting early when encountering bound vars in\n-            // the function signature, consider keeping the binder here and\n-            // propagating it downwards.\n-            let Some(fn_sig) = self.tcx.fn_sig(def_id).no_bound_vars() else {\n-                return false;\n-            };\n-\n-            let other_ty = if let FnDef(def_id, _) = *other_ty.kind() {\n-                if !self.tcx.has_typeck_results(def_id) {\n-                    return false;\n-                }\n-                // We're emitting a suggestion, so we can just ignore regions\n-                self.tcx.fn_sig(def_id).skip_binder().output()\n-            } else {\n-                other_ty\n-            };\n-\n-            if self\n-                .lookup_op_method(\n-                    fn_sig.output(),\n-                    Some(other_ty),\n-                    Some(other_expr),\n-                    Op::Binary(op, is_assign),\n-                    expected,\n-                )\n-                .is_ok()\n-            {\n-                let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n-                    (\"( /* arguments */ )\", Applicability::HasPlaceholders)\n-                } else {\n-                    (\"()\", Applicability::MaybeIncorrect)\n-                };\n-\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"you might have forgotten to call this function\",\n-                    variable_snippet,\n-                    applicability,\n-                );\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     /// Provide actionable suggestions when trying to add two strings with incorrect types,\n     /// like `&str + &str`, `String + String` and `&str + &String`.\n     ///"}, {"sha": "74860a93f37994d31ec7b90204643c08b9675359", "filename": "src/test/ui/binop/issue-77910-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -5,6 +5,11 @@ LL |     if foo == y {}\n    |        --- ^^ - _\n    |        |\n    |        for<'r> fn(&'r i32) -> &'r i32 {foo}\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     if foo(_) == y {}\n+   |           +++\n \n error: aborting due to previous error\n "}, {"sha": "df838cb11810578e8ec10274324269c48750cf43", "filename": "src/test/ui/fn/fn-compare-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -6,14 +6,10 @@ LL |     let x = f == g;\n    |             |\n    |             fn() {f}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call these\n    |\n-LL |     let x = f() == g;\n-   |              ++\n-help: you might have forgotten to call this function\n-   |\n-LL |     let x = f == g();\n-   |                   ++\n+LL |     let x = f() == g();\n+   |              ++     ++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-compare-mismatch.rs:4:18"}, {"sha": "df681eb2489c0acf96d1777cc064c9f0c263f39e", "filename": "src/test/ui/issues/issue-59488.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -6,7 +6,7 @@ LL |     foo > 12;\n    |     |\n    |     fn() -> i32 {foo}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call this function\n    |\n LL |     foo() > 12;\n    |        ++\n@@ -28,10 +28,10 @@ LL |     bar > 13;\n    |     |\n    |     fn(i64) -> i64 {bar}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call this function\n    |\n-LL |     bar( /* arguments */ ) > 13;\n-   |        +++++++++++++++++++\n+LL |     bar(_) > 13;\n+   |        +++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-59488.rs:18:11\n@@ -50,14 +50,10 @@ LL |     foo > foo;\n    |     |\n    |     fn() -> i32 {foo}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call these\n    |\n-LL |     foo() > foo;\n-   |        ++\n-help: you might have forgotten to call this function\n-   |\n-LL |     foo > foo();\n-   |              ++\n+LL |     foo() > foo();\n+   |        ++      ++\n \n error[E0369]: binary operation `>` cannot be applied to type `fn() -> i32 {foo}`\n   --> $DIR/issue-59488.rs:25:9"}, {"sha": "9239385e6436904b5235e8bc657dfa283c9b4077", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18b640aee5b5435491a9db82c08c8fde8b7b62c9/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=18b640aee5b5435491a9db82c08c8fde8b7b62c9", "patch": "@@ -8,11 +8,6 @@ LL |     assert_eq!(a, 0);\n    |     {integer}\n    |\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you might have forgotten to call this function\n-  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |                 if !(*left_val() == *right_val) {\n-   |                               ++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n@@ -21,7 +16,7 @@ LL |     assert_eq!(a, 0);\n    |     ^^^^^^^^^^^^^^^^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() -> i32 {a}`\n-                 found type `i32`\n+                 found type `{integer}`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `fn() -> i32 {a}` doesn't implement `Debug`"}]}