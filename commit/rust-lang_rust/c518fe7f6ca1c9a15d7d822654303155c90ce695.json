{"sha": "c518fe7f6ca1c9a15d7d822654303155c90ce695", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MThmZTdmNmNhMWM5YTE1ZDdkODIyNjU0MzAzMTU1YzkwY2U2OTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-12T16:00:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-12T16:00:13Z"}, "message": "Merge #6130 #6135\n\n6130: Items case quick fix (snake_case / UPPER_SNAKE_CASE / CamelCase) r=matklad a=popzxc\n\nResolves #4598.\r\n\r\nAfter a third try, it finally works. Boy, it appeared tougher than it seemed.\r\n\r\nInitially I thought like \"Ha, `rustc` already tells us where idents are named incorrectly. It shouldn't be that hard, should it?\".\r\n\r\nWell, the problems with the information provided by `rustc` appeared shortly:\r\n\r\n- `rustc` warnings are `flycheck` warnings, which are slightly aside from our diagnostics with fixes.\r\n  When we map flycheck diagnostic to LSP, we can convert it into a fix, but only if it's marked as `Applicability::MachineApplicable`.\r\n  Name case fix is marked `Applicability::MaybeIncorrect`, and for a reason: it only suggest to rename symbol under cursor, without tracking any references.\r\n- Warning spawned by `rustc` are identified by string labels rather than enum. It means that if one day the diagnostic will be renamed in `rustc`, `rust-analyzer` code will still compile, but won't find the required diagnostic by name anymore. If by chance this will happen when some unlucky guy will decide to create their first pull request, they'll be confused by suddenly failing tests  (likely) not related to their changes.\r\n- Even if we'll try to build fixes atop of `rustc` warnings, we'll have to do it in the `rust_analyzer::diagnostics::to_proto` module, which is far less\r\n  convenient for that matter than `ide` crate.\r\n\r\nThat's why I decided that it's worth a separate `rust-analyzer` diagnostic, which will implement `DiagnosticWithFix` trait.\r\n\r\nAfter that, I discovered that currently `hir_ty::diagnostics` only check `DefWithBody` types, like function bodies. I had to add support for diagnostics\r\nwhich look at any `ModuleDef`.\r\n\r\nAnd of course, since I'd added a lot of new functionality, it required extensive testing.\r\n\r\nThat explains why the diff is so big for a (looking) relatively small feature.\r\n\r\nI hope that this PR doesn't only add a small feature, but also creates a base for building another features.\r\n\r\n## Example:\r\n\r\n![case_quick_fix](https://user-images.githubusercontent.com/12111581/95008475-e07ee780-0622-11eb-9978-62a9ea0e7782.gif)\r\n\r\nP.S. My eyes were bleeding when I had to write the code for the example...\r\n\n\n6135: when generating new function, focus on return type instead of body r=matklad a=bnjjj\n\nI made a little change when we use the assist to generate a new function, instead of focusing on the function body, it will focus on return type\n\nCo-authored-by: Igor Aleksanov <popzxc@yandex.ru>\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "38a80a3b721c9f7bc6ac2a3e9309683f24024dca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38a80a3b721c9f7bc6ac2a3e9309683f24024dca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c518fe7f6ca1c9a15d7d822654303155c90ce695", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfhH2NCRBK7hj4Ov3rIwAAdHIIAEfc9PjeONMxqUOoXrvHc86P\ngoqk9rjSoDVnX8O+yD4YYDQ2n6htw7UMGb3ks3wI6i05atCts7IzN4UTKTcEIN0K\n2vFCFf8LB3+k8v++awQDPfgbikJNJKbUsuvHiFiKeiNFOaXkx3QDN/Iz+BjCBgo4\ngRcuoNOAkK0FfRqfBytYtQYBUavxizWCvpHyhJAjAmJG0aRGT3CgGbZRgKv9DJ2u\n/Pxv/2zN3Us0IKp3KuOqXOeuTdXCoeVWqcP9aAbWmlpSVe9t6aKNmiqfxmOzDP82\nV0gUxjZBgp2W5DcJsdM0pryp5CjpW80ECV0rLOUt+SGg4pfAPDRvo9jJ3waRppo=\n=+qnd\n-----END PGP SIGNATURE-----\n", "payload": "tree 38a80a3b721c9f7bc6ac2a3e9309683f24024dca\nparent ef33953c70e361e8ab6b0bb6b0f5604e1f1c7f29\nparent 991d0190968662f23220d8aefaf28bd03b1dbe41\nparent 3bfa3e8123dd2d652019ad270622025d10b87cc8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602518413 +0000\ncommitter GitHub <noreply@github.com> 1602518413 +0000\n\nMerge #6130 #6135\n\n6130: Items case quick fix (snake_case / UPPER_SNAKE_CASE / CamelCase) r=matklad a=popzxc\n\nResolves #4598.\r\n\r\nAfter a third try, it finally works. Boy, it appeared tougher than it seemed.\r\n\r\nInitially I thought like \"Ha, `rustc` already tells us where idents are named incorrectly. It shouldn't be that hard, should it?\".\r\n\r\nWell, the problems with the information provided by `rustc` appeared shortly:\r\n\r\n- `rustc` warnings are `flycheck` warnings, which are slightly aside from our diagnostics with fixes.\r\n  When we map flycheck diagnostic to LSP, we can convert it into a fix, but only if it's marked as `Applicability::MachineApplicable`.\r\n  Name case fix is marked `Applicability::MaybeIncorrect`, and for a reason: it only suggest to rename symbol under cursor, without tracking any references.\r\n- Warning spawned by `rustc` are identified by string labels rather than enum. It means that if one day the diagnostic will be renamed in `rustc`, `rust-analyzer` code will still compile, but won't find the required diagnostic by name anymore. If by chance this will happen when some unlucky guy will decide to create their first pull request, they'll be confused by suddenly failing tests  (likely) not related to their changes.\r\n- Even if we'll try to build fixes atop of `rustc` warnings, we'll have to do it in the `rust_analyzer::diagnostics::to_proto` module, which is far less\r\n  convenient for that matter than `ide` crate.\r\n\r\nThat's why I decided that it's worth a separate `rust-analyzer` diagnostic, which will implement `DiagnosticWithFix` trait.\r\n\r\nAfter that, I discovered that currently `hir_ty::diagnostics` only check `DefWithBody` types, like function bodies. I had to add support for diagnostics\r\nwhich look at any `ModuleDef`.\r\n\r\nAnd of course, since I'd added a lot of new functionality, it required extensive testing.\r\n\r\nThat explains why the diff is so big for a (looking) relatively small feature.\r\n\r\nI hope that this PR doesn't only add a small feature, but also creates a base for building another features.\r\n\r\n## Example:\r\n\r\n![case_quick_fix](https://user-images.githubusercontent.com/12111581/95008475-e07ee780-0622-11eb-9978-62a9ea0e7782.gif)\r\n\r\nP.S. My eyes were bleeding when I had to write the code for the example...\r\n\n\n6135: when generating new function, focus on return type instead of body r=matklad a=bnjjj\n\nI made a little change when we use the assist to generate a new function, instead of focusing on the function body, it will focus on return type\n\nCo-authored-by: Igor Aleksanov <popzxc@yandex.ru>\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c518fe7f6ca1c9a15d7d822654303155c90ce695", "html_url": "https://github.com/rust-lang/rust/commit/c518fe7f6ca1c9a15d7d822654303155c90ce695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c518fe7f6ca1c9a15d7d822654303155c90ce695/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef33953c70e361e8ab6b0bb6b0f5604e1f1c7f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef33953c70e361e8ab6b0bb6b0f5604e1f1c7f29", "html_url": "https://github.com/rust-lang/rust/commit/ef33953c70e361e8ab6b0bb6b0f5604e1f1c7f29"}, {"sha": "991d0190968662f23220d8aefaf28bd03b1dbe41", "url": "https://api.github.com/repos/rust-lang/rust/commits/991d0190968662f23220d8aefaf28bd03b1dbe41", "html_url": "https://github.com/rust-lang/rust/commit/991d0190968662f23220d8aefaf28bd03b1dbe41"}, {"sha": "3bfa3e8123dd2d652019ad270622025d10b87cc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfa3e8123dd2d652019ad270622025d10b87cc8", "html_url": "https://github.com/rust-lang/rust/commit/3bfa3e8123dd2d652019ad270622025d10b87cc8"}], "stats": {"total": 1491, "additions": 1407, "deletions": 84}, "files": [{"sha": "d23f4293b35f6b4bbce09b5a11590a67ec3ab6f8", "filename": "crates/assists/src/handlers/generate_function.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -36,8 +36,8 @@ use crate::{\n //     bar(\"\", baz());\n // }\n //\n-// fn bar(arg: &str, baz: Baz) {\n-//     ${0:todo!()}\n+// fn bar(arg: &str, baz: Baz) ${0:-> ()} {\n+//     todo!()\n // }\n //\n // ```\n@@ -80,21 +80,19 @@ pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Optio\n \n struct FunctionTemplate {\n     insert_offset: TextSize,\n-    placeholder_expr: ast::MacroCall,\n     leading_ws: String,\n     fn_def: ast::Fn,\n+    ret_type: ast::RetType,\n     trailing_ws: String,\n     file: FileId,\n }\n \n impl FunctionTemplate {\n     fn to_string(&self, cap: Option<SnippetCap>) -> String {\n         let f = match cap {\n-            Some(cap) => render_snippet(\n-                cap,\n-                self.fn_def.syntax(),\n-                Cursor::Replace(self.placeholder_expr.syntax()),\n-            ),\n+            Some(cap) => {\n+                render_snippet(cap, self.fn_def.syntax(), Cursor::Replace(self.ret_type.syntax()))\n+            }\n             None => self.fn_def.to_string(),\n         };\n         format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n@@ -141,8 +139,14 @@ impl FunctionBuilder {\n         let placeholder_expr = make::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n         let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n-        let mut fn_def =\n-            make::fn_(visibility, self.fn_name, self.type_params, self.params, fn_body);\n+        let mut fn_def = make::fn_(\n+            visibility,\n+            self.fn_name,\n+            self.type_params,\n+            self.params,\n+            fn_body,\n+            Some(make::ret_type(make::ty(\"()\"))),\n+        );\n         let leading_ws;\n         let trailing_ws;\n \n@@ -163,12 +167,10 @@ impl FunctionBuilder {\n             }\n         };\n \n-        let placeholder_expr =\n-            fn_def.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n         FunctionTemplate {\n             insert_offset,\n-            placeholder_expr,\n             leading_ws,\n+            ret_type: fn_def.ret_type().unwrap(),\n             fn_def,\n             trailing_ws,\n             file: self.file,\n@@ -349,8 +351,8 @@ fn foo() {\n     bar();\n }\n \n-fn bar() {\n-    ${0:todo!()}\n+fn bar() ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -376,8 +378,8 @@ impl Foo {\n     }\n }\n \n-fn bar() {\n-    ${0:todo!()}\n+fn bar() ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -400,8 +402,8 @@ fn foo1() {\n     bar();\n }\n \n-fn bar() {\n-    ${0:todo!()}\n+fn bar() ${0:-> ()} {\n+    todo!()\n }\n \n fn foo2() {}\n@@ -426,8 +428,8 @@ mod baz {\n         bar();\n     }\n \n-    fn bar() {\n-        ${0:todo!()}\n+    fn bar() ${0:-> ()} {\n+        todo!()\n     }\n }\n \",\n@@ -452,8 +454,8 @@ fn foo() {\n     bar(baz());\n }\n \n-fn bar(baz: Baz) {\n-    ${0:todo!()}\n+fn bar(baz: Baz) ${0:-> ()} {\n+    todo!()\n }\n \",\n         );\n@@ -485,8 +487,8 @@ impl Baz {\n     }\n }\n \n-fn bar(baz: Baz) {\n-    ${0:todo!()}\n+fn bar(baz: Baz) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -506,8 +508,8 @@ fn foo() {\n     bar(\"bar\")\n }\n \n-fn bar(arg: &str) {\n-    ${0:todo!()}\n+fn bar(arg: &str) ${0:-> ()} {\n+    todo!()\n }\n \"#,\n         )\n@@ -527,8 +529,8 @@ fn foo() {\n     bar('x')\n }\n \n-fn bar(arg: char) {\n-    ${0:todo!()}\n+fn bar(arg: char) ${0:-> ()} {\n+    todo!()\n }\n \"#,\n         )\n@@ -548,8 +550,8 @@ fn foo() {\n     bar(42)\n }\n \n-fn bar(arg: i32) {\n-    ${0:todo!()}\n+fn bar(arg: i32) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -569,8 +571,8 @@ fn foo() {\n     bar(42 as u8)\n }\n \n-fn bar(arg: u8) {\n-    ${0:todo!()}\n+fn bar(arg: u8) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -594,8 +596,8 @@ fn foo() {\n     bar(x as u8)\n }\n \n-fn bar(x: u8) {\n-    ${0:todo!()}\n+fn bar(x: u8) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -617,8 +619,8 @@ fn foo() {\n     bar(worble)\n }\n \n-fn bar(worble: ()) {\n-    ${0:todo!()}\n+fn bar(worble: ()) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -646,8 +648,8 @@ fn baz() {\n     bar(foo())\n }\n \n-fn bar(foo: impl Foo) {\n-    ${0:todo!()}\n+fn bar(foo: impl Foo) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -673,8 +675,8 @@ fn foo() {\n     bar(&baz())\n }\n \n-fn bar(baz: &Baz) {\n-    ${0:todo!()}\n+fn bar(baz: &Baz) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -702,8 +704,8 @@ fn foo() {\n     bar(Baz::baz())\n }\n \n-fn bar(baz: Baz::Bof) {\n-    ${0:todo!()}\n+fn bar(baz: Baz::Bof) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -725,8 +727,8 @@ fn foo<T>(t: T) {\n     bar(t)\n }\n \n-fn bar<T>(t: T) {\n-    ${0:todo!()}\n+fn bar<T>(t: T) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -756,8 +758,8 @@ fn foo() {\n     bar(Baz::new);\n }\n \n-fn bar(arg: fn() -> Baz) {\n-    ${0:todo!()}\n+fn bar(arg: fn() -> Baz) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -781,8 +783,8 @@ fn foo() {\n     bar(closure)\n }\n \n-fn bar(closure: impl Fn(i64) -> i64) {\n-    ${0:todo!()}\n+fn bar(closure: impl Fn(i64) -> i64) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -802,8 +804,8 @@ fn foo() {\n     bar(baz)\n }\n \n-fn bar(baz: ()) {\n-    ${0:todo!()}\n+fn bar(baz: ()) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -827,8 +829,8 @@ fn foo() {\n     bar(baz(), baz())\n }\n \n-fn bar(baz_1: Baz, baz_2: Baz) {\n-    ${0:todo!()}\n+fn bar(baz_1: Baz, baz_2: Baz) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -852,8 +854,8 @@ fn foo() {\n     bar(baz(), baz(), \"foo\", \"bar\")\n }\n \n-fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n-    ${0:todo!()}\n+fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) ${0:-> ()} {\n+    todo!()\n }\n \"#,\n         )\n@@ -872,8 +874,8 @@ fn foo() {\n \",\n             r\"\n mod bar {\n-    pub(crate) fn my_fn() {\n-        ${0:todo!()}\n+    pub(crate) fn my_fn() ${0:-> ()} {\n+        todo!()\n     }\n }\n \n@@ -911,8 +913,8 @@ fn bar() {\n     baz(foo)\n }\n \n-fn baz(foo: foo::Foo) {\n-    ${0:todo!()}\n+fn baz(foo: foo::Foo) ${0:-> ()} {\n+    todo!()\n }\n \",\n         )\n@@ -935,8 +937,8 @@ fn foo() {\n mod bar {\n     fn something_else() {}\n \n-    pub(crate) fn my_fn() {\n-        ${0:todo!()}\n+    pub(crate) fn my_fn() ${0:-> ()} {\n+        todo!()\n     }\n }\n \n@@ -963,8 +965,8 @@ fn foo() {\n             r\"\n mod bar {\n     mod baz {\n-        pub(crate) fn my_fn() {\n-            ${0:todo!()}\n+        pub(crate) fn my_fn() ${0:-> ()} {\n+            todo!()\n         }\n     }\n }\n@@ -992,8 +994,8 @@ fn main() {\n             r\"\n \n \n-pub(crate) fn bar() {\n-    ${0:todo!()}\n+pub(crate) fn bar() ${0:-> ()} {\n+    todo!()\n }\",\n         )\n     }"}, {"sha": "41f536574eacedcb4451fd7fd0766bc2cd8f4abc", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -454,8 +454,8 @@ fn foo() {\n     bar(\"\", baz());\n }\n \n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n+fn bar(arg: &str, baz: Baz) ${0:-> ()} {\n+    todo!()\n }\n \n \"#####,"}, {"sha": "b65be4fe1b2c4c94923eb07bad7d767c915e9b9e", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -255,6 +255,25 @@ impl ModuleDef {\n             ModuleDef::BuiltinType(it) => Some(it.as_name()),\n         }\n     }\n+\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+        let id = match self {\n+            ModuleDef::Adt(it) => match it {\n+                Adt::Struct(it) => it.id.into(),\n+                Adt::Enum(it) => it.id.into(),\n+                Adt::Union(it) => it.id.into(),\n+            },\n+            ModuleDef::Trait(it) => it.id.into(),\n+            ModuleDef::Function(it) => it.id.into(),\n+            ModuleDef::TypeAlias(it) => it.id.into(),\n+            ModuleDef::Module(it) => it.id.into(),\n+            ModuleDef::Const(it) => it.id.into(),\n+            ModuleDef::Static(it) => it.id.into(),\n+            _ => return,\n+        };\n+\n+        hir_ty::diagnostics::validate_module_item(db, id, sink)\n+    }\n }\n \n pub use hir_def::{\n@@ -358,6 +377,8 @@ impl Module {\n         let crate_def_map = db.crate_def_map(self.id.krate);\n         crate_def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n         for decl in self.declarations(db) {\n+            decl.diagnostics(db, sink);\n+\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n                 crate::ModuleDef::Module(m) => {\n@@ -760,7 +781,8 @@ impl Function {\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n-        hir_ty::diagnostics::validate_body(db, self.id.into(), sink)\n+        hir_ty::diagnostics::validate_module_item(db, self.id.into(), sink);\n+        hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n     }\n \n     /// Whether this function declaration has a definition."}, {"sha": "da2b40849a58f7edd1510d7ce8a58cd8422d783b", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -2,5 +2,6 @@\n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{Diagnostic, DiagnosticSink, DiagnosticSinkBuilder};\n pub use hir_ty::diagnostics::{\n-    MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField,\n+    IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr,\n+    NoSuchField,\n };"}, {"sha": "a8b3fe844a5324a3777be38330d51e49a688e0de", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -95,6 +95,12 @@ impl ItemScope {\n         self.impls.iter().copied()\n     }\n \n+    pub fn values(\n+        &self,\n+    ) -> impl Iterator<Item = (ModuleDefId, Visibility)> + ExactSizeIterator + '_ {\n+        self.values.values().copied()\n+    }\n+\n     pub fn visibility_of(&self, def: ModuleDefId) -> Option<Visibility> {\n         self.name_of(ItemInNs::Types(def))\n             .or_else(|| self.name_of(ItemInNs::Values(def)))"}, {"sha": "dfe98571e718a1168f1bf042deba9cc633b6cd7c", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -2,10 +2,11 @@\n mod expr;\n mod match_check;\n mod unsafe_check;\n+mod decl_check;\n \n-use std::any::Any;\n+use std::{any::Any, fmt};\n \n-use hir_def::DefWithBodyId;\n+use hir_def::{DefWithBodyId, ModuleDefId};\n use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n@@ -15,6 +16,16 @@ use crate::db::HirDatabase;\n \n pub use crate::diagnostics::expr::{record_literal_missing_fields, record_pattern_missing_fields};\n \n+pub fn validate_module_item(\n+    db: &dyn HirDatabase,\n+    owner: ModuleDefId,\n+    sink: &mut DiagnosticSink<'_>,\n+) {\n+    let _p = profile::span(\"validate_module_item\");\n+    let mut validator = decl_check::DeclValidator::new(owner, sink);\n+    validator.validate_item(db);\n+}\n+\n pub fn validate_body(db: &dyn HirDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n     let _p = profile::span(\"validate_body\");\n     let infer = db.infer(owner);\n@@ -231,6 +242,66 @@ impl Diagnostic for MismatchedArgCount {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum CaseType {\n+    // `some_var`\n+    LowerSnakeCase,\n+    // `SOME_CONST`\n+    UpperSnakeCase,\n+    // `SomeStruct`\n+    UpperCamelCase,\n+}\n+\n+impl fmt::Display for CaseType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let repr = match self {\n+            CaseType::LowerSnakeCase => \"snake_case\",\n+            CaseType::UpperSnakeCase => \"UPPER_SNAKE_CASE\",\n+            CaseType::UpperCamelCase => \"CamelCase\",\n+        };\n+\n+        write!(f, \"{}\", repr)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct IncorrectCase {\n+    pub file: HirFileId,\n+    pub ident: AstPtr<ast::Name>,\n+    pub expected_case: CaseType,\n+    pub ident_type: String,\n+    pub ident_text: String,\n+    pub suggested_text: String,\n+}\n+\n+impl Diagnostic for IncorrectCase {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"incorrect-ident-case\")\n+    }\n+\n+    fn message(&self) -> String {\n+        format!(\n+            \"{} `{}` should have {} name, e.g. `{}`\",\n+            self.ident_type,\n+            self.ident_text,\n+            self.expected_case.to_string(),\n+            self.suggested_text\n+        )\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.ident.clone().into())\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n@@ -242,7 +313,10 @@ mod tests {\n     use rustc_hash::FxHashMap;\n     use syntax::{TextRange, TextSize};\n \n-    use crate::{diagnostics::validate_body, test_db::TestDB};\n+    use crate::{\n+        diagnostics::{validate_body, validate_module_item},\n+        test_db::TestDB,\n+    };\n \n     impl TestDB {\n         fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n@@ -253,6 +327,9 @@ mod tests {\n                 let mut fns = Vec::new();\n                 for (module_id, _) in crate_def_map.modules.iter() {\n                     for decl in crate_def_map[module_id].scope.declarations() {\n+                        let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n+                        validate_module_item(self, decl, &mut sink);\n+\n                         if let ModuleDefId::FunctionId(f) = decl {\n                             fns.push(f)\n                         }\n@@ -262,6 +339,8 @@ mod tests {\n                         let impl_data = self.impl_data(impl_id);\n                         for item in impl_data.items.iter() {\n                             if let AssocItemId::FunctionId(f) = item {\n+                                let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n+                                validate_module_item(self, ModuleDefId::FunctionId(*f), &mut sink);\n                                 fns.push(*f)\n                             }\n                         }"}, {"sha": "f987636fe57a18ce1efe9682f01a17574bf681bc", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "added", "additions": 833, "deletions": 0, "changes": 833, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -0,0 +1,833 @@\n+//! Provides validators for the item declarations.\n+//!\n+//! This includes the following items:\n+//!\n+//! - variable bindings (e.g. `let x = foo();`)\n+//! - struct fields (e.g. `struct Foo { field: u8 }`)\n+//! - enum variants (e.g. `enum Foo { Variant { field: u8 } }`)\n+//! - function/method arguments (e.g. `fn foo(arg: u8)`)\n+//! - constants (e.g. `const FOO: u8 = 10;`)\n+//! - static items (e.g. `static FOO: u8 = 10;`)\n+//! - match arm bindings (e.g. `foo @ Some(_)`)\n+\n+mod case_conv;\n+\n+use hir_def::{\n+    adt::VariantData,\n+    expr::{Pat, PatId},\n+    src::HasSource,\n+    AdtId, ConstId, EnumId, FunctionId, Lookup, ModuleDefId, StaticId, StructId,\n+};\n+use hir_expand::{\n+    diagnostics::DiagnosticSink,\n+    name::{AsName, Name},\n+};\n+use syntax::{\n+    ast::{self, NameOwner},\n+    AstNode, AstPtr,\n+};\n+\n+use crate::{\n+    db::HirDatabase,\n+    diagnostics::{decl_check::case_conv::*, CaseType, IncorrectCase},\n+};\n+\n+pub(super) struct DeclValidator<'a, 'b: 'a> {\n+    owner: ModuleDefId,\n+    sink: &'a mut DiagnosticSink<'b>,\n+}\n+\n+#[derive(Debug)]\n+struct Replacement {\n+    current_name: Name,\n+    suggested_text: String,\n+    expected_case: CaseType,\n+}\n+\n+impl<'a, 'b> DeclValidator<'a, 'b> {\n+    pub(super) fn new(\n+        owner: ModuleDefId,\n+        sink: &'a mut DiagnosticSink<'b>,\n+    ) -> DeclValidator<'a, 'b> {\n+        DeclValidator { owner, sink }\n+    }\n+\n+    pub(super) fn validate_item(&mut self, db: &dyn HirDatabase) {\n+        match self.owner {\n+            ModuleDefId::FunctionId(func) => self.validate_func(db, func),\n+            ModuleDefId::AdtId(adt) => self.validate_adt(db, adt),\n+            ModuleDefId::ConstId(const_id) => self.validate_const(db, const_id),\n+            ModuleDefId::StaticId(static_id) => self.validate_static(db, static_id),\n+            _ => return,\n+        }\n+    }\n+\n+    fn validate_adt(&mut self, db: &dyn HirDatabase, adt: AdtId) {\n+        match adt {\n+            AdtId::StructId(struct_id) => self.validate_struct(db, struct_id),\n+            AdtId::EnumId(enum_id) => self.validate_enum(db, enum_id),\n+            AdtId::UnionId(_) => {\n+                // Unions aren't yet supported by this validator.\n+            }\n+        }\n+    }\n+\n+    fn validate_func(&mut self, db: &dyn HirDatabase, func: FunctionId) {\n+        let data = db.function_data(func);\n+        let body = db.body(func.into());\n+\n+        // 1. Check the function name.\n+        let function_name = data.name.to_string();\n+        let fn_name_replacement = if let Some(new_name) = to_lower_snake_case(&function_name) {\n+            let replacement = Replacement {\n+                current_name: data.name.clone(),\n+                suggested_text: new_name,\n+                expected_case: CaseType::LowerSnakeCase,\n+            };\n+            Some(replacement)\n+        } else {\n+            None\n+        };\n+\n+        // 2. Check the param names.\n+        let mut fn_param_replacements = Vec::new();\n+\n+        for pat_id in body.params.iter().cloned() {\n+            let pat = &body[pat_id];\n+\n+            let param_name = match pat {\n+                Pat::Bind { name, .. } => name,\n+                _ => continue,\n+            };\n+\n+            let name = param_name.to_string();\n+            if let Some(new_name) = to_lower_snake_case(&name) {\n+                let replacement = Replacement {\n+                    current_name: param_name.clone(),\n+                    suggested_text: new_name,\n+                    expected_case: CaseType::LowerSnakeCase,\n+                };\n+                fn_param_replacements.push(replacement);\n+            }\n+        }\n+\n+        // 3. Check the patterns inside the function body.\n+        let mut pats_replacements = Vec::new();\n+\n+        for (pat_idx, pat) in body.pats.iter() {\n+            if body.params.contains(&pat_idx) {\n+                // We aren't interested in function parameters, we've processed them above.\n+                continue;\n+            }\n+\n+            let bind_name = match pat {\n+                Pat::Bind { name, .. } => name,\n+                _ => continue,\n+            };\n+\n+            let name = bind_name.to_string();\n+            if let Some(new_name) = to_lower_snake_case(&name) {\n+                let replacement = Replacement {\n+                    current_name: bind_name.clone(),\n+                    suggested_text: new_name,\n+                    expected_case: CaseType::LowerSnakeCase,\n+                };\n+                pats_replacements.push((pat_idx, replacement));\n+            }\n+        }\n+\n+        // 4. If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n+        self.create_incorrect_case_diagnostic_for_func(\n+            func,\n+            db,\n+            fn_name_replacement,\n+            fn_param_replacements,\n+        );\n+        self.create_incorrect_case_diagnostic_for_variables(func, db, pats_replacements);\n+\n+        // 5. Recursively validate inner scope items, such as static variables and constants.\n+        for (item_id, _) in body.item_scope.values() {\n+            let mut validator = DeclValidator::new(item_id, self.sink);\n+            validator.validate_item(db);\n+        }\n+    }\n+\n+    /// Given the information about incorrect names in the function declaration, looks up into the source code\n+    /// for exact locations and adds diagnostics into the sink.\n+    fn create_incorrect_case_diagnostic_for_func(\n+        &mut self,\n+        func: FunctionId,\n+        db: &dyn HirDatabase,\n+        fn_name_replacement: Option<Replacement>,\n+        fn_param_replacements: Vec<Replacement>,\n+    ) {\n+        // XXX: only look at sources if we do have incorrect names\n+        if fn_name_replacement.is_none() && fn_param_replacements.is_empty() {\n+            return;\n+        }\n+\n+        let fn_loc = func.lookup(db.upcast());\n+        let fn_src = fn_loc.source(db.upcast());\n+\n+        // 1. Diagnostic for function name.\n+        if let Some(replacement) = fn_name_replacement {\n+            let ast_ptr = match fn_src.value.name() {\n+                Some(name) => name,\n+                None => {\n+                    // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n+                    log::error!(\n+                        \"Replacement ({:?}) was generated for a function without a name: {:?}\",\n+                        replacement,\n+                        fn_src\n+                    );\n+                    return;\n+                }\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: fn_src.file_id,\n+                ident_type: \"Function\".to_string(),\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: replacement.expected_case,\n+                ident_text: replacement.current_name.to_string(),\n+                suggested_text: replacement.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+\n+        // 2. Diagnostics for function params.\n+        let fn_params_list = match fn_src.value.param_list() {\n+            Some(params) => params,\n+            None => {\n+                if !fn_param_replacements.is_empty() {\n+                    log::error!(\n+                        \"Replacements ({:?}) were generated for a function parameters which had no parameters list: {:?}\",\n+                        fn_param_replacements, fn_src\n+                    );\n+                }\n+                return;\n+            }\n+        };\n+        let mut fn_params_iter = fn_params_list.params();\n+        for param_to_rename in fn_param_replacements {\n+            // We assume that parameters in replacement are in the same order as in the\n+            // actual params list, but just some of them (ones that named correctly) are skipped.\n+            let ast_ptr: ast::Name = loop {\n+                match fn_params_iter.next() {\n+                    Some(element)\n+                        if pat_equals_to_name(element.pat(), &param_to_rename.current_name) =>\n+                    {\n+                        if let ast::Pat::IdentPat(pat) = element.pat().unwrap() {\n+                            break pat.name().unwrap();\n+                        } else {\n+                            // This is critical. If we consider this parameter the expected one,\n+                            // it **must** have a name.\n+                            panic!(\n+                                \"Pattern {:?} equals to expected replacement {:?}, but has no name\",\n+                                element, param_to_rename\n+                            );\n+                        }\n+                    }\n+                    Some(_) => {}\n+                    None => {\n+                        log::error!(\n+                            \"Replacement ({:?}) was generated for a function parameter which was not found: {:?}\",\n+                            param_to_rename, fn_src\n+                        );\n+                        return;\n+                    }\n+                }\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: fn_src.file_id,\n+                ident_type: \"Argument\".to_string(),\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: param_to_rename.expected_case,\n+                ident_text: param_to_rename.current_name.to_string(),\n+                suggested_text: param_to_rename.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+    }\n+\n+    /// Given the information about incorrect variable names, looks up into the source code\n+    /// for exact locations and adds diagnostics into the sink.\n+    fn create_incorrect_case_diagnostic_for_variables(\n+        &mut self,\n+        func: FunctionId,\n+        db: &dyn HirDatabase,\n+        pats_replacements: Vec<(PatId, Replacement)>,\n+    ) {\n+        // XXX: only look at source_map if we do have missing fields\n+        if pats_replacements.is_empty() {\n+            return;\n+        }\n+\n+        let (_, source_map) = db.body_with_source_map(func.into());\n+\n+        for (id, replacement) in pats_replacements {\n+            if let Ok(source_ptr) = source_map.pat_syntax(id) {\n+                if let Some(expr) = source_ptr.value.as_ref().left() {\n+                    let root = source_ptr.file_syntax(db.upcast());\n+                    if let ast::Pat::IdentPat(ident_pat) = expr.to_node(&root) {\n+                        let parent = match ident_pat.syntax().parent() {\n+                            Some(parent) => parent,\n+                            None => continue,\n+                        };\n+                        let name_ast = match ident_pat.name() {\n+                            Some(name_ast) => name_ast,\n+                            None => continue,\n+                        };\n+\n+                        // We have to check that it's either `let var = ...` or `var @ Variant(_)` statement,\n+                        // because e.g. match arms are patterns as well.\n+                        // In other words, we check that it's a named variable binding.\n+                        let is_binding = ast::LetStmt::cast(parent.clone()).is_some()\n+                            || (ast::MatchArm::cast(parent).is_some()\n+                                && ident_pat.at_token().is_some());\n+                        if !is_binding {\n+                            // This pattern is not an actual variable declaration, e.g. `Some(val) => {..}` match arm.\n+                            continue;\n+                        }\n+\n+                        let diagnostic = IncorrectCase {\n+                            file: source_ptr.file_id,\n+                            ident_type: \"Variable\".to_string(),\n+                            ident: AstPtr::new(&name_ast).into(),\n+                            expected_case: replacement.expected_case,\n+                            ident_text: replacement.current_name.to_string(),\n+                            suggested_text: replacement.suggested_text,\n+                        };\n+\n+                        self.sink.push(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn validate_struct(&mut self, db: &dyn HirDatabase, struct_id: StructId) {\n+        let data = db.struct_data(struct_id);\n+\n+        // 1. Check the structure name.\n+        let struct_name = data.name.to_string();\n+        let struct_name_replacement = if let Some(new_name) = to_camel_case(&struct_name) {\n+            let replacement = Replacement {\n+                current_name: data.name.clone(),\n+                suggested_text: new_name,\n+                expected_case: CaseType::UpperCamelCase,\n+            };\n+            Some(replacement)\n+        } else {\n+            None\n+        };\n+\n+        // 2. Check the field names.\n+        let mut struct_fields_replacements = Vec::new();\n+\n+        if let VariantData::Record(fields) = data.variant_data.as_ref() {\n+            for (_, field) in fields.iter() {\n+                let field_name = field.name.to_string();\n+                if let Some(new_name) = to_lower_snake_case(&field_name) {\n+                    let replacement = Replacement {\n+                        current_name: field.name.clone(),\n+                        suggested_text: new_name,\n+                        expected_case: CaseType::LowerSnakeCase,\n+                    };\n+                    struct_fields_replacements.push(replacement);\n+                }\n+            }\n+        }\n+\n+        // 3. If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n+        self.create_incorrect_case_diagnostic_for_struct(\n+            struct_id,\n+            db,\n+            struct_name_replacement,\n+            struct_fields_replacements,\n+        );\n+    }\n+\n+    /// Given the information about incorrect names in the struct declaration, looks up into the source code\n+    /// for exact locations and adds diagnostics into the sink.\n+    fn create_incorrect_case_diagnostic_for_struct(\n+        &mut self,\n+        struct_id: StructId,\n+        db: &dyn HirDatabase,\n+        struct_name_replacement: Option<Replacement>,\n+        struct_fields_replacements: Vec<Replacement>,\n+    ) {\n+        // XXX: only look at sources if we do have incorrect names\n+        if struct_name_replacement.is_none() && struct_fields_replacements.is_empty() {\n+            return;\n+        }\n+\n+        let struct_loc = struct_id.lookup(db.upcast());\n+        let struct_src = struct_loc.source(db.upcast());\n+\n+        if let Some(replacement) = struct_name_replacement {\n+            let ast_ptr = match struct_src.value.name() {\n+                Some(name) => name,\n+                None => {\n+                    // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n+                    log::error!(\n+                        \"Replacement ({:?}) was generated for a structure without a name: {:?}\",\n+                        replacement,\n+                        struct_src\n+                    );\n+                    return;\n+                }\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: struct_src.file_id,\n+                ident_type: \"Structure\".to_string(),\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: replacement.expected_case,\n+                ident_text: replacement.current_name.to_string(),\n+                suggested_text: replacement.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+\n+        let struct_fields_list = match struct_src.value.field_list() {\n+            Some(ast::FieldList::RecordFieldList(fields)) => fields,\n+            _ => {\n+                if !struct_fields_replacements.is_empty() {\n+                    log::error!(\n+                        \"Replacements ({:?}) were generated for a structure fields which had no fields list: {:?}\",\n+                        struct_fields_replacements, struct_src\n+                    );\n+                }\n+                return;\n+            }\n+        };\n+        let mut struct_fields_iter = struct_fields_list.fields();\n+        for field_to_rename in struct_fields_replacements {\n+            // We assume that parameters in replacement are in the same order as in the\n+            // actual params list, but just some of them (ones that named correctly) are skipped.\n+            let ast_ptr = loop {\n+                match struct_fields_iter.next() {\n+                    Some(element) if names_equal(element.name(), &field_to_rename.current_name) => {\n+                        break element.name().unwrap()\n+                    }\n+                    Some(_) => {}\n+                    None => {\n+                        log::error!(\n+                            \"Replacement ({:?}) was generated for a structure field which was not found: {:?}\",\n+                            field_to_rename, struct_src\n+                        );\n+                        return;\n+                    }\n+                }\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: struct_src.file_id,\n+                ident_type: \"Field\".to_string(),\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: field_to_rename.expected_case,\n+                ident_text: field_to_rename.current_name.to_string(),\n+                suggested_text: field_to_rename.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+    }\n+\n+    fn validate_enum(&mut self, db: &dyn HirDatabase, enum_id: EnumId) {\n+        let data = db.enum_data(enum_id);\n+\n+        // 1. Check the enum name.\n+        let enum_name = data.name.to_string();\n+        let enum_name_replacement = if let Some(new_name) = to_camel_case(&enum_name) {\n+            let replacement = Replacement {\n+                current_name: data.name.clone(),\n+                suggested_text: new_name,\n+                expected_case: CaseType::UpperCamelCase,\n+            };\n+            Some(replacement)\n+        } else {\n+            None\n+        };\n+\n+        // 2. Check the field names.\n+        let mut enum_fields_replacements = Vec::new();\n+\n+        for (_, variant) in data.variants.iter() {\n+            let variant_name = variant.name.to_string();\n+            if let Some(new_name) = to_camel_case(&variant_name) {\n+                let replacement = Replacement {\n+                    current_name: variant.name.clone(),\n+                    suggested_text: new_name,\n+                    expected_case: CaseType::UpperCamelCase,\n+                };\n+                enum_fields_replacements.push(replacement);\n+            }\n+        }\n+\n+        // 3. If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n+        self.create_incorrect_case_diagnostic_for_enum(\n+            enum_id,\n+            db,\n+            enum_name_replacement,\n+            enum_fields_replacements,\n+        )\n+    }\n+\n+    /// Given the information about incorrect names in the struct declaration, looks up into the source code\n+    /// for exact locations and adds diagnostics into the sink.\n+    fn create_incorrect_case_diagnostic_for_enum(\n+        &mut self,\n+        enum_id: EnumId,\n+        db: &dyn HirDatabase,\n+        enum_name_replacement: Option<Replacement>,\n+        enum_variants_replacements: Vec<Replacement>,\n+    ) {\n+        // XXX: only look at sources if we do have incorrect names\n+        if enum_name_replacement.is_none() && enum_variants_replacements.is_empty() {\n+            return;\n+        }\n+\n+        let enum_loc = enum_id.lookup(db.upcast());\n+        let enum_src = enum_loc.source(db.upcast());\n+\n+        if let Some(replacement) = enum_name_replacement {\n+            let ast_ptr = match enum_src.value.name() {\n+                Some(name) => name,\n+                None => {\n+                    // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n+                    log::error!(\n+                        \"Replacement ({:?}) was generated for a enum without a name: {:?}\",\n+                        replacement,\n+                        enum_src\n+                    );\n+                    return;\n+                }\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: enum_src.file_id,\n+                ident_type: \"Enum\".to_string(),\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: replacement.expected_case,\n+                ident_text: replacement.current_name.to_string(),\n+                suggested_text: replacement.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+\n+        let enum_variants_list = match enum_src.value.variant_list() {\n+            Some(variants) => variants,\n+            _ => {\n+                if !enum_variants_replacements.is_empty() {\n+                    log::error!(\n+                        \"Replacements ({:?}) were generated for a enum variants which had no fields list: {:?}\",\n+                        enum_variants_replacements, enum_src\n+                    );\n+                }\n+                return;\n+            }\n+        };\n+        let mut enum_variants_iter = enum_variants_list.variants();\n+        for variant_to_rename in enum_variants_replacements {\n+            // We assume that parameters in replacement are in the same order as in the\n+            // actual params list, but just some of them (ones that named correctly) are skipped.\n+            let ast_ptr = loop {\n+                match enum_variants_iter.next() {\n+                    Some(variant)\n+                        if names_equal(variant.name(), &variant_to_rename.current_name) =>\n+                    {\n+                        break variant.name().unwrap()\n+                    }\n+                    Some(_) => {}\n+                    None => {\n+                        log::error!(\n+                            \"Replacement ({:?}) was generated for a enum variant which was not found: {:?}\",\n+                            variant_to_rename, enum_src\n+                        );\n+                        return;\n+                    }\n+                }\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: enum_src.file_id,\n+                ident_type: \"Variant\".to_string(),\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: variant_to_rename.expected_case,\n+                ident_text: variant_to_rename.current_name.to_string(),\n+                suggested_text: variant_to_rename.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+    }\n+\n+    fn validate_const(&mut self, db: &dyn HirDatabase, const_id: ConstId) {\n+        let data = db.const_data(const_id);\n+\n+        let name = match &data.name {\n+            Some(name) => name,\n+            None => return,\n+        };\n+\n+        let const_name = name.to_string();\n+        let replacement = if let Some(new_name) = to_upper_snake_case(&const_name) {\n+            Replacement {\n+                current_name: name.clone(),\n+                suggested_text: new_name,\n+                expected_case: CaseType::UpperSnakeCase,\n+            }\n+        } else {\n+            // Nothing to do here.\n+            return;\n+        };\n+\n+        let const_loc = const_id.lookup(db.upcast());\n+        let const_src = const_loc.source(db.upcast());\n+\n+        let ast_ptr = match const_src.value.name() {\n+            Some(name) => name,\n+            None => return,\n+        };\n+\n+        let diagnostic = IncorrectCase {\n+            file: const_src.file_id,\n+            ident_type: \"Constant\".to_string(),\n+            ident: AstPtr::new(&ast_ptr).into(),\n+            expected_case: replacement.expected_case,\n+            ident_text: replacement.current_name.to_string(),\n+            suggested_text: replacement.suggested_text,\n+        };\n+\n+        self.sink.push(diagnostic);\n+    }\n+\n+    fn validate_static(&mut self, db: &dyn HirDatabase, static_id: StaticId) {\n+        let data = db.static_data(static_id);\n+\n+        let name = match &data.name {\n+            Some(name) => name,\n+            None => return,\n+        };\n+\n+        let static_name = name.to_string();\n+        let replacement = if let Some(new_name) = to_upper_snake_case(&static_name) {\n+            Replacement {\n+                current_name: name.clone(),\n+                suggested_text: new_name,\n+                expected_case: CaseType::UpperSnakeCase,\n+            }\n+        } else {\n+            // Nothing to do here.\n+            return;\n+        };\n+\n+        let static_loc = static_id.lookup(db.upcast());\n+        let static_src = static_loc.source(db.upcast());\n+\n+        let ast_ptr = match static_src.value.name() {\n+            Some(name) => name,\n+            None => return,\n+        };\n+\n+        let diagnostic = IncorrectCase {\n+            file: static_src.file_id,\n+            ident_type: \"Static variable\".to_string(),\n+            ident: AstPtr::new(&ast_ptr).into(),\n+            expected_case: replacement.expected_case,\n+            ident_text: replacement.current_name.to_string(),\n+            suggested_text: replacement.suggested_text,\n+        };\n+\n+        self.sink.push(diagnostic);\n+    }\n+}\n+\n+fn names_equal(left: Option<ast::Name>, right: &Name) -> bool {\n+    if let Some(left) = left {\n+        &left.as_name() == right\n+    } else {\n+        false\n+    }\n+}\n+\n+fn pat_equals_to_name(pat: Option<ast::Pat>, name: &Name) -> bool {\n+    if let Some(ast::Pat::IdentPat(ident)) = pat {\n+        ident.to_string() == name.to_string()\n+    } else {\n+        false\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn incorrect_function_name() {\n+        check_diagnostics(\n+            r#\"\n+fn NonSnakeCaseName() {}\n+// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_function_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(SomeParam: u8) {}\n+    // ^^^^^^^^^ Argument `SomeParam` should have snake_case name, e.g. `some_param`\n+\n+fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n+                     // ^^^^^^^^^^ Argument `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_variable_names() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let SOME_VALUE = 10;\n+     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n+    let AnotherValue = 20;\n+     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_name() {\n+        check_diagnostics(\n+            r#\"\n+struct non_camel_case_name {}\n+    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_field() {\n+        check_diagnostics(\n+            r#\"\n+struct SomeStruct { SomeField: u8 }\n+                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_name() {\n+        check_diagnostics(\n+            r#\"\n+enum some_enum { Val(u8) }\n+  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_variant_name() {\n+        check_diagnostics(\n+            r#\"\n+enum SomeEnum { SOME_VARIANT(u8) }\n+             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_const_name() {\n+        check_diagnostics(\n+            r#\"\n+const some_weird_const: u8 = 10;\n+   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\n+fn func() {\n+    const someConstInFunc: &str = \"hi there\";\n+       // ^^^^^^^^^^^^^^^ Constant `someConstInFunc` should have UPPER_SNAKE_CASE name, e.g. `SOME_CONST_IN_FUNC`\n+\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_static_name() {\n+        check_diagnostics(\n+            r#\"\n+static some_weird_const: u8 = 10;\n+    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\n+fn func() {\n+    static someConstInFunc: &str = \"hi there\";\n+        // ^^^^^^^^^^^^^^^ Static variable `someConstInFunc` should have UPPER_SNAKE_CASE name, e.g. `SOME_CONST_IN_FUNC`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_inside_impl_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct someStruct;\n+    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n+\n+impl someStruct {\n+    fn SomeFunc(&self) {\n+    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n+        static someConstInFunc: &str = \"hi there\";\n+            // ^^^^^^^^^^^^^^^ Static variable `someConstInFunc` should have UPPER_SNAKE_CASE name, e.g. `SOME_CONST_IN_FUNC`\n+        let WHY_VAR_IS_CAPS = 10;\n+         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_enum_varinats() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        None => (),\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_let_bind() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        SOME_VAR @ None => (),\n+     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "3800f2a6b355a40f18bb71c7f5d429c59695136f", "filename": "crates/hir_ty/src/diagnostics/decl_check/case_conv.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -0,0 +1,194 @@\n+//! Functions for string case manipulation, such as detecting the identifier case,\n+//! and converting it into appropriate form.\n+\n+#[derive(Debug)]\n+enum DetectedCase {\n+    LowerCamelCase,\n+    UpperCamelCase,\n+    LowerSnakeCase,\n+    UpperSnakeCase,\n+    Unknown,\n+}\n+\n+fn detect_case(ident: &str) -> DetectedCase {\n+    let trimmed_ident = ident.trim_matches('_');\n+    let first_lowercase = trimmed_ident.starts_with(|chr: char| chr.is_ascii_lowercase());\n+    let mut has_lowercase = first_lowercase;\n+    let mut has_uppercase = false;\n+    let mut has_underscore = false;\n+\n+    for chr in trimmed_ident.chars() {\n+        if chr == '_' {\n+            has_underscore = true;\n+        } else if chr.is_ascii_uppercase() {\n+            has_uppercase = true;\n+        } else if chr.is_ascii_lowercase() {\n+            has_lowercase = true;\n+        }\n+    }\n+\n+    if has_uppercase {\n+        if !has_lowercase {\n+            DetectedCase::UpperSnakeCase\n+        } else if !has_underscore {\n+            if first_lowercase {\n+                DetectedCase::LowerCamelCase\n+            } else {\n+                DetectedCase::UpperCamelCase\n+            }\n+        } else {\n+            // It has uppercase, it has lowercase, it has underscore.\n+            // No assumptions here\n+            DetectedCase::Unknown\n+        }\n+    } else {\n+        DetectedCase::LowerSnakeCase\n+    }\n+}\n+\n+/// Converts an identifier to an UpperCamelCase form.\n+/// Returns `None` if the string is already is UpperCamelCase.\n+pub fn to_camel_case(ident: &str) -> Option<String> {\n+    let detected_case = detect_case(ident);\n+\n+    match detected_case {\n+        DetectedCase::UpperCamelCase => return None,\n+        DetectedCase::LowerCamelCase => {\n+            let mut first_capitalized = false;\n+            let output = ident\n+                .chars()\n+                .map(|chr| {\n+                    if !first_capitalized && chr.is_ascii_lowercase() {\n+                        first_capitalized = true;\n+                        chr.to_ascii_uppercase()\n+                    } else {\n+                        chr\n+                    }\n+                })\n+                .collect();\n+            return Some(output);\n+        }\n+        _ => {}\n+    }\n+\n+    let mut output = String::with_capacity(ident.len());\n+\n+    let mut capital_added = false;\n+    for chr in ident.chars() {\n+        if chr.is_alphabetic() {\n+            if !capital_added {\n+                output.push(chr.to_ascii_uppercase());\n+                capital_added = true;\n+            } else {\n+                output.push(chr.to_ascii_lowercase());\n+            }\n+        } else if chr == '_' {\n+            // Skip this character and make the next one capital.\n+            capital_added = false;\n+        } else {\n+            // Put the characted as-is.\n+            output.push(chr);\n+        }\n+    }\n+\n+    if output == ident {\n+        // While we didn't detect the correct case at the beginning, there\n+        // may be special cases: e.g. `A` is both valid CamelCase and UPPER_SNAKE_CASE.\n+        None\n+    } else {\n+        Some(output)\n+    }\n+}\n+\n+/// Converts an identifier to a lower_snake_case form.\n+/// Returns `None` if the string is already in lower_snake_case.\n+pub fn to_lower_snake_case(ident: &str) -> Option<String> {\n+    // First, assume that it's UPPER_SNAKE_CASE.\n+    match detect_case(ident) {\n+        DetectedCase::LowerSnakeCase => return None,\n+        DetectedCase::UpperSnakeCase => {\n+            return Some(ident.chars().map(|chr| chr.to_ascii_lowercase()).collect())\n+        }\n+        _ => {}\n+    }\n+\n+    // Otherwise, assume that it's CamelCase.\n+    let lower_snake_case = stdx::to_lower_snake_case(ident);\n+\n+    if lower_snake_case == ident {\n+        // While we didn't detect the correct case at the beginning, there\n+        // may be special cases: e.g. `a` is both valid camelCase and snake_case.\n+        None\n+    } else {\n+        Some(lower_snake_case)\n+    }\n+}\n+\n+/// Converts an identifier to an UPPER_SNAKE_CASE form.\n+/// Returns `None` if the string is already is UPPER_SNAKE_CASE.\n+pub fn to_upper_snake_case(ident: &str) -> Option<String> {\n+    match detect_case(ident) {\n+        DetectedCase::UpperSnakeCase => return None,\n+        DetectedCase::LowerSnakeCase => {\n+            return Some(ident.chars().map(|chr| chr.to_ascii_uppercase()).collect())\n+        }\n+        _ => {}\n+    }\n+\n+    // Normalize the string from whatever form it's in currently, and then just make it uppercase.\n+    let upper_snake_case = stdx::to_upper_snake_case(ident);\n+\n+    if upper_snake_case == ident {\n+        // While we didn't detect the correct case at the beginning, there\n+        // may be special cases: e.g. `A` is both valid CamelCase and UPPER_SNAKE_CASE.\n+        None\n+    } else {\n+        Some(upper_snake_case)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check<F: Fn(&str) -> Option<String>>(fun: F, input: &str, expect: Expect) {\n+        // `None` is translated to empty string, meaning that there is nothing to fix.\n+        let output = fun(input).unwrap_or_default();\n+\n+        expect.assert_eq(&output);\n+    }\n+\n+    #[test]\n+    fn test_to_lower_snake_case() {\n+        check(to_lower_snake_case, \"lower_snake_case\", expect![[\"\"]]);\n+        check(to_lower_snake_case, \"UPPER_SNAKE_CASE\", expect![[\"upper_snake_case\"]]);\n+        check(to_lower_snake_case, \"Weird_Case\", expect![[\"weird_case\"]]);\n+        check(to_lower_snake_case, \"CamelCase\", expect![[\"camel_case\"]]);\n+        check(to_lower_snake_case, \"lowerCamelCase\", expect![[\"lower_camel_case\"]]);\n+        check(to_lower_snake_case, \"a\", expect![[\"\"]]);\n+    }\n+\n+    #[test]\n+    fn test_to_camel_case() {\n+        check(to_camel_case, \"CamelCase\", expect![[\"\"]]);\n+        check(to_camel_case, \"CamelCase_\", expect![[\"\"]]);\n+        check(to_camel_case, \"_CamelCase\", expect![[\"\"]]);\n+        check(to_camel_case, \"lowerCamelCase\", expect![[\"LowerCamelCase\"]]);\n+        check(to_camel_case, \"lower_snake_case\", expect![[\"LowerSnakeCase\"]]);\n+        check(to_camel_case, \"UPPER_SNAKE_CASE\", expect![[\"UpperSnakeCase\"]]);\n+        check(to_camel_case, \"Weird_Case\", expect![[\"WeirdCase\"]]);\n+        check(to_camel_case, \"name\", expect![[\"Name\"]]);\n+        check(to_camel_case, \"A\", expect![[\"\"]]);\n+    }\n+\n+    #[test]\n+    fn test_to_upper_snake_case() {\n+        check(to_upper_snake_case, \"UPPER_SNAKE_CASE\", expect![[\"\"]]);\n+        check(to_upper_snake_case, \"lower_snake_case\", expect![[\"LOWER_SNAKE_CASE\"]]);\n+        check(to_upper_snake_case, \"Weird_Case\", expect![[\"WEIRD_CASE\"]]);\n+        check(to_upper_snake_case, \"CamelCase\", expect![[\"CAMEL_CASE\"]]);\n+        check(to_upper_snake_case, \"lowerCamelCase\", expect![[\"LOWER_CAMEL_CASE\"]]);\n+        check(to_upper_snake_case, \"A\", expect![[\"\"]]);\n+    }\n+}"}, {"sha": "21a121aad7e7844a65d90e0745cb18aa6ec87ff9", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -190,13 +190,13 @@ struct Ty {\n     a: u8,\n }\n \n-static mut static_mut: Ty = Ty { a: 0 };\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n \n fn main() {\n-    let x = static_mut.a;\n+    let x = STATIC_MUT.a;\n           //^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n     unsafe {\n-        let x = static_mut.a;\n+        let x = STATIC_MUT.a;\n     }\n }\n \"#,"}, {"sha": "b30cdb6edd1196e1d4d2332b8ae5938033cb8b6c", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 139, "deletions": 2, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -96,6 +96,9 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::NoSuchField, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n+        .on::<hir::diagnostics::IncorrectCase, _>(|d| {\n+            res.borrow_mut().push(warning_with_fix(d, &sema));\n+        })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n         .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n@@ -130,6 +133,15 @@ fn diagnostic_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabas\n     }\n }\n \n+fn warning_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabase>) -> Diagnostic {\n+    Diagnostic {\n+        range: sema.diagnostics_display_range(d).range,\n+        message: d.message(),\n+        severity: Severity::WeakWarning,\n+        fix: d.fix(&sema),\n+    }\n+}\n+\n fn check_unnecessary_braces_in_use_statement(\n     acc: &mut Vec<Diagnostic>,\n     file_id: FileId,\n@@ -245,8 +257,37 @@ mod tests {\n \n         assert_eq_text!(&after, &actual);\n         assert!(\n-            fix.fix_trigger_range.start() <= file_position.offset\n-                && fix.fix_trigger_range.end() >= file_position.offset,\n+            fix.fix_trigger_range.contains_inclusive(file_position.offset),\n+            \"diagnostic fix range {:?} does not touch cursor position {:?}\",\n+            fix.fix_trigger_range,\n+            file_position.offset\n+        );\n+    }\n+\n+    /// Similar to `check_fix`, but applies all the available fixes.\n+    fn check_fixes(ra_fixture_before: &str, ra_fixture_after: &str) {\n+        let after = trim_indent(ra_fixture_after);\n+\n+        let (analysis, file_position) = fixture::position(ra_fixture_before);\n+        let diagnostic = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), file_position.file_id)\n+            .unwrap()\n+            .pop()\n+            .unwrap();\n+        let fix = diagnostic.fix.unwrap();\n+        let target_file_contents = analysis.file_text(file_position.file_id).unwrap();\n+        let actual = {\n+            let mut actual = target_file_contents.to_string();\n+            // Go from the last one to the first one, so that ranges won't be affected by previous edits.\n+            for edit in fix.source_change.source_file_edits.iter().rev() {\n+                edit.edit.apply(&mut actual);\n+            }\n+            actual\n+        };\n+\n+        assert_eq_text!(&after, &actual);\n+        assert!(\n+            fix.fix_trigger_range.contains_inclusive(file_position.offset),\n             \"diagnostic fix range {:?} does not touch cursor position {:?}\",\n             fix.fix_trigger_range,\n             file_position.offset\n@@ -790,4 +831,100 @@ struct Foo {\n         let diagnostics = analysis.diagnostics(&DiagnosticsConfig::default(), file_id).unwrap();\n         assert!(!diagnostics.is_empty());\n     }\n+\n+    #[test]\n+    fn test_rename_incorrect_case() {\n+        check_fixes(\n+            r#\"\n+pub struct test_struct<|> { one: i32 }\n+\n+pub fn some_fn(val: test_struct) -> test_struct {\n+    test_struct { one: val.one + 1 }\n+}\n+\"#,\n+            r#\"\n+pub struct TestStruct { one: i32 }\n+\n+pub fn some_fn(val: TestStruct) -> TestStruct {\n+    TestStruct { one: val.one + 1 }\n+}\n+\"#,\n+        );\n+\n+        check_fixes(\n+            r#\"\n+pub fn some_fn(NonSnakeCase<|>: u8) -> u8 {\n+    NonSnakeCase\n+}\n+\"#,\n+            r#\"\n+pub fn some_fn(non_snake_case: u8) -> u8 {\n+    non_snake_case\n+}\n+\"#,\n+        );\n+\n+        check_fixes(\n+            r#\"\n+pub fn SomeFn<|>(val: u8) -> u8 {\n+    if val != 0 { SomeFn(val - 1) } else { val }\n+}\n+\"#,\n+            r#\"\n+pub fn some_fn(val: u8) -> u8 {\n+    if val != 0 { some_fn(val - 1) } else { val }\n+}\n+\"#,\n+        );\n+\n+        check_fixes(\n+            r#\"\n+fn some_fn() {\n+    let whatAWeird_Formatting<|> = 10;\n+    another_func(whatAWeird_Formatting);\n+}\n+\"#,\n+            r#\"\n+fn some_fn() {\n+    let what_a_weird_formatting = 10;\n+    another_func(what_a_weird_formatting);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_uppercase_const_no_diagnostics() {\n+        check_no_diagnostics(\n+            r#\"\n+fn foo() {\n+    const ANOTHER_ITEM<|>: &str = \"some_item\";\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_incorrect_case_struct_method() {\n+        check_fixes(\n+            r#\"\n+pub struct TestStruct;\n+\n+impl TestStruct {\n+    pub fn SomeFn<|>() -> TestStruct {\n+        TestStruct\n+    }\n+}\n+\"#,\n+            r#\"\n+pub struct TestStruct;\n+\n+impl TestStruct {\n+    pub fn some_fn() -> TestStruct {\n+        TestStruct\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "0c75e50b01794ff30ce9c33b80cc655428878f39", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -3,7 +3,10 @@\n use base_db::FileId;\n use hir::{\n     db::AstDatabase,\n-    diagnostics::{Diagnostic, MissingFields, MissingOkInTailExpr, NoSuchField, UnresolvedModule},\n+    diagnostics::{\n+        Diagnostic, IncorrectCase, MissingFields, MissingOkInTailExpr, NoSuchField,\n+        UnresolvedModule,\n+    },\n     HasSource, HirDisplay, Semantics, VariantDef,\n };\n use ide_db::{\n@@ -17,7 +20,7 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::diagnostics::Fix;\n+use crate::{diagnostics::Fix, references::rename::rename_with_semantics, FilePosition};\n \n /// A [Diagnostic] that potentially has a fix available.\n ///\n@@ -99,6 +102,23 @@ impl DiagnosticWithFix for MissingOkInTailExpr {\n     }\n }\n \n+impl DiagnosticWithFix for IncorrectCase {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let name_node = self.ident.to_node(&root);\n+\n+        let file_id = self.file.original_file(sema.db);\n+        let offset = name_node.syntax().text_range().start();\n+        let file_position = FilePosition { file_id, offset };\n+\n+        let rename_changes =\n+            rename_with_semantics(sema, file_position, &self.suggested_text).ok()?;\n+\n+        let label = format!(\"Rename to {}\", self.suggested_text);\n+        Some(Fix::new(&label, rename_changes.info, rename_changes.range))\n+    }\n+}\n+\n fn missing_record_expr_field_fix(\n     sema: &Semantics<RootDatabase>,\n     usage_file_id: FileId,"}, {"sha": "88e2f2db3fd46cab9a3747ba16381b60bc10390f", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -9,7 +9,7 @@\n //! at the index that the match starts at and its tree parent is\n //! resolved to the search element definition, we get a reference.\n \n-mod rename;\n+pub(crate) mod rename;\n \n use hir::Semantics;\n use ide_db::{"}, {"sha": "f9a11e43d8d2c4828f5f034d2118988f64cdb73a", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -42,7 +42,14 @@ pub(crate) fn rename(\n     new_name: &str,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n     let sema = Semantics::new(db);\n+    rename_with_semantics(&sema, position, new_name)\n+}\n \n+pub(crate) fn rename_with_semantics(\n+    sema: &Semantics<RootDatabase>,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Result<RangeInfo<SourceChange>, RenameError> {\n     match lex_single_syntax_kind(new_name) {\n         Some(res) => match res {\n             (SyntaxKind::IDENT, _) => (),"}, {"sha": "59d89f47d1c2d9946f2bdd90030883be5e7934ab", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -28,20 +28,32 @@ pub fn timeit(label: &'static str) -> impl Drop {\n     Guard { label, start: Instant::now() }\n }\n \n-pub fn to_lower_snake_case(s: &str) -> String {\n+fn to_snake_case<F: Fn(&char) -> char>(s: &str, change_case: F) -> String {\n     let mut buf = String::with_capacity(s.len());\n     let mut prev = false;\n     for c in s.chars() {\n+        // `&& prev` is required to not insert `_` before the first symbol.\n         if c.is_ascii_uppercase() && prev {\n-            buf.push('_')\n+            // This check is required to not translate `Weird_Case` into `weird__case`.\n+            if !buf.ends_with('_') {\n+                buf.push('_')\n+            }\n         }\n         prev = true;\n \n-        buf.push(c.to_ascii_lowercase());\n+        buf.push(change_case(&c));\n     }\n     buf\n }\n \n+pub fn to_lower_snake_case(s: &str) -> String {\n+    to_snake_case(s, char::to_ascii_lowercase)\n+}\n+\n+pub fn to_upper_snake_case(s: &str) -> String {\n+    to_snake_case(s, char::to_ascii_uppercase)\n+}\n+\n pub fn replace(buf: &mut String, from: char, to: &str) {\n     if !buf.contains(from) {\n         return;"}, {"sha": "74dbdfaf7b795397bf1cf6951d742f5cbb383ed3", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c518fe7f6ca1c9a15d7d822654303155c90ce695/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=c518fe7f6ca1c9a15d7d822654303155c90ce695", "patch": "@@ -320,6 +320,10 @@ pub fn param(name: String, ty: String) -> ast::Param {\n     ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n }\n \n+pub fn ret_type(ty: ast::Type) -> ast::RetType {\n+    ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n+}\n+\n pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList {\n     let args = pats.into_iter().join(\", \");\n     ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n@@ -350,14 +354,20 @@ pub fn fn_(\n     type_params: Option<ast::GenericParamList>,\n     params: ast::ParamList,\n     body: ast::BlockExpr,\n+    ret_type: Option<ast::RetType>,\n ) -> ast::Fn {\n     let type_params =\n         if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n+    let ret_type = if let Some(ret_type) = ret_type { format!(\"{} \", ret_type) } else { \"\".into() };\n     let visibility = match visibility {\n         None => String::new(),\n         Some(it) => format!(\"{} \", it),\n     };\n-    ast_from_text(&format!(\"{}fn {}{}{} {}\", visibility, fn_name, type_params, params, body))\n+\n+    ast_from_text(&format!(\n+        \"{}fn {}{}{} {}{}\",\n+        visibility, fn_name, type_params, params, ret_type, body\n+    ))\n }\n \n fn ast_from_text<N: AstNode>(text: &str) -> N {"}]}