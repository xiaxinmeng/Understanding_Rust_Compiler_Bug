{"sha": "4d203699981c185381c0882dca0bf860ad31c2b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMjAzNjk5OTgxYzE4NTM4MWMwODgyZGNhMGJmODYwYWQzMWMyYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-12T16:31:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-12T16:31:10Z"}, "message": "Auto merge of #28371 - killercup:docs/trpl-markup-fixes, r=steveklabnik\n\n- Headlines begin at 1st level now like the rest of the book\r\n- All Headlines a blank line above and below\r\n- Fix links in this chapter's TOC\r\n\r\nr? @steveklabnik", "tree": {"sha": "9015cc1d12c4dd97563cb966031b9ae708e7dfd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9015cc1d12c4dd97563cb966031b9ae708e7dfd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d203699981c185381c0882dca0bf860ad31c2b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d203699981c185381c0882dca0bf860ad31c2b9", "html_url": "https://github.com/rust-lang/rust/commit/4d203699981c185381c0882dca0bf860ad31c2b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d203699981c185381c0882dca0bf860ad31c2b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b858f218dac09dd3e8458bb203e226c62e3d941a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b858f218dac09dd3e8458bb203e226c62e3d941a", "html_url": "https://github.com/rust-lang/rust/commit/b858f218dac09dd3e8458bb203e226c62e3d941a"}, {"sha": "39f97cfcf806c3d5ab4dc7a9708973a19eaa8646", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f97cfcf806c3d5ab4dc7a9708973a19eaa8646", "html_url": "https://github.com/rust-lang/rust/commit/39f97cfcf806c3d5ab4dc7a9708973a19eaa8646"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "673dc950ecce4187f0aaa39547747d7c99b6c76d", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4d203699981c185381c0882dca0bf860ad31c2b9/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d203699981c185381c0882dca0bf860ad31c2b9/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=4d203699981c185381c0882dca0bf860ad31c2b9", "patch": "@@ -14,7 +14,7 @@ When done na\u00efvely, error handling in Rust can be verbose and annoying. This\n chapter will explore those stumbling blocks and demonstrate how to use the\n standard library to make error handling concise and ergonomic.\n \n-## Table of Contents\n+# Table of Contents\n \n This chapter is very long, mostly because we start at the very beginning with\n sum types and combinators, and try to motivate the way Rust does error handling\n@@ -24,11 +24,11 @@ systems may want to jump around.\n * [The Basics](#the-basics)\n     * [Unwrapping explained](#unwrapping-explained)\n     * [The `Option` type](#the-option-type)\n-        * [Composing `Option<T>` values](#composing-option-t-values)\n+        * [Composing `Option<T>` values](#composing-optiont-values)\n     * [The `Result` type](#the-result-type)\n         * [Parsing integers](#parsing-integers)\n         * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n-    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isn-t-evil)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isnt-evil)\n * [Working with multiple error types](#working-with-multiple-error-types)\n     * [Composing `Option` and `Result`](#composing-option-and-result)\n     * [The limits of combinators](#the-limits-of-combinators)\n@@ -42,17 +42,16 @@ systems may want to jump around.\n     * [Composing custom error types](#composing-custom-error-types)\n     * [Advice for library writers](#advice-for-library-writers)\n * [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n-    * [It's on Github](#it-s-on-github)\n     * [Initial setup](#initial-setup)\n     * [Argument parsing](#argument-parsing)\n     * [Writing the logic](#writing-the-logic)\n-    * [Error handling with `Box<Error>`](#error-handling-with-box-error)\n+    * [Error handling with `Box<Error>`](#error-handling-with-boxerror)\n     * [Reading from stdin](#reading-from-stdin)\n     * [Error handling with a custom type](#error-handling-with-a-custom-type)\n     * [Adding functionality](#adding-functionality)\n * [The short story](#the-short-story)\n \n-## The Basics\n+# The Basics\n \n You can think of error handling as using *case analysis* to determine whether\n a computation was successful or not. As you will see, the key to ergonomic error\n@@ -107,7 +106,7 @@ You can think of this style of error handling as similar to a bull running\n through a china shop. The bull will get to where it wants to go, but it will\n trample everything in the process.\n \n-### Unwrapping explained\n+## Unwrapping explained\n \n In the previous example, we claimed\n that the program would simply panic if it reached one of the two error\n@@ -121,7 +120,7 @@ It would be better if we just showed the code for unwrapping because it is so\n simple, but to do that, we will first need to explore the `Option` and `Result`\n types. Both of these types have a method called `unwrap` defined on them.\n \n-### The `Option` type\n+## The `Option` type\n \n The `Option` type is\n [defined in the standard library][1]: \n@@ -205,7 +204,7 @@ The `unwrap` method *abstracts away the case analysis*. This is precisely the th\n that makes `unwrap` ergonomic to use. Unfortunately, that `panic!` means that\n `unwrap` is not composable: it is the bull in the china shop.\n \n-#### Composing `Option<T>` values\n+### Composing `Option<T>` values\n \n In [`option-ex-string-find`](#code-option-ex-string-find-2)\n we saw how to use `find` to discover the extension in a file name. Of course,\n@@ -382,7 +381,8 @@ Combinators make using types like `Option` ergonomic because they reduce\n explicit case analysis. They are also composable because they permit the caller\n to handle the possibility of absence in their own way. Methods like `unwrap`\n remove choices because they will panic if `Option<T>` is `None`.\n-### The `Result` type\n+\n+## The `Result` type\n \n The `Result` type is also\n [defined in the standard library][6]:\n@@ -442,7 +442,7 @@ way to print a human readable description of values with that type.)\n \n OK, let's move on to an example.\n \n-#### Parsing integers\n+### Parsing integers\n \n The Rust standard library makes converting strings to integers dead simple.\n It's so easy in fact, that it is very tempting to write something like the\n@@ -548,7 +548,9 @@ Additionally, since `Result` has a second type parameter, there are\n combinators that affect only the error type, such as\n [`map_err`](../std/result/enum.Result.html#method.map_err) (instead of\n `map`) and [`or_else`](../std/result/enum.Result.html#method.or_else)\n-(instead of `and_then`). #### The `Result` type alias idiom\n+(instead of `and_then`).\n+\n+### The `Result` type alias idiom\n \n In the standard library, you may frequently see types like\n `Result<i32>`. But wait, [we defined `Result`](#code-result-def-1) to\n@@ -580,9 +582,7 @@ module's type alias instead of the plain definition from\n `std::result`. (This idiom is also used for\n [`fmt::Result`](../std/fmt/type.Result.html).)\n \n-### A brief interlude:\n-\n-unwrapping isn't evil\n+## A brief interlude: unwrapping isn't evil\n \n If you've been following along, you might have noticed that I've taken a pretty\n hard line against calling methods like `unwrap` that could `panic` and abort\n@@ -620,7 +620,7 @@ Now that we've covered the basics of error handling in Rust, and\n explained unwrapping, let's start exploring more of the standard\n library.\n \n-## Working with multiple error types\n+# Working with multiple error types\n \n Thus far, we've looked at error handling where everything was either an\n `Option<T>` or a `Result<T, SomeError>`. But what happens when you have both an\n@@ -629,7 +629,7 @@ Thus far, we've looked at error handling where everything was either an\n challenge in front of us, and it will be the major theme throughout the rest of\n this chapter.\n \n-### Composing `Option` and `Result`\n+## Composing `Option` and `Result`\n \n So far, I've talked about combinators defined for `Option` and combinators\n defined for `Result`. We can use these combinators to compose results of\n@@ -706,7 +706,7 @@ the same (because of our use of `and_then`). Since we chose to convert the\n `Option<String>` (from `argv.nth(1)`) to a `Result<String, String>`, we must\n also convert the `ParseIntError` from `arg.parse()` to a `String`.\n \n-### The limits of combinators\n+## The limits of combinators\n \n Doing IO and parsing input is a very common task, and it's one that I\n personally have done a lot of in Rust. Therefore, we will use (and continue to\n@@ -839,7 +839,7 @@ With all of that said, the code is still hairy. Mastering use of combinators is\n important, but they have their limits. Let's try a different approach: early\n returns.\n \n-### Early returns\n+## Early returns\n \n I'd like to take the code from the previous section and rewrite it using *early\n returns*. Early returns let you exit the function early. We can't return early\n@@ -886,7 +886,7 @@ ergonomic error handling is reducing explicit case analysis, yet we've reverted\n back to explicit case analysis here. It turns out, there are *multiple* ways to\n reduce explicit case analysis. Combinators aren't the only way.\n \n-### The `try!` macro\n+## The `try!` macro\n \n A cornerstone of error handling in Rust is the `try!` macro. The `try!` macro\n abstracts case analysis just like combinators, but unlike combinators, it also\n@@ -939,7 +939,7 @@ The good news is that we will soon learn how to remove those `map_err` calls!\n The bad news is that we will need to learn a bit more about a couple important\n traits in the standard library before we can remove the `map_err` calls.\n \n-### Defining your own error type\n+## Defining your own error type\n \n Before we dive into some of the standard library error traits, I'd like to wrap\n up this section by removing the use of `String` as our error type in the\n@@ -1033,14 +1033,16 @@ will do in a pinch, particularly if you're writing an application. If you're\n writing a library, defining your own error type should be strongly preferred so\n that you don't remove choices from the caller unnecessarily.\n \n-## Standard library traits used for error handling\n+# Standard library traits used for error handling\n \n The standard library defines two integral traits for error handling:\n [`std::error::Error`](../std/error/trait.Error.html) and\n [`std::convert::From`](../std/convert/trait.From.html). While `Error`\n is designed specifically for generically describing errors, the `From`\n trait serves a more general role for converting values between two\n-distinct types. ### The `Error` trait\n+distinct types.\n+\n+## The `Error` trait\n \n The `Error` trait is [defined in the standard\n library](../std/error/trait.Error.html):\n@@ -1147,7 +1149,7 @@ We note that this is a very typical implementation of `Error`: match on your\n different error types and satisfy the contracts defined for `description` and\n `cause`.\n \n-### The `From` trait\n+## The `From` trait\n \n The `std::convert::From` trait is\n [defined in the standard\n@@ -1217,7 +1219,7 @@ us a way to reliably convert errors to the same type using the same function.\n \n Time to revisit an old friend; the `try!` macro.\n \n-### The real `try!` macro\n+## The real `try!` macro\n \n Previously, we presented this definition of `try!`:\n \n@@ -1307,7 +1309,7 @@ chapter](https://crates.io/crates/error).)\n \n It's time to revisit our custom `CliError` type and tie everything together.\n \n-### Composing custom error types\n+## Composing custom error types\n \n In the last section, we looked at the real `try!` macro and how it does\n automatic type conversion for us by calling `From::from` on the error value.\n@@ -1437,7 +1439,7 @@ impl From<num::ParseFloatError> for CliError {\n \n And that's it!\n \n-### Advice for library writers\n+## Advice for library writers\n \n If your library needs to report custom errors, then you should\n probably define your own error type. It's up to you whether or not to\n@@ -1468,7 +1470,7 @@ library defines a single error type. This is used in the standard library\n for [`io::Result`](../std/io/type.Result.html)\n and [`fmt::Result`](../std/fmt/type.Result.html).\n \n-## Case study: A program to read population data\n+# Case study: A program to read population data\n \n This chapter was long, and depending on your background, it might be\n rather dense. While there is plenty of example code to go along with\n@@ -1492,7 +1494,7 @@ parse the program arguments and decode that stuff into Rust types automatically.\n [`csv`](https://crates.io/crates/csv),\n and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n \n-### Initial setup\n+## Initial setup\n \n We're not going to spend a lot of time on setting up a project with\n Cargo because it is already covered well in [the Cargo\n@@ -1524,7 +1526,7 @@ cargo build --release\n # Outputs: Hello, world!\n ```\n \n-### Argument parsing\n+## Argument parsing\n \n Let's get argument parsing out of the way. we won't go into too much\n detail on Getopts, but there is [some good documentation][15]\n@@ -1584,7 +1586,7 @@ print for the program name and template. If the user has not passed in\n the help flag, we assign the proper variables to their corresponding\n arguments.\n \n-### Writing the logic\n+## Writing the logic\n \n We're all different in how we write code, but error handling is\n usually the last thing we want to think about. This isn't very good\n@@ -1681,7 +1683,7 @@ explore two different ways to approach handling these errors.\n I'd like to start with `Box<Error>`. Later, we'll see how defining our own\n error type can be useful.\n \n-### Error handling with `Box<Error>`\n+## Error handling with `Box<Error>`\n \n `Box<Error>` is nice because it *just works*. You don't need to define your own\n error types and you don't need any `From` implementations. The downside is that\n@@ -1830,7 +1832,7 @@ Now that we've seen how to do proper error handling with `Box<Error>`, let's\n try a different approach with our own custom error type. But first, let's take\n a quick break from error handling and add support for reading from `stdin`.\n \n-### Reading from stdin\n+## Reading from stdin\n \n In our program, we accept a single file for input and do one pass over the\n data. This means we probably should be able to accept input on stdin. But maybe\n@@ -1907,7 +1909,8 @@ fn search<P: AsRef<Path>>\n     // The rest remains unchanged!\n }\n ```\n-### Error handling with a custom type\n+\n+## Error handling with a custom type\n \n Previously, we learned how to\n [compose errors using a custom error type](#composing-custom-error-types).\n@@ -2013,7 +2016,7 @@ fn search<P: AsRef<Path>>\n \n No other changes are necessary.\n \n-### Adding functionality\n+## Adding functionality\n \n Writing generic code is great, because generalizing stuff is cool, and\n it can then be useful later. But sometimes, the juice isn't worth the\n@@ -2073,7 +2076,7 @@ This pretty much sums up our case study. From here, you should be ready to go\n out into the world and write your own programs and libraries with proper error\n handling.\n \n-## The Short Story\n+# The Short Story\n \n Since this chapter is long, it is useful to have a quick summary for error\n handling in Rust. These are some good \u201crules of thumb.\" They are emphatically"}]}