{"sha": "ef663a8a48ea6b98b43cbfaefd99316b36b16825", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNjYzYThhNDhlYTZiOThiNDNjYmZhZWZkOTkzMTZiMzZiMTY4MjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-30T20:49:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-30T20:49:27Z"}, "message": "Auto merge of #77372 - jonas-schievink:rollup-e5bdzga, r=jonas-schievink\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #77037 (more tiny clippy cleanups)\n - #77233 (BTreeMap: keep an eye out on the size of the main components)\n - #77280 (Ensure that all LLVM components requested by tests are available on CI)\n - #77284 (library: Forward compiler-builtins \"mem\" feature)\n - #77296 (liveness: Use Option::None to represent absent live nodes)\n - #77322 (Add unstable book docs for `-Zunsound-mir-opts`)\n - #77328 (Use `rtassert!` instead of `assert!` from the child process after fork() in std::sys::unix::process::Command::spawn())\n - #77331 (Add test for async/await combined with const-generics.)\n - #77338 (Fix typo in alloc vec comment)\n - #77340 (Alloc vec use imported path)\n - #77345 (Add test for issue #74761)\n - #77348 (Update books)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "98502334aa6c2c0bd30ddf371d4cebe1e21d2a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98502334aa6c2c0bd30ddf371d4cebe1e21d2a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef663a8a48ea6b98b43cbfaefd99316b36b16825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef663a8a48ea6b98b43cbfaefd99316b36b16825", "html_url": "https://github.com/rust-lang/rust/commit/ef663a8a48ea6b98b43cbfaefd99316b36b16825", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef663a8a48ea6b98b43cbfaefd99316b36b16825/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "867bd42c38bac3870388765f65386b18cf1d9c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/867bd42c38bac3870388765f65386b18cf1d9c5f", "html_url": "https://github.com/rust-lang/rust/commit/867bd42c38bac3870388765f65386b18cf1d9c5f"}, {"sha": "3624a901345c9c384aa9d1e27e21d0c4cd2c85ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/3624a901345c9c384aa9d1e27e21d0c4cd2c85ae", "html_url": "https://github.com/rust-lang/rust/commit/3624a901345c9c384aa9d1e27e21d0c4cd2c85ae"}], "stats": {"total": 181, "additions": 127, "deletions": 54}, "files": [{"sha": "8513e5e531bd7e88b7cfe607fc6c43800a908a2c", "filename": "compiler/rustc_mir/src/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -62,8 +62,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // `self.constraints`, but we also want to be mutating\n         // `self.member_constraints`. For now, just swap out the value\n         // we want and replace at the end.\n-        let mut tmp =\n-            std::mem::replace(&mut self.constraints.member_constraints, Default::default());\n+        let mut tmp = std::mem::take(&mut self.constraints.member_constraints);\n         for member_constraint in member_constraints {\n             tmp.push_constraint(member_constraint, |r| self.to_region_vid(r));\n         }"}, {"sha": "7a9089d0f3675c1893cd02b1326c626131c64a0f", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n             let not_equal_rvalue = Rvalue::BinaryOp(\n                 not_equal,\n                 Operand::Copy(Place::from(second_discriminant_temp)),\n-                Operand::Copy(Place::from(first_descriminant_place)),\n+                Operand::Copy(first_descriminant_place),\n             );\n             patch.add_statement(\n                 end_of_block_location,"}, {"sha": "e8b97d7dc7d50e9a3ebb9d24f638766074937b6a", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -62,13 +62,13 @@\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`. If the `reader` is `INVALID_NODE`, then the current\n+//!    write `V`. If the `reader` is `None`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n //!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`. If the `writer` is `INVALID_NODE`, then there is no writer\n+//!    `V`. If the `writer` is `None`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n //! - `used`: a boolean value indicating whether `V` is *used*. We\n@@ -114,7 +114,6 @@ rustc_index::newtype_index! {\n rustc_index::newtype_index! {\n     pub struct LiveNode {\n         DEBUG_FORMAT = \"ln({})\",\n-        const INVALID_NODE = LiveNode::MAX_AS_U32,\n     }\n }\n \n@@ -168,12 +167,6 @@ pub fn provide(providers: &mut Providers) {\n // variable must not be assigned if there is some successor\n // assignment.  And so forth.\n \n-impl LiveNode {\n-    fn is_valid(self) -> bool {\n-        self != INVALID_NODE\n-    }\n-}\n-\n struct CaptureInfo {\n     ln: LiveNode,\n     var_hid: HirId,\n@@ -467,8 +460,8 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n #[derive(Clone, Copy)]\n struct RWU {\n-    reader: LiveNode,\n-    writer: LiveNode,\n+    reader: Option<LiveNode>,\n+    writer: Option<LiveNode>,\n     used: bool,\n }\n \n@@ -490,10 +483,10 @@ struct RWUTable {\n     unpacked_rwus: Vec<RWU>,\n }\n \n-// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: false }`.\n+// A constant representing `RWU { reader: None; writer: None; used: false }`.\n const INV_INV_FALSE: u32 = u32::MAX;\n \n-// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: true }`.\n+// A constant representing `RWU { reader: None; writer: None; used: true }`.\n const INV_INV_TRUE: u32 = u32::MAX - 1;\n \n impl RWUTable {\n@@ -504,24 +497,24 @@ impl RWUTable {\n     fn get(&self, idx: usize) -> RWU {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: false },\n-            INV_INV_TRUE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: true },\n+            INV_INV_FALSE => RWU { reader: None, writer: None, used: false },\n+            INV_INV_TRUE => RWU { reader: None, writer: None, used: true },\n             _ => self.unpacked_rwus[packed_rwu as usize],\n         }\n     }\n \n-    fn get_reader(&self, idx: usize) -> LiveNode {\n+    fn get_reader(&self, idx: usize) -> Option<LiveNode> {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n+            INV_INV_FALSE | INV_INV_TRUE => None,\n             _ => self.unpacked_rwus[packed_rwu as usize].reader,\n         }\n     }\n \n-    fn get_writer(&self, idx: usize) -> LiveNode {\n+    fn get_writer(&self, idx: usize) -> Option<LiveNode> {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n+            INV_INV_FALSE | INV_INV_TRUE => None,\n             _ => self.unpacked_rwus[packed_rwu as usize].writer,\n         }\n     }\n@@ -541,7 +534,7 @@ impl RWUTable {\n     }\n \n     fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n-        if rwu.reader == INVALID_NODE && rwu.writer == INVALID_NODE {\n+        if rwu.reader == None && rwu.writer == None {\n             // When we overwrite an indexing entry in `self.packed_rwus` with\n             // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n             // from `self.unpacked_rwus`; it's not worth the effort, and we\n@@ -570,7 +563,7 @@ struct Liveness<'a, 'tcx> {\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-    successors: IndexVec<LiveNode, LiveNode>,\n+    successors: IndexVec<LiveNode, Option<LiveNode>>,\n     rwu_table: RWUTable,\n \n     /// A live node representing a point of execution before closure entry &\n@@ -606,7 +599,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             typeck_results,\n             param_env,\n             upvars,\n-            successors: IndexVec::from_elem_n(INVALID_NODE, num_live_nodes),\n+            successors: IndexVec::from_elem_n(None, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n             exit_ln,\n@@ -651,30 +644,33 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        assert!(ln.is_valid());\n-        let reader = self.rwu_table.get_reader(self.idx(ln, var));\n-        if reader.is_valid() { Some(self.ir.lnks[reader]) } else { None }\n+        if let Some(reader) = self.rwu_table.get_reader(self.idx(ln, var)) {\n+            Some(self.ir.lnks[reader])\n+        } else {\n+            None\n+        }\n     }\n \n     // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln];\n+        let successor = self.successors[ln].unwrap();\n         self.live_on_entry(successor, var)\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        assert!(ln.is_valid());\n         self.rwu_table.get_used(self.idx(ln, var))\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        assert!(ln.is_valid());\n-        let writer = self.rwu_table.get_writer(self.idx(ln, var));\n-        if writer.is_valid() { Some(self.ir.lnks[writer]) } else { None }\n+        if let Some(writer) = self.rwu_table.get_writer(self.idx(ln, var)) {\n+            Some(self.ir.lnks[writer])\n+        } else {\n+            None\n+        }\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln];\n+        let successor = self.successors[ln].unwrap();\n         self.assigned_on_entry(successor, var)\n     }\n \n@@ -709,9 +705,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[{:?} of kind {:?} reads\", ln, self.ir.lnks[ln]);\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_some());\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_some());\n             write!(wr, \"  uses\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n \n@@ -735,7 +731,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        self.successors[ln] = succ_ln;\n+        self.successors[ln] = Some(succ_ln);\n \n         // It is not necessary to initialize the RWUs here because they are all\n         // set to INV_INV_FALSE when they are created, and the sets only grow\n@@ -744,7 +740,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        self.successors[ln] = succ_ln;\n+        self.successors[ln] = Some(succ_ln);\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             this.rwu_table.copy_packed(idx, succ_idx);\n@@ -768,12 +764,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let mut changed = false;\n             let mut rwu = this.rwu_table.get(idx);\n             let succ_rwu = this.rwu_table.get(succ_idx);\n-            if succ_rwu.reader.is_valid() && !rwu.reader.is_valid() {\n+            if succ_rwu.reader.is_some() && rwu.reader.is_none() {\n                 rwu.reader = succ_rwu.reader;\n                 changed = true\n             }\n \n-            if succ_rwu.writer.is_valid() && !rwu.writer.is_valid() {\n+            if succ_rwu.writer.is_some() && rwu.writer.is_none() {\n                 rwu.writer = succ_rwu.writer;\n                 changed = true\n             }\n@@ -817,14 +813,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            rwu.reader = INVALID_NODE;\n-            rwu.writer = ln;\n+            rwu.reader = None;\n+            rwu.writer = Some(ln);\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            rwu.reader = ln;\n+            rwu.reader = Some(ln);\n         }\n \n         if (acc & ACC_USE) != 0 {"}, {"sha": "5363702a5be6d8583cef3bd9b1fe0f34d8c848d8", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -70,10 +70,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n         wbcx.typeck_results.used_trait_imports = used_trait_imports;\n \n-        wbcx.typeck_results.closure_captures = mem::replace(\n-            &mut self.typeck_results.borrow_mut().closure_captures,\n-            Default::default(),\n-        );\n+        wbcx.typeck_results.closure_captures =\n+            mem::take(&mut self.typeck_results.borrow_mut().closure_captures);\n \n         if self.is_tainted_by_errors() {\n             // FIXME(eddyb) keep track of `ErrorReported` from where the error was emitted."}, {"sha": "54c3709821acd414b635424274667cccaeb1252c", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -23,3 +23,12 @@ fn test_splitpoint() {\n         assert!(left_len + right_len == CAPACITY);\n     }\n }\n+\n+#[test]\n+#[cfg(target_arch = \"x86_64\")]\n+fn test_sizes() {\n+    assert_eq!(core::mem::size_of::<LeafNode<(), ()>>(), 16);\n+    assert_eq!(core::mem::size_of::<LeafNode<i64, i64>>(), 16 + CAPACITY * 8 * 2);\n+    assert_eq!(core::mem::size_of::<InternalNode<(), ()>>(), 112);\n+    assert_eq!(core::mem::size_of::<InternalNode<i64, i64>>(), 112 + CAPACITY * 8 * 2);\n+}"}, {"sha": "5114f578f02ead3814448f6479314bfbfb8a6403", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -2281,14 +2281,14 @@ where\n \n         // use try-fold since\n         // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods methods it only takes a &mut self\n+        // - unlike most internal iteration methods, it only takes a &mut self\n         // - it lets us thread the write pointer through its innards and get it back in the end\n         let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n         let sink = iterator\n             .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n             .unwrap();\n         // iteration succeeded, don't drop head\n-        let dst = mem::ManuallyDrop::new(sink).dst;\n+        let dst = ManuallyDrop::new(sink).dst;\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };\n         // check if SourceIter contract was upheld"}, {"sha": "b27b056086a646125c89c27ec41d34e2a1ea1971", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -59,6 +59,7 @@ gimli-symbolize = []\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n compiler-builtins-c = [\"alloc/compiler-builtins-c\"]\n+compiler-builtins-mem = [\"alloc/compiler-builtins-mem\"]\n llvm-libunwind = [\"unwind/llvm-libunwind\"]\n \n # Make panics and failed asserts immediately abort without formatting any message"}, {"sha": "c3625d306ab736a5ac4dcbe18881a43935bfa1a2", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -67,7 +67,7 @@ impl Command {\n                     // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n                     // we want to be sure we *don't* run at_exit destructors as\n                     // we're being torn down regardless\n-                    assert!(output.write(&bytes).is_ok());\n+                    rtassert!(output.write(&bytes).is_ok());\n                     libc::_exit(1)\n                 }\n                 n => n,"}, {"sha": "e44c781113583e3a34dc64f0de2c951921b12c73", "filename": "library/test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Ftest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/library%2Ftest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2FCargo.toml?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -25,6 +25,7 @@ proc_macro = { path = \"../proc_macro\" }\n default = [\"std_detect_file_io\", \"std_detect_dlsym_getauxval\", \"panic-unwind\"]\n backtrace = [\"std/backtrace\"]\n compiler-builtins-c = [\"std/compiler-builtins-c\"]\n+compiler-builtins-mem = [\"std/compiler-builtins-mem\"]\n llvm-libunwind = [\"std/llvm-libunwind\"]\n panic-unwind = [\"std/panic_unwind\"]\n panic_immediate_abort = [\"std/panic_immediate_abort\"]"}, {"sha": "181a7fcb732661cffec9e8c9cf3233470ce922ac", "filename": "src/ci/run.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -104,6 +104,8 @@ if [ \"$RUST_RELEASE_CHANNEL\" = \"nightly\" ] || [ \"$DIST_REQUIRE_ALL_TOOLS\" = \"\" ]\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-missing-tools\"\n fi\n \n+export COMPILETEST_NEEDS_ALL_LLVM_COMPONENTS=1\n+\n # Print the date from the local machine and the date from an external source to\n # check for clock drifts. An HTTP URL is used instead of HTTPS since on Azure\n # Pipelines it happened that the certificates were marked as expired."}, {"sha": "dd310616308e01f6cf227f46347b744aa56b77d9", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -1 +1 @@\n-Subproject commit 0cd2ca116274b915924c3a7e07c1e046b6f19b77\n+Subproject commit dd310616308e01f6cf227f46347b744aa56b77d9"}, {"sha": "7d3ff1c12db08a847a57a054be4a7951ce532d2d", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -1 +1 @@\n-Subproject commit 19f0a0372af497b34369cf182d9d16156cab2969\n+Subproject commit 7d3ff1c12db08a847a57a054be4a7951ce532d2d"}, {"sha": "8e46e227c25b470a0fc68b974f0baa3dd54f0d04", "filename": "src/doc/unstable-book/src/compiler-flags/unsound-mir-opts.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Funsound-mir-opts.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Funsound-mir-opts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Funsound-mir-opts.md?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -0,0 +1,8 @@\n+# `unsound-mir-opts`\n+\n+--------------------\n+\n+The `-Zunsound-mir-opts` compiler flag enables [MIR optimization passes] which can cause unsound behavior.\n+This flag should only be used by MIR optimization tests in the rustc test suite.\n+\n+[MIR optimization passes]: https://rustc-dev-guide.rust-lang.org/mir/optimizations.html"}, {"sha": "9162d1142b64a81f69d931fe2d1fcfed7978b077", "filename": "src/test/ui/const-generics/issue-74906.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftest%2Fui%2Fconst-generics%2Fissue-74906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftest%2Fui%2Fconst-generics%2Fissue-74906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-74906.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -0,0 +1,25 @@\n+// edition:2018\n+// check-pass\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+const SIZE: usize = 16;\n+\n+struct Bar<const H: usize> {}\n+\n+struct Foo<const H: usize> {}\n+\n+impl<const H: usize> Foo<H> {\n+    async fn biz(_: &[[u8; SIZE]]) -> Vec<()> {\n+        vec![]\n+    }\n+\n+    pub async fn baz(&self) -> Bar<H> {\n+        Self::biz(&vec![]).await;\n+        Bar {}\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "4345b5d886ee2e52bb9d8f424b248750253103dd", "filename": "src/test/ui/type-alias-impl-trait/issue-74761.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74761.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -0,0 +1,16 @@\n+#![feature(member_constraints)]\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait A {\n+    type B;\n+    fn f(&self) -> Self::B;\n+}\n+impl<'a, 'b> A for () {\n+    //~^ ERROR the lifetime parameter `'a` is not constrained\n+    //~| ERROR the lifetime parameter `'b` is not constrained\n+    type B = impl core::fmt::Debug;\n+\n+    fn f(&self) -> Self::B {}\n+}\n+\n+fn main() {}"}, {"sha": "3f38fa4de01654a132519c0a05723155ddc8ea48", "filename": "src/test/ui/type-alias-impl-trait/issue-74761.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74761.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74761.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74761.stderr?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -0,0 +1,15 @@\n+error[E0207]: the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-74761.rs:8:6\n+   |\n+LL | impl<'a, 'b> A for () {\n+   |      ^^ unconstrained lifetime parameter\n+\n+error[E0207]: the lifetime parameter `'b` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-74761.rs:8:10\n+   |\n+LL | impl<'a, 'b> A for () {\n+   |          ^^ unconstrained lifetime parameter\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "59f64e7df0f41a219d23ed8c81d60a9d4ba0663f", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef663a8a48ea6b98b43cbfaefd99316b36b16825/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=ef663a8a48ea6b98b43cbfaefd99316b36b16825", "patch": "@@ -208,10 +208,13 @@ impl EarlyProps {\n                 config.parse_name_value_directive(line, \"needs-llvm-components\")\n             {\n                 let components: HashSet<_> = config.llvm_components.split_whitespace().collect();\n-                if !needed_components\n+                if let Some(missing_component) = needed_components\n                     .split_whitespace()\n-                    .all(|needed_component| components.contains(needed_component))\n+                    .find(|needed_component| !components.contains(needed_component))\n                 {\n+                    if env::var_os(\"COMPILETEST_NEEDS_ALL_LLVM_COMPONENTS\").is_some() {\n+                        panic!(\"missing LLVM component: {}\", missing_component);\n+                    }\n                     return true;\n                 }\n             }"}]}