{"sha": "0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNDY5NDdkMzVlOWZkYzM1Y2QwNmRkODg5YzNjM2E4OTJkN2RkZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-09T23:13:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-09T23:13:58Z"}, "message": "Auto merge of #37603 - arielb1:max-slice-length, r=nikomatsakis\n\n_match: correct max_slice_length logic\n\nThe logic used to be wildly wrong, but before the HAIR patch its wrongness was in most cases hidden by another bug.\n\nFixes #37598.\n\nr? @nikomatsakis", "tree": {"sha": "243eae5327969b906c60278f0fdd82c26e471000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/243eae5327969b906c60278f0fdd82c26e471000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "html_url": "https://github.com/rust-lang/rust/commit/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da2ce2276873242a101f205537e7ce297d68f8dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/da2ce2276873242a101f205537e7ce297d68f8dd", "html_url": "https://github.com/rust-lang/rust/commit/da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "html_url": "https://github.com/rust-lang/rust/commit/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82"}], "stats": {"total": 150, "additions": 142, "deletions": 8}, "files": [{"sha": "c48811cb295bd60d681e82c29138a42b04764938", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 97, "deletions": 8, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "patch": "@@ -39,7 +39,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n \n-use std::cmp::Ordering;\n+use std::cmp::{self, Ordering};\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n \n@@ -419,6 +419,99 @@ fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constr\n     }\n }\n \n+fn max_slice_length<'a, 'tcx, I>(\n+    _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    patterns: I) -> usize\n+    where I: Iterator<Item=&'a Pattern<'tcx>>\n+{\n+    // The exhaustiveness-checking paper does not include any details on\n+    // checking variable-length slice patterns. However, they are matched\n+    // by an infinite collection of fixed-length array patterns.\n+    //\n+    // Checking the infinite set directly would take an infinite amount\n+    // of time. However, it turns out that for each finite set of\n+    // patterns `P`, all sufficiently large array lengths are equivalent:\n+    //\n+    // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+    // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+    // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+    // the same subset of `P`.\n+    //\n+    // Because of that, each witness for reachability-checking from one\n+    // of the sufficiently-large lengths can be transformed to an\n+    // equally-valid witness from any other length, so we only have\n+    // to check slice lengths from the \"minimal sufficiently-large length\"\n+    // and below.\n+    //\n+    // Note that the fact that there is a *single* `s\u2098` for each `m`\n+    // not depending on the specific pattern in `P` is important: if\n+    // you look at the pair of patterns\n+    //     `[true, ..]`\n+    //     `[.., false]`\n+    // Then any slice of length \u22651 that matches one of these two\n+    // patterns can be  be trivially turned to a slice of any\n+    // other length \u22651 that matches them and vice-versa - for\n+    // but the slice from length 2 `[false, true]` that matches neither\n+    // of these patterns can't be turned to a slice from length 1 that\n+    // matches neither of these patterns, so we have to consider\n+    // slices from length 2 there.\n+    //\n+    // Now, to see that that length exists and find it, observe that slice\n+    // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+    // \"variable-length\" patterns (`[_, .., _]`).\n+    //\n+    // For fixed-length patterns, all slices with lengths *longer* than\n+    // the pattern's length have the same outcome (of not matching), so\n+    // as long as `L` is greater than the pattern's length we can pick\n+    // any `s\u2098` from that length and get the same result.\n+    //\n+    // For variable-length patterns, the situation is more complicated,\n+    // because as seen above the precise value of `s\u2098` matters.\n+    //\n+    // However, for each variable-length pattern `p` with a prefix of length\n+    // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+    // `sl\u209a` elements are examined.\n+    //\n+    // Therefore, as long as `L` is positive (to avoid concerns about empty\n+    // types), all elements after the maximum prefix length and before\n+    // the maximum suffix length are not examined by any variable-length\n+    // pattern, and therefore can be added/removed without affecting\n+    // them - creating equivalent patterns from any sufficiently-large\n+    // length.\n+    //\n+    // Of course, if fixed-length patterns exist, we must be sure\n+    // that our length is large enough to miss them all, so\n+    // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n+    //\n+    // for example, with the above pair of patterns, all elements\n+    // but the first and last can be added/removed, so any\n+    // witness of length \u22652 (say, `[false, false, true]`) can be\n+    // turned to a witness from any other length \u22652.\n+\n+    let mut max_prefix_len = 0;\n+    let mut max_suffix_len = 0;\n+    let mut max_fixed_len = 0;\n+\n+    for row in patterns {\n+        match *row.kind {\n+            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } => {\n+                max_fixed_len = cmp::max(max_fixed_len, data.len());\n+            }\n+            PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                let fixed_len = prefix.len() + suffix.len();\n+                max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n+            }\n+            PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                max_prefix_len = cmp::max(max_prefix_len, prefix.len());\n+                max_suffix_len = cmp::max(max_suffix_len, suffix.len());\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n+}\n+\n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n ///\n /// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n@@ -453,16 +546,12 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n     let &Matrix(ref rows) = matrix;\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n+\n+\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n-        max_slice_length: rows.iter().filter_map(|row| match *row[0].kind {\n-            PatternKind::Slice { ref prefix, slice: _, ref suffix } =>\n-                Some(prefix.len() + suffix.len()),\n-            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } =>\n-                Some(data.len()),\n-            _ => None\n-        }).max().map_or(0, |v| v + 1)\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);"}, {"sha": "c0fc75f9713a878e8c80c9cd883098b8836c4ac2", "filename": "src/test/compile-fail/match-slice-patterns.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs?ref=0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn check(list: &[Option<()>]) {\n+    match list {\n+    //~^ ERROR `&[None, Some(_), None, _]` and `&[Some(_), Some(_), None, _]` not covered\n+        &[] => {},\n+        &[_] => {},\n+        &[_, _] => {},\n+        &[_, None, ..] => {},\n+        &[.., Some(_), _] => {},\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d32d2fc295440ed12a65be3558fa0c41bb279a05", "filename": "src/test/run-pass/issue-37598.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/src%2Ftest%2Frun-pass%2Fissue-37598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8/src%2Ftest%2Frun-pass%2Fissue-37598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37598.rs?ref=0b46947d35e9fdc35cd06dd889c3c3a892d7ddf8", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn check(list: &[u8]) {\n+    match list {\n+        &[] => {},\n+        &[_u1, _u2, ref _next..] => {},\n+        &[_u1] => {},\n+    }\n+}\n+\n+fn main() {}"}]}