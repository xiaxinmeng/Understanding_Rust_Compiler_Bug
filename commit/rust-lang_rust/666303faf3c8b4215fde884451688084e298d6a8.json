{"sha": "666303faf3c8b4215fde884451688084e298d6a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NjMwM2ZhZjNjOGI0MjE1ZmRlODg0NDUxNjg4MDg0ZTI5OGQ2YTg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-24T13:57:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-24T13:57:05Z"}, "message": "support upcastig in AST enum", "tree": {"sha": "a57e96d575a1e3cb5192b8a88128a6087b5a1479", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a57e96d575a1e3cb5192b8a88128a6087b5a1479"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/666303faf3c8b4215fde884451688084e298d6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/666303faf3c8b4215fde884451688084e298d6a8", "html_url": "https://github.com/rust-lang/rust/commit/666303faf3c8b4215fde884451688084e298d6a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/666303faf3c8b4215fde884451688084e298d6a8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c110e72a115bbec36413bd440812dfe9194c58e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c110e72a115bbec36413bd440812dfe9194c58e2", "html_url": "https://github.com/rust-lang/rust/commit/c110e72a115bbec36413bd440812dfe9194c58e2"}], "stats": {"total": 407, "additions": 407, "deletions": 0}, "files": [{"sha": "aa88b1e283ec05722aa483ab001988b0d892ae1d", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/666303faf3c8b4215fde884451688084e298d6a8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666303faf3c8b4215fde884451688084e298d6a8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=666303faf3c8b4215fde884451688084e298d6a8", "patch": "@@ -834,6 +834,142 @@ pub enum ExprKind<'a> {\n     BinExpr(&'a BinExpr),\n     Literal(&'a Literal),\n }\n+impl<'a> From<&'a TupleExpr> for &'a Expr {\n+    fn from(n: &'a TupleExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ArrayExpr> for &'a Expr {\n+    fn from(n: &'a ArrayExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ParenExpr> for &'a Expr {\n+    fn from(n: &'a ParenExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PathExpr> for &'a Expr {\n+    fn from(n: &'a PathExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LambdaExpr> for &'a Expr {\n+    fn from(n: &'a LambdaExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a IfExpr> for &'a Expr {\n+    fn from(n: &'a IfExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LoopExpr> for &'a Expr {\n+    fn from(n: &'a LoopExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ForExpr> for &'a Expr {\n+    fn from(n: &'a ForExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a WhileExpr> for &'a Expr {\n+    fn from(n: &'a WhileExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ContinueExpr> for &'a Expr {\n+    fn from(n: &'a ContinueExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BreakExpr> for &'a Expr {\n+    fn from(n: &'a BreakExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Label> for &'a Expr {\n+    fn from(n: &'a Label) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BlockExpr> for &'a Expr {\n+    fn from(n: &'a BlockExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ReturnExpr> for &'a Expr {\n+    fn from(n: &'a ReturnExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a MatchExpr> for &'a Expr {\n+    fn from(n: &'a MatchExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a StructLit> for &'a Expr {\n+    fn from(n: &'a StructLit) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a CallExpr> for &'a Expr {\n+    fn from(n: &'a CallExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a IndexExpr> for &'a Expr {\n+    fn from(n: &'a IndexExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a MethodCallExpr> for &'a Expr {\n+    fn from(n: &'a MethodCallExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FieldExpr> for &'a Expr {\n+    fn from(n: &'a FieldExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TryExpr> for &'a Expr {\n+    fn from(n: &'a TryExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a CastExpr> for &'a Expr {\n+    fn from(n: &'a CastExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RefExpr> for &'a Expr {\n+    fn from(n: &'a RefExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PrefixExpr> for &'a Expr {\n+    fn from(n: &'a PrefixExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RangeExpr> for &'a Expr {\n+    fn from(n: &'a RangeExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BinExpr> for &'a Expr {\n+    fn from(n: &'a BinExpr) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Literal> for &'a Expr {\n+    fn from(n: &'a Literal) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for Expr {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -1375,6 +1511,22 @@ pub enum ImplItemKind<'a> {\n     TypeDef(&'a TypeDef),\n     ConstDef(&'a ConstDef),\n }\n+impl<'a> From<&'a FnDef> for &'a ImplItem {\n+    fn from(n: &'a FnDef) -> &'a ImplItem {\n+        ImplItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TypeDef> for &'a ImplItem {\n+    fn from(n: &'a TypeDef) -> &'a ImplItem {\n+        ImplItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ConstDef> for &'a ImplItem {\n+    fn from(n: &'a ConstDef) -> &'a ImplItem {\n+        ImplItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for ImplItem {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -1778,6 +1930,57 @@ pub enum LiteralExprKind<'a> {\n     TrueKw(&'a TrueKw),\n     FalseKw(&'a FalseKw),\n }\n+impl<'a> From<&'a String> for &'a LiteralExpr {\n+    fn from(n: &'a String) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ByteString> for &'a LiteralExpr {\n+    fn from(n: &'a ByteString) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RawString> for &'a LiteralExpr {\n+    fn from(n: &'a RawString) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RawByteString> for &'a LiteralExpr {\n+    fn from(n: &'a RawByteString) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Char> for &'a LiteralExpr {\n+    fn from(n: &'a Char) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Byte> for &'a LiteralExpr {\n+    fn from(n: &'a Byte) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a IntNumber> for &'a LiteralExpr {\n+    fn from(n: &'a IntNumber) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FloatNumber> for &'a LiteralExpr {\n+    fn from(n: &'a FloatNumber) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TrueKw> for &'a LiteralExpr {\n+    fn from(n: &'a TrueKw) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FalseKw> for &'a LiteralExpr {\n+    fn from(n: &'a FalseKw) -> &'a LiteralExpr {\n+        LiteralExpr::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for LiteralExpr {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -2164,6 +2367,62 @@ pub enum ModuleItemKind<'a> {\n     StaticDef(&'a StaticDef),\n     Module(&'a Module),\n }\n+impl<'a> From<&'a StructDef> for &'a ModuleItem {\n+    fn from(n: &'a StructDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a EnumDef> for &'a ModuleItem {\n+    fn from(n: &'a EnumDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FnDef> for &'a ModuleItem {\n+    fn from(n: &'a FnDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TraitDef> for &'a ModuleItem {\n+    fn from(n: &'a TraitDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TypeDef> for &'a ModuleItem {\n+    fn from(n: &'a TypeDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ImplBlock> for &'a ModuleItem {\n+    fn from(n: &'a ImplBlock) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a UseItem> for &'a ModuleItem {\n+    fn from(n: &'a UseItem) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ExternCrateItem> for &'a ModuleItem {\n+    fn from(n: &'a ExternCrateItem) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ConstDef> for &'a ModuleItem {\n+    fn from(n: &'a ConstDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a StaticDef> for &'a ModuleItem {\n+    fn from(n: &'a StaticDef) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a Module> for &'a ModuleItem {\n+    fn from(n: &'a Module) -> &'a ModuleItem {\n+        ModuleItem::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for ModuleItem {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -2446,6 +2705,17 @@ pub enum NominalDefKind<'a> {\n     StructDef(&'a StructDef),\n     EnumDef(&'a EnumDef),\n }\n+impl<'a> From<&'a StructDef> for &'a NominalDef {\n+    fn from(n: &'a StructDef) -> &'a NominalDef {\n+        NominalDef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a EnumDef> for &'a NominalDef {\n+    fn from(n: &'a EnumDef) -> &'a NominalDef {\n+        NominalDef::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for NominalDef {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -2637,6 +2907,57 @@ pub enum PatKind<'a> {\n     RangePat(&'a RangePat),\n     LiteralPat(&'a LiteralPat),\n }\n+impl<'a> From<&'a RefPat> for &'a Pat {\n+    fn from(n: &'a RefPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a BindPat> for &'a Pat {\n+    fn from(n: &'a BindPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PlaceholderPat> for &'a Pat {\n+    fn from(n: &'a PlaceholderPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PathPat> for &'a Pat {\n+    fn from(n: &'a PathPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a StructPat> for &'a Pat {\n+    fn from(n: &'a StructPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TupleStructPat> for &'a Pat {\n+    fn from(n: &'a TupleStructPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TuplePat> for &'a Pat {\n+    fn from(n: &'a TuplePat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a SlicePat> for &'a Pat {\n+    fn from(n: &'a SlicePat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a RangePat> for &'a Pat {\n+    fn from(n: &'a RangePat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LiteralPat> for &'a Pat {\n+    fn from(n: &'a LiteralPat) -> &'a Pat {\n+        Pat::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for Pat {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -3520,6 +3841,17 @@ pub enum StmtKind<'a> {\n     ExprStmt(&'a ExprStmt),\n     LetStmt(&'a LetStmt),\n }\n+impl<'a> From<&'a ExprStmt> for &'a Stmt {\n+    fn from(n: &'a ExprStmt) -> &'a Stmt {\n+        Stmt::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a LetStmt> for &'a Stmt {\n+    fn from(n: &'a LetStmt) -> &'a Stmt {\n+        Stmt::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for Stmt {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n@@ -4142,6 +4474,72 @@ pub enum TypeRefKind<'a> {\n     ImplTraitType(&'a ImplTraitType),\n     DynTraitType(&'a DynTraitType),\n }\n+impl<'a> From<&'a ParenType> for &'a TypeRef {\n+    fn from(n: &'a ParenType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a TupleType> for &'a TypeRef {\n+    fn from(n: &'a TupleType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a NeverType> for &'a TypeRef {\n+    fn from(n: &'a NeverType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PathType> for &'a TypeRef {\n+    fn from(n: &'a PathType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PointerType> for &'a TypeRef {\n+    fn from(n: &'a PointerType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ArrayType> for &'a TypeRef {\n+    fn from(n: &'a ArrayType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a SliceType> for &'a TypeRef {\n+    fn from(n: &'a SliceType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ReferenceType> for &'a TypeRef {\n+    fn from(n: &'a ReferenceType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a PlaceholderType> for &'a TypeRef {\n+    fn from(n: &'a PlaceholderType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a FnPointerType> for &'a TypeRef {\n+    fn from(n: &'a FnPointerType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ForType> for &'a TypeRef {\n+    fn from(n: &'a ForType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a ImplTraitType> for &'a TypeRef {\n+    fn from(n: &'a ImplTraitType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+impl<'a> From<&'a DynTraitType> for &'a TypeRef {\n+    fn from(n: &'a DynTraitType) -> &'a TypeRef {\n+        TypeRef::cast(&n.syntax).unwrap()\n+    }\n+}\n+\n \n impl AstNode for TypeRef {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {"}, {"sha": "e2d4856cfee84c0d46a2a6119cb30ae3be59e431", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/666303faf3c8b4215fde884451688084e298d6a8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/666303faf3c8b4215fde884451688084e298d6a8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=666303faf3c8b4215fde884451688084e298d6a8", "patch": "@@ -38,6 +38,15 @@ pub enum {{ node }}Kind<'a> {\n {%- endfor %}\n }\n \n+{%- for kind in methods.enum %}\n+impl<'a> From<&'a {{ kind }}> for &'a {{ node }} {\n+    fn from(n: &'a {{ kind }}) -> &'a {{ node }} {\n+        {{ node }}::cast(&n.syntax).unwrap()\n+    }\n+}\n+{%- endfor %}\n+\n+\n impl AstNode for {{ node }} {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {"}]}