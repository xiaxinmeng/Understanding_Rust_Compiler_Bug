{"sha": "9b5db220c899fdd3656c8e28fc747808b8cab7c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNWRiMjIwYzg5OWZkZDM2NTZjOGUyOGZjNzQ3ODA4YjhjYWI3Yzc=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-07-19T12:40:42Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-07-20T12:06:25Z"}, "message": "Add doc for btree_map types", "tree": {"sha": "83e1dd830452004d21f318c5bececce2dd5204c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83e1dd830452004d21f318c5bececce2dd5204c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b5db220c899fdd3656c8e28fc747808b8cab7c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5db220c899fdd3656c8e28fc747808b8cab7c7", "html_url": "https://github.com/rust-lang/rust/commit/9b5db220c899fdd3656c8e28fc747808b8cab7c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b5db220c899fdd3656c8e28fc747808b8cab7c7/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a63e3fac8fdf5187b155624aca622597ca9d344d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a63e3fac8fdf5187b155624aca622597ca9d344d", "html_url": "https://github.com/rust-lang/rust/commit/a63e3fac8fdf5187b155624aca622597ca9d344d"}], "stats": {"total": 191, "additions": 189, "deletions": 2}, "files": [{"sha": "c3a7d4023754aac97d45a0539a9cf0e4a8cfe490", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 189, "deletions": 2, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/9b5db220c899fdd3656c8e28fc747808b8cab7c7/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5db220c899fdd3656c8e28fc747808b8cab7c7/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9b5db220c899fdd3656c8e28fc747808b8cab7c7", "patch": "@@ -313,6 +313,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n+/// This enum is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`entry`]: struct.BTreeMap.html#method.entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n@@ -340,7 +344,9 @@ impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for Entry<'a, K, V> {\n     }\n }\n \n-/// A vacant Entry.\n+/// A vacant Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n@@ -360,7 +366,9 @@ impl<'a, K: 'a + Debug + Ord, V: 'a> Debug for VacantEntry<'a, K, V> {\n     }\n }\n \n-/// An occupied Entry.\n+/// An occupied Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -1890,6 +1898,17 @@ impl<K, V> BTreeMap<K, V> {\n impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n@@ -1900,6 +1919,19 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n \n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_owned();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n@@ -1909,6 +1941,15 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -1921,19 +1962,58 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n \n     /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn into_key(self) -> K {\n         self.key\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n+    ///     *count.entry(x).or_insert(0) += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         *self.length += 1;\n@@ -1979,43 +2059,150 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n     }\n \n     /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_pair();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn remove_pair(self) -> (K, V) {\n         self.remove_kv()\n     }\n \n     /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.handle.reborrow().into_kv().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.handle.kv_mut().1\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.handle.into_kv_mut().1\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         self.remove_kv().1"}]}