{"sha": "2fb4c4472e4563a52e2dc544e47a01f564b9219e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYjRjNDQ3MmU0NTYzYTUyZTJkYzU0NGU0N2EwMWY1NjRiOTIxOWU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-11T19:48:47Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-14T21:23:07Z"}, "message": "Improve graphviz visualization for new framework", "tree": {"sha": "539f646aabd5dc4d489d080f70a74d2c69d5d2f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/539f646aabd5dc4d489d080f70a74d2c69d5d2f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fb4c4472e4563a52e2dc544e47a01f564b9219e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb4c4472e4563a52e2dc544e47a01f564b9219e", "html_url": "https://github.com/rust-lang/rust/commit/2fb4c4472e4563a52e2dc544e47a01f564b9219e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fb4c4472e4563a52e2dc544e47a01f564b9219e/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30ca215b4e38b32aa7abdd635c5e2d56f5724494", "url": "https://api.github.com/repos/rust-lang/rust/commits/30ca215b4e38b32aa7abdd635c5e2d56f5724494", "html_url": "https://github.com/rust-lang/rust/commit/30ca215b4e38b32aa7abdd635c5e2d56f5724494"}], "stats": {"total": 521, "additions": 405, "deletions": 116}, "files": [{"sha": "fdf86e7b53f607d4ce0a8338ef9e4fadd5111f4a", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "modified", "additions": 402, "deletions": 116, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/2fb4c4472e4563a52e2dc544e47a01f564b9219e/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb4c4472e4563a52e2dc544e47a01f564b9219e/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=2fb4c4472e4563a52e2dc544e47a01f564b9219e", "patch": "@@ -1,13 +1,14 @@\n+//! A helpful diagram for debugging dataflow problems.\n+\n use std::cell::RefCell;\n-use std::io::{self, Write};\n-use std::{ops, str};\n+use std::{io, ops, str};\n \n use rustc::mir::{self, BasicBlock, Body, Location};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::Idx;\n+use rustc_index::vec::{Idx, IndexVec};\n \n-use super::{Analysis, Results, ResultsRefCursor};\n+use super::{Analysis, GenKillSet, Results, ResultsRefCursor};\n use crate::util::graphviz_safe_def_name;\n \n pub struct Formatter<'a, 'tcx, A>\n@@ -25,11 +26,16 @@ impl<A> Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    pub fn new(body: &'a Body<'tcx>, def_id: DefId, results: &'a Results<'tcx, A>) -> Self {\n+    pub fn new(\n+        body: &'a Body<'tcx>,\n+        def_id: DefId,\n+        results: &'a Results<'tcx, A>,\n+        state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n+    ) -> Self {\n         let block_formatter = BlockFormatter {\n             bg: Background::Light,\n-            prev_state: BitSet::new_empty(results.analysis.bits_per_block(body)),\n             results: ResultsRefCursor::new(body, results),\n+            state_formatter,\n         };\n \n         Formatter { body, def_id, block_formatter: RefCell::new(block_formatter) }\n@@ -117,15 +123,21 @@ struct BlockFormatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    prev_state: BitSet<A::Idx>,\n     results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n     bg: Background,\n+    state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n }\n \n impl<A> BlockFormatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n+    const HEADER_COLOR: &'static str = \"#a0a0a0\";\n+\n+    fn num_state_columns(&self) -> usize {\n+        std::cmp::max(1, self.state_formatter.column_names().len())\n+    }\n+\n     fn toggle_background(&mut self) -> Background {\n         let bg = self.bg;\n         self.bg = !bg;\n@@ -164,196 +176,470 @@ where\n             r#\"<table border=\"1\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"3\" sides=\"rb\">\"#,\n         )?;\n \n-        // A: Block info\n-        write!(\n-            w,\n-            r#\"<tr>\n-                 <td colspan=\"{num_headers}\" sides=\"tl\">bb{block_id}</td>\n-               </tr>\"#,\n-            num_headers = 3,\n-            block_id = block.index(),\n-        )?;\n-\n-        // B: Column headings\n-        write!(\n-            w,\n-            r#\"<tr>\n-                 <td colspan=\"2\" {fmt}>MIR</td>\n-                 <td {fmt}>STATE</td>\n-               </tr>\"#,\n-            fmt = r##\"bgcolor=\"#a0a0a0\" sides=\"tl\"\"##,\n-        )?;\n+        // A + B: Block header\n+        if self.state_formatter.column_names().is_empty() {\n+            self.write_block_header_simple(w, block)?;\n+        } else {\n+            self.write_block_header_with_state_columns(w, block)?;\n+        }\n \n         // C: Entry state\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n-        self.write_row_with_curr_state(w, \"\", \"(on entry)\")?;\n-        self.prev_state.overwrite(self.results.get());\n+        self.write_row_with_full_state(w, \"\", \"(on_entry)\")?;\n \n         // D: Statement transfer functions\n         for (i, statement) in body[block].statements.iter().enumerate() {\n             let location = Location { block, statement_index: i };\n-\n-            let mir_col = format!(\"{:?}\", statement);\n-            let i_col = i.to_string();\n-\n-            self.results.seek_after(location);\n-            self.write_row_with_curr_diff(w, &i_col, &mir_col)?;\n-            self.prev_state.overwrite(self.results.get());\n+            let statement_str = format!(\"{:?}\", statement);\n+            self.write_row_for_location(w, &i.to_string(), &statement_str, location)?;\n         }\n \n         // E: Terminator transfer function\n         let terminator = body[block].terminator();\n-        let location = body.terminator_loc(block);\n+        let terminator_loc = body.terminator_loc(block);\n+        let mut terminator_str = String::new();\n+        terminator.kind.fmt_head(&mut terminator_str).unwrap();\n \n-        let mut mir_col = String::new();\n-        terminator.kind.fmt_head(&mut mir_col).unwrap();\n-\n-        self.results.seek_after(location);\n-        self.write_row_with_curr_diff(w, \"T\", &mir_col)?;\n-        self.prev_state.overwrite(self.results.get());\n+        self.write_row_for_location(w, \"T\", &terminator_str, terminator_loc)?;\n \n         // F: Exit state\n+        self.results.seek_after(terminator_loc);\n         if let mir::TerminatorKind::Call { destination: Some(_), .. } = &terminator.kind {\n-            self.write_row_with_curr_state(w, \"\", \"(on unwind)\")?;\n-\n-            self.results.seek_after_assume_call_returns(location);\n-            self.write_row_with_curr_diff(w, \"\", \"(on successful return)\")?;\n+            self.write_row_with_full_state(w, \"\", \"(on unwind)\")?;\n+\n+            let num_state_columns = self.num_state_columns();\n+            self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n+                write!(\n+                    w,\n+                    r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                    colspan = num_state_columns,\n+                    fmt = fmt,\n+                )?;\n+\n+                let state_on_unwind = this.results.get().clone();\n+                this.results.seek_after_assume_call_returns(terminator_loc);\n+                write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n+\n+                write!(w, \"</td>\")\n+            })?;\n         } else {\n-            self.write_row_with_curr_state(w, \"\", \"(on exit)\")?;\n+            self.write_row_with_full_state(w, \"\", \"(on exit)\")?;\n         }\n \n         write!(w, \"</table>\")\n     }\n \n-    fn write_row_with_curr_state(\n+    fn write_block_header_simple(\n         &mut self,\n         w: &mut impl io::Write,\n-        i: &str,\n-        mir: &str,\n+        block: BasicBlock,\n     ) -> io::Result<()> {\n-        let bg = self.toggle_background();\n+        //   +-------------------------------------------------+\n+        // A |                      bb4                        |\n+        //   +-----------------------------------+-------------+\n+        // B |                MIR                |    STATE    |\n+        //   +-+---------------------------------+-------------+\n+        //   | |              ...                |             |\n \n-        let mut out = Vec::new();\n-        write!(&mut out, \"{{\")?;\n-        pretty_print_state_elems(&mut out, self.results.analysis(), self.results.get().iter())?;\n-        write!(&mut out, \"}}\")?;\n+        // A\n+        write!(\n+            w,\n+            concat!(\"<tr>\", r#\"<td colspan=\"3\" sides=\"tl\">bb{block_id}</td>\"#, \"</tr>\",),\n+            block_id = block.index(),\n+        )?;\n \n+        // B\n         write!(\n             w,\n-            r#\"<tr>\n-                 <td {fmt} align=\"right\">{i}</td>\n-                 <td {fmt} align=\"left\">{mir}</td>\n-                 <td {fmt} align=\"left\">{state}</td>\n-               </tr>\"#,\n-            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n-            i = i,\n-            mir = dot::escape_html(mir),\n-            state = dot::escape_html(str::from_utf8(&out).unwrap()),\n+            concat!(\n+                \"<tr>\",\n+                r#\"<td colspan=\"2\" {fmt}>MIR</td>\"#,\n+                r#\"<td {fmt}>STATE</td>\"#,\n+                \"</tr>\",\n+            ),\n+            fmt = format!(\"bgcolor=\\\"{}\\\" sides=\\\"tl\\\"\", Self::HEADER_COLOR),\n         )\n     }\n \n-    fn write_row_with_curr_diff(\n+    fn write_block_header_with_state_columns(\n         &mut self,\n         w: &mut impl io::Write,\n-        i: &str,\n-        mir: &str,\n+        block: BasicBlock,\n     ) -> io::Result<()> {\n-        let bg = self.toggle_background();\n-        let analysis = self.results.analysis();\n+        //   +------------------------------------+-------------+\n+        // A |                bb4                 |    STATE    |\n+        //   +------------------------------------+------+------+\n+        // B |                MIR                 |  GEN | KILL |\n+        //   +-+----------------------------------+------+------+\n+        //   | |              ...                 |      |      |\n \n-        let diff = BitSetDiff::compute(&self.prev_state, self.results.get());\n+        let state_column_names = self.state_formatter.column_names();\n \n-        let mut set = Vec::new();\n-        pretty_print_state_elems(&mut set, analysis, diff.set.iter())?;\n+        // A\n+        write!(\n+            w,\n+            concat!(\n+                \"<tr>\",\n+                r#\"<td {fmt} colspan=\"2\">bb{block_id}</td>\"#,\n+                r#\"<td {fmt} colspan=\"{num_state_cols}\">STATE</td>\"#,\n+                \"</tr>\",\n+            ),\n+            fmt = \"sides=\\\"tl\\\"\",\n+            num_state_cols = state_column_names.len(),\n+            block_id = block.index(),\n+        )?;\n+\n+        // B\n+        let fmt = format!(\"bgcolor=\\\"{}\\\" sides=\\\"tl\\\"\", Self::HEADER_COLOR);\n+        write!(w, concat!(\"<tr>\", r#\"<td colspan=\"2\" {fmt}>MIR</td>\"#,), fmt = fmt,)?;\n \n-        let mut clear = Vec::new();\n-        pretty_print_state_elems(&mut clear, analysis, diff.clear.iter())?;\n+        for name in state_column_names {\n+            write!(w, \"<td {fmt}>{name}</td>\", fmt = fmt, name = name)?;\n+        }\n+\n+        write!(w, \"</tr>\")\n+    }\n+\n+    /// Write a row with the given index and MIR, using the function argument to fill in the\n+    /// \"STATE\" column(s).\n+    fn write_row<W: io::Write>(\n+        &mut self,\n+        w: &mut W,\n+        i: &str,\n+        mir: &str,\n+        f: impl FnOnce(&mut Self, &mut W, &str) -> io::Result<()>,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+        let fmt = format!(\"sides=\\\"tl\\\" {}\", bg.attr());\n \n         write!(\n             w,\n-            r#\"<tr>\n-                 <td {fmt} align=\"right\">{i}</td>\n-                 <td {fmt} align=\"left\">{mir}</td>\n-                 <td {fmt} align=\"left\">\"#,\n+            concat!(\n+                \"<tr>\",\n+                r#\"<td {fmt} align=\"right\">{i}</td>\"#,\n+                r#\"<td {fmt} align=\"left\">{mir}</td>\"#,\n+            ),\n             i = i,\n-            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            fmt = fmt,\n             mir = dot::escape_html(mir),\n         )?;\n \n-        if !set.is_empty() {\n+        f(self, w, &fmt)?;\n+        write!(w, \"</tr>\")\n+    }\n+\n+    fn write_row_with_full_state(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        self.write_row(w, i, mir, |this, w, fmt| {\n+            let state = this.results.get();\n+            let analysis = this.results.analysis();\n+\n             write!(\n                 w,\n-                r#\"<font color=\"darkgreen\">+{}</font>\"#,\n-                dot::escape_html(str::from_utf8(&set).unwrap()),\n+                r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{{\"#,\n+                colspan = this.num_state_columns(),\n+                fmt = fmt,\n             )?;\n+            pretty_print_state_elems(w, analysis, state.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+            write!(w, \"}}</td>\")\n+        })\n+    }\n+\n+    fn write_row_for_location(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        self.write_row(w, i, mir, |this, w, fmt| {\n+            this.state_formatter.write_state_for_location(w, fmt, &mut this.results, location)\n+        })\n+    }\n+}\n+\n+/// Controls what gets printed under the `STATE` header.\n+pub trait StateFormatter<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// The columns that will get printed under `STATE`.\n+    fn column_names(&self) -> &[&str];\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()>;\n+}\n+\n+/// Prints a single column containing the state vector immediately *after* each statement.\n+pub struct SimpleDiff<T: Idx> {\n+    prev_state: BitSet<T>,\n+    prev_loc: Location,\n+}\n+\n+impl<T: Idx> SimpleDiff<T> {\n+    #![allow(unused)]\n+    pub fn new(bits_per_block: usize) -> Self {\n+        SimpleDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+    }\n+}\n+\n+impl<A> StateFormatter<'tcx, A> for SimpleDiff<A::Idx>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn column_names(&self) -> &[&str] {\n+        &[]\n+    }\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        mut w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        if location.statement_index == 0 {\n+            results.seek_to_block_start(location.block);\n+            self.prev_state.overwrite(results.get());\n+        } else {\n+            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n+            assert_eq!(self.prev_loc.successor_within_block(), location);\n+        }\n+\n+        self.prev_loc = location;\n+        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_before(location);\n+        let curr_state = results.get();\n+        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n+        self.prev_state.overwrite(curr_state);\n+        write!(w, \"</td>\")\n+    }\n+}\n+\n+/// Prints two state columns, one containing only the \"before\" effect of each statement and one\n+/// containing the full effect.\n+pub struct TwoPhaseDiff<T: Idx> {\n+    prev_state: BitSet<T>,\n+    prev_loc: Location,\n+}\n+\n+impl<T: Idx> TwoPhaseDiff<T> {\n+    #![allow(unused)]\n+    pub fn new(bits_per_block: usize) -> Self {\n+        TwoPhaseDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+    }\n+}\n+\n+impl<A> StateFormatter<'tcx, A> for TwoPhaseDiff<A::Idx>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn column_names(&self) -> &[&str] {\n+        &[\"ENTRY\", \" EXIT\"]\n+    }\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        mut w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        if location.statement_index == 0 {\n+            results.seek_to_block_start(location.block);\n+            self.prev_state.overwrite(results.get());\n+        } else {\n+            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n+            assert_eq!(self.prev_loc.successor_within_block(), location);\n         }\n \n-        if !set.is_empty() && !clear.is_empty() {\n-            write!(w, \"  \")?;\n+        self.prev_loc = location;\n+\n+        // Entry\n+\n+        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_before(location);\n+        let curr_state = results.get();\n+        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n+        self.prev_state.overwrite(curr_state);\n+        write!(w, \"</td>\")?;\n+\n+        // Exit\n+\n+        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_after(location);\n+        let curr_state = results.get();\n+        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n+        self.prev_state.overwrite(curr_state);\n+        write!(w, \"</td>\")\n+    }\n+}\n+\n+/// Prints the gen/kill set for the entire block.\n+pub struct BlockTransferFunc<'a, 'tcx, T: Idx> {\n+    body: &'a mir::Body<'tcx>,\n+    trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n+}\n+\n+impl<T: Idx> BlockTransferFunc<'mir, 'tcx, T> {\n+    #![allow(unused)]\n+    pub fn new(\n+        body: &'mir mir::Body<'tcx>,\n+        trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n+    ) -> Self {\n+        BlockTransferFunc { body, trans_for_block }\n+    }\n+}\n+\n+impl<A> StateFormatter<'tcx, A> for BlockTransferFunc<'mir, 'tcx, A::Idx>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn column_names(&self) -> &[&str] {\n+        &[\"GEN\", \"KILL\"]\n+    }\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        mut w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        // Only print a single row.\n+        if location.statement_index != 0 {\n+            return Ok(());\n         }\n \n-        if !clear.is_empty() {\n+        let block_trans = &self.trans_for_block[location.block];\n+        let rowspan = self.body.basic_blocks()[location.block].statements.len();\n+\n+        for set in &[&block_trans.gen, &block_trans.kill] {\n             write!(\n                 w,\n-                r#\"<font color=\"red\">-{}</font>\"#,\n-                dot::escape_html(str::from_utf8(&clear).unwrap()),\n+                r#\"<td {fmt} rowspan=\"{rowspan}\" align=\"center\">\"#,\n+                fmt = fmt,\n+                rowspan = rowspan\n             )?;\n+\n+            pretty_print_state_elems(&mut w, results.analysis(), set.iter(), \"\\n\", None)?;\n+            write!(w, \"</td>\")?;\n         }\n \n-        write!(w, \"</td></tr>\")\n+        Ok(())\n     }\n }\n \n-/// The operations required to transform one `BitSet` into another.\n-struct BitSetDiff<T: Idx> {\n-    set: HybridBitSet<T>,\n-    clear: HybridBitSet<T>,\n-}\n+/// Writes two lines, one containing the added bits and one the removed bits.\n+fn write_diff<A: Analysis<'tcx>>(\n+    w: &mut impl io::Write,\n+    analysis: &A,\n+    from: &BitSet<A::Idx>,\n+    to: &BitSet<A::Idx>,\n+) -> io::Result<()> {\n+    assert_eq!(from.domain_size(), to.domain_size());\n+    let len = from.domain_size();\n+\n+    let mut set = HybridBitSet::new_empty(len);\n+    let mut clear = HybridBitSet::new_empty(len);\n+\n+    // FIXME: Implement a lazy iterator over the symmetric difference of two bitsets.\n+    for i in (0..len).map(|i| A::Idx::new(i)) {\n+        match (from.contains(i), to.contains(i)) {\n+            (false, true) => set.insert(i),\n+            (true, false) => clear.insert(i),\n+            _ => continue,\n+        };\n+    }\n \n-impl<T: Idx> BitSetDiff<T> {\n-    fn compute(from: &BitSet<T>, to: &BitSet<T>) -> Self {\n-        assert_eq!(from.domain_size(), to.domain_size());\n-        let len = from.domain_size();\n-\n-        let mut set = HybridBitSet::new_empty(len);\n-        let mut clear = HybridBitSet::new_empty(len);\n-\n-        // FIXME: This could be made faster if `BitSet::xor` were implemented.\n-        for i in (0..len).map(|i| T::new(i)) {\n-            match (from.contains(i), to.contains(i)) {\n-                (false, true) => set.insert(i),\n-                (true, false) => clear.insert(i),\n-                _ => continue,\n-            };\n-        }\n+    if !set.is_empty() {\n+        write!(w, r#\"<font color=\"darkgreen\">+\"#)?;\n+        pretty_print_state_elems(w, analysis, set.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+        write!(w, r#\"</font>\"#)?;\n+    }\n \n-        BitSetDiff { set, clear }\n+    if !set.is_empty() && !clear.is_empty() {\n+        write!(w, \"<br/>\")?;\n     }\n+\n+    if !clear.is_empty() {\n+        write!(w, r#\"<font color=\"red\">-\"#)?;\n+        pretty_print_state_elems(w, analysis, clear.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+        write!(w, r#\"</font>\"#)?;\n+    }\n+\n+    Ok(())\n }\n \n-/// Formats each `elem` using the pretty printer provided by `analysis` into a comma-separated\n-/// list.\n+/// Line break policy that breaks at 40 characters and starts the next line with a single space.\n+const LIMIT_40_ALIGN_1: Option<LineBreak> = Some(LineBreak { sequence: \"<br/> \", limit: 40 });\n+\n+struct LineBreak {\n+    sequence: &'static str,\n+    limit: usize,\n+}\n+\n+/// Formats each `elem` using the pretty printer provided by `analysis` into a list with the given\n+/// separator (`sep`).\n+///\n+/// Optionally, it will break lines using the given character sequence (usually `<br/>`) and\n+/// character limit.\n fn pretty_print_state_elems<A>(\n     w: &mut impl io::Write,\n     analysis: &A,\n     elems: impl Iterator<Item = A::Idx>,\n-) -> io::Result<()>\n+    sep: &str,\n+    line_break: Option<LineBreak>,\n+) -> io::Result<bool>\n where\n     A: Analysis<'tcx>,\n {\n+    let sep_width = sep.chars().count();\n+\n+    let mut buf = Vec::new();\n+\n     let mut first = true;\n+    let mut curr_line_width = 0;\n+    let mut line_break_inserted = false;\n+\n     for idx in elems {\n         if first {\n             first = false;\n         } else {\n-            write!(w, \",\")?;\n+            write!(w, \"{}\", sep)?;\n+            curr_line_width += sep_width;\n+        }\n+\n+        buf.clear();\n+        analysis.pretty_print_idx(&mut buf, idx)?;\n+        let idx_str =\n+            str::from_utf8(&buf).expect(\"Output of `pretty_print_idx` must be valid UTF-8\");\n+        let escaped = dot::escape_html(idx_str);\n+        let escaped_width = escaped.chars().count();\n+\n+        if let Some(line_break) = &line_break {\n+            if curr_line_width + sep_width + escaped_width > line_break.limit {\n+                write!(w, \"{}\", line_break.sequence)?;\n+                line_break_inserted = true;\n+                curr_line_width = 0;\n+            }\n         }\n \n-        analysis.pretty_print_idx(w, idx)?;\n+        write!(w, \"{}\", escaped)?;\n+        curr_line_width += escaped_width;\n     }\n \n-    Ok(())\n+    Ok(line_break_inserted)\n }\n \n /// The background color used for zebra-striping the table."}, {"sha": "138388d8719de6bd9243c369b98ade7c3302746b", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fb4c4472e4563a52e2dc544e47a01f564b9219e/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb4c4472e4563a52e2dc544e47a01f564b9219e/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=2fb4c4472e4563a52e2dc544e47a01f564b9219e", "patch": "@@ -167,6 +167,7 @@ symbols! {\n         bindings_after_at,\n         block,\n         bool,\n+        borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n         borrowck_graphviz_preflow,\n         box_patterns,\n@@ -337,6 +338,7 @@ symbols! {\n         FxHashSet,\n         FxHashMap,\n         gen_future,\n+        gen_kill,\n         generators,\n         generic_associated_types,\n         generic_param_attrs,\n@@ -735,6 +737,7 @@ symbols! {\n         try_trait,\n         tt,\n         tuple_indexing,\n+        two_phase,\n         Ty,\n         ty,\n         type_alias_impl_trait,"}]}