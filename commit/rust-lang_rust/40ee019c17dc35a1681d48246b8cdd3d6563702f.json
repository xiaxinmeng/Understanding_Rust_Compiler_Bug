{"sha": "40ee019c17dc35a1681d48246b8cdd3d6563702f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZWUwMTljMTdkYzM1YTE2ODFkNDgyNDZiOGNkZDNkNjU2MzcwMmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-07-04T15:26:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-07-04T15:28:20Z"}, "message": "allow inference vars in  type_implements_trait", "tree": {"sha": "b5e9795febaff40ffd5ab83439c2fcecc44ca655", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5e9795febaff40ffd5ab83439c2fcecc44ca655"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40ee019c17dc35a1681d48246b8cdd3d6563702f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40ee019c17dc35a1681d48246b8cdd3d6563702f", "html_url": "https://github.com/rust-lang/rust/commit/40ee019c17dc35a1681d48246b8cdd3d6563702f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40ee019c17dc35a1681d48246b8cdd3d6563702f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26f7030b16716712070d04ad938e9762b8756f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f7030b16716712070d04ad938e9762b8756f7f", "html_url": "https://github.com/rust-lang/rust/commit/26f7030b16716712070d04ad938e9762b8756f7f"}], "stats": {"total": 164, "additions": 118, "deletions": 46}, "files": [{"sha": "0986a46572969b4293dd6902c5d7b6f6fc6ed086", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -1559,9 +1559,22 @@ rustc_queries! {\n         desc { \"evaluating trait selection obligation `{}`\", goal.value }\n     }\n \n+    /// Evaluates whether the given type implements the given trait\n+    /// in the given environment.\n+    ///\n+    /// The inputs are:\n+    ///\n+    /// - the def-id of the trait\n+    /// - the self type\n+    /// - the *other* type parameters of the trait, excluding the self-type\n+    /// - the parameter environment\n+    ///\n+    /// FIXME. If the type, trait, or environment has inference variables,\n+    /// this yields `EvaluatedToUnknown`. It should be refactored\n+    /// to use canonicalization, really.\n     query type_implements_trait(\n         key: (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>, )\n-    ) -> bool {\n+    ) -> traits::EvaluationResult {\n         desc { \"evaluating `type_implements_trait` `{:?}`\", key }\n     }\n "}, {"sha": "c1c875eac5589873d1e374261ca061b07a7b4d3a", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -1331,7 +1331,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // to avoid panics\n             if !return_ty.has_infer_types() {\n                 if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator) {\n-                    if tcx.type_implements_trait((iter_trait, return_ty, ty_params, self.param_env))\n+                    if tcx\n+                        .type_implements_trait((iter_trait, return_ty, ty_params, self.param_env))\n+                        .must_apply_modulo_regions()\n                     {\n                         if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(return_span) {\n                             err.span_suggestion_hidden("}, {"sha": "dc765f5228b9dc39a39b8e1268ecdb768d28dad6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -2396,7 +2396,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     normalized_ty,\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n-                if self.predicate_may_hold(&try_obligation) && impls_future {\n+                if self.predicate_may_hold(&try_obligation)\n+                    && impls_future.must_apply_modulo_regions()\n+                {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.ends_with('?') {\n                             err.span_suggestion_verbose("}, {"sha": "c5c1da2d2c0283151c8938ac71efcd21700cc9c8", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -542,8 +542,7 @@ fn vtable_trait_first_method_offset<'tcx>(\n }\n \n /// Check whether a `ty` implements given trait(trait_def_id).\n-///\n-/// NOTE: Always return `false` for a type which needs inference.\n+/// See query definition for details.\n fn type_implements_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: (\n@@ -552,7 +551,7 @@ fn type_implements_trait<'tcx>(\n         SubstsRef<'tcx>,\n         ParamEnv<'tcx>,\n     ),\n-) -> bool {\n+) -> EvaluationResult {\n     let (trait_def_id, ty, params, param_env) = key;\n \n     debug!(\n@@ -562,13 +561,22 @@ fn type_implements_trait<'tcx>(\n \n     let trait_ref = ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, params) };\n \n+    // FIXME: If there are inference variables anywhere, just give up and assume\n+    // we don't know the answer. This works around the ICEs that would result from\n+    // using those inference variables within the `infer_ctxt` we create below.\n+    // Really we should be using canonicalized variables, or perhaps removing\n+    // this query altogether.\n+    if (trait_ref, param_env).needs_infer() {\n+        return EvaluationResult::EvaluatedToUnknown;\n+    }\n+\n     let obligation = Obligation {\n         cause: ObligationCause::dummy(),\n         param_env,\n         recursion_depth: 0,\n         predicate: trait_ref.without_const().to_predicate(tcx),\n     };\n-    tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+    tcx.infer_ctxt().enter(|infcx| infcx.evaluate_obligation_no_overflow(&obligation))\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "7ff4a108dabcf83a925f23a5fa06c7a0c732d9c7", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -444,12 +444,15 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             // panic otherwise.\n                             if !expr_ty.has_infer_types()\n                                 && !ty.has_infer_types()\n-                                && fcx.tcx.type_implements_trait((\n-                                    from_trait,\n-                                    ty,\n-                                    ty_params,\n-                                    fcx.param_env,\n-                                ))\n+                                && fcx\n+                                    .tcx\n+                                    .type_implements_trait((\n+                                        from_trait,\n+                                        ty,\n+                                        ty_params,\n+                                        fcx.param_env,\n+                                    ))\n+                                    .must_apply_modulo_regions()\n                             {\n                                 label = false;\n                                 err.span_suggestion("}, {"sha": "e5f18778f43e62171fd089c97972133ac20cd328", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -961,12 +961,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_drop_defined_for_ty = |ty: Ty<'tcx>| {\n             let drop_trait = self.tcx.require_lang_item(hir::LangItem::Drop, Some(closure_span));\n             let ty_params = self.tcx.mk_substs_trait(base_path_ty, &[]);\n-            self.tcx.type_implements_trait((\n-                drop_trait,\n-                ty,\n-                ty_params,\n-                self.tcx.param_env(closure_def_id.expect_local()),\n-            ))\n+            self.tcx\n+                .type_implements_trait((\n+                    drop_trait,\n+                    ty,\n+                    ty_params,\n+                    self.tcx.param_env(closure_def_id.expect_local()),\n+                ))\n+                .must_apply_modulo_regions()\n         };\n \n         let is_drop_defined_for_ty = is_drop_defined_for_ty(base_path_ty);"}, {"sha": "ba3a1617b9c1d57fe4c2f97c3d5c12225ec979af", "filename": "src/test/ui/async-await/issue-84841.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/src%2Ftest%2Fui%2Fasync-await%2Fissue-84841.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/src%2Ftest%2Fui%2Fasync-await%2Fissue-84841.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-84841.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -1,8 +1,14 @@\n // edition:2018\n \n-async fn main() {\n+fn main() {\n+\n+}\n+\n+async fn foo() {\n     // Adding an .await here avoids the ICE\n     test()?;\n+    //~^ ERROR the `?` operator can only be applied to values that implement `Try`\n+    //~| ERROR the `?` operator can only be used in an async function that returns\n }\n \n // Removing the const generic parameter here avoids the ICE"}, {"sha": "170dcf581ed263ca9303baac07cc097152ddfd66", "filename": "src/test/ui/async-await/issue-84841.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/src%2Ftest%2Fui%2Fasync-await%2Fissue-84841.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/src%2Ftest%2Fui%2Fasync-await%2Fissue-84841.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-84841.stderr?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -0,0 +1,28 @@\n+error[E0277]: the `?` operator can only be applied to values that implement `Try`\n+  --> $DIR/issue-84841.rs:9:5\n+   |\n+LL |     test()?;\n+   |     ^^^^^^^ the `?` operator cannot be applied to type `impl Future`\n+   |\n+   = help: the trait `Try` is not implemented for `impl Future`\n+   = note: required by `branch`\n+\n+error[E0277]: the `?` operator can only be used in an async function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n+  --> $DIR/issue-84841.rs:9:11\n+   |\n+LL |   async fn foo() {\n+   |  ________________-\n+LL | |     // Adding an .await here avoids the ICE\n+LL | |     test()?;\n+   | |           ^ cannot use the `?` operator in an async function that returns `()`\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n+   |\n+   = help: the trait `FromResidual<_>` is not implemented for `()`\n+   = note: required by `from_residual`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "add487593c6d2a480e220e21dbbe7b7d19bcd72a", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/40ee019c17dc35a1681d48246b8cdd3d6563702f/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ee019c17dc35a1681d48246b8cdd3d6563702f/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=40ee019c17dc35a1681d48246b8cdd3d6563702f", "patch": "@@ -128,7 +128,9 @@ pub fn implements_trait<'tcx>(\n         return false;\n     }\n     let ty_params = cx.tcx.mk_substs(ty_params.iter());\n-    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n+    cx.tcx\n+        .type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n+        .must_apply_modulo_regions()\n }\n \n /// Checks whether this type implements `Drop`.\n@@ -144,22 +146,26 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did)).is_some(),\n         ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n+        ty::Slice(ty)\n+        | ty::Array(ty, _)\n+        | ty::RawPtr(ty::TypeAndMut { ty, .. })\n+        | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n-        },\n+        }\n         ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder()\n+                {\n                     if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n             }\n             false\n-        },\n+        }\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n@@ -169,7 +175,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        },\n+        }\n         _ => false,\n     }\n }\n@@ -179,7 +185,11 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // not succeed\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn is_normalizable<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> bool {\n     is_normalizable_helper(cx, param_env, ty, &mut FxHashMap::default())\n }\n \n@@ -199,15 +209,14 @@ fn is_normalizable_helper<'tcx>(\n         if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n             match ty.kind() {\n                 ty::Adt(def, substs) => def.variants.iter().all(|variant| {\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n+                    variant.fields.iter().all(|field| {\n+                        is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache)\n+                    })\n                 }),\n                 _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    },\n+                    }\n                     _ => true, // if inner_ty == ty, we've already checked it\n                 }),\n             }\n@@ -225,7 +234,9 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => {\n+            is_recursively_primitive_type(inner_type)\n+        }\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -269,11 +280,7 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n-        } else {\n-            (ty, count)\n-        }\n+        if let ty::Ref(_, ty, _) = ty.kind() { peel(ty, count + 1) } else { (ty, count) }\n     }\n     peel(ty, 0)\n }\n@@ -328,17 +335,18 @@ pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n                 return false;\n             }\n \n-            substs_a\n-                .iter()\n-                .zip(substs_b.iter())\n-                .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) {\n-                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b,\n+            substs_a.iter().zip(substs_b.iter()).all(|(arg_a, arg_b)| {\n+                match (arg_a.unpack(), arg_b.unpack()) {\n+                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => {\n+                        inner_a == inner_b\n+                    }\n                     (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => {\n                         same_type_and_consts(type_a, type_b)\n-                    },\n+                    }\n                     _ => true,\n-                })\n-        },\n+                }\n+            })\n+        }\n         _ => a == b,\n     }\n }"}]}