{"sha": "85c0558d032e204f4f4ed6137f3119cb92dbc684", "node_id": "C_kwDOAAsO6NoAKDg1YzA1NThkMDMyZTIwNGY0ZjRlZDYxMzdmMzExOWNiOTJkYmM2ODQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-28T16:03:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-28T16:03:13Z"}, "message": "Auto merge of #90218 - JakobDegen:adt_significant_drop_fix, r=nikomatsakis\n\nFixes incorrect handling of ADT's drop requirements\n\nFixes #90024 and a bunch of duplicates.\n\nThe main issue was just that the contract of `NeedsDropTypes::adt_components` was inconsistent; the list of types it might return were the generic parameters themselves or the fields of the ADT, depending on the nature of the drop impl. This meant that the caller could not determine whether a `.subst()` call was still needed on those types; it called `.subst()` in all cases, and this led to ICEs when the returned types were the generic params.\n\nFirst contribution of more than a few lines, so feedback definitely appreciated.", "tree": {"sha": "3127518a8c43fba07d795570a44569b84f90bb8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3127518a8c43fba07d795570a44569b84f90bb8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85c0558d032e204f4f4ed6137f3119cb92dbc684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85c0558d032e204f4f4ed6137f3119cb92dbc684", "html_url": "https://github.com/rust-lang/rust/commit/85c0558d032e204f4f4ed6137f3119cb92dbc684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85c0558d032e204f4f4ed6137f3119cb92dbc684/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4ff03f689c03d73d3a8af49611b1f2b54d6a300", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ff03f689c03d73d3a8af49611b1f2b54d6a300", "html_url": "https://github.com/rust-lang/rust/commit/c4ff03f689c03d73d3a8af49611b1f2b54d6a300"}, {"sha": "aff37f8f7b0a14493e17bc9fd7844f4392d08241", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff37f8f7b0a14493e17bc9fd7844f4392d08241", "html_url": "https://github.com/rust-lang/rust/commit/aff37f8f7b0a14493e17bc9fd7844f4392d08241"}], "stats": {"total": 138, "additions": 93, "deletions": 45}, "files": [{"sha": "3f66e5b4ebfbeb80c2894201bd3d153e2c58f974", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/85c0558d032e204f4f4ed6137f3119cb92dbc684/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c0558d032e204f4f4ed6137f3119cb92dbc684/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=85c0558d032e204f4f4ed6137f3119cb92dbc684", "patch": "@@ -12,14 +12,12 @@ use rustc_span::{sym, DUMMY_SP};\n type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n \n fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    let adt_components =\n-        move |adt_def: &ty::AdtDef, _| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter());\n-\n     // If we don't know a type doesn't need drop, for example if it's a type\n     // parameter without a `Copy` bound, then we conservatively return that it\n     // needs drop.\n-    let res =\n-        NeedsDropTypes::new(tcx, query.param_env, query.value, adt_components).next().is_some();\n+    let adt_has_dtor =\n+        |adt_def: &ty::AdtDef| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n+    let res = drop_tys_helper(tcx, query.value, query.param_env, adt_has_dtor).next().is_some();\n \n     debug!(\"needs_drop_raw({:?}) = {:?}\", query, res);\n     res\n@@ -29,12 +27,10 @@ fn has_significant_drop_raw<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> bool {\n-    let significant_drop_fields = move |adt_def: &ty::AdtDef, _| {\n-        tcx.adt_significant_drop_tys(adt_def.did).map(|tys| tys.iter())\n-    };\n-    let res = NeedsDropTypes::new(tcx, query.param_env, query.value, significant_drop_fields)\n-        .next()\n-        .is_some();\n+    let res =\n+        drop_tys_helper(tcx, query.value, query.param_env, adt_consider_insignificant_dtor(tcx))\n+            .next()\n+            .is_some();\n     debug!(\"has_significant_drop_raw({:?}) = {:?}\", query, res);\n     res\n }\n@@ -145,10 +141,8 @@ where\n                             Ok(tys) => tys,\n                         };\n                         for required_ty in tys {\n-                            let subst_ty = tcx.normalize_erasing_regions(\n-                                self.param_env,\n-                                required_ty.subst(tcx, substs),\n-                            );\n+                            let subst_ty =\n+                                tcx.normalize_erasing_regions(self.param_env, required_ty);\n                             queue_type(self, subst_ty);\n                         }\n                     }\n@@ -187,23 +181,24 @@ enum DtorType {\n // Depending on the implentation of `adt_has_dtor`, it is used to check if the\n // ADT has a destructor or if the ADT only has a significant destructor. For\n // understanding significant destructor look at `adt_significant_drop_tys`.\n-fn adt_drop_tys_helper<'tcx>(\n+fn drop_tys_helper<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    ty: Ty<'tcx>,\n+    param_env: rustc_middle::ty::ParamEnv<'tcx>,\n     adt_has_dtor: impl Fn(&ty::AdtDef) -> Option<DtorType>,\n-) -> Result<&ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+) -> impl Iterator<Item = NeedsDropResult<Ty<'tcx>>> {\n     let adt_components = move |adt_def: &ty::AdtDef, substs: SubstsRef<'tcx>| {\n         if adt_def.is_manually_drop() {\n-            debug!(\"adt_drop_tys: `{:?}` is manually drop\", adt_def);\n+            debug!(\"drop_tys_helper: `{:?}` is manually drop\", adt_def);\n             return Ok(Vec::new().into_iter());\n         } else if let Some(dtor_info) = adt_has_dtor(adt_def) {\n             match dtor_info {\n                 DtorType::Significant => {\n-                    debug!(\"adt_drop_tys: `{:?}` implements `Drop`\", adt_def);\n+                    debug!(\"drop_tys_helper: `{:?}` implements `Drop`\", adt_def);\n                     return Err(AlwaysRequiresDrop);\n                 }\n                 DtorType::Insignificant => {\n-                    debug!(\"adt_drop_tys: `{:?}` drop is insignificant\", adt_def);\n+                    debug!(\"drop_tys_helper: `{:?}` drop is insignificant\", adt_def);\n \n                     // Since the destructor is insignificant, we just want to make sure all of\n                     // the passed in type parameters are also insignificant.\n@@ -212,34 +207,27 @@ fn adt_drop_tys_helper<'tcx>(\n                 }\n             }\n         } else if adt_def.is_union() {\n-            debug!(\"adt_drop_tys: `{:?}` is a union\", adt_def);\n+            debug!(\"drop_tys_helper: `{:?}` is a union\", adt_def);\n             return Ok(Vec::new().into_iter());\n         }\n-        Ok(adt_def.all_fields().map(|field| tcx.type_of(field.did)).collect::<Vec<_>>().into_iter())\n+        Ok(adt_def\n+            .all_fields()\n+            .map(|field| {\n+                let r = tcx.type_of(field.did).subst(tcx, substs);\n+                debug!(\"drop_tys_helper: Subst into {:?} with {:?} gettng {:?}\", field, substs, r);\n+                r\n+            })\n+            .collect::<Vec<_>>()\n+            .into_iter())\n     };\n \n-    let adt_ty = tcx.type_of(def_id);\n-    let param_env = tcx.param_env(def_id);\n-    let res: Result<Vec<_>, _> =\n-        NeedsDropTypes::new(tcx, param_env, adt_ty, adt_components).collect();\n-\n-    debug!(\"adt_drop_tys(`{}`) = `{:?}`\", tcx.def_path_str(def_id), res);\n-    res.map(|components| tcx.intern_type_list(&components))\n+    NeedsDropTypes::new(tcx, param_env, ty, adt_components)\n }\n \n-fn adt_drop_tys(tcx: TyCtxt<'_>, def_id: DefId) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n-    // This is for the \"needs_drop\" query, that considers all `Drop` impls, therefore all dtors are\n-    // significant.\n-    let adt_has_dtor =\n-        |adt_def: &ty::AdtDef| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n-    adt_drop_tys_helper(tcx, def_id, adt_has_dtor)\n-}\n-\n-fn adt_significant_drop_tys(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n-    let adt_has_dtor = |adt_def: &ty::AdtDef| {\n+fn adt_consider_insignificant_dtor<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+) -> impl Fn(&ty::AdtDef) -> Option<DtorType> + 'tcx {\n+    move |adt_def: &ty::AdtDef| {\n         let is_marked_insig = tcx.has_attr(adt_def.did, sym::rustc_insignificant_dtor);\n         if is_marked_insig {\n             // In some cases like `std::collections::HashMap` where the struct is a wrapper around\n@@ -256,8 +244,31 @@ fn adt_significant_drop_tys(\n             // treat this as the simple case of Drop impl for type.\n             None\n         }\n-    };\n-    adt_drop_tys_helper(tcx, def_id, adt_has_dtor)\n+    }\n+}\n+\n+fn adt_drop_tys(tcx: TyCtxt<'_>, def_id: DefId) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n+    // This is for the \"adt_drop_tys\" query, that considers all `Drop` impls, therefore all dtors are\n+    // significant.\n+    let adt_has_dtor =\n+        |adt_def: &ty::AdtDef| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n+    drop_tys_helper(tcx, tcx.type_of(def_id), tcx.param_env(def_id), adt_has_dtor)\n+        .collect::<Result<Vec<_>, _>>()\n+        .map(|components| tcx.intern_type_list(&components))\n+}\n+\n+fn adt_significant_drop_tys(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n+    drop_tys_helper(\n+        tcx,\n+        tcx.type_of(def_id),\n+        tcx.param_env(def_id),\n+        adt_consider_insignificant_dtor(tcx),\n+    )\n+    .collect::<Result<Vec<_>, _>>()\n+    .map(|components| tcx.intern_type_list(&components))\n }\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "ed8cb042b3ea6a6862f9b9be3bf5fa7b1321158c", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/issue-90024-adt-correct-subst.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/85c0558d032e204f4f4ed6137f3119cb92dbc684/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-90024-adt-correct-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c0558d032e204f4f4ed6137f3119cb92dbc684/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-90024-adt-correct-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-90024-adt-correct-subst.rs?ref=85c0558d032e204f4f4ed6137f3119cb92dbc684", "patch": "@@ -0,0 +1,37 @@\n+// Test that rustc doesn't ICE as in #90024.\n+// check-pass\n+// edition=2018\n+\n+#![warn(rust_2021_incompatible_closure_captures)]\n+\n+// Checks there's no double-subst into the generic args, otherwise we get OOB\n+// MCVE by @lqd\n+pub struct Graph<N, E, Ix> {\n+    _edges: E,\n+    _nodes: N,\n+    _ix: Vec<Ix>,\n+}\n+fn graph<N, E>() -> Graph<N, E, i32> {\n+    todo!()\n+}\n+fn first_ice() {\n+    let g = graph::<i32, i32>();\n+    let _ = || g;\n+}\n+\n+// Checks that there is a subst into the fields, otherwise we get normalization error\n+// MCVE by @cuviper\n+use std::iter::Empty;\n+struct Foo<I: Iterator> {\n+    data: Vec<I::Item>,\n+}\n+pub fn second_ice() {\n+    let v = Foo::<Empty<()>> { data: vec![] };\n+\n+    (|| v.data[0])();\n+}\n+\n+pub fn main() {\n+    first_ice();\n+    second_ice();\n+}"}]}