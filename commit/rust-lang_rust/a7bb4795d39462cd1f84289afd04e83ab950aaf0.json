{"sha": "a7bb4795d39462cd1f84289afd04e83ab950aaf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmI0Nzk1ZDM5NDYyY2QxZjg0Mjg5YWZkMDRlODNhYjk1MGFhZjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:35:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:31Z"}, "message": "rollup merge of #19935: cgaebel/hashmap-tuple-indexing\n\nr? @Gankro @pczarn", "tree": {"sha": "f8fa67db7ed2e6d6124d715495c3900e7800eea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8fa67db7ed2e6d6124d715495c3900e7800eea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7bb4795d39462cd1f84289afd04e83ab950aaf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bb4795d39462cd1f84289afd04e83ab950aaf0", "html_url": "https://github.com/rust-lang/rust/commit/a7bb4795d39462cd1f84289afd04e83ab950aaf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7bb4795d39462cd1f84289afd04e83ab950aaf0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42dbee098ba766787206e5b4a61e080c90be88fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/42dbee098ba766787206e5b4a61e080c90be88fa", "html_url": "https://github.com/rust-lang/rust/commit/42dbee098ba766787206e5b4a61e080c90be88fa"}, {"sha": "c42e2f604ef2f43e9b8adbf1fc7a40944bfcb668", "url": "https://api.github.com/repos/rust-lang/rust/commits/c42e2f604ef2f43e9b8adbf1fc7a40944bfcb668", "html_url": "https://github.com/rust-lang/rust/commit/c42e2f604ef2f43e9b8adbf1fc7a40944bfcb668"}], "stats": {"total": 129, "additions": 41, "deletions": 88}, "files": [{"sha": "0ff29a94f2f949775545a8fc6cc03f03435358cf", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 38, "deletions": 85, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a7bb4795d39462cd1f84289afd04e83ab950aaf0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bb4795d39462cd1f84289afd04e83ab950aaf0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a7bb4795d39462cd1f84289afd04e83ab950aaf0", "patch": "@@ -297,7 +297,7 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n \n /// Search for a pre-hashed key.\n fn search_hashed<K, V, M, F>(table: M,\n-                             hash: &SafeHash,\n+                             hash: SafeHash,\n                              mut is_match: F)\n                              -> SearchResult<K, V, M> where\n     M: Deref<RawTable<K, V>>,\n@@ -320,14 +320,9 @@ fn search_hashed<K, V, M, F>(table: M,\n         }\n \n         // If the hash doesn't match, it can't be this one..\n-        if *hash == full.hash() {\n-            let matched = {\n-                let (k, _) = full.read();\n-                is_match(k)\n-            };\n-\n+        if hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n-            if matched {\n+            if is_match(full.read().0) {\n                 return FoundExisting(full);\n             }\n         }\n@@ -353,7 +348,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    return (retkey, retval);\n+    (retkey, retval)\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -389,10 +384,11 @@ fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n                     let b = bucket.put(old_hash, old_key, old_val);\n                     // Now that it's stolen, just read the value's pointer\n                     // right out of the table!\n-                    let (_, v) = Bucket::at_index(b.into_table(), starting_index).peek()\n-                                                                                 .expect_full()\n-                                                                                 .into_mut_refs();\n-                    return v;\n+                    return Bucket::at_index(b.into_table(), starting_index)\n+                               .peek()\n+                               .expect_full()\n+                               .into_mut_refs()\n+                               .1;\n                 },\n                 table::Full(bucket) => bucket\n             };\n@@ -441,14 +437,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&self.table, hash, |k| q.equiv(k)).into_option()\n     }\n \n     #[allow(deprecated)]\n     fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&mut self.table, hash, |k| q.equiv(k)).into_option()\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n@@ -458,22 +454,22 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n         let cap = self.table.capacity();\n-        let mut buckets = Bucket::new(&mut self.table, &hash);\n+        let mut buckets = Bucket::new(&mut self.table, hash);\n         let ib = buckets.index();\n \n         while buckets.index() != ib + cap {\n@@ -762,26 +758,22 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     {\n         // Worst case, we'll find one empty bucket among `size + 1` buckets.\n         let size = self.table.size();\n-        let mut probe = Bucket::new(&mut self.table, &hash);\n+        let mut probe = Bucket::new(&mut self.table, hash);\n         let ib = probe.index();\n \n         loop {\n             let mut bucket = match probe.peek() {\n                 Empty(bucket) => {\n                     // Found a hole!\n-                    let bucket = bucket.put(hash, k, v);\n-                    let (_, val) = bucket.into_mut_refs();\n-                    return val;\n-                },\n+                    return bucket.put(hash, k, v).into_mut_refs().1;\n+                }\n                 Full(bucket) => bucket\n             };\n \n+            // hash matches?\n             if bucket.hash() == hash {\n-                let found_match = {\n-                    let (bucket_k, _) = bucket.read_mut();\n-                    k == *bucket_k\n-                };\n-                if found_match {\n+                // key matches?\n+                if k == *bucket.read_mut().0 {\n                     let (bucket_k, bucket_v) = bucket.into_mut_refs();\n                     debug_assert!(k == *bucket_k);\n                     // Key already exists. Get its reference.\n@@ -811,13 +803,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Deprecated: use `get` and `BorrowFrom` instead.\n     #[deprecated = \"use get and BorrowFrom instead\"]\n     pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n-        match self.search_equiv(k) {\n-            None      => None,\n-            Some(bucket) => {\n-                let (_, v_ref) = bucket.into_refs();\n-                Some(v_ref)\n-            }\n-        }\n+        self.search_equiv(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Deprecated: use `remove` and `BorrowFrom` instead.\n@@ -829,13 +815,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         self.reserve(1);\n \n-        match self.search_equiv_mut(k) {\n-            Some(bucket) => {\n-                let (_k, val) = pop_internal(bucket);\n-                Some(val)\n-            }\n-            _ => None\n-        }\n+        self.search_equiv_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n \n     /// An iterator visiting all keys in arbitrary order.\n@@ -1022,11 +1002,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         while buckets.index() != cap {\n             buckets = match buckets.peek() {\n-                Empty(b)  => b.next(),\n-                Full(full) => {\n-                    let (b, _, _) = full.take();\n-                    b.next()\n-                }\n+                Empty(b)   => b.next(),\n+                Full(full) => full.take().0.next(),\n             };\n         }\n     }\n@@ -1057,10 +1034,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n-        self.search(k).map(|bucket| {\n-            let (_, v) = bucket.into_refs();\n-            v\n-        })\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1115,13 +1089,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n-        match self.search_mut(k) {\n-            Some(bucket) => {\n-                let (_, v) = bucket.into_mut_refs();\n-                Some(v)\n-            }\n-            _ => None\n-        }\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Deprecated: Renamed to `insert`.\n@@ -1189,18 +1157,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n             return None\n         }\n \n-        self.search_mut(k).map(|bucket| {\n-            let (_k, val) = pop_internal(bucket);\n-            val\n-        })\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n }\n \n fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n         -> Entry<'a, K, V> {\n     // Worst case, we'll find one empty bucket among `size + 1` buckets.\n     let size = table.size();\n-    let mut probe = Bucket::new(table, &hash);\n+    let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();\n \n     loop {\n@@ -1216,13 +1181,10 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n             Full(bucket) => bucket\n         };\n \n+        // hash matches?\n         if bucket.hash() == hash {\n-            let is_eq = {\n-                let (bucket_k, _) = bucket.read();\n-                k == *bucket_k\n-            };\n-\n-            if is_eq {\n+            // key matches?\n+            if k == *bucket.read().0 {\n                 return Occupied(OccupiedEntry{\n                     elem: bucket,\n                 });\n@@ -1310,10 +1272,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K\n {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n-        match self.get_mut(index) {\n-            Some(v) => v,\n-            None => panic!(\"no entry found for key\")\n-        }\n+        self.get_mut(index).expect(\"no entry found for key\")\n     }\n }\n \n@@ -1404,21 +1363,18 @@ impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {\n-        let (_, v) = self.elem.read();\n-        v\n+        self.elem.read().1\n     }\n \n     /// Gets a mutable reference to the value in the entry\n     pub fn get_mut(&mut self) -> &mut V {\n-        let (_, v) = self.elem.read_mut();\n-        v\n+        self.elem.read_mut().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself\n     pub fn into_mut(self) -> &'a mut V {\n-        let (_, v) = self.elem.into_mut_refs();\n-        v\n+        self.elem.into_mut_refs().1\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value\n@@ -1430,8 +1386,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n \n     /// Takes the value out of the entry, and returns it\n     pub fn take(self) -> V {\n-        let (_, v) = pop_internal(self.elem);\n-        v\n+        pop_internal(self.elem).1\n     }\n }\n \n@@ -1444,17 +1399,15 @@ impl<'a, K, V> VacantEntry<'a, K, V> {\n                 robin_hood(bucket, ib, self.hash, self.key, value)\n             }\n             NoElem(bucket) => {\n-                let full = bucket.put(self.hash, self.key, value);\n-                let (_, v) = full.into_mut_refs();\n-                v\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             }\n         }\n     }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {\n-        let (lower, _) = iter.size_hint();\n+        let lower = iter.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n         map.extend(iter);\n         map"}, {"sha": "67c0f887832fa08d62e9296bb8fefbe9a8df92f8", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7bb4795d39462cd1f84289afd04e83ab950aaf0/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bb4795d39462cd1f84289afd04e83ab950aaf0/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=a7bb4795d39462cd1f84289afd04e83ab950aaf0", "patch": "@@ -593,7 +593,7 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n     fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n-        let (lower, _) = iter.size_hint();\n+        let lower = iter.size_hint().0;\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n         set.extend(iter);\n         set"}, {"sha": "da06387e9a5eb7b940de5ce7b4759e778d362bec", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7bb4795d39462cd1f84289afd04e83ab950aaf0/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bb4795d39462cd1f84289afd04e83ab950aaf0/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=a7bb4795d39462cd1f84289afd04e83ab950aaf0", "patch": "@@ -124,7 +124,7 @@ struct GapThenFull<K, V, M> {\n \n /// A hash that is not zero, since we use a hash of zero to represent empty\n /// buckets.\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Copy)]\n pub struct SafeHash {\n     hash: u64,\n }\n@@ -211,7 +211,7 @@ impl<K, V, M> Bucket<K, V, M> {\n }\n \n impl<K, V, M: Deref<RawTable<K, V>>> Bucket<K, V, M> {\n-    pub fn new(table: M, hash: &SafeHash) -> Bucket<K, V, M> {\n+    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as uint)\n     }\n "}]}