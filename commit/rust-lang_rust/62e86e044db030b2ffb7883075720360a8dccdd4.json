{"sha": "62e86e044db030b2ffb7883075720360a8dccdd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZTg2ZTA0NGRiMDMwYjJmZmI3ODgzMDc1NzIwMzYwYThkY2NkZDQ=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-11T19:41:09Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-17T15:41:25Z"}, "message": "Fixed compile warnings.\nFixed whitespace \"errors\".", "tree": {"sha": "fa049fce4080b323f182d0abedb835973ff1b17e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa049fce4080b323f182d0abedb835973ff1b17e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62e86e044db030b2ffb7883075720360a8dccdd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62e86e044db030b2ffb7883075720360a8dccdd4", "html_url": "https://github.com/rust-lang/rust/commit/62e86e044db030b2ffb7883075720360a8dccdd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62e86e044db030b2ffb7883075720360a8dccdd4/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00bb15bf726e0aa440557131224bdab77dd46682", "url": "https://api.github.com/repos/rust-lang/rust/commits/00bb15bf726e0aa440557131224bdab77dd46682", "html_url": "https://github.com/rust-lang/rust/commit/00bb15bf726e0aa440557131224bdab77dd46682"}], "stats": {"total": 191, "additions": 96, "deletions": 95}, "files": [{"sha": "d248627907ac0ce310b40e79109d19dfeec79fdb", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62e86e044db030b2ffb7883075720360a8dccdd4/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62e86e044db030b2ffb7883075720360a8dccdd4/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=62e86e044db030b2ffb7883075720360a8dccdd4", "patch": "@@ -966,10 +966,10 @@ pub mod llvm {\n                                                  -> BasicBlockRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n-        \n+\n         #[fast_ffi]\n         pub unsafe fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef, MoveAfter: BasicBlockRef);\n-        \n+\n         #[fast_ffi]\n         pub unsafe fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef, MoveBefore: BasicBlockRef);\n \n@@ -2072,13 +2072,13 @@ pub mod llvm {\n             Val: ValueRef,\n             VarInfo: DIVariable,\n             InsertAtEnd: BasicBlockRef) -> ValueRef;\n-            \n+\n         #[fast_ffi]\n         pub unsafe fn LLVMDIBuilderInsertDeclareBefore(\n             Builder: DIBuilderRef,\n             Val: ValueRef,\n             VarInfo: DIVariable,\n-            InsertBefore: ValueRef) -> ValueRef;            \n+            InsertBefore: ValueRef) -> ValueRef;\n     }\n }\n "}, {"sha": "ddc8207dfe04f94c13a155f4056d4fc0027f222e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62e86e044db030b2ffb7883075720360a8dccdd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62e86e044db030b2ffb7883075720360a8dccdd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=62e86e044db030b2ffb7883075720360a8dccdd4", "patch": "@@ -1907,7 +1907,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     finish(bcx);\n     cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n-    \n+\n     unsafe { llvm::LLVMMoveBasicBlockAfter(fcx.llreturn, bcx.llbb); }\n \n     // Insert the mandatory first few basic blocks before lltop."}, {"sha": "bbdfefaaa5963c055cffa90a5744e541ab87bec3", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 91, "deletions": 90, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/62e86e044db030b2ffb7883075720360a8dccdd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62e86e044db030b2ffb7883075720360a8dccdd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=62e86e044db030b2ffb7883075720360a8dccdd4", "patch": "@@ -25,12 +25,10 @@ use core::hashmap::HashMap;\n use core::libc;\n use core::libc::c_uint;\n use core::ptr;\n-use core::str;\n use core::str::as_c_str;\n use core::sys;\n use core::vec;\n use syntax::codemap::span;\n-use syntax::parse::token::ident_interner;\n use syntax::{ast, codemap, ast_util, ast_map};\n \n static LLVMDebugVersion: int = (12 << 16);\n@@ -98,8 +96,8 @@ fn dbg_cx(cx: &CrateContext) -> DebugContext\n }\n \n fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n-    return unsafe { \n-        llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32) \n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n     };\n }\n \n@@ -108,7 +106,7 @@ pub fn finalize(cx: @CrateContext) {\n     debug!(\"finalize\");\n     create_compile_unit(cx);\n     let dcx = dbg_cx(cx);\n-    unsafe { \n+    unsafe {\n         llvm::LLVMDIBuilderFinalize(dcx.builder);\n         llvm::LLVMDIBuilderDispose(dcx.builder);\n     };\n@@ -118,43 +116,43 @@ fn create_compile_unit(cx: @CrateContext) {\n     let crate_name: &str = dbg_cx(cx).crate_file;\n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n-    \n+\n     do as_c_str(crate_name) |crate_name| {\n     do as_c_str(work_dir) |work_dir| {\n     do as_c_str(producer) |producer| {\n     do as_c_str(\"\") |flags| {\n     do as_c_str(\"\") |split_name| { unsafe {\n         llvm::LLVMDIBuilderCreateCompileUnit(dbg_cx(cx).builder,\n-            DW_LANG_RUST as c_uint, crate_name, work_dir, producer, \n+            DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n             cx.sess.opts.optimize != session::No,\n             flags, 0, split_name);\n     }}}}}};\n }\n \n fn create_file(cx: @CrateContext, full_path: &str) -> DIFile {\n     let dcx = dbg_cx(cx);\n-    \n+\n     match dcx.created_files.find_equiv(&full_path) {\n         Some(file_md) => return *file_md,\n         None => ()\n     }\n \n     debug!(\"create_file: %s\", full_path);\n-    \n+\n     let work_dir = cx.sess.working_dir.to_str();\n-    let file_name = \n+    let file_name =\n         if full_path.starts_with(work_dir) {\n             full_path.slice(work_dir.len() + 1u, full_path.len())\n         } else {\n             full_path\n         };\n-        \n-    let file_md = \n+\n+    let file_md =\n         do as_c_str(file_name) |file_name| {\n         do as_c_str(work_dir) |work_dir| { unsafe {\n             llvm::LLVMDIBuilderCreateFile(dcx.builder, file_name, work_dir)\n         }}};\n-        \n+\n     dcx.created_files.insert(full_path.to_owned(), file_md);\n     return file_md;\n }\n@@ -166,8 +164,8 @@ fn span_start(cx: @CrateContext, span: span) -> codemap::Loc {\n fn create_block(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n     let cx = bcx.ccx();\n-    let mut dcx = dbg_cx(cx);\n-    \n+    let dcx = dbg_cx(cx);\n+\n     while bcx.node_info.is_none() {\n         match bcx.parent {\n           Some(b) => bcx = b,\n@@ -176,31 +174,31 @@ fn create_block(bcx: block) -> DILexicalBlock {\n     }\n     let span = bcx.node_info.get().span;\n     let id = bcx.node_info.get().id;\n-    \n+\n     match dcx.created_blocks.find(&id) {\n         Some(block) => return *block,\n         None => ()\n     }\n-    \n+\n     debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(span));\n-    \n+\n     let parent = match bcx.parent {\n         None => create_function(bcx.fcx),\n         Some(b) => create_block(b)\n     };\n     let cx = bcx.ccx();\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n-    \n-    let block_md = unsafe { \n+\n+    let block_md = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n-            dcx.builder, \n-            parent, file_md, \n-            loc.line as c_uint, loc.col.to_uint() as c_uint) \n+            dcx.builder,\n+            parent, file_md,\n+            loc.line as c_uint, loc.col.to_uint() as c_uint)\n     };\n-    \n+\n     dcx.created_blocks.insert(id, block_md);\n-    \n+\n     return block_md;\n }\n \n@@ -211,14 +209,14 @@ fn size_and_align_of(cx: @CrateContext, t: ty::t) -> (uint, uint) {\n }\n \n fn create_basic_type(cx: @CrateContext, t: ty::t, span: span) -> DIType{\n-    let mut dcx = dbg_cx(cx);\n+    let dcx = dbg_cx(cx);\n     let ty_id = ty::type_id(t);\n     match dcx.created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n         None => ()\n     }\n-    \n-    debug!(\"create_basic_type: %?\", ty::get(t));    \n+\n+    debug!(\"create_basic_type: %?\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -249,10 +247,10 @@ fn create_basic_type(cx: @CrateContext, t: ty::t, span: span) -> DIType{\n     let (size, align) = size_and_align_of(cx, t);\n     let ty_md = do as_c_str(name) |name| { unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n-                dcx.builder, name, \n+                dcx.builder, name,\n                 size * 8 as u64, align * 8 as u64, encoding as c_uint)\n         }};\n-        \n+\n     dcx.created_types.insert(ty_id, ty_md);\n     return ty_md;\n }\n@@ -261,7 +259,7 @@ fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span, pointee: DIType)\n     let (size, align) = size_and_align_of(cx, t);\n     let name = ty_to_str(cx.tcx, t);\n     let ptr_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(dbg_cx(cx).builder, \n+        llvm::LLVMDIBuilderCreatePointerType(dbg_cx(cx).builder,\n                 pointee, size * 8 as u64, align * 8 as u64, name)\n     }};\n     return ptr_md;\n@@ -290,27 +288,27 @@ impl StructContext {\n         };\n         return scx;\n     }\n-    \n+\n     fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n         let mem_t = do as_c_str(name) |name| { unsafe {\n-            llvm::LLVMDIBuilderCreateMemberType(dbg_cx(self.cx).builder, \n-                ptr::null(), name, self.file, line as c_uint, \n-                size * 8 as u64, align * 8 as u64, self.total_size as u64, \n+            llvm::LLVMDIBuilderCreateMemberType(dbg_cx(self.cx).builder,\n+                ptr::null(), name, self.file, line as c_uint,\n+                size * 8 as u64, align * 8 as u64, self.total_size as u64,\n                 0, ty)\n             }};\n         // XXX What about member alignment???\n         self.members.push(mem_t);\n         self.total_size += size * 8;\n     }\n-    \n+\n     fn finalize(&self) -> DICompositeType {\n         let dcx = dbg_cx(self.cx);\n         let members_md = create_DIArray(dcx.builder, self.members);\n-        \n-        let struct_md = \n+\n+        let struct_md =\n             do as_c_str(self.name) |name| { unsafe {\n                 llvm::LLVMDIBuilderCreateStructType(\n-                    dcx.builder, ptr::null(), name, \n+                    dcx.builder, ptr::null(), name,\n                     self.file, self.line as c_uint,\n                     self.total_size as u64, self.align as u64, 0, ptr::null(),\n                     members_md, 0, ptr::null())\n@@ -322,7 +320,7 @@ impl StructContext {\n fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field], span: span) -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n-    \n+\n     let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, t), loc.line);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n@@ -339,7 +337,7 @@ fn voidptr(cx: @CrateContext) -> (DIDerivedType, uint, uint) {\n     let size = sys::size_of::<ValueRef>();\n     let align = sys::min_align_of::<ValueRef>();\n     let vp = do as_c_str(\"*void\") |name| { unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(dbg_cx(cx).builder, ptr::null(), \n+            llvm::LLVMDIBuilderCreatePointerType(dbg_cx(cx).builder, ptr::null(),\n                 size*8 as u64, align*8 as u64, name)\n         }};\n     return (vp, size, align);\n@@ -352,7 +350,7 @@ fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span) ->\n \n     let name = (cx.sess.str_of((dcx.names)(\"tuple\"))).to_owned();\n     let mut scx = StructContext::create(cx, file_md, name, loc.line);\n-           \n+\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n@@ -368,7 +366,7 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n-    \n+\n     let mut scx = StructContext::create(cx, file_md, fmt!(\"box<%s>\", name), 0);\n     scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n                sys::min_align_of::<uint>(), refcount_type);\n@@ -391,13 +389,13 @@ fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let file_md = create_file(cx, loc.file.name);\n     let (size, align) = size_and_align_of(cx, elem_t);\n \n-    let subrange = unsafe { \n+    let subrange = unsafe {\n         llvm::LLVMDIBuilderGetOrCreateSubrange(dcx.builder, 0_i64, (len-1) as i64) };\n \n     let subscripts = create_DIArray(dcx.builder, [subrange]);\n-    return unsafe { \n-        llvm::LLVMDIBuilderCreateVectorType(dcx.builder, \n-            size * len as u64, align as u64, elem_ty_md, subscripts) \n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateVectorType(dcx.builder,\n+            size * len as u64, align as u64, elem_ty_md, subscripts)\n     };\n }\n \n@@ -407,9 +405,9 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let loc = span_start(cx, vec_ty_span);\n     let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n-    \n+\n     let mut vec_scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n-    \n+\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n     vec_scx.add_member(\"fill\", 0, sys::size_of::<libc::size_t>(),\n                sys::min_align_of::<libc::size_t>(), size_t_type);\n@@ -418,9 +416,9 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let subrange = unsafe { llvm::LLVMDIBuilderGetOrCreateSubrange(dcx.builder, 0_i64, 0_i64) };\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    \n+\n     let subscripts = create_DIArray(dcx.builder, [subrange]);\n-    let data_ptr = unsafe { llvm::LLVMDIBuilderCreateVectorType(dcx.builder, \n+    let data_ptr = unsafe { llvm::LLVMDIBuilderCreateVectorType(dcx.builder,\n                 arr_size as u64, arr_align as u64, elem_ty_md, subscripts) };\n     vec_scx.add_member(\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>(), data_ptr);\n@@ -448,7 +446,7 @@ fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n-    \n+\n     let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n     let (_, ptr_size, ptr_align) = voidptr(cx);\n     scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n@@ -467,15 +465,15 @@ fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n     let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span) };\n     let members = ~[output_ptr_md, vp] + inputs_vals;\n-    \n-    return unsafe { \n-        llvm::LLVMDIBuilderCreateSubroutineType(dcx.builder, file_md, \n-            create_DIArray(dcx.builder, members)) \n+\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(dcx.builder, file_md,\n+            create_DIArray(dcx.builder, members))\n     };\n }\n \n fn create_ty(cx: @CrateContext, t: ty::t, span: span) -> DIType {\n-    let mut dcx = dbg_cx(cx);\n+    let dcx = dbg_cx(cx);\n     let ty_id = ty::type_id(t);\n     match dcx.created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n@@ -552,7 +550,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span) -> DIType {\n         },\n         _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n     };\n-    \n+\n     dcx.created_types.insert(ty_id, ty_md);\n     return ty_md;\n }\n@@ -568,7 +566,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     };\n     let name: &str = cx.sess.str_of(ident);\n     debug!(\"create_local_var: %s\", name);\n-    \n+\n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty.span);\n@@ -577,14 +575,14 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n         None => create_function(bcx.fcx),\n         Some(_) => create_block(bcx)\n     };\n-    \n+\n     let var_md = do as_c_str(name) |name| { unsafe {\n         llvm::LLVMDIBuilderCreateLocalVariable(\n             dcx.builder, AutoVariableTag as u32,\n-            context, name, filemd, \n+            context, name, filemd,\n             loc.line as c_uint, tymd, false, 0, 0)\n         }};\n-    \n+\n     // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n     let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n         Some(v) => v,\n@@ -594,30 +592,33 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n                 fmt!(\"No entry in lllocals table for %?\", local.node.id));\n         }\n     };\n-    \n+\n     set_debug_location(bcx, loc.line, loc.col.to_uint());\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(dcx.builder, llptr, var_md, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n     }\n-    \n+\n     return var_md;\n }\n \n pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     debug!(\"create_arg\");\n-    let fcx = bcx.fcx, cx = *fcx.ccx;\n+    if true {\n+        // FIXME(5848) create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n+        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        return None;\n+    }\n+\n+    let fcx = bcx.fcx;\n+    let cx = *fcx.ccx;\n     let dcx = dbg_cx(cx);\n \n     let loc = span_start(cx, span);\n     if \"<intrinsic>\" == loc.file.name {\n         return None;\n     }\n-    // FIXME: Disabled for now because \"node_id_type(bcx, arg.id)\" below blows up:\n-    // \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n-    // (same as https://github.com/mozilla/rust/issues/5848)\n-    return None;\n-    \n+\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty.span);\n     let filemd = create_file(cx, loc.file.name);\n@@ -629,12 +630,12 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n             let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(dcx.builder, \n-                    ArgVariableTag as u32, context, name, \n+                llvm::LLVMDIBuilderCreateLocalVariable(dcx.builder,\n+                    ArgVariableTag as u32, context, name,\n                     filemd, loc.line as c_uint, tymd, false, 0, 0)\n                     // FIXME need to pass a real argument number\n             }};\n-                \n+\n             let llptr = fcx.llargs.get_copy(&arg.id);\n             unsafe {\n                 llvm::LLVMDIBuilderInsertDeclareAtEnd(dcx.builder, llptr, mdnode, bcx.llbb);\n@@ -652,21 +653,21 @@ fn set_debug_location(bcx: block, line: uint, col: uint) {\n     let elems = ~[C_i32(line as i32), C_i32(col as i32), blockmd, ptr::null()];\n     unsafe {\n         let dbg_loc = llvm::LLVMMDNode(vec::raw::to_ptr(elems), elems.len() as libc::c_uint);\n-        llvm::LLVMSetCurrentDebugLocation(trans::build::B(bcx), dbg_loc);        \n+        llvm::LLVMSetCurrentDebugLocation(trans::build::B(bcx), dbg_loc);\n     }\n }\n \n pub fn update_source_pos(bcx: block, span: span) {\n     if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n         return;\n     }\n-    \n+\n     debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n \n     let cx = bcx.ccx();\n     let loc = span_start(cx, span);\n-    let mut dcx = dbg_cx(cx);\n-    \n+    let dcx = dbg_cx(cx);\n+\n     let loc = (loc.line, loc.col.to_uint());\n     if  loc == dcx.curr_loc {\n         return;\n@@ -678,7 +679,7 @@ pub fn update_source_pos(bcx: block, span: span) {\n \n pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let cx = *fcx.ccx;\n-    let mut dcx = dbg_cx(cx);\n+    let dcx = dbg_cx(cx);\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n@@ -705,7 +706,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n       }\n       _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n-    \n+\n     match dcx.created_functions.find(&id) {\n         Some(fn_md) => return *fn_md,\n         None => ()\n@@ -725,27 +726,27 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     } else {\n         ptr::null()\n     };\n-    \n+\n     let fn_ty = unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(dcx.builder,\n             file_md, create_DIArray(dcx.builder, [ret_ty_md]))\n         };\n-    \n-    let fn_md = \n+\n+    let fn_md =\n         do as_c_str(cx.sess.str_of(ident)) |name| {\n         do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n             llvm::LLVMDIBuilderCreateFunction(\n-                dcx.builder, \n-                file_md, \n-                name, linkage, \n-                file_md, loc.line as c_uint, \n-                fn_ty, false, true, \n-                loc.line as c_uint, \n+                dcx.builder,\n+                file_md,\n+                name, linkage,\n+                file_md, loc.line as c_uint,\n+                fn_ty, false, true,\n+                loc.line as c_uint,\n                 FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No, \n+                cx.sess.opts.optimize != session::No,\n                 fcx.llfn, ptr::null(), ptr::null())\n             }}};\n-            \n+\n     dcx.created_functions.insert(id, fn_md);\n     return fn_md;\n }"}]}