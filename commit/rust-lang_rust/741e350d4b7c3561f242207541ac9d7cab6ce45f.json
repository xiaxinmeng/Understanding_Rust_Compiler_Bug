{"sha": "741e350d4b7c3561f242207541ac9d7cab6ce45f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MWUzNTBkNGI3YzM1NjFmMjQyMjA3NTQxYWM5ZDdjYWI2Y2U0NWY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-23T15:19:37Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-03T12:00:35Z"}, "message": "Add support for associated type bindings (`where Trait<Type = X>`)", "tree": {"sha": "8ab45d1f2491395eba0e6f938eddc65f15d2667d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ab45d1f2491395eba0e6f938eddc65f15d2667d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/741e350d4b7c3561f242207541ac9d7cab6ce45f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/741e350d4b7c3561f242207541ac9d7cab6ce45f", "html_url": "https://github.com/rust-lang/rust/commit/741e350d4b7c3561f242207541ac9d7cab6ce45f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/741e350d4b7c3561f242207541ac9d7cab6ce45f/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "966ab9abd2253e68d2e410a58dc1328805ee7f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/966ab9abd2253e68d2e410a58dc1328805ee7f61", "html_url": "https://github.com/rust-lang/rust/commit/966ab9abd2253e68d2e410a58dc1328805ee7f61"}], "stats": {"total": 235, "additions": 183, "deletions": 52}, "files": [{"sha": "24316fc911b2d980c1c077e79f78b124d21a0dc4", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=741e350d4b7c3561f242207541ac9d7cab6ce45f", "patch": "@@ -31,7 +31,8 @@ pub struct GenericArgs {\n     /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n     /// is left out.\n     pub has_self_type: bool,\n-    // someday also bindings\n+    /// Associated type bindings like in `Iterator<Item = T>`.\n+    pub bindings: Vec<(Name, TypeRef)>,\n }\n \n /// A single generic argument.\n@@ -170,16 +171,24 @@ impl GenericArgs {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n             args.push(GenericArg::Type(type_ref));\n         }\n-        // lifetimes and assoc type args ignored for now\n-        if !args.is_empty() {\n-            Some(GenericArgs { args, has_self_type: false })\n-        } else {\n+        // lifetimes ignored for now\n+        let mut bindings = Vec::new();\n+        for assoc_type_arg in node.assoc_type_args() {\n+            if let Some(name_ref) = assoc_type_arg.name_ref() {\n+                let name = name_ref.as_name();\n+                let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n+                bindings.push((name, type_ref));\n+            }\n+        }\n+        if args.is_empty() && bindings.is_empty() {\n             None\n+        } else {\n+            Some(GenericArgs { args, has_self_type: false, bindings })\n         }\n     }\n \n     pub(crate) fn empty() -> GenericArgs {\n-        GenericArgs { args: Vec::new(), has_self_type: false }\n+        GenericArgs { args: Vec::new(), has_self_type: false, bindings: Vec::new() }\n     }\n }\n "}, {"sha": "035491bfffe5c07de68cf3fbcddfe6d62d8aee1a", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=741e350d4b7c3561f242207541ac9d7cab6ce45f", "patch": "@@ -120,12 +120,32 @@ pub struct ProjectionTy {\n     pub parameters: Substs,\n }\n \n+impl ProjectionTy {\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.parameters.walk(f);\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.parameters.walk_mut(f);\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct UnselectedProjectionTy {\n     pub type_name: Name,\n     pub parameters: Substs,\n }\n \n+impl UnselectedProjectionTy {\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.parameters.walk(f);\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.parameters.walk_mut(f);\n+    }\n+}\n+\n /// A type.\n ///\n /// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n@@ -306,6 +326,8 @@ impl TraitRef {\n pub enum GenericPredicate {\n     /// The given trait needs to be implemented for its type parameters.\n     Implemented(TraitRef),\n+    /// An associated type bindings like in `Iterator<Item = T>`.\n+    Projection(ProjectionPredicate),\n     /// We couldn't resolve the trait reference. (If some type parameters can't\n     /// be resolved, they will just be Unknown).\n     Error,\n@@ -324,20 +346,25 @@ impl GenericPredicate {\n             GenericPredicate::Implemented(trait_ref) => {\n                 GenericPredicate::Implemented(trait_ref.subst(substs))\n             }\n+            GenericPredicate::Projection(projection_predicate) => {\n+                GenericPredicate::Projection(projection_predicate.subst(substs))\n+            }\n             GenericPredicate::Error => self,\n         }\n     }\n \n     pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n+            GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n             GenericPredicate::Error => {}\n         }\n     }\n \n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n+            GenericPredicate::Projection(projection_pred) => projection_pred.walk_mut(f),\n             GenericPredicate::Error => {}\n         }\n     }\n@@ -754,6 +781,9 @@ impl HirDisplay for Ty {\n                         GenericPredicate::Implemented(trait_ref) => {\n                             trait_ref.hir_fmt_ext(f, false)?\n                         }\n+                        GenericPredicate::Projection(_projection_pred) => {\n+                            // TODO show something\n+                        }\n                         GenericPredicate::Error => p.hir_fmt(f)?,\n                     }\n                 }\n@@ -800,6 +830,9 @@ impl HirDisplay for GenericPredicate {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Projection(projection_pred) => {\n+                // TODO print something\n+            }\n             GenericPredicate::Error => write!(f, \"{{error}}\")?,\n         }\n         Ok(())"}, {"sha": "0011c06b42a5d91101116d9f4d0b500c793949b4", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=741e350d4b7c3561f242207541ac9d7cab6ce45f", "patch": "@@ -8,7 +8,9 @@\n use std::iter;\n use std::sync::Arc;\n \n-use super::{FnSig, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor};\n+use super::{\n+    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+};\n use crate::{\n     adt::VariantDef,\n     generics::HasGenericParams,\n@@ -62,15 +64,19 @@ impl Ty {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .flat_map(|b| {\n+                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n+                    })\n                     .collect::<Vec<_>>();\n                 Ty::Dyn(predicates.into())\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .flat_map(|b| {\n+                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n+                    })\n                     .collect::<Vec<_>>();\n                 Ty::Opaque(predicates.into())\n             }\n@@ -326,15 +332,6 @@ impl TraitRef {\n         TraitRef { trait_, substs }\n     }\n \n-    pub(crate) fn from_where_predicate(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        pred: &WherePredicate,\n-    ) -> Option<TraitRef> {\n-        let self_ty = Ty::from_hir(db, resolver, &pred.type_ref);\n-        TraitRef::from_type_bound(db, resolver, &pred.bound, self_ty)\n-    }\n-\n     pub(crate) fn from_type_bound(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -349,26 +346,58 @@ impl TraitRef {\n }\n \n impl GenericPredicate {\n-    pub(crate) fn from_where_predicate(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        where_predicate: &WherePredicate,\n-    ) -> GenericPredicate {\n-        TraitRef::from_where_predicate(db, &resolver, where_predicate)\n-            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+    pub(crate) fn from_where_predicate<'a>(\n+        db: &'a impl HirDatabase,\n+        resolver: &'a Resolver,\n+        where_predicate: &'a WherePredicate,\n+    ) -> impl Iterator<Item = GenericPredicate> + 'a {\n+        let self_ty = Ty::from_hir(db, resolver, &where_predicate.type_ref);\n+        GenericPredicate::from_type_bound(db, resolver, &where_predicate.bound, self_ty)\n     }\n \n-    pub(crate) fn from_type_bound(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        bound: &TypeBound,\n+    pub(crate) fn from_type_bound<'a>(\n+        db: &'a impl HirDatabase,\n+        resolver: &'a Resolver,\n+        bound: &'a TypeBound,\n         self_ty: Ty,\n-    ) -> GenericPredicate {\n-        TraitRef::from_type_bound(db, &resolver, bound, self_ty)\n-            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+    ) -> impl Iterator<Item = GenericPredicate> + 'a {\n+        let trait_ref = TraitRef::from_type_bound(db, &resolver, bound, self_ty);\n+        iter::once(trait_ref.clone().map_or(GenericPredicate::Error, GenericPredicate::Implemented))\n+            .chain(\n+                trait_ref.into_iter().flat_map(move |tr| {\n+                    assoc_type_bindings_from_type_bound(db, resolver, bound, tr)\n+                }),\n+            )\n     }\n }\n \n+fn assoc_type_bindings_from_type_bound<'a>(\n+    db: &'a impl HirDatabase,\n+    resolver: &'a Resolver,\n+    bound: &'a TypeBound,\n+    trait_ref: TraitRef,\n+) -> impl Iterator<Item = GenericPredicate> + 'a {\n+    let last_segment = match bound {\n+        TypeBound::Path(path) => path.segments.last(),\n+        TypeBound::Error => None,\n+    };\n+    last_segment\n+        .into_iter()\n+        .flat_map(|segment| segment.args_and_bindings.iter())\n+        .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n+        .map(move |(name, type_ref)| {\n+            let associated_ty = match trait_ref.trait_.associated_type_by_name(db, name.clone()) {\n+                None => return GenericPredicate::Error,\n+                Some(t) => t,\n+            };\n+            let projection_ty =\n+                ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n+            let ty = Ty::from_hir(db, resolver, type_ref);\n+            let projection_predicate = ProjectionPredicate { projection_ty, ty };\n+            GenericPredicate::Projection(projection_predicate)\n+        })\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n@@ -425,7 +454,7 @@ pub(crate) fn trait_env(\n ) -> Arc<super::TraitEnvironment> {\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n \n     Arc::new(super::TraitEnvironment { predicates })\n@@ -439,7 +468,7 @@ pub(crate) fn generic_predicates_query(\n     let resolver = def.resolver(db);\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n     predicates.into()\n }"}, {"sha": "3e743ef58216977536743e51c819d95f8c6ed536", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=741e350d4b7c3561f242207541ac9d7cab6ce45f", "patch": "@@ -3586,37 +3586,63 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [166; 169) '{t}': T\n     [167; 168) 't': T\n     [257; 258) 'x': T\n-    [263; 264) 'y': impl Trait\n+    [263; 264) 'y': impl Trait + \n     [290; 398) '{     ...r>); }': ()\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n     [296; 302) 'get(x)': {unknown}\n     [300; 301) 'x': T\n-    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> U\n+    [308; 312) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n     [308; 315) 'get2(x)': {unknown}\n     [313; 314) 'x': T\n-    [321; 324) 'get': fn get<impl Trait>(T) -> <T as Trait>::Type\n+    [321; 324) 'get': fn get<impl Trait + >(T) -> <T as Trait>::Type\n     [321; 327) 'get(y)': {unknown}\n-    [325; 326) 'y': impl Trait\n-    [333; 337) 'get2': fn get2<{unknown}, impl Trait>(T) -> U\n+    [325; 326) 'y': impl Trait + \n+    [333; 337) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n     [333; 340) 'get2(y)': {unknown}\n-    [338; 339) 'y': impl Trait\n-    [346; 349) 'get': fn get<S<{unknown}>>(T) -> <T as Trait>::Type\n-    [346; 357) 'get(set(S))': {unknown}\n-    [350; 353) 'set': fn set<S<{unknown}>>(T) -> T\n-    [350; 356) 'set(S)': S<{unknown}>\n-    [354; 355) 'S': S<{unknown}>\n-    [363; 367) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n-    [363; 375) 'get2(set(S))': {unknown}\n-    [368; 371) 'set': fn set<S<{unknown}>>(T) -> T\n-    [368; 374) 'set(S)': S<{unknown}>\n-    [372; 373) 'S': S<{unknown}>\n-    [381; 385) 'get2': fn get2<{unknown}, S<str>>(T) -> U\n-    [381; 395) 'get2(S::<str>)': {unknown}\n+    [338; 339) 'y': impl Trait + \n+    [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n+    [346; 357) 'get(set(S))': u64\n+    [350; 353) 'set': fn set<S<u64>>(T) -> T\n+    [350; 356) 'set(S)': S<u64>\n+    [354; 355) 'S': S<u64>\n+    [363; 367) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [363; 375) 'get2(set(S))': u64\n+    [368; 371) 'set': fn set<S<u64>>(T) -> T\n+    [368; 374) 'set(S)': S<u64>\n+    [372; 373) 'S': S<u64>\n+    [381; 385) 'get2': fn get2<str, S<str>>(T) -> U\n+    [381; 395) 'get2(S::<str>)': str\n     [386; 394) 'S::<str>': S<str>\n     \"###\n     );\n }\n \n+#[test]\n+fn projection_eq_within_chalk() {\n+    // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait1 {\n+    type Type;\n+}\n+trait Trait2<T> {\n+    fn foo(self) -> T;\n+}\n+impl<T, U> Trait2<T> for U where U: Trait1<Type = T> {}\n+\n+fn test<T: Trait1<Type = u32>>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [62; 66) 'self': Self\n+    [164; 165) 'x': T\n+    [170; 186) '{     ...o(); }': ()\n+    [176; 177) 'x': T\n+    [176; 183) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "25316bc020591ec5be131d56b5302b10b08695d8", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=741e350d4b7c3561f242207541ac9d7cab6ce45f", "patch": "@@ -124,6 +124,9 @@ impl Obligation {\n     pub fn from_predicate(predicate: GenericPredicate) -> Option<Obligation> {\n         match predicate {\n             GenericPredicate::Implemented(trait_ref) => Some(Obligation::Trait(trait_ref)),\n+            GenericPredicate::Projection(projection_pred) => {\n+                Some(Obligation::Projection(projection_pred))\n+            }\n             GenericPredicate::Error => None,\n         }\n     }\n@@ -135,6 +138,30 @@ pub struct ProjectionPredicate {\n     pub ty: Ty,\n }\n \n+impl ProjectionPredicate {\n+    pub fn subst(mut self, substs: &super::Substs) -> ProjectionPredicate {\n+        self.walk_mut(&mut |ty| match ty {\n+            Ty::Param { idx, .. } => {\n+                if let Some(t) = substs.get(*idx as usize).cloned() {\n+                    *ty = t;\n+                }\n+            }\n+            _ => {}\n+        });\n+        self\n+    }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.projection_ty.walk(f);\n+        self.ty.walk(f);\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.projection_ty.walk_mut(f);\n+        self.ty.walk_mut(f);\n+    }\n+}\n+\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &impl HirDatabase,"}, {"sha": "3ab5b7cca9dde12147a08e374ba69a48ffa9afc0", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e350d4b7c3561f242207541ac9d7cab6ce45f/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=741e350d4b7c3561f242207541ac9d7cab6ce45f", "patch": "@@ -211,6 +211,13 @@ impl ToChalk for GenericPredicate {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n             }\n+            GenericPredicate::Projection(projection_pred) => make_binders(\n+                chalk_ir::WhereClause::ProjectionEq(chalk_ir::ProjectionEq {\n+                    projection: projection_pred.projection_ty.to_chalk(db),\n+                    ty: projection_pred.ty.to_chalk(db),\n+                }),\n+                0,\n+            ),\n             GenericPredicate::Error => {\n                 let impossible_trait_ref = chalk_ir::TraitRef {\n                     trait_id: UNKNOWN_TRAIT,"}]}