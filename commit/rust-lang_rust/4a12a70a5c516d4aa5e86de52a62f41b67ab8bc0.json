{"sha": "4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMTJhNzBhNWM1MTZkNGFhNWU4NmRlNTJhNjJmNDFiNjdhYjhiYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-13T14:27:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-13T14:27:43Z"}, "message": "Auto merge of #34752 - ollie27:rustdoc_search, r=GuillaumeGomez\n\nrustdoc: Fix methods in seach results\n\nCurrently methods from extern crates are sometimes added to the search\nindex when they shouldn't be or added with the original path rather than\nthe reexported path. This fixes that by making sure `cache().paths` only\ncontains local paths like the description for it states. It also fixes a\nfew minor issues with link rendering and redirect generation which would\npoint to local crate docs even if the docs for that crate hadn't been\ngenerated.\n\nAlso a bug with methods implemented on traits which caused wrong paths and\nso dead links in the search results has been fixed.\n\nFor example:\n[before](https://doc.rust-lang.org/nightly/std/?search=is_disjoint) [after](https://ollie27.github.io/rust_doc_test/std/?search=is_disjoint)\n[before](https://doc.rust-lang.org/nightly/std/?search=map_or) [after](https://ollie27.github.io/rust_doc_test/std/?search=map_or)\n[before](https://doc.rust-lang.org/nightly/std/?search=unsafecell%3A%3Anew) [after](https://ollie27.github.io/rust_doc_test/std/?search=unsafecell%3A%3Anew)\n[before](https://doc.rust-lang.org/nightly/std/?search=rng%3A%3Agen_) [after](https://ollie27.github.io/rust_doc_test/std/?search=rng%3A%3Agen_)\n[before](https://doc.rust-lang.org/nightly/std/?search=downcast_ref) [after](https://ollie27.github.io/rust_doc_test/std/?search=downcast_ref)\n\nFixes #20246", "tree": {"sha": "2b5914b3e836bc308ca106056ccec3ae0fb9fb86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b5914b3e836bc308ca106056ccec3ae0fb9fb86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "html_url": "https://github.com/rust-lang/rust/commit/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "362b665bb2d1523d2522b38083b806e1d02c46fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/362b665bb2d1523d2522b38083b806e1d02c46fc", "html_url": "https://github.com/rust-lang/rust/commit/362b665bb2d1523d2522b38083b806e1d02c46fc"}, {"sha": "b905464668a5dbd51ea91c2766d5e764868ebf3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b905464668a5dbd51ea91c2766d5e764868ebf3e", "html_url": "https://github.com/rust-lang/rust/commit/b905464668a5dbd51ea91c2766d5e764868ebf3e"}], "stats": {"total": 126, "additions": 80, "deletions": 46}, "files": [{"sha": "eed2615175b27a62ce77ce4debd5a2de1aff430e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "patch": "@@ -19,7 +19,7 @@ use std::fmt;\n use std::iter::repeat;\n \n use rustc::middle::cstore::LOCAL_CRATE;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::DefId;\n use syntax::abi::Abi;\n use rustc::hir;\n \n@@ -301,18 +301,19 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n     }\n \n     let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n-    let &(ref fqp, shortty) = match cache.paths.get(&did) {\n-        Some(p) => p,\n-        None => return None,\n-    };\n-\n-    let mut url = if did.is_local() || cache.inlined.contains(&did) {\n-        repeat(\"../\").take(loc.len()).collect::<String>()\n-    } else {\n-        match cache.extern_locations[&did.krate] {\n-            (_, render::Remote(ref s)) => s.to_string(),\n-            (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n-            (_, render::Unknown) => return None,\n+    let (fqp, shortty, mut url) = match cache.paths.get(&did) {\n+        Some(&(ref fqp, shortty)) => {\n+            (fqp, shortty, repeat(\"../\").take(loc.len()).collect())\n+        }\n+        None => match cache.external_paths.get(&did) {\n+            Some(&(ref fqp, shortty)) => {\n+                (fqp, shortty, match cache.extern_locations[&did.krate] {\n+                    (_, render::Remote(ref s)) => s.to_string(),\n+                    (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+                    (_, render::Unknown) => return None,\n+                })\n+            }\n+            None => return None,\n         }\n     };\n     for component in &fqp[..fqp.len() - 1] {\n@@ -387,22 +388,18 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = &m.paths[&DefId {\n-                krate: cnum,\n-                index: CRATE_DEF_INDEX,\n-            }];\n             let loc = match m.extern_locations[&cnum] {\n-                (_, render::Remote(ref s)) => Some(s.to_string()),\n-                (_, render::Local) => {\n+                (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n+                (ref cname, render::Local) => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-                    Some(repeat(\"../\").take(len).collect::<String>())\n+                    Some((cname, repeat(\"../\").take(len).collect::<String>()))\n                 }\n                 (_, render::Unknown) => None,\n             };\n-            if let Some(root) = loc {\n+            if let Some((cname, root)) = loc {\n                 write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n                        root,\n-                       path.0.first().unwrap(),\n+                       cname,\n                        prim.to_url_str())?;\n                 needs_termination = true;\n             }"}, {"sha": "2e2fc011ddbe6c3198c0ac3dafb6e144e471769f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "patch": "@@ -230,7 +230,7 @@ pub struct Cache {\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: HashMap<DefId, Vec<String>>,\n+    pub external_paths: HashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -249,9 +249,6 @@ pub struct Cache {\n     /// Cache of where documentation for primitives can be found.\n     pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n \n-    /// Set of definitions which have been inlined from external crates.\n-    pub inlined: HashSet<DefId>,\n-\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n@@ -505,20 +502,20 @@ pub fn run(mut krate: clean::Crate,\n \n     // Crawl the crate to build various caches used for the output\n     let RenderInfo {\n-        inlined,\n+        inlined: _,\n         external_paths,\n         external_typarams,\n         deref_trait_did,\n     } = renderinfo;\n \n-    let paths = external_paths.into_iter()\n-                              .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n-                              .collect::<HashMap<_, _>>();\n+    let external_paths = external_paths.into_iter()\n+        .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n+        .collect();\n \n     let mut cache = Cache {\n         impls: HashMap::new(),\n-        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone())).collect(),\n-        paths: paths,\n+        external_paths: external_paths,\n+        paths: HashMap::new(),\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n@@ -534,15 +531,14 @@ pub fn run(mut krate: clean::Crate,\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n         deref_trait_did: deref_trait_did,\n         typarams: external_typarams,\n-        inlined: inlined,\n     };\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, (e.name.clone(),\n                                           extern_location(e, &cx.dst)));\n         let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-        cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n     // Cache where all known primitives have their documentation located.\n@@ -753,7 +749,10 @@ fn write_shared(cx: &Context,\n         //        theory it should be...\n         let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n-            None => continue,\n+            None => match cache.external_paths.get(&did) {\n+                Some(p) => p,\n+                None => continue,\n+            }\n         };\n \n         let mut mydst = dst.clone();\n@@ -1055,12 +1054,11 @@ impl DocFolder for Cache {\n                         let last = self.parent_stack.last().unwrap();\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n-                            Some(&(_, ItemType::Trait)) =>\n-                                Some(&self.stack[..self.stack.len() - 1]),\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n                             // information if present.\n+                            Some(&(ref fqp, ItemType::Trait)) |\n                             Some(&(ref fqp, ItemType::Struct)) |\n                             Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(&fqp[..fqp.len() - 1]),\n@@ -1092,12 +1090,10 @@ impl DocFolder for Cache {\n                         });\n                     }\n                 }\n-                (Some(parent), None) if is_method || (!self.stripped_mod)=> {\n-                    if parent.is_local() {\n-                        // We have a parent, but we don't know where they're\n-                        // defined yet. Wait for later to index this item.\n-                        self.orphan_methods.push((parent, item.clone()))\n-                    }\n+                (Some(parent), None) if is_method => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_methods.push((parent, item.clone()));\n                 }\n                 _ => {}\n             }\n@@ -1127,7 +1123,6 @@ impl DocFolder for Cache {\n                 // not a public item.\n                 if\n                     !self.paths.contains_key(&item.def_id) ||\n-                    !item.def_id.is_local() ||\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n@@ -1521,7 +1516,7 @@ impl<'a> Item<'a> {\n         } else {\n             let cache = cache();\n             let external_path = match cache.external_paths.get(&self.item.def_id) {\n-                Some(path) => path,\n+                Some(&(ref path, _)) => path,\n                 None => return None,\n             };\n             let mut path = match cache.extern_locations.get(&self.item.def_id.krate) {\n@@ -2106,7 +2101,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            path = if it.def_id.is_local() {\n                cx.current.join(\"/\")\n            } else {\n-               let path = &cache.external_paths[&it.def_id];\n+               let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n            ty = shortty(it).to_static_str(),"}, {"sha": "94b7278e9904b2bfba32c4f0039d7c85ef632151", "filename": "src/test/rustdoc/auxiliary/extern-links.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Ftest%2Frustdoc%2Fauxiliary%2Fextern-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Ftest%2Frustdoc%2Fauxiliary%2Fextern-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fextern-links.rs?ref=4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo;"}, {"sha": "c35a5668dced7d770d3b6b32ea03b79360101869", "filename": "src/test/rustdoc/extern-links.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Ftest%2Frustdoc%2Fextern-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0/src%2Ftest%2Frustdoc%2Fextern-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-links.rs?ref=4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:extern-links.rs\n+// ignore-cross-compile\n+\n+#![crate_name = \"foo\"]\n+\n+extern crate extern_links;\n+\n+// @!has foo/index.html '//a' 'extern_links'\n+#[doc(no_inline)]\n+pub use extern_links as extern_links2;\n+\n+// @!has foo/index.html '//a' 'Foo'\n+#[doc(no_inline)]\n+pub use extern_links::Foo;\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    // @!has foo/hidden/extern_links/index.html\n+    // @!has foo/hidden/extern_links/struct.Foo.html\n+    pub use extern_links;\n+}"}]}