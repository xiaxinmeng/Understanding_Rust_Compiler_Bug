{"sha": "5cccda1770f76b8184ea55e4735ce88f824f7fd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjY2NkYTE3NzBmNzZiODE4NGVhNTVlNDczNWNlODhmODI0ZjdmZDg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-11T15:43:27Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-10T17:41:10Z"}, "message": "Remove hir::ExprKind::If and replace it with lowering to hir::ExprKind::Match.", "tree": {"sha": "8f40dad8b22d19fcc2e80657f40a1e5161c1d72b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f40dad8b22d19fcc2e80657f40a1e5161c1d72b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cccda1770f76b8184ea55e4735ce88f824f7fd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cccda1770f76b8184ea55e4735ce88f824f7fd8", "html_url": "https://github.com/rust-lang/rust/commit/5cccda1770f76b8184ea55e4735ce88f824f7fd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cccda1770f76b8184ea55e4735ce88f824f7fd8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ac53da03dad79655e2f3e65a58f94a2f3314d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac53da03dad79655e2f3e65a58f94a2f3314d5f", "html_url": "https://github.com/rust-lang/rust/commit/0ac53da03dad79655e2f3e65a58f94a2f3314d5f"}], "stats": {"total": 1071, "additions": 436, "deletions": 635}, "files": [{"sha": "2e54165be1f1baf485b42ac331c8922ae7694b2e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -166,47 +166,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n-            hir::ExprKind::If(ref cond, ref then, None) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //     [cond]\n-                //       |\n-                //      / \\\n-                //     /   \\\n-                //    v 2   *\n-                //  [then]  |\n-                //    |     |\n-                //    v 3   v 4\n-                //   [..expr..]\n-                //\n-                let cond_exit = self.expr(&cond, pred);                // 1\n-                let then_exit = self.expr(&then, cond_exit);          // 2\n-                self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n-            }\n-\n-            hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //     [cond]\n-                //       |\n-                //      / \\\n-                //     /   \\\n-                //    v 2   v 3\n-                //  [then][otherwise]\n-                //    |     |\n-                //    v 4   v 5\n-                //   [..expr..]\n-                //\n-                let cond_exit = self.expr(&cond, pred);                // 1\n-                let then_exit = self.expr(&then, cond_exit);          // 2\n-                let else_exit = self.expr(&otherwise, cond_exit);      // 3\n-                self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n-            }\n-\n             hir::ExprKind::While(ref cond, ref body, _) => {\n                 //\n                 //         [pred]"}, {"sha": "38d6d710868c08919821de9caf2b34a05cb2a761", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -1032,11 +1032,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n-            visitor.visit_expr(head_expression);\n-            visitor.visit_expr(if_block);\n-            walk_list!(visitor, visit_expr, optional_else);\n-        }\n         ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);"}, {"sha": "7ccfb826e37b793676c2fed1aedbbd2ea2aa5de9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -62,6 +62,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -4115,31 +4116,46 @@ impl<'a> LoweringContext<'a> {\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n-            ExprKind::If(ref cond, ref blk, ref else_opt) => {\n-                let else_opt = else_opt.as_ref().map(|els| {\n-                    match els.node {\n+            ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                // `true => then`:\n+                let then_pat = self.pat_bool(e.span, true);\n+                let then_blk = self.lower_block(then, false);\n+                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+                let then_arm = self.arm(hir_vec![then_pat], P(then_expr));\n+\n+                // `_ => else_block` where `else_block` is `{}` if there's `None`:\n+                let else_pat = self.pat_wild(e.span);\n+                let else_expr = match else_opt {\n+                    None => self.expr_block_empty(e.span),\n+                    Some(els) => match els.node {\n                         ExprKind::IfLet(..) => {\n                             // Wrap the `if let` expr in a block.\n-                            let span = els.span;\n-                            let els = P(self.lower_expr(els));\n-                            let blk = P(hir::Block {\n-                                stmts: hir_vec![],\n-                                expr: Some(els),\n-                                hir_id: self.next_id(),\n-                                rules: hir::DefaultBlock,\n-                                span,\n-                                targeted_by_break: false,\n-                            });\n-                            P(self.expr_block(blk, ThinVec::new()))\n+                            let els = self.lower_expr(els);\n+                            let blk = self.block_all(els.span, hir_vec![], Some(P(els)));\n+                            self.expr_block(P(blk), ThinVec::new())\n                         }\n-                        _ => P(self.lower_expr(els)),\n+                        _ => self.lower_expr(els),\n                     }\n-                });\n-\n-                let then_blk = self.lower_block(blk, false);\n-                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+                };\n+                let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n+\n+                // Lower condition:\n+                let span_block = self\n+                    .sess\n+                    .source_map()\n+                    .mark_span_with_reason(IfTemporary, cond.span, None);\n+                let cond = self.lower_expr(cond);\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }` to preserve drop\n+                // semantics since `if cond { ... }` don't let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n \n-                hir::ExprKind::If(P(self.lower_expr(cond)), P(then_expr), else_opt)\n+                hir::ExprKind::Match(\n+                    P(cond),\n+                    vec![then_arm, else_arm].into(),\n+                    hir::MatchSource::IfDesugar {\n+                        contains_else_clause: else_opt.is_some()\n+                    },\n+                )\n             }\n             ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n                 hir::ExprKind::While(\n@@ -4486,16 +4502,16 @@ impl<'a> LoweringContext<'a> {\n                     arms.push(self.arm(pats, body_expr));\n                 }\n \n-                // _ => [<else_opt>|()]\n+                // _ => [<else_opt>|{}]\n                 {\n                     let wildcard_arm: Option<&Expr> = else_opt.as_ref().map(|p| &**p);\n                     let wildcard_pattern = self.pat_wild(e.span);\n                     let body = if let Some(else_expr) = wildcard_arm {\n-                        P(self.lower_expr(else_expr))\n+                        self.lower_expr(else_expr)\n                     } else {\n-                        P(self.expr_tuple(e.span, hir_vec![]))\n+                        self.expr_block_empty(e.span)\n                     };\n-                    arms.push(self.arm(hir_vec![wildcard_pattern], body));\n+                    arms.push(self.arm(hir_vec![wildcard_pattern], P(body)));\n                 }\n \n                 let contains_else_clause = else_opt.is_some();\n@@ -4658,11 +4674,7 @@ impl<'a> LoweringContext<'a> {\n                         ThinVec::new(),\n                     ))\n                 };\n-                let match_stmt = hir::Stmt {\n-                    hir_id: self.next_id(),\n-                    node: hir::StmtKind::Expr(match_expr),\n-                    span: head_sp,\n-                };\n+                let match_stmt = self.stmt(head_sp, hir::StmtKind::Expr(match_expr));\n \n                 let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n \n@@ -4685,11 +4697,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = hir::Stmt {\n-                    hir_id: self.next_id(),\n-                    node: hir::StmtKind::Expr(body_expr),\n-                    span: body.span,\n-                };\n+                let body_stmt = self.stmt(body.span, hir::StmtKind::Expr(body_expr));\n \n                 let loop_block = P(self.block_all(\n                     e.span,\n@@ -4869,12 +4877,7 @@ impl<'a> LoweringContext<'a> {\n                     .into_iter()\n                     .map(|item_id| {\n                         let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n-\n-                        hir::Stmt {\n-                            hir_id: self.next_id(),\n-                            node: hir::StmtKind::Item(item_id),\n-                            span: s.span,\n-                        }\n+                        self.stmt(s.span, hir::StmtKind::Item(item_id))\n                     })\n                     .collect();\n                 ids.push({\n@@ -5174,28 +5177,32 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn stmt(&mut self, span: Span, node: hir::StmtKind) -> hir::Stmt {\n+        hir::Stmt { span, node, hir_id: self.next_id() }\n+    }\n+\n     fn stmt_let_pat(\n         &mut self,\n-        sp: Span,\n-        ex: Option<P<hir::Expr>>,\n+        span: Span,\n+        init: Option<P<hir::Expr>>,\n         pat: P<hir::Pat>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt {\n         let local = hir::Local {\n             pat,\n             ty: None,\n-            init: ex,\n+            init,\n             hir_id: self.next_id(),\n-            span: sp,\n-            attrs: ThinVec::new(),\n+            span,\n             source,\n+            attrs: ThinVec::new()\n         };\n+        self.stmt(span, hir::StmtKind::Local(P(local)))\n+    }\n \n-        hir::Stmt {\n-            hir_id: self.next_id(),\n-            node: hir::StmtKind::Local(P(local)),\n-            span: sp\n-        }\n+    fn expr_block_empty(&mut self, span: Span) -> hir::Expr {\n+        let blk = self.block_all(span, hir_vec![], None);\n+        self.expr_block(P(blk), ThinVec::new())\n     }\n \n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n@@ -5235,6 +5242,13 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n+    /// Constructs a `true` or `false` literal pattern.\n+    fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat> {\n+        let lit = Spanned { span, node: LitKind::Bool(val) };\n+        let expr = self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new());\n+        self.pat(span, hir::PatKind::Lit(P(expr)))\n+    }\n+\n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n         self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n     }\n@@ -5622,15 +5636,7 @@ impl<'a> LoweringContext<'a> {\n                 &[\"task\", \"Poll\", \"Pending\"],\n                 hir_vec![],\n             );\n-            let empty_block = P(hir::Block {\n-                stmts: hir_vec![],\n-                expr: None,\n-                hir_id: self.next_id(),\n-                rules: hir::DefaultBlock,\n-                span,\n-                targeted_by_break: false,\n-            });\n-            let empty_block = P(self.expr_block(empty_block, ThinVec::new()));\n+            let empty_block = P(self.expr_block_empty(span));\n             self.arm(hir_vec![pending_pat], empty_block)\n         };\n "}, {"sha": "9f7fa6c5557ef80436e18f6996fa7068e114b16f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -1368,7 +1368,6 @@ impl Expr {\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::DropTemps(ref expr, ..) => expr.precedence(),\n-            ExprKind::If(..) => ExprPrecedence::If,\n             ExprKind::While(..) => ExprPrecedence::While,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n             ExprKind::Match(..) => ExprPrecedence::Match,\n@@ -1421,7 +1420,6 @@ impl Expr {\n             ExprKind::MethodCall(..) |\n             ExprKind::Struct(..) |\n             ExprKind::Tup(..) |\n-            ExprKind::If(..) |\n             ExprKind::Match(..) |\n             ExprKind::Closure(..) |\n             ExprKind::Block(..) |\n@@ -1498,10 +1496,6 @@ pub enum ExprKind {\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n     DropTemps(P<Expr>),\n-    /// An `if` block, with an optional else block.\n-    ///\n-    /// I.e., `if <expr> { <expr> } else { <expr> }`.\n-    If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// I.e., `'label: while expr { <block> }`.\n@@ -1615,6 +1609,10 @@ pub enum LocalSource {\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n+    /// An `if _ { .. }` (optionally with `else { .. }`).\n+    IfDesugar {\n+        contains_else_clause: bool,\n+    },\n     /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n     IfLetDesugar {\n         contains_else_clause: bool,"}, {"sha": "c42d8f3cb3c36275f99845a3b9d4dccd1494ea30", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -1093,65 +1093,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n-    fn print_else(&mut self, els: Option<&hir::Expr>) -> io::Result<()> {\n-        match els {\n-            Some(_else) => {\n-                match _else.node {\n-                    // \"another else-if\"\n-                    hir::ExprKind::If(ref i, ref then, ref e) => {\n-                        self.cbox(indent_unit - 1)?;\n-                        self.ibox(0)?;\n-                        self.s.word(\" else if \")?;\n-                        self.print_expr_as_cond(&i)?;\n-                        self.s.space()?;\n-                        self.print_expr(&then)?;\n-                        self.print_else(e.as_ref().map(|e| &**e))\n-                    }\n-                    // \"final else\"\n-                    hir::ExprKind::Block(ref b, _) => {\n-                        self.cbox(indent_unit - 1)?;\n-                        self.ibox(0)?;\n-                        self.s.word(\" else \")?;\n-                        self.print_block(&b)\n-                    }\n-                    // BLEAH, constraints would be great here\n-                    _ => {\n-                        panic!(\"print_if saw if with weird alternative\");\n-                    }\n-                }\n-            }\n-            _ => Ok(()),\n-        }\n-    }\n-\n-    pub fn print_if(&mut self,\n-                    test: &hir::Expr,\n-                    blk: &hir::Expr,\n-                    elseopt: Option<&hir::Expr>)\n-                    -> io::Result<()> {\n-        self.head(\"if\")?;\n-        self.print_expr_as_cond(test)?;\n-        self.s.space()?;\n-        self.print_expr(blk)?;\n-        self.print_else(elseopt)\n-    }\n-\n-    pub fn print_if_let(&mut self,\n-                        pat: &hir::Pat,\n-                        expr: &hir::Expr,\n-                        blk: &hir::Block,\n-                        elseopt: Option<&hir::Expr>)\n-                        -> io::Result<()> {\n-        self.head(\"if let\")?;\n-        self.print_pat(pat)?;\n-        self.s.space()?;\n-        self.word_space(\"=\")?;\n-        self.print_expr_as_cond(expr)?;\n-        self.s.space()?;\n-        self.print_block(blk)?;\n-        self.print_else(elseopt)\n-    }\n-\n     pub fn print_anon_const(&mut self, constant: &hir::AnonConst) -> io::Result<()> {\n         self.ann.nested(self, Nested::Body(constant.body))\n     }\n@@ -1406,9 +1347,6 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, indent_unit, true)?;\n             }\n-            hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n-            }\n             hir::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n@@ -2414,7 +2352,6 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n-        hir::ExprKind::If(..) |\n         hir::ExprKind::Match(..) |\n         hir::ExprKind::Block(..) |\n         hir::ExprKind::While(..) |"}, {"sha": "35df43ef25efa4720ac28ea6e0ca7919d7a49a70", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -395,6 +395,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+    IfTemporary,\n     Async,\n     Await,\n     QuestionMark,"}, {"sha": "d46bba92f3fc90947c66d07b91fdfddcc2952dca", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -424,14 +424,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprKind::If(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n-                self.consume_expr(&cond_expr);\n-                self.walk_expr(&then_expr);\n-                if let Some(ref else_expr) = *opt_else_expr {\n-                    self.consume_expr(&else_expr);\n-                }\n-            }\n-\n             hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n                 let r = self.tcx().lifetimes.re_empty;"}, {"sha": "a142b220f31afcb9d885f62dc4557bf061b940bd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -500,7 +500,6 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      hir::ExprKind::If(..) |\n       hir::ExprKind::Match(..) |\n       hir::ExprKind::While(..) |\n       hir::ExprKind::Loop(..) => {\n@@ -1040,28 +1039,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            hir::ExprKind::If(ref cond, ref then, ref els) => {\n-                //\n-                //     (cond)\n-                //       |\n-                //       v\n-                //     (expr)\n-                //     /   \\\n-                //    |     |\n-                //    v     v\n-                //  (then)(els)\n-                //    |     |\n-                //    v     v\n-                //   (  succ  )\n-                //\n-                let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n-                let then_ln = self.propagate_through_expr(&then, succ);\n-                let ln = self.live_node(expr.hir_id, expr.span);\n-                self.init_from_succ(ln, else_ln);\n-                self.merge_from_succ(ln, then_ln, false);\n-                self.propagate_through_expr(&cond, ln)\n-            }\n-\n             hir::ExprKind::While(ref cond, ref blk, _) => {\n                 self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n             }\n@@ -1523,7 +1500,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         }\n \n         // no correctness conditions related to liveness\n-        hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) | hir::ExprKind::If(..) |\n+        hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) |\n         hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n         hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n         hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |"}, {"sha": "85c7f4379033625c2f1264bf714de62deca7be2c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -678,7 +678,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n             hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n             hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) |\n-            hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n+            hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) |\n             hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n             hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n             hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |"}, {"sha": "8ef4e9ac8f45faeb357b0a56aa5b172e84967c55", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -884,17 +884,6 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                     terminating(r.hir_id.local_id);\n             }\n \n-            hir::ExprKind::If(ref expr, ref then, Some(ref otherwise)) => {\n-                terminating(expr.hir_id.local_id);\n-                terminating(then.hir_id.local_id);\n-                terminating(otherwise.hir_id.local_id);\n-            }\n-\n-            hir::ExprKind::If(ref expr, ref then, None) => {\n-                terminating(expr.hir_id.local_id);\n-                terminating(then.hir_id.local_id);\n-            }\n-\n             hir::ExprKind::Loop(ref body, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }"}, {"sha": "31f697a724a0357385bfb81487c7684c32f84041", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -100,6 +100,18 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.cancel();\n     }\n \n+    /// Emit the diagnostic unless `delay` is true,\n+    /// in which case the emission will be delayed as a bug.\n+    ///\n+    /// See `emit` and `delay_as_bug` for details.\n+    pub fn emit_unless(&mut self, delay: bool) {\n+        if delay {\n+            self.delay_as_bug()\n+        } else {\n+            self.emit()\n+        }\n+    }\n+\n     /// Buffers the diagnostic for later emission, unless handler\n     /// has disabled such buffering.\n     pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {"}, {"sha": "5f444d4ceeb8895fe40bae33b69969bad3ac3942", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -192,7 +192,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n             | ExprKind::Borrow { .. }\n-            | ExprKind::If { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "fbc4835a6557b4e2a7b34f744286a8c2c424fd72", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -345,7 +345,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Literal { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }\n-            | ExprKind::If { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n             | ExprKind::Loop { .. }"}, {"sha": "222ce6d1c968eaaf716c5bc2b3543a8539b76f9d", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -45,7 +45,6 @@ impl Category {\n             | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),\n \n             ExprKind::LogicalOp { .. }\n-            | ExprKind::If { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }"}, {"sha": "15795a64e3b7dcea2703280b12c3fc6024ff40dc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -76,43 +76,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     end_block.unit()\n                 }\n             }\n-            ExprKind::If {\n-                condition: cond_expr,\n-                then: then_expr,\n-                otherwise: else_expr,\n-            } => {\n-                let operand = unpack!(block = this.as_local_operand(block, cond_expr));\n-\n-                let mut then_block = this.cfg.start_new_block();\n-                let mut else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n-                this.cfg.terminate(block, source_info, term);\n-\n-                unpack!(then_block = this.into(destination, then_block, then_expr));\n-                else_block = if let Some(else_expr) = else_expr {\n-                    unpack!(this.into(destination, else_block, else_expr))\n-                } else {\n-                    // Body of the `if` expression without an `else` clause must return `()`, thus\n-                    // we implicitly generate a `else {}` if it is not specified.\n-                    this.cfg\n-                        .push_assign_unit(else_block, source_info, destination);\n-                    else_block\n-                };\n-\n-                let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(\n-                    then_block,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-                this.cfg.terminate(\n-                    else_block,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-\n-                join_block.unit()\n-            }\n             ExprKind::LogicalOp { op, lhs, rhs } => {\n                 // And:\n                 //"}, {"sha": "50140880a368df329bdbf08b35f3cb833cffb9a4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -601,13 +601,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }\n-        hir::ExprKind::If(ref cond, ref then, ref otherwise) => {\n-            ExprKind::If {\n-                condition: cond.to_ref(),\n-                then: then.to_ref(),\n-                otherwise: otherwise.to_ref(),\n-            }\n-        }\n         hir::ExprKind::While(ref cond, ref body, _) => {\n             ExprKind::Loop {\n                 condition: Some(cond.to_ref()),"}, {"sha": "d4f139e103a641a12d665f0e8cf05ec2e96f0255", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -185,11 +185,6 @@ pub enum ExprKind<'tcx> {\n         cast: PointerCast,\n         source: ExprRef<'tcx>,\n     },\n-    If {\n-        condition: ExprRef<'tcx>,\n-        then: ExprRef<'tcx>,\n-        otherwise: Option<ExprRef<'tcx>>,\n-    },\n     Loop {\n         condition: Option<ExprRef<'tcx>>,\n         body: ExprRef<'tcx>,"}, {"sha": "b58f8dd49242454a0b61ce338c821b6ef2b958fc", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -365,6 +365,7 @@ fn check_arms<'a, 'tcx>(\n             match is_useful(cx, &seen, &v, LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n+                        hir::MatchSource::IfDesugar { .. } => bug!(),\n                         hir::MatchSource::IfLetDesugar { .. } => {\n                             cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,"}, {"sha": "2d35a0de7953f4193a0cf1c86c4aa016a82381ba", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -518,15 +518,6 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n \n-        hir::ExprKind::If(ref lhs, ref rhs, ref option_expr) => {\n-            let _ = v.check_expr(lhs);\n-            let _ = v.check_expr(rhs);\n-            if let Some(ref expr) = option_expr {\n-                let _ = v.check_expr(&expr);\n-            }\n-            NotPromotable\n-        }\n-\n         // Loops (not very meaningful in constants).\n         hir::ExprKind::While(ref expr, ref box_block, ref _option_label) => {\n             let _ = v.check_expr(expr);"}, {"sha": "e8af2f40b87a71f28bb8de45f031b655655f082b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 327, "deletions": 138, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -2,30 +2,30 @@ use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir::{self, PatKind, Pat};\n+use rustc::hir::{self, PatKind, Pat, ExprKind};\n use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::traits::ObligationCauseCode;\n+use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n use syntax::ast;\n use syntax::source_map::Spanned;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n+use syntax_pos::hygiene::CompilerDesugaringKind;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n \n use super::report_unexpected_variant_res;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    /// `match_discrim_span` argument having a `Span` indicates that this pattern is part of\n-    /// a match expression arm guard, and it points to the match discriminant to add context\n-    /// in type errors. In the folloowing example, `match_discrim_span` corresponds to the\n-    /// `a + b` expression:\n+    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n+    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n+    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n     ///\n     /// ```text\n     /// error[E0308]: mismatched types\n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         pat: &'gcx hir::Pat,\n         mut expected: Ty<'tcx>,\n         mut def_bm: ty::BindingMode,\n-        match_discrim_span: Option<Span>,\n+        discrim_span: Option<Span>,\n     ) {\n         let tcx = self.tcx;\n \n@@ -176,7 +176,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //     &'static str <: expected\n                 //\n                 // that's equivalent to there existing a LUB.\n-                self.demand_suptype(pat.span, expected, pat_ty);\n+                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n+                    err.emit_unless(discrim_span\n+                        .filter(|&s| s.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary))\n+                        .is_some());\n+                }\n+\n                 pat_ty\n             }\n             PatKind::Range(ref begin, ref end, _) => {\n@@ -224,8 +229,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n-                self.demand_eqtype_pat(pat.span, expected, lhs_ty, match_discrim_span);\n-                self.demand_eqtype_pat(pat.span, expected, rhs_ty, match_discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n                 common_type\n             }\n             PatKind::Binding(ba, var_id, _, ref sub) => {\n@@ -254,25 +259,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n                         // an explanation.\n-                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, match_discrim_span);\n+                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n                     }\n                     // otherwise the type of x is the expected type T\n                     ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n-                        self.demand_eqtype_pat(pat.span, expected, local_ty, match_discrim_span);\n+                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n                     }\n                 }\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 if var_id != pat.hir_id {\n                     let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype_pat(pat.span, vt, local_ty, match_discrim_span);\n+                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n                 }\n \n                 local_ty\n@@ -285,14 +290,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ddpos,\n                     expected,\n                     def_bm,\n-                    match_discrim_span,\n+                    discrim_span,\n                 )\n             }\n             PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, qpath, expected)\n             }\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, match_discrim_span)\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -318,7 +323,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // further errors being emitted when using the bindings. #50333\n                     let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n                     for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, match_discrim_span);\n+                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n                     }\n                     tcx.mk_tup(element_tys_iter)\n                 } else {\n@@ -327,7 +332,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             elem,\n                             &element_tys[i].expect_ty(),\n                             def_bm,\n-                            match_discrim_span,\n+                            discrim_span,\n                         );\n                     }\n                     pat_ty\n@@ -341,11 +346,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Here, `demand::subtype` is good enough, but I don't\n                     // think any errors can be introduced by using\n                     // `demand::eqtype`.\n-                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, match_discrim_span);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n+                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n                     uniq_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -384,10 +389,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     };\n \n-                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n                     rptr_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -445,13 +450,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n                 }\n                 for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n                 }\n                 expected_ty\n             }\n@@ -595,73 +600,24 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n-        // Not entirely obvious: if matches may create ref bindings, we want to\n-        // use the *precise* type of the discriminant, *not* some supertype, as\n-        // the \"discriminant type\" (issue #23116).\n-        //\n-        // arielb1 [writes here in this comment thread][c] that there\n-        // is certainly *some* potential danger, e.g., for an example\n-        // like:\n-        //\n-        // [c]: https://github.com/rust-lang/rust/pull/43399#discussion_r130223956\n-        //\n-        // ```\n-        // let Foo(x) = f()[0];\n-        // ```\n-        //\n-        // Then if the pattern matches by reference, we want to match\n-        // `f()[0]` as a lexpr, so we can't allow it to be\n-        // coerced. But if the pattern matches by value, `f()[0]` is\n-        // still syntactically a lexpr, but we *do* want to allow\n-        // coercions.\n-        //\n-        // However, *likely* we are ok with allowing coercions to\n-        // happen if there are no explicit ref mut patterns - all\n-        // implicit ref mut patterns must occur behind a reference, so\n-        // they will have the \"correct\" variance and lifetime.\n-        //\n-        // This does mean that the following pattern would be legal:\n-        //\n-        // ```\n-        // struct Foo(Bar);\n-        // struct Bar(u32);\n-        // impl Deref for Foo {\n-        //     type Target = Bar;\n-        //     fn deref(&self) -> &Bar { &self.0 }\n-        // }\n-        // impl DerefMut for Foo {\n-        //     fn deref_mut(&mut self) -> &mut Bar { &mut self.0 }\n-        // }\n-        // fn foo(x: &mut Foo) {\n-        //     {\n-        //         let Bar(z): &mut Bar = x;\n-        //         *z = 42;\n-        //     }\n-        //     assert_eq!(foo.0.0, 42);\n-        // }\n-        // ```\n-        //\n-        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n-        // is problematic as the HIR is being scraped, but ref bindings may be\n-        // implicit after #42640. We need to make sure that pat_adjustments\n-        // (once introduced) is populated by the time we get here.\n-        //\n-        // See #44848.\n-        let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| a.contains_explicit_ref_binding())\n-                                        .max_by_key(|m| match *m {\n-                                            hir::MutMutable => 1,\n-                                            hir::MutImmutable => 0,\n-                                        });\n-        let discrim_ty;\n-        if let Some(m) = contains_ref_bindings {\n-            discrim_ty = self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m));\n+        use hir::MatchSource::*;\n+        let (source_if, if_no_else, if_desugar) = match match_src {\n+            IfDesugar { contains_else_clause } => (true, !contains_else_clause, true),\n+            IfLetDesugar { contains_else_clause } => (true, !contains_else_clause, false),\n+            _ => (false, false, false),\n+        };\n+\n+        // Type check the descriminant and get its type.\n+        let discrim_ty = if if_desugar {\n+            // Here we want to ensure:\n+            //\n+            // 1. That default match bindings are *not* accepted in the condition of an\n+            //    `if` expression. E.g. given `fn foo() -> &bool;` we reject `if foo() { .. }`.\n+            //\n+            // 2. By expecting `bool` for `expr` we get nice diagnostics for e.g. `if x = y { .. }`.\n+            self.check_expr_has_type_or_error(discrim, self.tcx.types.bool)\n         } else {\n-            // ...but otherwise we want to use any supertype of the\n-            // discriminant. This is sort of a workaround, see note (*) in\n-            // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n-            self.check_expr_has_type_or_error(discrim, discrim_ty);\n+            self.demand_discriminant_type(arms, discrim)\n         };\n \n         // If there are no arms, that is a diverging match; a special case.\n@@ -670,11 +626,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             return tcx.types.never;\n         }\n \n-        if self.diverges.get().always() {\n-            for arm in arms {\n-                self.warn_if_unreachable(arm.body.hir_id, arm.body.span, \"arm\");\n-            }\n-        }\n+        self.warn_arms_when_scrutinee_diverges(arms, source_if);\n \n         // Otherwise, we have to union together the types that the\n         // arms produce and so forth.\n@@ -687,12 +639,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat_walk(\n-                    &p,\n-                    discrim_ty,\n-                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-                    Some(discrim.span),\n-                );\n+                let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+                self.check_pat_walk(&p, discrim_ty, binding_mode, Some(discrim.span));\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -734,7 +682,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut other_arms = vec![];  // used only for diagnostics\n         let mut prior_arm_ty = None;\n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n-            if let Some(ref g) = arm.guard {\n+            if let Some(g) = &arm.guard {\n                 self.diverges.set(pats_diverge);\n                 match g {\n                     hir::Guard::If(e) => self.check_expr_has_type_or_error(e, tcx.types.bool),\n@@ -745,43 +693,44 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            // Handle the fallback arm of a desugared if-let like a missing else.\n-            let is_if_let_fallback = match match_src {\n-                hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n-                    i == arms.len() - 1 && arm_ty.is_unit()\n+            let span = expr.span;\n+\n+            if source_if {\n+                let then_expr = &arms[0].body;\n+                match (i, if_no_else) {\n+                    (0, _) => coercion.coerce(self, &self.misc(span), then_expr, arm_ty),\n+                    (_, true) => self.if_fallback_coercion(span, then_expr, &mut coercion),\n+                    (_, _) => {\n+                        let then_ty = prior_arm_ty.unwrap();\n+                        let cause = self.if_cause(span, then_expr, &arm.body, then_ty, arm_ty);\n+                        coercion.coerce(self, &cause, &arm.body, arm_ty);\n+                    }\n                 }\n-                _ => false\n-            };\n-\n-            let arm_span = if let hir::ExprKind::Block(ref blk, _) = arm.body.node {\n-                // Point at the block expr instead of the entire block\n-                blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n             } else {\n-                arm.body.span\n-            };\n-            if is_if_let_fallback {\n-                let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n-                assert!(arm_ty.is_unit());\n-                coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-            } else {\n-                let cause = if i == 0 {\n+                let arm_span = if let hir::ExprKind::Block(blk, _) = &arm.body.node {\n+                    // Point at the block expr instead of the entire block\n+                    blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n+                } else {\n+                    arm.body.span\n+                };\n+                let (span, code) = match i {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n-                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id))\n-                } else {\n-                    self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                    0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n+                    _ => (span, ObligationCauseCode::MatchExpressionArm {\n                         arm_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n                         last_ty: prior_arm_ty.unwrap(),\n                         discrim_hir_id: discrim.hir_id,\n-                    })\n+                    }),\n                 };\n+                let cause = self.cause(span, code);\n                 coercion.coerce(self, &cause, &arm.body, arm_ty);\n-            }\n-            other_arms.push(arm_span);\n-            if other_arms.len() > 5 {\n-                other_arms.remove(0);\n+                other_arms.push(arm_span);\n+                if other_arms.len() > 5 {\n+                    other_arms.remove(0);\n+                }\n             }\n             prior_arm_ty = Some(arm_ty);\n         }\n@@ -792,6 +741,251 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         coercion.complete(self)\n     }\n \n+    /// When the previously checked expression (the scrutinee) diverges,\n+    /// warn the user about the match arms being unreachable.\n+    fn warn_arms_when_scrutinee_diverges(&self, arms: &'gcx [hir::Arm], source_if: bool) {\n+        if self.diverges.get().always() {\n+            let msg = if source_if { \"block in `if` expression\" } else { \"arm\" };\n+            for arm in arms {\n+                self.warn_if_unreachable(arm.body.hir_id, arm.body.span, msg);\n+            }\n+        }\n+    }\n+\n+    /// Handle the fallback arm of a desugared if(-let) like a missing else.\n+    fn if_fallback_coercion(\n+        &self,\n+        span: Span,\n+        then_expr: &'gcx hir::Expr,\n+        coercion: &mut CoerceMany<'gcx, 'tcx, '_, rustc::hir::Arm>,\n+    ) {\n+        // If this `if` expr is the parent's function return expr,\n+        // the cause of the type coercion is the return type, point at it. (#25228)\n+        let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, span);\n+        let cause = self.cause(span, ObligationCauseCode::IfExpressionWithNoElse);\n+        coercion.coerce_forced_unit(self, &cause, &mut |err| {\n+            if let Some((span, msg)) = &ret_reason {\n+                err.span_label(*span, msg.as_str());\n+            } else if let ExprKind::Block(block, _) = &then_expr.node {\n+                if let Some(expr) = &block.expr {\n+                    err.span_label(expr.span, \"found here\".to_string());\n+                }\n+            }\n+            err.note(\"`if` expressions without `else` evaluate to `()`\");\n+            err.help(\"consider adding an `else` block that evaluates to the expected type\");\n+        }, ret_reason.is_none());\n+    }\n+\n+    fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, span: Span) -> Option<(Span, String)> {\n+        use hir::Node::{Block, Item, Local};\n+\n+        let node = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(\n+            self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n+        ));\n+        if let Block(block) = node {\n+            // check that the body's parent is an fn\n+            let parent = self.tcx.hir().get_by_hir_id(\n+                self.tcx.hir().get_parent_node_by_hir_id(\n+                    self.tcx.hir().get_parent_node_by_hir_id(block.hir_id),\n+                ),\n+            );\n+            if let (Some(expr), Item(hir::Item {\n+                node: hir::ItemKind::Fn(..), ..\n+            })) = (&block.expr, parent) {\n+                // check that the `if` expr without `else` is the fn body's expr\n+                if expr.span == span {\n+                    return self.get_fn_decl(hir_id).map(|(fn_decl, _)| (\n+                        fn_decl.output.span(),\n+                        format!(\"expected `{}` because of this return type\", fn_decl.output),\n+                    ));\n+                }\n+            }\n+        }\n+        if let Local(hir::Local { ty: Some(_), pat, .. }) = node {\n+            return Some((pat.span, \"expected because of this assignment\".to_string()));\n+        }\n+        None\n+    }\n+\n+    fn if_cause(\n+        &self,\n+        span: Span,\n+        then_expr: &'gcx hir::Expr,\n+        else_expr: &'gcx hir::Expr,\n+        then_ty: Ty<'tcx>,\n+        else_ty: Ty<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n+            // The `if`/`else` isn't in one line in the output, include some context to make it\n+            // clear it is an if/else expression:\n+            // ```\n+            // LL |      let x = if true {\n+            //    | _____________-\n+            // LL ||         10i32\n+            //    ||         ----- expected because of this\n+            // LL ||     } else {\n+            // LL ||         10u32\n+            //    ||         ^^^^^ expected i32, found u32\n+            // LL ||     };\n+            //    ||_____- if and else have incompatible types\n+            // ```\n+            Some(span)\n+        } else {\n+            // The entire expression is in one line, only point at the arms\n+            // ```\n+            // LL |     let x = if true { 10i32 } else { 10u32 };\n+            //    |                       -----          ^^^^^ expected i32, found u32\n+            //    |                       |\n+            //    |                       expected because of this\n+            // ```\n+            None\n+        };\n+\n+        let mut remove_semicolon = None;\n+        let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n+            if let Some(expr) = &block.expr {\n+                expr.span\n+            } else if let Some(stmt) = block.stmts.last() {\n+                // possibly incorrect trailing `;` in the else arm\n+                remove_semicolon = self.could_remove_semicolon(block, then_ty);\n+                stmt.span\n+            } else {  // empty block, point at its entirety\n+                // Avoid overlapping spans that aren't as readable:\n+                // ```\n+                // 2 |        let x = if true {\n+                //   |   _____________-\n+                // 3 |  |         3\n+                //   |  |         - expected because of this\n+                // 4 |  |     } else {\n+                //   |  |____________^\n+                // 5 | ||\n+                // 6 | ||     };\n+                //   | ||     ^\n+                //   | ||_____|\n+                //   | |______if and else have incompatible types\n+                //   |        expected integer, found ()\n+                // ```\n+                // by not pointing at the entire expression:\n+                // ```\n+                // 2 |       let x = if true {\n+                //   |               ------- if and else have incompatible types\n+                // 3 |           3\n+                //   |           - expected because of this\n+                // 4 |       } else {\n+                //   |  ____________^\n+                // 5 | |\n+                // 6 | |     };\n+                //   | |_____^ expected integer, found ()\n+                // ```\n+                if outer_sp.is_some() {\n+                    outer_sp = Some(self.tcx.sess.source_map().def_span(span));\n+                }\n+                else_expr.span\n+            }\n+        } else { // shouldn't happen unless the parser has done something weird\n+            else_expr.span\n+        };\n+\n+        // Compute `Span` of `then` part of `if`-expression:\n+        let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n+            if let Some(expr) = &block.expr {\n+                expr.span\n+            } else if let Some(stmt) = block.stmts.last() {\n+                // possibly incorrect trailing `;` in the else arm\n+                remove_semicolon = remove_semicolon.or(self.could_remove_semicolon(block, else_ty));\n+                stmt.span\n+            } else {  // empty block, point at its entirety\n+                outer_sp = None;  // same as in `error_sp`, cleanup output\n+                then_expr.span\n+            }\n+        } else {  // shouldn't happen unless the parser has done something weird\n+            then_expr.span\n+        };\n+\n+        // Finally construct the cause:\n+        self.cause(error_sp, ObligationCauseCode::IfExpression {\n+            then: then_sp,\n+            outer: outer_sp,\n+            semicolon: remove_semicolon,\n+        })\n+    }\n+\n+    fn demand_discriminant_type(\n+        &self,\n+        arms: &'gcx [hir::Arm],\n+        discrim: &'gcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        // Not entirely obvious: if matches may create ref bindings, we want to\n+        // use the *precise* type of the discriminant, *not* some supertype, as\n+        // the \"discriminant type\" (issue #23116).\n+        //\n+        // arielb1 [writes here in this comment thread][c] that there\n+        // is certainly *some* potential danger, e.g., for an example\n+        // like:\n+        //\n+        // [c]: https://github.com/rust-lang/rust/pull/43399#discussion_r130223956\n+        //\n+        // ```\n+        // let Foo(x) = f()[0];\n+        // ```\n+        //\n+        // Then if the pattern matches by reference, we want to match\n+        // `f()[0]` as a lexpr, so we can't allow it to be\n+        // coerced. But if the pattern matches by value, `f()[0]` is\n+        // still syntactically a lexpr, but we *do* want to allow\n+        // coercions.\n+        //\n+        // However, *likely* we are ok with allowing coercions to\n+        // happen if there are no explicit ref mut patterns - all\n+        // implicit ref mut patterns must occur behind a reference, so\n+        // they will have the \"correct\" variance and lifetime.\n+        //\n+        // This does mean that the following pattern would be legal:\n+        //\n+        // ```\n+        // struct Foo(Bar);\n+        // struct Bar(u32);\n+        // impl Deref for Foo {\n+        //     type Target = Bar;\n+        //     fn deref(&self) -> &Bar { &self.0 }\n+        // }\n+        // impl DerefMut for Foo {\n+        //     fn deref_mut(&mut self) -> &mut Bar { &mut self.0 }\n+        // }\n+        // fn foo(x: &mut Foo) {\n+        //     {\n+        //         let Bar(z): &mut Bar = x;\n+        //         *z = 42;\n+        //     }\n+        //     assert_eq!(foo.0.0, 42);\n+        // }\n+        // ```\n+        //\n+        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n+        // is problematic as the HIR is being scraped, but ref bindings may be\n+        // implicit after #42640. We need to make sure that pat_adjustments\n+        // (once introduced) is populated by the time we get here.\n+        //\n+        // See #44848.\n+        let contains_ref_bindings = arms.iter()\n+                                        .filter_map(|a| a.contains_explicit_ref_binding())\n+                                        .max_by_key(|m| match *m {\n+                                            hir::MutMutable => 1,\n+                                            hir::MutImmutable => 0,\n+                                        });\n+\n+        if let Some(m) = contains_ref_bindings {\n+            self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m))\n+        } else {\n+            // ...but otherwise we want to use any supertype of the\n+            // discriminant. This is sort of a workaround, see note (*) in\n+            // `check_pat` for some details.\n+            let discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n+            self.check_expr_has_type_or_error(discrim, discrim_ty);\n+            discrim_ty\n+        }\n+    }\n+\n     fn check_pat_struct(\n         &self,\n         pat: &'gcx hir::Pat,\n@@ -800,7 +994,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n-        match_discrim_span: Option<Span>,\n+        discrim_span: Option<Span>,\n     ) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n@@ -809,18 +1003,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(\n-                    &field.node.pat,\n-                    self.tcx.types.err,\n-                    def_bm,\n-                    match_discrim_span,\n-                );\n+                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, discrim_span);\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_discrim_span);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n \n         // Type-check subpatterns.\n         if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)"}, {"sha": "008975068e581a374daca5a7eff7d34cc4e046ab", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -1248,12 +1248,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     augment_error(&mut db);\n                 }\n \n-                if expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some() {\n-                    // Error reported in `check_assign` so avoid emitting error again.\n-                    db.delay_as_bug();\n-                } else {\n-                    db.emit();\n-                }\n+                // Error possibly reported in `check_assign` so avoid emitting error again.\n+                db.emit_unless(expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some());\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }"}, {"sha": "2b519731eeedba51af918ec461361b1dc9c44d3e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 212, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -117,6 +117,7 @@ use rustc::ty::subst::{UnpackedKind, Subst, InternalSubsts, SubstsRef, UserSelfT\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n+use syntax_pos::hygiene::CompilerDesugaringKind;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -1086,12 +1087,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n         // Check the pattern.\n-        fcx.check_pat_walk(\n-            &arg.pat,\n-            arg_ty,\n-            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-            None,\n-        );\n+        let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+        fcx.check_pat_walk(&arg.pat, arg_ty, binding_mode, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n@@ -2045,15 +2042,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Produces warning on the given node, if the current point in the\n     /// function is unreachable, and there hasn't been another warning.\n     fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n-        if self.diverges.get() == Diverges::Always {\n+        if self.diverges.get() == Diverges::Always &&\n+            // If span arose from a desugaring of `if` then it is the condition itself,\n+            // which diverges, that we are about to lint on. This gives suboptimal diagnostics\n+            // and so we stop here and allow the block of the `if`-expression to be linted instead.\n+            !span.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary) {\n             self.diverges.set(Diverges::WarnedAlways);\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-            self.tcx().lint_hir(\n-                lint::builtin::UNREACHABLE_CODE,\n-                id, span,\n-                &format!(\"unreachable {}\", kind));\n+            let msg = format!(\"unreachable {}\", kind);\n+            self.tcx().lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, &msg);\n         }\n     }\n \n@@ -3161,13 +3160,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            if self.is_assign_to_bool(expr, expected_ty) {\n-                // Error reported in `check_assign` so avoid emitting error again.\n-                // FIXME(centril): Consider removing if/when `if` desugars to `match`.\n-                err.delay_as_bug();\n-            } else {\n-                err.emit();\n-            }\n+            let expr = match &expr.node {\n+                ExprKind::DropTemps(expr) => expr,\n+                _ => expr,\n+            };\n+            // Error possibly reported in `check_assign` so avoid emitting error again.\n+            err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n         }\n         ty\n     }\n@@ -3330,194 +3328,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             return_expr_ty);\n     }\n \n-    // A generic function for checking the 'then' and 'else' clauses in an 'if'\n-    // or 'if-else' expression.\n-    fn check_then_else(&self,\n-                       cond_expr: &'gcx hir::Expr,\n-                       then_expr: &'gcx hir::Expr,\n-                       opt_else_expr: Option<&'gcx hir::Expr>,\n-                       sp: Span,\n-                       expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_has_type_or_error(cond_expr, self.tcx.types.bool);\n-        let cond_diverges = self.diverges.get();\n-        self.diverges.set(Diverges::Maybe);\n-\n-        let expected = expected.adjust_for_branches(self);\n-        let then_ty = self.check_expr_with_expectation(then_expr, expected);\n-        let then_diverges = self.diverges.get();\n-        self.diverges.set(Diverges::Maybe);\n-\n-        // We've already taken the expected type's preferences\n-        // into account when typing the `then` branch. To figure\n-        // out the initial shot at a LUB, we thus only consider\n-        // `expected` if it represents a *hard* constraint\n-        // (`only_has_type`); otherwise, we just go with a\n-        // fresh type variable.\n-        let coerce_to_ty = expected.coercion_target_type(self, sp);\n-        let mut coerce: DynamicCoerceMany<'_, '_> = CoerceMany::new(coerce_to_ty);\n-\n-        coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n-\n-        if let Some(else_expr) = opt_else_expr {\n-            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n-            let else_diverges = self.diverges.get();\n-\n-            let mut outer_sp = if self.tcx.sess.source_map().is_multiline(sp) {\n-                // The `if`/`else` isn't in one line in the output, include some context to make it\n-                // clear it is an if/else expression:\n-                // ```\n-                // LL |      let x = if true {\n-                //    | _____________-\n-                // LL ||         10i32\n-                //    ||         ----- expected because of this\n-                // LL ||     } else {\n-                // LL ||         10u32\n-                //    ||         ^^^^^ expected i32, found u32\n-                // LL ||     };\n-                //    ||_____- if and else have incompatible types\n-                // ```\n-                Some(sp)\n-            } else {\n-                // The entire expression is in one line, only point at the arms\n-                // ```\n-                // LL |     let x = if true { 10i32 } else { 10u32 };\n-                //    |                       -----          ^^^^^ expected i32, found u32\n-                //    |                       |\n-                //    |                       expected because of this\n-                // ```\n-                None\n-            };\n-            let mut remove_semicolon = None;\n-            let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n-                if let Some(expr) = &block.expr {\n-                    expr.span\n-                } else if let Some(stmt) = block.stmts.last() {\n-                    // possibly incorrect trailing `;` in the else arm\n-                    remove_semicolon = self.could_remove_semicolon(block, then_ty);\n-                    stmt.span\n-                } else {  // empty block, point at its entirety\n-                    // Avoid overlapping spans that aren't as readable:\n-                    // ```\n-                    // 2 |        let x = if true {\n-                    //   |   _____________-\n-                    // 3 |  |         3\n-                    //   |  |         - expected because of this\n-                    // 4 |  |     } else {\n-                    //   |  |____________^\n-                    // 5 | ||\n-                    // 6 | ||     };\n-                    //   | ||     ^\n-                    //   | ||_____|\n-                    //   | |______if and else have incompatible types\n-                    //   |        expected integer, found ()\n-                    // ```\n-                    // by not pointing at the entire expression:\n-                    // ```\n-                    // 2 |       let x = if true {\n-                    //   |               ------- if and else have incompatible types\n-                    // 3 |           3\n-                    //   |           - expected because of this\n-                    // 4 |       } else {\n-                    //   |  ____________^\n-                    // 5 | |\n-                    // 6 | |     };\n-                    //   | |_____^ expected integer, found ()\n-                    // ```\n-                    if outer_sp.is_some() {\n-                        outer_sp = Some(self.tcx.sess.source_map().def_span(sp));\n-                    }\n-                    else_expr.span\n-                }\n-            } else { // shouldn't happen unless the parser has done something weird\n-                else_expr.span\n-            };\n-            let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n-                if let Some(expr) = &block.expr {\n-                    expr.span\n-                } else if let Some(stmt) = block.stmts.last() {\n-                    // possibly incorrect trailing `;` in the else arm\n-                    remove_semicolon = remove_semicolon.or(\n-                        self.could_remove_semicolon(block, else_ty));\n-                    stmt.span\n-                } else {  // empty block, point at its entirety\n-                    outer_sp = None;  // same as in `error_sp`, cleanup output\n-                    then_expr.span\n-                }\n-            } else {  // shouldn't happen unless the parser has done something weird\n-                then_expr.span\n-            };\n-\n-            let if_cause = self.cause(error_sp, ObligationCauseCode::IfExpression {\n-                then: then_sp,\n-                outer: outer_sp,\n-                semicolon: remove_semicolon,\n-            });\n-\n-            coerce.coerce(self, &if_cause, else_expr, else_ty);\n-\n-            // We won't diverge unless both branches do (or the condition does).\n-            self.diverges.set(cond_diverges | then_diverges & else_diverges);\n-        } else {\n-            // If this `if` expr is the parent's function return expr, the cause of the type\n-            // coercion is the return type, point at it. (#25228)\n-            let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, sp);\n-\n-            let else_cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n-            coerce.coerce_forced_unit(self, &else_cause, &mut |err| {\n-                if let Some((sp, msg)) = &ret_reason {\n-                    err.span_label(*sp, msg.as_str());\n-                } else if let ExprKind::Block(block, _) = &then_expr.node {\n-                    if let Some(expr) = &block.expr {\n-                        err.span_label(expr.span, \"found here\".to_string());\n-                    }\n-                }\n-                err.note(\"`if` expressions without `else` evaluate to `()`\");\n-                err.help(\"consider adding an `else` block that evaluates to the expected type\");\n-            }, ret_reason.is_none());\n-\n-            // If the condition is false we can't diverge.\n-            self.diverges.set(cond_diverges);\n-        }\n-\n-        let result_ty = coerce.complete(self);\n-        if cond_ty.references_error() {\n-            self.tcx.types.err\n-        } else {\n-            result_ty\n-        }\n-    }\n-\n-    fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, sp: Span) -> Option<(Span, String)> {\n-        let node = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(\n-            self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n-        ));\n-        if let Node::Block(block) = node {\n-            // check that the body's parent is an fn\n-            let parent = self.tcx.hir().get_by_hir_id(\n-                self.tcx.hir().get_parent_node_by_hir_id(\n-                    self.tcx.hir().get_parent_node_by_hir_id(block.hir_id),\n-                ),\n-            );\n-            if let (Some(expr), Node::Item(hir::Item {\n-                node: hir::ItemKind::Fn(..), ..\n-            })) = (&block.expr, parent) {\n-                // check that the `if` expr without `else` is the fn body's expr\n-                if expr.span == sp {\n-                    return self.get_fn_decl(hir_id).map(|(fn_decl, _)| (\n-                        fn_decl.output.span(),\n-                        format!(\"expected `{}` because of this return type\", fn_decl.output),\n-                    ));\n-                }\n-            }\n-        }\n-        if let Node::Local(hir::Local {\n-            ty: Some(_), pat, ..\n-        }) = node {\n-            return Some((pat.span, \"expected because of this assignment\".to_string()));\n-        }\n-        None\n-    }\n-\n     // Check field access expressions\n     fn check_field(&self,\n                    expr: &'gcx hir::Expr,\n@@ -4062,7 +3872,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match expr.node {\n             ExprKind::Block(..) |\n             ExprKind::Loop(..) | ExprKind::While(..) |\n-            ExprKind::If(..) | ExprKind::Match(..) => {}\n+            ExprKind::Match(..) => {}\n \n             _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n         }\n@@ -4444,10 +4254,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.check_assign(expr, expected, lhs, rhs)\n             }\n-            ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n-                self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n-                                     expr.span, expected)\n-            }\n             ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n                     // cannot use break with a value from a while loop\n@@ -5261,7 +5067,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match expression.node {\n                 ExprKind::Call(..) |\n                 ExprKind::MethodCall(..) |\n-                ExprKind::If(..) |\n                 ExprKind::While(..) |\n                 ExprKind::Loop(..) |\n                 ExprKind::Match(..) |"}, {"sha": "1d9dc26bf609260fa9106903f0f0eb7e8dced8e3", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cccda1770f76b8184ea55e4735ce88f824f7fd8/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=5cccda1770f76b8184ea55e4735ce88f824f7fd8", "patch": "@@ -591,6 +591,10 @@ impl ExpnFormat {\n /// The kind of compiler desugaring.\n #[derive(Clone, Copy, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CompilerDesugaringKind {\n+    /// We desugar `if c { i } else { e }` to `match $ExprKind::Use(c) { true => i, _ => e }`.\n+    /// However, we do not want to blame `c` for unreachability but rather say that `i`\n+    /// is unreachable. This desugaring kind allows us to avoid blaming `c`.\n+    IfTemporary,\n     QuestionMark,\n     TryBlock,\n     /// Desugaring of an `impl Trait` in return type position\n@@ -605,6 +609,7 @@ pub enum CompilerDesugaringKind {\n impl CompilerDesugaringKind {\n     pub fn name(self) -> Symbol {\n         Symbol::intern(match self {\n+            CompilerDesugaringKind::IfTemporary => \"if\",\n             CompilerDesugaringKind::Async => \"async\",\n             CompilerDesugaringKind::Await => \"await\",\n             CompilerDesugaringKind::QuestionMark => \"?\","}]}