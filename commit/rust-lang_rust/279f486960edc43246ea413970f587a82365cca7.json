{"sha": "279f486960edc43246ea413970f587a82365cca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OWY0ODY5NjBlZGM0MzI0NmVhNDEzOTcwZjU4N2E4MjM2NWNjYTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-08-06T14:26:56Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-08-06T14:26:56Z"}, "message": "Merge commit '05677b6bd6c938ed760835d9b1f6514992654ae3' into sync_cg_clif-2021-08-06", "tree": {"sha": "a15483e6de5d0c1c26b7a5d8839400f673f8b69a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a15483e6de5d0c1c26b7a5d8839400f673f8b69a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/279f486960edc43246ea413970f587a82365cca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/279f486960edc43246ea413970f587a82365cca7", "html_url": "https://github.com/rust-lang/rust/commit/279f486960edc43246ea413970f587a82365cca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/279f486960edc43246ea413970f587a82365cca7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f94abcda6884893d4723304102089198caa0839", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f94abcda6884893d4723304102089198caa0839", "html_url": "https://github.com/rust-lang/rust/commit/1f94abcda6884893d4723304102089198caa0839"}, {"sha": "05677b6bd6c938ed760835d9b1f6514992654ae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/05677b6bd6c938ed760835d9b1f6514992654ae3", "html_url": "https://github.com/rust-lang/rust/commit/05677b6bd6c938ed760835d9b1f6514992654ae3"}], "stats": {"total": 1413, "additions": 823, "deletions": 590}, "files": [{"sha": "f524b42c5eecda06098bdec6a7518295e3994013", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -49,12 +49,14 @@ jobs:\n     - name: Install MinGW toolchain and wine\n       if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       run: |\n+        sudo apt-get update\n         sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n         rustup target add x86_64-pc-windows-gnu\n \n     - name: Install AArch64 toolchain and qemu\n       if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'aarch64-unknown-linux-gnu'\n       run: |\n+        sudo apt-get update\n         sudo apt-get install -y gcc-aarch64-linux-gnu qemu-user\n \n     - name: Prepare dependencies"}, {"sha": "25080488a88b525f30b290caee0f6874851564fb", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -15,3 +15,4 @@ perf.data.old\n /rand\n /regex\n /simple-raytracer\n+/stdsimd"}, {"sha": "23c1fdc6ee425c7b73404c78a0303fc6aea9e73c", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.38\"\n+version = \"1.0.42\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afddf7f520a80dbf76e6f50a35bca42a2331ef227a28b3b6dc5c2e2338d114b1\"\n+checksum = \"595d3cfa7a60d4555cb5067b99f07142a08ea778de5cf993f7b75c7d8fabc486\"\n \n [[package]]\n name = \"ar\"\n@@ -34,15 +34,15 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n [[package]]\n name = \"cranelift-bforest\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -58,7 +58,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-meta\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n@@ -67,17 +67,17 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-shared\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n \n [[package]]\n name = \"cranelift-entity\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n \n [[package]]\n name = \"cranelift-frontend\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -88,7 +88,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-jit\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -105,7 +105,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-module\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -116,7 +116,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-native\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -126,7 +126,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-object\"\n version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git?branch=main#c71ad9490e7f3e19bbcae7e28bbe50f8a0b4a5d8\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -147,34 +147,34 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.24.0\"\n+version = \"0.25.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e4075386626662786ddb0ec9081e7c7eeb1ba31951f447ca780ef9f5d568189\"\n+checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n dependencies = [\n  \"indexmap\",\n ]\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.9.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.6.1\"\n+version = \"1.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4fb1fa934250de4de8aef298d81c729a7d33d8c239daa3a7575e6b92bfc7313b\"\n+checksum = \"bc633605454125dec4b66843673f01c7df2b89479b32e0ed634e43a91cff62a5\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.97\"\n+version = \"0.2.98\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"12b8adadd720df158f4d70dfe7ccc6adb0472d7c55ca83445f6a5ab3e36f8fb6\"\n+checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n \n [[package]]\n name = \"libloading\"\n@@ -212,9 +212,9 @@ checksum = \"b16bd47d9e329435e309c58469fe0791c2d0d1ba96ec0954152a5ae2b04387dc\"\n \n [[package]]\n name = \"object\"\n-version = \"0.25.3\"\n+version = \"0.26.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a38f2be3697a57b4060074ff41b44c16870d916ad7877c17696e063257482bc7\"\n+checksum = \"c55827317fb4c08822499848a14237d2874d6f139828893017237e7ab93eb386\"\n dependencies = [\n  \"crc32fast\",\n  \"indexmap\",\n@@ -277,9 +277,9 @@ checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"64ae3b39281e4b14b8123bdbaddd472b7dfe215e444181f2f9d2443c2444f834\"\n+checksum = \"b0652da4c4121005e9ed22b79f6c5f2d9e2752906b53a33e9490489ba421a6fb\"\n \n [[package]]\n name = \"winapi\""}, {"sha": "6f40fc0fcb881e77fa67e548191d380321f70550", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -8,15 +8,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime.git\", branch = \"main\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime.git\", branch = \"main\" }\n-cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime.git\", branch = \"main\" }\n-cranelift-native = { git = \"https://github.com/bytecodealliance/wasmtime.git\", branch = \"main\" }\n-cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime.git\", branch = \"main\", optional = true }\n-cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime.git\", branch = \"main\" }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime.git\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n+cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n+cranelift-native = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n+cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime.git\", optional = true }\n+cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime.git\" }\n target-lexicon = \"0.12.0\"\n-gimli = { version = \"0.24.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.25.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+gimli = { version = \"0.25.0\", default-features = false, features = [\"write\"]}\n+object = { version = \"0.26.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n@@ -36,7 +36,8 @@ smallvec = \"1.6.1\"\n #gimli = { path = \"../\" }\n \n [features]\n-default = [\"jit\", \"inline_asm\"]\n+# Enable features not ready to be enabled when compiling as part of rustc\n+unstable-features = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n "}, {"sha": "e068f084234bc734fc2e21c5e218a8089dc10d92", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -40,9 +40,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.68\"\n+version = \"1.0.69\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a72c244c1ff497a746a7e1fb3d14bd08420ecda70c8f25c7112f2781652d787\"\n+checksum = \"e70cc2f62c6ce1868963827bd677764c62d07c3d9a3e1fb1177ee1a9ab199eb2\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -132,9 +132,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.97\"\n+version = \"0.2.98\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"12b8adadd720df158f4d70dfe7ccc6adb0472d7c55ca83445f6a5ab3e36f8fb6\"\n+checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -270,14 +270,6 @@ dependencies = [\n  \"test\",\n ]\n \n-[[package]]\n-name = \"term\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core\",\n- \"std\",\n-]\n-\n [[package]]\n name = \"test\"\n version = \"0.0.0\"\n@@ -290,7 +282,6 @@ dependencies = [\n  \"panic_unwind\",\n  \"proc_macro\",\n  \"std\",\n- \"term\",\n ]\n \n [[package]]"}, {"sha": "150b6d01a6b30858091fec5b0f6cdd1b07a20ad9", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -4,7 +4,7 @@ use std::process::Command;\n \n pub(crate) fn build_backend(channel: &str, host_triple: &str) -> PathBuf {\n     let mut cmd = Command::new(\"cargo\");\n-    cmd.arg(\"build\").arg(\"--target\").arg(host_triple);\n+    cmd.arg(\"build\").arg(\"--target\").arg(host_triple).arg(\"--features\").arg(\"unstable-features\");\n \n     match channel {\n         \"debug\" => {}"}, {"sha": "642abc41f45a7ac2517458c22858ebd05a279a90", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -91,7 +91,9 @@ pub(crate) fn build_sysroot(\n             {\n                 let file = file.unwrap().path();\n                 let file_name_str = file.file_name().unwrap().to_str().unwrap();\n-                if file_name_str.contains(\"rustc_\")\n+                if (file_name_str.contains(\"rustc_\")\n+                    && !file_name_str.contains(\"rustc_std_workspace_\")\n+                    && !file_name_str.contains(\"rustc_demangle\"))\n                     || file_name_str.contains(\"chalk\")\n                     || file_name_str.contains(\"tracing\")\n                     || file_name_str.contains(\"regex\")"}, {"sha": "4b2051b605abdd726c99682639f95f5c8a7deeb3", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -27,6 +27,13 @@ pub(crate) fn prepare() {\n         \"341f207c1071f7290e3f228c710817c280c8dca1\",\n     );\n \n+    clone_repo(\n+        \"stdsimd\",\n+        \"https://github.com/rust-lang/stdsimd\",\n+        \"be96995d8ddec03fac9a0caf4d4c51c7fbc33507\",\n+    );\n+    apply_patches(\"stdsimd\", Path::new(\"stdsimd\"));\n+\n     clone_repo(\n         \"simple-raytracer\",\n         \"https://github.com/ebobby/simple-raytracer\",\n@@ -60,11 +67,7 @@ fn prepare_sysroot() {\n     copy_dir_recursively(&sysroot_src_orig.join(\"library\"), &sysroot_src.join(\"library\"));\n \n     let rustc_version = get_rustc_version();\n-    fs::write(\n-        Path::new(\"build_sysroot\").join(\"rustc_version\"),\n-        &rustc_version,\n-    )\n-    .unwrap();\n+    fs::write(Path::new(\"build_sysroot\").join(\"rustc_version\"), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n     let mut git_init_cmd = Command::new(\"git\");"}, {"sha": "23e5bf2e0a8fd77fd08e877fe1a2d2baa29cecaf", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -3,4 +3,4 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old}\n-rm -rf rand/ regex/ simple-raytracer/\n+rm -rf rand/ regex/ simple-raytracer/ stdsimd/"}, {"sha": "87eec0e818bb2407695c4fa6b82ff49eada037a1", "filename": "compiler/rustc_codegen_cranelift/docs/usage.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -36,7 +36,7 @@ $ $cg_clif_dir/build/cargo jit\n or\n \n ```bash\n-$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+$ $cg_clif_dir/build/bin/cg_clif -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n ```\n \n There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n@@ -52,7 +52,7 @@ These are a few functions that allow you to easily run rust code from the shell\n \n ```bash\n function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic\n }\n \n function jit() {"}, {"sha": "731c60fda58d675de31323addb9f71520b51683b", "filename": "compiler/rustc_codegen_cranelift/patches/0001-stdsimd-Disable-unsupported-tests.patch", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-stdsimd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-stdsimd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-stdsimd-Disable-unsupported-tests.patch?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -0,0 +1,165 @@\n+From 6bfce5dc2cbf834c74dbccb7538adc08c6eb57e7 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sun, 25 Jul 2021 18:39:31 +0200\n+Subject: [PATCH] Disable unsupported tests\n+\n+---\n+ crates/core_simd/src/array.rs        |  2 ++\n+ crates/core_simd/src/lib.rs          |  2 +-\n+ crates/core_simd/src/math.rs         |  4 ++++\n+ crates/core_simd/tests/masks.rs      | 12 ------------\n+ crates/core_simd/tests/ops_macros.rs |  6 ++++++\n+ crates/core_simd/tests/round.rs      |  2 ++\n+ 6 files changed, 15 insertions(+), 13 deletions(-)\n+\n+diff --git a/crates/core_simd/src/array.rs b/crates/core_simd/src/array.rs\n+index 25c5309..2b3d819 100644\n+--- a/crates/core_simd/src/array.rs\n++++ b/crates/core_simd/src/array.rs\n+@@ -22,6 +22,7 @@ where\n+     #[must_use]\n+     fn splat(val: Self::Scalar) -> Self;\n+ \n++    /*\n+     /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+     /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n+     /// ```\n+@@ -150,6 +151,7 @@ where\n+             // Cleared \u2622\ufe0f *mut T Zone\n+         }\n+     }\n++    */\n+ }\n+ \n+ macro_rules! impl_simdarray_for {\n+diff --git a/crates/core_simd/src/lib.rs b/crates/core_simd/src/lib.rs\n+index a64904d..299eb11 100644\n+--- a/crates/core_simd/src/lib.rs\n++++ b/crates/core_simd/src/lib.rs\n+@@ -1,7 +1,7 @@\n+ #![no_std]\n+ #![allow(incomplete_features)]\n+ #![feature(\n+-    const_generics, \n++    const_generics,\n+     platform_intrinsics,\n+     repr_simd,\n+     simd_ffi,\n+diff --git a/crates/core_simd/src/math.rs b/crates/core_simd/src/math.rs\n+index 7290a28..e394730 100644\n+--- a/crates/core_simd/src/math.rs\n++++ b/crates/core_simd/src/math.rs\n+@@ -2,6 +2,7 @@ macro_rules! impl_uint_arith {\n+     ($(($name:ident, $n:ident)),+) => {\n+         $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+ \n++            /*\n+             /// Lanewise saturating add.\n+             ///\n+             /// # Examples\n+@@ -38,6 +39,7 @@ macro_rules! impl_uint_arith {\n+             pub fn saturating_sub(self, second: Self) -> Self {\n+                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n+             }\n++            */\n+         })+\n+     }\n+ }\n+@@ -46,6 +48,7 @@ macro_rules! impl_int_arith {\n+     ($(($name:ident, $n:ident)),+) => {\n+         $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+ \n++            /*\n+             /// Lanewise saturating add.\n+             ///\n+             /// # Examples\n+@@ -141,6 +144,7 @@ macro_rules! impl_int_arith {\n+             pub fn saturating_neg(self) -> Self {\n+                 Self::splat(0).saturating_sub(self)\n+             }\n++            */\n+         })+\n+     }\n+ }\n+diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n+index 61d8e44..2bccae2 100644\n+--- a/crates/core_simd/tests/masks.rs\n++++ b/crates/core_simd/tests/masks.rs\n+@@ -67,18 +67,6 @@ macro_rules! test_mask_api {\n+                 assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n+                 assert_eq!(core_simd::$name::<8>::from_int(int), mask);\n+             }\n+-\n+-            #[test]\n+-            fn roundtrip_bitmask_conversion() {\n+-                let values = [\n+-                    true, false, false, true, false, false, true, false,\n+-                    true, true, false, false, false, false, false, true,\n+-                ];\n+-                let mask = core_simd::$name::<16>::from_array(values);\n+-                let bitmask = mask.to_bitmask();\n+-                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+-                assert_eq!(core_simd::$name::<16>::from_bitmask(bitmask), mask);\n+-            }\n+         }\n+     }\n+ }\n+diff --git a/crates/core_simd/tests/ops_macros.rs b/crates/core_simd/tests/ops_macros.rs\n+index cb39e73..fc0ebe1 100644\n+--- a/crates/core_simd/tests/ops_macros.rs\n++++ b/crates/core_simd/tests/ops_macros.rs\n+@@ -435,6 +435,7 @@ macro_rules! impl_float_tests {\n+                     )\n+                 }\n+ \n++                /*\n+                 fn mul_add<const LANES: usize>() {\n+                     test_helpers::test_ternary_elementwise(\n+                         &Vector::<LANES>::mul_add,\n+@@ -442,6 +443,7 @@ macro_rules! impl_float_tests {\n+                         &|_, _, _| true,\n+                     )\n+                 }\n++                */\n+ \n+                 fn sqrt<const LANES: usize>() {\n+                     test_helpers::test_unary_elementwise(\n+@@ -581,6 +585,7 @@ macro_rules! impl_float_tests {\n+                     });\n+                 }\n+ \n++                /*\n+                 fn horizontal_max<const LANES: usize>() {\n+                     test_helpers::test_1(&|x| {\n+                         let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+@@ -604,6 +609,7 @@ macro_rules! impl_float_tests {\n+                         Ok(())\n+                     });\n+                 }\n++                */\n+             }\n+         }\n+     }\n+diff --git a/crates/core_simd/tests/round.rs b/crates/core_simd/tests/round.rs\n+index 37044a7..4cdc6b7 100644\n+--- a/crates/core_simd/tests/round.rs\n++++ b/crates/core_simd/tests/round.rs\n+@@ -25,6 +25,7 @@ macro_rules! float_rounding_test {\n+                     )\n+                 }\n+ \n++                /*\n+                 fn round<const LANES: usize>() {\n+                     test_helpers::test_unary_elementwise(\n+                         &Vector::<LANES>::round,\n+@@ -32,6 +33,7 @@ macro_rules! float_rounding_test {\n+                         &|_| true,\n+                     )\n+                 }\n++                */\n+ \n+                 fn trunc<const LANES: usize>() {\n+                     test_helpers::test_unary_elementwise(\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "25a315f666e27c0906bdcec9e69c25338c2dffcf", "filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -51,14 +51,14 @@ index 1a6be3a..42dbd59 100644\n  #[test]\n  #[allow(warnings)]\n  // Have a symbol for the test below. It doesn\u2019t need to be an actual variadic function, match the\n-@@ -289,6 +290,7 @@ fn write_unaligned_drop() {\n-     }\n-     DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n+@@ -277,6 +277,7 @@ pub fn test_variadic_fnptr() {\n+     let mut s = SipHasher::new();\n+     assert_eq!(p.hash(&mut s), q.hash(&mut s));\n  }\n +*/\n  \n  #[test]\n- fn align_offset_zst() {\n+ fn write_unaligned_drop() {\n diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n index 6609bc3..241b497 100644\n --- a/library/core/tests/slice.rs"}, {"sha": "50ef0bd9418c74f8a760ca8b80629edc223be08c", "filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -46,45 +46,5 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n-diff --git a/library/core/tests/num/mod.rs b/library/core/tests/num/mod.rs\n-index a17c094..5bb11d2 100644\n---- a/library/core/tests/num/mod.rs\n-+++ b/library/core/tests/num/mod.rs\n-@@ -651,11 +651,12 @@ macro_rules! test_float {\n-                 assert_eq!((9.0 as $fty).min($neginf), $neginf);\n-                 assert_eq!(($neginf as $fty).min(-9.0), $neginf);\n-                 assert_eq!((-9.0 as $fty).min($neginf), $neginf);\n--                assert_eq!(($nan as $fty).min(9.0), 9.0);\n--                assert_eq!(($nan as $fty).min(-9.0), -9.0);\n--                assert_eq!((9.0 as $fty).min($nan), 9.0);\n--                assert_eq!((-9.0 as $fty).min($nan), -9.0);\n--                assert!(($nan as $fty).min($nan).is_nan());\n-+                // Cranelift fmin has NaN propagation\n-+                //assert_eq!(($nan as $fty).min(9.0), 9.0);\n-+                //assert_eq!(($nan as $fty).min(-9.0), -9.0);\n-+                //assert_eq!((9.0 as $fty).min($nan), 9.0);\n-+                //assert_eq!((-9.0 as $fty).min($nan), -9.0);\n-+                //assert!(($nan as $fty).min($nan).is_nan());\n-             }\n-             #[test]\n-             fn max() {\n-@@ -673,11 +674,12 @@ macro_rules! test_float {\n-                 assert_eq!((9.0 as $fty).max($neginf), 9.0);\n-                 assert_eq!(($neginf as $fty).max(-9.0), -9.0);\n-                 assert_eq!((-9.0 as $fty).max($neginf), -9.0);\n--                assert_eq!(($nan as $fty).max(9.0), 9.0);\n--                assert_eq!(($nan as $fty).max(-9.0), -9.0);\n--                assert_eq!((9.0 as $fty).max($nan), 9.0);\n--                assert_eq!((-9.0 as $fty).max($nan), -9.0);\n--                assert!(($nan as $fty).max($nan).is_nan());\n-+                // Cranelift fmax has NaN propagation\n-+                //assert_eq!(($nan as $fty).max(9.0), 9.0);\n-+                //assert_eq!(($nan as $fty).max(-9.0), -9.0);\n-+                //assert_eq!((9.0 as $fty).max($nan), 9.0);\n-+                //assert_eq!((-9.0 as $fty).max($nan), -9.0);\n-+                //assert!(($nan as $fty).max($nan).is_nan());\n-             }\n-             #[test]\n-             fn rem_euclid() {\n -- \n 2.21.0 (Apple Git-122)"}, {"sha": "cda8153083c337fd004cf2e3d5c0ac631156fd19", "filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -1,20 +1,44 @@\n-From 894e07dfec2624ba539129b1c1d63e1d7d812bda Mon Sep 17 00:00:00 2001\n+From 6a4e6f5dc8c8a529a822eb9b57f9e57519595439 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Thu, 18 Feb 2021 18:45:28 +0100\n Subject: [PATCH] Disable 128bit atomic operations\n \n Cranelift doesn't support them yet\n ---\n- library/core/src/sync/atomic.rs | 38 ---------------------------------\n- library/core/tests/atomic.rs    |  4 ----\n- library/std/src/panic.rs        |  6 ------\n+ library/core/src/panic/unwind_safe.rs |  6 -----\n+ library/core/src/sync/atomic.rs       | 38 ---------------------------\n+ library/core/tests/atomic.rs          |  4 ---\n  3 files changed, 48 deletions(-)\n \n+diff --git a/library/core/src/panic/unwind_safe.rs b/library/core/src/panic/unwind_safe.rs\n+index 092b7cf..158cf71 100644\n+--- a/library/core/src/panic/unwind_safe.rs\n++++ b/library/core/src/panic/unwind_safe.rs\n+@@ -216,9 +216,6 @@ impl RefUnwindSafe for crate::sync::atomic::AtomicI32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for crate::sync::atomic::AtomicI64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for crate::sync::atomic::AtomicI128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"ptr\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+@@ -235,9 +232,6 @@ impl RefUnwindSafe for crate::sync::atomic::AtomicU32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for crate::sync::atomic::AtomicU64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for crate::sync::atomic::AtomicU128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"8\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n diff --git a/library/core/src/sync/atomic.rs b/library/core/src/sync/atomic.rs\n-index 81c9e1d..65c9503 100644\n+index 0194c58..25a0038 100644\n --- a/library/core/src/sync/atomic.rs\n +++ b/library/core/src/sync/atomic.rs\n-@@ -2228,44 +2228,6 @@ atomic_int! {\n+@@ -2229,44 +2229,6 @@ atomic_int! {\n      \"AtomicU64::new(0)\",\n      u64 AtomicU64 ATOMIC_U64_INIT\n  }\n@@ -60,10 +84,10 @@ index 81c9e1d..65c9503 100644\n  macro_rules! atomic_int_ptr_sized {\n      ( $($target_pointer_width:literal $align:literal)* ) => { $(\n diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n-index 2d1e449..cb6da5d 100644\n+index b735957..ea728b6 100644\n --- a/library/core/tests/atomic.rs\n +++ b/library/core/tests/atomic.rs\n-@@ -145,10 +145,6 @@ fn atomic_alignment() {\n+@@ -185,10 +185,6 @@ fn atomic_alignment() {\n      assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n      #[cfg(target_has_atomic = \"64\")]\n      assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n@@ -74,30 +98,6 @@ index 2d1e449..cb6da5d 100644\n      #[cfg(target_has_atomic = \"ptr\")]\n      assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n      #[cfg(target_has_atomic = \"ptr\")]\n-diff --git a/library/std/src/panic.rs b/library/std/src/panic.rs\n-index 89a822a..779fd88 100644\n---- a/library/std/src/panic.rs\n-+++ b/library/std/src/panic.rs\n-@@ -279,9 +279,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}\n- #[cfg(target_has_atomic_load_store = \"64\")]\n- #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n- impl RefUnwindSafe for atomic::AtomicI64 {}\n--#[cfg(target_has_atomic_load_store = \"128\")]\n--#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n--impl RefUnwindSafe for atomic::AtomicI128 {}\n- \n- #[cfg(target_has_atomic_load_store = \"ptr\")]\n- #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-@@ -298,9 +295,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}\n- #[cfg(target_has_atomic_load_store = \"64\")]\n- #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n- impl RefUnwindSafe for atomic::AtomicU64 {}\n--#[cfg(target_has_atomic_load_store = \"128\")]\n--#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n--impl RefUnwindSafe for atomic::AtomicU128 {}\n- \n- #[cfg(target_has_atomic_load_store = \"8\")]\n- #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n -- \n 2.26.2.7.g19db9cfb68\n "}, {"sha": "f074ebe7a42e0dabf88c234aadb2ebcf9896ef64", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-07-07\"\n+channel = \"nightly-2021-08-05\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "89ec8da77d3ec5f6a1ade1ba67fe7aeb7500bac6", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -44,7 +44,11 @@ fn main() {\n             );\n             std::array::IntoIter::new([\"rustc\".to_string()])\n                 .chain(env::args().skip(2))\n-                .chain([\"--\".to_string(), \"-Cllvm-args=mode=jit\".to_string()])\n+                .chain([\n+                    \"--\".to_string(),\n+                    \"-Zunstable-features\".to_string(),\n+                    \"-Cllvm-args=mode=jit\".to_string(),\n+                ])\n                 .collect()\n         }\n         Some(\"lazy-jit\") => {\n@@ -54,7 +58,11 @@ fn main() {\n             );\n             std::array::IntoIter::new([\"rustc\".to_string()])\n                 .chain(env::args().skip(2))\n-                .chain([\"--\".to_string(), \"-Cllvm-args=mode=jit-lazy\".to_string()])\n+                .chain([\n+                    \"--\".to_string(),\n+                    \"-Zunstable-features\".to_string(),\n+                    \"-Cllvm-args=mode=jit-lazy\".to_string(),\n+                ])\n                 .collect()\n         }\n         _ => env::args().skip(1).collect(),"}, {"sha": "c4801a0a87b886feef8df77275caf0113f7c8f72", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -5,7 +5,7 @@ pushd $(dirname \"$0\")/../\n source scripts/config.sh\n RUSTC=\"$(pwd)/build/bin/cg_clif\"\n popd\n-PROFILE=$1 OUTPUT=$2 exec $RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic $0\n+PROFILE=$1 OUTPUT=$2 exec $RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic $0\n #*/\n \n //! This program filters away uninteresting samples and trims uninteresting frames for stackcollapse"}, {"sha": "ca83e7096b86db354e50a19eab683b90f1da36a2", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -33,7 +33,7 @@ index d95b5b7f17f..00b6f0e3635 100644\n  [dependencies]\n  core = { path = \"../core\" }\n -compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std'] }\n-+compiler_builtins = { version = \"0.1.45\", features = ['rustc-dep-of-std', 'no-asm'] }\n++compiler_builtins = { version = \"0.1.46\", features = ['rustc-dep-of-std', 'no-asm'] }\n \n  [dev-dependencies]\n  rand = \"0.7\""}, {"sha": "0ac49dd35740f51e36f1a7ba9265a5ef1f63f0cf", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -79,7 +79,6 @@ rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux\n \n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n rm src/test/ui/cfg/cfg-panic.rs\n-rm src/test/ui/default-alloc-error-hook.rs\n rm -r src/test/ui/hygiene/\n \n rm -r src/test/ui/polymorphization/ # polymorphization not yet supported"}, {"sha": "0eef710239bdd456e90df4ce7f69a8f2d5832a6b", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -16,10 +16,10 @@ function no_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n \n         echo \"[JIT-lazy] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] mini_core_hello_world (skipped)\"\n     fi\n@@ -44,10 +44,10 @@ function base_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] std_example\"\n-        $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n+        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n \n         echo \"[JIT-lazy] std_example\"\n-        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n+        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] std_example (skipped)\"\n     fi\n@@ -136,6 +136,15 @@ function extended_sysroot_tests() {\n         ../build/cargo build --tests --target $TARGET_TRIPLE\n     fi\n     popd\n+\n+    pushd stdsimd\n+    echo \"[TEST] rust-lang/stdsimd\"\n+    ../build/cargo clean\n+    ../build/cargo build --all-targets --target $TARGET_TRIPLE\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        ../build/cargo test -q\n+    fi\n+    popd\n }\n \n case \"$1\" in"}, {"sha": "13790409e59f633f28292f8e2c3709f189e37806", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 119, "deletions": 111, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -9,13 +9,12 @@ use rustc_middle::ty::layout::FnAbiExt;\n use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n-use cranelift_codegen::ir::AbiParam;\n-use smallvec::smallvec;\n+use cranelift_codegen::ir::{AbiParam, SigRef};\n \n use self::pass_mode::*;\n use crate::prelude::*;\n \n-pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n+pub(crate) use self::returning::codegen_return;\n \n fn clif_sig_from_fn_abi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -236,27 +235,20 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n         // not mutated by the current function, this is necessary to support unsized arguments.\n         if let ArgKind::Normal(Some(val)) = arg_kind {\n             if let Some((addr, meta)) = val.try_to_ptr() {\n-                let local_decl = &fx.mir.local_decls[local];\n-                //                       v this ! is important\n-                let internally_mutable = !val\n-                    .layout()\n-                    .ty\n-                    .is_freeze(fx.tcx.at(local_decl.source_info.span), ParamEnv::reveal_all());\n-                if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n-                    // We wont mutate this argument, so it is fine to borrow the backing storage\n-                    // of this argument, to prevent a copy.\n-\n-                    let place = if let Some(meta) = meta {\n-                        CPlace::for_ptr_with_extra(addr, meta, val.layout())\n-                    } else {\n-                        CPlace::for_ptr(addr, val.layout())\n-                    };\n-\n-                    self::comments::add_local_place_comments(fx, place, local);\n-\n-                    assert_eq!(fx.local_map.push(place), local);\n-                    continue;\n-                }\n+                // Ownership of the value at the backing storage for an argument is passed to the\n+                // callee per the ABI, so it is fine to borrow the backing storage of this argument\n+                // to prevent a copy.\n+\n+                let place = if let Some(meta) = meta {\n+                    CPlace::for_ptr_with_extra(addr, meta, val.layout())\n+                } else {\n+                    CPlace::for_ptr(addr, val.layout())\n+                };\n+\n+                self::comments::add_local_place_comments(fx, place, local);\n+\n+                assert_eq!(fx.local_map.push(place), local);\n+                continue;\n             }\n         }\n \n@@ -292,6 +284,22 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     fx.bcx.ins().jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n }\n \n+struct CallArgument<'tcx> {\n+    value: CValue<'tcx>,\n+    is_owned: bool,\n+}\n+\n+// FIXME avoid intermediate `CValue` before calling `adjust_arg_for_abi`\n+fn codegen_call_argument_operand<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    operand: &Operand<'tcx>,\n+) -> CallArgument<'tcx> {\n+    CallArgument {\n+        value: codegen_operand(fx, operand),\n+        is_owned: matches!(operand, Operand::Move(_)),\n+    }\n+}\n+\n pub(crate) fn codegen_terminator_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n@@ -360,131 +368,131 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     }\n \n     // Unpack arguments tuple for closures\n-    let args = if fn_sig.abi == Abi::RustCall {\n+    let mut args = if fn_sig.abi == Abi::RustCall {\n         assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n-        let self_arg = codegen_operand(fx, &args[0]);\n-        let pack_arg = codegen_operand(fx, &args[1]);\n+        let self_arg = codegen_call_argument_operand(fx, &args[0]);\n+        let pack_arg = codegen_call_argument_operand(fx, &args[1]);\n \n-        let tupled_arguments = match pack_arg.layout().ty.kind() {\n+        let tupled_arguments = match pack_arg.value.layout().ty.kind() {\n             ty::Tuple(ref tupled_arguments) => tupled_arguments,\n             _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n         };\n \n         let mut args = Vec::with_capacity(1 + tupled_arguments.len());\n         args.push(self_arg);\n         for i in 0..tupled_arguments.len() {\n-            args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n+            args.push(CallArgument {\n+                value: pack_arg.value.value_field(fx, mir::Field::new(i)),\n+                is_owned: pack_arg.is_owned,\n+            });\n         }\n         args\n     } else {\n-        args.iter().map(|arg| codegen_operand(fx, arg)).collect::<Vec<_>>()\n+        args.iter().map(|arg| codegen_call_argument_operand(fx, arg)).collect::<Vec<_>>()\n     };\n \n-    //   | indirect call target\n-    //   |         | the first argument to be passed\n-    //   v         v\n-    let (func_ref, first_arg) = match instance {\n+    // Pass the caller location for `#[track_caller]`.\n+    if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n+        let caller_location = fx.get_caller_location(span);\n+        args.push(CallArgument { value: caller_location, is_owned: false });\n+    }\n+\n+    let args = args;\n+    assert_eq!(fn_abi.args.len(), args.len());\n+\n+    enum CallTarget {\n+        Direct(FuncRef),\n+        Indirect(SigRef, Value),\n+    }\n+\n+    let (func_ref, first_arg_override) = match instance {\n         // Trait object call\n         Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n             if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n-                    format!(\"virtual call; self arg pass mode: {:?}\", &fn_abi.args[0],),\n+                    format!(\"virtual call; self arg pass mode: {:?}\", &fn_abi.args[0]),\n                 );\n             }\n-            let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n-            (Some(method), smallvec![ptr])\n+\n+            let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0].value, idx);\n+            let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n+            let sig = fx.bcx.import_signature(sig);\n+\n+            (CallTarget::Indirect(sig, method), Some(ptr))\n         }\n \n         // Normal call\n-        Some(_) => (\n-            None,\n-            args.get(0)\n-                .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n-                .unwrap_or(smallvec![]),\n-        ),\n+        Some(instance) => {\n+            let func_ref = fx.get_function_ref(instance);\n+            (CallTarget::Direct(func_ref), None)\n+        }\n \n         // Indirect call\n         None => {\n             if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n+\n             let func = codegen_operand(fx, func).load_scalar(fx);\n-            (\n-                Some(func),\n-                args.get(0)\n-                    .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n-                    .unwrap_or(smallvec![]),\n-            )\n+            let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n+            let sig = fx.bcx.import_signature(sig);\n+\n+            (CallTarget::Indirect(sig, func), None)\n         }\n     };\n \n     let ret_place = destination.map(|(place, _)| place);\n-    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(\n-        fx,\n-        &fn_abi.ret,\n-        ret_place,\n-        |fx, return_ptr| {\n-            let regular_args_count = args.len();\n-            let mut call_args: Vec<Value> = return_ptr\n-                .into_iter()\n-                .chain(first_arg.into_iter())\n-                .chain(\n-                    args.into_iter()\n-                        .enumerate()\n-                        .skip(1)\n-                        .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n-                        .flatten(),\n-                )\n-                .collect::<Vec<_>>();\n-\n-            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n-                // Pass the caller location for `#[track_caller]`.\n-                let caller_location = fx.get_caller_location(span);\n-                call_args.extend(\n-                    adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n-                        .into_iter(),\n-                );\n-                assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n-            } else {\n-                assert_eq!(fn_abi.args.len(), regular_args_count);\n+    self::returning::codegen_with_call_return_arg(fx, &fn_abi.ret, ret_place, |fx, return_ptr| {\n+        let call_args = return_ptr\n+            .into_iter()\n+            .chain(first_arg_override.into_iter())\n+            .chain(\n+                args.into_iter()\n+                    .enumerate()\n+                    .skip(if first_arg_override.is_some() { 1 } else { 0 })\n+                    .map(|(i, arg)| {\n+                        adjust_arg_for_abi(fx, arg.value, &fn_abi.args[i], arg.is_owned).into_iter()\n+                    })\n+                    .flatten(),\n+            )\n+            .collect::<Vec<Value>>();\n+\n+        let call_inst = match func_ref {\n+            CallTarget::Direct(func_ref) => fx.bcx.ins().call(func_ref, &call_args),\n+            CallTarget::Indirect(sig, func_ptr) => {\n+                fx.bcx.ins().call_indirect(sig, func_ptr, &call_args)\n             }\n+        };\n \n-            let call_inst = if let Some(func_ref) = func_ref {\n-                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n-                let sig = fx.bcx.import_signature(sig);\n-                fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n-            } else {\n-                let func_ref =\n-                    fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n-                fx.bcx.ins().call(func_ref, &call_args)\n-            };\n-\n-            (call_inst, call_args)\n-        },\n-    );\n-\n-    // FIXME find a cleaner way to support varargs\n-    if fn_sig.c_variadic {\n-        if !matches!(fn_sig.abi, Abi::C { .. }) {\n-            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+        // FIXME find a cleaner way to support varargs\n+        if fn_sig.c_variadic {\n+            if !matches!(fn_sig.abi, Abi::C { .. }) {\n+                fx.tcx\n+                    .sess\n+                    .span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+            }\n+            let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n+            let abi_params = call_args\n+                .into_iter()\n+                .map(|arg| {\n+                    let ty = fx.bcx.func.dfg.value_type(arg);\n+                    if !ty.is_int() {\n+                        // FIXME set %al to upperbound on float args once floats are supported\n+                        fx.tcx\n+                            .sess\n+                            .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    }\n+                    AbiParam::new(ty)\n+                })\n+                .collect::<Vec<AbiParam>>();\n+            fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n         }\n-        let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n-        let abi_params = call_args\n-            .into_iter()\n-            .map(|arg| {\n-                let ty = fx.bcx.func.dfg.value_type(arg);\n-                if !ty.is_int() {\n-                    // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n-                }\n-                AbiParam::new(ty)\n-            })\n-            .collect::<Vec<AbiParam>>();\n-        fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n-    }\n+\n+        call_inst\n+    });\n \n     if let Some((_, dest)) = destination {\n         let ret_block = fx.get_block(dest);\n@@ -535,15 +543,15 @@ pub(crate) fn codegen_drop<'tcx>(\n                         TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );\n-                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);\n+                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0], true);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n                 if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n                     call_args.extend(\n-                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1]).into_iter(),\n+                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1], false).into_iter(),\n                     );\n                 }\n "}, {"sha": "44eae706ea8f6df56448214f8afab5383bc67ade", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -227,6 +227,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    is_owned: bool,\n ) -> SmallVec<[Value; 2]> {\n     assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n     match arg_abi.mode {\n@@ -237,10 +238,21 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             smallvec![a, b]\n         }\n         PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n-        PassMode::Indirect { .. } => match arg.force_stack(fx) {\n-            (ptr, None) => smallvec![ptr.get_addr(fx)],\n-            (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n-        },\n+        PassMode::Indirect { .. } => {\n+            if is_owned {\n+                match arg.force_stack(fx) {\n+                    (ptr, None) => smallvec![ptr.get_addr(fx)],\n+                    (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n+                }\n+            } else {\n+                // Ownership of the value at the backing storage for an argument is passed to the\n+                // callee per the ABI, so we must make a copy of the argument unless the argument\n+                // local is moved.\n+                let place = CPlace::new_stack_slot(fx, arg.layout());\n+                place.write_cvalue(fx, arg);\n+                smallvec![place.to_ptr().get_addr(fx)]\n+            }\n+        }\n     }\n }\n "}, {"sha": "c1bdba43e6ccb4e65e622d66bbf358729c701aff", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 29, "deletions": 61, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -2,54 +2,9 @@\n \n use crate::prelude::*;\n \n-use rustc_middle::ty::layout::FnAbiExt;\n-use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use rustc_target::abi::call::{ArgAbi, PassMode};\n use smallvec::{smallvec, SmallVec};\n \n-/// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n-pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    fx: &FunctionCx<'_, '_, 'tcx>,\n-    func: &mir::Operand<'tcx>,\n-    args: &[mir::Operand<'tcx>],\n-) -> bool {\n-    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig =\n-        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n-\n-    // Handle special calls like instrinsics and empty drop glue.\n-    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n-        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n-            .unwrap()\n-            .unwrap()\n-            .polymorphize(fx.tcx);\n-\n-        match instance.def {\n-            InstanceDef::Intrinsic(_) | InstanceDef::DropGlue(_, _) => {\n-                return true;\n-            }\n-            _ => Some(instance),\n-        }\n-    } else {\n-        None\n-    };\n-\n-    let extra_args = &args[fn_sig.inputs().len()..];\n-    let extra_args = extra_args\n-        .iter()\n-        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n-        .collect::<Vec<_>>();\n-    let fn_abi = if let Some(instance) = instance {\n-        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n-    } else {\n-        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n-    };\n-    match fn_abi.ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n-        // FIXME Make it possible to return Cast and Indirect to an ssa var.\n-        PassMode::Cast(_) | PassMode::Indirect { .. } => false,\n-    }\n-}\n-\n /// Return a place where the return value of the current function can be written to. If necessary\n /// this adds an extra parameter pointing to where the return value needs to be stored.\n pub(super) fn codegen_return_param<'tcx>(\n@@ -58,8 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore => (CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout), smallvec![]),\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -73,7 +27,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             let ret_param = block_params_iter.next().unwrap();\n-            assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n+            assert_eq!(fx.bcx.func.dfg.value_type(ret_param), fx.pointer_type);\n             (\n                 CPlace::for_ptr(Pointer::new(ret_param), fx.fn_abi.as_ref().unwrap().ret.layout),\n                 smallvec![ret_param],\n@@ -99,25 +53,33 @@ pub(super) fn codegen_return_param<'tcx>(\n \n /// Invokes the closure with if necessary a value representing the return pointer. When the closure\n /// returns the call return value(s) if any are written to the correct place.\n-pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n+pub(super) fn codegen_with_call_return_arg<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n-    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> (Inst, T),\n-) -> (Inst, T) {\n-    let return_ptr = match ret_arg_abi.mode {\n-        PassMode::Ignore => None,\n+    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> Inst,\n+) {\n+    let (ret_temp_place, return_ptr) = match ret_arg_abi.mode {\n+        PassMode::Ignore => (None, None),\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n-            Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n-            None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n+            Some(ret_place) if matches!(ret_place.inner(), CPlaceInner::Addr(_, None)) => {\n+                // This is an optimization to prevent unnecessary copies of the return value when\n+                // the return place is already a memory place as opposed to a register.\n+                // This match arm can be safely removed.\n+                (None, Some(ret_place.to_ptr().get_addr(fx)))\n+            }\n+            _ => {\n+                let place = CPlace::new_stack_slot(fx, ret_arg_abi.layout);\n+                (Some(place), Some(place.to_ptr().get_addr(fx)))\n+            }\n         },\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n     };\n \n-    let (call_inst, meta) = f(fx, return_ptr);\n+    let call_inst = f(fx, return_ptr);\n \n     match ret_arg_abi.mode {\n         PassMode::Ignore => {}\n@@ -150,13 +112,19 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n                 ret_place.write_cvalue(fx, result);\n             }\n         }\n-        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {}\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+            if let (Some(ret_place), Some(ret_temp_place)) = (ret_place, ret_temp_place) {\n+                // Both ret_place and ret_temp_place must be Some. If ret_place is None, this is\n+                // a non-returning call. If ret_temp_place is None, it is not necessary to copy the\n+                // return value.\n+                let ret_temp_value = ret_temp_place.to_cvalue(fx);\n+                ret_place.write_cvalue(fx, ret_temp_value);\n+            }\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n     }\n-\n-    (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any."}, {"sha": "637d30f9344f98b6f7c77a0fc46cb2a910ff8b49", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -5,7 +5,6 @@ use crate::prelude::*;\n \n use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n-use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -20,7 +19,7 @@ pub(crate) fn codegen(\n     if any_dynamic_crate {\n         false\n     } else if let Some(kind) = tcx.allocator_kind(()) {\n-        codegen_inner(module, unwind_context, kind);\n+        codegen_inner(module, unwind_context, kind, tcx.lang_items().oom().is_some());\n         true\n     } else {\n         false\n@@ -31,6 +30,7 @@ fn codegen_inner(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n+    has_alloc_error_handler: bool,\n ) {\n     let usize_ty = module.target_config().pointer_type();\n \n@@ -65,7 +65,6 @@ fn codegen_inner(\n \n         let caller_name = format!(\"__rust_{}\", method.name);\n         let callee_name = kind.fn_name(method.name);\n-        //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n         let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n \n@@ -104,13 +103,12 @@ fn codegen_inner(\n         returns: vec![],\n     };\n \n-    let callee_name = kind.fn_name(sym::oom);\n-    //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n+    let callee_name = if has_alloc_error_handler { \"__rg_oom\" } else { \"__rdl_oom\" };\n \n     let func_id =\n         module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n+    let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);"}, {"sha": "35b89358b1984ee40a2c184a38753987ffbd46f7", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -38,17 +38,6 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n                 _ => {}\n             }\n         }\n-\n-        match &bb.terminator().kind {\n-            TerminatorKind::Call { destination, func, args, .. } => {\n-                if let Some((dest_place, _dest_bb)) = destination {\n-                    if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n-                        not_ssa(&mut flag_map, dest_place.local)\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n     }\n \n     flag_map"}, {"sha": "e99a227a3a6eafc49b7156bc0fd0582e00ab8ff8", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -334,8 +334,6 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                         crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n                     let test_zero = if is_inverted { !test_zero } else { test_zero };\n                     let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n-                    let discr =\n-                        crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n                     if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n                         &fx.bcx, discr, test_zero,\n                     ) {"}, {"sha": "e7e6afeb865bb005bf436b7ec6e2802930dc7fe2", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -14,21 +14,6 @@ pub(crate) fn clif_intcast(\n         (_, _) if from == to => val,\n \n         // extend\n-        (_, types::I128) => {\n-            let lo = if from == types::I64 {\n-                val\n-            } else if signed {\n-                fx.bcx.ins().sextend(types::I64, val)\n-            } else {\n-                fx.bcx.ins().uextend(types::I64, val)\n-            };\n-            let hi = if signed {\n-                fx.bcx.ins().sshr_imm(lo, 63)\n-            } else {\n-                fx.bcx.ins().iconst(types::I64, 0)\n-            };\n-            fx.bcx.ins().iconcat(lo, hi)\n-        }\n         (_, _) if to.wider_or_equal(from) => {\n             if signed {\n                 fx.bcx.ins().sextend(to, val)\n@@ -38,10 +23,6 @@ pub(crate) fn clif_intcast(\n         }\n \n         // reduce\n-        (types::I128, _) => {\n-            let (lsb, _msb) = fx.bcx.ins().isplit(val);\n-            if to == types::I64 { lsb } else { fx.bcx.ins().ireduce(to, lsb) }\n-        }\n         (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n }"}, {"sha": "638b2d573b5ddbe00ae715e12417cde097f12072", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 51, "deletions": 65, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -19,9 +19,6 @@ pub(crate) fn maybe_codegen<'tcx>(\n         return None;\n     }\n \n-    let lhs_val = lhs.load_scalar(fx);\n-    let rhs_val = rhs.load_scalar(fx);\n-\n     let is_signed = type_sign(lhs.layout().ty);\n \n     match bin_op {\n@@ -30,29 +27,53 @@ pub(crate) fn maybe_codegen<'tcx>(\n             None\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Mul if !checked => {\n-            let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-            if fx.tcx.sess.target.is_like_windows {\n-                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                let args =\n-                    [ret_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n-                fx.lib_call(\n-                    \"__multi3\",\n+        BinOp::Mul if !checked || is_signed => {\n+            if !checked {\n+                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+                if fx.tcx.sess.target.is_like_windows {\n+                    let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                    let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                    let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                    assert!(lhs_extra.is_none());\n+                    assert!(rhs_extra.is_none());\n+                    let args = [\n+                        ret_place.to_ptr().get_addr(fx),\n+                        lhs_ptr.get_addr(fx),\n+                        rhs_ptr.get_addr(fx),\n+                    ];\n+                    fx.lib_call(\n+                        \"__multi3\",\n+                        vec![\n+                            AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                            AbiParam::new(fx.pointer_type),\n+                            AbiParam::new(fx.pointer_type),\n+                        ],\n+                        vec![],\n+                        &args,\n+                    );\n+                    Some(ret_place.to_cvalue(fx))\n+                } else {\n+                    Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+                }\n+            } else {\n+                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+                let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n+                let lhs = lhs.load_scalar(fx);\n+                let rhs = rhs.load_scalar(fx);\n+                let oflow_ptr = oflow.to_ptr().get_addr(fx);\n+                let res = fx.lib_call(\n+                    \"__muloti4\",\n                     vec![\n-                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n-                        AbiParam::new(pointer_ty(fx.tcx)),\n-                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(types::I128),\n+                        AbiParam::new(types::I128),\n+                        AbiParam::new(fx.pointer_type),\n                     ],\n-                    vec![],\n-                    &args,\n-                );\n-                Some(ret_place.to_cvalue(fx))\n-            } else {\n-                Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+                    vec![AbiParam::new(types::I128)],\n+                    &[lhs, rhs, oflow_ptr],\n+                )[0];\n+                let oflow = oflow.to_cvalue(fx).load_scalar(fx);\n+                let oflow = fx.bcx.ins().ireduce(types::I8, oflow);\n+                Some(CValue::by_val_pair(res, oflow, fx.layout_of(out_ty)))\n             }\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n@@ -66,16 +87,16 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 assert!(rhs_extra.is_none());\n                 (\n                     vec![\n-                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n-                        AbiParam::new(pointer_ty(fx.tcx)),\n-                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                        AbiParam::new(fx.pointer_type),\n+                        AbiParam::new(fx.pointer_type),\n                     ],\n                     [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n                 )\n             } else {\n                 (\n                     vec![\n-                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n                         AbiParam::new(types::I128),\n                         AbiParam::new(types::I128),\n                     ],\n@@ -88,7 +109,6 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 (BinOp::Sub, false) => \"__rust_u128_subo\",\n                 (BinOp::Sub, true) => \"__rust_i128_subo\",\n                 (BinOp::Mul, false) => \"__rust_u128_mulo\",\n-                (BinOp::Mul, true) => \"__rust_i128_mulo\",\n                 _ => unreachable!(),\n             };\n             fx.lib_call(name, param_types, vec![], &args);\n@@ -112,7 +132,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n                 let ret = fx.lib_call(\n                     name,\n-                    vec![AbiParam::new(pointer_ty(fx.tcx)), AbiParam::new(pointer_ty(fx.tcx))],\n+                    vec![AbiParam::new(fx.pointer_type), AbiParam::new(fx.pointer_type)],\n                     vec![AbiParam::new(types::I64X2)],\n                     &args,\n                 )[0];\n@@ -128,40 +148,6 @@ pub(crate) fn maybe_codegen<'tcx>(\n             assert!(!checked);\n             None\n         }\n-        BinOp::Shl | BinOp::Shr => {\n-            let is_overflow = if checked {\n-                // rhs >= 128\n-\n-                // FIXME support non 128bit rhs\n-                /*let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs_val);\n-                let rhs_msb_gt_0 = fx.bcx.ins().icmp_imm(IntCC::NotEqual, rhs_msb, 0);\n-                let rhs_lsb_ge_128 = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, rhs_lsb, 127);\n-                let is_overflow = fx.bcx.ins().bor(rhs_msb_gt_0, rhs_lsb_ge_128);*/\n-                let is_overflow = fx.bcx.ins().bconst(types::B1, false);\n-\n-                Some(fx.bcx.ins().bint(types::I8, is_overflow))\n-            } else {\n-                None\n-            };\n-\n-            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n-            let val = match bin_op {\n-                BinOp::Shl => fx.bcx.ins().ishl(lhs_val, truncated_rhs),\n-                BinOp::Shr => {\n-                    if is_signed {\n-                        fx.bcx.ins().sshr(lhs_val, truncated_rhs)\n-                    } else {\n-                        fx.bcx.ins().ushr(lhs_val, truncated_rhs)\n-                    }\n-                }\n-                _ => unreachable!(),\n-            };\n-            if let Some(is_overflow) = is_overflow {\n-                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n-            } else {\n-                Some(CValue::by_val(val, lhs.layout()))\n-            }\n-        }\n+        BinOp::Shl | BinOp::Shr => None,\n     }\n }"}, {"sha": "fb6ccd7c535845b85d9582de3d82f4638bc1cbe4", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -160,7 +160,7 @@ impl Writer for WriterRelocate {\n                 let val = match eh_pe.application() {\n                     gimli::DW_EH_PE_absptr => val,\n                     gimli::DW_EH_PE_pcrel => {\n-                        // TODO: better handling of sign\n+                        // FIXME better handling of sign\n                         let offset = self.len() as u64;\n                         offset.wrapping_sub(val)\n                     }"}, {"sha": "ceef65d54785fc92338045dd7e40cd9af627fa72", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> DebugContext<'tcx> {\n     pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n         let encoding = Encoding {\n             format: Format::Dwarf32,\n-            // TODO: this should be configurable\n+            // FIXME this should be configurable\n             // macOS doesn't seem to support DWARF > 3\n             // 5 version is required for md5 file hash\n             version: if tcx.sess.target.is_like_osx {"}, {"sha": "86698460747494f7a95711fe58bfada5da0a34e0", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 49, "deletions": 62, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -175,12 +175,11 @@ fn simd_for_each_lane<'tcx>(\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n-        let lane_idx = mir::Field::new(lane_idx.try_into().unwrap());\n-        let lane = val.value_field(fx, lane_idx).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n \n         let res_lane = f(fx, lane_layout, ret_lane_layout, lane);\n \n-        ret.place_field(fx, lane_idx).write_cvalue(fx, res_lane);\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n }\n \n@@ -206,37 +205,38 @@ fn simd_pair_for_each_lane<'tcx>(\n     let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n-    for lane in 0..lane_count {\n-        let lane = mir::Field::new(lane.try_into().unwrap());\n-        let x_lane = x.value_field(fx, lane).load_scalar(fx);\n-        let y_lane = y.value_field(fx, lane).load_scalar(fx);\n+    for lane_idx in 0..lane_count {\n+        let x_lane = x.value_lane(fx, lane_idx).load_scalar(fx);\n+        let y_lane = y.value_lane(fx, lane_idx).load_scalar(fx);\n \n         let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n \n-        ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n }\n \n fn simd_reduce<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n+    acc: Option<Value>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n-    let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n-    for lane_idx in 1..lane_count {\n-        let lane =\n-            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n+    let (mut res_val, start_lane) =\n+        if let Some(acc) = acc { (acc, 0) } else { (val.value_lane(fx, 0).load_scalar(fx), 1) };\n+    for lane_idx in start_lane..lane_count {\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n     ret.write_cvalue(fx, res);\n }\n \n+// FIXME move all uses to `simd_reduce`\n fn simd_reduce_bool<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n@@ -246,14 +246,18 @@ fn simd_reduce_bool<'tcx>(\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n-    let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n+    let res_val = val.value_lane(fx, 0).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane =\n-            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }\n+    let res_val = if fx.bcx.func.dfg.value_type(res_val) != types::I8 {\n+        fx.bcx.ins().ireduce(types::I8, res_val)\n+    } else {\n+        res_val\n+    };\n     let res = CValue::by_val(res_val, ret.layout());\n     ret.write_cvalue(fx, res);\n }\n@@ -288,7 +292,11 @@ macro simd_cmp {\n         if let Some(vector_ty) = vector_ty {\n             let x = $x.load_scalar($fx);\n             let y = $y.load_scalar($fx);\n-            let val = $fx.bcx.ins().icmp(IntCC::$cc, x, y);\n+            let val = if vector_ty.lane_type().is_float() {\n+                $fx.bcx.ins().fcmp(FloatCC::$cc_f, x, y)\n+            } else {\n+                $fx.bcx.ins().icmp(IntCC::$cc, x, y)\n+            };\n \n             // HACK This depends on the fact that icmp for vectors represents bools as 0 and !0, not 0 and 1.\n             let val = $fx.bcx.ins().raw_bitcast(vector_ty, val);\n@@ -603,9 +611,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n             let clif_ty = fx.clif_type(T).unwrap();\n \n-            // `select.i8` is not implemented by Cranelift.\n-            let has_overflow = fx.bcx.ins().uextend(types::I32, has_overflow);\n-\n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n             let val = match (intrinsic, signed) {\n@@ -632,21 +637,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         rotate_left, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n-            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n-                fx.bcx.ins().ireduce(types::I64, y)\n-            } else {\n-                y\n-            };\n             let res = fx.bcx.ins().rotl(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n         rotate_right, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n-            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n-                fx.bcx.ins().ireduce(types::I64, y)\n-            } else {\n-                y\n-            };\n             let res = fx.bcx.ins().rotr(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n@@ -684,35 +679,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n-            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n-                // FIXME verify this algorithm is correct\n-                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n-                let lsb_lz = fx.bcx.ins().clz(lsb);\n-                let msb_lz = fx.bcx.ins().clz(msb);\n-                let msb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, msb, 0);\n-                let lsb_lz_plus_64 = fx.bcx.ins().iadd_imm(lsb_lz, 64);\n-                let res = fx.bcx.ins().select(msb_is_zero, lsb_lz_plus_64, msb_lz);\n-                fx.bcx.ins().uextend(types::I128, res)\n-            } else {\n-                fx.bcx.ins().clz(arg)\n-            };\n+            let res = fx.bcx.ins().clz(arg);\n             let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n         cttz | cttz_nonzero, <T> (v arg) {\n             // FIXME trap on `cttz_nonzero` with zero arg.\n-            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n-                // FIXME verify this algorithm is correct\n-                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n-                let lsb_tz = fx.bcx.ins().ctz(lsb);\n-                let msb_tz = fx.bcx.ins().ctz(msb);\n-                let lsb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, lsb, 0);\n-                let msb_tz_plus_64 = fx.bcx.ins().iadd_imm(msb_tz, 64);\n-                let res = fx.bcx.ins().select(lsb_is_zero, msb_tz_plus_64, lsb_tz);\n-                fx.bcx.ins().uextend(types::I128, res)\n-            } else {\n-                fx.bcx.ins().ctz(arg)\n-            };\n+            let res = fx.bcx.ins().ctz(arg);\n             let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n@@ -995,8 +968,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-\n-        // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n         _ if intrinsic.as_str().starts_with(\"atomic_nand\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n@@ -1058,23 +1029,39 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, old);\n         };\n \n+        // In Rust floating point min and max don't propagate NaN. In Cranelift they do however.\n+        // For this reason it is necessary to use `a.is_nan() ? b : (a >= b ? b : a)` for `minnumf*`\n+        // and `a.is_nan() ? b : (a <= b ? b : a)` for `maxnumf*`. NaN checks are done by comparing\n+        // a float against itself. Only in case of NaN is it not equal to itself.\n         minnumf32, (v a, v b) {\n-            let val = fx.bcx.ins().fmin(a, b);\n+            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n+            let a_ge_b = fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, a, b);\n+            let temp = fx.bcx.ins().select(a_ge_b, b, a);\n+            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n             ret.write_cvalue(fx, val);\n         };\n         minnumf64, (v a, v b) {\n-            let val = fx.bcx.ins().fmin(a, b);\n+            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n+            let a_ge_b = fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, a, b);\n+            let temp = fx.bcx.ins().select(a_ge_b, b, a);\n+            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n             ret.write_cvalue(fx, val);\n         };\n         maxnumf32, (v a, v b) {\n-            let val = fx.bcx.ins().fmax(a, b);\n+            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n+            let a_le_b = fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, a, b);\n+            let temp = fx.bcx.ins().select(a_le_b, b, a);\n+            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n             ret.write_cvalue(fx, val);\n         };\n         maxnumf64, (v a, v b) {\n-            let val = fx.bcx.ins().fmax(a, b);\n+            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n+            let a_le_b = fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, a, b);\n+            let temp = fx.bcx.ins().select(a_le_b, b, a);\n+            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n             ret.write_cvalue(fx, val);\n         };\n@@ -1122,6 +1109,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             }\n \n             let size = fx.layout_of(T).layout.size;\n+            // FIXME add and use emit_small_memcmp\n             let is_eq_value =\n                 if size == Size::ZERO {\n                     // No bytes means they're trivially equal\n@@ -1137,10 +1125,9 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 } else {\n                     // Just call `memcmp` (like slices do in core) when the\n                     // size is too large or it's not a power-of-two.\n-                    let ptr_ty = pointer_ty(fx.tcx);\n                     let signed_bytes = i64::try_from(size.bytes()).unwrap();\n-                    let bytes_val = fx.bcx.ins().iconst(ptr_ty, signed_bytes);\n-                    let params = vec![AbiParam::new(ptr_ty); 3];\n+                    let bytes_val = fx.bcx.ins().iconst(fx.pointer_type, signed_bytes);\n+                    let params = vec![AbiParam::new(fx.pointer_type); 3];\n                     let returns = vec![AbiParam::new(types::I32)];\n                     let args = &[lhs_ref, rhs_ref, bytes_val];\n                     let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];"}, {"sha": "43e68b4afa9eac0140264ebf9259a90b77eb9599", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 170, "deletions": 20, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -108,11 +108,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n                 let in_lane = if u64::from(in_idx) < lane_count {\n-                    x.value_field(fx, mir::Field::new(in_idx.into()))\n+                    x.value_lane(fx, in_idx.into())\n                 } else {\n-                    y.value_field(fx, mir::Field::new(usize::from(in_idx) - usize::try_from(lane_count).unwrap()))\n+                    y.value_lane(fx, u64::from(in_idx) - lane_count)\n                 };\n-                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n+                let out_lane = ret.place_lane(fx, u64::try_from(out_idx).unwrap());\n                 out_lane.write_cvalue(fx, in_lane);\n             }\n         };\n@@ -163,10 +163,38 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n \n-            let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            let ret_lane = v.value_lane(fx, idx.try_into().unwrap());\n             ret.write_cvalue(fx, ret_lane);\n         };\n \n+        simd_neg, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = match lane_layout.ty.kind() {\n+                    ty::Int(_) => fx.bcx.ins().ineg(lane),\n+                    ty::Float(_) => fx.bcx.ins().fneg(lane),\n+                    _ => unreachable!(),\n+                };\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        simd_fabs, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().fabs(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        simd_fsqrt, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().sqrt(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n         simd_add, (c x, c y) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n@@ -183,6 +211,29 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n         };\n+        simd_rem, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_pair_for_each_lane(fx, x, y, ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Uint(_) => fx.bcx.ins().urem(x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().srem(x_lane, y_lane),\n+                    ty::Float(FloatTy::F32) => fx.lib_call(\n+                        \"fmodf\",\n+                        vec![AbiParam::new(types::F32), AbiParam::new(types::F32)],\n+                        vec![AbiParam::new(types::F32)],\n+                        &[x_lane, y_lane],\n+                    )[0],\n+                    ty::Float(FloatTy::F64) => fx.lib_call(\n+                        \"fmod\",\n+                        vec![AbiParam::new(types::F64), AbiParam::new(types::F64)],\n+                        vec![AbiParam::new(types::F64)],\n+                        &[x_lane, y_lane],\n+                    )[0],\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            });\n+        };\n         simd_shl, (c x, c y) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, ishl(x, y) -> ret);\n@@ -216,15 +267,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             let ret_lane_layout = fx.layout_of(ret_lane_ty);\n \n             for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.try_into().unwrap());\n-                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n-                let b_lane = b.value_field(fx, lane).load_scalar(fx);\n-                let c_lane = c.value_field(fx, lane).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_lane(fx, lane).load_scalar(fx);\n \n                 let mul_lane = fx.bcx.ins().fmul(a_lane, b_lane);\n                 let res_lane = CValue::by_val(fx.bcx.ins().fadd(mul_lane, c_lane), ret_lane_layout);\n \n-                ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n             }\n         };\n \n@@ -237,9 +287,52 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             simd_flt_binop!(fx, fmax(x, y) -> ret);\n         };\n \n-        simd_reduce_add_ordered | simd_reduce_add_unordered, (c v) {\n+        simd_round, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Float(FloatTy::F32) => fx.lib_call(\n+                        \"roundf\",\n+                        vec![AbiParam::new(types::F32)],\n+                        vec![AbiParam::new(types::F32)],\n+                        &[lane],\n+                    )[0],\n+                    ty::Float(FloatTy::F64) => fx.lib_call(\n+                        \"round\",\n+                        vec![AbiParam::new(types::F64)],\n+                        vec![AbiParam::new(types::F64)],\n+                        &[lane],\n+                    )[0],\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            });\n+        };\n+        simd_ceil, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().ceil(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+        simd_floor, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().floor(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+        simd_trunc, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().trunc(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        simd_reduce_add_ordered | simd_reduce_add_unordered, (c v, v acc) {\n             validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, ret, |fx, lane_layout, a, b| {\n+            simd_reduce(fx, v, Some(acc), ret, |fx, lane_layout, a, b| {\n                 if lane_layout.ty.is_floating_point() {\n                     fx.bcx.ins().fadd(a, b)\n                 } else {\n@@ -248,9 +341,9 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             });\n         };\n \n-        simd_reduce_mul_ordered | simd_reduce_mul_unordered, (c v) {\n+        simd_reduce_mul_ordered | simd_reduce_mul_unordered, (c v, v acc) {\n             validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, ret, |fx, lane_layout, a, b| {\n+            simd_reduce(fx, v, Some(acc), ret, |fx, lane_layout, a, b| {\n                 if lane_layout.ty.is_floating_point() {\n                     fx.bcx.ins().fmul(a, b)\n                 } else {\n@@ -269,13 +362,70 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             simd_reduce_bool(fx, v, ret, |fx, a, b| fx.bcx.ins().bor(a, b));\n         };\n \n-        // simd_fabs\n-        // simd_saturating_add\n+        simd_reduce_and, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().band(a, b));\n+        };\n+\n+        simd_reduce_or, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().bor(a, b));\n+        };\n+\n+        simd_reduce_xor, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().bxor(a, b));\n+        };\n+\n+        simd_reduce_min, (c v) {\n+            // FIXME support floats\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n+                let lt = fx.bcx.ins().icmp(if layout.ty.is_signed() {\n+                    IntCC::SignedLessThan\n+                } else {\n+                    IntCC::UnsignedLessThan\n+                }, a, b);\n+                fx.bcx.ins().select(lt, a, b)\n+            });\n+        };\n+\n+        simd_reduce_max, (c v) {\n+            // FIXME support floats\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n+                let gt = fx.bcx.ins().icmp(if layout.ty.is_signed() {\n+                    IntCC::SignedGreaterThan\n+                } else {\n+                    IntCC::UnsignedGreaterThan\n+                }, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        };\n+\n+        simd_select, (c m, c a, c b) {\n+            validate_simd_type!(fx, intrinsic, span, m.layout().ty);\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            assert_eq!(a.layout(), b.layout());\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_layout = fx.layout_of(lane_ty);\n+\n+            for lane in 0..lane_count {\n+                let m_lane = m.value_lane(fx, lane).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+\n+                let m_lane = fx.bcx.ins().icmp_imm(IntCC::Equal, m_lane, 0);\n+                let res_lane = CValue::by_val(fx.bcx.ins().select(m_lane, b_lane, a_lane), lane_layout);\n+\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n+            }\n+        };\n+\n+        // simd_saturating_*\n         // simd_bitmask\n-        // simd_select\n-        // simd_rem\n-        // simd_neg\n-        // simd_trunc\n-        // simd_floor\n+        // simd_scatter\n+        // simd_gather\n     }\n }"}, {"sha": "4ef53663ca0d95219549c88c440ecf9a0b50522a", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -184,6 +184,9 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         let config = if let Some(config) = self.config.clone() {\n             config\n         } else {\n+            if !tcx.sess.unstable_options() && !tcx.sess.opts.cg.llvm_args.is_empty() {\n+                tcx.sess.fatal(\"`-Z unstable-options` must be passed to allow configuring cg_clif\");\n+            }\n             BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n                 .unwrap_or_else(|err| tcx.sess.fatal(&err))\n         };\n@@ -217,16 +220,15 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n-            sess,\n-            &codegen_results,\n-            outputs,\n-        )\n+        link_binary::<crate::archive::ArArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n     }\n }\n \n fn target_triple(sess: &Session) -> target_lexicon::Triple {\n-    sess.target.llvm_target.parse().unwrap()\n+    match sess.target.llvm_target.parse() {\n+        Ok(triple) => triple,\n+        Err(err) => sess.fatal(&format!(\"target not recognized: {}\", err)),\n+    }\n }\n \n fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::TargetIsa + 'static> {\n@@ -276,15 +278,21 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n         Some(value) => {\n             let mut builder =\n-                cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n+                cranelift_codegen::isa::lookup_variant(target_triple.clone(), variant)\n+                    .unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n+                    });\n             if let Err(_) = builder.enable(value) {\n-                sess.fatal(\"The specified target cpu isn't currently supported by Cranelift.\");\n+                sess.fatal(\"the specified target cpu isn't currently supported by Cranelift.\");\n             }\n             builder\n         }\n         None => {\n             let mut builder =\n-                cranelift_codegen::isa::lookup_variant(target_triple.clone(), variant).unwrap();\n+                cranelift_codegen::isa::lookup_variant(target_triple.clone(), variant)\n+                    .unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n+                    });\n             if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n                 // Don't use \"haswell\" as the default, as it implies `has_lzcnt`.\n                 // macOS CI is still at Ivy Bridge EP, so `lzcnt` is interpreted as `bsr`."}, {"sha": "545d390e269957f1ef94c48b83d2c1e10b5f953f", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -67,19 +67,6 @@ pub(crate) fn codegen_binop<'tcx>(\n                     let lhs = in_lhs.load_scalar(fx);\n                     let rhs = in_rhs.load_scalar(fx);\n \n-                    let (lhs, rhs) = if (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-                        && (in_lhs.layout().ty.kind() == fx.tcx.types.i8.kind()\n-                            || in_lhs.layout().ty.kind() == fx.tcx.types.i16.kind())\n-                    {\n-                        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n-                        (\n-                            fx.bcx.ins().sextend(types::I32, lhs),\n-                            fx.bcx.ins().sextend(types::I32, rhs),\n-                        )\n-                    } else {\n-                        (lhs, rhs)\n-                    };\n-\n                     return codegen_compare_bin_op(fx, bin_op, signed, lhs, rhs);\n                 }\n                 _ => {}\n@@ -293,22 +280,20 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n         }\n         BinOp::Shl => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n-            let val = fx.bcx.ins().ishl(lhs, actual_shift);\n+            let masked_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n+            let val = fx.bcx.ins().ishl(lhs, masked_shift);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n             let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n+            let masked_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n             let val = if !signed {\n-                fx.bcx.ins().ushr(lhs, actual_shift)\n+                fx.bcx.ins().ushr(lhs, masked_shift)\n             } else {\n-                fx.bcx.ins().sshr(lhs, actual_shift)\n+                fx.bcx.ins().sshr(lhs, masked_shift)\n             };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;"}, {"sha": "d637b4d89293cea0a0a855ebb97378b111c3789b", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -1,8 +1,6 @@\n //! Peephole optimizations that can be performed while creating clif ir.\n \n-use cranelift_codegen::ir::{\n-    condcodes::IntCC, types, InstBuilder, InstructionData, Opcode, Value, ValueDef,\n-};\n+use cranelift_codegen::ir::{condcodes::IntCC, InstructionData, Opcode, Value, ValueDef};\n use cranelift_frontend::FunctionBuilder;\n \n /// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n@@ -37,43 +35,6 @@ pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n     }\n }\n \n-pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n-    if bcx.func.dfg.value_type(arg).is_bool() {\n-        return arg;\n-    }\n-\n-    (|| {\n-        let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-            arg_inst\n-        } else {\n-            return None;\n-        };\n-\n-        match bcx.func.dfg[arg_inst] {\n-            // This is the lowering of Rvalue::Not\n-            InstructionData::Load { opcode: Opcode::Load, arg: ptr, flags, offset } => {\n-                // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n-                // uextend.i32`. Just `uload8` is much faster.\n-                match bcx.func.dfg.ctrl_typevar(arg_inst) {\n-                    types::I8 => Some(bcx.ins().uload8(types::I32, flags, ptr, offset)),\n-                    types::I16 => Some(bcx.ins().uload16(types::I32, flags, ptr, offset)),\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    })()\n-    .unwrap_or_else(|| {\n-        match bcx.func.dfg.value_type(arg) {\n-            types::I8 | types::I16 => {\n-                // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n-                bcx.ins().uextend(types::I32, arg)\n-            }\n-            _ => arg,\n-        }\n-    })\n-}\n-\n /// Returns whether the branch is statically known to be taken or `None` if it isn't statically known.\n pub(crate) fn maybe_known_branch_taken(\n     bcx: &FunctionBuilder<'_>,"}, {"sha": "fe8d20fa39fc2b82f826947b4f0a5f5a150a7873", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -10,7 +10,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n             Linkage::Import,\n             &Signature {\n                 call_conv: CallConv::triple_default(fx.triple()),\n-                params: vec![AbiParam::new(pointer_ty(fx.tcx))],\n+                params: vec![AbiParam::new(fx.pointer_type)],\n                 returns: vec![AbiParam::new(types::I32)],\n             },\n         )"}, {"sha": "d9c4647cba3a98938f6e861f494e01b2ad605f6a", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -77,12 +77,10 @@ fn unsize_ptr<'tcx>(\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(!fx.layout_of(a).is_unsized());\n             (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());\n-            assert!(!fx.layout_of(a).is_unsized());\n             (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {"}, {"sha": "364b3da92b88822fe614904ce75ed44582d2a288", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 70, "deletions": 7, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -34,10 +34,10 @@ fn codegen_field<'tcx>(\n                 let (_, unsized_align) =\n                     crate::unsize::size_and_align_of_dst(fx, field_layout, extra);\n \n-                let one = fx.bcx.ins().iconst(pointer_ty(fx.tcx), 1);\n+                let one = fx.bcx.ins().iconst(fx.pointer_type, 1);\n                 let align_sub_1 = fx.bcx.ins().isub(unsized_align, one);\n                 let and_lhs = fx.bcx.ins().iadd_imm(align_sub_1, unaligned_offset as i64);\n-                let zero = fx.bcx.ins().iconst(pointer_ty(fx.tcx), 0);\n+                let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n                 let and_rhs = fx.bcx.ins().isub(zero, unsized_align);\n                 let offset = fx.bcx.ins().band(and_lhs, and_rhs);\n \n@@ -206,6 +206,38 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    /// Like [`CValue::value_field`] except handling ADTs containing a single array field in a way\n+    /// such that you can access individual lanes.\n+    pub(crate) fn value_lane(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: u64,\n+    ) -> CValue<'tcx> {\n+        let layout = self.1;\n+        assert!(layout.ty.is_simd());\n+        let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        assert!(lane_idx < lane_count);\n+        match self.0 {\n+            CValueInner::ByVal(val) => match layout.abi {\n+                Abi::Vector { element: _, count: _ } => {\n+                    assert!(lane_count <= u8::MAX.into(), \"SIMD type with more than 255 lanes???\");\n+                    let lane_idx = u8::try_from(lane_idx).unwrap();\n+                    let lane = fx.bcx.ins().extractlane(val, lane_idx);\n+                    CValue::by_val(lane, lane_layout)\n+                }\n+                _ => unreachable!(\"value_lane for ByVal with abi {:?}\", layout.abi),\n+            },\n+            CValueInner::ByValPair(_, _) => unreachable!(),\n+            CValueInner::ByRef(ptr, None) => {\n+                let field_offset = lane_layout.size * lane_idx;\n+                let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n+                CValue::by_ref(field_ptr, lane_layout)\n+            }\n+            CValueInner::ByRef(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n@@ -286,17 +318,16 @@ impl<'tcx> CPlace<'tcx> {\n         &self.inner\n     }\n \n-    pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace { inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None), layout }\n-    }\n-\n     pub(crate) fn new_stack_slot(\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         assert!(!layout.is_unsized());\n         if layout.size.bytes() == 0 {\n-            return CPlace::no_place(layout);\n+            return CPlace {\n+                inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n+                layout,\n+            };\n         }\n \n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n@@ -610,6 +641,38 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    /// Like [`CPlace::place_field`] except handling ADTs containing a single array field in a way\n+    /// such that you can access individual lanes.\n+    pub(crate) fn place_lane(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: u64,\n+    ) -> CPlace<'tcx> {\n+        let layout = self.layout();\n+        assert!(layout.ty.is_simd());\n+        let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        assert!(lane_idx < lane_count);\n+\n+        match self.inner {\n+            CPlaceInner::Var(local, var) => {\n+                assert!(matches!(layout.abi, Abi::Vector { .. }));\n+                CPlace {\n+                    inner: CPlaceInner::VarLane(local, var, lane_idx.try_into().unwrap()),\n+                    layout: lane_layout,\n+                }\n+            }\n+            CPlaceInner::VarPair(_, _, _) => unreachable!(),\n+            CPlaceInner::VarLane(_, _, _) => unreachable!(),\n+            CPlaceInner::Addr(ptr, None) => {\n+                let field_offset = lane_layout.size * lane_idx;\n+                let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n+                CPlace::for_ptr(field_ptr, lane_layout)\n+            }\n+            CPlaceInner::Addr(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     pub(crate) fn place_index(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "f97d416b66f9ff8cabf19755b97f221dd256e9ea", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -14,7 +14,7 @@ pub(crate) fn vtable_memflags() -> MemFlags {\n pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n-        pointer_ty(fx.tcx),\n+        fx.pointer_type,\n         vtable_memflags(),\n         vtable,\n         (ty::COMMON_VTABLE_ENTRIES_DROPINPLACE * usize_size) as i32,\n@@ -24,7 +24,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) ->\n pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n-        pointer_ty(fx.tcx),\n+        fx.pointer_type,\n         vtable_memflags(),\n         vtable,\n         (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32,\n@@ -34,7 +34,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Val\n pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n-        pointer_ty(fx.tcx),\n+        fx.pointer_type,\n         vtable_memflags(),\n         vtable,\n         (ty::COMMON_VTABLE_ENTRIES_ALIGN * usize_size) as i32,\n@@ -55,7 +55,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n \n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();\n     let func_ref = fx.bcx.ins().load(\n-        pointer_ty(fx.tcx),\n+        fx.pointer_type,\n         vtable_memflags(),\n         vtable,\n         (idx * usize_size as usize) as i32,"}, {"sha": "26605003c42008cd8c3baf101e622e5ea4497013", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279f486960edc43246ea413970f587a82365cca7/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=279f486960edc43246ea413970f587a82365cca7", "patch": "@@ -15,8 +15,8 @@ exec ${0/.rs/.bin} $@\n //! for example:\n //!\n //! ```shell\n-//! $ rustc y.rs -o build/y.bin\n-//! $ build/y.bin\n+//! $ rustc y.rs -o y.bin\n+//! $ ./y.bin\n //! ```\n //!\n //! # Naming"}]}