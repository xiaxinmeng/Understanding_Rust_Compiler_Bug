{"sha": "df36a8dfc98af7e78b416ca1faab3c214be29fab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMzZhOGRmYzk4YWY3ZTc4YjQxNmNhMWZhYWIzYzIxNGJlMjlmYWI=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-02-15T04:40:01Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-02-15T04:40:01Z"}, "message": "Long lines, proper FIXME, inlining", "tree": {"sha": "2e1fb8a21d681b0a3ddb9a7bc5ae53b177399ba0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e1fb8a21d681b0a3ddb9a7bc5ae53b177399ba0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df36a8dfc98af7e78b416ca1faab3c214be29fab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df36a8dfc98af7e78b416ca1faab3c214be29fab", "html_url": "https://github.com/rust-lang/rust/commit/df36a8dfc98af7e78b416ca1faab3c214be29fab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df36a8dfc98af7e78b416ca1faab3c214be29fab/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd93a36d73a005de23b9f9137f16ee90b3daecf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd93a36d73a005de23b9f9137f16ee90b3daecf4", "html_url": "https://github.com/rust-lang/rust/commit/bd93a36d73a005de23b9f9137f16ee90b3daecf4"}], "stats": {"total": 137, "additions": 71, "deletions": 66}, "files": [{"sha": "f842742520c4a60a48895b385fdd5e4ce84c9985", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 71, "deletions": 66, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/df36a8dfc98af7e78b416ca1faab3c214be29fab/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df36a8dfc98af7e78b416ca1faab3c214be29fab/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=df36a8dfc98af7e78b416ca1faab3c214be29fab", "patch": "@@ -62,71 +62,77 @@ pub trait NumStrConv {\n \n }\n \n-macro_rules! impl_NumStrConv_Floating (\n-    ($t:ty) => (\n-        impl NumStrConv for $t {\n-            static pure fn has_NaN()      -> bool { true }\n-            static pure fn has_inf()      -> bool { true }\n-            static pure fn has_neg_inf()  -> bool { true }\n-            static pure fn has_neg_zero() -> bool { true }\n-\n-            static pure fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n-            static pure fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-            static pure fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-            static pure fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n-\n-            pure fn is_NaN(&self)      -> bool { *self != *self }\n-\n-            pure fn is_inf(&self)      -> bool {\n-                *self == NumStrConv::inf().unwrap()\n-            }\n-\n-            pure fn is_neg_inf(&self)  -> bool {\n-                *self == NumStrConv::neg_inf().unwrap()\n-            }\n+macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n+    impl NumStrConv for $t {\n+        #[inline(always)] static pure fn has_NaN()      -> bool { true }\n+        #[inline(always)] static pure fn has_inf()      -> bool { true }\n+        #[inline(always)] static pure fn has_neg_inf()  -> bool { true }\n+        #[inline(always)] static pure fn has_neg_zero() -> bool { true }\n+\n+        #[inline(always)]\n+        static pure fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n+        #[inline(always)]\n+        static pure fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n+        #[inline(always)]\n+        static pure fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n+        #[inline(always)]\n+        static pure fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n+\n+        #[inline(always)] pure fn is_NaN(&self) -> bool { *self != *self }\n+\n+        #[inline(always)]\n+        pure fn is_inf(&self)      -> bool {\n+            *self == NumStrConv::inf().unwrap()\n+        }\n \n-            pure fn is_neg_zero(&self) -> bool {\n-                *self == 0.0 && (1.0 / *self).is_neg_inf()\n-            }\n+        #[inline(always)]\n+        pure fn is_neg_inf(&self)  -> bool {\n+            *self == NumStrConv::neg_inf().unwrap()\n+        }\n \n-            pure fn round_to_zero(&self) -> $t {\n-                ( if *self < 0.0 { f64::ceil(*self as f64)  }\n-                  else           { f64::floor(*self as f64) }\n-                ) as $t\n-            }\n+        #[inline(always)]\n+        pure fn is_neg_zero(&self) -> bool {\n+            *self == 0.0 && (1.0 / *self).is_neg_inf()\n+        }\n \n-            pure fn fractional_part(&self) -> $t {\n-                *self - self.round_to_zero()\n-            }\n+        #[inline(always)]\n+        pure fn round_to_zero(&self) -> $t {\n+            ( if *self < 0.0 { f64::ceil(*self as f64)  }\n+                else           { f64::floor(*self as f64) }\n+            ) as $t\n         }\n-    )\n-)\n-\n-macro_rules! impl_NumStrConv_Integer (\n-    ($t:ty) => (\n-        impl NumStrConv for $t {\n-            static pure fn has_NaN()      -> bool { false }\n-            static pure fn has_inf()      -> bool { false }\n-            static pure fn has_neg_inf()  -> bool { false }\n-            static pure fn has_neg_zero() -> bool { false }\n-\n-            static pure fn NaN()      -> Option<$t> { None }\n-            static pure fn inf()      -> Option<$t> { None }\n-            static pure fn neg_inf()  -> Option<$t> { None }\n-            static pure fn neg_zero() -> Option<$t> { None }\n-\n-            pure fn is_NaN(&self)      -> bool { false }\n-            pure fn is_inf(&self)      -> bool { false }\n-            pure fn is_neg_inf(&self)  -> bool { false }\n-            pure fn is_neg_zero(&self) -> bool { false }\n-\n-            pure fn round_to_zero(&self)   -> $t { *self }\n-            pure fn fractional_part(&self) -> $t {     0 }\n+\n+        #[inline(always)]\n+        pure fn fractional_part(&self) -> $t {\n+            *self - self.round_to_zero()\n         }\n-    )\n-)\n+    }\n+))\n+\n+macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n+    impl NumStrConv for $t {\n+        #[inline(always)] static pure fn has_NaN()      -> bool { false }\n+        #[inline(always)] static pure fn has_inf()      -> bool { false }\n+        #[inline(always)] static pure fn has_neg_inf()  -> bool { false }\n+        #[inline(always)] static pure fn has_neg_zero() -> bool { false }\n+\n+        #[inline(always)] static pure fn NaN()      -> Option<$t> { None }\n+        #[inline(always)] static pure fn inf()      -> Option<$t> { None }\n+        #[inline(always)] static pure fn neg_inf()  -> Option<$t> { None }\n+        #[inline(always)] static pure fn neg_zero() -> Option<$t> { None }\n+\n+        #[inline(always)] pure fn is_NaN(&self)      -> bool { false }\n+        #[inline(always)] pure fn is_inf(&self)      -> bool { false }\n+        #[inline(always)] pure fn is_neg_inf(&self)  -> bool { false }\n+        #[inline(always)] pure fn is_neg_zero(&self) -> bool { false }\n+\n+        #[inline(always)] pure fn round_to_zero(&self)   -> $t { *self }\n+        #[inline(always)] pure fn fractional_part(&self) -> $t {     0 }\n+    }\n+))\n \n-// XXX: Replace by two generic impls for traits 'Integral' and 'Floating'\n+// FIXME: #4955\n+// Replace by two generic impls for traits 'Integral' and 'Floating'\n impl_NumStrConv_Floating!(float)\n impl_NumStrConv_Floating!(f32)\n impl_NumStrConv_Floating!(f64)\n@@ -143,8 +149,6 @@ impl_NumStrConv_Integer!(u16)\n impl_NumStrConv_Integer!(u32)\n impl_NumStrConv_Integer!(u64)\n \n-// NOTE: inline the methods\n-\n /**\n  * Converts a number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all numeric string\n@@ -176,8 +180,8 @@ impl_NumStrConv_Integer!(u64)\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+Div<T,T>+\n-                                  Neg<T>+Modulo<T,T>+Mul<T,T>>(\n+pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+                                  Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n     if radix as int <  2 {\n@@ -400,8 +404,8 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+Div<T,\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+Div<T,T>+Neg<T>\n-                            +Modulo<T,T>+Mul<T,T>>(\n+pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+                            Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = to_str_bytes_common(num, radix,\n@@ -457,7 +461,8 @@ priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  *   formated like `FF_AE_FF_FF`.\n  */\n pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n-                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n+                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n+                                    NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool\n         ) -> Option<T> {"}]}