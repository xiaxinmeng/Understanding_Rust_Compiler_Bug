{"sha": "4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMjMxYmFiNWVmNjIwMDczYzNjMjliOWIxZjUwN2Y0YThmOGM0NDg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-16T09:28:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-16T09:48:28Z"}, "message": "format much of Miri", "tree": {"sha": "2c6c829dfabac1e08c9ec5bfbec4b3ab96528825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c6c829dfabac1e08c9ec5bfbec4b3ab96528825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "html_url": "https://github.com/rust-lang/rust/commit/4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b3566096c1013ac5e011b47d09298db8c838913", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3566096c1013ac5e011b47d09298db8c838913", "html_url": "https://github.com/rust-lang/rust/commit/7b3566096c1013ac5e011b47d09298db8c838913"}], "stats": {"total": 1266, "additions": 752, "deletions": 514}, "files": [{"sha": "7642018c08cbc2f730c159334f876fbcb8b3e98d", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -2,8 +2,8 @@ extern crate rustc_driver;\n extern crate rustc_hir;\n extern crate rustc_interface;\n \n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_driver::Compilation;\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::{interface, Queries};\n \n use crate::test::Bencher;"}, {"sha": "0e9a6ffe8050297dd088d3ce3c9d7a17fda74304", "filename": "src/bin/miri.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,11 +1,11 @@\n #![feature(rustc_private)]\n \n-extern crate rustc_middle;\n extern crate rustc_driver;\n+extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_interface;\n+extern crate rustc_middle;\n extern crate rustc_session;\n-extern crate rustc_errors;\n \n use std::convert::TryFrom;\n use std::env;\n@@ -14,11 +14,11 @@ use std::str::FromStr;\n use hex::FromHexError;\n use log::debug;\n \n-use rustc_session::{CtfeBacktrace, config::ErrorOutputType};\n-use rustc_errors::emitter::{HumanReadableErrorType, ColorConfig};\n use rustc_driver::Compilation;\n+use rustc_errors::emitter::{ColorConfig, HumanReadableErrorType};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n+use rustc_session::{config::ErrorOutputType, CtfeBacktrace};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n@@ -37,8 +37,13 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n             let (entry_def_id, _) = if let Some((entry_def, x)) = tcx.entry_fn(LOCAL_CRATE) {\n                 (entry_def, x)\n             } else {\n-                let output_ty = ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto));\n-                rustc_session::early_error(output_ty, \"miri can only run programs that have a main function\");\n+                let output_ty = ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(\n+                    ColorConfig::Auto,\n+                ));\n+                rustc_session::early_error(\n+                    output_ty,\n+                    \"miri can only run programs that have a main function\",\n+                );\n             };\n             let mut config = self.miri_config.clone();\n \n@@ -249,28 +254,27 @@ fn main() {\n                             err => panic!(\"unknown error decoding -Zmiri-seed as hex: {:?}\", err),\n                         });\n                     if seed_raw.len() > 8 {\n-                        panic!(\n-                            \"-Zmiri-seed must be at most 8 bytes, was {}\",\n-                            seed_raw.len()\n-                        );\n+                        panic!(\"-Zmiri-seed must be at most 8 bytes, was {}\", seed_raw.len());\n                     }\n \n                     let mut bytes = [0; 8];\n                     bytes[..seed_raw.len()].copy_from_slice(&seed_raw);\n                     miri_config.seed = Some(u64::from_be_bytes(bytes));\n                 }\n                 arg if arg.starts_with(\"-Zmiri-env-exclude=\") => {\n-                    miri_config.excluded_env_vars\n+                    miri_config\n+                        .excluded_env_vars\n                         .push(arg.strip_prefix(\"-Zmiri-env-exclude=\").unwrap().to_owned());\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-pointer-tag=\") => {\n-                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-pointer-tag=\").unwrap().parse() {\n-                        Ok(id) => id,\n-                        Err(err) => panic!(\n-                            \"-Zmiri-track-pointer-tag requires a valid `u64` argument: {}\",\n-                            err\n-                        ),\n-                    };\n+                    let id: u64 =\n+                        match arg.strip_prefix(\"-Zmiri-track-pointer-tag=\").unwrap().parse() {\n+                            Ok(id) => id,\n+                            Err(err) => panic!(\n+                                \"-Zmiri-track-pointer-tag requires a valid `u64` argument: {}\",\n+                                err\n+                            ),\n+                        };\n                     if let Some(id) = miri::PtrId::new(id) {\n                         miri_config.tracked_pointer_tag = Some(id);\n                     } else {\n@@ -280,10 +284,8 @@ fn main() {\n                 arg if arg.starts_with(\"-Zmiri-track-call-id=\") => {\n                     let id: u64 = match arg.strip_prefix(\"-Zmiri-track-call-id=\").unwrap().parse() {\n                         Ok(id) => id,\n-                        Err(err) => panic!(\n-                            \"-Zmiri-track-call-id requires a valid `u64` argument: {}\",\n-                            err\n-                        ),\n+                        Err(err) =>\n+                            panic!(\"-Zmiri-track-call-id requires a valid `u64` argument: {}\", err),\n                     };\n                     if let Some(id) = miri::CallId::new(id) {\n                         miri_config.tracked_call_id = Some(id);\n@@ -292,20 +294,28 @@ fn main() {\n                     }\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-alloc-id=\") => {\n-                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-alloc-id=\").unwrap().parse() {\n+                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-alloc-id=\").unwrap().parse()\n+                    {\n                         Ok(id) => id,\n-                        Err(err) => panic!(\n-                            \"-Zmiri-track-alloc-id requires a valid `u64` argument: {}\",\n-                            err\n-                        ),\n+                        Err(err) =>\n+                            panic!(\"-Zmiri-track-alloc-id requires a valid `u64` argument: {}\", err),\n                     };\n                     miri_config.tracked_alloc_id = Some(miri::AllocId(id));\n                 }\n                 arg if arg.starts_with(\"-Zmiri-compare-exchange-weak-failure-rate=\") => {\n-                    let rate = match arg.strip_prefix(\"-Zmiri-compare-exchange-weak-failure-rate=\").unwrap().parse::<f64>() {\n+                    let rate = match arg\n+                        .strip_prefix(\"-Zmiri-compare-exchange-weak-failure-rate=\")\n+                        .unwrap()\n+                        .parse::<f64>()\n+                    {\n                         Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n-                        Ok(_) => panic!(\"-Zmiri-compare-exchange-weak-failure-rate must be between `0.0` and `1.0`\"),\n-                        Err(err) => panic!(\"-Zmiri-compare-exchange-weak-failure-rate requires a `f64` between `0.0` and `1.0`: {}\", err),\n+                        Ok(_) => panic!(\n+                            \"-Zmiri-compare-exchange-weak-failure-rate must be between `0.0` and `1.0`\"\n+                        ),\n+                        Err(err) => panic!(\n+                            \"-Zmiri-compare-exchange-weak-failure-rate requires a `f64` between `0.0` and `1.0`: {}\",\n+                            err\n+                        ),\n                     };\n                     miri_config.cmpxchg_weak_failure_rate = rate;\n                 }\n@@ -319,5 +329,9 @@ fn main() {\n \n     debug!(\"rustc arguments: {:?}\", rustc_args);\n     debug!(\"crate arguments: {:?}\", miri_config.args);\n-    run_compiler(rustc_args, &mut MiriCompilerCalls { miri_config }, /* insert_default_args: */ true)\n+    run_compiler(\n+        rustc_args,\n+        &mut MiriCompilerCalls { miri_config },\n+        /* insert_default_args: */ true,\n+    )\n }"}, {"sha": "1e46015f87a824d20550c5272ca0436456724db1", "filename": "src/eval.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -135,8 +135,9 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             argvs.push(arg_place.ptr);\n         }\n         // Make an array with all these pointers, in the Miri memory.\n-        let argvs_layout =\n-            ecx.layout_of(tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), u64::try_from(argvs.len()).unwrap()))?;\n+        let argvs_layout = ecx.layout_of(\n+            tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), u64::try_from(argvs.len()).unwrap()),\n+        )?;\n         let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Machine.into());\n         for (idx, arg) in argvs.into_iter().enumerate() {\n             let place = ecx.mplace_field(&argvs_place, idx)?;\n@@ -224,9 +225,11 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {\n-                    assert!(ecx.machine.communicate,\n+                    assert!(\n+                        ecx.machine.communicate,\n                         \"scheduler callbacks require disabled isolation, but the code \\\n-                        that created the callback did not check it\");\n+                        that created the callback did not check it\"\n+                    );\n                     ecx.run_timeout_callback()?;\n                 }\n                 SchedulingAction::ExecuteDtors => {\n@@ -241,7 +244,8 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n             }\n             ecx.process_diagnostics(info);\n         }\n-        let return_code = ecx.read_scalar(&ret_place.into())?.check_init()?.to_machine_isize(&ecx)?;\n+        let return_code =\n+            ecx.read_scalar(&ret_place.into())?.check_init()?.to_machine_isize(&ecx)?;\n         Ok(return_code)\n     })();\n "}, {"sha": "7215cb4b0c7bde4cca000e9350e98bb3254231e1", "filename": "src/helpers.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -5,10 +5,10 @@ use std::time::Duration;\n \n use log::trace;\n \n-use rustc_middle::mir;\n-use rustc_middle::ty::{self, List, TyCtxt, layout::TyAndLayout};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n-use rustc_target::abi::{LayoutOf, Size, FieldsShape, Variants};\n+use rustc_middle::mir;\n+use rustc_middle::ty::{self, layout::TyAndLayout, List, TyCtxt};\n+use rustc_target::abi::{FieldsShape, LayoutOf, Size, Variants};\n use rustc_target::spec::abi::Abi;\n \n use rand::RngCore;\n@@ -19,10 +19,8 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n \n /// Gets an instance for a path.\n fn try_resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n-    tcx.crates()\n-        .iter()\n-        .find(|&&krate| tcx.original_crate_name(krate).as_str() == path[0])\n-        .and_then(|krate| {\n+    tcx.crates().iter().find(|&&krate| tcx.original_crate_name(krate).as_str() == path[0]).and_then(\n+        |krate| {\n             let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n             let mut items = tcx.item_children(krate);\n             let mut path_it = path.iter().skip(1).peekable();\n@@ -40,7 +38,8 @@ fn try_resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId\n                 }\n             }\n             None\n-        })\n+        },\n+    )\n }\n \n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -53,10 +52,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(\n-        &mut self,\n-        path: &[&str],\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_mut();\n         let instance = this.resolve_path(path);\n         let cid = GlobalId { instance, promoted: None };\n@@ -67,9 +63,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n     fn eval_libc(&mut self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.eval_context_mut()\n-            .eval_path_scalar(&[\"libc\", name])?\n-            .check_init()\n+        self.eval_context_mut().eval_path_scalar(&[\"libc\", name])?.check_init()\n     }\n \n     /// Helper function to get a `libc` constant as an `i32`.\n@@ -101,7 +95,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Helper function to get the `TyAndLayout` of a `windows` type\n     fn windows_ty_layout(&mut self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n         let this = self.eval_context_mut();\n-        let ty = this.resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name]).ty(*this.tcx, ty::ParamEnv::reveal_all());\n+        let ty = this\n+            .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name])\n+            .ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n \n@@ -170,7 +166,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let param_env = ty::ParamEnv::reveal_all(); // in Miri this is always the param_env we use... and this.param_env is private.\n         let callee_abi = f.ty(*this.tcx, param_env).fn_sig(*this.tcx).abi();\n         if callee_abi != caller_abi {\n-            throw_ub_format!(\"calling a function with ABI {} using caller ABI {}\", callee_abi.name(), caller_abi.name())\n+            throw_ub_format!(\n+                \"calling a function with ABI {} using caller ABI {}\",\n+                callee_abi.name(),\n+                caller_abi.name()\n+            )\n         }\n \n         // Push frame.\n@@ -181,9 +181,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let mut callee_args = this.frame().body.args_iter();\n         for arg in args {\n             let callee_arg = this.local_place(\n-                callee_args.next().ok_or_else(||\n-                    err_ub_format!(\"callee has fewer arguments than expected\")\n-                )?\n+                callee_args\n+                    .next()\n+                    .ok_or_else(|| err_ub_format!(\"callee has fewer arguments than expected\"))?,\n             )?;\n             this.write_immediate(*arg, &callee_arg)?;\n         }\n@@ -356,7 +356,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n-            fn visit_union(&mut self, _v: &MPlaceTy<'tcx, Tag>, _fields: NonZeroUsize) -> InterpResult<'tcx> {\n+            fn visit_union(\n+                &mut self,\n+                _v: &MPlaceTy<'tcx, Tag>,\n+                _fields: NonZeroUsize,\n+            ) -> InterpResult<'tcx> {\n                 bug!(\"we should have already handled unions in `visit_value`\")\n             }\n         }\n@@ -465,12 +469,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             })?\n         } else if target.families.contains(&\"windows\".to_owned()) {\n             // FIXME: we have to finish implementing the Windows equivalent of this.\n-            this.eval_windows(\"c\", match e.kind() {\n-                NotFound => \"ERROR_FILE_NOT_FOUND\",\n-                _ => throw_unsup_format!(\"io error {} cannot be transformed into a raw os error\", e)\n-            })?\n+            this.eval_windows(\n+                \"c\",\n+                match e.kind() {\n+                    NotFound => \"ERROR_FILE_NOT_FOUND\",\n+                    _ => throw_unsup_format!(\n+                        \"io error {} cannot be transformed into a raw os error\",\n+                        e\n+                    ),\n+                },\n+            )?\n         } else {\n-            throw_unsup_format!(\"setting the last OS error from an io::Error is unsupported for {}.\", target_os)\n+            throw_unsup_format!(\n+                \"setting the last OS error from an io::Error is unsupported for {}.\",\n+                target_os\n+            )\n         };\n         this.set_last_error(last_error)\n     }\n@@ -556,8 +569,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n }\n \n /// Check that the number of args is what we expect.\n-pub fn check_arg_count<'a, 'tcx, const N: usize>(args: &'a [OpTy<'tcx, Tag>]) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n-    where &'a [OpTy<'tcx, Tag>; N]: TryFrom<&'a [OpTy<'tcx, Tag>]> {\n+pub fn check_arg_count<'a, 'tcx, const N: usize>(\n+    args: &'a [OpTy<'tcx, Tag>],\n+) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n+where\n+    &'a [OpTy<'tcx, Tag>; N]: TryFrom<&'a [OpTy<'tcx, Tag>]>,\n+{\n     if let Ok(ops) = args.try_into() {\n         return Ok(ops);\n     }\n@@ -569,7 +586,11 @@ pub fn check_abi<'a>(abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n     if abi == exp_abi {\n         Ok(())\n     } else {\n-        throw_ub_format!(\"calling a function with ABI {} using caller ABI {}\", exp_abi.name(), abi.name())\n+        throw_ub_format!(\n+            \"calling a function with ABI {} using caller ABI {}\",\n+            exp_abi.name(),\n+            abi.name()\n+        )\n     }\n }\n "}, {"sha": "b5a77b08ff52dcb113ac8e01086822e4839bafa2", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -6,7 +6,7 @@ use log::trace;\n use rand::Rng;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_target::abi::{Size, HasDataLayout};\n+use rustc_target::abi::{HasDataLayout, Size};\n \n use crate::*;\n "}, {"sha": "c9645d12fad16f6a67f58e809648868205d1fd12", "filename": "src/lib.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -3,13 +3,13 @@\n #![feature(map_try_insert)]\n #![feature(never_type)]\n #![feature(try_blocks)]\n-\n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n-#[macro_use] extern crate rustc_middle;\n+#[macro_use]\n+extern crate rustc_middle;\n extern crate rustc_data_structures;\n extern crate rustc_hir;\n extern crate rustc_index;\n@@ -44,18 +44,18 @@ pub use crate::shims::env::{EnvVars, EvalContextExt as _};\n pub use crate::shims::foreign_items::EvalContextExt as _;\n pub use crate::shims::intrinsics::EvalContextExt as _;\n pub use crate::shims::os_str::EvalContextExt as _;\n-pub use crate::shims::time::EvalContextExt as _;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as _};\n+pub use crate::shims::time::EvalContextExt as _;\n pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n pub use crate::shims::EvalContextExt as _;\n \n pub use crate::data_race::{\n-    AtomicReadOp, AtomicWriteOp, AtomicRwOp, AtomicFenceOp,\n-    EvalContextExt as DataRaceEvalContextExt\n+    AtomicFenceOp, AtomicReadOp, AtomicRwOp, AtomicWriteOp,\n+    EvalContextExt as DataRaceEvalContextExt,\n };\n pub use crate::diagnostics::{\n     register_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n-    TerminationInfo, NonHaltingDiagnostic,\n+    NonHaltingDiagnostic, TerminationInfo,\n };\n pub use crate::eval::{create_ecx, eval_main, AlignmentCheck, MiriConfig};\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n@@ -67,17 +67,13 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    EvalContextExt as StackedBorEvalContextExt, Item, Permission, CallId, PtrId, Stack, Stacks, Tag,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, Stack, Stacks, Tag,\n };\n+pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{\n     EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager, ThreadState,\n };\n-pub use crate::sync::{\n-    EvalContextExt as SyncEvalContextExt, CondvarId, MutexId, RwLockId\n-};\n-pub use crate::vector_clock::{\n-    VClock, VectorIdx, VTimestamp\n-};\n+pub use crate::vector_clock::{VClock, VTimestamp, VectorIdx};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "635f3297b4e9c61592f5f804af19e95b488f016b", "filename": "src/machine.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -3,10 +3,10 @@\n \n use std::borrow::Cow;\n use std::cell::RefCell;\n+use std::fmt;\n use std::num::NonZeroU64;\n use std::rc::Rc;\n use std::time::Instant;\n-use std::fmt;\n \n use log::trace;\n use rand::rngs::StdRng;\n@@ -21,8 +21,8 @@ use rustc_middle::{\n         TyCtxt,\n     },\n };\n-use rustc_span::symbol::{sym, Symbol};\n use rustc_span::def_id::DefId;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{LayoutOf, Size};\n use rustc_target::spec::abi::Abi;\n \n@@ -100,7 +100,7 @@ impl fmt::Display for MiriMemoryKind {\n             Env => write!(f, \"environment variable\"),\n             Global => write!(f, \"global (static or const)\"),\n             ExternStatic => write!(f, \"extern static\"),\n-            Tls =>  write!(f, \"thread-local static\"),\n+            Tls => write!(f, \"thread-local static\"),\n         }\n     }\n }\n@@ -176,11 +176,7 @@ impl MemoryExtra {\n     ) {\n         let ptr = ptr.assert_ptr();\n         assert_eq!(ptr.offset, Size::ZERO);\n-        this.memory\n-            .extra\n-            .extern_statics\n-            .try_insert(Symbol::intern(name), ptr.alloc_id)\n-            .unwrap();\n+        this.memory.extra.extern_statics.try_insert(Symbol::intern(name), ptr.alloc_id).unwrap();\n     }\n \n     /// Sets up the \"extern statics\" for this machine.\n@@ -196,7 +192,11 @@ impl MemoryExtra {\n                 this.write_scalar(Scalar::from_machine_usize(0, this), &place.into())?;\n                 Self::add_extern_static(this, \"__cxa_thread_atexit_impl\", place.ptr);\n                 // \"environ\"\n-                Self::add_extern_static(this, \"environ\", this.machine.env_vars.environ.unwrap().ptr);\n+                Self::add_extern_static(\n+                    this,\n+                    \"environ\",\n+                    this.machine.env_vars.environ.unwrap().ptr,\n+                );\n             }\n             \"windows\" => {\n                 // \"_tls_used\"\n@@ -282,8 +282,8 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n         validate: bool,\n         layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n     ) -> Self {\n-        let layouts = PrimitiveLayouts::new(layout_cx)\n-            .expect(\"Couldn't get layouts of primitive types\");\n+        let layouts =\n+            PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n         Evaluator {\n             // `env_vars` could be initialized properly here if `Memory` were available before\n             // calling this method.\n@@ -476,15 +476,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (stacks, base_tag) =\n-            if let Some(stacked_borrows) = &memory_extra.stacked_borrows {\n-                let (stacks, base_tag) =\n-                    Stacks::new_allocation(id, alloc.size, Rc::clone(stacked_borrows), kind);\n-                (Some(stacks), base_tag)\n-            } else {\n-                // No stacks, no tag.\n-                (None, Tag::Untagged)\n-            };\n+        let (stacks, base_tag) = if let Some(stacked_borrows) = &memory_extra.stacked_borrows {\n+            let (stacks, base_tag) =\n+                Stacks::new_allocation(id, alloc.size, Rc::clone(stacked_borrows), kind);\n+            (Some(stacks), base_tag)\n+        } else {\n+            // No stacks, no tag.\n+            (None, Tag::Untagged)\n+        };\n         let race_alloc = if let Some(data_race) = &memory_extra.data_race {\n             Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size, kind))\n         } else {\n@@ -518,7 +517,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    \n     fn after_static_mem_initialized(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n@@ -545,11 +543,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.stacked_borrows.is_some() {\n-            ecx.retag(kind, place)\n-        } else {\n-            Ok(())\n-        }\n+        if ecx.memory.extra.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n     }\n \n     #[inline(always)]\n@@ -566,24 +560,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     fn stack<'a>(\n-        ecx: &'a InterpCx<'mir, 'tcx, Self>\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n     ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n         ecx.active_thread_stack()\n     }\n \n     fn stack_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n     ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n         ecx.active_thread_stack_mut()\n     }\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.stacked_borrows.is_some() {\n-            ecx.retag_return_place()\n-        } else {\n-            Ok(())\n-        }\n+        if ecx.memory.extra.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n     #[inline(always)]"}, {"sha": "8b5a3af5bac5b14026a7a74af9c9efdb8a52a66f", "filename": "src/range_map.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -77,7 +77,10 @@ impl<T> RangeMap<T> {\n         };\n         // The first offset that is not included any more.\n         let end = offset + len;\n-        slice.iter().take_while(move |elem| elem.range.start < end).map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n+        slice\n+            .iter()\n+            .take_while(move |elem| elem.range.start < end)\n+            .map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n     }\n \n     pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n@@ -213,7 +216,9 @@ mod tests {\n     fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n-            .map(|i| map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|(_, &t)| t).unwrap())\n+            .map(|i| {\n+                map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|(_, &t)| t).unwrap()\n+            })\n             .collect()\n     }\n \n@@ -267,7 +272,9 @@ mod tests {\n         assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n         // Should be seeing two blocks with 19.\n         assert_eq!(\n-            map.iter(Size::from_bytes(15), Size::from_bytes(2)).map(|(_, &t)| t).collect::<Vec<_>>(),\n+            map.iter(Size::from_bytes(15), Size::from_bytes(2))\n+                .map(|(_, &t)| t)\n+                .collect::<Vec<_>>(),\n             vec![19, 19]\n         );\n "}, {"sha": "f936913114c48204a3b2fd3c77dfb0331ec05315", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,19 +1,18 @@\n+use crate::rustc_target::abi::LayoutOf as _;\n use crate::*;\n use helpers::check_arg_count;\n-use rustc_middle::ty::{self, TypeAndMut};\n use rustc_ast::ast::Mutability;\n+use rustc_middle::ty::{self, TypeAndMut};\n use rustc_span::BytePos;\n use rustc_target::abi::Size;\n use std::convert::TryInto as _;\n-use crate::rustc_target::abi::LayoutOf as _;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-\n     fn handle_miri_get_backtrace(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>\n+        dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n@@ -35,24 +34,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             data.push((frame.instance, span.lo()));\n         }\n \n-        let ptrs: Vec<_> = data.into_iter().map(|(instance, pos)| {\n-            // We represent a frame pointer by using the `span.lo` value\n-            // as an offset into the function's allocation. This gives us an\n-            // opaque pointer that we can return to user code, and allows us\n-            // to reconstruct the needed frame information in `handle_miri_resolve_frame`.\n-            // Note that we never actually read or write anything from/to this pointer -\n-            // all of the data is represented by the pointer value itself.\n-            let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n-            fn_ptr.offset = Size::from_bytes(pos.0);\n-            Scalar::Ptr(fn_ptr)\n-        }).collect();\n+        let ptrs: Vec<_> = data\n+            .into_iter()\n+            .map(|(instance, pos)| {\n+                // We represent a frame pointer by using the `span.lo` value\n+                // as an offset into the function's allocation. This gives us an\n+                // opaque pointer that we can return to user code, and allows us\n+                // to reconstruct the needed frame information in `handle_miri_resolve_frame`.\n+                // Note that we never actually read or write anything from/to this pointer -\n+                // all of the data is represented by the pointer value itself.\n+                let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n+                fn_ptr.offset = Size::from_bytes(pos.0);\n+                Scalar::Ptr(fn_ptr)\n+            })\n+            .collect();\n \n         let len = ptrs.len();\n \n-        let ptr_ty = tcx.mk_ptr(TypeAndMut {\n-            ty: tcx.types.unit,\n-            mutbl: Mutability::Mut\n-        });\n+        let ptr_ty = tcx.mk_ptr(TypeAndMut { ty: tcx.types.unit, mutbl: Mutability::Mut });\n \n         let array_ty = tcx.mk_array(ptr_ty, ptrs.len().try_into().unwrap());\n \n@@ -63,14 +62,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.write_immediate_to_mplace(ptr.into(), &place)?;\n         }\n \n-        this.write_immediate(Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this), dest)?;\n+        this.write_immediate(\n+            Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this),\n+            dest,\n+        )?;\n         Ok(())\n     }\n \n     fn handle_miri_resolve_frame(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>\n+        dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n@@ -83,7 +85,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n \n-        let fn_instance = if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(ptr.alloc_id) {\n+        let fn_instance = if let Some(GlobalAlloc::Function(instance)) =\n+            this.tcx.get_global_alloc(ptr.alloc_id)\n+        {\n             instance\n         } else {\n             throw_ub_format!(\"expected function pointer, found {:?}\", ptr);\n@@ -100,7 +104,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if !(4..=5).contains(&num_fields) {\n             // Always mention 5 fields, since the 4-field struct\n             // is deprecated and slated for removal.\n-            throw_ub_format!(\"bad declaration of miri_resolve_frame - should return a struct with 5 fields\");\n+            throw_ub_format!(\n+                \"bad declaration of miri_resolve_frame - should return a struct with 5 fields\"\n+            );\n         }\n \n         let pos = BytePos(ptr.offset.bytes().try_into().unwrap());\n@@ -121,7 +127,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let dest = this.force_allocation(dest)?;\n         if let ty::Adt(adt, _) = dest.layout.ty.kind() {\n             if !adt.repr.c() {\n-                throw_ub_format!(\"miri_resolve_frame must be declared with a `#[repr(C)]` return type\");\n+                throw_ub_format!(\n+                    \"miri_resolve_frame must be declared with a `#[repr(C)]` return type\"\n+                );\n             }\n         }\n "}, {"sha": "1855d65d6c504187f9ba5cae203368373b87cfbb", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -37,7 +37,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         match dlsym {\n             Dlsym::Posix(dlsym) => posix::EvalContextExt::call_dlsym(this, dlsym, abi, args, ret),\n-            Dlsym::Windows(dlsym) => windows::EvalContextExt::call_dlsym(this, dlsym, abi, args, ret),\n+            Dlsym::Windows(dlsym) =>\n+                windows::EvalContextExt::call_dlsym(this, dlsym, abi, args, ret),\n         }\n     }\n }"}, {"sha": "a0916975322318b4a8134fe535a9cdf2a5a95e46", "filename": "src/shims/env.rs", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,10 +1,10 @@\n-use std::ffi::{OsString, OsStr};\n-use std::env;\n use std::convert::TryFrom;\n+use std::env;\n+use std::ffi::{OsStr, OsString};\n \n-use rustc_target::abi::{Size, LayoutOf};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_mir::interpret::Pointer;\n+use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n@@ -49,9 +49,13 @@ impl<'tcx> EnvVars<'tcx> {\n             for (name, value) in env::vars() {\n                 if !excluded_env_vars.contains(&name) {\n                     let var_ptr = match target_os {\n-                        \"linux\" | \"macos\" => alloc_env_var_as_c_str(name.as_ref(), value.as_ref(), ecx)?,\n+                        \"linux\" | \"macos\" =>\n+                            alloc_env_var_as_c_str(name.as_ref(), value.as_ref(), ecx)?,\n                         \"windows\" => alloc_env_var_as_wide_str(name.as_ref(), value.as_ref(), ecx)?,\n-                        unsupported => throw_unsup_format!(\"environment support for target OS `{}` not yet available\", unsupported),\n+                        unsupported => throw_unsup_format!(\n+                            \"environment support for target OS `{}` not yet available\",\n+                            unsupported\n+                        ),\n                     };\n                     ecx.machine.env_vars.map.insert(OsString::from(name), var_ptr);\n                 }\n@@ -102,14 +106,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn getenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n-        assert!(target_os == \"linux\" || target_os == \"macos\", \"`getenv` is only available for the UNIX target family\");\n+        assert!(\n+            target_os == \"linux\" || target_os == \"macos\",\n+            \"`getenv` is only available for the UNIX target family\"\n+        );\n \n         let name_ptr = this.read_scalar(name_op)?.check_init()?;\n         let name = this.read_os_str_from_c_str(name_ptr)?;\n         Ok(match this.machine.env_vars.map.get(name) {\n             Some(var_ptr) => {\n                 // The offset is used to strip the \"{name}=\" part of the string.\n-                Scalar::from(var_ptr.offset(Size::from_bytes(u64::try_from(name.len()).unwrap().checked_add(1).unwrap()), this)?)\n+                Scalar::from(var_ptr.offset(\n+                    Size::from_bytes(u64::try_from(name.len()).unwrap().checked_add(1).unwrap()),\n+                    this,\n+                )?)\n             }\n             None => Scalar::null_ptr(&*this.tcx),\n         })\n@@ -118,10 +128,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn GetEnvironmentVariableW(\n         &mut self,\n-        name_op: &OpTy<'tcx, Tag>,  // LPCWSTR\n-        buf_op: &OpTy<'tcx, Tag>,   // LPWSTR\n-        size_op: &OpTy<'tcx, Tag>,  // DWORD\n-    ) -> InterpResult<'tcx, u32> { // Returns DWORD (u32 in Windows)\n+        name_op: &OpTy<'tcx, Tag>, // LPCWSTR\n+        buf_op: &OpTy<'tcx, Tag>,  // LPWSTR\n+        size_op: &OpTy<'tcx, Tag>, // DWORD\n+    ) -> InterpResult<'tcx, u32> {\n+        // ^ Returns DWORD (u32 on Windows)\n+\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetEnvironmentVariableW\");\n \n@@ -130,9 +142,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(match this.machine.env_vars.map.get(&name) {\n             Some(var_ptr) => {\n                 // The offset is used to strip the \"{name}=\" part of the string.\n-                let name_offset_bytes =\n-                    u64::try_from(name.len()).unwrap().checked_add(1).unwrap().checked_mul(2).unwrap();\n-                let var_ptr = Scalar::from(var_ptr.offset(Size::from_bytes(name_offset_bytes), this)?);\n+                #[rustfmt::skip]\n+                let name_offset_bytes = u64::try_from(name.len()).unwrap()\n+                    .checked_add(1).unwrap()\n+                    .checked_mul(2).unwrap();\n+                let var_ptr =\n+                    Scalar::from(var_ptr.offset(Size::from_bytes(name_offset_bytes), this)?);\n                 let var = this.read_os_str_from_wide_str(var_ptr)?;\n \n                 let buf_ptr = this.read_scalar(buf_op)?.check_init()?;\n@@ -169,12 +184,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn FreeEnvironmentStringsW(&mut self, env_block_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn FreeEnvironmentStringsW(\n+        &mut self,\n+        env_block_op: &OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n \n         let env_block_ptr = this.read_scalar(env_block_op)?.check_init()?;\n-        let result = this.memory.deallocate(this.force_ptr(env_block_ptr)?, None, MiriMemoryKind::Env.into());\n+        let result = this.memory.deallocate(\n+            this.force_ptr(env_block_ptr)?,\n+            None,\n+            MiriMemoryKind::Env.into(),\n+        );\n         // If the function succeeds, the return value is nonzero.\n         Ok(result.is_ok() as i32)\n     }\n@@ -186,7 +208,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let mut this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n-        assert!(target_os == \"linux\" || target_os == \"macos\", \"`setenv` is only available for the UNIX target family\");\n+        assert!(\n+            target_os == \"linux\" || target_os == \"macos\",\n+            \"`setenv` is only available for the UNIX target family\"\n+        );\n \n         let name_ptr = this.read_scalar(name_op)?.check_init()?;\n         let value_ptr = this.read_scalar(value_op)?.check_init()?;\n@@ -202,8 +227,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some((name, value)) = new {\n             let var_ptr = alloc_env_var_as_c_str(&name, &value, &mut this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n-                this.memory\n-                    .deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n             }\n             this.update_environ()?;\n             Ok(0) // return zero on success\n@@ -248,8 +272,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, &mut this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n-                this.memory\n-                    .deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n             }\n             this.update_environ()?;\n             Ok(1) // return non-zero on success\n@@ -259,7 +282,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn unsetenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n-        assert!(target_os == \"linux\" || target_os == \"macos\", \"`unsetenv` is only available for the UNIX target family\");\n+        assert!(\n+            target_os == \"linux\" || target_os == \"macos\",\n+            \"`unsetenv` is only available for the UNIX target family\"\n+        );\n \n         let name_ptr = this.read_scalar(name_op)?.check_init()?;\n         let mut success = None;\n@@ -271,8 +297,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         if let Some(old) = success {\n             if let Some(var) = old {\n-                this.memory\n-                    .deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n             }\n             this.update_environ()?;\n             Ok(0)\n@@ -291,7 +316,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n-        assert!(target_os == \"linux\" || target_os == \"macos\", \"`getcwd` is only available for the UNIX target family\");\n+        assert!(\n+            target_os == \"linux\" || target_os == \"macos\",\n+            \"`getcwd` is only available for the UNIX target family\"\n+        );\n \n         this.check_no_isolation(\"`getcwd`\")?;\n \n@@ -337,7 +365,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn chdir(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n-        assert!(target_os == \"linux\" || target_os == \"macos\", \"`getcwd` is only available for the UNIX target family\");\n+        assert!(\n+            target_os == \"linux\" || target_os == \"macos\",\n+            \"`getcwd` is only available for the UNIX target family\"\n+        );\n \n         this.check_no_isolation(\"`chdir`\")?;\n \n@@ -353,10 +384,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn SetCurrentDirectoryW (\n+    fn SetCurrentDirectoryW(\n         &mut self,\n-        path_op: &OpTy<'tcx, Tag>   // LPCTSTR\n-    ) -> InterpResult<'tcx, i32> { // Returns BOOL (i32 in Windows)\n+        path_op: &OpTy<'tcx, Tag>, // LPCTSTR\n+    ) -> InterpResult<'tcx, i32> {\n+        // ^ Returns BOOL (i32 on Windows)\n+\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetCurrentDirectoryW\");\n \n@@ -380,7 +413,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Deallocate the old environ list, if any.\n         if let Some(environ) = this.machine.env_vars.environ {\n             let old_vars_ptr = this.read_scalar(&environ.into())?.check_init()?;\n-            this.memory.deallocate(this.force_ptr(old_vars_ptr)?, None, MiriMemoryKind::Env.into())?;\n+            this.memory.deallocate(\n+                this.force_ptr(old_vars_ptr)?,\n+                None,\n+                MiriMemoryKind::Env.into(),\n+            )?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n             // This is memory backing an extern static, hence `ExternStatic`, not `Env`.\n@@ -390,7 +427,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Collect all the pointers to each variable in a vector.\n-        let mut vars: Vec<Scalar<Tag>> = this.machine.env_vars.map.values().map(|&ptr| ptr.into()).collect();\n+        let mut vars: Vec<Scalar<Tag>> =\n+            this.machine.env_vars.map.values().map(|&ptr| ptr.into()).collect();\n         // Add the trailing null pointer.\n         vars.push(Scalar::null_ptr(this));\n         // Make an array with all these pointers inside Miri.\n@@ -402,10 +440,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let place = this.mplace_field(&vars_place, idx)?;\n             this.write_scalar(var, &place.into())?;\n         }\n-        this.write_scalar(\n-            vars_place.ptr,\n-            &this.machine.env_vars.environ.unwrap().into(),\n-        )?;\n+        this.write_scalar(vars_place.ptr, &this.machine.env_vars.environ.unwrap().into())?;\n \n         Ok(())\n     }"}, {"sha": "371a50f0e4b2e93440488d71934e4d3550ec9bf9", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,16 +1,22 @@\n-use std::{convert::{TryInto, TryFrom}, iter};\n+use std::{\n+    convert::{TryFrom, TryInto},\n+    iter,\n+};\n \n use log::trace;\n \n+use rustc_apfloat::Float;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir;\n-use rustc_target::{abi::{Align, Size}, spec::{PanicStrategy, abi::Abi}};\n use rustc_middle::ty;\n-use rustc_apfloat::Float;\n use rustc_span::symbol::sym;\n+use rustc_target::{\n+    abi::{Align, Size},\n+    spec::{abi::Abi, PanicStrategy},\n+};\n \n-use crate::*;\n use super::backtrace::EvalContextExt as _;\n+use crate::*;\n use helpers::{check_abi, check_arg_count};\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}"}, {"sha": "13ea14b4b9d4056835401d6ed320f6f67dccf6b4", "filename": "src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -74,8 +74,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(false);\n         }\n \n-        let req_align = this\n-            .force_bits(this.read_scalar(align_op)?.check_init()?, this.pointer_size())?;\n+        let req_align =\n+            this.force_bits(this.read_scalar(align_op)?.check_init()?, this.pointer_size())?;\n \n         // Stop if the alignment is not a power of two.\n         if !req_align.is_power_of_two() {"}, {"sha": "22e3806ad33458c4bbbb6f5570187843571e0d3b", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -48,7 +48,6 @@ pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsSt\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n     fn read_os_str_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n@@ -94,7 +93,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         scalar: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n-\n         let bytes = os_str_to_bytes(os_str)?;\n         // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n         // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n@@ -199,7 +197,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_wide_str(scalar)?;\n \n-        Ok(this.convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost).into_owned().into())\n+        Ok(this\n+            .convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost)\n+            .into_owned()\n+            .into())\n     }\n \n     /// Write a Path to the machine memory (as a null-terminated sequence of bytes),\n@@ -211,7 +212,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-        let os_str = this.convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str = this\n+            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.write_os_str_to_c_str(&os_str, scalar, size)\n     }\n \n@@ -224,7 +226,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-        let os_str = this.convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str = this\n+            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.write_os_str_to_wide_str(&os_str, scalar, size)\n     }\n \n@@ -270,4 +273,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n     }\n }\n-"}, {"sha": "b60da058e2cbb8792ddf242ede53f549785d0af9", "filename": "src/shims/panic.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -14,8 +14,8 @@\n use log::trace;\n \n use rustc_middle::{mir, ty};\n-use rustc_target::spec::PanicStrategy;\n use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::PanicStrategy;\n \n use crate::*;\n use helpers::check_arg_count;\n@@ -54,10 +54,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let &[ref payload] = check_arg_count(args)?;\n         let payload = this.read_scalar(payload)?.check_init()?;\n         let thread = this.active_thread_mut();\n-        assert!(\n-            thread.panic_payload.is_none(),\n-            \"the panic runtime should avoid double-panics\"\n-        );\n+        assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n         thread.panic_payload = Some(payload);\n \n         // Jump to the unwind block to begin unwinding.\n@@ -111,7 +108,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // This lets `handle_stack_pop` (below) know that we should stop unwinding\n         // when we pop this frame.\n         if this.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n-            this.frame_mut().extra.catch_unwind = Some(CatchUnwindData { catch_fn, data, dest: *dest, ret });\n+            this.frame_mut().extra.catch_unwind =\n+                Some(CatchUnwindData { catch_fn, data, dest: *dest, ret });\n         }\n \n         return Ok(());\n@@ -134,7 +132,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let (true, Some(catch_unwind)) = (unwinding, extra.catch_unwind.take()) {\n             // We've just popped a frame that was pushed by `try`,\n             // and we are unwinding, so we should catch that.\n-            trace!(\"unwinding: found catch_panic frame during unwinding: {:?}\", this.frame().instance);\n+            trace!(\n+                \"unwinding: found catch_panic frame during unwinding: {:?}\",\n+                this.frame().instance\n+            );\n \n             // We set the return value of `try` to 1, since there was a panic.\n             this.write_scalar(Scalar::from_i32(1), &catch_unwind.dest)?;\n@@ -164,11 +165,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Starta a panic in the interpreter with the given message as payload.\n-    fn start_panic(\n-        &mut self,\n-        msg: &str,\n-        unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n+    fn start_panic(&mut self, msg: &str, unwind: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         // First arg: message."}, {"sha": "234f03ff462c10feb728afe3d6431746b386eba8", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 189, "deletions": 108, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,35 +1,52 @@\n+use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::convert::{TryFrom, TryInto};\n-use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir};\n+use std::fs::{\n+    read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir,\n+};\n use std::io::{self, Read, Seek, SeekFrom, Write};\n use std::path::Path;\n use std::time::SystemTime;\n-use std::borrow::Cow;\n \n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_target::abi::{Align, LayoutOf, Size};\n use rustc_middle::ty;\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use crate::*;\n-use stacked_borrows::Tag;\n use helpers::{check_arg_count, immty_from_int_checked, immty_from_uint_checked};\n use shims::time::system_time_to_duration;\n+use stacked_borrows::Tag;\n \n #[derive(Debug)]\n struct FileHandle {\n     file: File,\n     writable: bool,\n }\n \n-trait FileDescriptor : std::fmt::Debug {\n+trait FileDescriptor: std::fmt::Debug {\n     fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle>;\n \n-    fn read<'tcx>(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>>;\n-    fn write<'tcx>(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>>;\n-    fn seek<'tcx>(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>>;\n-    fn close<'tcx>(self: Box<Self>, _communicate_allowed: bool) -> InterpResult<'tcx, io::Result<i32>>;\n+    fn read<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        bytes: &mut [u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn write<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        bytes: &[u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn seek<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        offset: SeekFrom,\n+    ) -> InterpResult<'tcx, io::Result<u64>>;\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>>;\n \n     fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>>;\n }\n@@ -39,22 +56,37 @@ impl FileDescriptor for FileHandle {\n         Ok(&self)\n     }\n \n-    fn read<'tcx>(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        bytes: &mut [u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.read(bytes))\n     }\n \n-    fn write<'tcx>(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        bytes: &[u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.write(bytes))\n     }\n \n-    fn seek<'tcx>(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        offset: SeekFrom,\n+    ) -> InterpResult<'tcx, io::Result<u64>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.seek(offset))\n     }\n \n-    fn close<'tcx>(self: Box<Self>, communicate_allowed: bool) -> InterpResult<'tcx, io::Result<i32>> {\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         // We sync the file if it was opened in a mode different than read-only.\n         if self.writable {\n@@ -88,23 +120,38 @@ impl FileDescriptor for io::Stdin {\n         throw_unsup_format!(\"stdin cannot be used as FileHandle\");\n     }\n \n-    fn read<'tcx>(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(\n+        &mut self,\n+        communicate_allowed: bool,\n+        bytes: &mut [u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         if !communicate_allowed {\n             // We want isolation mode to be deterministic, so we have to disallow all reads, even stdin.\n             helpers::isolation_error(\"`read` from stdin\")?;\n         }\n         Ok(Read::read(self, bytes))\n     }\n \n-    fn write<'tcx>(&mut self, _communicate_allowed: bool, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        _bytes: &[u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot write to stdin\");\n     }\n \n-    fn seek<'tcx>(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        _offset: SeekFrom,\n+    ) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stdin\");\n     }\n \n-    fn close<'tcx>(self: Box<Self>, _communicate_allowed: bool) -> InterpResult<'tcx, io::Result<i32>> {\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n         throw_unsup_format!(\"stdin cannot be closed\");\n     }\n \n@@ -118,11 +165,19 @@ impl FileDescriptor for io::Stdout {\n         throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n     }\n \n-    fn read<'tcx>(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        _bytes: &mut [u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from stdout\");\n     }\n \n-    fn write<'tcx>(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        bytes: &[u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         let result = Write::write(self, bytes);\n         // Stdout is buffered, flush to make sure it appears on the\n@@ -135,11 +190,18 @@ impl FileDescriptor for io::Stdout {\n         Ok(result)\n     }\n \n-    fn seek<'tcx>(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        _offset: SeekFrom,\n+    ) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stdout\");\n     }\n \n-    fn close<'tcx>(self: Box<Self>, _communicate_allowed: bool) -> InterpResult<'tcx, io::Result<i32>> {\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n         throw_unsup_format!(\"stdout cannot be closed\");\n     }\n \n@@ -153,21 +215,36 @@ impl FileDescriptor for io::Stderr {\n         throw_unsup_format!(\"stderr cannot be used as FileHandle\");\n     }\n \n-    fn read<'tcx>(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        _bytes: &mut [u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from stderr\");\n     }\n \n-    fn write<'tcx>(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        bytes: &[u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         // No need to flush, stderr is not buffered.\n         Ok(Write::write(self, bytes))\n     }\n \n-    fn seek<'tcx>(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(\n+        &mut self,\n+        _communicate_allowed: bool,\n+        _offset: SeekFrom,\n+    ) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stderr\");\n     }\n \n-    fn close<'tcx>(self: Box<Self>, _communicate_allowed: bool) -> InterpResult<'tcx, io::Result<i32>> {\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n         throw_unsup_format!(\"stderr cannot be closed\");\n     }\n \n@@ -187,9 +264,7 @@ impl<'tcx> Default for FileHandler {\n         handles.insert(0i32, Box::new(io::stdin()));\n         handles.insert(1i32, Box::new(io::stdout()));\n         handles.insert(2i32, Box::new(io::stderr()));\n-        FileHandler {\n-            handles\n-        }\n+        FileHandler { handles }\n     }\n }\n \n@@ -203,11 +278,8 @@ impl<'tcx> FileHandler {\n         // between used FDs, the find_map combinator will return it. If the first such unused FD\n         // is after all other used FDs, the find_map combinator will return None, and we will use\n         // the FD following the greatest FD thus far.\n-        let candidate_new_fd = self\n-            .handles\n-            .range(min_fd..)\n-            .zip(min_fd..)\n-            .find_map(|((fd, _fh), counter)| {\n+        let candidate_new_fd =\n+            self.handles.range(min_fd..).zip(min_fd..).find_map(|((fd, _fh), counter)| {\n                 if *fd != counter {\n                     // There was a gap in the fds stored, return the first unused one\n                     // (note that this relies on BTreeMap iterating in key order)\n@@ -220,7 +292,10 @@ impl<'tcx> FileHandler {\n         let new_fd = candidate_new_fd.unwrap_or_else(|| {\n             // find_map ran out of BTreeMap entries before finding a free fd, use one plus the\n             // maximum fd in the map\n-            self.handles.last_key_value().map(|(fd, _)| fd.checked_add(1).unwrap()).unwrap_or(min_fd)\n+            self.handles\n+                .last_key_value()\n+                .map(|(fd, _)| fd.checked_add(1).unwrap())\n+                .unwrap_or(min_fd)\n         });\n \n         self.handles.try_insert(new_fd, file_handle).unwrap();\n@@ -292,7 +367,7 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n             immty_from_uint_checked(modified_sec, time_t_layout)?, // st_mtime\n             immty_from_uint_checked(modified_nsec, long_layout)?, // st_mtime_nsec\n             immty_from_uint_checked(0u128, time_t_layout)?, // st_ctime\n-            immty_from_uint_checked(0u128, long_layout)?, // st_ctime_nsec\n+            immty_from_uint_checked(0u128, long_layout)?,  // st_ctime_nsec\n             immty_from_uint_checked(created_sec, time_t_layout)?, // st_birthtime\n             immty_from_uint_checked(created_nsec, long_layout)?, // st_birthtime_nsec\n             immty_from_uint_checked(metadata.size, off_t_layout)?, // st_size\n@@ -319,7 +394,10 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n         Ok((-1).into())\n     }\n \n-    fn file_type_to_d_type(&mut self, file_type: std::io::Result<FileType>) -> InterpResult<'tcx, i32> {\n+    fn file_type_to_d_type(\n+        &mut self,\n+        file_type: std::io::Result<FileType>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         match file_type {\n             Ok(file_type) => {\n@@ -353,10 +431,14 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n                     Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()?.into())\n                 }\n             }\n-            Err(e) => return match e.raw_os_error() {\n-                Some(error) => Ok(error),\n-                None => throw_unsup_format!(\"the error {} couldn't be converted to a return value\", e),\n-            }\n+            Err(e) =>\n+                return match e.raw_os_error() {\n+                    Some(error) => Ok(error),\n+                    None => throw_unsup_format!(\n+                        \"the error {} couldn't be converted to a return value\",\n+                        e\n+                    ),\n+                },\n         }\n     }\n }\n@@ -396,7 +478,11 @@ impl Default for DirHandler {\n     }\n }\n \n-fn maybe_sync_file(file: &File, writable: bool, operation: fn(&File) -> std::io::Result<()>) -> std::io::Result<i32> {\n+fn maybe_sync_file(\n+    file: &File,\n+    writable: bool,\n+    operation: fn(&File) -> std::io::Result<()>,\n+) -> std::io::Result<i32> {\n     if !writable && cfg!(windows) {\n         // sync_all() and sync_data() will return an error on Windows hosts if the file is not opened\n         // for writing. (FlushFileBuffers requires that the file handle have the\n@@ -505,16 +591,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(fd)\n     }\n \n-    fn fcntl(\n-        &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-    ) -> InterpResult<'tcx, i32> {\n+    fn fcntl(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"`fcntl`\")?;\n \n         if args.len() < 2 {\n-            throw_ub_format!(\"incorrect number of arguments for fcntl: got {}, expected at least 2\", args.len());\n+            throw_ub_format!(\n+                \"incorrect number of arguments for fcntl: got {}, expected at least 2\",\n+                args.len()\n+            );\n         }\n         let fd = this.read_scalar(&args[0])?.to_i32()?;\n         let cmd = this.read_scalar(&args[1])?.to_i32()?;\n@@ -552,12 +638,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             Ok(-1)\n                         }\n                     }\n-                },\n+                }\n                 None => return this.handle_not_found(),\n             }\n-        } else if this.tcx.sess.target.os == \"macos\"\n-            && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")?\n-        {\n+        } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")? {\n             let &[_, _] = check_arg_count(args)?;\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n                 // FIXME: Support fullfsync for all FDs\n@@ -585,12 +669,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn read(\n-        &mut self,\n-        fd: i32,\n-        buf: Scalar<Tag>,\n-        count: u64,\n-    ) -> InterpResult<'tcx, i64> {\n+    fn read(&mut self, fd: i32, buf: Scalar<Tag>, count: u64) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -637,12 +716,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn write(\n-        &mut self,\n-        fd: i32,\n-        buf: Scalar<Tag>,\n-        count: u64,\n-    ) -> InterpResult<'tcx, i64> {\n+    fn write(&mut self, fd: i32, buf: Scalar<Tag>, count: u64) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -719,7 +793,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn symlink(\n         &mut self,\n         target_op: &OpTy<'tcx, Tag>,\n-        linkpath_op: &OpTy<'tcx, Tag>\n+        linkpath_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         #[cfg(unix)]\n         fn create_link(src: &Path, dst: &Path) -> std::io::Result<()> {\n@@ -729,11 +803,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         #[cfg(windows)]\n         fn create_link(src: &Path, dst: &Path) -> std::io::Result<()> {\n             use std::os::windows::fs;\n-            if src.is_dir() {\n-                fs::symlink_dir(src, dst)\n-            } else {\n-                fs::symlink_file(src, dst)\n-            }\n+            if src.is_dir() { fs::symlink_dir(src, dst) } else { fs::symlink_file(src, dst) }\n         }\n \n         let this = self.eval_context_mut();\n@@ -842,11 +912,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // set.\n         // Other behaviors cannot be tested from `libstd` and thus are not implemented. If you\n         // found this error, please open an issue reporting it.\n-        if !(\n-            path.is_absolute() ||\n-            dirfd == this.eval_libc_i32(\"AT_FDCWD\")? ||\n-            (path.as_os_str().is_empty() && empty_path_flag)\n-        ) {\n+        if !(path.is_absolute()\n+            || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?\n+            || (path.as_os_str().is_empty() && empty_path_flag))\n+        {\n             throw_unsup_format!(\n                 \"using statx is only supported with absolute paths, relative paths with the file \\\n                 descriptor `AT_FDCWD`, and empty paths with the `AT_EMPTY_PATH` flag set and any \\\n@@ -889,20 +958,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // We need to set the corresponding bits of `mask` if the access, creation and modification\n         // times were available. Otherwise we let them be zero.\n-        let (access_sec, access_nsec) = metadata.accessed.map(|tup| {\n-            mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n-            InterpResult::Ok(tup)\n-        }).unwrap_or(Ok((0, 0)))?;\n-\n-        let (created_sec, created_nsec) = metadata.created.map(|tup| {\n-            mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n-            InterpResult::Ok(tup)\n-        }).unwrap_or(Ok((0, 0)))?;\n-\n-        let (modified_sec, modified_nsec) = metadata.modified.map(|tup| {\n-            mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n-            InterpResult::Ok(tup)\n-        }).unwrap_or(Ok((0, 0)))?;\n+        let (access_sec, access_nsec) = metadata\n+            .accessed\n+            .map(|tup| {\n+                mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n+                InterpResult::Ok(tup)\n+            })\n+            .unwrap_or(Ok((0, 0)))?;\n+\n+        let (created_sec, created_nsec) = metadata\n+            .created\n+            .map(|tup| {\n+                mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n+                InterpResult::Ok(tup)\n+            })\n+            .unwrap_or(Ok((0, 0)))?;\n+\n+        let (modified_sec, modified_nsec) = metadata\n+            .modified\n+            .map(|tup| {\n+                mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n+                InterpResult::Ok(tup)\n+            })\n+            .unwrap_or(Ok((0, 0)))?;\n \n         let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n         let __u64_layout = this.libc_ty_layout(\"__u64\")?;\n@@ -1006,10 +1084,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n-    fn rmdir(\n-        &mut self,\n-        path_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n+    fn rmdir(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"`rmdir`\")?;\n@@ -1087,7 +1162,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     name_place.layout.size.bytes(),\n                 )?;\n                 if !name_fits {\n-                    throw_unsup_format!(\"a directory entry had a name too large to fit in libc::dirent64\");\n+                    throw_unsup_format!(\n+                        \"a directory entry had a name too large to fit in libc::dirent64\"\n+                    );\n                 }\n \n                 let entry_place = this.deref_operand(entry_op)?;\n@@ -1175,7 +1252,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     name_place.layout.size.bytes(),\n                 )?;\n                 if !name_fits {\n-                    throw_unsup_format!(\"a directory entry had a name too large to fit in libc::dirent\");\n+                    throw_unsup_format!(\n+                        \"a directory entry had a name too large to fit in libc::dirent\"\n+                    );\n                 }\n \n                 let entry_place = this.deref_operand(entry_op)?;\n@@ -1194,8 +1273,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let file_type = this.file_type_to_d_type(dir_entry.file_type())?;\n \n                 let imms = [\n-                    immty_from_uint_checked(ino, ino_t_layout)?, // d_ino\n-                    immty_from_uint_checked(0u128, off_t_layout)?, // d_seekoff\n+                    immty_from_uint_checked(ino, ino_t_layout)?,      // d_ino\n+                    immty_from_uint_checked(0u128, off_t_layout)?,    // d_seekoff\n                     immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n                     immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n                     immty_from_int_checked(file_type, c_uchar_layout)?, // d_type\n@@ -1352,7 +1431,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         pathname_op: &OpTy<'tcx, Tag>,\n         buf_op: &OpTy<'tcx, Tag>,\n-        bufsize_op: &OpTy<'tcx, Tag>\n+        bufsize_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n@@ -1365,7 +1444,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let result = std::fs::read_link(pathname);\n         match result {\n             Ok(resolved) => {\n-                let resolved = this.convert_path_separator(Cow::Borrowed(resolved.as_ref()), crate::shims::os_str::PathConversion::HostToTarget);\n+                let resolved = this.convert_path_separator(\n+                    Cow::Borrowed(resolved.as_ref()),\n+                    crate::shims::os_str::PathConversion::HostToTarget,\n+                );\n                 let mut path_bytes = crate::shims::os_str::os_str_to_bytes(resolved.as_ref())?;\n                 let bufsize: usize = bufsize.try_into().unwrap();\n                 if path_bytes.len() > bufsize {\n@@ -1388,12 +1470,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n /// `time` is Ok. Returns `None` if `time` is an error. Fails if `time` happens before the unix\n /// epoch.\n fn extract_sec_and_nsec<'tcx>(\n-    time: std::io::Result<SystemTime>\n+    time: std::io::Result<SystemTime>,\n ) -> InterpResult<'tcx, Option<(u64, u32)>> {\n-    time.ok().map(|time| {\n-        let duration = system_time_to_duration(&time)?;\n-        Ok((duration.as_secs(), duration.subsec_nanos()))\n-    }).transpose()\n+    time.ok()\n+        .map(|time| {\n+            let duration = system_time_to_duration(&time)?;\n+            Ok((duration.as_secs(), duration.subsec_nanos()))\n+        })\n+        .transpose()\n }\n \n /// Stores a file's metadata in order to avoid code duplication in the different metadata related\n@@ -1410,13 +1494,10 @@ impl FileMetadata {\n     fn from_path<'tcx, 'mir>(\n         ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         path: &Path,\n-        follow_symlink: bool\n+        follow_symlink: bool,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n-        let metadata = if follow_symlink {\n-            std::fs::metadata(path)\n-        } else {\n-            std::fs::symlink_metadata(path)\n-        };\n+        let metadata =\n+            if follow_symlink { std::fs::metadata(path) } else { std::fs::symlink_metadata(path) };\n \n         FileMetadata::from_meta(ecx, metadata)\n     }"}, {"sha": "1b7ac2754af7182ae415b6ab04d192e26826cfa5", "filename": "src/shims/posix/linux/dlsym.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -3,8 +3,7 @@ use rustc_middle::mir;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n-pub enum Dlsym {\n-}\n+pub enum Dlsym {}\n \n impl Dlsym {\n     // Returns an error for unsupported symbols, and None if this symbol\n@@ -13,7 +12,7 @@ impl Dlsym {\n         Ok(match &*name {\n             \"__pthread_get_minstack\" => None,\n             \"getrandom\" => None, // std falls back to syscall(SYS_getrandom, ...) when this is NULL.\n-            \"statx\" => None, // std falls back to syscall(SYS_statx, ...) when this is NULL.\n+            \"statx\" => None,     // std falls back to syscall(SYS_statx, ...) when this is NULL.\n             _ => throw_unsup_format!(\"unsupported Linux dlsym: {}\", name),\n         })\n     }"}, {"sha": "f7d7706e3f5e9fecf78ee01667fa29ddc93c7852", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,8 +1,8 @@\n use rustc_middle::mir;\n use rustc_target::spec::abi::Abi;\n \n-use crate::*;\n use crate::helpers::{check_abi, check_arg_count};\n+use crate::*;\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::linux::sync::futex;\n use shims::posix::sync::EvalContextExt as _;\n@@ -133,32 +133,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // other types might be treated differently by the calling convention.\n                 for arg in args {\n                     if !matches!(arg.layout.abi, rustc_target::abi::Abi::Scalar(_)) {\n-                        throw_ub_format!(\"`syscall` arguments must all have scalar layout, but {} does not\", arg.layout.ty);\n+                        throw_ub_format!(\n+                            \"`syscall` arguments must all have scalar layout, but {} does not\",\n+                            arg.layout.ty\n+                        );\n                     }\n                 }\n \n-                let sys_getrandom = this\n-                    .eval_libc(\"SYS_getrandom\")?\n-                    .to_machine_usize(this)?;\n+                let sys_getrandom = this.eval_libc(\"SYS_getrandom\")?.to_machine_usize(this)?;\n \n-                let sys_statx = this\n-                    .eval_libc(\"SYS_statx\")?\n-                    .to_machine_usize(this)?;\n+                let sys_statx = this.eval_libc(\"SYS_statx\")?.to_machine_usize(this)?;\n \n-                let sys_futex = this\n-                    .eval_libc(\"SYS_futex\")?\n-                    .to_machine_usize(this)?;\n+                let sys_futex = this.eval_libc(\"SYS_futex\")?.to_machine_usize(this)?;\n \n                 if args.is_empty() {\n-                    throw_ub_format!(\"incorrect number of arguments for syscall: got 0, expected at least 1\");\n+                    throw_ub_format!(\n+                        \"incorrect number of arguments for syscall: got 0, expected at least 1\"\n+                    );\n                 }\n                 match this.read_scalar(&args[0])?.to_machine_usize(this)? {\n                     // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id, so skip over it.\n                         if args.len() < 4 {\n-                            throw_ub_format!(\"incorrect number of arguments for `getrandom` syscall: got {}, expected at least 4\", args.len());\n+                            throw_ub_format!(\n+                                \"incorrect number of arguments for `getrandom` syscall: got {}, expected at least 4\",\n+                                args.len()\n+                            );\n                         }\n                         getrandom(this, &args[1], &args[2], &args[3], dest)?;\n                     }\n@@ -167,9 +169,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     id if id == sys_statx => {\n                         // The first argument is the syscall id, so skip over it.\n                         if args.len() < 6 {\n-                            throw_ub_format!(\"incorrect number of arguments for `statx` syscall: got {}, expected at least 6\", args.len());\n+                            throw_ub_format!(\n+                                \"incorrect number of arguments for `statx` syscall: got {}, expected at least 6\",\n+                                args.len()\n+                            );\n                         }\n-                        let result = this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n+                        let result =\n+                            this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n                     // `futex` is used by some synchonization primitives.\n@@ -200,7 +206,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n-            \"pthread_getattr_np\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+            \"pthread_getattr_np\"\n+                if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") =>\n+            {\n                 check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref _thread, ref _attr] = check_arg_count(args)?;\n                 this.write_null(dest)?;"}, {"sha": "498eb57c57fe0ebc0e9c1d306dad37693046f9d6", "filename": "src/shims/posix/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fmod.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,3 +1,3 @@\n-pub mod foreign_items;\n pub mod dlsym;\n+pub mod foreign_items;\n pub mod sync;"}, {"sha": "c5101203eb46fbbff1bc4dc3c26631c6feb5d7c3", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -18,7 +18,10 @@ pub fn futex<'tcx>(\n     // Therefore we don't use `check_arg_count` here, but only check for the\n     // number of arguments to fall within a range.\n     if args.len() < 4 {\n-        throw_ub_format!(\"incorrect number of arguments for `futex` syscall: got {}, expected at least 4\", args.len());\n+        throw_ub_format!(\n+            \"incorrect number of arguments for `futex` syscall: got {}, expected at least 4\",\n+            args.len()\n+        );\n     }\n \n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n@@ -49,13 +52,18 @@ pub fn futex<'tcx>(\n         // or *timeout expires. `timeout == null` for an infinite timeout.\n         op if op & !futex_realtime == futex_wait => {\n             if args.len() < 5 {\n-                throw_ub_format!(\"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\", args.len());\n+                throw_ub_format!(\n+                    \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\",\n+                    args.len()\n+                );\n             }\n             let timeout = &args[4];\n             let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n                 None\n             } else {\n-                this.check_no_isolation(\"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\")?;\n+                this.check_no_isolation(\n+                    \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\",\n+                )?;\n                 let duration = match this.read_timespec(timeout)? {\n                     Some(duration) => duration,\n                     None => {\n@@ -74,7 +82,11 @@ pub fn futex<'tcx>(\n             // Check the pointer for alignment and validity.\n             // The API requires `addr` to be a 4-byte aligned pointer, and will\n             // use the 4 bytes at the given address as an (atomic) i32.\n-            this.memory.check_ptr_access(addr.to_scalar()?, Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n+            this.memory.check_ptr_access(\n+                addr.to_scalar()?,\n+                Size::from_bytes(4),\n+                Align::from_bytes(4).unwrap(),\n+            )?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             // FIXME: this fails if `addr` is not a pointer type.\n@@ -87,9 +99,14 @@ pub fn futex<'tcx>(\n             //   operations on the same futex word.\"\n             // SeqCst is total order over all operations.\n             // FIXME: check if this should be changed when weak memory orders are added.\n-            let futex_val = this.read_scalar_at_offset_atomic(\n-                &addr.into(), 0, this.machine.layouts.i32, AtomicReadOp::SeqCst\n-            )?.to_i32()?;\n+            let futex_val = this\n+                .read_scalar_at_offset_atomic(\n+                    &addr.into(),\n+                    0,\n+                    this.machine.layouts.i32,\n+                    AtomicReadOp::SeqCst,\n+                )?\n+                .to_i32()?;\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);"}, {"sha": "9a7d3be1eb9aa3011bbdb358e99ae2f2f42b77e5", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -97,7 +97,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let &[ref info] = check_arg_count(args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n-            },\n+            }\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n@@ -162,4 +162,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(true)\n     }\n }\n-"}, {"sha": "434f5f30b5a5689206655f20e623d99789556bb6", "filename": "src/shims/posix/macos/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fmod.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,2 +1,2 @@\n-pub mod foreign_items;\n pub mod dlsym;\n+pub mod foreign_items;"}, {"sha": "f40dfaefb92ac2ca26d1443fed44831eb3fff95f", "filename": "src/shims/posix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmod.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,5 +1,5 @@\n-pub mod foreign_items;\n pub mod dlsym;\n+pub mod foreign_items;\n \n mod fs;\n mod sync;"}, {"sha": "3b68e4eee4405e4e0eb91ea5b5e726c747779672", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -63,8 +63,10 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.read_scalar_at_offset_atomic(\n-        mutex_op, offset, ecx.machine.layouts.i32,\n-        AtomicReadOp::Relaxed\n+        mutex_op,\n+        offset,\n+        ecx.machine.layouts.i32,\n+        AtomicReadOp::Relaxed,\n     )\n }\n \n@@ -75,19 +77,19 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.write_scalar_at_offset_atomic(\n-        mutex_op, offset, kind, ecx.machine.layouts.i32,\n-        AtomicWriteOp::Relaxed\n+        mutex_op,\n+        offset,\n+        kind,\n+        ecx.machine.layouts.i32,\n+        AtomicWriteOp::Relaxed,\n     )\n }\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(\n-        mutex_op, 4, ecx.machine.layouts.u32, \n-        AtomicReadOp::Relaxed\n-    )\n+    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n@@ -96,8 +98,11 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n-        mutex_op, 4, id, ecx.machine.layouts.u32,\n-        AtomicWriteOp::Relaxed\n+        mutex_op,\n+        4,\n+        id,\n+        ecx.machine.layouts.u32,\n+        AtomicWriteOp::Relaxed,\n     )\n }\n \n@@ -128,10 +133,7 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(\n-        rwlock_op, 4, ecx.machine.layouts.u32,\n-        AtomicReadOp::Relaxed\n-    )\n+    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n }\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n@@ -140,8 +142,11 @@ fn rwlock_set_id<'mir, 'tcx: 'mir>(\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n-        rwlock_op, 4, id, ecx.machine.layouts.u32,\n-        AtomicWriteOp::Relaxed\n+        rwlock_op,\n+        4,\n+        id,\n+        ecx.machine.layouts.u32,\n+        AtomicWriteOp::Relaxed,\n     )\n }\n \n@@ -195,10 +200,7 @@ fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(\n-        cond_op, 4, ecx.machine.layouts.u32,\n-        AtomicReadOp::Relaxed\n-    )\n+    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n@@ -207,8 +209,11 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n-        cond_op, 4, id, ecx.machine.layouts.u32,\n-        AtomicWriteOp::Relaxed\n+        cond_op,\n+        4,\n+        id,\n+        ecx.machine.layouts.u32,\n+        AtomicWriteOp::Relaxed,\n     )\n }\n "}, {"sha": "214a2ce411d6c2fec720feb8f46edda6c4872dd4", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -16,7 +16,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.tcx.sess.warn(\n-            \"thread support is experimental and incomplete: weak memory effects are not emulated.\"\n+            \"thread support is experimental and incomplete: weak memory effects are not emulated.\",\n         );\n \n         // Create the new thread\n@@ -31,7 +31,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         )?;\n \n         // Read the function argument that will be sent to the new thread\n-        // before the thread starts executing since reading after the \n+        // before the thread starts executing since reading after the\n         // context switch will incorrectly report a data-race.\n         let fn_ptr = this.read_scalar(start_routine)?.check_init()?;\n         let func_arg = this.read_immediate(arg)?;\n@@ -130,10 +130,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_setname_np(\n-        &mut self,\n-        name: Scalar<Tag>,\n-    ) -> InterpResult<'tcx> {\n+    fn pthread_setname_np(&mut self, name: Scalar<Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"pthread_setname_np\");\n "}, {"sha": "d293e4d12774463bdc391e258fbfd363e68ee152", "filename": "src/shims/time.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,5 +1,5 @@\n-use std::time::{Duration, SystemTime, Instant};\n use std::convert::TryFrom;\n+use std::time::{Duration, Instant, SystemTime};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n@@ -99,7 +99,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let NANOS_PER_INTERVAL = NANOS_PER_SEC / INTERVALS_PER_SEC;\n         let SECONDS_TO_UNIX_EPOCH = INTERVALS_TO_UNIX_EPOCH / INTERVALS_PER_SEC;\n \n-        let duration = system_time_to_duration(&SystemTime::now())? + Duration::from_secs(SECONDS_TO_UNIX_EPOCH);\n+        let duration = system_time_to_duration(&SystemTime::now())?\n+            + Duration::from_secs(SECONDS_TO_UNIX_EPOCH);\n         let duration_ticks = u64::try_from(duration.as_nanos() / u128::from(NANOS_PER_INTERVAL))\n             .map_err(|_| err_unsup_format!(\"programs running more than 2^64 Windows ticks after the Windows epoch are not supported\"))?;\n \n@@ -115,7 +116,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn QueryPerformanceCounter(&mut self, lpPerformanceCount_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn QueryPerformanceCounter(\n+        &mut self,\n+        lpPerformanceCount_op: &OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceCounter\");\n@@ -124,14 +128,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // QueryPerformanceCounter uses a hardware counter as its basis.\n         // Miri will emulate a counter with a resolution of 1 nanosecond.\n         let duration = Instant::now().duration_since(this.machine.time_anchor);\n-        let qpc = i64::try_from(duration.as_nanos())\n-            .map_err(|_| err_unsup_format!(\"programs running longer than 2^63 nanoseconds are not supported\"))?;\n-        this.write_scalar(Scalar::from_i64(qpc), &this.deref_operand(lpPerformanceCount_op)?.into())?;\n+        let qpc = i64::try_from(duration.as_nanos()).map_err(|_| {\n+            err_unsup_format!(\"programs running longer than 2^63 nanoseconds are not supported\")\n+        })?;\n+        this.write_scalar(\n+            Scalar::from_i64(qpc),\n+            &this.deref_operand(lpPerformanceCount_op)?.into(),\n+        )?;\n         Ok(-1) // return non-zero on success\n     }\n \n     #[allow(non_snake_case)]\n-    fn QueryPerformanceFrequency(&mut self, lpFrequency_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn QueryPerformanceFrequency(\n+        &mut self,\n+        lpFrequency_op: &OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceFrequency\");\n@@ -142,7 +153,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // is consistent across all processors.\n         // Miri emulates a \"hardware\" performance counter with a resolution of 1ns,\n         // and thus 10^9 counts per second.\n-        this.write_scalar(Scalar::from_i64(1_000_000_000), &this.deref_operand(lpFrequency_op)?.into())?;\n+        this.write_scalar(\n+            Scalar::from_i64(1_000_000_000),\n+            &this.deref_operand(lpFrequency_op)?.into(),\n+        )?;\n         Ok(-1) // Return non-zero on success\n     }\n \n@@ -155,8 +169,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // This returns a u64, with time units determined dynamically by `mach_timebase_info`.\n         // We return plain nanoseconds.\n         let duration = Instant::now().duration_since(this.machine.time_anchor);\n-        u64::try_from(duration.as_nanos())\n-            .map_err(|_| err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\").into())\n+        u64::try_from(duration.as_nanos()).map_err(|_| {\n+            err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\")\n+                .into()\n+        })\n     }\n \n     fn mach_timebase_info(&mut self, info_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n@@ -169,10 +185,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Since our emulated ticks in `mach_absolute_time` *are* nanoseconds,\n         // no scaling needs to happen.\n-        let (numer, denom) = (1,1);\n+        let (numer, denom) = (1, 1);\n         let imms = [\n             immty_from_int_checked(numer, this.machine.layouts.u32)?,\n-            immty_from_int_checked(denom, this.machine.layouts.u32)?\n+            immty_from_int_checked(denom, this.machine.layouts.u32)?,\n         ];\n \n         this.write_packed_immediates(&info, &imms)?;"}, {"sha": "239364508e08ffd660ef91122765109de568abb7", "filename": "src/shims/tls.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,14 +1,14 @@\n //! Implement thread-local storage.\n \n-use std::collections::BTreeMap;\n use std::collections::btree_map::Entry as BTreeEntry;\n use std::collections::hash_map::Entry as HashMapEntry;\n+use std::collections::BTreeMap;\n \n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty;\n-use rustc_target::abi::{Size, HasDataLayout};\n+use rustc_target::abi::{HasDataLayout, Size};\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n@@ -63,7 +63,11 @@ impl<'tcx> Default for TlsData<'tcx> {\n impl<'tcx> TlsData<'tcx> {\n     /// Generate a new TLS key with the given destructor.\n     /// `max_size` determines the integer size the key has to fit in.\n-    pub fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>, max_size: Size) -> InterpResult<'tcx, TlsKey> {\n+    pub fn create_tls_key(\n+        &mut self,\n+        dtor: Option<ty::Instance<'tcx>>,\n+        max_size: Size,\n+    ) -> InterpResult<'tcx, TlsKey> {\n         let new_key = self.next_key;\n         self.next_key += 1;\n         self.keys.try_insert(new_key, TlsEntry { data: Default::default(), dtor }).unwrap();\n@@ -105,7 +109,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: TlsKey,\n         thread_id: ThreadId,\n-        new_data: Option<Scalar<Tag>>\n+        new_data: Option<Scalar<Tag>>,\n     ) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(TlsEntry { data, .. }) => {\n@@ -138,14 +142,18 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         thread: ThreadId,\n         dtor: ty::Instance<'tcx>,\n-        data: Scalar<Tag>\n+        data: Scalar<Tag>,\n     ) -> InterpResult<'tcx> {\n         if self.dtors_running.contains_key(&thread) {\n             // UB, according to libstd docs.\n-            throw_ub_format!(\"setting thread's local storage destructor while destructors are already running\");\n+            throw_ub_format!(\n+                \"setting thread's local storage destructor while destructors are already running\"\n+            );\n         }\n         if self.macos_thread_dtors.insert(thread, (dtor, data)).is_some() {\n-            throw_unsup_format!(\"setting more than one thread local storage destructor for the same thread is not supported\");\n+            throw_unsup_format!(\n+                \"setting more than one thread local storage destructor for the same thread is not supported\"\n+            );\n         }\n         Ok(())\n     }\n@@ -181,9 +189,7 @@ impl<'tcx> TlsData<'tcx> {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n-        for (&key, TlsEntry { data, dtor }) in\n-            thread_local.range_mut((start, Unbounded))\n-        {\n+        for (&key, TlsEntry { data, dtor }) in thread_local.range_mut((start, Unbounded)) {\n             match data.entry(thread_id) {\n                 BTreeEntry::Occupied(entry) => {\n                     if let Some(dtor) = dtor {\n@@ -237,7 +243,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n         // we specifically look up the static in libstd that we know is placed\n         // in that section.\n-        let thread_callback = this.eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"thread_local_key\", \"p_thread_callback\"])?;\n+        let thread_callback = this.eval_path_scalar(&[\n+            \"std\",\n+            \"sys\",\n+            \"windows\",\n+            \"thread_local_key\",\n+            \"p_thread_callback\",\n+        ])?;\n         let thread_callback = this.memory.get_fn(thread_callback.check_init()?)?.as_instance()?;\n \n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n@@ -297,12 +309,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n             dtor @ Some(_) => dtor,\n             // We ran each dtor once, start over from the beginning.\n-            None => {\n-                this.machine.tls.fetch_tls_dtor(None, active_thread)\n-            }\n+            None => this.machine.tls.fetch_tls_dtor(None, active_thread),\n         };\n         if let Some((instance, ptr, key)) = dtor {\n-            this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = Some(key);\n+            this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key =\n+                Some(key);\n             trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n             assert!(!this.is_null(ptr).unwrap(), \"data can't be NULL when dtor is called!\");\n \n@@ -326,7 +337,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-\n     /// Schedule an active thread's TLS destructor to run on the active thread.\n     /// Note that this function does not run the destructors itself, it just\n     /// schedules them one by one each time it is called and reenables the\n@@ -349,7 +359,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // relevant function, reenabling the thread, and going back to\n                 // the scheduler.\n                 this.schedule_windows_tls_dtors()?;\n-                return Ok(())\n+                return Ok(());\n             }\n         }\n         // The remaining dtors make some progress each time around the scheduler loop,\n@@ -361,12 +371,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // We have scheduled a MacOS dtor to run on the thread. Execute it\n             // to completion and come back here. Scheduling a destructor\n             // destroys it, so we will not enter this branch again.\n-            return Ok(())\n+            return Ok(());\n         }\n         if this.schedule_next_pthread_tls_dtor()? {\n             // We have scheduled a pthread destructor and removed it from the\n             // destructors list. Run it to completion and come back here.\n-            return Ok(())\n+            return Ok(());\n         }\n \n         // All dtors done!"}, {"sha": "ace6c4674ae990ee68efe68ffeb10a2320b2d348", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -5,8 +5,7 @@ use crate::*;\n use helpers::check_abi;\n \n #[derive(Debug, Copy, Clone)]\n-pub enum Dlsym {\n-}\n+pub enum Dlsym {}\n \n impl Dlsym {\n     // Returns an error for unsupported symbols, and None if this symbol"}, {"sha": "655f6b08c2c34315b875baf0e13b9b1e976a23d7", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -75,7 +75,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"WriteFile\" => {\n                 check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] = check_arg_count(args)?;\n+                let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] =\n+                    check_arg_count(args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -95,17 +96,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     res.ok().map(|n| n as u32)\n                 } else {\n-                    throw_unsup_format!(\"on Windows, writing to anything except stdout/stderr is not supported\")\n+                    throw_unsup_format!(\n+                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n+                    )\n                 };\n                 // If there was no error, write back how much was written.\n                 if let Some(n) = written {\n                     this.write_scalar(Scalar::from_u32(n), &written_place.into())?;\n                 }\n                 // Return whether this was a success.\n-                this.write_scalar(\n-                    Scalar::from_i32(if written.is_some() { 1 } else { 0 }),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_i32(if written.is_some() { 1 } else { 0 }), dest)?;\n             }\n \n             // Allocation\n@@ -297,11 +297,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n-                if flags != 2 { // BCRYPT_USE_SYSTEM_PREFERRED_RNG\n-                    throw_unsup_format!(\"BCryptGenRandom is supported only with the BCRYPT_USE_SYSTEM_PREFERRED_RNG flag\");\n+                if flags != 2 {\n+                    // BCRYPT_USE_SYSTEM_PREFERRED_RNG\n+                    throw_unsup_format!(\n+                        \"BCryptGenRandom is supported only with the BCRYPT_USE_SYSTEM_PREFERRED_RNG flag\"\n+                    );\n                 }\n                 if algorithm.to_machine_usize(this)? != 0 {\n-                    throw_unsup_format!(\"BCryptGenRandom algorithm must be NULL when the flag is BCRYPT_USE_SYSTEM_PREFERRED_RNG\");\n+                    throw_unsup_format!(\n+                        \"BCryptGenRandom algorithm must be NULL when the flag is BCRYPT_USE_SYSTEM_PREFERRED_RNG\"\n+                    );\n                 }\n                 this.gen_random(ptr, len.into())?;\n                 this.write_null(dest)?; // STATUS_SUCCESS\n@@ -342,27 +347,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n-            \"GetProcessHeap\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+            \"GetProcessHeap\"\n+                if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n+            {\n                 check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n-            \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+            \"SetConsoleTextAttribute\"\n+                if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n+            {\n                 check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _hConsoleOutput, ref _wAttribute] = check_arg_count(args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n-            \"AddVectoredExceptionHandler\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+            \"AddVectoredExceptionHandler\"\n+                if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n+            {\n                 check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _First, ref _Handler] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n             }\n-            \"SetThreadStackGuarantee\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+            \"SetThreadStackGuarantee\"\n+                if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n+            {\n                 check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[_StackSizeInBytes] = check_arg_count(args)?;\n@@ -373,21 +386,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"EnterCriticalSection\"\n             | \"LeaveCriticalSection\"\n             | \"DeleteCriticalSection\"\n-            if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n+            {\n                 check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+                assert_eq!(\n+                    this.get_total_thread_count(),\n+                    1,\n+                    \"concurrency on Windows is not supported\"\n+                );\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n             }\n             \"TryEnterCriticalSection\"\n-            if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n+            {\n                 check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+                assert_eq!(\n+                    this.get_total_thread_count(),\n+                    1,\n+                    \"concurrency on Windows is not supported\"\n+                );\n                 // There is only one thread, so this always succeeds and returns TRUE.\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n@@ -398,4 +421,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(true)\n     }\n }\n-"}, {"sha": "668d69966bc4c7786e8d403769eb8977b1d376ca", "filename": "src/shims/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fmod.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,4 +1,4 @@\n-pub mod foreign_items;\n pub mod dlsym;\n+pub mod foreign_items;\n \n mod sync;"}, {"sha": "78458dc6c9977cd971470817a8db1a59c419f86b", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -22,10 +22,7 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     #[allow(non_snake_case)]\n-    fn AcquireSRWLockExclusive(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n+    fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -47,10 +44,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn TryAcquireSRWLockExclusive(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, u8> {\n+    fn TryAcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, u8> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -65,27 +59,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn ReleaseSRWLockExclusive(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n+    fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_writer_unlock(id, active_thread) {\n             // The docs do not say anything about this case, but it seems better to not allow it.\n-            throw_ub_format!(\"calling ReleaseSRWLockExclusive on an SRWLock that is not exclusively locked by the current thread\");\n+            throw_ub_format!(\n+                \"calling ReleaseSRWLockExclusive on an SRWLock that is not exclusively locked by the current thread\"\n+            );\n         }\n \n         Ok(())\n     }\n \n     #[allow(non_snake_case)]\n-    fn AcquireSRWLockShared(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n+    fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -100,10 +90,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn TryAcquireSRWLockShared(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, u8> {\n+    fn TryAcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, u8> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -117,17 +104,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn ReleaseSRWLockShared(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n+    fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_reader_unlock(id, active_thread) {\n             // The docs do not say anything about this case, but it seems better to not allow it.\n-            throw_ub_format!(\"calling ReleaseSRWLockShared on an SRWLock that is not locked by the current thread\");\n+            throw_ub_format!(\n+                \"calling ReleaseSRWLockShared on an SRWLock that is not locked by the current thread\"\n+            );\n         }\n \n         Ok(())"}, {"sha": "88f42efd13cf0cfa4915a00db1ea4e71e7b7a45a", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -9,10 +9,10 @@ use std::rc::Rc;\n use log::trace;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::Mutability;\n use rustc_middle::mir::RetagKind;\n use rustc_middle::ty;\n use rustc_target::abi::{Align, LayoutOf, Size};\n-use rustc_hir::Mutability;\n \n use crate::*;\n \n@@ -157,7 +157,11 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalState {\n-    pub fn new(tracked_pointer_tag: Option<PtrId>, tracked_call_id: Option<CallId>, track_raw: bool) -> Self {\n+    pub fn new(\n+        tracked_pointer_tag: Option<PtrId>,\n+        tracked_call_id: Option<CallId>,\n+        track_raw: bool,\n+    ) -> Self {\n         GlobalState {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n             base_ptr_ids: FxHashMap::default(),\n@@ -211,7 +215,9 @@ impl GlobalState {\n fn err_sb_ub(msg: String) -> InterpError<'static> {\n     err_machine_stop!(TerminationInfo::ExperimentalUb {\n         msg,\n-        url: format!(\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"),\n+        url: format!(\n+            \"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"\n+        ),\n     })\n }\n \n@@ -300,10 +306,7 @@ impl<'tcx> Stack {\n                         tag, item\n                     )))?\n                 } else {\n-                    Err(err_sb_ub(format!(\n-                        \"deallocating while item is protected: {:?}\",\n-                        item\n-                    )))?\n+                    Err(err_sb_ub(format!(\"deallocating while item is protected: {:?}\", item)))?\n                 }\n             }\n         }\n@@ -312,14 +315,21 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n-    fn access(&mut self, access: AccessKind, ptr: Pointer<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn access(\n+        &mut self,\n+        access: AccessKind,\n+        ptr: Pointer<Tag>,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n         let granting_idx = self.find_granting(access, ptr.tag).ok_or_else(|| {\n             err_sb_ub(format!(\n                 \"no item granting {} to tag {:?} at {} found in borrow stack.\",\n-                access, ptr.tag, ptr.erase_tag(),\n+                access,\n+                ptr.tag,\n+                ptr.erase_tag(),\n             ))\n         })?;\n \n@@ -379,7 +389,12 @@ impl<'tcx> Stack {\n     /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n     /// an access, and they add the new item directly on top of the one it is derived\n     /// from instead of all the way at the top of the stack.\n-    fn grant(&mut self, derived_from: Pointer<Tag>, new: Item, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn grant(\n+        &mut self,\n+        derived_from: Pointer<Tag>,\n+        new: Item,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n@@ -480,12 +495,17 @@ impl Stacks {\n             // `ExternStatic` is used for extern statics, and thus must also be listed here.\n             // `Env` we list because we can get away with precise tracking there.\n             // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n-            MemoryKind::Machine(MiriMemoryKind::Global | MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls | MiriMemoryKind::Env) =>\n-                (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Global\n+                | MiriMemoryKind::ExternStatic\n+                | MiriMemoryKind::Tls\n+                | MiriMemoryKind::Env,\n+            ) => (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n             // Everything else we handle like raw pointers for now.\n             _ => {\n                 let mut extra = extra.borrow_mut();\n-                let tag = if extra.track_raw { Tag::Tagged(extra.new_ptr()) } else { Tag::Untagged };\n+                let tag =\n+                    if extra.track_raw { Tag::Tagged(extra.new_ptr()) } else { Tag::Untagged };\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n@@ -584,9 +604,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n-        let size = this\n-            .size_and_align_of_mplace(&place)?\n-            .map(|(size, _)| size);\n+        let size = this.size_and_align_of_mplace(&place)?.map(|(size, _)| size);\n         // FIXME: If we cannot determine the size (because the unsized tail is an `extern type`),\n         // bail out -- we cannot reasonably figure out which memory range to reborrow.\n         // See https://github.com/rust-lang/unsafe-code-guidelines/issues/276.\n@@ -667,7 +685,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// After a stack frame got pushed, retag the return place so that we are sure\n     /// it does not alias with anything.\n-    /// \n+    ///\n     /// This is a HACK because there is nothing in MIR that would make the retag\n     /// explicit. Also see https://github.com/rust-lang/rust/issues/71117.\n     fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n@@ -690,7 +708,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(), ptr_layout);\n         // Reborrow it.\n-        let val = this.retag_reference(&val, RefKind::Unique { two_phase: false }, /*protector*/ true)?;\n+        let val = this.retag_reference(\n+            &val,\n+            RefKind::Unique { two_phase: false },\n+            /*protector*/ true,\n+        )?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;\n         this.frame_mut().return_place = Some(return_place.into());"}, {"sha": "b53af0aeb24aeb7b1b5cdbeb8dfe1d50951f29bc", "filename": "src/sync.rs", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -66,7 +66,7 @@ struct Mutex {\n     /// released to during unlock and acquired from during\n     /// locking, and therefore stores the clock of the last\n     /// thread to release this mutex.\n-    data_race: VClock\n+    data_race: VClock,\n }\n \n declare_id!(RwLockId);\n@@ -98,7 +98,7 @@ struct RwLock {\n     /// is stored to the main data_race variable once all\n     /// readers are finished.\n     /// Has to be stored separately since reader lock acquires\n-    /// must load the clock of the last write and must not \n+    /// must load the clock of the last write and must not\n     /// add happens-before orderings between shared reader\n     /// locks.\n     data_race_reader: VClock,\n@@ -251,11 +251,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// count. If the lock count reaches 0, release the lock and potentially\n     /// give to a new owner. If the lock was not locked by `expected_owner`,\n     /// return `None`.\n-    fn mutex_unlock(\n-        &mut self,\n-        id: MutexId,\n-        expected_owner: ThreadId,\n-    ) -> Option<usize> {\n+    fn mutex_unlock(&mut self, id: MutexId, expected_owner: ThreadId) -> Option<usize> {\n         let this = self.eval_context_mut();\n         let mutex = &mut this.machine.threads.sync.mutexes[id];\n         if let Some(current_owner) = mutex.owner {\n@@ -307,9 +303,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let rwlock = &this.machine.threads.sync.rwlocks[id];\n         trace!(\n             \"rwlock_is_locked: {:?} writer is {:?} and there are {} reader threads (some of which could hold multiple read locks)\",\n-            id, rwlock.writer, rwlock.readers.len(),\n+            id,\n+            rwlock.writer,\n+            rwlock.readers.len(),\n         );\n-        rwlock.writer.is_some()|| rwlock.readers.is_empty().not()\n+        rwlock.writer.is_some() || rwlock.readers.is_empty().not()\n     }\n \n     #[inline]\n@@ -360,7 +358,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // The thread was a reader. If the lock is not held any more, give it to a writer.\n         if this.rwlock_is_locked(id).not() {\n-\n             // All the readers are finished, so set the writer data-race handle to the value\n             //  of the union of all reader data race handles, since the set of readers\n             //  happen-before the writers\n@@ -373,11 +370,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Put the reader in the queue waiting for the lock and block it.\n-    fn rwlock_enqueue_and_block_reader(\n-        &mut self,\n-        id: RwLockId,\n-        reader: ThreadId,\n-    ) {\n+    fn rwlock_enqueue_and_block_reader(&mut self, id: RwLockId, reader: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"read-queueing on not write locked rwlock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n@@ -437,11 +430,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Put the writer in the queue waiting for the lock.\n-    fn rwlock_enqueue_and_block_writer(\n-        &mut self,\n-        id: RwLockId,\n-        writer: ThreadId,\n-    ) {\n+    fn rwlock_enqueue_and_block_writer(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"write-queueing on unlocked rwlock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n@@ -482,14 +471,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(data_race) = data_race {\n             data_race.validate_lock_release(&mut condvar.data_race, current_thread);\n         }\n-        condvar.waiters\n-            .pop_front()\n-            .map(|waiter| {\n-                if let Some(data_race) = data_race {\n-                    data_race.validate_lock_acquire(&mut condvar.data_race, waiter.thread);\n-                }\n-                (waiter.thread, waiter.mutex)\n-            })\n+        condvar.waiters.pop_front().map(|waiter| {\n+            if let Some(data_race) = data_race {\n+                data_race.validate_lock_acquire(&mut condvar.data_race, waiter.thread);\n+            }\n+            (waiter.thread, waiter.mutex)\n+        })\n     }\n \n     #[inline]\n@@ -511,15 +498,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr.erase_tag())?;\n-        let data_race =  &this.memory.extra.data_race;\n+        let data_race = &this.memory.extra.data_race;\n \n         // Each futex-wake happens-before the end of the futex wait\n         if let Some(data_race) = data_race {\n             data_race.validate_lock_release(&mut futex.data_race, current_thread);\n         }\n         let res = futex.waiters.pop_front().map(|waiter| {\n             if let Some(data_race) = data_race {\n-                data_race.validate_lock_acquire(&futex.data_race, waiter.thread);  \n+                data_race.validate_lock_acquire(&futex.data_race, waiter.thread);\n             }\n             waiter.thread\n         });"}, {"sha": "7d6fe8041e98000b7dbea1be756ec1edd80412de", "filename": "src/thread.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -3,8 +3,8 @@\n use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::convert::TryFrom;\n-use std::rc::Rc;\n use std::num::TryFromIntError;\n+use std::rc::Rc;\n use std::time::{Duration, Instant, SystemTime};\n \n use log::trace;\n@@ -141,17 +141,19 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n \n     /// Get the name of the current thread, or `<unnamed>` if it was not set.\n     fn thread_name(&self) -> &[u8] {\n-        if let Some(ref thread_name) = self.thread_name {\n-            thread_name\n-        } else {\n-            b\"<unnamed>\"\n-        }\n+        if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n     }\n }\n \n impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"{}({:?}, {:?})\", String::from_utf8_lossy(self.thread_name()), self.state, self.join_status)\n+        write!(\n+            f,\n+            \"{}({:?}, {:?})\",\n+            String::from_utf8_lossy(self.thread_name()),\n+            self.state,\n+            self.join_status\n+        )\n     }\n }\n \n@@ -328,7 +330,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Mark that the active thread tries to join the thread with `joined_thread_id`.\n-    fn join_thread(&mut self, joined_thread_id: ThreadId, data_race: &Option<Rc<data_race::GlobalState>>) -> InterpResult<'tcx> {\n+    fn join_thread(\n+        &mut self,\n+        joined_thread_id: ThreadId,\n+        data_race: &Option<Rc<data_race::GlobalState>>,\n+    ) -> InterpResult<'tcx> {\n         if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n             throw_ub_format!(\"trying to join a detached or already joined thread\");\n         }\n@@ -431,7 +437,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Wakes up threads joining on the active one and deallocates thread-local statics.\n     /// The `AllocId` that can now be freed is returned.\n-    fn thread_terminated(&mut self, data_race: &Option<Rc<data_race::GlobalState>>) -> Vec<AllocId> {\n+    fn thread_terminated(\n+        &mut self,\n+        data_race: &Option<Rc<data_race::GlobalState>>,\n+    ) -> Vec<AllocId> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n@@ -470,7 +479,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// used in stateless model checkers such as Loom: run the active thread as\n     /// long as we can and switch only when we have to (the active thread was\n     /// blocked, terminated, or has explicitly asked to be preempted).\n-    fn schedule(&mut self, data_race: &Option<Rc<data_race::GlobalState>>) -> InterpResult<'tcx, SchedulingAction> {\n+    fn schedule(\n+        &mut self,\n+        data_race: &Option<Rc<data_race::GlobalState>>,\n+    ) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets\n         // the thread state to terminated).\n@@ -546,7 +558,10 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Get a thread-specific allocation id for the given thread-local static.\n     /// If needed, allocate a new one.\n-    fn get_or_create_thread_local_alloc_id(&mut self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n+    fn get_or_create_thread_local_alloc_id(\n+        &mut self,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, AllocId> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n         if let Some(new_alloc_id) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n@@ -562,7 +577,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             let allocation = tcx.eval_static_initializer(def_id)?;\n             // Create a fresh allocation with this content.\n-            let new_alloc_id = this.memory.allocate_with(allocation.clone(), MiriMemoryKind::Tls.into()).alloc_id;\n+            let new_alloc_id =\n+                this.memory.allocate_with(allocation.clone(), MiriMemoryKind::Tls.into()).alloc_id;\n             this.machine.threads.set_thread_local_alloc_id(def_id, new_alloc_id);\n             Ok(new_alloc_id)\n         }\n@@ -654,9 +670,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &this.memory.extra.data_race {\n             if let Ok(string) = String::from_utf8(new_thread_name.clone()) {\n-                data_race.thread_set_name(\n-                    this.machine.threads.active_thread, string\n-                );\n+                data_race.thread_set_name(this.machine.threads.active_thread, string);\n             }\n         }\n         this.machine.threads.set_thread_name(new_thread_name);"}, {"sha": "a2e235858d83abf13f4cf8bc7f37ad9e923d4f16", "filename": "src/vector_clock.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e231bab5ef620073c3c29b9b1f507f4a8f8c448/src%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvector_clock.rs?ref=4e231bab5ef620073c3c29b9b1f507f4a8f8c448", "patch": "@@ -1,11 +1,6 @@\n use rustc_index::vec::Idx;\n use smallvec::SmallVec;\n-use std::{\n-    cmp::Ordering,\n-    convert::TryFrom,\n-    fmt::Debug,\n-    ops::Index,\n-};\n+use std::{cmp::Ordering, convert::TryFrom, fmt::Debug, ops::Index};\n \n /// A vector clock index, this is associated with a thread id\n /// but in some cases one vector index may be shared with"}]}