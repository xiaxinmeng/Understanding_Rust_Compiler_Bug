{"sha": "459652c832815118cf78c30f7a59cea99c43d308", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OTY1MmM4MzI4MTUxMThjZjc4YzMwZjdhNTljZWE5OWM0M2QzMDg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-05-10T05:31:46Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-05-10T05:31:46Z"}, "message": "Rollup merge of #25251 - nham:whitespace_lang_items, r=Manishearth\n\nIn my opinion this looks nicer, but also it matches the whitespace generally\r\nused for stability markers.", "tree": {"sha": "e619018cbe727c13c3a4c13d8a470fe79de4a6a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e619018cbe727c13c3a4c13d8a470fe79de4a6a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/459652c832815118cf78c30f7a59cea99c43d308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/459652c832815118cf78c30f7a59cea99c43d308", "html_url": "https://github.com/rust-lang/rust/commit/459652c832815118cf78c30f7a59cea99c43d308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/459652c832815118cf78c30f7a59cea99c43d308/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd099b2d50e38a3ccd3f43e4457e5f73f089f075", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd099b2d50e38a3ccd3f43e4457e5f73f089f075", "html_url": "https://github.com/rust-lang/rust/commit/fd099b2d50e38a3ccd3f43e4457e5f73f089f075"}, {"sha": "7984074e25e2d4ac2b5bc125d44e38a280f964f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7984074e25e2d4ac2b5bc125d44e38a280f964f9", "html_url": "https://github.com/rust-lang/rust/commit/7984074e25e2d4ac2b5bc125d44e38a280f964f9"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "16fdcfa301392532ddf1444044adf1f8f7417bb8", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -2028,7 +2028,7 @@ makes it possible to declare these operations. For example, the `str` module\n in the Rust standard library defines the string equality function:\n \n ```{.ignore}\n-#[lang=\"str_eq\"]\n+#[lang = \"str_eq\"]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     // details elided\n }"}, {"sha": "4808ad6ff1febb22e55291320747f7a6c10f1b15", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -7,7 +7,7 @@\n The `rustc` compiler has certain pluggable operations, that is,\n functionality that isn't hard-coded into the language, but is\n implemented in libraries, with a special marker to tell the compiler\n-it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n+it exists. The marker is the attribute `#[lang = \"...\"]` and there are\n various different values of `...`, i.e. various different 'lang\n items'.\n \n@@ -28,7 +28,7 @@ extern {\n #[lang = \"owned_box\"]\n pub struct Box<T>(*mut T);\n \n-#[lang=\"exchange_malloc\"]\n+#[lang = \"exchange_malloc\"]\n unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n@@ -39,7 +39,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n \n     p\n }\n-#[lang=\"exchange_free\"]\n+#[lang = \"exchange_free\"]\n unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n     libc::free(ptr as *mut libc::c_void)\n }"}, {"sha": "83795a24c816066f17ed1997c7ca77e6aad03706", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -95,7 +95,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n #[cfg(not(test))]\n-#[lang=\"exchange_malloc\"]\n+#[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n@@ -108,7 +108,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n }\n \n #[cfg(not(test))]\n-#[lang=\"exchange_free\"]\n+#[lang = \"exchange_free\"]\n #[inline]\n unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);"}, {"sha": "bf5fdb973eb768a84672f87f7b18bda1dfcca26e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -634,7 +634,7 @@ impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n ///\n /// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n /// recommended to access its fields directly, `get` should be used instead.\n-#[lang=\"unsafe_cell\"]\n+#[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T: ?Sized> {\n     /// Wrapped value"}, {"sha": "dab549f784cf82bf68a175fa0d67b7423729b8c8", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -41,7 +41,7 @@ use option::Option::{self, Some, None};\n /// PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by\n /// default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict\n /// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n-#[lang=\"eq\"]\n+#[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n@@ -222,7 +222,7 @@ impl PartialOrd for Ordering {\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n-#[lang=\"ord\"]\n+#[lang = \"ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values if one exists."}, {"sha": "e4d2ab198630a4fd5ed8875e82333d72739d0fe0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -82,7 +82,7 @@ fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n /// is returned. A concrete Iterator implementation may choose to behave however\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n-#[lang=\"iterator\"]\n+#[lang = \"iterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n                             `.iter()` or a similar method\"]"}, {"sha": "3aaedaeb813e38a1186848dddb09932ddfa59564", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -33,7 +33,7 @@ use hash::Hasher;\n \n /// Types able to be transferred across thread boundaries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"send\"]\n+#[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n pub unsafe trait Send {\n     // empty.\n@@ -46,7 +46,7 @@ impl<T> !Send for *mut T { }\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"sized\"]\n+#[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n pub trait Sized {\n@@ -154,7 +154,7 @@ pub trait Sized {\n /// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"copy\"]\n+#[lang = \"copy\"]\n pub trait Copy : Clone {\n     // Empty.\n }\n@@ -201,7 +201,7 @@ pub trait Copy : Clone {\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"sync\"]\n+#[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n pub unsafe trait Sync {\n     // Empty\n@@ -217,7 +217,7 @@ impl<T> !Sync for *mut T { }\n /// ensure that they are never copied, even if they lack a destructor.\n #[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n-#[lang=\"no_copy_bound\"]\n+#[lang = \"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct NoCopy;\n \n@@ -359,7 +359,7 @@ macro_rules! impls{\n /// better to use a reference type, like `PhantomData<&'a T>`\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n-#[lang=\"phantom_data\"]\n+#[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n "}, {"sha": "13b6468105dcf9d88a0c8c3db50bd33cdc6b1221", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -31,7 +31,7 @@ unsafe impl Zeroable for u64 {}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n-#[lang=\"non_zero\"]\n+#[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n #[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);"}, {"sha": "55c4264b10c7063cd343c9bed2b37daf73cf2abb", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -91,7 +91,7 @@ use fmt;\n ///     let _x = HasDrop;\n /// }\n /// ```\n-#[lang=\"drop\"]\n+#[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n@@ -181,7 +181,7 @@ macro_rules! forward_ref_binop {\n ///     Foo + Foo;\n /// }\n /// ```\n-#[lang=\"add\"]\n+#[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n     /// The resulting type after applying the `+` operator\n@@ -235,7 +235,7 @@ add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo - Foo;\n /// }\n /// ```\n-#[lang=\"sub\"]\n+#[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n     /// The resulting type after applying the `-` operator\n@@ -289,7 +289,7 @@ sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo * Foo;\n /// }\n /// ```\n-#[lang=\"mul\"]\n+#[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n     /// The resulting type after applying the `*` operator\n@@ -343,7 +343,7 @@ mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo / Foo;\n /// }\n /// ```\n-#[lang=\"div\"]\n+#[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n     /// The resulting type after applying the `/` operator\n@@ -397,7 +397,7 @@ div_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo % Foo;\n /// }\n /// ```\n-#[lang=\"rem\"]\n+#[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n     /// The resulting type after applying the `%` operator\n@@ -470,7 +470,7 @@ rem_float_impl! { f64, fmod }\n ///     -Foo;\n /// }\n /// ```\n-#[lang=\"neg\"]\n+#[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n     /// The resulting type after applying the `-` operator\n@@ -541,7 +541,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }\n ///     !Foo;\n /// }\n /// ```\n-#[lang=\"not\"]\n+#[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n     /// The resulting type after applying the `!` operator\n@@ -595,7 +595,7 @@ not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo & Foo;\n /// }\n /// ```\n-#[lang=\"bitand\"]\n+#[lang = \"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n     /// The resulting type after applying the `&` operator\n@@ -649,7 +649,7 @@ bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo | Foo;\n /// }\n /// ```\n-#[lang=\"bitor\"]\n+#[lang = \"bitor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n     /// The resulting type after applying the `|` operator\n@@ -703,7 +703,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo ^ Foo;\n /// }\n /// ```\n-#[lang=\"bitxor\"]\n+#[lang = \"bitxor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n     /// The resulting type after applying the `^` operator\n@@ -757,7 +757,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo << Foo;\n /// }\n /// ```\n-#[lang=\"shl\"]\n+#[lang = \"shl\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n     /// The resulting type after applying the `<<` operator\n@@ -829,7 +829,7 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n ///     Foo >> Foo;\n /// }\n /// ```\n-#[lang=\"shr\"]\n+#[lang = \"shr\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n     /// The resulting type after applying the `>>` operator\n@@ -902,7 +902,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n ///     Foo[Bar];\n /// }\n /// ```\n-#[lang=\"index\"]\n+#[lang = \"index\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Idx: ?Sized> {\n@@ -949,7 +949,7 @@ pub trait Index<Idx: ?Sized> {\n ///     &mut Foo[Bar];\n /// }\n /// ```\n-#[lang=\"index_mut\"]\n+#[lang = \"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n@@ -960,7 +960,7 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang=\"range_full\"]\n+#[lang = \"range_full\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n \n@@ -973,7 +973,7 @@ impl fmt::Debug for RangeFull {\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Clone, PartialEq, Eq)]\n-#[lang=\"range\"]\n+#[lang = \"range\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -993,7 +993,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n \n /// A range which is only bounded below.\n #[derive(Clone, PartialEq, Eq)]\n-#[lang=\"range_from\"]\n+#[lang = \"range_from\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -1010,7 +1010,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n \n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang=\"range_to\"]\n+#[lang = \"range_to\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n@@ -1053,7 +1053,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n ///     assert_eq!('a', *x);\n /// }\n /// ```\n-#[lang=\"deref\"]\n+#[lang = \"deref\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n     /// The resulting type after dereferencing\n@@ -1114,7 +1114,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n ///     assert_eq!('b', *x);\n /// }\n /// ```\n-#[lang=\"deref_mut\"]\n+#[lang = \"deref_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n@@ -1128,7 +1128,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n }\n \n /// A version of the call operator that takes an immutable receiver.\n-#[lang=\"fn\"]\n+#[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n@@ -1138,7 +1138,7 @@ pub trait Fn<Args> : FnMut<Args> {\n }\n \n /// A version of the call operator that takes a mutable receiver.\n-#[lang=\"fn_mut\"]\n+#[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n@@ -1148,7 +1148,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n }\n \n /// A version of the call operator that takes a by-value receiver.\n-#[lang=\"fn_once\"]\n+#[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`"}, {"sha": "635150c088688f3c98b5a17aea9c1f6694787e92", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -33,7 +33,7 @@\n use fmt;\n \n #[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"panic\"]\n+#[lang = \"panic\"]\n pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n     // reduce size overhead. The format_args! macro uses str's Display trait to\n@@ -46,7 +46,7 @@ pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n }\n \n #[cold] #[inline(never)]\n-#[lang=\"panic_bounds_check\"]\n+#[lang = \"panic_bounds_check\"]\n fn panic_bounds_check(file_line: &(&'static str, u32),\n                      index: usize, len: usize) -> ! {\n     panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\","}, {"sha": "4d39607b16e92a140e3000b942f2a9c18c45f74a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -1185,7 +1185,7 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n /// Bytewise slice equality\n /// NOTE: This function is (ab)used in rustc::middle::trans::_match\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[lang=\"str_eq\"]\n+#[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)"}, {"sha": "b24099505ed896a7207760b3c4139bf7e23f141c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459652c832815118cf78c30f7a59cea99c43d308/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=459652c832815118cf78c30f7a59cea99c43d308", "patch": "@@ -238,7 +238,7 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     #[allow(private_no_mangle_fns)]\n     extern fn rust_eh_personality(\n@@ -292,7 +292,7 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality(\n         version: c_int,\n@@ -345,7 +345,7 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     #[allow(private_no_mangle_fns)]\n     extern \"C\" fn rust_eh_personality(\n@@ -432,7 +432,7 @@ pub mod eabi {\n         ) -> EXCEPTION_DISPOSITION;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     #[allow(private_no_mangle_fns)]\n     extern \"C\" fn rust_eh_personality("}]}