{"sha": "964a81eb37db6ee33b8fc107582618bf2befe02d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NGE4MWViMzdkYjZlZTMzYjhmYzEwNzU4MjYxOGJmMmJlZmUwMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-24T04:48:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-24T04:48:46Z"}, "message": "Auto merge of #86588 - JohnTitor:rollup-ibgjbkf, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #86137 (Error code cleanup and enforce checks)\n - #86296 (Add documentation for various THIR structs)\n - #86415 (Document associativity of iterator folds.)\n - #86533 (Support lowercase error codes in `--explain`)\n - #86536 (Edition 2021 enables disjoint capture)\n - #86560 (Update cargo)\n - #86561 (chore(rustdoc): Remove unused impl block)\n - #86566 (Use `use_verbose` for `mir::Constant`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "476a676f704c5b73f01ada725e776074d78265ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476a676f704c5b73f01ada725e776074d78265ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/964a81eb37db6ee33b8fc107582618bf2befe02d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/964a81eb37db6ee33b8fc107582618bf2befe02d", "html_url": "https://github.com/rust-lang/rust/commit/964a81eb37db6ee33b8fc107582618bf2befe02d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/964a81eb37db6ee33b8fc107582618bf2befe02d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d", "html_url": "https://github.com/rust-lang/rust/commit/f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d"}, {"sha": "64c9712cf3f49644158f759d10783b31aa176042", "url": "https://api.github.com/repos/rust-lang/rust/commits/64c9712cf3f49644158f759d10783b31aa176042", "html_url": "https://github.com/rust-lang/rust/commit/64c9712cf3f49644158f759d10783b31aa176042"}], "stats": {"total": 477, "additions": 319, "deletions": 158}, "files": [{"sha": "17378cb4a2d07b0f566a30f9c231f2ae0c596a9c", "filename": "Cargo.lock", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -180,7 +180,7 @@ dependencies = [\n  \"merge\",\n  \"num_cpus\",\n  \"once_cell\",\n- \"opener\",\n+ \"opener 0.5.0\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\",\n@@ -195,7 +195,9 @@ version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"31accafdb70df7871592c058eca3985b71104e15ac32f64706022c58867da931\"\n dependencies = [\n+ \"lazy_static\",\n  \"memchr\",\n+ \"regex-automata\",\n ]\n \n [[package]]\n@@ -253,7 +255,7 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.55.0\"\n+version = \"0.56.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -288,11 +290,10 @@ dependencies = [\n  \"log\",\n  \"memchr\",\n  \"num_cpus\",\n- \"opener\",\n+ \"opener 0.5.0\",\n  \"openssl\",\n  \"percent-encoding 2.1.0\",\n  \"pretty_env_logger\",\n- \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustfix 0.6.0\",\n  \"semver 1.0.3\",\n@@ -375,10 +376,12 @@ dependencies = [\n  \"flate2\",\n  \"git2\",\n  \"glob\",\n+ \"itertools 0.10.0\",\n  \"lazy_static\",\n  \"remove_dir_all\",\n  \"serde_json\",\n  \"tar\",\n+ \"termcolor\",\n  \"toml\",\n  \"url 2.2.2\",\n ]\n@@ -575,7 +578,7 @@ dependencies = [\n  \"bytecount\",\n  \"clap\",\n  \"itertools 0.9.0\",\n- \"opener\",\n+ \"opener 0.4.1\",\n  \"regex\",\n  \"shell-escape\",\n  \"walkdir\",\n@@ -2418,6 +2421,16 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"opener\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ea3ebcd72a54701f56345f16785a6d3ac2df7e986d273eb4395c0b01db17952\"\n+dependencies = [\n+ \"bstr\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"openssl\"\n version = \"0.10.33\"\n@@ -3558,6 +3571,7 @@ dependencies = [\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n+ \"bstr\",\n  \"byteorder\",\n  \"crossbeam-utils 0.8.3\",\n  \"libc\",\n@@ -5158,9 +5172,9 @@ dependencies = [\n \n [[package]]\n name = \"termcolor\"\n-version = \"1.1.0\"\n+version = \"1.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f\"\n+checksum = \"2dfed899f0eb03f32ee8c6a0aabdb8a7949659e3466561fc0adf54e26d88c5f4\"\n dependencies = [\n  \"winapi-util\",\n ]"}, {"sha": "87bc829b48891bde6c0cf60118c85548f03c8d13", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -528,8 +528,12 @@ fn stderr_isatty() -> bool {\n }\n \n fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n-    let normalised =\n-        if code.starts_with('E') { code.to_string() } else { format!(\"E{0:0>4}\", code) };\n+    let upper_cased_code = code.to_ascii_uppercase();\n+    let normalised = if upper_cased_code.starts_with('E') {\n+        upper_cased_code\n+    } else {\n+        format!(\"E{0:0>4}\", code)\n+    };\n     match registry.try_find_description(&normalised) {\n         Ok(Some(description)) => {\n             let mut is_in_code_block = false;"}, {"sha": "ff7a2344e69537543e5eb6ed2a6263216e3713ca", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -609,7 +609,7 @@ E0783: include_str!(\"./error_codes/E0783.md\"),\n //  E0540, // multiple rustc_deprecated attributes\n     E0544, // multiple stability levels\n //  E0548, // replaced with a generic attribute input check\n-    E0553, // multiple rustc_const_unstable attributes\n+//  E0553, // multiple rustc_const_unstable attributes\n //  E0555, // replaced with a generic attribute input check\n //  E0558, // replaced with a generic attribute input check\n //  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n@@ -620,10 +620,9 @@ E0783: include_str!(\"./error_codes/E0783.md\"),\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n     E0625, // thread-local statics cannot be accessed at compile-time\n-    E0629, // missing 'feature' (rustc_const_unstable)\n-    // rustc_const_unstable attribute must be paired with stable/unstable\n-    // attribute\n-    E0630,\n+//  E0629, // missing 'feature' (rustc_const_unstable)\n+//  E0630, // rustc_const_unstable attribute must be paired with stable/unstable\n+           // attribute\n     E0632, // cannot provide explicit generic arguments when `impl Trait` is\n            // used in argument position\n     E0640, // infer outlives requirements"}, {"sha": "cdefc9effa1e9ac0ce840991ec1687486de2b35e", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 109, "deletions": 35, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -1,3 +1,13 @@\n+//! THIR datatypes and definitions. See the [rustc dev guide] for more info.\n+//!\n+//! If you compare the THIR [`ExprKind`] to [`hir::ExprKind`], you will see it is\n+//! a good bit simpler. In fact, a number of the more straight-forward\n+//! MIR simplifications are already done in the lowering to THIR. For\n+//! example, method calls and overloaded operators are absent: they are\n+//! expected to be converted into [`ExprKind::Call`] instances.\n+//!\n+//! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/thir.html\n+\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -24,13 +34,15 @@ use std::fmt;\n use std::ops::Index;\n \n newtype_index! {\n+    /// An index to an [`Arm`] stored in [`Thir::arms`]\n     #[derive(HashStable)]\n     pub struct ArmId {\n         DEBUG_FORMAT = \"a{}\"\n     }\n }\n \n newtype_index! {\n+    /// An index to an [`Expr`] stored in [`Thir::exprs`]\n     #[derive(HashStable)]\n     pub struct ExprId {\n         DEBUG_FORMAT = \"e{}\"\n@@ -39,13 +51,17 @@ newtype_index! {\n \n newtype_index! {\n     #[derive(HashStable)]\n+    /// An index to a [`Stmt`] stored in [`Thir::stmts`]\n     pub struct StmtId {\n         DEBUG_FORMAT = \"s{}\"\n     }\n }\n \n macro_rules! thir_with_elements {\n     ($($name:ident: $id:ty => $value:ty,)*) => {\n+        /// A container for a THIR body.\n+        ///\n+        /// This can be indexed directly by any THIR index (e.g. [`ExprId`]).\n         #[derive(Debug, HashStable)]\n         pub struct Thir<'tcx> {\n             $(\n@@ -88,18 +104,28 @@ pub enum LintLevel {\n \n #[derive(Debug, HashStable)]\n pub struct Block {\n+    /// Whether the block itself has a label. Used by `label: {}`\n+    /// and `try` blocks.\n+    ///\n+    /// This does *not* include labels on loops, e.g. `'label: loop {}`.\n     pub targeted_by_break: bool,\n     pub region_scope: region::Scope,\n     pub opt_destruction_scope: Option<region::Scope>,\n+    /// The span of the block, including the opening braces,\n+    /// the label, and the `unsafe` keyword, if present.\n     pub span: Span,\n+    /// The statements in the blocK.\n     pub stmts: Box<[StmtId]>,\n+    /// The trailing expression of the block, if any.\n     pub expr: Option<ExprId>,\n     pub safety_mode: BlockSafety,\n }\n \n #[derive(Debug, HashStable)]\n pub struct Adt<'tcx> {\n+    /// The ADT we're constructing.\n     pub adt_def: &'tcx AdtDef,\n+    /// The variant of the ADT.\n     pub variant_index: VariantIdx,\n     pub substs: SubstsRef<'tcx>,\n \n@@ -108,13 +134,16 @@ pub struct Adt<'tcx> {\n     pub user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n     pub fields: Box<[FieldExpr]>,\n+    /// The base, e.g. `Foo {x: 1, .. base}`.\n     pub base: Option<FruInfo<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]\n pub enum BlockSafety {\n     Safe,\n+    /// A compiler-generated unsafe block\n     BuiltinUnsafe,\n+    /// An `unsafe` block. The `HirId` is the ID of the block.\n     ExplicitUnsafe(hir::HirId),\n }\n \n@@ -126,32 +155,34 @@ pub struct Stmt<'tcx> {\n \n #[derive(Debug, HashStable)]\n pub enum StmtKind<'tcx> {\n+    /// An expression with a trailing semicolon.\n     Expr {\n-        /// scope for this statement; may be used as lifetime of temporaries\n+        /// The scope for this statement; may be used as lifetime of temporaries.\n         scope: region::Scope,\n \n-        /// expression being evaluated in this statement\n+        /// The expression being evaluated in this statement.\n         expr: ExprId,\n     },\n \n+    /// A `let` binding.\n     Let {\n-        /// scope for variables bound in this let; covers this and\n-        /// remaining statements in block\n+        /// The scope for variables bound in this `let`; it covers this and\n+        /// all the remaining statements in the block.\n         remainder_scope: region::Scope,\n \n-        /// scope for the initialization itself; might be used as\n-        /// lifetime of temporaries\n+        /// The scope for the initialization itself; might be used as\n+        /// lifetime of temporaries.\n         init_scope: region::Scope,\n \n         /// `let <PAT> = ...`\n         ///\n-        /// if a type is included, it is added as an ascription pattern\n+        /// If a type annotation is included, it is added as an ascription pattern.\n         pattern: Pat<'tcx>,\n \n-        /// let pat: ty = <INIT> ...\n+        /// `let pat: ty = <INIT>`\n         initializer: Option<ExprId>,\n \n-        /// the lint level for this let-statement\n+        /// The lint level for this `let` statement.\n         lint_level: LintLevel,\n     },\n }\n@@ -160,27 +191,14 @@ pub enum StmtKind<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Expr<'_>, 104);\n \n-/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n-/// into instances of this `Expr` enum. This lowering can be done\n-/// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `ExprId`, which\n-/// may in turn be another instance of this enum (boxed), or else an\n-/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n-/// short-lived. They are created by `Thir::to_expr`, analyzed and\n-/// converted into MIR, and then discarded.\n-///\n-/// If you compare `Expr` to the full compiler AST, you will see it is\n-/// a good bit simpler. In fact, a number of the more straight-forward\n-/// MIR simplifications are already done in the impl of `Thir`. For\n-/// example, method calls and overloaded operators are absent: they are\n-/// expected to be converted into `Expr::Call` instances.\n+/// A THIR expression.\n #[derive(Debug, HashStable)]\n pub struct Expr<'tcx> {\n-    /// type of this expression\n+    /// The type of this expression\n     pub ty: Ty<'tcx>,\n \n-    /// lifetime of this expression if it should be spilled into a\n-    /// temporary; should be None only if in a constant context\n+    /// The lifetime of this expression if it should be spilled into a\n+    /// temporary; should be `None` only if in a constant context\n     pub temp_lifetime: Option<region::Scope>,\n \n     /// span of the expression in the source\n@@ -192,88 +210,120 @@ pub struct Expr<'tcx> {\n \n #[derive(Debug, HashStable)]\n pub enum ExprKind<'tcx> {\n+    /// `Scope`s are used to explicitely mark destruction scopes,\n+    /// and to track the `HirId` of the expressions within the scope.\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n         value: ExprId,\n     },\n+    /// A `box <value>` expression.\n     Box {\n         value: ExprId,\n     },\n+    /// An `if` expression.\n     If {\n         cond: ExprId,\n         then: ExprId,\n         else_opt: Option<ExprId>,\n     },\n+    /// A function call. Method calls and overloaded operators are converted to plain function calls.\n     Call {\n+        /// The type of the function. This is often a [`FnDef`] or a [`FnPtr`].\n+        ///\n+        /// [`FnDef`]: ty::TyKind::FnDef\n+        /// [`FnPtr`]: ty::TyKind::FnPtr\n         ty: Ty<'tcx>,\n+        /// The function itself.\n         fun: ExprId,\n+        /// The arguments passed to the function.\n+        ///\n+        /// Note: in some cases (like calling a closure), the function call `f(...args)` gets\n+        /// rewritten as a call to a function trait method (e.g. `FnOnce::call_once(f, (...args))`).\n         args: Box<[ExprId]>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n-        /// operator. `true` for overloaded function call.\n+        /// Whether this is from an overloaded operator rather than a\n+        /// function call from HIR. `true` for overloaded function call.\n         from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        /// The span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`).\n         fn_span: Span,\n     },\n+    /// A *non-overloaded* dereference.\n     Deref {\n         arg: ExprId,\n-    }, // NOT overloaded!\n+    },\n+    /// A *non-overloaded* binary operation.\n     Binary {\n         op: BinOp,\n         lhs: ExprId,\n         rhs: ExprId,\n-    }, // NOT overloaded!\n+    },\n+    /// A logical operation. This is distinct from `BinaryOp` because\n+    /// the operands need to be lazily evaluated.\n     LogicalOp {\n         op: LogicalOp,\n         lhs: ExprId,\n         rhs: ExprId,\n-    }, // NOT overloaded!\n-    // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n+    },\n+    /// A *non-overloaded* unary operation. Note that here the deref (`*`)\n+    /// operator is represented by `ExprKind::Deref`.\n     Unary {\n         op: UnOp,\n         arg: ExprId,\n-    }, // NOT overloaded!\n+    },\n+    /// A cast: `<source> as <type>`. The type we cast to is the type of\n+    /// the parent expression.\n     Cast {\n         source: ExprId,\n     },\n     Use {\n         source: ExprId,\n     }, // Use a lexpr to get a vexpr.\n+    /// A coercion from `!` to any type.\n     NeverToAny {\n         source: ExprId,\n     },\n+    /// A pointer cast. More information can be found in [`PointerCast`].\n     Pointer {\n         cast: PointerCast,\n         source: ExprId,\n     },\n+    /// A `loop` expression.\n     Loop {\n         body: ExprId,\n     },\n+    /// A `match` expression.\n     Match {\n         scrutinee: ExprId,\n         arms: Box<[ArmId]>,\n     },\n+    /// A block.\n     Block {\n         body: Block,\n     },\n+    /// An assignment: `lhs = rhs`.\n     Assign {\n         lhs: ExprId,\n         rhs: ExprId,\n     },\n+    /// A *non-overloaded* operation assignment, e.g. `lhs += rhs`.\n     AssignOp {\n         op: BinOp,\n         lhs: ExprId,\n         rhs: ExprId,\n     },\n+    /// Access to a struct or tuple field.\n     Field {\n         lhs: ExprId,\n+        /// This can be a named (`.foo`) or unnamed (`.0`) field.\n         name: Field,\n     },\n+    /// A *non-overloaded* indexing operation.\n     Index {\n         lhs: ExprId,\n         index: ExprId,\n     },\n+    /// A local variable.\n     VarRef {\n         id: hir::HirId,\n     },\n@@ -285,6 +335,7 @@ pub enum ExprKind<'tcx> {\n         /// HirId of the root variable\n         var_hir_id: hir::HirId,\n     },\n+    /// A borrow, e.g. `&arg`.\n     Borrow {\n         borrow_kind: BorrowKind,\n         arg: ExprId,\n@@ -294,47 +345,59 @@ pub enum ExprKind<'tcx> {\n         mutability: hir::Mutability,\n         arg: ExprId,\n     },\n+    /// A `break` expression.\n     Break {\n         label: region::Scope,\n         value: Option<ExprId>,\n     },\n+    /// A `continue` expression.\n     Continue {\n         label: region::Scope,\n     },\n+    /// A `return` expression.\n     Return {\n         value: Option<ExprId>,\n     },\n+    /// An inline `const` block, e.g. `const {}`.\n     ConstBlock {\n         value: &'tcx Const<'tcx>,\n     },\n+    /// An array literal constructed from one repeated element, e.g. `[1; 5]`.\n     Repeat {\n         value: ExprId,\n         count: &'tcx Const<'tcx>,\n     },\n+    /// An array, e.g. `[a, b, c, d]`.\n     Array {\n         fields: Box<[ExprId]>,\n     },\n+    /// A tuple, e.g. `(a, b, c, d)`.\n     Tuple {\n         fields: Box<[ExprId]>,\n     },\n+    /// An ADT constructor, e.g. `Foo {x: 1, y: 2}`.\n     Adt(Box<Adt<'tcx>>),\n+    /// A type ascription on a place.\n     PlaceTypeAscription {\n         source: ExprId,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A type ascription on a value, e.g. `42: i32`.\n     ValueTypeAscription {\n         source: ExprId,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A closure definition.\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n         upvars: Box<[ExprId]>,\n         movability: Option<hir::Movability>,\n         fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n     },\n+    /// A literal.\n     Literal {\n         literal: &'tcx Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n@@ -351,6 +414,7 @@ pub enum ExprKind<'tcx> {\n         literal: &'tcx Const<'tcx>,\n         def_id: DefId,\n     },\n+    /// Inline assembly, i.e. `asm!()`.\n     InlineAsm {\n         template: &'tcx [InlineAsmTemplatePiece],\n         operands: Box<[InlineAsmOperand<'tcx>]>,\n@@ -359,16 +423,21 @@ pub enum ExprKind<'tcx> {\n     },\n     /// An expression taking a reference to a thread local.\n     ThreadLocalRef(DefId),\n+    /// Inline LLVM assembly, i.e. `llvm_asm!()`.\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n         outputs: Box<[ExprId]>,\n         inputs: Box<[ExprId]>,\n     },\n+    /// A `yield` expression.\n     Yield {\n         value: ExprId,\n     },\n }\n \n+/// Represents the association of a field identifier and an expression.\n+///\n+/// This is used in struct constructors.\n #[derive(Debug, HashStable)]\n pub struct FieldExpr {\n     pub name: Field,\n@@ -381,6 +450,7 @@ pub struct FruInfo<'tcx> {\n     pub field_types: Box<[Ty<'tcx>]>,\n }\n \n+/// A `match` arm.\n #[derive(Debug, HashStable)]\n pub struct Arm<'tcx> {\n     pub pattern: Pat<'tcx>,\n@@ -391,6 +461,7 @@ pub struct Arm<'tcx> {\n     pub span: Span,\n }\n \n+/// A `match` guard.\n #[derive(Debug, HashStable)]\n pub enum Guard<'tcx> {\n     If(ExprId),\n@@ -399,7 +470,9 @@ pub enum Guard<'tcx> {\n \n #[derive(Copy, Clone, Debug, HashStable)]\n pub enum LogicalOp {\n+    /// The `&&` operator.\n     And,\n+    /// The `||` operator.\n     Or,\n }\n \n@@ -516,6 +589,7 @@ pub struct Ascription<'tcx> {\n \n #[derive(Clone, Debug, PartialEq, HashStable)]\n pub enum PatKind<'tcx> {\n+    /// A wildward pattern: `_`.\n     Wild,\n \n     AscribeUserType {"}, {"sha": "cb1203393b3d7396f8d7321925803e2e64acd9f7", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -426,14 +426,14 @@ impl ExtraComments<'tcx> {\n     }\n }\n \n-fn use_verbose(ty: &&TyS<'tcx>) -> bool {\n+fn use_verbose(ty: &&TyS<'tcx>, fn_def: bool) -> bool {\n     match ty.kind() {\n         ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => false,\n         // Unit type\n         ty::Tuple(g_args) if g_args.is_empty() => false,\n-        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(&g_arg.expect_ty())),\n-        ty::Array(ty, _) => use_verbose(ty),\n-        ty::FnDef(..) => false,\n+        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(&g_arg.expect_ty(), fn_def)),\n+        ty::Array(ty, _) => use_verbose(ty, fn_def),\n+        ty::FnDef(..) => fn_def,\n         _ => true,\n     }\n }\n@@ -442,28 +442,20 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, user_ty, literal } = constant;\n-        match literal.ty().kind() {\n-            ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char => {}\n-            // Unit type\n-            ty::Tuple(tys) if tys.is_empty() => {}\n-            _ => {\n-                self.push(\"mir::Constant\");\n-                self.push(&format!(\n-                    \"+ span: {}\",\n-                    self.tcx.sess.source_map().span_to_embeddable_string(*span)\n-                ));\n-                if let Some(user_ty) = user_ty {\n-                    self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n-                }\n-                match literal {\n-                    ConstantKind::Ty(literal) => self.push(&format!(\"+ literal: {:?}\", literal)),\n-                    ConstantKind::Val(val, ty) => {\n-                        // To keep the diffs small, we render this almost like we render ty::Const\n-                        self.push(&format!(\n-                            \"+ literal: Const {{ ty: {}, val: Value({:?}) }}\",\n-                            ty, val\n-                        ))\n-                    }\n+        if use_verbose(&literal.ty(), true) {\n+            self.push(\"mir::Constant\");\n+            self.push(&format!(\n+                \"+ span: {}\",\n+                self.tcx.sess.source_map().span_to_embeddable_string(*span)\n+            ));\n+            if let Some(user_ty) = user_ty {\n+                self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n+            }\n+            match literal {\n+                ConstantKind::Ty(literal) => self.push(&format!(\"+ literal: {:?}\", literal)),\n+                ConstantKind::Val(val, ty) => {\n+                    // To keep the diffs small, we render this almost like we render ty::Const\n+                    self.push(&format!(\"+ literal: Const {{ ty: {}, val: Value({:?}) }}\", ty, val))\n                 }\n             }\n         }\n@@ -472,7 +464,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n         let ty::Const { ty, val, .. } = constant;\n-        if use_verbose(ty) {\n+        if use_verbose(ty, false) {\n             self.push(\"ty::Const\");\n             self.push(&format!(\"+ ty: {:?}\", ty));\n             let val = match val {"}, {"sha": "4c9c3954624f5acf7a979b8ef372a49d89206c57", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We now fake capture information for all variables that are mentioned within the closure\n         // We do this after handling migrations so that min_captures computes before\n-        if !self.tcx.features().capture_disjoint_fields {\n+        if !enable_precise_capture(self.tcx, span) {\n             let mut capture_information: InferredCaptureInformation<'tcx> = Default::default();\n \n             if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // If we have an origin, store it.\n             if let Some(origin) = delegate.current_origin.clone() {\n-                let origin = if self.tcx.features().capture_disjoint_fields {\n+                let origin = if enable_precise_capture(self.tcx, span) {\n                     (origin.0, restrict_capture_precision(origin.1))\n                 } else {\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n@@ -1924,3 +1924,13 @@ fn determine_place_ancestry_relation(\n         PlaceAncestryRelation::Divergent\n     }\n }\n+\n+/// Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if\n+/// user is using Rust Edition 2021 or higher.\n+///\n+/// `span` is the span of the closure.\n+fn enable_precise_capture(tcx: TyCtxt<'_>, span: Span) -> bool {\n+    // We use span here to ensure that if the closure was generated by a macro with a different\n+    // edition.\n+    tcx.features().capture_disjoint_fields || span.rust_2021()\n+}"}, {"sha": "6d3ab788e5f480ba2e04b5cc677b6b3c531b79c8", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -248,6 +248,11 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Folding is useful whenever you have a collection of something, and want\n     /// to produce a single value from it.\n     ///\n+    /// Note: `rfold()` combines elements in a *right-associative* fashion. For associative\n+    /// operators like `+`, the order the elements are combined in is not important, but for non-associative\n+    /// operators like `-` the order will affect the final result.\n+    /// For a *left-associative* version of `rfold()`, see [`Iterator::fold()`].\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -262,7 +267,8 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(sum, 6);\n     /// ```\n     ///\n-    /// This example builds a string, starting with an initial value\n+    /// This example demonstrates the right-associative nature of `rfold()`:\n+    /// it builds a string, starting with an initial value\n     /// and continuing with each element from the back until the front:\n     ///\n     /// ```\n@@ -276,6 +282,7 @@ pub trait DoubleEndedIterator: Iterator {\n     ///\n     /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n     /// ```\n+    #[doc(alias = \"foldr\")]\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n     fn rfold<B, F>(mut self, init: B, mut f: F) -> B"}, {"sha": "41d9993abaa4faa95dd27d8373333658aaf94448", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -2083,6 +2083,11 @@ pub trait Iterator {\n     /// Note: [`reduce()`] can be used to use the first element as the initial\n     /// value, if the accumulator type and item type is the same.\n     ///\n+    /// Note: `fold()` combines elements in a *left-associative* fashion. For associative\n+    /// operators like `+`, the order the elements are combined in is not important, but for non-associative\n+    /// operators like `-` the order will affect the final result.\n+    /// For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n+    ///\n     /// # Note to Implementors\n     ///\n     /// Several of the other (forward) methods have default implementations in\n@@ -2116,6 +2121,21 @@ pub trait Iterator {\n     ///\n     /// And so, our final result, `6`.\n     ///\n+    /// This example demonstrates the left-associative nature of `fold()`:\n+    /// it builds a string, starting with an initial value\n+    /// and continuing with each element from the front until the back:\n+    ///\n+    /// ```\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let zero = \"0\".to_string();\n+    ///\n+    /// let result = numbers.iter().fold(zero, |acc, &x| {\n+    ///     format!(\"({} + {})\", acc, x)\n+    /// });\n+    ///\n+    /// assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n+    /// ```\n     /// It's common for people who haven't used iterators a lot to\n     /// use a `for` loop with a list of things to build up a result. Those\n     /// can be turned into `fold()`s:\n@@ -2140,7 +2160,7 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// [`reduce()`]: Iterator::reduce\n-    #[doc(alias = \"inject\")]\n+    #[doc(alias = \"inject\", alias = \"foldl\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B"}, {"sha": "6fb7a1c088f33690f2417067ab3403d07eb16caa", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -48,7 +48,7 @@ toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n-opener = \"0.4\"\n+opener = \"0.5\"\n merge = \"0.1.0\"\n once_cell = \"1.7.2\"\n "}, {"sha": "a43a5424f04fc240865585e83a406eb07217a6f9", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -101,28 +101,6 @@ crate struct RenderType {\n     generics: Option<Vec<Generic>>,\n }\n \n-impl Serialize for RenderType {\n-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        if let Some(name) = &self.name {\n-            let mut seq = serializer.serialize_seq(None)?;\n-            if let Some(id) = self.idx {\n-                seq.serialize_element(&id)?;\n-            } else {\n-                seq.serialize_element(&name)?;\n-            }\n-            if let Some(generics) = &self.generics {\n-                seq.serialize_element(&generics)?;\n-            }\n-            seq.end()\n-        } else {\n-            serializer.serialize_none()\n-        }\n-    }\n-}\n-\n /// A type used for the search index.\n #[derive(Debug)]\n crate struct Generic {"}, {"sha": "77ff8ef4e49528554280b86aac3334a30e090469", "filename": "src/test/mir-opt/const_prop/checked_add.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -14,9 +14,6 @@\n -         _2 = CheckedAdd(const 1_u32, const 1_u32); // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n -         assert(!move (_2.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const 1_u32, const 1_u32) -> bb1; // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n +         _2 = const (2_u32, false);       // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/checked_add.rs:5:18: 5:23\n-+                                          // + literal: Const { ty: (u32, bool), val: Value(ByRef { alloc: Allocation { bytes: [2, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 1_u32, const 1_u32) -> bb1; // scope 0 at $DIR/checked_add.rs:5:18: 5:23\n       }\n   "}, {"sha": "8dd55235ef37b42c6aa258d352977f62221931cf", "filename": "src/test/mir-opt/const_prop/indirect.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -18,9 +18,6 @@\n -         assert(!move (_3.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _2, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:5:13: 5:29\n +         _2 = const 2_u8;                 // scope 0 at $DIR/indirect.rs:5:13: 5:25\n +         _3 = const (3_u8, false);        // scope 0 at $DIR/indirect.rs:5:13: 5:29\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/indirect.rs:5:13: 5:29\n-+                                          // + literal: Const { ty: (u8, bool), val: Value(ByRef { alloc: Allocation { bytes: [3, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 2_u8, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:5:13: 5:29\n       }\n   "}, {"sha": "2d3289f7ce51d9d475051441bd083ac68a343ec5", "filename": "src/test/mir-opt/const_prop/issue_67019.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -15,9 +15,6 @@\n           (_3.1: u8) = const 2_u8;         // scope 0 at $DIR/issue-67019.rs:11:11: 11:17\n -         (_2.0: (u8, u8)) = move _3;      // scope 0 at $DIR/issue-67019.rs:11:10: 11:19\n +         (_2.0: (u8, u8)) = const (1_u8, 2_u8); // scope 0 at $DIR/issue-67019.rs:11:10: 11:19\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/issue-67019.rs:11:10: 11:19\n-+                                          // + literal: Const { ty: (u8, u8), val: Value(ByRef { alloc: Allocation { bytes: [1, 2], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n           StorageDead(_3);                 // scope 0 at $DIR/issue-67019.rs:11:18: 11:19\n           _1 = test(move _2) -> bb1;       // scope 0 at $DIR/issue-67019.rs:11:5: 11:20\n                                            // mir::Constant"}, {"sha": "a044d1dcfe1d9403239494376f8c9d893083b420", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -20,9 +20,6 @@\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:7:9: 7:10\n -         _2 = _1;                         // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n +         _2 = const (42_i32, 99_i32);     // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/mutable_variable_aggregate.rs:7:13: 7:14\n-+                                          // + literal: Const { ty: (i32, i32), val: Value(ByRef { alloc: Allocation { bytes: [42, 0, 0, 0, 99, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n           nop;                             // scope 0 at $DIR/mutable_variable_aggregate.rs:4:11: 8:2\n           StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:8:1: 8:2\n           StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:8:1: 8:2"}, {"sha": "4c3f66cd0907f95a883416d53e1ef7619276c209", "filename": "src/test/mir-opt/const_prop/optimizes_into_variable.main.ConstProp.32bit.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.32bit.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -27,9 +27,6 @@\n -         _2 = CheckedAdd(const 2_i32, const 2_i32); // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n -         assert(!move (_2.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n +         _2 = const (4_i32, false);       // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/optimizes_into_variable.rs:12:13: 12:18\n-+                                          // + literal: Const { ty: (i32, bool), val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n       }\n   "}, {"sha": "4c3f66cd0907f95a883416d53e1ef7619276c209", "filename": "src/test/mir-opt/const_prop/optimizes_into_variable.main.ConstProp.64bit.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.64bit.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -27,9 +27,6 @@\n -         _2 = CheckedAdd(const 2_i32, const 2_i32); // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n -         assert(!move (_2.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n +         _2 = const (4_i32, false);       // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/optimizes_into_variable.rs:12:13: 12:18\n-+                                          // + literal: Const { ty: (i32, bool), val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 2_i32, const 2_i32) -> bb1; // scope 0 at $DIR/optimizes_into_variable.rs:12:13: 12:18\n       }\n   "}, {"sha": "c6ac8d6fb139d7bf2cdd29968d088bc3a9d38acf", "filename": "src/test/mir-opt/const_prop/return_place.add.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.add.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.add.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.add.ConstProp.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -9,9 +9,6 @@\n -         _1 = CheckedAdd(const 2_u32, const 2_u32); // scope 0 at $DIR/return_place.rs:6:5: 6:10\n -         assert(!move (_1.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const 2_u32, const 2_u32) -> bb1; // scope 0 at $DIR/return_place.rs:6:5: 6:10\n +         _1 = const (4_u32, false);       // scope 0 at $DIR/return_place.rs:6:5: 6:10\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/return_place.rs:6:5: 6:10\n-+                                          // + literal: Const { ty: (u32, bool), val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [31], len: Size { raw: 8 } }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 2_u32, const 2_u32) -> bb1; // scope 0 at $DIR/return_place.rs:6:5: 6:10\n       }\n   "}, {"sha": "15253a364e99026493c7a275c1c70605162a82aa", "filename": "src/test/mir-opt/const_prop/tuple_literal_propagation.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -18,9 +18,6 @@\n           StorageLive(_3);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n -         _3 = _1;                         // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n +         _3 = const (1_u32, 2_u32);       // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/tuple_literal_propagation.rs:5:13: 5:14\n-+                                          // + literal: Const { ty: (u32, u32), val: Value(ByRef { alloc: Allocation { bytes: [1, 0, 0, 0, 2, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n           _2 = consume(move _3) -> bb1;    // scope 1 at $DIR/tuple_literal_propagation.rs:5:5: 5:15\n                                            // mir::Constant\n                                            // + span: $DIR/tuple_literal_propagation.rs:5:5: 5:12"}, {"sha": "d3c7136c6478f2eb1041d942821066c147a3c57b", "filename": "src/test/mir-opt/deaggregator_test.bar.Deaggregator.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.bar.Deaggregator.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.bar.Deaggregator.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.bar.Deaggregator.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -12,9 +12,6 @@\n -         _0 = Baz { x: move _2, y: const 0f32, z: const false }; // scope 0 at $DIR/deaggregator_test.rs:9:5: 9:35\n +         (_0.0: usize) = move _2;         // scope 0 at $DIR/deaggregator_test.rs:9:5: 9:35\n +         (_0.1: f32) = const 0f32;        // scope 0 at $DIR/deaggregator_test.rs:9:5: 9:35\n-                                           // mir::Constant\n-                                           // + span: $DIR/deaggregator_test.rs:9:20: 9:23\n-                                           // + literal: Const { ty: f32, val: Value(Scalar(0x00000000)) }\n +         (_0.2: bool) = const false;      // scope 0 at $DIR/deaggregator_test.rs:9:5: 9:35\n           StorageDead(_2);                 // scope 0 at $DIR/deaggregator_test.rs:9:34: 9:35\n           return;                          // scope 0 at $DIR/deaggregator_test.rs:10:2: 10:2"}, {"sha": "64a3f52f3a06ac870b750c0353c90de61e916db4", "filename": "src/test/mir-opt/if_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -12,9 +12,6 @@\n           StorageLive(_3);                 // scope 0 at $DIR/if-condition-int.rs:53:8: 53:9\n           _3 = _1;                         // scope 0 at $DIR/if-condition-int.rs:53:8: 53:9\n           _2 = Eq(move _3, const -42f32);  // scope 0 at $DIR/if-condition-int.rs:53:8: 53:18\n-                                           // mir::Constant\n-                                           // + span: $DIR/if-condition-int.rs:53:13: 53:18\n-                                           // + literal: Const { ty: f32, val: Value(Scalar(0xc2280000)) }\n           StorageDead(_3);                 // scope 0 at $DIR/if-condition-int.rs:53:17: 53:18\n           switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if-condition-int.rs:53:5: 53:35\n       }"}, {"sha": "598e8247efc5af37f4eb93a63bedd31b034c0116", "filename": "src/test/mir-opt/simplify_locals_removes_unused_consts.main.SimplifyLocals.diff", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fsimplify_locals_removes_unused_consts.main.SimplifyLocals.diff", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fmir-opt%2Fsimplify_locals_removes_unused_consts.main.SimplifyLocals.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_locals_removes_unused_consts.main.SimplifyLocals.diff?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -38,9 +38,6 @@\n                                            // mir::Constant\n                                            // + span: $DIR/simplify-locals-removes-unused-consts.rs:14:5: 14:12\n                                            // + literal: Const { ty: fn(((), ())) {use_zst}, val: Value(Scalar(<ZST>)) }\n-                                           // mir::Constant\n-                                           // + span: $DIR/simplify-locals-removes-unused-consts.rs:14:5: 14:22\n-                                           // + literal: Const { ty: ((), ()), val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb1: {"}, {"sha": "20bbe1d89e45d92152c4aca5fe3a216f3b2ec649", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/edition.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fedition.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -0,0 +1,23 @@\n+// edition:2021\n+// run-pass\n+\n+// Test that edition 2021 enables disjoint capture by default.\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: 10, y: 10 };\n+\n+    let c = || {\n+        println!(\"{}\", p.x);\n+    };\n+\n+    // `c` should only capture `p.x`, therefore mutating `p.y` is allowed.\n+    let py = &mut p.y;\n+\n+    c();\n+    *py = 20;\n+}"}, {"sha": "9233aa06c801801cff75df65df718d70905a235e", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -1 +1 @@\n-Subproject commit 44456677b5d1d82fe981c955dc5c67734b31f340\n+Subproject commit 9233aa06c801801cff75df65df718d70905a235e"}, {"sha": "4a4b26da54caf301ec23e69d5773a9ad306d1a41", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -61,6 +61,7 @@ features = [\n ]\n \n [dependencies]\n+bstr = { version = \"0.2.13\", features = [\"default\"] }\n byteorder = { version = \"1\", features = ['default', 'std'] }\n curl-sys = { version = \"0.4.13\", features = [\"http2\", \"libnghttp2-sys\"], optional = true }\n crossbeam-utils = { version = \"0.8.0\", features = [\"nightly\"] }"}, {"sha": "63fbee34bd6e405eb7981e0db0993d8579b8909f", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 93, "deletions": 21, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964a81eb37db6ee33b8fc107582618bf2befe02d/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=964a81eb37db6ee33b8fc107582618bf2befe02d", "patch": "@@ -6,20 +6,33 @@ use std::ffi::OsStr;\n use std::fs::read_to_string;\n use std::path::Path;\n \n+use regex::Regex;\n+\n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0461\", \"E0462\", \"E0464\",\n-    \"E0465\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\", \"E0480\", \"E0481\", \"E0482\", \"E0483\",\n-    \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\", \"E0514\", \"E0519\", \"E0523\", \"E0553\",\n-    \"E0554\", \"E0570\", \"E0629\", \"E0630\", \"E0640\", \"E0717\", \"E0729\",\n+    \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0464\", \"E0465\", \"E0476\",\n+    \"E0482\", \"E0514\", \"E0519\", \"E0523\", \"E0554\", \"E0570\", \"E0640\", \"E0717\", \"E0729\",\n ];\n \n // Some error codes don't have any tests apparently...\n const IGNORE_EXPLANATION_CHECK: &[&str] = &[\"E0570\", \"E0601\", \"E0602\", \"E0729\"];\n \n+// If the file path contains any of these, we don't want to try to extract error codes from it.\n+//\n+// We need to declare each path in the windows version (with backslash).\n+const PATHS_TO_IGNORE_FOR_EXTRACTION: &[&str] =\n+    &[\"src/test/\", \"src\\\\test\\\\\", \"src/doc/\", \"src\\\\doc\\\\\", \"src/tools/\", \"src\\\\tools\\\\\"];\n+\n+#[derive(Default, Debug)]\n+struct ErrorCodeStatus {\n+    has_test: bool,\n+    has_explanation: bool,\n+    is_used: bool,\n+}\n+\n fn check_error_code_explanation(\n     f: &str,\n-    error_codes: &mut HashMap<String, bool>,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n     err_code: String,\n ) -> bool {\n     let mut invalid_compile_fail_format = false;\n@@ -30,15 +43,15 @@ fn check_error_code_explanation(\n         if s.starts_with(\"```\") {\n             if s.contains(\"compile_fail\") && s.contains('E') {\n                 if !found_error_code {\n-                    error_codes.insert(err_code.clone(), true);\n+                    error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n                     found_error_code = true;\n                 }\n             } else if s.contains(\"compile-fail\") {\n                 invalid_compile_fail_format = true;\n             }\n         } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n             if !found_error_code {\n-                error_codes.get_mut(&err_code).map(|x| *x = true);\n+                error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n                 found_error_code = true;\n             }\n         }\n@@ -77,7 +90,7 @@ macro_rules! some_or_continue {\n \n fn extract_error_codes(\n     f: &str,\n-    error_codes: &mut HashMap<String, bool>,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n     path: &Path,\n     errors: &mut Vec<String>,\n ) {\n@@ -90,15 +103,16 @@ fn extract_error_codes(\n                 .split_once(':')\n                 .expect(\n                     format!(\n-                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} without a `:` delimiter\",\n+                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} \\\n+                         without a `:` delimiter\",\n                         s,\n-                    ).as_str()\n+                    )\n+                    .as_str(),\n                 )\n                 .0\n                 .to_owned();\n-            if !error_codes.contains_key(&err_code) {\n-                error_codes.insert(err_code.clone(), false);\n-            }\n+            error_codes.entry(err_code.clone()).or_default().has_explanation = true;\n+\n             // Now we extract the tests from the markdown file!\n             let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n                 None => continue,\n@@ -145,15 +159,15 @@ fn extract_error_codes(\n             .to_string();\n             if !error_codes.contains_key(&err_code) {\n                 // this check should *never* fail!\n-                error_codes.insert(err_code, false);\n+                error_codes.insert(err_code, ErrorCodeStatus::default());\n             }\n         } else if s == \";\" {\n             reached_no_explanation = true;\n         }\n     }\n }\n \n-fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, bool>) {\n+fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, ErrorCodeStatus>) {\n     for line in f.lines() {\n         let s = line.trim();\n         if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n@@ -164,8 +178,24 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n                     Some((_, err_code)) => err_code,\n                 },\n             };\n-            let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n-            *nb = true;\n+            error_codes.entry(err_code.to_owned()).or_default().has_test = true;\n+        }\n+    }\n+}\n+\n+fn extract_error_codes_from_source(\n+    f: &str,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n+    regex: &Regex,\n+) {\n+    for line in f.lines() {\n+        if line.trim_start().starts_with(\"//\") {\n+            continue;\n+        }\n+        for cap in regex.captures_iter(line) {\n+            if let Some(error_code) = cap.get(1) {\n+                error_codes.entry(error_code.as_str().to_owned()).or_default().is_used = true;\n+            }\n         }\n     }\n }\n@@ -174,8 +204,17 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     let mut errors = Vec::new();\n     let mut found_explanations = 0;\n     let mut found_tests = 0;\n+    let mut error_codes: HashMap<String, ErrorCodeStatus> = HashMap::new();\n+    // We want error codes which match the following cases:\n+    //\n+    // * foo(a, E0111, a)\n+    // * foo(a, E0111)\n+    // * foo(E0111, a)\n+    // * #[error = \"E0111\"]\n+    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n+\n     println!(\"Checking which error codes lack tests...\");\n-    let mut error_codes: HashMap<String, bool> = HashMap::new();\n+\n     for path in paths {\n         super::walk(path, &mut |path| super::filter_dirs(path), &mut |entry, contents| {\n             let file_name = entry.file_name();\n@@ -185,6 +224,11 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n             } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n                 extract_error_codes_from_tests(contents, &mut error_codes);\n                 found_tests += 1;\n+            } else if entry.path().extension() == Some(OsStr::new(\"rs\")) {\n+                let path = entry.path().to_string_lossy();\n+                if PATHS_TO_IGNORE_FOR_EXTRACTION.iter().all(|c| !path.contains(c)) {\n+                    extract_error_codes_from_source(contents, &mut error_codes, &regex);\n+                }\n             }\n         });\n     }\n@@ -199,15 +243,43 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     if errors.is_empty() {\n         println!(\"Found {} error codes\", error_codes.len());\n \n-        for (err_code, nb) in &error_codes {\n-            if !*nb && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n+        for (err_code, error_status) in &error_codes {\n+            if !error_status.has_test && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n-            } else if *nb && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n+            } else if error_status.has_test && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\n                     \"Error code {} has a UI test, it shouldn't be listed into EXEMPTED_FROM_TEST!\",\n                     err_code\n                 ));\n             }\n+            if !error_status.is_used && !error_status.has_explanation {\n+                errors.push(format!(\n+                    \"Error code {} isn't used and doesn't have an error explanation, it should be \\\n+                     commented in error_codes.rs file\",\n+                    err_code\n+                ));\n+            }\n+        }\n+    }\n+    if errors.is_empty() {\n+        // Checking if local constants need to be cleaned.\n+        for err_code in EXEMPTED_FROM_TEST {\n+            match error_codes.get(err_code.to_owned()) {\n+                Some(status) => {\n+                    if status.has_test {\n+                        errors.push(format!(\n+                            \"{} error code has a test and therefore should be \\\n+                            removed from the `EXEMPTED_FROM_TEST` constant\",\n+                            err_code\n+                        ));\n+                    }\n+                }\n+                None => errors.push(format!(\n+                    \"{} error code isn't used anymore and therefore should be removed \\\n+                        from `EXEMPTED_FROM_TEST` constant\",\n+                    err_code\n+                )),\n+            }\n         }\n     }\n     errors.sort();"}]}