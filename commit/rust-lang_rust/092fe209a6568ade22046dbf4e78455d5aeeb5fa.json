{"sha": "092fe209a6568ade22046dbf4e78455d5aeeb5fa", "node_id": "C_kwDOAAsO6NoAKDA5MmZlMjA5YTY1NjhhZGUyMjA0NmRiZjRlNzg0NTVkNWFlZWI1ZmE", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-20T09:00:50Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-20T14:48:21Z"}, "message": "Move deref closure builder to `clippy_utils::sugg` module", "tree": {"sha": "504c32b083593bbba04854629be8d7ffe3321bb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/504c32b083593bbba04854629be8d7ffe3321bb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/092fe209a6568ade22046dbf4e78455d5aeeb5fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/092fe209a6568ade22046dbf4e78455d5aeeb5fa", "html_url": "https://github.com/rust-lang/rust/commit/092fe209a6568ade22046dbf4e78455d5aeeb5fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/092fe209a6568ade22046dbf4e78455d5aeeb5fa/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebede0c14d00f50a2db3d5a8e944563e40244c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebede0c14d00f50a2db3d5a8e944563e40244c7", "html_url": "https://github.com/rust-lang/rust/commit/5ebede0c14d00f50a2db3d5a8e944563e40244c7"}], "stats": {"total": 536, "additions": 279, "deletions": 257}, "files": [{"sha": "5ed4ba94884e26b627874b7253608150eca9a0a9", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 5, "deletions": 253, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/092fe209a6568ade22046dbf4e78455d5aeeb5fa/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092fe209a6568ade22046dbf4e78455d5aeeb5fa/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=092fe209a6568ade22046dbf4e78455d5aeeb5fa", "patch": "@@ -1,21 +1,16 @@\n-use std::iter;\n-\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::sugg::deref_closure_args;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr_for_hir, is_trait_method, strip_pat_refs};\n+use clippy_utils::{is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{self, ExprKind, HirId, MutTy, PatKind, TyKind};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_hir::PatKind;\n use rustc_lint::LateContext;\n-use rustc_middle::hir::place::ProjectionKind;\n-use rustc_middle::mir::{FakeReadCause, Mutability};\n use rustc_middle::ty;\n-use rustc_span::source_map::{BytePos, Span};\n+use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n-use rustc_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n use super::SEARCH_IS_SOME;\n \n@@ -55,7 +50,7 @@ pub(super) fn check<'tcx>(\n                     } else if let PatKind::Binding(..) = strip_pat_refs(closure_arg.pat).kind {\n                         // `find()` provides a reference to the item, but `any` does not,\n                         // so we should fix item usages for suggestion\n-                        if let Some(closure_sugg) = get_closure_suggestion(cx, search_arg) {\n+                        if let Some(closure_sugg) = deref_closure_args(cx, search_arg) {\n                             applicability = closure_sugg.applicability;\n                             Some(closure_sugg.suggestion)\n                         } else {\n@@ -159,246 +154,3 @@ pub(super) fn check<'tcx>(\n         }\n     }\n }\n-\n-#[derive(Debug)]\n-struct ClosureSugg {\n-    applicability: Applicability,\n-    suggestion: String,\n-}\n-\n-// Build suggestion gradually by handling closure arg specific usages,\n-// such as explicit deref and borrowing cases.\n-// Returns `None` if no such use cases have been triggered in closure body\n-fn get_closure_suggestion<'tcx>(cx: &LateContext<'_>, search_expr: &'tcx hir::Expr<'_>) -> Option<ClosureSugg> {\n-    if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = search_expr.kind {\n-        let closure_body = cx.tcx.hir().body(body_id);\n-        // is closure arg a double reference (i.e.: `|x: &&i32| ...`)\n-        let closure_arg_is_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind {\n-            matches!(ty.kind, TyKind::Rptr(_, MutTy { .. }))\n-        } else {\n-            false\n-        };\n-\n-        let mut visitor = DerefDelegate {\n-            cx,\n-            closure_span: search_expr.span,\n-            closure_arg_is_double_ref,\n-            next_pos: search_expr.span.lo(),\n-            suggestion_start: String::new(),\n-            applicability: Applicability::MaybeIncorrect,\n-        };\n-\n-        let fn_def_id = cx.tcx.hir().local_def_id(search_expr.hir_id);\n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-                .consume_body(closure_body);\n-        });\n-\n-        if !visitor.suggestion_start.is_empty() {\n-            return Some(ClosureSugg {\n-                applicability: visitor.applicability,\n-                suggestion: visitor.finish(),\n-            });\n-        }\n-    }\n-    None\n-}\n-\n-struct DerefDelegate<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    closure_span: Span,\n-    closure_arg_is_double_ref: bool,\n-    next_pos: BytePos,\n-    suggestion_start: String,\n-    applicability: Applicability,\n-}\n-\n-impl DerefDelegate<'_, 'tcx> {\n-    pub fn finish(&mut self) -> String {\n-        let end_span = Span::new(self.next_pos, self.closure_span.hi(), self.closure_span.ctxt(), None);\n-        let end_snip = snippet_with_applicability(self.cx, end_span, \"..\", &mut self.applicability);\n-        let sugg = format!(\"{}{}\", self.suggestion_start, end_snip);\n-        if self.closure_arg_is_double_ref {\n-            sugg.replacen('&', \"\", 1)\n-        } else {\n-            sugg\n-        }\n-    }\n-\n-    fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n-        let (call_args, inputs) = match parent_expr.kind {\n-            ExprKind::MethodCall(_, _, call_args, _) => {\n-                if let Some(method_did) = self.cx.typeck_results().type_dependent_def_id(parent_expr.hir_id) {\n-                    (call_args, self.cx.tcx.fn_sig(method_did).skip_binder().inputs())\n-                } else {\n-                    return false;\n-                }\n-            },\n-            ExprKind::Call(func, call_args) => {\n-                let typ = self.cx.typeck_results().expr_ty(func);\n-                (call_args, typ.fn_sig(self.cx.tcx).skip_binder().inputs())\n-            },\n-            _ => return false,\n-        };\n-\n-        iter::zip(call_args, inputs)\n-            .any(|(arg, ty)| arg.hir_id == cmt_hir_id && matches!(ty.kind(), ty::Ref(_, inner, _) if inner.is_ref()))\n-    }\n-}\n-\n-impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n-    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n-\n-    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, _: ty::BorrowKind) {\n-        if let PlaceBase::Local(id) = cmt.place.base {\n-            let map = self.cx.tcx.hir();\n-            let span = map.span(cmt.hir_id);\n-            let start_span = Span::new(self.next_pos, span.lo(), span.ctxt(), None);\n-            let mut start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n-\n-            // identifier referring to the variable currently triggered (i.e.: `fp`)\n-            let ident_str = map.name(id).to_string();\n-            // full identifier that includes projection (i.e.: `fp.field`)\n-            let ident_str_with_proj = snippet(self.cx, span, \"..\").to_string();\n-\n-            if cmt.place.projections.is_empty() {\n-                // handle item without any projection, that needs an explicit borrowing\n-                // i.e.: suggest `&x` instead of `x`\n-                self.closure_arg_is_double_ref = false;\n-                self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n-            } else {\n-                // cases where a parent `Call` or `MethodCall` is using the item\n-                // i.e.: suggest `.contains(&x)` for `.find(|x| [1, 2, 3].contains(x)).is_none()`\n-                //\n-                // Note about method calls:\n-                // - compiler automatically dereference references if the target type is a reference (works also for\n-                //   function call)\n-                // - `self` arguments in the case of `x.is_something()` are also automatically (de)referenced, and\n-                //   no projection should be suggested\n-                if let Some(parent_expr) = get_parent_expr_for_hir(self.cx, cmt.hir_id) {\n-                    match &parent_expr.kind {\n-                        // given expression is the self argument and will be handled completely by the compiler\n-                        // i.e.: `|x| x.is_something()`\n-                        ExprKind::MethodCall(_, _, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n-                            self.suggestion_start\n-                                .push_str(&format!(\"{}{}\", start_snip, ident_str_with_proj));\n-                            self.next_pos = span.hi();\n-                            return;\n-                        },\n-                        // item is used in a call\n-                        // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n-                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [_, call_args @ ..], _) => {\n-                            let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n-                            let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n-\n-                            if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n-                                // suggest ampersand if call function is taking args by double reference\n-                                let takes_arg_by_double_ref =\n-                                    self.func_takes_arg_by_double_ref(parent_expr, cmt.hir_id);\n-\n-                                // compiler will automatically dereference field projection, so no need\n-                                // to suggest ampersand, but full identifier that includes projection is required\n-                                let has_field_projection = cmt\n-                                    .place\n-                                    .projections\n-                                    .iter()\n-                                    .any(|proj| matches!(proj.kind, ProjectionKind::Field(..)));\n-\n-                                // no need to bind again if the function doesn't take arg by double ref\n-                                // and if the item is already a double ref\n-                                let ident_sugg = if !call_args.is_empty()\n-                                    && !takes_arg_by_double_ref\n-                                    && (self.closure_arg_is_double_ref || has_field_projection)\n-                                {\n-                                    let ident = if has_field_projection {\n-                                        ident_str_with_proj\n-                                    } else {\n-                                        ident_str\n-                                    };\n-                                    format!(\"{}{}\", start_snip, ident)\n-                                } else {\n-                                    format!(\"{}&{}\", start_snip, ident_str)\n-                                };\n-                                self.suggestion_start.push_str(&ident_sugg);\n-                                self.next_pos = span.hi();\n-                                return;\n-                            }\n-\n-                            self.applicability = Applicability::Unspecified;\n-                        },\n-                        _ => (),\n-                    }\n-                }\n-\n-                let mut replacement_str = ident_str;\n-                let mut projections_handled = false;\n-                cmt.place.projections.iter().enumerate().for_each(|(i, proj)| {\n-                    match proj.kind {\n-                        // Field projection like `|v| v.foo`\n-                        // no adjustment needed here, as field projections are handled by the compiler\n-                        ProjectionKind::Field(..) => match cmt.place.ty_before_projection(i).kind() {\n-                            ty::Adt(..) | ty::Tuple(_) => {\n-                                replacement_str = ident_str_with_proj.clone();\n-                                projections_handled = true;\n-                            },\n-                            _ => (),\n-                        },\n-                        // Index projection like `|x| foo[x]`\n-                        // the index is dropped so we can't get it to build the suggestion,\n-                        // so the span is set-up again to get more code, using `span.hi()` (i.e.: `foo[x]`)\n-                        // instead of `span.lo()` (i.e.: `foo`)\n-                        ProjectionKind::Index => {\n-                            let start_span = Span::new(self.next_pos, span.hi(), span.ctxt(), None);\n-                            start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n-                            replacement_str.clear();\n-                            projections_handled = true;\n-                        },\n-                        // note: unable to trigger `Subslice` kind in tests\n-                        ProjectionKind::Subslice => (),\n-                        ProjectionKind::Deref => {\n-                            // explicit deref for arrays should be avoided in the suggestion\n-                            // i.e.: `|sub| *sub[1..4].len() == 3` is not expected\n-                            if let ty::Ref(_, inner, _) = cmt.place.ty_before_projection(i).kind() {\n-                                // dereferencing an array (i.e.: `|sub| sub[1..4].len() == 3`)\n-                                if matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_array()) {\n-                                    projections_handled = true;\n-                                }\n-                            }\n-                        },\n-                    }\n-                });\n-\n-                // handle `ProjectionKind::Deref` by removing one explicit deref\n-                // if no special case was detected (i.e.: suggest `*x` instead of `**x`)\n-                if projections_handled {\n-                    self.closure_arg_is_double_ref = false;\n-                } else {\n-                    let last_deref = cmt\n-                        .place\n-                        .projections\n-                        .iter()\n-                        .rposition(|proj| proj.kind == ProjectionKind::Deref);\n-\n-                    if let Some(pos) = last_deref {\n-                        let mut projections = cmt.place.projections.clone();\n-                        projections.truncate(pos);\n-\n-                        for item in projections {\n-                            if item.kind == ProjectionKind::Deref {\n-                                replacement_str = format!(\"*{}\", replacement_str);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                self.suggestion_start\n-                    .push_str(&format!(\"{}{}\", start_snip, replacement_str));\n-            }\n-            self.next_pos = span.hi();\n-        }\n-    }\n-\n-    fn mutate(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n-\n-    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) {}\n-}"}, {"sha": "e8a35f8c8dc3dcbccb763851197a0d86c5a75083", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 274, "deletions": 4, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/092fe209a6568ade22046dbf4e78455d5aeeb5fa/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092fe209a6568ade22046dbf4e78455d5aeeb5fa/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=092fe209a6568ade22046dbf4e78455d5aeeb5fa", "patch": "@@ -1,19 +1,27 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::higher;\n-use crate::source::{snippet, snippet_opt, snippet_with_context, snippet_with_macro_callsite};\n+use crate::source::{\n+    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n+};\n+use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::{ExprKind, HirId, MutTy, TyKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n-use rustc_span::source_map::{CharPos, Span};\n-use rustc_span::{BytePos, Pos, SyntaxContext};\n+use rustc_middle::hir::place::ProjectionKind;\n+use rustc_middle::mir::{FakeReadCause, Mutability};\n+use rustc_middle::ty;\n+use rustc_span::source_map::{BytePos, CharPos, Pos, Span, SyntaxContext};\n+use rustc_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n+use std::iter;\n use std::ops::{Add, Neg, Not, Sub};\n \n /// A helper type to build suggestion correctly handling parentheses.\n@@ -716,6 +724,268 @@ impl<T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder\n     }\n }\n \n+/// Suggestion results for handling closure\n+/// args dereferencing and borrowing\n+pub struct DerefClosure {\n+    /// confidence on the built suggestion\n+    pub applicability: Applicability,\n+    /// gradually built suggestion\n+    pub suggestion: String,\n+}\n+\n+/// Build suggestion gradually by handling closure arg specific usages,\n+/// such as explicit deref and borrowing cases.\n+/// Returns `None` if no such use cases have been triggered in closure body\n+///\n+/// note: this only works on single line immutable closures\n+pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, search_expr: &'tcx hir::Expr<'_>) -> Option<DerefClosure> {\n+    if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = search_expr.kind {\n+        let closure_body = cx.tcx.hir().body(body_id);\n+        // is closure arg a double reference (i.e.: `|x: &&i32| ...`)\n+        let closure_arg_is_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind {\n+            matches!(ty.kind, TyKind::Rptr(_, MutTy { .. }))\n+        } else {\n+            false\n+        };\n+\n+        let mut visitor = DerefDelegate {\n+            cx,\n+            closure_span: search_expr.span,\n+            closure_arg_is_double_ref,\n+            next_pos: search_expr.span.lo(),\n+            suggestion_start: String::new(),\n+            applicability: Applicability::MaybeIncorrect,\n+        };\n+\n+        let fn_def_id = cx.tcx.hir().local_def_id(search_expr.hir_id);\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n+            ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+                .consume_body(closure_body);\n+        });\n+\n+        if !visitor.suggestion_start.is_empty() {\n+            return Some(DerefClosure {\n+                applicability: visitor.applicability,\n+                suggestion: visitor.finish(),\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+/// Visitor struct used for tracking down\n+/// dereferencing and borrowing of closure's args\n+struct DerefDelegate<'a, 'tcx> {\n+    /// The late context of the lint\n+    cx: &'a LateContext<'tcx>,\n+    /// The span of the input closure to adapt\n+    closure_span: Span,\n+    /// Indicates if the arg of the closure is a double reference\n+    closure_arg_is_double_ref: bool,\n+    /// last position of the span to gradually build the suggestion\n+    next_pos: BytePos,\n+    /// starting part of the gradually built suggestion\n+    suggestion_start: String,\n+    /// confidence on the built suggestion\n+    applicability: Applicability,\n+}\n+\n+impl DerefDelegate<'_, 'tcx> {\n+    /// build final suggestion:\n+    /// - create the ending part of suggestion\n+    /// - concatenate starting and ending parts\n+    /// - potentially remove needless borrowing\n+    pub fn finish(&mut self) -> String {\n+        let end_span = Span::new(self.next_pos, self.closure_span.hi(), self.closure_span.ctxt(), None);\n+        let end_snip = snippet_with_applicability(self.cx, end_span, \"..\", &mut self.applicability);\n+        let sugg = format!(\"{}{}\", self.suggestion_start, end_snip);\n+        if self.closure_arg_is_double_ref {\n+            sugg.replacen('&', \"\", 1)\n+        } else {\n+            sugg\n+        }\n+    }\n+\n+    /// indicates whether the function from `parent_expr` takes its args by double reference\n+    fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n+        let (call_args, inputs) = match parent_expr.kind {\n+            ExprKind::MethodCall(_, _, call_args, _) => {\n+                if let Some(method_did) = self.cx.typeck_results().type_dependent_def_id(parent_expr.hir_id) {\n+                    (call_args, self.cx.tcx.fn_sig(method_did).skip_binder().inputs())\n+                } else {\n+                    return false;\n+                }\n+            },\n+            ExprKind::Call(func, call_args) => {\n+                let typ = self.cx.typeck_results().expr_ty(func);\n+                (call_args, typ.fn_sig(self.cx.tcx).skip_binder().inputs())\n+            },\n+            _ => return false,\n+        };\n+\n+        iter::zip(call_args, inputs)\n+            .any(|(arg, ty)| arg.hir_id == cmt_hir_id && matches!(ty.kind(), ty::Ref(_, inner, _) if inner.is_ref()))\n+    }\n+}\n+\n+impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n+\n+    #[allow(clippy::too_many_lines)]\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, _: ty::BorrowKind) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n+            let map = self.cx.tcx.hir();\n+            let span = map.span(cmt.hir_id);\n+            let start_span = Span::new(self.next_pos, span.lo(), span.ctxt(), None);\n+            let mut start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+\n+            // identifier referring to the variable currently triggered (i.e.: `fp`)\n+            let ident_str = map.name(id).to_string();\n+            // full identifier that includes projection (i.e.: `fp.field`)\n+            let ident_str_with_proj = snippet(self.cx, span, \"..\").to_string();\n+\n+            if cmt.place.projections.is_empty() {\n+                // handle item without any projection, that needs an explicit borrowing\n+                // i.e.: suggest `&x` instead of `x`\n+                self.closure_arg_is_double_ref = false;\n+                self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n+            } else {\n+                // cases where a parent `Call` or `MethodCall` is using the item\n+                // i.e.: suggest `.contains(&x)` for `.find(|x| [1, 2, 3].contains(x)).is_none()`\n+                //\n+                // Note about method calls:\n+                // - compiler automatically dereference references if the target type is a reference (works also for\n+                //   function call)\n+                // - `self` arguments in the case of `x.is_something()` are also automatically (de)referenced, and\n+                //   no projection should be suggested\n+                if let Some(parent_expr) = get_parent_expr_for_hir(self.cx, cmt.hir_id) {\n+                    match &parent_expr.kind {\n+                        // given expression is the self argument and will be handled completely by the compiler\n+                        // i.e.: `|x| x.is_something()`\n+                        ExprKind::MethodCall(_, _, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                            self.suggestion_start\n+                                .push_str(&format!(\"{}{}\", start_snip, ident_str_with_proj));\n+                            self.next_pos = span.hi();\n+                            return;\n+                        },\n+                        // item is used in a call\n+                        // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [_, call_args @ ..], _) => {\n+                            let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n+                            let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n+\n+                            if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n+                                // suggest ampersand if call function is taking args by double reference\n+                                let takes_arg_by_double_ref =\n+                                    self.func_takes_arg_by_double_ref(parent_expr, cmt.hir_id);\n+\n+                                // compiler will automatically dereference field projection, so no need\n+                                // to suggest ampersand, but full identifier that includes projection is required\n+                                let has_field_projection = cmt\n+                                    .place\n+                                    .projections\n+                                    .iter()\n+                                    .any(|proj| matches!(proj.kind, ProjectionKind::Field(..)));\n+\n+                                // no need to bind again if the function doesn't take arg by double ref\n+                                // and if the item is already a double ref\n+                                let ident_sugg = if !call_args.is_empty()\n+                                    && !takes_arg_by_double_ref\n+                                    && (self.closure_arg_is_double_ref || has_field_projection)\n+                                {\n+                                    let ident = if has_field_projection {\n+                                        ident_str_with_proj\n+                                    } else {\n+                                        ident_str\n+                                    };\n+                                    format!(\"{}{}\", start_snip, ident)\n+                                } else {\n+                                    format!(\"{}&{}\", start_snip, ident_str)\n+                                };\n+                                self.suggestion_start.push_str(&ident_sugg);\n+                                self.next_pos = span.hi();\n+                                return;\n+                            }\n+\n+                            self.applicability = Applicability::Unspecified;\n+                        },\n+                        _ => (),\n+                    }\n+                }\n+\n+                let mut replacement_str = ident_str;\n+                let mut projections_handled = false;\n+                cmt.place.projections.iter().enumerate().for_each(|(i, proj)| {\n+                    match proj.kind {\n+                        // Field projection like `|v| v.foo`\n+                        // no adjustment needed here, as field projections are handled by the compiler\n+                        ProjectionKind::Field(..) => match cmt.place.ty_before_projection(i).kind() {\n+                            ty::Adt(..) | ty::Tuple(_) => {\n+                                replacement_str = ident_str_with_proj.clone();\n+                                projections_handled = true;\n+                            },\n+                            _ => (),\n+                        },\n+                        // Index projection like `|x| foo[x]`\n+                        // the index is dropped so we can't get it to build the suggestion,\n+                        // so the span is set-up again to get more code, using `span.hi()` (i.e.: `foo[x]`)\n+                        // instead of `span.lo()` (i.e.: `foo`)\n+                        ProjectionKind::Index => {\n+                            let start_span = Span::new(self.next_pos, span.hi(), span.ctxt(), None);\n+                            start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+                            replacement_str.clear();\n+                            projections_handled = true;\n+                        },\n+                        // note: unable to trigger `Subslice` kind in tests\n+                        ProjectionKind::Subslice => (),\n+                        ProjectionKind::Deref => {\n+                            // explicit deref for arrays should be avoided in the suggestion\n+                            // i.e.: `|sub| *sub[1..4].len() == 3` is not expected\n+                            if let ty::Ref(_, inner, _) = cmt.place.ty_before_projection(i).kind() {\n+                                // dereferencing an array (i.e.: `|sub| sub[1..4].len() == 3`)\n+                                if matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_array()) {\n+                                    projections_handled = true;\n+                                }\n+                            }\n+                        },\n+                    }\n+                });\n+\n+                // handle `ProjectionKind::Deref` by removing one explicit deref\n+                // if no special case was detected (i.e.: suggest `*x` instead of `**x`)\n+                if projections_handled {\n+                    self.closure_arg_is_double_ref = false;\n+                } else {\n+                    let last_deref = cmt\n+                        .place\n+                        .projections\n+                        .iter()\n+                        .rposition(|proj| proj.kind == ProjectionKind::Deref);\n+\n+                    if let Some(pos) = last_deref {\n+                        let mut projections = cmt.place.projections.clone();\n+                        projections.truncate(pos);\n+\n+                        for item in projections {\n+                            if item.kind == ProjectionKind::Deref {\n+                                replacement_str = format!(\"*{}\", replacement_str);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                self.suggestion_start\n+                    .push_str(&format!(\"{}{}\", start_snip, replacement_str));\n+            }\n+            self.next_pos = span.hi();\n+        }\n+    }\n+\n+    fn mutate(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n+\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) {}\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::Sugg;"}]}