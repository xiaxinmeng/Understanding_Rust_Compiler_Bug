{"sha": "a59bec43e34715880f471db7d7c9d57939649d92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OWJlYzQzZTM0NzE1ODgwZjQ3MWRiN2Q3YzlkNTc5Mzk2NDlkOTI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-19T05:53:42Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-21T14:30:52Z"}, "message": "syntax/ext: convert all AstBuilder methods to a uniform syntax.", "tree": {"sha": "1014b9310c45d34b1fe1514b4125669555c5a977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1014b9310c45d34b1fe1514b4125669555c5a977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a59bec43e34715880f471db7d7c9d57939649d92", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a59bec43e34715880f471db7d7c9d57939649d92", "html_url": "https://github.com/rust-lang/rust/commit/a59bec43e34715880f471db7d7c9d57939649d92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a59bec43e34715880f471db7d7c9d57939649d92/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e5051553050974eb9362e1465cc2d40e2c9a610", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5051553050974eb9362e1465cc2d40e2c9a610", "html_url": "https://github.com/rust-lang/rust/commit/6e5051553050974eb9362e1465cc2d40e2c9a610"}], "stats": {"total": 2684, "additions": 998, "deletions": 1686}, "files": [{"sha": "01a504101b914ce11c70f1464bf9bbafcd2aa95f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 520, "deletions": 1042, "changes": 1562, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -12,8 +12,7 @@ use abi::AbiSet;\n use ast::ident;\n use ast;\n use ast_util;\n-use codemap;\n-use codemap::{span, respan, dummy_sp, spanned};\n+use codemap::{span, respan, dummy_sp};\n use fold;\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n@@ -34,460 +33,314 @@ mod syntax {\n pub trait AstBuilder {\n     // paths\n     fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path;\n     fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-        -> @ast::Path;\n-    fn path_tps_global(&self,\n-                       span: span,\n-                       strs: ~[ast::ident],\n-                       tps: ~[@ast::Ty])\n+    fn path_all(&self, sp: span,\n+                global: bool,\n+                idents: ~[ast::ident],\n+                rp: Option<@ast::Lifetime>,\n+                types: ~[@ast::Ty])\n         -> @ast::Path;\n \n     // types\n+    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+\n+    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n     fn ty_path(&self, @ast::Path) -> @ast::Ty;\n+    fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n+\n+    fn ty_rptr(&self, span: span,\n+               ty: @ast::Ty,\n+               lifetime: Option<@ast::Lifetime>,\n+               mutbl: ast::mutability)\n+        -> @ast::Ty;\n+    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_box(&self, span: span, ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n+\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_infer(&self, sp: span) -> @ast::Ty;\n+    fn ty_nil(&self) -> @ast::Ty;\n \n-    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam;\n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer(&self) -> @ast::Ty;\n-    fn ty_nil_ast_builder(&self) -> @ast::Ty;\n+    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n+    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam;\n+\n+    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref;\n+    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound;\n+    fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n \n     // statements\n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n-    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n-\n-    // literals\n-    fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n-    fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n+    fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n \n     // blocks\n     fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::blk;\n     fn blk_expr(&self, expr: @ast::expr) -> ast::blk;\n+    fn blk_all(&self, span: span,\n+               view_items: ~[@ast::view_item],\n+               stmts: ~[@ast::stmt],\n+               expr: Option<@ast::expr>) -> ast::blk;\n \n     // expressions\n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n-    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n+    fn expr_path(&self, path: @ast::Path) -> @ast::expr;\n+    fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr;\n+\n     fn expr_self(&self, span: span) -> @ast::expr;\n-    fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n-        -> @ast::expr;\n-    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n-        -> @ast::expr;\n-    fn expr_method_call(&self,\n-                        span: span,\n-                        expr: @ast::expr,\n-                        ident: ast::ident,\n-                        args: ~[@ast::expr])\n-        -> @ast::expr;\n+    fn expr_binary(&self, sp: span, op: ast::binop,\n+                   lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr;\n+    fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr) -> @ast::expr;\n+\n+    fn expr_copy(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_managed(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn expr_field_access(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_ident(&self, span: span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+                        args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_method_call(&self, span: span,\n+                        expr: @ast::expr, ident: ast::ident,\n+                        args: ~[@ast::expr]) -> @ast::expr;\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n-    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n-    fn expr_struct(&self,\n-                   path: @ast::Path,\n-                   fields: ~[ast::field]) -> @ast::expr;\n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n-    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-        -> @ast::expr;\n+\n+    fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field;\n+    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr;\n+    fn expr_struct_ident(&self, span: span, id: ast::ident, fields: ~[ast::field]) -> @ast::expr;\n+\n+    fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n+\n+    fn expr_uint(&self, span: span, i: uint) -> @ast::expr;\n+    fn expr_int(&self, sp: span, i: int) -> @ast::expr;\n+    fn expr_u8(&self, sp: span, u: u8) -> @ast::expr;\n+    fn expr_bool(&self, sp: span, value: bool) -> @ast::expr;\n+\n+    fn expr_vstore(&self, sp: span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr;\n+    fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_str(&self, sp: span, s: ~str) -> @ast::expr;\n+    fn expr_str_uniq(&self, sp: span, s: ~str) -> @ast::expr;\n+\n+    fn expr_unreachable(&self, span: span) -> @ast::expr;\n+\n+    fn pat(&self, span: span, pat: ast::pat_) -> @ast::pat;\n+    fn pat_wild(&self, span: span) -> @ast::pat;\n+    fn pat_lit(&self, span: span, expr: @ast::expr) -> @ast::pat;\n+    fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat;\n+\n+    fn pat_ident_binding_mode(&self,\n+                              span: span,\n+                              ident: ast::ident,\n+                              bm: ast::binding_mode) -> @ast::pat;\n+    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+    fn pat_struct(&self, span: span,\n+                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n+\n+    fn arm(&self, span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n+    fn arm_unreachable(&self, span: span) -> ast::arm;\n+\n+    fn expr_match(&self, span: span, arg: @ast::expr, arms: ~[ast::arm]) -> @ast::expr;\n+    fn expr_if(&self, span: span,\n+               cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr;\n+\n+    fn lambda_fn_decl(&self, span: span, fn_decl: ast::fn_decl, blk: ast::blk) -> @ast::expr;\n+\n+    fn lambda(&self, span: span, ids: ~[ast::ident], blk: ast::blk) -> @ast::expr;\n+    fn lambda0(&self, span: span, blk: ast::blk) -> @ast::expr;\n+    fn lambda1(&self, span: span, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n+\n+    fn lambda_expr(&self, span: span, ids: ~[ast::ident], blk: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_0(&self, span: span, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_1(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+\n+    fn lambda_stmts(&self, span: span, ids: ~[ast::ident], blk: ~[@ast::stmt]) -> @ast::expr;\n     fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_1(&self,\n-                      span: span,\n-                      stmts: ~[@ast::stmt],\n-                      ident: ast::ident)\n-        -> @ast::expr;\n+    fn lambda_stmts_1(&self, span: span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr;\n \n     // items\n-    fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n+    fn item(&self, span: span,\n+            name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn arg(&self, span: span, name: ident, ty: @ast::Ty) -> ast::arg;\n+    // XXX unused self\n     fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n \n     fn item_fn_poly(&self,\n-                    ame: ident,\n+                    span: span,\n+                    name: ident,\n                     inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n+               span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n                output: @ast::Ty,\n                body: ast::blk) -> @ast::item;\n \n-    fn variant(&self,\n-               name: ident,\n-               span: span,\n-               tys: ~[@ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant;\n     fn item_enum_poly(&self,\n-                      name: ident,\n                       span: span,\n+                      name: ident,\n                       enum_definition: ast::enum_def,\n                       generics: Generics) -> @ast::item;\n-    fn item_enum(&self,\n-                 name: ident,\n-                 span: span,\n-                 enum_definition: ast::enum_def) -> @ast::item;\n+    fn item_enum(&self, span: span, name: ident, enum_def: ast::enum_def) -> @ast::item;\n \n     fn item_struct_poly(&self,\n-                        name: ident,\n                         span: span,\n+                        name: ident,\n                         struct_def: ast::struct_def,\n                         generics: Generics) -> @ast::item;\n-    fn item_struct(&self,\n-                   name: ident,\n-                   span: span,\n-                   struct_def: ast::struct_def) -> @ast::item;\n+    fn item_struct(&self, span: span, name: ident, struct_def: ast::struct_def) -> @ast::item;\n \n-    fn item_mod(&self,\n-                name: ident,\n-                span: span,\n-                items: ~[@ast::item]) -> @ast::item;\n+    fn item_mod(&self, span: span,\n+                name: ident, attrs: ~[ast::attribute],\n+                vi: ~[@ast::view_item], items: ~[@ast::item]) -> @ast::item;\n \n     fn item_ty_poly(&self,\n-                    name: ident,\n                     span: span,\n+                    name: ident,\n                     ty: @ast::Ty,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-\n-\n-\n-\n-    fn mk_expr(&self,\n-               sp: codemap::span,\n-               expr: ast::expr_)\n-        -> @ast::expr;\n-\n-    fn mk_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n-    fn mk_int(&self, sp: span, i: int) -> @ast::expr;\n-    fn mk_uint(&self, sp: span, u: uint) -> @ast::expr;\n-    fn mk_u8(&self, sp: span, u: u8) -> @ast::expr;\n-    fn mk_binary(&self, sp: span, op: ast::binop,\n-                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr;\n-\n-    fn mk_deref(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn mk_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n-        -> @ast::expr;\n-    // XXX: unused self\n-    fn mk_raw_path(&self, sp: span, idents: ~[ast::ident]) -> @ast::Path;\n-    // XXX: unused self\n-    fn mk_raw_path_(&self, sp: span,\n-                    idents: ~[ast::ident],\n-                    rp: Option<@ast::Lifetime>,\n-                    types: ~[@ast::Ty])\n-        -> @ast::Path;\n-    // XXX: unused self\n-    fn mk_raw_path_global(&self,  sp: span,idents: ~[ast::ident]) -> @ast::Path;\n-    // XXX: unused self\n-    fn mk_raw_path_global_(&self, sp: span,\n-                           idents: ~[ast::ident],\n-                           rp: Option<@ast::Lifetime>,\n-                           types: ~[@ast::Ty]) -> @ast::Path;\n-    fn mk_path_raw(&self, sp: span, path: @ast::Path)-> @ast::expr;\n-    fn mk_path(&self, sp: span, idents: ~[ast::ident])\n-        -> @ast::expr;\n-    fn mk_path_global(&self, sp: span, idents: ~[ast::ident])\n-        -> @ast::expr;\n-    fn mk_access_(&self, sp: span, p: @ast::expr, m: ast::ident)\n-        -> @ast::expr;\n-    fn mk_access(&self, sp: span, p: ~[ast::ident], m: ast::ident)\n-        -> @ast::expr;\n-    fn mk_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn mk_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn mk_method_call(&self,\n-                      sp: span,\n-                      rcvr_expr: @ast::expr,\n-                      method_ident: ast::ident,\n-                      args: ~[@ast::expr]) -> @ast::expr;\n-    fn mk_call_(&self, sp: span, fn_expr: @ast::expr,\n-                args: ~[@ast::expr]) -> @ast::expr;\n-    fn mk_call(&self, sp: span, fn_path: ~[ast::ident],\n-               args: ~[@ast::expr]) -> @ast::expr;\n-    fn mk_call_global(&self, sp: span, fn_path: ~[ast::ident],\n-                      args: ~[@ast::expr]) -> @ast::expr;\n-    // e = expr, t = type\n-    fn mk_base_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n-        -> @ast::expr;\n-    fn mk_vstore_e(&self, sp: span, expr: @ast::expr,\n-                   vst: ast::expr_vstore) ->\n-        @ast::expr;\n-    fn mk_uniq_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n-        -> @ast::expr;\n-    fn mk_slice_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n-        -> @ast::expr;\n-    fn mk_base_str(&self, sp: span, s: ~str) -> @ast::expr;\n-    fn mk_uniq_str(&self, sp: span, s: ~str) -> @ast::expr;\n-    // XXX: unused self\n-    fn mk_field(&self, sp: span, f: &Field) -> ast::field;\n-    // XXX: unused self\n-    fn mk_fields(&self, sp: span, fields: ~[Field]) -> ~[ast::field];\n-    fn mk_struct_e(&self,\n-                   sp: span,\n-                   ctor_path: ~[ast::ident],\n-                   fields: ~[Field])\n-        -> @ast::expr;\n-    fn mk_global_struct_e(&self,\n-                          sp: span,\n-                          ctor_path: ~[ast::ident],\n-                          fields: ~[Field])\n-        -> @ast::expr;\n-    fn mk_glob_use(&self,\n-                   sp: span,\n-                   vis: ast::visibility,\n-                   path: ~[ast::ident]) -> @ast::view_item;\n-    fn mk_local(&self, sp: span, mutbl: bool,\n-                ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n-    fn mk_block(&self, span: span,\n-                view_items: ~[@ast::view_item],\n-                stmts: ~[@ast::stmt],\n-                expr: Option<@ast::expr>) -> @ast::expr;\n-    fn mk_block_(&self,\n-                 span: span,\n-                 stmts: ~[@ast::stmt])\n-        -> ast::blk;\n-    fn mk_simple_block(&self,\n-                       span: span,\n-                       expr: @ast::expr)\n-        -> ast::blk;\n-    fn mk_lambda_(&self,\n-                  span: span,\n-                  fn_decl: ast::fn_decl,\n-                  blk: ast::blk)\n-        -> @ast::expr;\n-    fn mk_lambda(&self,\n-                 span: span,\n-                 fn_decl: ast::fn_decl,\n-                 expr: @ast::expr)\n-        -> @ast::expr;\n-    fn mk_lambda_stmts(&self,\n-                       span: span,\n-                       fn_decl: ast::fn_decl,\n-                       stmts: ~[@ast::stmt])\n-        -> @ast::expr ;\n-    fn mk_lambda_no_args(&self,\n-                         span: span,\n-                         expr: @ast::expr)\n-        -> @ast::expr;\n-    fn mk_copy(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn mk_managed(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn mk_pat(&self, span: span, pat: ast::pat_) -> @ast::pat;\n-    fn mk_pat_wild(&self, span: span) -> @ast::pat;\n-    fn mk_pat_lit(&self,\n-                  span: span,\n-                  expr: @ast::expr) -> @ast::pat;\n-    fn mk_pat_ident(&self,\n-                    span: span,\n-                    ident: ast::ident) -> @ast::pat;\n-\n-    fn mk_pat_ident_with_binding_mode(&self,\n-                                      span: span,\n-                                      ident: ast::ident,\n-                                      bm: ast::binding_mode) -> @ast::pat;\n-    fn mk_pat_enum(&self,\n-                   span: span,\n-                   path: @ast::Path,\n-                   subpats: ~[@ast::pat])\n-        -> @ast::pat;\n-    fn mk_pat_struct(&self,\n-                     span: span,\n-                     path: @ast::Path,\n-                     field_pats: ~[ast::field_pat])\n-        -> @ast::pat;\n-    fn mk_bool(&self, span: span, value: bool) -> @ast::expr;\n-    fn mk_stmt(&self, span: span, expr: @ast::expr) -> @ast::stmt;\n-\n-    // XXX: unused self\n-    fn mk_ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n-\n-    fn mk_ty(&self,\n-             span: span,\n-             ty: ast::ty_) -> @ast::Ty;\n-\n-    fn mk_ty_path(&self,\n-                  span: span,\n-                  idents: ~[ ast::ident ])\n-        -> @ast::Ty;\n-\n-    fn mk_ty_path_global(&self,\n-                         span: span,\n-                         idents: ~[ ast::ident ])\n-        -> @ast::Ty;\n-\n-    fn mk_ty_path_path(&self,\n-                       span: span,\n-                       path: @ast::Path)\n-        -> @ast::Ty;\n+    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item;\n \n-    fn mk_ty_rptr(&self,\n-                  span: span,\n-                  ty: @ast::Ty,\n-                  lifetime: Option<@ast::Lifetime>,\n-                  mutbl: ast::mutability)\n-        -> @ast::Ty;\n-    fn mk_ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n-    fn mk_ty_box(&self, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n+    fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n \n+    fn meta_word(&self, sp: span, w: ~str) -> @ast::meta_item;\n+    fn meta_list(&self, sp: span, name: ~str, mis: ~[@ast::meta_item]) -> @ast::meta_item;\n+    fn meta_name_value(&self, sp: span, name: ~str, value: ast::lit_) -> @ast::meta_item;\n \n-\n-    fn mk_ty_infer(&self, span: span) -> @ast::Ty;\n-    fn mk_trait_ref_global(&self,\n-                           span: span,\n-                           idents: ~[ ast::ident ])\n-        -> @ast::trait_ref;\n-    fn mk_trait_ref_(&self, path: @ast::Path) -> @ast::trait_ref;\n-    fn mk_simple_ty_path(&self,\n-                         span: span,\n-                         ident: ast::ident)\n-        -> @ast::Ty;\n-    fn mk_arg(&self,\n-              span: span,\n-              ident: ast::ident,\n-              ty: @ast::Ty)\n-        -> ast::arg;\n-    // XXX unused self\n-    fn mk_fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn mk_trait_ty_param_bound_global(&self,\n-                                      span: span,\n-                                      idents: ~[ast::ident])\n-        -> ast::TyParamBound;\n-    fn mk_trait_ty_param_bound_(&self,\n-                                path: @ast::Path) -> ast::TyParamBound;\n-    fn mk_ty_param(&self,\n-                   ident: ast::ident,\n-                   bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam;\n-    fn mk_lifetime(&self,\n-                   span: span,\n-                   ident: ast::ident)\n-        -> ast::Lifetime;\n-    fn mk_arm(&self,\n-              span: span,\n-              pats: ~[@ast::pat],\n-              expr: @ast::expr)\n-        -> ast::arm;\n-    fn mk_unreachable(&self, span: span) -> @ast::expr;\n-    fn mk_unreachable_arm(&self, span: span) -> ast::arm;\n-\n-    fn make_self(&self, span: span) -> @ast::expr;\n+    fn view_use(&self, sp: span,\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item;\n+    fn view_use_list(&self, sp: span, vis: ast::visibility,\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item;\n+    fn view_use_glob(&self, sp: span,\n+                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item;\n }\n \n impl AstBuilder for @ExtCtxt {\n     fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: false,\n-            idents: strs,\n-            rp: None,\n-            types: ~[]\n-        }\n+        self.path_all(span, false, strs, None, ~[])\n+    }\n+    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path {\n+        self.path(span, ~[id])\n     }\n-\n     fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+        self.path_all(span, true, strs, None, ~[])\n+    }\n+    fn path_all(&self, sp: span,\n+                global: bool,\n+                idents: ~[ast::ident],\n+                rp: Option<@ast::Lifetime>,\n+                types: ~[@ast::Ty])\n+        -> @ast::Path {\n         @ast::Path {\n-            span: span,\n-            global: true,\n-            idents: strs,\n-            rp: None,\n-            types: ~[]\n+            span: sp,\n+            global: global,\n+            idents: idents,\n+            rp: rp,\n+            types: types\n         }\n     }\n \n-    fn path_tps(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: false,\n-            idents: strs,\n-            rp: None,\n-            types: tps\n+    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+        ast::mt {\n+            ty: ty,\n+            mutbl: mutbl\n         }\n     }\n \n-    fn path_tps_global(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Path {\n-        @ast::Path {\n+    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty {\n+        @ast::Ty {\n+            id: self.next_id(),\n             span: span,\n-            global: true,\n-            idents: strs,\n-            rp: None,\n-            types: tps\n+            node: ty\n         }\n     }\n \n     fn ty_path(&self, path: @ast::Path) -> @ast::Ty {\n-        self.mk_ty(path.span,\n-                   ast::ty_path(path, self.next_id()))\n+        self.ty(path.span,\n+                ast::ty_path(path, self.next_id()))\n+    }\n+\n+    fn ty_ident(&self, span: span, ident: ast::ident)\n+        -> @ast::Ty {\n+        self.ty_path(self.path_ident(span, ident))\n+    }\n+\n+    fn ty_rptr(&self,\n+               span: span,\n+               ty: @ast::Ty,\n+               lifetime: Option<@ast::Lifetime>,\n+               mutbl: ast::mutability)\n+        -> @ast::Ty {\n+        self.ty(span,\n+                ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n+    }\n+    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n+        self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n+    }\n+    fn ty_box(&self, span: span,\n+                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+        self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n \n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path(\n-            self.path_tps_global(dummy_sp(),\n-                                 ~[\n-                                     self.ident_of(\"core\"),\n-                                     self.ident_of(\"option\"),\n-                                     self.ident_of(\"Option\")\n-                                 ],\n-                                 ~[ ty ]))\n-    }\n-\n-    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field {\n-        spanned {\n-            node: ast::ty_field_ {\n-                ident: name,\n-                mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n-            },\n-            span: dummy_sp(),\n-        }\n+            self.path_all(dummy_sp(),\n+                          true,\n+                          ~[\n+                              self.ident_of(\"core\"),\n+                              self.ident_of(\"option\"),\n+                              self.ident_of(\"Option\")\n+                          ],\n+                          None,\n+                          ~[ ty ]))\n     }\n \n-    fn ty_infer(&self) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_infer,\n-            span: dummy_sp(),\n-        }\n+    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n+        respan(span,\n+               ast::ty_field_ {\n+                   ident: name,\n+                   mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+               })\n     }\n \n-    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam\n-    {\n-        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n+    fn ty_infer(&self, span: span) -> @ast::Ty {\n+        self.ty(span, ast::ty_infer)\n     }\n \n-    fn ty_nil_ast_builder(&self) -> @ast::Ty {\n+    fn ty_nil(&self) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_nil,\n             span: dummy_sp(),\n         }\n     }\n \n+    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam {\n+        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n+    }\n+\n+    // these are strange, and probably shouldn't be used outside of\n+    // pipes. Specifically, the global version possible generates\n+    // incorrect code.\n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_path(\n-                self.mk_raw_path(dummy_sp(), ~[p.ident]))))\n+            ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n     }\n \n-    fn ty_vars_global(&self,\n-                      ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.mk_raw_path(dummy_sp(), ~[p.ident]))))\n+                self.path_global(dummy_sp(), ~[p.ident]))))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n@@ -501,52 +354,59 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n+    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref {\n+        @ast::trait_ref {\n+            path: path,\n+            ref_id: self.next_id()\n+        }\n+    }\n \n-    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n-        @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n-                           span: expr.span }\n+    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound {\n+        ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n-    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n-        let ext_cx = *self;\n-        quote_stmt!( let $ident = $e; )\n+    fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime {\n+        ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n     }\n \n-    fn lit_str(&self, span: span, s: @~str) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_vstore(\n-                self.expr(\n-                    span,\n-                    ast::expr_lit(\n-                        @codemap::spanned { node: ast::lit_str(s),\n-                                           span: span})),\n-                ast::expr_vstore_uniq))\n+    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n+        @respan(expr.span, ast::stmt_semi(expr, self.next_id()))\n     }\n \n-    fn lit_uint(&self, span: span, i: uint) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_lit(\n-                @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n-                                   span: span}))\n+    fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+        let pat = self.pat_ident(sp, ident);\n+        let local = @respan(sp,\n+                            ast::local_ {\n+                                is_mutbl: mutbl,\n+                                ty: self.ty_infer(sp),\n+                                pat: pat,\n+                                init: Some(ex),\n+                                id: self.next_id(),\n+                            });\n+        let decl = respan(sp, ast::decl_local(~[local]));\n+        @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n     }\n \n     fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: stmts,\n-                expr: expr,\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: span,\n-        }\n+        self.blk_all(span, ~[], stmts, expr)\n     }\n \n     fn blk_expr(&self, expr: @ast::expr) -> ast::blk {\n-        self.blk(expr.span, ~[], Some(expr))\n+        self.blk_all(expr.span, ~[], ~[], Some(expr))\n+    }\n+    fn blk_all(&self,\n+               span: span,\n+               view_items: ~[@ast::view_item],\n+               stmts: ~[@ast::stmt],\n+               expr: Option<@ast::expr>) -> ast::blk {\n+        respan(span,\n+               ast::blk_ {\n+                   view_items: view_items,\n+                   stmts: stmts,\n+                   expr: expr,\n+                   id: self.next_id(),\n+                   rules: ast::default_blk,\n+               })\n     }\n \n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n@@ -558,164 +418,272 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, strs)))\n+    fn expr_path(&self, path: @ast::Path) -> @ast::expr {\n+        self.expr(path.span, ast::expr_path(path))\n     }\n \n-    fn expr_path_global(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path_global(span, strs)))\n+    fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr {\n+        self.expr_path(self.path_ident(span, id))\n+    }\n+    fn expr_self(&self, span: span) -> @ast::expr {\n+        self.expr(span, ast::expr_self)\n     }\n \n-    fn expr_var(&self, span: span, var: &str) -> @ast::expr {\n-        self.expr_path(span, ~[self.ident_of(var)])\n+    fn expr_binary(&self, sp: span, op: ast::binop,\n+                   lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n+        self.next_id(); // see ast_util::op_expr_callee_id\n+        self.expr(sp, ast::expr_binary(op, lhs, rhs))\n     }\n \n-    fn expr_self(&self, span: span) -> @ast::expr {\n-        self.expr(span, ast::expr_self)\n+    fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr_unary(sp, ast::deref, e)\n+    }\n+    fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n+        -> @ast::expr {\n+        self.next_id(); // see ast_util::op_expr_callee_id\n+        self.expr(sp, ast::expr_unary(op, e))\n     }\n \n-    fn expr_field(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_field(expr, ident, ~[]))\n+    fn expr_copy(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr(sp, ast::expr_copy(e))\n+    }\n+    fn expr_managed(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr_unary(sp, ast::box(ast::m_imm), e)\n     }\n \n-    fn expr_call(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n+    fn expr_field_access(&self, sp: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+        self.expr(sp, ast::expr_field(expr, ident, ~[]))\n+    }\n+    fn expr_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr(sp, ast::expr_addr_of(ast::m_imm, e))\n+    }\n+    fn expr_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.expr(sp, ast::expr_addr_of(ast::m_mutbl, e))\n     }\n \n-    fn expr_method_call(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n+    }\n+    fn expr_call_ident(&self, span: span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(span,\n+                  ast::expr_call(self.expr_ident(span, id), args, ast::NoSugar))\n+    }\n+    fn expr_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr {\n+        let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n+        self.expr_call(sp, pathexpr, args)\n+    }\n+    fn expr_method_call(&self, span: span,\n+                        expr: @ast::expr,\n+                        ident: ast::ident,\n+                        args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span,\n                   ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n     }\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr {\n-        self.expr(dummy_sp(), ast::expr_block(b))\n+        self.expr(b.span, ast::expr_block(b))\n     }\n-    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field {\n-        spanned {\n-            node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n-            span: dummy_sp(),\n-        }\n+    fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field {\n+        respan(span, ast::field_ { mutbl: ast::m_imm, ident: name, expr: e })\n     }\n-    fn expr_struct(&self, path: @ast::Path,\n-                   fields: ~[ast::field]) -> @ast::expr {\n-        @ast::expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_struct(path, fields, None),\n-            span: dummy_sp()\n+    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr {\n+        self.expr(span, ast::expr_struct(path, fields, None))\n+    }\n+    fn expr_struct_ident(&self, span: span,\n+                         id: ast::ident, fields: ~[ast::field]) -> @ast::expr {\n+        self.expr_struct(span, self.path_ident(span, id), fields)\n+    }\n+\n+    fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr {\n+        self.expr(sp, ast::expr_lit(@respan(sp, lit)))\n+    }\n+    fn expr_uint(&self, span: span, i: uint) -> @ast::expr {\n+        self.expr_lit(span, ast::lit_uint(i as u64, ast::ty_u))\n+    }\n+    fn expr_int(&self, sp: span, i: int) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_int(i as i64, ast::ty_i))\n+    }\n+    fn expr_u8(&self, sp: span, u: u8) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_uint(u as u64, ast::ty_u8))\n+    }\n+    fn expr_bool(&self, sp: span, value: bool) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_bool(value))\n+    }\n+\n+    fn expr_vstore(&self, sp: span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr {\n+        self.expr(sp, ast::expr_vstore(expr, vst))\n+    }\n+    fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+        self.expr(sp, ast::expr_vec(exprs, ast::m_imm))\n+    }\n+    fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_uniq)\n+    }\n+    fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_slice)\n+    }\n+    fn expr_str(&self, sp: span, s: ~str) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_str(@s))\n+    }\n+    fn expr_str_uniq(&self, sp: span, s: ~str) -> @ast::expr {\n+        self.expr_vstore(sp, self.expr_str(sp, s), ast::expr_vstore_uniq)\n+    }\n+\n+\n+    fn expr_unreachable(&self, span: span) -> @ast::expr {\n+        let loc = self.codemap().lookup_char_pos(span.lo);\n+        self.expr_call_global(\n+            span,\n+            ~[\n+                self.ident_of(\"core\"),\n+                self.ident_of(\"sys\"),\n+                self.ident_of(\"FailWithCause\"),\n+                self.ident_of(\"fail_with\"),\n+            ],\n+            ~[\n+                self.expr_str(span, ~\"internal error: entered unreachable code\"),\n+                self.expr_str(span, copy loc.file.name),\n+                self.expr_uint(span, loc.line),\n+            ])\n+    }\n+\n+\n+    fn pat(&self, span: span, pat: ast::pat_) -> @ast::pat {\n+        @ast::pat { id: self.next_id(), node: pat, span: span }\n+    }\n+    fn pat_wild(&self, span: span) -> @ast::pat {\n+        self.pat(span, ast::pat_wild)\n+    }\n+    fn pat_lit(&self, span: span, expr: @ast::expr) -> @ast::pat {\n+        self.pat(span, ast::pat_lit(expr))\n+    }\n+    fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat {\n+        self.pat_ident_binding_mode(span, ident, ast::bind_by_copy)\n+    }\n+\n+    fn pat_ident_binding_mode(&self,\n+                              span: span,\n+                              ident: ast::ident,\n+                              bm: ast::binding_mode) -> @ast::pat {\n+        let path = self.path_ident(span, ident);\n+        let pat = ast::pat_ident(bm, path, None);\n+        self.pat(span, pat)\n+    }\n+    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n+        let pat = ast::pat_enum(path, Some(subpats));\n+        self.pat(span, pat)\n+    }\n+    fn pat_struct(&self, span: span,\n+                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n+        let pat = ast::pat_struct(path, field_pats, false);\n+        self.pat(span, pat)\n+    }\n+\n+    fn arm(&self, _span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm {\n+        ast::arm {\n+            pats: pats,\n+            guard: None,\n+            body: self.blk_expr(expr)\n         }\n     }\n \n+    fn arm_unreachable(&self, span: span) -> ast::arm {\n+        self.arm(span, ~[self.pat_wild(span)], self.expr_unreachable(span))\n+    }\n+\n+    fn expr_match(&self, span: span, arg: @ast::expr, arms: ~[ast::arm]) -> @expr {\n+        self.expr(span, ast::expr_match(arg, arms))\n+    }\n \n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n+    fn expr_if(&self, span: span,\n+               cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr {\n+        let els = els.map(|x| self.expr_blk(self.blk_expr(*x)));\n+        self.expr(span, ast::expr_if(cond, self.blk_expr(then), els))\n+    }\n+\n+    fn lambda_fn_decl(&self, span: span, fn_decl: ast::fn_decl, blk: ast::blk) -> @ast::expr {\n+        self.expr(span, ast::expr_fn_block(fn_decl, blk))\n+    }\n+    fn lambda(&self, span: span, ids: ~[ast::ident], blk: ast::blk) -> @ast::expr {\n+        let fn_decl = self.fn_decl(\n+            ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n+            self.ty_infer(span));\n+\n+        self.expr(span, ast::expr_fn_block(fn_decl, blk))\n+    }\n+    fn lambda0(&self, _span: span, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( || $blk_e )\n+        quote_expr!(|| $blk_e )\n     }\n \n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n+    fn lambda1(&self, _span: span, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( |$ident| $blk_e )\n+        quote_expr!(|$ident| $blk_e )\n     }\n \n-    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n-        self.lambda0(self.blk_expr(expr))\n+    fn lambda_expr(&self, span: span, ids: ~[ast::ident], expr: @ast::expr) -> @ast::expr {\n+        self.lambda(span, ids, self.blk_expr(expr))\n     }\n-\n-    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-        -> @ast::expr {\n-        self.lambda1(self.blk_expr(expr), ident)\n+    fn lambda_expr_0(&self, span: span, expr: @ast::expr) -> @ast::expr {\n+        self.lambda0(span, self.blk_expr(expr))\n+    }\n+    fn lambda_expr_1(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+        self.lambda1(span, self.blk_expr(expr), ident)\n     }\n \n+    fn lambda_stmts(&self, span: span, ids: ~[ast::ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda(span, ids, self.blk(span, stmts, None))\n+    }\n     fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda0(self.blk(span, stmts, None))\n+        self.lambda0(span, self.blk(span, stmts, None))\n     }\n-\n-    fn lambda_stmts_1(&self,\n-                      span: span,\n-                      stmts: ~[@ast::stmt],\n-                      ident: ast::ident)\n-        -> @ast::expr {\n-        self.lambda1(self.blk(span, stmts, None), ident)\n+    fn lambda_stmts_1(&self, span: span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr {\n+        self.lambda1(span, self.blk(span, stmts, None), ident)\n     }\n \n-\n-    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n+    fn arg(&self, span: span, ident: ast::ident, ty: @ast::Ty) -> ast::arg {\n+        let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             is_mutbl: false,\n             ty: ty,\n-            pat: @ast::pat {\n-                id: self.next_id(),\n-                node: ast::pat_ident(\n-                    ast::bind_by_copy,\n-                    ast_util::ident_to_path(dummy_sp(), name),\n-                    None),\n-                span: dummy_sp(),\n-            },\n-            id: self.next_id(),\n+            pat: arg_pat,\n+            id: self.next_id()\n         }\n     }\n \n-    fn fn_decl(&self, inputs: ~[ast::arg],\n-               output: @ast::Ty) -> ast::fn_decl {\n+    // XXX unused self\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n             output: output,\n             cf: ast::return_val,\n         }\n     }\n \n-    fn item(&self, name: ident, span: span,\n-            node: ast::item_) -> @ast::item {\n-\n+    fn item(&self, span: span,\n+            name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item {\n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n-            style: ast::attr_outer,\n-            value: @respan(dummy_sp(),\n-                           ast::meta_list(@~\"allow\", ~[\n-                               @respan(dummy_sp(),\n-                                       ast::meta_word(\n-                                           @~\"non_camel_case_types\"))\n-                           ])),\n-            is_sugared_doc: false\n-        });\n-\n         @ast::item { ident: name,\n-                    attrs: ~[non_camel_case_attribute],\n+                    attrs: attrs,\n                     id: self.next_id(),\n                     node: node,\n                     vis: ast::public,\n                     span: span }\n     }\n \n-    fn item_fn_poly(&self, name: ident,\n+    fn item_fn_poly(&self,\n+                    span: span,\n+                    name: ident,\n                     inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item {\n-        self.item(name,\n-                  dummy_sp(),\n+        self.item(span,\n+                  name,\n+                  ~[],\n                   ast::item_fn(self.fn_decl(inputs, output),\n                                ast::impure_fn,\n                                AbiSet::Rust(),\n@@ -724,634 +692,144 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn item_fn(&self,\n+               span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n                output: @ast::Ty,\n                body: ast::blk\n               ) -> @ast::item {\n         self.item_fn_poly(\n+            span,\n             name,\n             inputs,\n             output,\n             ast_util::empty_generics(),\n-            body\n-        )\n+            body)\n     }\n \n-    fn variant(&self, name: ident, span: span,\n-               tys: ~[@ast::Ty]) -> ast::variant {\n+    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant {\n         let args = do tys.map |ty| {\n             ast::variant_arg { ty: *ty, id: self.next_id() }\n         };\n \n-        spanned {\n-            node: ast::variant_ {\n-                name: name,\n-                attrs: ~[],\n-                kind: ast::tuple_variant_kind(args),\n-                id: self.next_id(),\n-                disr_expr: None,\n-                vis: ast::public\n-            },\n-            span: span,\n-        }\n+        respan(span,\n+               ast::variant_ {\n+                   name: name,\n+                   attrs: ~[],\n+                   kind: ast::tuple_variant_kind(args),\n+                   id: self.next_id(),\n+                   disr_expr: None,\n+                   vis: ast::public\n+               })\n     }\n \n-    fn item_enum_poly(&self, name: ident, span: span,\n+    fn item_enum_poly(&self, span: span, name: ident,\n                       enum_definition: ast::enum_def,\n                       generics: Generics) -> @ast::item {\n-        self.item(name, span, ast::item_enum(enum_definition, generics))\n+        self.item(span, name, ~[], ast::item_enum(enum_definition, generics))\n     }\n \n-    fn item_enum(&self, name: ident, span: span,\n+    fn item_enum(&self, span: span, name: ident,\n                  enum_definition: ast::enum_def) -> @ast::item {\n-        self.item_enum_poly(name, span, enum_definition,\n+        self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(\n-        &self, name: ident,\n+        &self,\n         span: span,\n+        name: ident,\n         struct_def: ast::struct_def\n     ) -> @ast::item {\n         self.item_struct_poly(\n-            name,\n             span,\n+            name,\n             struct_def,\n             ast_util::empty_generics()\n         )\n     }\n \n     fn item_struct_poly(\n         &self,\n-        name: ident,\n         span: span,\n+        name: ident,\n         struct_def: ast::struct_def,\n         generics: Generics\n     ) -> @ast::item {\n-        self.item(name, span, ast::item_struct(@struct_def, generics))\n+        self.item(span, name, ~[], ast::item_struct(@struct_def, generics))\n     }\n \n-    fn item_mod(&self, name: ident, span: span,\n+    fn item_mod(&self, span: span, name: ident,\n+                attrs: ~[ast::attribute],\n+                vi: ~[@ast::view_item],\n                 items: ~[@ast::item]) -> @ast::item {\n-\n-        // XXX: Total hack: import `core::kinds::Owned` to work around a\n-        // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n-        let vi = ast::view_item_use(~[\n-            @codemap::spanned {\n-                node: ast::view_path_simple(\n-                    self.ident_of(\"Owned\"),\n-                    self.mk_raw_path(\n-                        codemap::dummy_sp(),\n-                        ~[\n-                            self.ident_of(\"core\"),\n-                            self.ident_of(\"kinds\"),\n-                            self.ident_of(\"Owned\")\n-                        ]\n-                    ),\n-                    self.next_id()\n-                ),\n-                span: codemap::dummy_sp()\n-            }\n-        ]);\n-        let vi = @ast::view_item {\n-            node: vi,\n-            attrs: ~[],\n-            vis: ast::private,\n-            span: codemap::dummy_sp()\n-        };\n-\n         self.item(\n-            name,\n             span,\n+            name,\n+            attrs,\n             ast::item_mod(ast::_mod {\n-                view_items: ~[vi],\n+                view_items: vi,\n                 items: items,\n             })\n         )\n     }\n \n-    fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n+    fn item_ty_poly(&self, span: span, name: ident, ty: @ast::Ty,\n                     generics: Generics) -> @ast::item {\n-        self.item(name, span, ast::item_ty(ty, generics))\n+        self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n-        self.item_ty_poly(name, span, ty, ast_util::empty_generics())\n+    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item {\n+        self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-\n-\n-\n-\n-\n-\n-    fn mk_expr(&self,\n-               sp: codemap::span,\n-               expr: ast::expr_)\n-        -> @ast::expr {\n-        @ast::expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: expr,\n-            span: sp,\n-        }\n+    fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute {\n+        respan(sp,\n+               ast::attribute_ {\n+                   style: ast::attr_outer,\n+                   value: mi,\n+                   is_sugared_doc: false\n+               })\n     }\n \n-    fn mk_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr {\n-        let sp_lit = @codemap::spanned { node: lit, span: sp };\n-        self.mk_expr( sp, ast::expr_lit(sp_lit))\n+    fn meta_word(&self, sp: span, w: ~str) -> @ast::meta_item {\n+        @respan(sp, ast::meta_word(@w))\n     }\n-    fn mk_int(&self, sp: span, i: int) -> @ast::expr {\n-        let lit = ast::lit_int(i as i64, ast::ty_i);\n-        return self.mk_lit( sp, lit);\n+    fn meta_list(&self, sp: span, name: ~str, mis: ~[@ast::meta_item]) -> @ast::meta_item {\n+        @respan(sp, ast::meta_list(@name, mis))\n     }\n-    fn mk_uint(&self, sp: span, u: uint) -> @ast::expr {\n-        let lit = ast::lit_uint(u as u64, ast::ty_u);\n-        return self.mk_lit( sp, lit);\n-    }\n-    fn mk_u8(&self, sp: span, u: u8) -> @ast::expr {\n-        let lit = ast::lit_uint(u as u64, ast::ty_u8);\n-        return self.mk_lit( sp, lit);\n-    }\n-    fn mk_binary(&self, sp: span, op: ast::binop,\n-                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n-        self.next_id(); // see ast_util::op_expr_callee_id\n-        self.mk_expr( sp, ast::expr_binary(op, lhs, rhs))\n+    fn meta_name_value(&self, sp: span, name: ~str, value: ast::lit_) -> @ast::meta_item {\n+        @respan(sp, ast::meta_name_value(@name, respan(sp, value)))\n     }\n \n-    fn mk_deref(&self, sp: span, e: @ast::expr) -> @ast::expr {\n-        self.mk_unary( sp, ast::deref, e)\n-    }\n-    fn mk_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n-        -> @ast::expr {\n-        self.next_id(); // see ast_util::op_expr_callee_id\n-        self.mk_expr( sp, ast::expr_unary(op, e))\n-    }\n-    // XXX: unused self\n-    fn mk_raw_path(&self, sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-        self.mk_raw_path_(sp, idents, None, ~[])\n-    }\n-    // XXX: unused self\n-    fn mk_raw_path_(&self, sp: span,\n-                    idents: ~[ast::ident],\n-                    rp: Option<@ast::Lifetime>,\n-                    types: ~[@ast::Ty])\n-        -> @ast::Path {\n-        @ast::Path { span: sp,\n-                    global: false,\n-                    idents: idents,\n-                    rp: rp,\n-                    types: types }\n-    }\n-    // XXX: unused self\n-    fn mk_raw_path_global(&self, sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-        self.mk_raw_path_global_(sp, idents, None, ~[])\n-    }\n-    // XXX: unused self\n-    fn mk_raw_path_global_(&self, sp: span,\n-                           idents: ~[ast::ident],\n-                           rp: Option<@ast::Lifetime>,\n-                           types: ~[@ast::Ty]) -> @ast::Path {\n-        @ast::Path { span: sp,\n-                    global: true,\n-                    idents: idents,\n-                    rp: rp,\n-                    types: types }\n-    }\n-    fn mk_path_raw(&self, sp: span, path: @ast::Path)-> @ast::expr {\n-        self.mk_expr( sp, ast::expr_path(path))\n-    }\n-    fn mk_path(&self, sp: span, idents: ~[ast::ident])\n-        -> @ast::expr {\n-        self.mk_path_raw( sp, self.mk_raw_path(sp, idents))\n-    }\n-    fn mk_path_global(&self, sp: span, idents: ~[ast::ident])\n-        -> @ast::expr {\n-        self.mk_path_raw( sp, self.mk_raw_path_global(sp, idents))\n-    }\n-    fn mk_access_(&self, sp: span, p: @ast::expr, m: ast::ident)\n-        -> @ast::expr {\n-        self.mk_expr( sp, ast::expr_field(p, m, ~[]))\n-    }\n-    fn mk_access(&self, sp: span, p: ~[ast::ident], m: ast::ident)\n-        -> @ast::expr {\n-        let pathexpr = self.mk_path( sp, p);\n-        return self.mk_access_( sp, pathexpr, m);\n-    }\n-    fn mk_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n-        return self.mk_expr( sp, ast::expr_addr_of(ast::m_imm, e));\n-    }\n-    fn mk_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n-        return self.mk_expr( sp, ast::expr_addr_of(ast::m_mutbl, e));\n-    }\n-    fn mk_method_call(&self,\n-                      sp: span,\n-                      rcvr_expr: @ast::expr,\n-                      method_ident: ast::ident,\n-                      args: ~[@ast::expr]) -> @ast::expr {\n-        self.mk_expr( sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n-    }\n-    fn mk_call_(&self, sp: span, fn_expr: @ast::expr,\n-                args: ~[@ast::expr]) -> @ast::expr {\n-        self.mk_expr( sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n-    }\n-    fn mk_call(&self, sp: span, fn_path: ~[ast::ident],\n-               args: ~[@ast::expr]) -> @ast::expr {\n-        let pathexpr = self.mk_path( sp, fn_path);\n-        return self.mk_call_( sp, pathexpr, args);\n-    }\n-    fn mk_call_global(&self, sp: span, fn_path: ~[ast::ident],\n-                      args: ~[@ast::expr]) -> @ast::expr {\n-        let pathexpr = self.mk_path_global( sp, fn_path);\n-        return self.mk_call_( sp, pathexpr, args);\n-    }\n-    // e = expr, t = type\n-    fn mk_base_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n-        -> @ast::expr {\n-        let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n-        self.mk_expr( sp, vecexpr)\n-    }\n-    fn mk_vstore_e(&self, sp: span, expr: @ast::expr,\n-                   vst: ast::expr_vstore) ->\n-        @ast::expr {\n-        self.mk_expr( sp, ast::expr_vstore(expr, vst))\n-    }\n-    fn mk_uniq_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n-        -> @ast::expr {\n-        self.mk_vstore_e( sp, self.mk_base_vec_e( sp, exprs), ast::expr_vstore_uniq)\n-    }\n-    fn mk_slice_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n-        -> @ast::expr {\n-        self.mk_vstore_e( sp, self.mk_base_vec_e( sp, exprs),\n-                    ast::expr_vstore_slice)\n-    }\n-    fn mk_base_str(&self, sp: span, s: ~str) -> @ast::expr {\n-        let lit = ast::lit_str(@s);\n-        return self.mk_lit( sp, lit);\n-    }\n-    fn mk_uniq_str(&self, sp: span, s: ~str) -> @ast::expr {\n-        self.mk_vstore_e( sp, self.mk_base_str( sp, s), ast::expr_vstore_uniq)\n-    }\n-    // XXX: unused self\n-    fn mk_field(&self, sp: span, f: &Field) -> ast::field {\n-        codemap::spanned {\n-            node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n-            span: sp,\n+    fn view_use(&self, sp: span,\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item {\n+        @ast::view_item {\n+            node: ast::view_item_use(vp),\n+            attrs: ~[],\n+            vis: vis,\n+            span: sp\n         }\n     }\n-    // XXX: unused self\n-    fn mk_fields(&self, sp: span, fields: ~[Field]) -> ~[ast::field] {\n-        fields.map(|f| self.mk_field(sp, f))\n-    }\n-    fn mk_struct_e(&self,\n-                   sp: span,\n-                   ctor_path: ~[ast::ident],\n-                   fields: ~[Field])\n-        -> @ast::expr {\n-        self.mk_expr( sp,\n-                ast::expr_struct(self.mk_raw_path(sp, ctor_path),\n-                                 self.mk_fields(sp, fields),\n-                                 option::None::<@ast::expr>))\n-    }\n-    fn mk_global_struct_e(&self,\n-                          sp: span,\n-                          ctor_path: ~[ast::ident],\n-                          fields: ~[Field])\n-        -> @ast::expr {\n-        self.mk_expr( sp,\n-                ast::expr_struct(self.mk_raw_path_global(sp, ctor_path),\n-                                 self.mk_fields(sp, fields),\n-                                 option::None::<@ast::expr>))\n-    }\n-    fn mk_glob_use(&self,\n-                   sp: span,\n-                   vis: ast::visibility,\n-                   path: ~[ast::ident]) -> @ast::view_item {\n-        let glob = @codemap::spanned {\n-            node: ast::view_path_glob(self.mk_raw_path(sp, path), self.next_id()),\n-            span: sp,\n-        };\n-        @ast::view_item { node: ast::view_item_use(~[glob]),\n-                         attrs: ~[],\n-                         vis: vis,\n-                         span: sp }\n-    }\n-    fn mk_local(&self, sp: span, mutbl: bool,\n-                ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n \n-        let pat = @ast::pat {\n-            id: self.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_copy,\n-                self.mk_raw_path(sp, ~[ident]),\n-                None),\n-            span: sp,\n-        };\n-        let ty = @ast::Ty { id: self.next_id(), node: ast::ty_infer, span: sp };\n-        let local = @codemap::spanned {\n-            node: ast::local_ {\n-                is_mutbl: mutbl,\n-                ty: ty,\n-                pat: pat,\n-                init: Some(ex),\n-                id: self.next_id(),\n-            },\n-            span: sp,\n+    fn view_use_list(&self, sp: span, vis: ast::visibility,\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item {\n+        let imports = do imports.map |id| {\n+            respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n         };\n-        let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n-        @codemap::spanned { node: ast::stmt_decl(@decl, self.next_id()), span: sp }\n-    }\n-    fn mk_block(&self, span: span,\n-                view_items: ~[@ast::view_item],\n-                stmts: ~[@ast::stmt],\n-                expr: Option<@ast::expr>) -> @ast::expr {\n-        let blk = codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: view_items,\n-                stmts: stmts,\n-                expr: expr,\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: span,\n-        };\n-        self.mk_expr( span, ast::expr_block(blk))\n-    }\n-    fn mk_block_(&self,\n-                 span: span,\n-                 stmts: ~[@ast::stmt])\n-        -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: span,\n-        }\n-    }\n-    fn mk_simple_block(&self,\n-                       span: span,\n-                       expr: @ast::expr)\n-        -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: span,\n-        }\n-    }\n-    fn mk_lambda_(&self,\n-                  span: span,\n-                  fn_decl: ast::fn_decl,\n-                  blk: ast::blk)\n-        -> @ast::expr {\n-        self.mk_expr( span, ast::expr_fn_block(fn_decl, blk))\n-    }\n-    fn mk_lambda(&self,\n-                 span: span,\n-                 fn_decl: ast::fn_decl,\n-                 expr: @ast::expr)\n-        -> @ast::expr {\n-        let blk = self.mk_simple_block( span, expr);\n-        self.mk_lambda_( span, fn_decl, blk)\n-    }\n-    fn mk_lambda_stmts(&self,\n-                       span: span,\n-                       fn_decl: ast::fn_decl,\n-                       stmts: ~[@ast::stmt])\n-        -> @ast::expr {\n-        let blk = self.mk_block( span, ~[], stmts, None);\n-        self.mk_lambda( span, fn_decl, blk)\n-    }\n-    fn mk_lambda_no_args(&self,\n-                         span: span,\n-                         expr: @ast::expr)\n-        -> @ast::expr {\n-        let fn_decl = self.mk_fn_decl(~[], self.mk_ty_infer( span));\n-        self.mk_lambda( span, fn_decl, expr)\n-    }\n-    fn mk_copy(&self, sp: span, e: @ast::expr) -> @ast::expr {\n-        self.mk_expr( sp, ast::expr_copy(e))\n-    }\n-    fn mk_managed(&self, sp: span, e: @ast::expr) -> @ast::expr {\n-        self.mk_expr( sp, ast::expr_unary(ast::box(ast::m_imm), e))\n-    }\n-    fn mk_pat(&self, span: span, pat: ast::pat_) -> @ast::pat {\n-        @ast::pat { id: self.next_id(), node: pat, span: span }\n-    }\n-    fn mk_pat_wild(&self, span: span) -> @ast::pat {\n-        self.mk_pat( span, ast::pat_wild)\n-    }\n-    fn mk_pat_lit(&self,\n-                  span: span,\n-                  expr: @ast::expr) -> @ast::pat {\n-        self.mk_pat( span, ast::pat_lit(expr))\n-    }\n-    fn mk_pat_ident(&self,\n-                    span: span,\n-                    ident: ast::ident) -> @ast::pat {\n-        self.mk_pat_ident_with_binding_mode( span, ident, ast::bind_by_copy)\n-    }\n-\n-    fn mk_pat_ident_with_binding_mode(&self,\n-                                      span: span,\n-                                      ident: ast::ident,\n-                                      bm: ast::binding_mode) -> @ast::pat {\n-        let path = self.mk_raw_path(span, ~[ ident ]);\n-        let pat = ast::pat_ident(bm, path, None);\n-        self.mk_pat( span, pat)\n-    }\n-    fn mk_pat_enum(&self,\n-                   span: span,\n-                   path: @ast::Path,\n-                   subpats: ~[@ast::pat])\n-        -> @ast::pat {\n-        let pat = ast::pat_enum(path, Some(subpats));\n-        self.mk_pat( span, pat)\n-    }\n-    fn mk_pat_struct(&self,\n-                     span: span,\n-                     path: @ast::Path,\n-                     field_pats: ~[ast::field_pat])\n-        -> @ast::pat {\n-        let pat = ast::pat_struct(path, field_pats, false);\n-        self.mk_pat( span, pat)\n-    }\n-    fn mk_bool(&self, span: span, value: bool) -> @ast::expr {\n-        let lit_expr = ast::expr_lit(@codemap::spanned {\n-            node: ast::lit_bool(value),\n-            span: span });\n-        self.mk_expr( span, lit_expr)\n-    }\n-    fn mk_stmt(&self, span: span, expr: @ast::expr) -> @ast::stmt {\n-        let stmt_ = ast::stmt_semi(expr, self.next_id());\n-        @codemap::spanned { node: stmt_, span: span }\n-    }\n-\n-    // XXX: unused self\n-    fn mk_ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n-        ast::mt {\n-            ty: ty,\n-            mutbl: mutbl\n-        }\n-    }\n-\n-    fn mk_ty(&self,\n-             span: span,\n-             ty: ast::ty_) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            span: span,\n-            node: ty\n-        }\n-    }\n-\n-    fn mk_ty_path(&self,\n-                  span: span,\n-                  idents: ~[ ast::ident ])\n-        -> @ast::Ty {\n-        let ty = self.mk_raw_path(span, idents);\n-        self.mk_ty_path_path( span, ty)\n-    }\n \n-    fn mk_ty_path_global(&self,\n-                         span: span,\n-                         idents: ~[ ast::ident ])\n-        -> @ast::Ty {\n-        let ty = self.mk_raw_path_global(span, idents);\n-        self.mk_ty_path_path( span, ty)\n-    }\n-\n-    fn mk_ty_path_path(&self,\n-                       span: span,\n-                       path: @ast::Path)\n-        -> @ast::Ty {\n-        let ty = ast::ty_path(path, self.next_id());\n-        self.mk_ty( span, ty)\n-    }\n-\n-    fn mk_ty_rptr(&self,\n-                  span: span,\n-                  ty: @ast::Ty,\n-                  lifetime: Option<@ast::Lifetime>,\n-                  mutbl: ast::mutability)\n-        -> @ast::Ty {\n-        self.mk_ty( span,\n-              ast::ty_rptr(lifetime, self.mk_ty_mt(ty, mutbl)))\n-    }\n-    fn mk_ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n-        self.mk_ty( span, ast::ty_uniq(self.mk_ty_mt(ty, ast::m_imm)))\n-    }\n-    fn mk_ty_box(&self, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n-        self.mk_ty( span, ast::ty_box(self.mk_ty_mt(ty, mutbl)))\n-    }\n-\n-\n-\n-    fn mk_ty_infer(&self, span: span) -> @ast::Ty {\n-        self.mk_ty( span, ast::ty_infer)\n-    }\n-    fn mk_trait_ref_global(&self,\n-                           span: span,\n-                           idents: ~[ ast::ident ])\n-        -> @ast::trait_ref\n-    {\n-        self.mk_trait_ref_( self.mk_raw_path_global(span, idents))\n-    }\n-    fn mk_trait_ref_(&self, path: @ast::Path) -> @ast::trait_ref {\n-        @ast::trait_ref {\n-            path: path,\n-            ref_id: self.next_id()\n-        }\n-    }\n-    fn mk_simple_ty_path(&self,\n-                         span: span,\n-                         ident: ast::ident)\n-        -> @ast::Ty {\n-        self.mk_ty_path( span, ~[ ident ])\n-    }\n-    fn mk_arg(&self,\n-              span: span,\n-              ident: ast::ident,\n-              ty: @ast::Ty)\n-        -> ast::arg {\n-        let arg_pat = self.mk_pat_ident( span, ident);\n-        ast::arg {\n-            is_mutbl: false,\n-            ty: ty,\n-            pat: arg_pat,\n-            id: self.next_id()\n-        }\n-    }\n-    // XXX unused self\n-    fn mk_fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n-        ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n-    }\n-    fn mk_trait_ty_param_bound_global(&self,\n-                                      span: span,\n-                                      idents: ~[ast::ident])\n-        -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.mk_trait_ref_global( span, idents))\n-    }\n-    fn mk_trait_ty_param_bound_(&self,\n-                                path: @ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.mk_trait_ref_( path))\n-    }\n-    fn mk_ty_param(&self,\n-                   ident: ast::ident,\n-                   bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam {\n-        ast::TyParam { ident: ident, id: self.next_id(), bounds: bounds }\n-    }\n-    fn mk_lifetime(&self,\n-                   span: span,\n-                   ident: ast::ident)\n-        -> ast::Lifetime {\n-        ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n-    }\n-    fn mk_arm(&self,\n-              span: span,\n-              pats: ~[@ast::pat],\n-              expr: @ast::expr)\n-        -> ast::arm {\n-        ast::arm {\n-            pats: pats,\n-            guard: None,\n-            body: self.mk_simple_block( span, expr)\n-        }\n-    }\n-    fn mk_unreachable(&self, span: span) -> @ast::expr {\n-        let loc = self.codemap().lookup_char_pos(span.lo);\n-        self.mk_call_global(\n-            span,\n-            ~[\n-                self.ident_of(\"core\"),\n-                self.ident_of(\"sys\"),\n-                self.ident_of(\"FailWithCause\"),\n-                self.ident_of(\"fail_with\"),\n-            ],\n-            ~[\n-                self.mk_base_str( span, ~\"internal error: entered unreachable code\"),\n-                self.mk_base_str( span, copy loc.file.name),\n-                self.mk_uint( span, loc.line),\n-            ]\n-        )\n-    }\n-    fn mk_unreachable_arm(&self, span: span) -> ast::arm {\n-        self.mk_arm( span, ~[self.mk_pat_wild( span)], self.mk_unreachable( span))\n+        self.view_use(sp, vis,\n+                      ~[@respan(sp,\n+                                ast::view_path_list(self.path(sp, path),\n+                                                    imports,\n+                                                    self.next_id()))])\n     }\n \n-    fn make_self(&self, span: span) -> @ast::expr {\n-        self.mk_expr( span, ast::expr_self)\n+    fn view_use_glob(&self, sp: span,\n+                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item {\n+        self.view_use(sp, vis,\n+                      ~[@respan(sp,\n+                                ast::view_path_glob(self.path(sp, path), self.next_id()))])\n     }\n }\n "}, {"sha": "a046395b6f5c8009047cb7b85eac291d2ee09ece", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -28,7 +28,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n                     for s.each |byte| {\n-                        bytes.push(cx.mk_u8(sp, byte));\n+                        bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }\n \n@@ -37,7 +37,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n                     if v > 0xFF {\n                         cx.span_err(sp, \"Too large u8 literal in bytes!\")\n                     } else {\n-                        bytes.push(cx.mk_u8(sp, v as u8));\n+                        bytes.push(cx.expr_u8(sp, v as u8));\n                     }\n                 }\n \n@@ -48,14 +48,14 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n                     } else if v < 0 {\n                         cx.span_err(sp, \"Negative integer literal in bytes!\")\n                     } else {\n-                        bytes.push(cx.mk_u8(sp, v as u8));\n+                        bytes.push(cx.expr_u8(sp, v as u8));\n                     }\n                 }\n \n                 // char literal, push to vector expression\n                 ast::lit_int(v, ast::ty_char) => {\n                     if (v as char).is_ascii() {\n-                        bytes.push(cx.mk_u8(sp, v as u8));\n+                        bytes.push(cx.expr_u8(sp, v as u8));\n                     } else {\n                         cx.span_err(sp, \"Non-ascii char literal in bytes!\")\n                     }\n@@ -68,6 +68,6 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n         }\n     }\n \n-    let e = cx.mk_slice_vec_e(sp, bytes);\n+    let e = cx.expr_vec_slice(sp, bytes);\n     MRExpr(e)\n }"}, {"sha": "007826a84165d4232a35c756574a9fbf838e9db8", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -11,7 +11,6 @@\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n@@ -80,15 +79,15 @@ fn cs_clone(\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field|\n-        cx.mk_method_call(span, field, clone_ident, ~[]);\n+        cx.expr_method_call(span, field, clone_ident, ~[]);\n \n     match *substr.fields {\n         Struct(ref af) => {\n-            ctor_ident = ~[ substr.type_ident ];\n+            ctor_ident = substr.type_ident;\n             all_fields = af;\n         }\n         EnumMatching(_, variant, ref af) => {\n-            ctor_ident = ~[ variant.node.name ];\n+            ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n         EnumNonMatching(*) => cx.span_bug(span,\n@@ -103,7 +102,7 @@ fn cs_clone(\n         [(None, _, _), .. _] => {\n             // enum-like\n             let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));\n-            cx.mk_call(span, ctor_ident, subcalls)\n+            cx.expr_call_ident(span, ctor_ident, subcalls)\n         },\n         _ => {\n             // struct-like\n@@ -114,16 +113,14 @@ fn cs_clone(\n                                         fmt!(\"unnamed field in normal struct in `deriving(%s)`\",\n                                              name))\n                 };\n-                build::Field { ident: ident, ex: subcall(self_f) }\n+                cx.field_imm(span, ident, subcall(self_f))\n             };\n \n             if fields.is_empty() {\n                 // no fields, so construct like `None`\n-                cx.mk_path(span, ctor_ident)\n+                cx.expr_ident(span, ctor_ident)\n             } else {\n-                cx.mk_struct_e(span,\n-                                   ctor_ident,\n-                                   fields)\n+                cx.expr_struct_ident(span, ctor_ident, fields)\n             }\n         }\n     }"}, {"sha": "11c0a597cebab1169c3104d0fd4e7c3d6f3c041e", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -21,11 +21,11 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _, _| cx.mk_bool(span, false),\n+        cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n     fn cs_ne(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-        cs_or(|cx, span, _, _| cx.mk_bool(span, true),\n+        cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }\n "}, {"sha": "9438e1b0f858d2f1a489d00d3f8da41b4539c583", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use ast::{meta_item, item, expr_if, expr};\n+use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -62,10 +62,7 @@ fn cs_ord(less: bool, equal: bool,\n     } else {\n         cx.ident_of(\"gt\")\n     };\n-    let false_blk_expr = cx.mk_block(span,\n-                                         ~[], ~[],\n-                                         Some(cx.mk_bool(span, false)));\n-    let base = cx.mk_bool(span, equal);\n+    let base = cx.expr_bool(span, equal);\n \n     cs_fold(\n         false, // need foldr,\n@@ -98,19 +95,15 @@ fn cs_ord(less: bool, equal: bool,\n                 cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n             }\n \n-            let cmp = cx.mk_method_call(span,\n-                                            self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n-            let subexpr = cx.mk_simple_block(span, subexpr);\n-            let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n-            let elseif = cx.mk_expr(span, elseif);\n+            let cmp = cx.expr_method_call(span,\n+                                          self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n+            let elseif = cx.expr_if(span, cmp,\n+                                    subexpr, Some(cx.expr_bool(span, false)));\n \n-            let cmp = cx.mk_method_call(span,\n-                                            self_f, binop, other_fs.to_owned());\n-            let true_blk = cx.mk_simple_block(span,\n-                                                  cx.mk_bool(span, true));\n-            let if_ = expr_if(cmp, true_blk, Some(elseif));\n-\n-            cx.mk_expr(span, if_)\n+            let cmp = cx.expr_method_call(span,\n+                                          self_f, binop, other_fs.to_owned());\n+            cx.expr_if(span, cmp,\n+                        cx.expr_bool(span, true), Some(elseif))\n         },\n         base,\n         |cx, span, args, _| {\n@@ -119,7 +112,7 @@ fn cs_ord(less: bool, equal: bool,\n             match args {\n                 [(self_var, _, _),\n                  (other_var, _, _)] =>\n-                    cx.mk_bool(span,\n+                    cx.expr_bool(span,\n                                    if less {\n                                        self_var < other_var\n                                    } else {"}, {"sha": "f1e952eb5f63c98c76bc2ab048d0b748447ec47c", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -21,7 +21,7 @@ pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n                           in_items: ~[@item]) -> ~[@item] {\n \n     fn cs_equals(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _, _| cx.mk_bool(span, false),\n+        cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)\n     }\n "}, {"sha": "e26f4a34304cb19fba162b89c312a963e1459575", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -47,10 +47,11 @@ pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> @expr {\n         Equal => \"Equal\",\n         Greater => \"Greater\"\n     };\n-    cx.mk_path_global(span,\n-                          ~[cx.ident_of(\"core\"),\n-                            cx.ident_of(\"cmp\"),\n-                            cx.ident_of(cnst)])\n+    cx.expr_path(\n+        cx.path_global(span,\n+                       ~[cx.ident_of(\"core\"),\n+                         cx.ident_of(\"cmp\"),\n+                         cx.ident_of(cnst)]))\n }\n \n pub fn cs_cmp(cx: @ExtCtxt, span: span,\n@@ -60,11 +61,11 @@ pub fn cs_cmp(cx: @ExtCtxt, span: span,\n         // foldr (possibly) nests the matches in lexical_ordering better\n         false,\n         |cx, span, old, new| {\n-            cx.mk_call_global(span,\n-                                  ~[cx.ident_of(\"core\"),\n-                                    cx.ident_of(\"cmp\"),\n-                                    cx.ident_of(\"lexical_ordering\")],\n-                                  ~[old, new])\n+            cx.expr_call_global(span,\n+                                ~[cx.ident_of(\"core\"),\n+                                  cx.ident_of(\"cmp\"),\n+                                  cx.ident_of(\"lexical_ordering\")],\n+                                ~[old, new])\n         },\n         ordering_const(cx, span, Equal),\n         |cx, span, list, _| {"}, {"sha": "a8c84e8e361e566804098584a3e7c43d90beb51c", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 73, "deletions": 131, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -16,7 +16,6 @@ encodable.rs for more.\n use ast;\n use ast::*;\n use ext::base::ExtCtxt;\n-use ext::build::Field;\n use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span, spanned};\n@@ -45,34 +44,33 @@ fn create_derived_decodable_impl(\n     generics: &Generics,\n     method: @method\n ) -> @item {\n-    let decoder_ty_param = cx.mk_ty_param(\n+    let decoder_ty_param = cx.typaram(\n         cx.ident_of(\"__D\"),\n         @opt_vec::with(\n-            cx.mk_trait_ty_param_bound_global(\n-                span,\n-                ~[\n-                    cx.ident_of(\"std\"),\n-                    cx.ident_of(\"serialize\"),\n-                    cx.ident_of(\"Decoder\"),\n-                ]\n-            )\n-        )\n-    );\n+            cx.typarambound(\n+                cx.path_global(\n+                    span,\n+                    ~[\n+                        cx.ident_of(\"std\"),\n+                        cx.ident_of(\"serialize\"),\n+                        cx.ident_of(\"Decoder\"),\n+                    ]))));\n \n     // All the type parameters need to bound to the trait.\n     let generic_ty_params = opt_vec::with(decoder_ty_param);\n \n     let methods = [method];\n-    let trait_path = cx.mk_raw_path_global_(\n+    let trait_path = cx.path_all(\n         span,\n+        true,\n         ~[\n             cx.ident_of(\"std\"),\n             cx.ident_of(\"serialize\"),\n             cx.ident_of(\"Decodable\")\n         ],\n         None,\n         ~[\n-            cx.mk_simple_ty_path(span, cx.ident_of(\"__D\"))\n+            cx.ty_ident(span, cx.ident_of(\"__D\"))\n         ]\n     );\n     create_derived_impl(\n@@ -97,14 +95,14 @@ fn create_decode_method(\n     expr: @ast::expr\n ) -> @method {\n     // Create the `e` parameter.\n-    let d_arg_type = cx.mk_ty_rptr(\n+    let d_arg_type = cx.ty_rptr(\n         span,\n-        cx.mk_simple_ty_path(span, cx.ident_of(\"__D\")),\n+        cx.ty_ident(span, cx.ident_of(\"__D\")),\n         None,\n         ast::m_mutbl\n     );\n     let d_ident = cx.ident_of(\"__d\");\n-    let d_arg = cx.mk_arg(span, d_ident, d_arg_type);\n+    let d_arg = cx.arg(span, d_ident, d_arg_type);\n \n     // Create the type of the return value.\n     let output_type = create_self_type_with_params(\n@@ -116,10 +114,10 @@ fn create_decode_method(\n \n     // Create the function declaration.\n     let inputs = ~[d_arg];\n-    let fn_decl = cx.mk_fn_decl(inputs, output_type);\n+    let fn_decl = cx.fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = cx.mk_simple_block(span, expr);\n+    let body_block = cx.blk_expr(expr);\n \n     // Create the method.\n     let explicit_self = spanned { node: sty_static, span: span };\n@@ -144,19 +142,21 @@ fn call_substructure_decode_method(\n     span: span\n ) -> @ast::expr {\n     // Call the substructure method.\n-    cx.mk_call_(\n+    cx.expr_call(\n         span,\n-        cx.mk_path_global(\n-            span,\n-            ~[\n-                cx.ident_of(\"std\"),\n-                cx.ident_of(\"serialize\"),\n-                cx.ident_of(\"Decodable\"),\n-                cx.ident_of(\"decode\"),\n-            ]\n+        cx.expr_path(\n+            cx.path_global(\n+                span,\n+                ~[\n+                    cx.ident_of(\"std\"),\n+                    cx.ident_of(\"serialize\"),\n+                    cx.ident_of(\"Decodable\"),\n+                    cx.ident_of(\"decode\"),\n+                ]\n+            )\n         ),\n         ~[\n-            cx.mk_path(span, ~[cx.ident_of(\"__d\")])\n+            cx.expr_ident(span, cx.ident_of(\"__d\"))\n         ]\n     )\n }\n@@ -218,53 +218,46 @@ fn create_read_struct_field(\n     span: span,\n     idx: uint,\n     ident: ident\n-) -> Field {\n+) -> ast::field {\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n-    let d_arg = cx.mk_arg(\n-                              span,\n-                              cx.ident_of(\"__d\"),\n-                              cx.mk_ty_infer(span));\n+    let d_id = cx.ident_of(\"__d\");\n \n-    let call_expr = cx.mk_method_call(\n+    let call_expr = cx.expr_method_call(\n         span,\n-        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, d_id),\n         cx.ident_of(\"read_struct_field\"),\n         ~[\n-            cx.mk_base_str(span, cx.str_of(ident)),\n-            cx.mk_uint(span, idx),\n-            cx.mk_lambda(\n-                             span,\n-                             cx.mk_fn_decl(~[d_arg],\n-                                           cx.mk_ty_infer(span)),\n-                             decode_expr),\n+            cx.expr_str(span, cx.str_of(ident)),\n+            cx.expr_uint(span, idx),\n+            cx.lambda_expr_1(span, decode_expr, d_id)\n         ]\n     );\n \n-    Field { ident: ident, ex: call_expr }\n+    cx.field_imm(span, ident, call_expr)\n }\n \n fn create_read_struct_arg(\n     cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     ident: ident\n-) -> Field {\n+) -> ast::field {\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n-    let call_expr = cx.mk_method_call(\n+    let call_expr = cx.expr_method_call(\n         span,\n-        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, cx.ident_of(\"__d\")),\n         cx.ident_of(\"read_struct_arg\"),\n         ~[\n-            cx.mk_uint(span, idx),\n-            cx.mk_lambda_no_args(span, decode_expr),\n+            cx.expr_uint(span, idx),\n+            cx.lambda_expr_0(span, decode_expr),\n         ]\n     );\n \n-    Field { ident: ident, ex: call_expr }\n+    cx.field_imm(span, ident, call_expr)\n }\n \n fn expand_deriving_decodable_struct_method(\n@@ -292,30 +285,19 @@ fn expand_deriving_decodable_struct_method(\n         i += 1;\n     }\n \n-    let d_arg = cx.mk_arg(\n-                              span,\n-                              cx.ident_of(\"__d\"),\n-                              cx.mk_ty_infer(span));\n+    let d_id = cx.ident_of(\"__d\");\n \n-    let read_struct_expr = cx.mk_method_call(\n+    let read_struct_expr = cx.expr_method_call(\n         span,\n-        cx.mk_path(\n-            span,\n-            ~[cx.ident_of(\"__d\")]\n-        ),\n+        cx.expr_ident(span, d_id),\n         cx.ident_of(\"read_struct\"),\n         ~[\n-            cx.mk_base_str(span, cx.str_of(type_ident)),\n-            cx.mk_uint(span, fields.len()),\n-            cx.mk_lambda(\n+            cx.expr_str(span, cx.str_of(type_ident)),\n+            cx.expr_uint(span, fields.len()),\n+            cx.lambda_expr_1(\n                 span,\n-                cx.mk_fn_decl(~[d_arg], cx.mk_ty_infer(span)),\n-                cx.mk_struct_e(\n-                    span,\n-                    ~[type_ident],\n-                    fields\n-                )\n-            ),\n+                cx.expr_struct_ident(span, type_ident, fields),\n+                d_id)\n         ]\n     );\n \n@@ -330,14 +312,14 @@ fn create_read_variant_arg(\n     variant: &ast::variant\n ) -> ast::arm {\n     // Create the matching pattern.\n-    let pat = cx.mk_pat_lit(span, cx.mk_uint(span, idx));\n+    let pat = cx.pat_lit(span, cx.expr_uint(span, idx));\n \n     // Feed each argument in this variant to the decode function\n     // as well.\n     let variant_arg_len = variant_arg_count(cx, span, variant);\n \n     let expr = if variant_arg_len == 0 {\n-        cx.mk_path(span, ~[variant.node.name])\n+        cx.expr_ident(span, variant.node.name)\n     } else {\n         // Feed the discriminant to the decode function.\n         let mut args = ~[];\n@@ -346,37 +328,26 @@ fn create_read_variant_arg(\n             // Call the substructure method.\n             let expr = call_substructure_decode_method(cx, span);\n \n-            let d_arg = cx.mk_arg(\n-                                      span,\n-                                      cx.ident_of(\"__d\"),\n-                                      cx.mk_ty_infer(span));\n-            let t_infer = cx.mk_ty_infer(span);\n+            let d_id = cx.ident_of(\"__d\");\n \n-            let call_expr = cx.mk_method_call(\n+            let call_expr = cx.expr_method_call(\n                 span,\n-                cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n+                cx.expr_ident(span, d_id),\n                 cx.ident_of(\"read_enum_variant_arg\"),\n                 ~[\n-                    cx.mk_uint(span, j),\n-                    cx.mk_lambda(\n-                                     span,\n-                                     cx.mk_fn_decl(~[d_arg], t_infer),\n-                                     expr),\n+                    cx.expr_uint(span, j),\n+                    cx.lambda_expr_1(span, expr, d_id),\n                 ]\n             );\n \n             args.push(call_expr);\n         }\n \n-        cx.mk_call(\n-            span,\n-            ~[variant.node.name],\n-            args\n-        )\n+        cx.expr_call_ident(span, variant.node.name, args)\n     };\n \n     // Create the arm.\n-    cx.mk_arm(span, ~[pat], expr)\n+    cx.arm(span, ~[pat], expr)\n }\n \n fn create_read_enum_variant(\n@@ -385,10 +356,10 @@ fn create_read_enum_variant(\n     enum_definition: &enum_def\n ) -> @expr {\n     // Create a vector that contains all the variant names.\n-    let expr_arm_names = cx.mk_base_vec_e(\n+    let expr_arm_names = cx.expr_vec(\n         span,\n         do enum_definition.variants.map |variant| {\n-            cx.mk_base_str(\n+            cx.expr_str(\n                 span,\n                 cx.str_of(variant.node.name)\n             )\n@@ -401,40 +372,18 @@ fn create_read_enum_variant(\n     };\n \n     // Add the impossible case arm.\n-    arms.push(cx.mk_unreachable_arm(span));\n+    arms.push(cx.arm_unreachable(span));\n \n     // Create the read_enum_variant expression.\n-    cx.mk_method_call(\n+    cx.expr_method_call(\n         span,\n-        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, cx.ident_of(\"__d\")),\n         cx.ident_of(\"read_enum_variant\"),\n         ~[\n             expr_arm_names,\n-            cx.mk_lambda(\n-                span,\n-                cx.mk_fn_decl(\n-                    ~[\n-                        cx.mk_arg(\n-                            span,\n-                            cx.ident_of(\"__d\"),\n-                            cx.mk_ty_infer(span)\n-                        ),\n-                        cx.mk_arg(\n-                            span,\n-                            cx.ident_of(\"__i\"),\n-                            cx.mk_ty_infer(span)\n-                        )\n-                    ],\n-                    cx.mk_ty_infer(span)\n-                ),\n-                cx.mk_expr(\n-                    span,\n-                    ast::expr_match(\n-                        cx.mk_path(span, ~[cx.ident_of(\"__i\")]),\n-                        arms\n-                    )\n-                )\n-            )\n+            cx.lambda_expr(span,\n+                           ~[cx.ident_of(\"__d\"), cx.ident_of(\"__i\")],\n+                           cx.expr_match(span, cx.expr_ident(span, cx.ident_of(\"__i\")), arms))\n         ]\n     )\n }\n@@ -452,23 +401,16 @@ fn expand_deriving_decodable_enum_method(\n         enum_definition\n     );\n \n-    let d_arg = cx.mk_arg(\n-                              span,\n-                              cx.ident_of(\"__d\"),\n-                              cx.mk_ty_infer(span));\n+    let d_id = cx.ident_of(\"__d\");\n \n     // Create the read_enum expression\n-    let read_enum_expr = cx.mk_method_call(\n+    let read_enum_expr = cx.expr_method_call(\n         span,\n-        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n+        cx.expr_ident(span, d_id),\n         cx.ident_of(\"read_enum\"),\n         ~[\n-            cx.mk_base_str(span, cx.str_of(type_ident)),\n-            cx.mk_lambda(\n-                             span,\n-                             cx.mk_fn_decl(~[d_arg],\n-                                               cx.mk_ty_infer(span)),\n-                             read_enum_variant_expr),\n+            cx.expr_str(span, cx.str_of(type_ident)),\n+            cx.lambda_expr_1(span, read_enum_variant_expr, d_id)\n         ]\n     );\n "}, {"sha": "72a1745f902beefcd79e38e00fc6f83b65c9f705", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 58, "deletions": 107, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -107,34 +107,33 @@ fn create_derived_encodable_impl(\n     generics: &Generics,\n     method: @method\n ) -> @item {\n-    let encoder_ty_param = cx.mk_ty_param(\n+    let encoder_ty_param = cx.typaram(\n         cx.ident_of(\"__E\"),\n         @opt_vec::with(\n-            cx.mk_trait_ty_param_bound_global(\n-                span,\n-                ~[\n-                    cx.ident_of(\"std\"),\n-                    cx.ident_of(\"serialize\"),\n-                    cx.ident_of(\"Encoder\"),\n-                ]\n-            )\n-        )\n-    );\n+            cx.typarambound(\n+                cx.path_global(\n+                    span,\n+                    ~[\n+                        cx.ident_of(\"std\"),\n+                        cx.ident_of(\"serialize\"),\n+                        cx.ident_of(\"Encoder\"),\n+                    ]))));\n \n     // All the type parameters need to bound to the trait.\n     let generic_ty_params = opt_vec::with(encoder_ty_param);\n \n     let methods = [method];\n-    let trait_path = cx.mk_raw_path_global_(\n+    let trait_path = cx.path_all(\n         span,\n+        true,\n         ~[\n             cx.ident_of(\"std\"),\n             cx.ident_of(\"serialize\"),\n             cx.ident_of(\"Encodable\")\n         ],\n         None,\n         ~[\n-            cx.mk_simple_ty_path(span, cx.ident_of(\"__E\"))\n+            cx.ty_ident(span, cx.ident_of(\"__E\"))\n         ]\n     );\n     create_derived_impl(\n@@ -157,23 +156,23 @@ fn create_encode_method(\n     statements: ~[@stmt]\n ) -> @method {\n     // Create the `e` parameter.\n-    let e_arg_type = cx.mk_ty_rptr(\n+    let e_arg_type = cx.ty_rptr(\n         span,\n-        cx.mk_simple_ty_path(span, cx.ident_of(\"__E\")),\n+        cx.ty_ident(span, cx.ident_of(\"__E\")),\n         None,\n         ast::m_mutbl\n     );\n-    let e_arg = cx.mk_arg(span, cx.ident_of(\"__e\"), e_arg_type);\n+    let e_arg = cx.arg(span, cx.ident_of(\"__e\"), e_arg_type);\n \n     // Create the type of the return value.\n-    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n+    let output_type = cx.ty_nil();\n \n     // Create the function declaration.\n     let inputs = ~[e_arg];\n-    let fn_decl = cx.mk_fn_decl(inputs, output_type);\n+    let fn_decl = cx.fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = cx.mk_block_(span, statements);\n+    let body_block = cx.blk(span, statements, None);\n \n     // Create the method.\n     let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n@@ -200,11 +199,11 @@ fn call_substructure_encode_method(\n ) -> @ast::expr {\n     // Gather up the parameters we want to chain along.\n     let e_ident = cx.ident_of(\"__e\");\n-    let e_expr = cx.mk_path(span, ~[e_ident]);\n+    let e_expr = cx.expr_ident(span, e_ident);\n \n     // Call the substructure method.\n     let encode_ident = cx.ident_of(\"encode\");\n-    cx.mk_method_call(\n+    cx.expr_method_call(\n         span,\n         self_field,\n         encode_ident,\n@@ -275,10 +274,9 @@ fn expand_deriving_encodable_struct_method(\n         match struct_field.node.kind {\n             named_field(ident, _) => {\n                 // Create the accessor for this field.\n-                let self_field = cx.mk_access_(\n-                                                   span,\n-                                                   cx.make_self(span),\n-                                                   ident);\n+                let self_field = cx.expr_field_access(span,\n+                                                      cx.expr_self(span),\n+                                                      ident);\n \n                 // Call the substructure method.\n                 let encode_expr = call_substructure_encode_method(\n@@ -288,29 +286,19 @@ fn expand_deriving_encodable_struct_method(\n                 );\n \n                 let e_ident = cx.ident_of(\"__e\");\n-                let e_arg = cx.mk_arg(\n-                                          span,\n-                                          e_ident,\n-                                          cx.mk_ty_infer(span));\n \n-                let blk_expr = cx.mk_lambda(\n+                let call_expr = cx.expr_method_call(\n                     span,\n-                    cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n-                    encode_expr\n-                );\n-\n-                let call_expr = cx.mk_method_call(\n-                    span,\n-                    cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n+                    cx.expr_ident(span, e_ident),\n                     cx.ident_of(\"emit_struct_field\"),\n                     ~[\n-                        cx.mk_base_str(span, cx.str_of(ident)),\n-                        cx.mk_uint(span, idx),\n-                        blk_expr\n+                        cx.expr_str(span, cx.str_of(ident)),\n+                        cx.expr_uint(span, idx),\n+                        cx.lambda_expr_1(span, encode_expr, e_ident)\n                     ]\n                 );\n \n-                statements.push(cx.mk_stmt(span, call_expr));\n+                statements.push(cx.stmt_expr(call_expr));\n             }\n             unnamed_field => {\n                 cx.span_unimpl(\n@@ -322,30 +310,19 @@ fn expand_deriving_encodable_struct_method(\n         idx += 1;\n     }\n \n-    let e_arg = cx.mk_arg(\n-                              span,\n-                              cx.ident_of(\"__e\"),\n-                              cx.mk_ty_infer(span));\n-\n-    let emit_struct_stmt = cx.mk_method_call(\n+    let e_id = cx.ident_of(\"__e\");\n+    let emit_struct_stmt = cx.expr_method_call(\n         span,\n-        cx.mk_path(\n-            span,\n-            ~[cx.ident_of(\"__e\")]\n-        ),\n+        cx.expr_ident(span, e_id),\n         cx.ident_of(\"emit_struct\"),\n         ~[\n-            cx.mk_base_str(span, cx.str_of(type_ident)),\n-            cx.mk_uint(span, statements.len()),\n-            cx.mk_lambda_stmts(\n-                span,\n-                cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n-                statements\n-            ),\n+            cx.expr_str(span, cx.str_of(type_ident)),\n+            cx.expr_uint(span, statements.len()),\n+            cx.lambda_stmts_1(span, statements, e_id),\n         ]\n     );\n \n-    let statements = ~[cx.mk_stmt(span, emit_struct_stmt)];\n+    let statements = ~[cx.stmt_expr(emit_struct_stmt)];\n \n     // Create the method itself.\n     return create_encode_method(cx, span, statements);\n@@ -373,85 +350,59 @@ fn expand_deriving_encodable_enum_method(\n             let expr = call_substructure_encode_method(cx, span, field);\n \n             let e_ident = cx.ident_of(\"__e\");\n-            let e_arg = cx.mk_arg(\n-                                      span,\n-                                      e_ident,\n-                                      cx.mk_ty_infer(span));\n-\n-            let blk_expr = cx.mk_lambda(\n-                span,\n-                cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n-                expr\n-            );\n-\n-            let call_expr = cx.mk_method_call(\n+            let call_expr = cx.expr_method_call(\n                 span,\n-                cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n+                cx.expr_ident(span, e_ident),\n                 cx.ident_of(\"emit_enum_variant_arg\"),\n                 ~[\n-                    cx.mk_uint(span, j),\n-                    blk_expr,\n+                    cx.expr_uint(span, j),\n+                    cx.lambda_expr_1(span, expr, e_ident),\n                 ]\n             );\n \n-            stmts.push(cx.mk_stmt(span, call_expr));\n+            stmts.push(cx.stmt_expr(call_expr));\n         }\n \n         // Create the pattern body.\n-        let e_arg = cx.mk_arg(\n-                                  span,\n-                                  cx.ident_of(\"__e\"),\n-                                  cx.mk_ty_infer(span));\n-        let call_expr = cx.mk_method_call(\n+        let e_id = cx.ident_of(\"__e\");\n+\n+        let call_expr = cx.expr_method_call(\n             span,\n-            cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n+            cx.expr_ident(span, e_id),\n             cx.ident_of(\"emit_enum_variant\"),\n             ~[\n-                cx.mk_base_str(span, cx.str_of(variant.node.name)),\n-                cx.mk_uint(span, i),\n-                cx.mk_uint(span, variant_arg_len),\n-                cx.mk_lambda_stmts(\n-                    span,\n-                    cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n-                    stmts\n-                )\n+                cx.expr_str(span, cx.str_of(variant.node.name)),\n+                cx.expr_uint(span, i),\n+                cx.expr_uint(span, variant_arg_len),\n+                cx.lambda_stmts_1(span, stmts, e_id)\n             ]\n         );\n \n-        let match_body_block = cx.mk_simple_block(span, call_expr);\n+        //let match_body_block = cx.blk_expr(call_expr);\n \n         // Create the arm.\n-        ast::arm {\n-            pats: ~[pat],\n-            guard: None,\n-            body: match_body_block,\n-        }\n+        cx.arm(span, ~[pat], call_expr) //match_body_block)\n     };\n \n     let e_ident = cx.ident_of(\"__e\");\n-    let e_arg = cx.mk_arg(\n-                              span,\n-                              e_ident,\n-                              cx.mk_ty_infer(span));\n \n     // Create the method body.\n-    let lambda_expr = cx.mk_lambda(\n+    let lambda_expr = cx.lambda_expr_1(\n         span,\n-        cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n-        expand_enum_or_struct_match(cx, span, arms)\n-    );\n+        expand_enum_or_struct_match(cx, span, arms),\n+        e_ident);\n \n-    let call_expr = cx.mk_method_call(\n+    let call_expr = cx.expr_method_call(\n         span,\n-        cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n+        cx.expr_ident(span, e_ident),\n         cx.ident_of(\"emit_enum\"),\n         ~[\n-            cx.mk_base_str(span, cx.str_of(type_ident)),\n+            cx.expr_str(span, cx.str_of(type_ident)),\n             lambda_expr,\n         ]\n     );\n \n-    let stmt = cx.mk_stmt(span, call_expr);\n+    let stmt = cx.stmt_expr(call_expr);\n \n     // Create the method.\n     create_encode_method(cx, span, ~[stmt])"}, {"sha": "b61c78721fee94efe44e27ee2f7edd17af10e537", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -431,7 +431,7 @@ impl<'self> MethodDef<'self> {\n             let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = cx.mk_path(span, ~[ident]);\n+            let arg_expr = cx.expr_ident(span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -440,7 +440,7 @@ impl<'self> MethodDef<'self> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(cx.mk_deref(span, arg_expr))\n+                    self_args.push(cx.expr_deref(span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -461,14 +461,14 @@ impl<'self> MethodDef<'self> {\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = do arg_types.map |&(id, ty)| {\n-            cx.mk_arg(span, id, ty)\n+            cx.arg(span, id, ty)\n         };\n \n         let ret_type = self.get_ret_ty(cx, span, generics, type_ident);\n \n         let method_ident = cx.ident_of(self.name);\n-        let fn_decl = cx.mk_fn_decl(args, ret_type);\n-        let body_block = cx.mk_simple_block(span, body);\n+        let fn_decl = cx.fn_decl(args, ret_type);\n+        let body_block = cx.blk_expr(body);\n \n \n         // Create the method.\n@@ -555,13 +555,8 @@ impl<'self> MethodDef<'self> {\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n         for vec::each2(self_args, patterns) |&arg_expr, &pat| {\n-            let match_arm = ast::arm {\n-                pats: ~[ pat ],\n-                guard: None,\n-                body: cx.mk_simple_block(span, body)\n-            };\n-\n-            body = cx.mk_expr(span, ast::expr_match(arg_expr, ~[match_arm]))\n+            body = cx.expr_match(span, arg_expr,\n+                                 ~[ cx.arm(span, ~[pat], body) ])\n         }\n         body\n     }\n@@ -690,7 +685,7 @@ impl<'self> MethodDef<'self> {\n                     }\n                     let field_tuples =\n                         do vec::map_zip(*self_vec,\n-                                     enum_matching_fields) |&(id, self_f), &other| {\n+                                        enum_matching_fields) |&(id, self_f), &other| {\n                         (id, self_f, other)\n                     };\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n@@ -738,16 +733,16 @@ impl<'self> MethodDef<'self> {\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop();\n-                arms.push(cx.mk_arm(span, ~[ pattern ], arm_expr));\n+                arms.push(cx.arm(span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n                     let wild_expr = self.call_substructure_method(cx, span, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = cx.mk_arm(span,\n-                                                 ~[ cx.mk_pat_wild(span) ],\n-                                                 wild_expr);\n+                    let wild_arm = cx.arm(span,\n+                                          ~[ cx.pat_wild(span) ],\n+                                          wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n@@ -774,14 +769,13 @@ impl<'self> MethodDef<'self> {\n                                                          match_count + 1);\n                     matches_so_far.pop();\n \n-                    let arm = cx.mk_arm(span, ~[ pattern ], arm_expr);\n+                    let arm = cx.arm(span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n                 }\n             }\n \n             // match foo { arm, arm, arm, ... }\n-            cx.mk_expr(span,\n-                           ast::expr_match(self_args[match_count], arms))\n+            cx.expr_match(span, self_args[match_count], arms)\n         }\n     }\n \n@@ -887,10 +881,10 @@ pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = do all_fields.map |&(_, self_field, other_fields)| {\n-                cx.mk_method_call(span,\n-                                      self_field,\n-                                      substructure.method_ident,\n-                                      other_fields)\n+                cx.expr_method_call(span,\n+                                    self_field,\n+                                    substructure.method_ident,\n+                                    other_fields)\n             };\n \n             f(cx, span, called)\n@@ -945,9 +939,9 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n-            cx.mk_binary(span,\n-                             binop,\n-                             old, new)\n+            cx.expr_binary(span,\n+                           binop,\n+                           old, new)\n \n         },\n         base,\n@@ -960,7 +954,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: @ExtCtxt, span: span,\n              substructure: &Substructure) -> @expr {\n-    cs_binop(ast::or, cx.mk_bool(span, false),\n+    cs_binop(ast::or, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n@@ -969,7 +963,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: @ExtCtxt, span: span,\n               substructure: &Substructure) -> @expr {\n-    cs_binop(ast::and, cx.mk_bool(span, true),\n+    cs_binop(ast::and, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }"}, {"sha": "ae321c3e40956f14ed78802f41890c22575b7edc", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -48,7 +48,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n     };\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n-        cx.mk_method_call(span,\n+        cx.expr_method_call(span,\n                               thing_expr, iter_bytes_ident,\n                               copy lsb0_f)\n     };\n@@ -63,7 +63,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n                 Some(copy d)=> d,\n-                None => cx.mk_uint(span, index)\n+                None => cx.expr_uint(span, index)\n             };\n \n             exprs.push(call_iterbytes(discriminant));\n@@ -82,6 +82,6 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n     }\n \n     do vec::foldl(exprs[0], exprs.slice(1, exprs.len())) |prev, me| {\n-        cx.mk_binary(span, and, prev, *me)\n+        cx.expr_binary(span, and, prev, *me)\n     }\n }"}, {"sha": "7da66f88ca9082fc983485cd8b8a6170d45d7f27", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 39, "deletions": 63, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -22,7 +22,7 @@ use ast;\n use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use codemap::{span, respan};\n+use codemap::span;\n use parse::token::special_idents::clownshoes_extensions;\n use opt_vec;\n \n@@ -143,38 +143,15 @@ pub fn expand_deriving(cx: @ExtCtxt,\n     result\n }\n \n-fn create_impl_item(cx: @ExtCtxt, span: span, item: ast::item_) -> @item {\n-    let doc_attr = respan(span,\n-                          ast::lit_str(@~\"Automatically derived.\"));\n-    let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));\n-    let doc_attr = ast::attribute_ {\n-        style: ast::attr_outer,\n-        value: @doc_attr,\n-        is_sugared_doc: false\n-    };\n-    let doc_attr = respan(span, doc_attr);\n-\n-    @ast::item {\n-        ident: clownshoes_extensions,\n-        attrs: ~[doc_attr],\n-        id: cx.next_id(),\n-        node: item,\n-        vis: ast::public,\n-        span: span,\n-    }\n-}\n-\n pub fn create_self_type_with_params(cx: @ExtCtxt,\n-                                span: span,\n-                                type_ident: ident,\n-                                generics: &Generics)\n-                             -> @Ty {\n+                                    span: span,\n+                                    type_ident: ident,\n+                                    generics: &Generics)\n+    -> @Ty {\n     // Create the type parameters on the `self` path.\n     let mut self_ty_params = ~[];\n     for generics.ty_params.each |ty_param| {\n-        let self_ty_param = cx.mk_simple_ty_path(\n-                                                     span,\n-                                                     ty_param.ident);\n+        let self_ty_param = cx.ty_ident(span, ty_param.ident);\n         self_ty_params.push(self_ty_param);\n     }\n \n@@ -186,11 +163,7 @@ pub fn create_self_type_with_params(cx: @ExtCtxt,\n \n \n     // Create the type of `self`.\n-    let self_type = cx.mk_raw_path_(span,\n-                                    ~[ type_ident ],\n-                                        lifetime,\n-                                        self_ty_params);\n-    cx.mk_ty_path_path(span, self_type)\n+    cx.ty_path(cx.path_all(span, false, ~[ type_ident ], lifetime, self_ty_params))\n }\n \n pub fn create_derived_impl(cx: @ExtCtxt,\n@@ -222,31 +195,36 @@ pub fn create_derived_impl(cx: @ExtCtxt,\n     for generics.ty_params.each |ty_param| {\n         // extra restrictions on the generics parameters to the type being derived upon\n         let mut bounds = do bounds_paths.map |&bound_path| {\n-            cx.mk_trait_ty_param_bound_(bound_path)\n+            cx.typarambound(bound_path)\n         };\n \n-        let this_trait_bound =\n-            cx.mk_trait_ty_param_bound_(trait_path);\n+        let this_trait_bound = cx.typarambound(trait_path);\n         bounds.push(this_trait_bound);\n \n-        impl_generics.ty_params.push(cx.mk_ty_param(ty_param.ident, @bounds));\n+        impl_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n     }\n \n     // Create the reference to the trait.\n-    let trait_ref = cx.mk_trait_ref_(trait_path);\n+    let trait_ref = cx.trait_ref(trait_path);\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n                                                  span,\n                                                  type_ident,\n                                                  generics);\n \n-    // Create the impl item.\n-    let impl_item = ast::item_impl(impl_generics,\n-                              Some(trait_ref),\n-                              self_type,\n-                              methods.map(|x| *x));\n-    return create_impl_item(cx, span, impl_item);\n+    let doc_attr = cx.attribute(\n+        span,\n+        cx.meta_name_value(span,\n+                           ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n+    cx.item(\n+        span,\n+        clownshoes_extensions,\n+        ~[doc_attr],\n+        ast::item_impl(impl_generics,\n+                       Some(trait_ref),\n+                       self_type,\n+                       methods.map(|x| *x)))\n }\n \n pub fn create_subpatterns(cx: @ExtCtxt,\n@@ -255,7 +233,7 @@ pub fn create_subpatterns(cx: @ExtCtxt,\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |&path| {\n-        cx.mk_pat(span,\n+        cx.pat(span,\n                       ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n     }\n }\n@@ -274,12 +252,12 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n     -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n     if struct_def.fields.is_empty() {\n         return (\n-            cx.mk_pat_ident_with_binding_mode(\n+            cx.pat_ident_binding_mode(\n                 span, struct_ident, ast::bind_infer),\n             ~[]);\n     }\n \n-    let matching_path = cx.mk_raw_path(span, ~[ struct_ident ]);\n+    let matching_path = cx.path(span, ~[ struct_ident ]);\n \n     let mut paths = ~[], ident_expr = ~[];\n \n@@ -301,10 +279,10 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n                 cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n             }\n         };\n-        let path = cx.mk_raw_path(span,\n-                                      ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n+        let path = cx.path_ident(span,\n+                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n         paths.push(path);\n-        ident_expr.push((opt_id, cx.mk_path_raw(span, path)));\n+        ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n \n     let subpats = create_subpatterns(cx, span, paths, mutbl);\n@@ -318,9 +296,9 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n                 push(ast::field_pat { ident: id.get(), pat: pat })\n             }\n         };\n-        cx.mk_pat_struct(span, matching_path, field_pats)\n+        cx.pat_struct(span, matching_path, field_pats)\n     } else {\n-        cx.mk_pat_enum(span, matching_path, subpats)\n+        cx.pat_enum(span, matching_path, subpats)\n     };\n \n     (pattern, ident_expr)\n@@ -337,24 +315,24 @@ pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref variant_args) => {\n             if variant_args.is_empty() {\n-                return (cx.mk_pat_ident_with_binding_mode(\n+                return (cx.pat_ident_binding_mode(\n                     span, variant_ident, ast::bind_infer), ~[]);\n             }\n \n-            let matching_path = cx.mk_raw_path(span, ~[ variant_ident ]);\n+            let matching_path = cx.path_ident(span, variant_ident);\n \n             let mut paths = ~[], ident_expr = ~[];\n             for uint::range(0, variant_args.len()) |i| {\n-                let path = cx.mk_raw_path(span,\n-                                              ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n+                let path = cx.path_ident(span,\n+                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n \n                 paths.push(path);\n-                ident_expr.push((None, cx.mk_path_raw(span, path)));\n+                ident_expr.push((None, cx.expr_path(path)));\n             }\n \n             let subpats = create_subpatterns(cx, span, paths, mutbl);\n \n-            (cx.mk_pat_enum(span, matching_path, subpats),\n+            (cx.pat_enum(span, matching_path, subpats),\n              ident_expr)\n         }\n         ast::struct_variant_kind(struct_def) => {\n@@ -377,8 +355,6 @@ pub fn expand_enum_or_struct_match(cx: @ExtCtxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n-    let self_expr = cx.make_self(span);\n-    let self_expr = cx.mk_unary(span, ast::deref, self_expr);\n-    let self_match_expr = ast::expr_match(self_expr, arms);\n-    cx.mk_expr(span, self_match_expr)\n+    let self_expr = cx.expr_deref(span, cx.expr_self(span));\n+    cx.expr_match(span, self_expr, arms)\n }"}, {"sha": "16f754727b0789610d94d4523d948d5356cb7d64", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -12,7 +12,7 @@ use ast;\n use ast::{meta_item, item, expr, ident};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build::{AstBuilder, Duplicate, Field};\n+use ext::build::{AstBuilder, Duplicate};\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_rand(cx: @ExtCtxt,\n@@ -59,10 +59,9 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cx.ident_of(\"rand\")\n     ];\n     let rand_call = || {\n-        cx.mk_call_global(\n-                              span,\n-                              copy rand_ident,\n-                              ~[ rng[0].duplicate(cx) ])\n+        cx.expr_call_global(span,\n+                            copy rand_ident,\n+                            ~[ rng[0].duplicate(cx) ])\n     };\n \n     return match *substr.fields {\n@@ -74,41 +73,39 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                 cx.span_fatal(span, \"`Rand` cannot be derived for enums with no variants\");\n             }\n \n-            let variant_count = cx.mk_uint(span, variants.len());\n+            let variant_count = cx.expr_uint(span, variants.len());\n \n             // need to specify the uint-ness of the random number\n-            let u32_ty = cx.mk_ty_path(span, ~[cx.ident_of(\"uint\")]);\n-            let r_ty = cx.mk_ty_path(span, ~[cx.ident_of(\"R\")]);\n-            let rand_name = cx.mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n-            let rand_name = cx.mk_path_raw(span, rand_name);\n+            let u32_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n+            let r_ty = cx.ty_ident(span, cx.ident_of(\"R\"));\n+            let rand_name = cx.path_all(span, false, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n+            let rand_name = cx.expr_path(rand_name);\n \n-            let rv_call = cx.mk_call_(\n-                                          span,\n-                                          rand_name,\n-                                          ~[ rng[0].duplicate(cx) ]);\n+            let rv_call = cx.expr_call(span,\n+                                       rand_name,\n+                                       ~[ rng[0].duplicate(cx) ]);\n \n             // rand() % variants.len()\n-            let rand_variant = cx.mk_binary(span, ast::rem,\n+            let rand_variant = cx.expr_binary(span, ast::rem,\n                                                 rv_call, variant_count);\n \n             let mut arms = do variants.mapi |i, id_sum| {\n-                let i_expr = cx.mk_uint(span, i);\n-                let pat = cx.mk_pat_lit(span, i_expr);\n+                let i_expr = cx.expr_uint(span, i);\n+                let pat = cx.pat_lit(span, i_expr);\n \n                 match *id_sum {\n                     (ident, ref summary) => {\n-                        cx.mk_arm(span,\n-                                      ~[ pat ],\n-                                      rand_thing(cx, span, ident, summary, rand_call))\n+                        cx.arm(span,\n+                               ~[ pat ],\n+                               rand_thing(cx, span, ident, summary, rand_call))\n                     }\n                 }\n             };\n \n             // _ => {} at the end. Should never occur\n-            arms.push(cx.mk_unreachable_arm(span));\n+            arms.push(cx.arm_unreachable(span));\n \n-            cx.mk_expr(span,\n-                           ast::expr_match(rand_variant, arms))\n+            cx.expr_match(span, rand_variant, arms)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n@@ -117,24 +114,20 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                   ctor_ident: ident,\n                   summary: &Either<uint, ~[ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {\n-        let ctor_ident = ~[ ctor_ident ];\n         match *summary {\n             Left(copy count) => {\n                 if count == 0 {\n-                    cx.mk_path(span, ctor_ident)\n+                    cx.expr_ident(span, ctor_ident)\n                 } else {\n                     let exprs = vec::from_fn(count, |_| rand_call());\n-                    cx.mk_call(span, ctor_ident, exprs)\n+                    cx.expr_call_ident(span, ctor_ident, exprs)\n                 }\n             }\n             Right(ref fields) => {\n                 let rand_fields = do fields.map |ident| {\n-                    Field {\n-                        ident: *ident,\n-                        ex: rand_call()\n-                    }\n+                    cx.field_imm(span, *ident, rand_call())\n                 };\n-                cx.mk_struct_e(span, ctor_ident, rand_fields)\n+                cx.expr_struct_ident(span, ctor_ident, rand_fields)\n             }\n         }\n     }"}, {"sha": "89b469575e54bf255b4296ac0fa95e82273153cd", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -42,12 +42,12 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     match substr.self_args {\n         [self_obj] => {\n-            let self_addr = cx.mk_addr_of(span, self_obj);\n-            cx.mk_call_global(span,\n-                                  ~[cx.ident_of(\"core\"),\n-                                    cx.ident_of(\"sys\"),\n-                                    cx.ident_of(\"log_str\")],\n-                                  ~[self_addr])\n+            let self_addr = cx.expr_addr_of(span, self_obj);\n+            cx.expr_call_global(span,\n+                                ~[cx.ident_of(\"core\"),\n+                                  cx.ident_of(\"sys\"),\n+                                  cx.ident_of(\"log_str\")],\n+                                ~[self_addr])\n         }\n         _ => cx.span_bug(span, \"Invalid number of arguments in `deriving(ToStr)`\")\n     }"}, {"sha": "99bc2d87b3095b4ce08493fee9befabaf10bdd43", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -55,21 +55,16 @@ pub impl<'self> Path<'self> {\n \n     fn to_ty(&self, cx: @ExtCtxt, span: span,\n              self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n-        cx.mk_ty_path_path(span,\n-                               self.to_path(cx, span,\n-                                            self_ty, self_generics))\n+        cx.ty_path(self.to_path(cx, span,\n+                                self_ty, self_generics))\n     }\n     fn to_path(&self, cx: @ExtCtxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n-        if self.global {\n-            cx.mk_raw_path_global_(span, idents, lt, tys)\n-        } else {\n-            cx.mk_raw_path_(span, idents, lt, tys)\n-        }\n+        cx.path_all(span, self.global, idents, lt, tys)\n     }\n }\n \n@@ -106,7 +101,7 @@ pub fn nil_ty() -> Ty<'static> {\n \n fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(@cx.mk_lifetime(span, cx.ident_of(*s))),\n+        Some(ref s) => Some(@cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -119,20 +114,20 @@ pub impl<'self> Ty<'self> {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n                 match *ptr {\n                     Owned => {\n-                        cx.mk_ty_uniq(span, raw_ty)\n+                        cx.ty_uniq(span, raw_ty)\n                     }\n                     Managed(mutbl) => {\n-                        cx.mk_ty_box(span, raw_ty, mutbl)\n+                        cx.ty_box(span, raw_ty, mutbl)\n                     }\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n-                        cx.mk_ty_rptr(span, raw_ty, lt, mutbl)\n+                        cx.ty_rptr(span, raw_ty, lt, mutbl)\n                     }\n                 }\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                cx.mk_ty_path_path(span, self.to_path(cx, span, self_ty, self_generics))\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {\n@@ -141,7 +136,7 @@ pub impl<'self> Ty<'self> {\n                     ast::ty_tup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n                 };\n \n-                cx.mk_ty(span, ty)\n+                cx.ty(span, ty)\n             }\n         }\n     }\n@@ -151,16 +146,16 @@ pub impl<'self> Ty<'self> {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n-                    cx.mk_ty_path(span, ~[ ty_param.ident ])\n+                    cx.ty_ident(span, ty_param.ident)\n                 };\n                 let lifetime = if self_generics.lifetimes.is_empty() {\n                     None\n                 } else {\n                     Some(@*self_generics.lifetimes.get(0))\n                 };\n \n-                cx.mk_raw_path_(span, ~[self_ty], lifetime,\n-                                    opt_vec::take_vec(self_params))\n+                cx.path_all(span, false, ~[self_ty], lifetime,\n+                            opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)\n@@ -177,9 +172,9 @@ fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n     let bounds = opt_vec::from(\n         do bounds.map |b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n-            cx.mk_trait_ty_param_bound_(path)\n+            cx.typarambound(path)\n         });\n-    cx.mk_ty_param(cx.ident_of(name), @bounds)\n+    cx.typaram(cx.ident_of(name), @bounds)\n }\n \n fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n@@ -204,7 +199,7 @@ pub impl<'self> LifetimeBounds<'self> {\n     fn to_generics(&self, cx: @ExtCtxt, span: span,\n                    self_ty: ident, self_generics: &Generics) -> Generics {\n         let lifetimes = do self.lifetimes.map |lt| {\n-            cx.mk_lifetime(span, cx.ident_of(*lt))\n+            cx.lifetime(span, cx.ident_of(*lt))\n         };\n         let ty_params = do self.bounds.map |t| {\n             match t {\n@@ -220,7 +215,7 @@ pub impl<'self> LifetimeBounds<'self> {\n \n pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::explicit_self) {\n-    let self_path = cx.make_self(span);\n+    let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))\n@@ -232,12 +227,12 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n                     Owned => ast::sty_uniq(ast::m_imm),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| @cx.mk_lifetime(span,\n-                                                                cx.ident_of(*s)));\n+                        let lt = lt.map(|s| @cx.lifetime(span,\n+                                                         cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });\n-            let self_expr = cx.mk_deref(span, self_path);\n+            let self_expr = cx.expr_deref(span, self_path);\n             (self_expr, self_ty)\n         }\n     }"}, {"sha": "32fbc9139998ee32bb8ed5748311cb3e0ed1d270", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -29,8 +29,8 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      None => cx.mk_base_str(sp, ~\"\"),\n-      Some(ref s) => cx.mk_base_str(sp, copy *s)\n+      None => cx.expr_str(sp, ~\"\"),\n+      Some(ref s) => cx.expr_str(sp, copy *s)\n     };\n     MRExpr(e)\n }"}, {"sha": "55d3d4ee8349dfc820f062a60d8660ca902f2fde", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -18,7 +18,6 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build;\n use ext::build::AstBuilder;\n \n use core::unstable::extfmt::ct::*;\n@@ -56,7 +55,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     }\n     fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n-        cx.mk_path_global(sp, path)\n+        cx.expr_path(cx.path_global(sp, path))\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n@@ -72,8 +71,8 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   FlagSignAlways => \"flag_sign_always\",\n                   FlagAlternate => \"flag_alternate\"\n                 };\n-                tmp_expr = cx.mk_binary(sp, ast::bitor, tmp_expr,\n-                                     make_rt_path_expr(cx, sp, fstr));\n+                tmp_expr = cx.expr_binary(sp, ast::bitor, tmp_expr,\n+                                          make_rt_path_expr(cx, sp, fstr));\n             }\n             return tmp_expr;\n         }\n@@ -83,10 +82,10 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                 return make_rt_path_expr(cx, sp, \"CountImplied\");\n               }\n               CountIs(c) => {\n-                let count_lit = cx.mk_uint(sp, c as uint);\n+                let count_lit = cx.expr_uint(sp, c as uint);\n                 let count_is_path = make_path_vec(cx, \"CountIs\");\n                 let count_is_args = ~[count_lit];\n-                return cx.mk_call_global(sp, count_is_path, count_is_args);\n+                return cx.expr_call_global(sp, count_is_path, count_is_args);\n               }\n               _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n@@ -107,22 +106,14 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             let intr = cx.parse_sess().interner;\n-            cx.mk_global_struct_e(\n+            cx.expr_struct(\n                 sp,\n-                make_path_vec(cx, \"Conv\"),\n+                cx.path_global(sp, make_path_vec(cx, \"Conv\")),\n                 ~[\n-                    build::Field {\n-                        ident: intr.intern(\"flags\"), ex: flags_expr\n-                    },\n-                    build::Field {\n-                        ident: intr.intern(\"width\"), ex: width_expr\n-                    },\n-                    build::Field {\n-                        ident: intr.intern(\"precision\"), ex: precision_expr\n-                    },\n-                    build::Field {\n-                        ident: intr.intern(\"ty\"), ex: ty_expr\n-                    },\n+                    cx.field_imm(sp, intr.intern(\"flags\"), flags_expr),\n+                    cx.field_imm(sp, intr.intern(\"width\"), width_expr),\n+                    cx.field_imm(sp, intr.intern(\"precision\"), precision_expr),\n+                    cx.field_imm(sp, intr.intern(\"ty\"), ty_expr)\n                 ]\n             )\n         }\n@@ -139,7 +130,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg, buf];\n-        cx.mk_call_global(arg.span, path, args)\n+        cx.expr_call_global(arg.span, path, args)\n     }\n \n     fn make_new_conv(cx: @ExtCtxt, sp: span, cnv: &Conv,\n@@ -197,10 +188,10 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n             TyChar => (\"char\", arg),\n             TyBits | TyOctal | TyHex(_) | TyInt(Unsigned) => (\"uint\", arg),\n             TyFloat => (\"float\", arg),\n-            TyPoly => (\"poly\", cx.mk_addr_of(sp, arg))\n+            TyPoly => (\"poly\", cx.expr_addr_of(sp, arg))\n         };\n         return make_conv_call(cx, arg.span, name, cnv, actual_arg,\n-                              cx.mk_mut_addr_of(arg.span, buf));\n+                              cx.expr_mut_addr_of(arg.span, buf));\n     }\n     fn log_conv(c: &Conv) {\n         debug!(\"Building conversion:\");\n@@ -258,7 +249,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n     let ident = cx.parse_sess().interner.intern(\"__fmtbuf\");\n-    let buf = || cx.mk_path(fmt_sp, ~[ident]);\n+    let buf = || cx.expr_ident(fmt_sp, ident);\n     let str_ident = cx.parse_sess().interner.intern(\"str\");\n     let push_ident = cx.parse_sess().interner.intern(\"push_str\");\n     let mut stms = ~[];\n@@ -275,14 +266,14 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                    buffer with it directly. If it's actually the only piece,\n                    then there's no need for it to be mutable */\n                 if i == 0 {\n-                    stms.push(cx.mk_local(fmt_sp, npieces > 1, ident, cx.mk_uniq_str(fmt_sp, s)));\n+                    stms.push(cx.stmt_let(fmt_sp, npieces > 1,\n+                                          ident, cx.expr_str_uniq(fmt_sp, s)));\n                 } else {\n-                    let args = ~[cx.mk_mut_addr_of(fmt_sp, buf()), cx.mk_base_str(fmt_sp, s)];\n-                    let call = cx.mk_call_global(\n-                                              fmt_sp,\n-                                              ~[str_ident, push_ident],\n-                                              args);\n-                    stms.push(cx.mk_stmt(fmt_sp, call));\n+                    let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()), cx.expr_str(fmt_sp, s)];\n+                    let call = cx.expr_call_global(fmt_sp,\n+                                                   ~[str_ident, push_ident],\n+                                                   args);\n+                    stms.push(cx.stmt_expr(call));\n                 }\n             }\n \n@@ -299,12 +290,11 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                 /* If the first portion is a conversion, then the local buffer\n                    must be initialized as an empty string */\n                 if i == 0 {\n-                    stms.push(cx.mk_local(fmt_sp, true, ident,\n-                                          cx.mk_uniq_str(fmt_sp, ~\"\")));\n+                    stms.push(cx.stmt_let(fmt_sp, true, ident,\n+                                          cx.expr_str_uniq(fmt_sp, ~\"\")));\n                 }\n-                stms.push(cx.mk_stmt(fmt_sp,\n-                                     make_new_conv(cx, fmt_sp, conv,\n-                                                   args[n], buf())));\n+                stms.push(cx.stmt_expr(make_new_conv(cx, fmt_sp, conv,\n+                                                     args[n], buf())));\n             }\n         }\n     }\n@@ -316,5 +306,5 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                            nargs, expected_nargs));\n     }\n \n-    cx.mk_block(fmt_sp, ~[], stms, Some(buf()))\n+    cx.expr_blk(cx.blk(fmt_sp, stms, Some(buf())))\n }"}, {"sha": "1f2e3f06a731009f6de2682d8a51161593e0e617", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -16,7 +16,7 @@\n use ast::ident;\n use ast;\n use codemap::span;\n-use ext::quote::rt::*;\n+// use ext::quote::rt::*;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {"}, {"sha": "0482dffe6d44c59c308a95b5231eccb0fd264825", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -53,14 +53,13 @@ impl gen_send for message {\n             assert!(next_state.tys.len() ==\n                 next.generics.ty_params.len());\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n-            let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(*n, *t));\n+            let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(span, *n, *t));\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars_global(&this.generics.ty_params)));\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)));\n             let args_ast = vec::append(\n-                ~[cx.arg(cx.ident_of(\"pipe\"),\n-                              pipe_ty)],\n+                ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n \n             let mut body = ~\"{\\n\";\n@@ -113,15 +112,16 @@ impl gen_send for message {\n             let body = cx.parse_expr(body);\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n-                                                      span)\n-                                               .add_tys(copy next_state.tys));\n+                                          span)\n+                                     .add_tys(copy next_state.tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n \n             let name = cx.ident_of(if try { ~\"try_\" + name } else { name } );\n \n-            cx.item_fn_poly(name,\n+            cx.item_fn_poly(dummy_sp(),\n+                            name,\n                             args_ast,\n                             rty,\n                             self.get_generics(),\n@@ -133,14 +133,15 @@ impl gen_send for message {\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = do vec::map_zip(arg_names, *tys) |n, t| {\n-                    cx.arg(cx.ident_of(*n), *t)\n+                    cx.arg(span, cx.ident_of(*n), *t)\n                 };\n \n                 let args_ast = vec::append(\n-                    ~[cx.arg(cx.ident_of(\"pipe\"),\n+                    ~[cx.arg(span,\n+                             cx.ident_of(\"pipe\"),\n                              cx.ty_path(\n                                  path(~[this.data_name()], span)\n-                                 .add_tys(cx.ty_vars_global(\n+                                 .add_tys(cx.ty_vars(\n                                      &this.generics.ty_params))))],\n                     args_ast);\n \n@@ -172,12 +173,13 @@ impl gen_send for message {\n \n                 let name = if try { ~\"try_\" + name } else { name };\n \n-                cx.item_fn_poly(cx.ident_of(name),\n+                cx.item_fn_poly(dummy_sp(),\n+                                cx.ident_of(name),\n                                 args_ast,\n                                 if try {\n-                                    cx.ty_option(cx.ty_nil_ast_builder())\n+                                    cx.ty_option(cx.ty_nil())\n                                 } else {\n-                                    cx.ty_nil_ast_builder()\n+                                    cx.ty_nil()\n                                 },\n                                 self.get_generics(),\n                                 cx.blk_expr(body))\n@@ -187,7 +189,7 @@ impl gen_send for message {\n \n     fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)))\n     }\n }\n \n@@ -226,15 +228,15 @@ impl to_type_decls for state {\n               None => tys\n             };\n \n-            let v = cx.variant(cx.ident_of(name), span, tys);\n+            let v = cx.variant(span, cx.ident_of(name), tys);\n \n             items_msg.push(v);\n         }\n \n         ~[\n             cx.item_enum_poly(\n-                name,\n                 self.span,\n+                name,\n                 ast::enum_def { variants: items_msg },\n                 cx.strip_bounds(&self.generics)\n             )\n@@ -263,8 +265,8 @@ impl to_type_decls for state {\n         if !self.proto.is_bounded() {\n             items.push(\n                 cx.item_ty_poly(\n-                    self.data_name(),\n                     self.span,\n+                    self.data_name(),\n                     cx.ty_path(\n                         path_global(~[cx.ident_of(\"core\"),\n                                       cx.ident_of(\"pipes\"),\n@@ -274,15 +276,15 @@ impl to_type_decls for state {\n                             path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                  dummy_sp())\n-                            .add_tys(cx.ty_vars_global(\n+                            .add_tys(cx.ty_vars(\n                                 &self.generics.ty_params))))),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n             items.push(\n                 cx.item_ty_poly(\n-                    self.data_name(),\n                     self.span,\n+                    self.data_name(),\n                     cx.ty_path(\n                         path_global(~[cx.ident_of(\"core\"),\n                                       cx.ident_of(\"pipes\"),\n@@ -342,15 +344,18 @@ impl gen_init for protocol {\n     }\n \n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n-        ext_cx.expr_struct(path(~[ext_cx.ident_of(\"__Buffer\")],\n-                                dummy_sp()),\n-                      self.states.map_to_vec(|s| {\n-            let fty = s.to_ty(ext_cx);\n-            ext_cx.field_imm(ext_cx.ident_of(s.name),\n-                             quote_expr!(\n-                                 ::core::pipes::mk_packet::<$fty>()\n-                             ))\n-        }))\n+        ext_cx.expr_struct(\n+            dummy_sp(),\n+            path(~[ext_cx.ident_of(\"__Buffer\")],\n+                 dummy_sp()),\n+            self.states.map_to_vec(|s| {\n+                let fty = s.to_ty(ext_cx);\n+                ext_cx.field_imm(dummy_sp(),\n+                                 ext_cx.ident_of(s.name),\n+                                 quote_expr!(\n+                                     ::core::pipes::mk_packet::<$fty>()\n+                                 ))\n+            }))\n     }\n \n     fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n@@ -392,9 +397,9 @@ impl gen_init for protocol {\n         }\n \n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n-                                      cx.ident_of(\"__Buffer\")],\n-                                    copy self.span)\n-                               .add_tys(cx.ty_vars_global(&params)))\n+                          cx.ident_of(\"__Buffer\")],\n+                        copy self.span)\n+                   .add_tys(cx.ty_vars_global(&params)))\n     }\n \n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n@@ -429,8 +434,8 @@ impl gen_init for protocol {\n         };\n \n         cx.item_struct_poly(\n-            cx.ident_of(\"__Buffer\"),\n             dummy_sp(),\n+            cx.ident_of(\"__Buffer\"),\n             ast::struct_def {\n                 fields: fields,\n                 ctor_id: None\n@@ -454,13 +459,24 @@ impl gen_init for protocol {\n             items.push(self.gen_buffer_type(cx))\n         }\n \n-        items.push(cx.item_mod(cx.ident_of(\"client\"),\n-                               copy self.span,\n+        items.push(cx.item_mod(copy self.span,\n+                               cx.ident_of(\"client\"),\n+                               ~[], ~[],\n                                client_states));\n-        items.push(cx.item_mod(cx.ident_of(\"server\"),\n-                               copy self.span,\n+        items.push(cx.item_mod(copy self.span,\n+                               cx.ident_of(\"server\"),\n+                               ~[], ~[],\n                                server_states));\n \n-        cx.item_mod(cx.ident_of(copy self.name), copy self.span, items)\n+        // XXX: Would be nice if our generated code didn't violate\n+        // Rust coding conventions\n+        let allows = cx.attribute(\n+            copy self.span,\n+            cx.meta_list(copy self.span,\n+                         ~\"allow\",\n+                         ~[cx.meta_word(copy self.span, ~\"non_camel_case_types\"),\n+                           cx.meta_word(copy self.span, ~\"unused_mut\")]));\n+        cx.item_mod(copy self.span, cx.ident_of(copy self.name),\n+                    ~[allows], ~[], items)\n     }\n }"}, {"sha": "1c57d500c221ab36018cd37669ecff9e753417f2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 106, "deletions": 120, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -382,31 +382,31 @@ pub fn expand_quote_expr(cx: @ExtCtxt,\n pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_attrs = cx.mk_uniq_vec_e(sp, ~[]);\n+    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_refutable = cx.mk_lit(sp, ast::lit_bool(true));\n+    let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_param_colons = cx.mk_lit(sp, ast::lit_bool(false));\n+    let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_attrs = cx.mk_uniq_vec_e(sp, ~[]);\n+    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n@@ -421,17 +421,17 @@ fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n-    let e_str = cx.mk_base_str(sp, cx.str_of(ident));\n-    cx.mk_method_call(sp,\n-                      cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                      id_ext(cx, \"ident_of\"),\n-                      ~[e_str])\n+    let e_str = cx.expr_str(sp, cx.str_of(ident));\n+    cx.expr_method_call(sp,\n+                        cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n+                        id_ext(cx, \"ident_of\"),\n+                        ~[e_str])\n }\n \n fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n-    let path = ids_ext(cx, ~[~\"BytePos\"]);\n-    let arg = cx.mk_uint(sp, bpos.to_uint());\n-    cx.mk_call(sp, path, ~[arg])\n+    let path = id_ext(cx, \"BytePos\");\n+    let arg = cx.expr_uint(sp, bpos.to_uint());\n+    cx.expr_call_ident(sp, path, ~[arg])\n }\n \n fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n@@ -447,22 +447,21 @@ fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n         SHL => \"SHL\",\n         SHR => \"SHR\"\n     };\n-    cx.mk_path(sp,\n-                   ids_ext(cx, ~[name.to_owned()]))\n+    cx.expr_ident(sp, id_ext(cx, name))\n }\n \n fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"BINOP\"]),\n-                                  ~[mk_binop(cx, sp, binop)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"BINOP\"),\n+                                      ~[mk_binop(cx, sp, binop)]);\n         }\n         BINOPEQ(binop) => {\n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"BINOPEQ\"]),\n-                                  ~[mk_binop(cx, sp, binop)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"BINOPEQ\"),\n+                                      ~[mk_binop(cx, sp, binop)]);\n         }\n \n         LIT_INT(i, ity) => {\n@@ -474,15 +473,13 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_i32 => ~\"ty_i32\",\n                 ast::ty_i64 => ~\"ty_i64\"\n             };\n-            let e_ity =\n-                cx.mk_path(sp,\n-                               ids_ext(cx, ~[s_ity]));\n+            let e_ity = cx.expr_ident(sp, id_ext(cx, s_ity));\n \n-            let e_i64 = cx.mk_lit(sp, ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"LIT_INT\"]),\n-                                  ~[e_i64, e_ity]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_INT\"),\n+                                      ~[e_i64, e_ity]);\n         }\n \n         LIT_UINT(u, uty) => {\n@@ -493,24 +490,21 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_u32 => ~\"ty_u32\",\n                 ast::ty_u64 => ~\"ty_u64\"\n             };\n-            let e_uty =\n-                cx.mk_path(sp,\n-                               ids_ext(cx, ~[s_uty]));\n+            let e_uty = cx.expr_ident(sp, id_ext(cx, s_uty));\n \n-            let e_u64 = cx.mk_lit(sp, ast::lit_uint(u, ast::ty_u64));\n+            let e_u64 = cx.expr_lit(sp, ast::lit_uint(u, ast::ty_u64));\n \n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"LIT_UINT\"]),\n-                                  ~[e_u64, e_uty]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_UINT\"),\n+                                      ~[e_u64, e_uty]);\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n-            let e_i64 = cx.mk_lit(sp,\n-                                      ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"LIT_INT_UNSUFFIXED\"]),\n-                                  ~[e_i64]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_INT_UNSUFFIXED\"),\n+                                      ~[e_i64]);\n         }\n \n         LIT_FLOAT(fident, fty) => {\n@@ -519,40 +513,38 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_f32 => ~\"ty_f32\",\n                 ast::ty_f64 => ~\"ty_f64\"\n             };\n-            let e_fty =\n-                cx.mk_path(sp,\n-                               ids_ext(cx, ~[s_fty]));\n+            let e_fty = cx.expr_ident(sp, id_ext(cx, s_fty));\n \n             let e_fident = mk_ident(cx, sp, fident);\n \n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"LIT_FLOAT\"]),\n-                                  ~[e_fident, e_fty]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_FLOAT\"),\n+                                      ~[e_fident, e_fty]);\n         }\n \n         LIT_STR(ident) => {\n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"LIT_STR\"]),\n-                                  ~[mk_ident(cx, sp, ident)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIT_STR\"),\n+                                      ~[mk_ident(cx, sp, ident)]);\n         }\n \n         IDENT(ident, b) => {\n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"IDENT\"]),\n-                                  ~[mk_ident(cx, sp, ident),\n-                                    cx.mk_lit(sp, ast::lit_bool(b))]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"IDENT\"),\n+                                      ~[mk_ident(cx, sp, ident),\n+                                        cx.expr_bool(sp, b)]);\n         }\n \n         LIFETIME(ident) => {\n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"LIFETIME\"]),\n-                                  ~[mk_ident(cx, sp, ident)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"LIFETIME\"),\n+                                      ~[mk_ident(cx, sp, ident)]);\n         }\n \n         DOC_COMMENT(ident) => {\n-            return cx.mk_call(sp,\n-                                  ids_ext(cx, ~[~\"DOC_COMMENT\"]),\n-                                  ~[mk_ident(cx, sp, ident)]);\n+            return cx.expr_call_ident(sp,\n+                                      id_ext(cx, \"DOC_COMMENT\"),\n+                                      ~[mk_ident(cx, sp, ident)]);\n         }\n \n         INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),\n@@ -595,8 +587,7 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n         EOF => \"EOF\",\n         _ => fail!()\n     };\n-    cx.mk_path(sp,\n-                   ids_ext(cx, ~[name.to_owned()]))\n+    cx.expr_ident(sp, id_ext(cx, name))\n }\n \n \n@@ -606,19 +597,16 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     match *tt {\n \n         ast::tt_tok(sp, ref tok) => {\n-            let e_sp = cx.mk_path(sp,\n-                                      ids_ext(cx, ~[~\"sp\"]));\n-            let e_tok =\n-                cx.mk_call(sp,\n-                               ids_ext(cx, ~[~\"tt_tok\"]),\n-                               ~[e_sp, mk_token(cx, sp, tok)]);\n+            let e_sp = cx.expr_ident(sp, id_ext(cx, \"sp\"));\n+            let e_tok = cx.expr_call_ident(sp,\n+                                           id_ext(cx, \"tt_tok\"),\n+                                           ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n-                cx.mk_method_call(sp,\n-                                      cx.mk_path(sp, ids_ext(cx, ~[~\"tt\"])),\n-                                      id_ext(cx, \"push\"),\n-                                      ~[e_tok]);\n-            ~[cx.mk_stmt(sp, e_push)]\n-\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n+                                    id_ext(cx, \"push\"),\n+                                    ~[e_tok]);\n+            ~[cx.stmt_expr(e_push)]\n         }\n \n         ast::tt_delim(ref tts) => mk_tts(cx, sp, *tts),\n@@ -629,19 +617,18 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n             // tt.push_all_move($ident.to_tokens(ext_cx))\n \n             let e_to_toks =\n-                cx.mk_method_call(sp,\n-                                      cx.mk_path(sp, ~[ident]),\n-                                      id_ext(cx, \"to_tokens\"),\n-                                      ~[cx.mk_path(sp,\n-                                                       ids_ext(cx, ~[~\"ext_cx\"]))]);\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, ident),\n+                                    id_ext(cx, \"to_tokens\"),\n+                                    ~[cx.expr_ident(sp, id_ext(cx, \"ext_cx\"))]);\n \n             let e_push =\n-                cx.mk_method_call(sp,\n-                                      cx.mk_path(sp, ids_ext(cx, ~[~\"tt\"])),\n-                                      id_ext(cx, \"push_all_move\"),\n-                                      ~[e_to_toks]);\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n+                                    id_ext(cx, \"push_all_move\"),\n+                                    ~[e_to_toks]);\n \n-            ~[cx.mk_stmt(sp, e_push)]\n+            ~[cx.stmt_expr(e_push)]\n         }\n     }\n }\n@@ -677,11 +664,11 @@ fn expand_tts(cx: @ExtCtxt,\n     // We want to emit a block expression that does a sequence of 'use's to\n     // import the runtime module, followed by a tt-building expression.\n \n-    let uses = ~[ cx.mk_glob_use(sp, ast::public,\n-                                 ids_ext(cx, ~[~\"syntax\",\n-                                               ~\"ext\",\n-                                               ~\"quote\",\n-                                               ~\"rt\"])) ];\n+    let uses = ~[ cx.view_use_glob(sp, ast::public,\n+                                   ids_ext(cx, ~[~\"syntax\",\n+                                                 ~\"ext\",\n+                                                 ~\"quote\",\n+                                                 ~\"rt\"])) ];\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n@@ -709,24 +696,24 @@ fn expand_tts(cx: @ExtCtxt,\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n \n-    let e_sp = cx.mk_method_call(sp,\n-                                     cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                                     id_ext(cx, \"call_site\"),\n-                                     ~[]);\n+    let e_sp = cx.expr_method_call(sp,\n+                                   cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n+                                   id_ext(cx, \"call_site\"),\n+                                   ~[]);\n \n-    let stmt_let_sp = cx.mk_local(sp, false,\n-                                      id_ext(cx, \"sp\"),\n-                                      e_sp);\n+    let stmt_let_sp = cx.stmt_let(sp, false,\n+                                  id_ext(cx, \"sp\"),\n+                                  e_sp);\n \n-    let stmt_let_tt = cx.mk_local(sp, true,\n-                                      id_ext(cx, \"tt\"),\n-                                      cx.mk_uniq_vec_e(sp, ~[]));\n+    let stmt_let_tt = cx.stmt_let(sp, true,\n+                                  id_ext(cx, \"tt\"),\n+                                  cx.expr_vec_uniq(sp, ~[]));\n \n-    cx.mk_block(sp, uses,\n-                    ~[stmt_let_sp,\n-                      stmt_let_tt] + mk_tts(cx, sp, tts),\n-                    Some(cx.mk_path(sp,\n-                                        ids_ext(cx, ~[~\"tt\"]))))\n+    cx.expr_blk(\n+        cx.blk_all(sp, uses,\n+                   ~[stmt_let_sp,\n+                     stmt_let_tt] + mk_tts(cx, sp, tts),\n+                   Some(cx.expr_ident(sp, id_ext(cx, \"tt\")))))\n }\n \n fn expand_parse_call(cx: @ExtCtxt,\n@@ -736,27 +723,26 @@ fn expand_parse_call(cx: @ExtCtxt,\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || cx.mk_method_call(\n-        sp, cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let cfg_call = || cx.expr_method_call(\n+        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n         id_ext(cx, \"cfg\"), ~[]);\n \n-    let parse_sess_call = || cx.mk_method_call(\n-        sp, cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let parse_sess_call = || cx.expr_method_call(\n+        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n         id_ext(cx, \"parse_sess\"), ~[]);\n \n     let new_parser_call =\n-        cx.mk_call_global(sp,\n-                              ids_ext(cx, ~[~\"syntax\",\n-                                            ~\"ext\",\n-                                            ~\"quote\",\n-                                            ~\"rt\",\n-                                            ~\"new_parser_from_tts\"]),\n-                              ~[parse_sess_call(),\n-                                cfg_call(),\n-                                tts_expr]);\n-\n-    cx.mk_method_call(sp,\n-                          new_parser_call,\n-                          id_ext(cx, parse_method),\n-                          arg_exprs)\n+        cx.expr_call_global(sp,\n+                            ids_ext(cx, ~[~\"syntax\",\n+                                          ~\"ext\",\n+                                          ~\"quote\",\n+                                          ~\"rt\",\n+                                          ~\"new_parser_from_tts\"]),\n+                            ~[parse_sess_call(),\n+                              cfg_call(),\n+                              tts_expr]);\n+\n+    cx.expr_method_call(sp, new_parser_call,\n+                        id_ext(cx, parse_method),\n+                        arg_exprs)\n }"}, {"sha": "30e6b7cfc65c90b560b8dae364418bc2ba3f1752", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59bec43e34715880f471db7d7c9d57939649d92/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=a59bec43e34715880f471db7d7c9d57939649d92", "patch": "@@ -30,7 +30,7 @@ pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n \n-    base::MRExpr(cx.mk_uint(topmost.call_site, loc.line))\n+    base::MRExpr(cx.expr_uint(topmost.call_site, loc.line))\n }\n \n /* col!(): expands to the current column number */\n@@ -40,7 +40,7 @@ pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(cx.mk_uint(topmost.call_site, loc.col.to_uint()))\n+    base::MRExpr(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n }\n \n /* file!(): expands to the current filename */\n@@ -53,19 +53,19 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let Loc { file: @FileMap { name: filename, _ }, _ } =\n         cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(cx.mk_base_str(topmost.call_site, filename))\n+    base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n-    base::MRExpr(cx.mk_base_str(sp, s))\n+    base::MRExpr(cx.expr_str(sp, s))\n }\n \n pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    base::MRExpr(cx.mk_base_str(sp,\n+    base::MRExpr(cx.expr_str(sp,\n                               str::connect(cx.mod_path().map(\n                                   |x| cx.str_of(*x)), \"::\")))\n }\n@@ -94,7 +94,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n       }\n     }\n \n-    base::MRExpr(cx.mk_base_str(sp, result::unwrap(res)))\n+    base::MRExpr(cx.expr_str(sp, result::unwrap(res)))\n }\n \n pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n@@ -103,9 +103,9 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n         let u8_exprs = vec::map(src, |char| {\n-            cx.mk_u8(sp, *char)\n+            cx.expr_u8(sp, *char)\n         });\n-        base::MRExpr(cx.mk_base_vec_e(sp, u8_exprs))\n+        base::MRExpr(cx.expr_vec(sp, u8_exprs))\n       }\n       result::Err(ref e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal((*e))"}]}