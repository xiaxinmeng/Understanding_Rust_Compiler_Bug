{"sha": "58dfe26045487ad490a8d095823ec69f12edf0f2", "node_id": "C_kwDOAAsO6NoAKDU4ZGZlMjYwNDU0ODdhZDQ5MGE4ZDA5NTgyM2VjNjlmMTJlZGYwZjI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-04-04T09:48:47Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-04-04T09:48:47Z"}, "message": "CandidateSource::XCandidate -> CandidateSource::X", "tree": {"sha": "7eb59c503c006cad6b4e73fe27e6a16dab30006e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eb59c503c006cad6b4e73fe27e6a16dab30006e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58dfe26045487ad490a8d095823ec69f12edf0f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58dfe26045487ad490a8d095823ec69f12edf0f2", "html_url": "https://github.com/rust-lang/rust/commit/58dfe26045487ad490a8d095823ec69f12edf0f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58dfe26045487ad490a8d095823ec69f12edf0f2/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec667fbcfcd29e2b5080f6be04e229356b27e600", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec667fbcfcd29e2b5080f6be04e229356b27e600", "html_url": "https://github.com/rust-lang/rust/commit/ec667fbcfcd29e2b5080f6be04e229356b27e600"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "8137d7029218296500edc721d5101f0b9eabe51c", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58dfe26045487ad490a8d095823ec69f12edf0f2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dfe26045487ad490a8d095823ec69f12edf0f2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=58dfe26045487ad490a8d095823ec69f12edf0f2", "patch": "@@ -8,7 +8,6 @@ pub mod probe;\n mod suggest;\n \n pub use self::suggest::SelfSource;\n-pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n@@ -82,8 +81,8 @@ pub struct NoMatchData<'tcx> {\n // candidate can arise. Used for error reporting only.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n-    ImplSource(DefId),\n-    TraitSource(DefId /* trait id */),\n+    Impl(DefId),\n+    Trait(DefId /* trait id */),\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -237,8 +236,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         match *source {\n                             // Note: this cannot come from an inherent impl,\n                             // because the first probing succeeded.\n-                            ImplSource(def) => self.tcx.trait_id_of_impl(def),\n-                            TraitSource(_) => None,\n+                            CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n+                            CandidateSource::Trait(_) => None,\n                         }\n                     })\n                     .collect(),"}, {"sha": "bc5398ec0d433a07ae55fcf2d23f6636e726b64f", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58dfe26045487ad490a8d095823ec69f12edf0f2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dfe26045487ad490a8d095823ec69f12edf0f2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=58dfe26045487ad490a8d095823ec69f12edf0f2", "patch": "@@ -1,7 +1,7 @@\n use super::suggest;\n+use super::CandidateSource;\n use super::MethodError;\n use super::NoMatchData;\n-use super::{CandidateSource, ImplSource, TraitSource};\n \n use crate::check::FnCtxt;\n use crate::errors::MethodCallOnUnknownType;\n@@ -692,7 +692,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         for item in self.impl_or_trait_item(impl_def_id) {\n             if !self.has_applicable_self(&item) {\n                 // No receiver declared. Not a candidate.\n-                self.record_static_candidate(ImplSource(impl_def_id));\n+                self.record_static_candidate(CandidateSource::Impl(impl_def_id));\n                 continue;\n             }\n \n@@ -846,7 +846,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"elaborate_bounds(bound_trait_ref={:?})\", bound_trait_ref);\n             for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 if !self.has_applicable_self(&item) {\n-                    self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n+                    self.record_static_candidate(CandidateSource::Trait(bound_trait_ref.def_id()));\n                 } else {\n                     mk_cand(self, bound_trait_ref, item);\n                 }\n@@ -944,7 +944,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // Check whether `trait_def_id` defines a method with suitable name.\n                 if !self.has_applicable_self(&item) {\n                     debug!(\"method has inapplicable self\");\n-                    self.record_static_candidate(TraitSource(trait_def_id));\n+                    self.record_static_candidate(CandidateSource::Trait(trait_def_id));\n                     continue;\n                 }\n \n@@ -1016,8 +1016,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             Some(Err(MethodError::Ambiguity(v))) => v\n                 .into_iter()\n                 .map(|source| match source {\n-                    TraitSource(id) => id,\n-                    ImplSource(impl_id) => match tcx.trait_id_of_impl(impl_id) {\n+                    CandidateSource::Trait(id) => id,\n+                    CandidateSource::Impl(impl_id) => match tcx.trait_id_of_impl(impl_id) {\n                         Some(id) => id,\n                         None => span_bug!(span, \"found inherent method when looking at traits\"),\n                     },\n@@ -1415,8 +1415,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn candidate_source(&self, candidate: &Candidate<'tcx>, self_ty: Ty<'tcx>) -> CandidateSource {\n         match candidate.kind {\n-            InherentImplCandidate(..) => ImplSource(candidate.item.container.id()),\n-            ObjectCandidate | WhereClauseCandidate(_) => TraitSource(candidate.item.container.id()),\n+            InherentImplCandidate(..) => CandidateSource::Impl(candidate.item.container.id()),\n+            ObjectCandidate | WhereClauseCandidate(_) => {\n+                CandidateSource::Trait(candidate.item.container.id())\n+            }\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n@@ -1426,9 +1428,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n                         // to that impl.\n-                        ImplSource(impl_data.impl_def_id)\n+                        CandidateSource::Impl(impl_data.impl_def_id)\n                     }\n-                    _ => TraitSource(candidate.item.container.id()),\n+                    _ => CandidateSource::Trait(candidate.item.container.id()),\n                 }\n             }),\n         }"}, {"sha": "c2cb233f5b84cfa142a433db644762a95b1ba418", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/58dfe26045487ad490a8d095823ec69f12edf0f2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dfe26045487ad490a8d095823ec69f12edf0f2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=58dfe26045487ad490a8d095823ec69f12edf0f2", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             for (idx, source) in sources.iter().take(limit).enumerate() {\n                 match *source {\n-                    CandidateSource::ImplSource(impl_did) => {\n+                    CandidateSource::Impl(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n                         let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    CandidateSource::TraitSource(trait_did) => {\n+                    CandidateSource::Trait(trait_did) => {\n                         let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n                         let item_span = self\n                             .tcx\n@@ -515,23 +515,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_sources.len() == 1 {\n-                    let ty_str = if let Some(CandidateSource::ImplSource(impl_did)) =\n-                        static_sources.get(0)\n-                    {\n-                        // When the \"method\" is resolved through dereferencing, we really want the\n-                        // original type that has the associated function for accurate suggestions.\n-                        // (#61411)\n-                        let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                            (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n-                                // Use `actual` as it will have more `substs` filled in.\n-                                self.ty_to_value_string(actual.peel_refs())\n+                    let ty_str =\n+                        if let Some(CandidateSource::Impl(impl_did)) = static_sources.get(0) {\n+                            // When the \"method\" is resolved through dereferencing, we really want the\n+                            // original type that has the associated function for accurate suggestions.\n+                            // (#61411)\n+                            let ty = tcx.at(span).type_of(*impl_did);\n+                            match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                                (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n+                                    // Use `actual` as it will have more `substs` filled in.\n+                                    self.ty_to_value_string(actual.peel_refs())\n+                                }\n+                                _ => self.ty_to_value_string(ty.peel_refs()),\n                             }\n-                            _ => self.ty_to_value_string(ty.peel_refs()),\n-                        }\n-                    } else {\n-                        self.ty_to_value_string(actual.peel_refs())\n-                    };\n+                        } else {\n+                            self.ty_to_value_string(actual.peel_refs())\n+                        };\n                     if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n                             expr.span.to(span),"}]}