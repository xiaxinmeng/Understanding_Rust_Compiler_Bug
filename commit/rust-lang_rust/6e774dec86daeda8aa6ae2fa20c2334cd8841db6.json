{"sha": "6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNzc0ZGVjODZkYWVkYThhYTZhZTJmYTIwYzIzMzRjZDg4NDFkYjY=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-30T21:48:09Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Move all run-pass synchronization primitive tests to sync.rs.", "tree": {"sha": "e3740ed1eb48a69478f0104f1c9b20ba112db9a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3740ed1eb48a69478f0104f1c9b20ba112db9a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "html_url": "https://github.com/rust-lang/rust/commit/6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/comments", "author": null, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "044a068c672cf8edae2cd9d5032995f37f1c3718", "url": "https://api.github.com/repos/rust-lang/rust/commits/044a068c672cf8edae2cd9d5032995f37f1c3718", "html_url": "https://github.com/rust-lang/rust/commit/044a068c672cf8edae2cd9d5032995f37f1c3718"}], "stats": {"total": 454, "additions": 216, "deletions": 238}, "files": [{"sha": "1e976a63453dbd8fd5e376a97203f7dbcc802d92", "filename": "tests/run-pass/concurrency/barrier.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fbarrier.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,27 +0,0 @@\n-// ignore-windows: Concurrency on Windows is not supported yet.\n-\n-//! Check if Rust barriers are working.\n-\n-use std::sync::{Arc, Barrier};\n-use std::thread;\n-\n-\n-/// This test is taken from the Rust documentation.\n-fn main() {\n-    let mut handles = Vec::with_capacity(10);\n-    let barrier = Arc::new(Barrier::new(10));\n-    for _ in 0..10 {\n-        let c = barrier.clone();\n-        // The same messages will be printed together.\n-        // You will NOT see any interleaving.\n-        handles.push(thread::spawn(move|| {\n-            println!(\"before wait\");\n-            c.wait();\n-            println!(\"after wait\");\n-        }));\n-    }\n-    // Wait for other threads to finish.\n-    for handle in handles {\n-        handle.join().unwrap();\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "ab971ee6e8c632d9ffeaac131aef6d8652039d9a", "filename": "tests/run-pass/concurrency/condvar.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fcondvar.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,28 +0,0 @@\n-// ignore-windows: Concurrency on Windows is not supported yet.\n-\n-//! Check if Rust conditional variables are working.\n-\n-use std::sync::{Arc, Condvar, Mutex};\n-use std::thread;\n-\n-/// The test taken from the Rust documentation.\n-fn main() {\n-    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n-    let pair2 = pair.clone();\n-\n-    // Inside of our lock, spawn a new thread, and then wait for it to start.\n-    thread::spawn(move || {\n-        let (lock, cvar) = &*pair2;\n-        let mut started = lock.lock().unwrap();\n-        *started = true;\n-        // We notify the condvar that the value has changed.\n-        cvar.notify_one();\n-    });\n-\n-    // Wait for the thread to start up.\n-    let (lock, cvar) = &*pair;\n-    let mut started = lock.lock().unwrap();\n-    while !*started {\n-        started = cvar.wait(started).unwrap();\n-    }\n-}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/condvar.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fcondvar.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fcondvar.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fcondvar.stderr?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,2 +0,0 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n-"}, {"sha": "f5469712c5f55fe318b1ff1e6294b801f1d08e5d", "filename": "tests/run-pass/concurrency/locks.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flocks.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,75 +0,0 @@\n-// ignore-windows: Concurrency on Windows is not supported yet.\n-\n-use std::sync::{Arc, Mutex, RwLock};\n-use std::thread;\n-\n-fn check_mutex() {\n-    let data = Arc::new(Mutex::new(0));\n-    let mut threads = Vec::new();\n-\n-    for _ in 0..3 {\n-        let data = Arc::clone(&data);\n-        let thread = thread::spawn(move || {\n-            let mut data = data.lock().unwrap();\n-            thread::yield_now();\n-            *data += 1;\n-        });\n-        threads.push(thread);\n-    }\n-\n-    for thread in threads {\n-        thread.join().unwrap();\n-    }\n-\n-    assert!(data.try_lock().is_ok());\n-\n-    let data = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n-    assert_eq!(data, 3);\n-}\n-\n-fn check_rwlock_write() {\n-    let data = Arc::new(RwLock::new(0));\n-    let mut threads = Vec::new();\n-\n-    for _ in 0..3 {\n-        let data = Arc::clone(&data);\n-        let thread = thread::spawn(move || {\n-            let mut data = data.write().unwrap();\n-            thread::yield_now();\n-            *data += 1;\n-        });\n-        threads.push(thread);\n-    }\n-\n-    for thread in threads {\n-        thread.join().unwrap();\n-    }\n-\n-    assert!(data.try_write().is_ok());\n-\n-    let data = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n-    assert_eq!(data, 3);\n-}\n-\n-fn check_rwlock_read_no_deadlock() {\n-    let l1 = Arc::new(RwLock::new(0));\n-    let l2 = Arc::new(RwLock::new(0));\n-\n-    let l1_copy = Arc::clone(&l1);\n-    let l2_copy = Arc::clone(&l2);\n-    let _guard1 = l1.read().unwrap();\n-    let handle = thread::spawn(move || {\n-        let _guard2 = l2_copy.read().unwrap();\n-        thread::yield_now();\n-        let _guard1 = l1_copy.read().unwrap();\n-    });\n-    thread::yield_now();\n-    let _guard2 = l2.read().unwrap();\n-    handle.join().unwrap();\n-}\n-\n-fn main() {\n-    check_mutex();\n-    check_rwlock_write();\n-    check_rwlock_read_no_deadlock();\n-}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/locks.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Flocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Flocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flocks.stderr?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,2 +0,0 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n-"}, {"sha": "3558f5415d071559fa5dddd445564c652631d673", "filename": "tests/run-pass/concurrency/mpsc.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fmpsc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fmpsc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fmpsc.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,56 +0,0 @@\n-// ignore-windows: Concurrency on Windows is not supported yet.\n-\n-//! Check if Rust channels are working.\n-\n-use std::sync::mpsc::{channel, sync_channel};\n-use std::thread;\n-\n-/// The test taken from the Rust documentation.\n-fn simple_send() {\n-    let (tx, rx) = channel();\n-    thread::spawn(move || {\n-        tx.send(10).unwrap();\n-    });\n-    assert_eq!(rx.recv().unwrap(), 10);\n-}\n-\n-/// The test taken from the Rust documentation.\n-fn multiple_send() {\n-    let (tx, rx) = channel();\n-    for i in 0..10 {\n-        let tx = tx.clone();\n-        thread::spawn(move || {\n-            tx.send(i).unwrap();\n-        });\n-    }\n-\n-    let mut sum = 0;\n-    for _ in 0..10 {\n-        let j = rx.recv().unwrap();\n-        assert!(0 <= j && j < 10);\n-        sum += j;\n-    }\n-    assert_eq!(sum, 45);\n-}\n-\n-/// The test taken from the Rust documentation.\n-fn send_on_sync() {\n-    let (sender, receiver) = sync_channel(1);\n-\n-    // this returns immediately\n-    sender.send(1).unwrap();\n-\n-    thread::spawn(move || {\n-        // this will block until the previous message has been received\n-        sender.send(2).unwrap();\n-    });\n-\n-    assert_eq!(receiver.recv().unwrap(), 1);\n-    assert_eq!(receiver.recv().unwrap(), 2);\n-}\n-\n-fn main() {\n-    simple_send();\n-    multiple_send();\n-    send_on_sync();\n-}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/mpsc.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fmpsc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fmpsc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fmpsc.stderr?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,2 +0,0 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n-"}, {"sha": "499ceacfa8c40a8b57f1dba09e02de2c346271f4", "filename": "tests/run-pass/concurrency/once.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fonce.rs?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,44 +0,0 @@\n-// ignore-windows: Concurrency on Windows is not supported yet.\n-\n-//! Check if Rust once statics are working. The test taken from the Rust\n-//! documentation.\n-\n-use std::sync::Once;\n-use std::thread;\n-\n-static mut VAL: usize = 0;\n-static INIT: Once = Once::new();\n-\n-fn get_cached_val() -> usize {\n-    unsafe {\n-        INIT.call_once(|| {\n-            VAL = expensive_computation();\n-        });\n-        VAL\n-    }\n-}\n-\n-fn expensive_computation() -> usize {\n-    let mut i = 1;\n-    let mut c = 1;\n-    while i < 10000 {\n-        i *= c;\n-        c += 1;\n-    }\n-    i\n-}\n-\n-fn main() {\n-    let handles: Vec<_> = (0..10)\n-        .map(|_| {\n-            thread::spawn(|| {\n-                thread::yield_now();\n-                let val = get_cached_val();\n-                assert_eq!(val, 40320);\n-            })\n-        })\n-        .collect();\n-    for handle in handles {\n-        handle.join().unwrap();\n-    }\n-}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/once.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fonce.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044a068c672cf8edae2cd9d5032995f37f1c3718/tests%2Frun-pass%2Fconcurrency%2Fonce.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fonce.stderr?ref=044a068c672cf8edae2cd9d5032995f37f1c3718", "patch": "@@ -1,2 +0,0 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n-"}, {"sha": "b09bfe9e0c8686af50d6c853508e1c2c2ae1ae83", "filename": "tests/run-pass/concurrency/sync.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.rs?ref=6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "patch": "@@ -0,0 +1,216 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::sync::mpsc::{channel, sync_channel};\n+use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};\n+use std::thread;\n+\n+// Check if Rust barriers are working.\n+\n+/// This test is taken from the Rust documentation.\n+fn check_barriers() {\n+    let mut handles = Vec::with_capacity(10);\n+    let barrier = Arc::new(Barrier::new(10));\n+    for _ in 0..10 {\n+        let c = barrier.clone();\n+        // The same messages will be printed together.\n+        // You will NOT see any interleaving.\n+        handles.push(thread::spawn(move || {\n+            println!(\"before wait\");\n+            c.wait();\n+            println!(\"after wait\");\n+        }));\n+    }\n+    // Wait for other threads to finish.\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// Check if Rust conditional variables are working.\n+\n+/// The test taken from the Rust documentation.\n+fn check_conditional_variables() {\n+    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    let pair2 = pair.clone();\n+\n+    // Inside of our lock, spawn a new thread, and then wait for it to start.\n+    thread::spawn(move || {\n+        let (lock, cvar) = &*pair2;\n+        let mut started = lock.lock().unwrap();\n+        *started = true;\n+        // We notify the condvar that the value has changed.\n+        cvar.notify_one();\n+    });\n+\n+    // Wait for the thread to start up.\n+    let (lock, cvar) = &*pair;\n+    let mut started = lock.lock().unwrap();\n+    while !*started {\n+        started = cvar.wait(started).unwrap();\n+    }\n+}\n+\n+// Check if locks are working.\n+\n+fn check_mutex() {\n+    let data = Arc::new(Mutex::new(0));\n+    let mut threads = Vec::new();\n+\n+    for _ in 0..3 {\n+        let data = Arc::clone(&data);\n+        let thread = thread::spawn(move || {\n+            let mut data = data.lock().unwrap();\n+            thread::yield_now();\n+            *data += 1;\n+        });\n+        threads.push(thread);\n+    }\n+\n+    for thread in threads {\n+        thread.join().unwrap();\n+    }\n+\n+    assert!(data.try_lock().is_ok());\n+\n+    let data = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n+    assert_eq!(data, 3);\n+}\n+\n+fn check_rwlock_write() {\n+    let data = Arc::new(RwLock::new(0));\n+    let mut threads = Vec::new();\n+\n+    for _ in 0..3 {\n+        let data = Arc::clone(&data);\n+        let thread = thread::spawn(move || {\n+            let mut data = data.write().unwrap();\n+            thread::yield_now();\n+            *data += 1;\n+        });\n+        threads.push(thread);\n+    }\n+\n+    for thread in threads {\n+        thread.join().unwrap();\n+    }\n+\n+    assert!(data.try_write().is_ok());\n+\n+    let data = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n+    assert_eq!(data, 3);\n+}\n+\n+fn check_rwlock_read_no_deadlock() {\n+    let l1 = Arc::new(RwLock::new(0));\n+    let l2 = Arc::new(RwLock::new(0));\n+\n+    let l1_copy = Arc::clone(&l1);\n+    let l2_copy = Arc::clone(&l2);\n+    let _guard1 = l1.read().unwrap();\n+    let handle = thread::spawn(move || {\n+        let _guard2 = l2_copy.read().unwrap();\n+        thread::yield_now();\n+        let _guard1 = l1_copy.read().unwrap();\n+    });\n+    thread::yield_now();\n+    let _guard2 = l2.read().unwrap();\n+    handle.join().unwrap();\n+}\n+\n+// Check if channels are working.\n+\n+/// The test taken from the Rust documentation.\n+fn simple_send() {\n+    let (tx, rx) = channel();\n+    thread::spawn(move || {\n+        tx.send(10).unwrap();\n+    });\n+    assert_eq!(rx.recv().unwrap(), 10);\n+}\n+\n+/// The test taken from the Rust documentation.\n+fn multiple_send() {\n+    let (tx, rx) = channel();\n+    for i in 0..10 {\n+        let tx = tx.clone();\n+        thread::spawn(move || {\n+            tx.send(i).unwrap();\n+        });\n+    }\n+\n+    let mut sum = 0;\n+    for _ in 0..10 {\n+        let j = rx.recv().unwrap();\n+        assert!(0 <= j && j < 10);\n+        sum += j;\n+    }\n+    assert_eq!(sum, 45);\n+}\n+\n+/// The test taken from the Rust documentation.\n+fn send_on_sync() {\n+    let (sender, receiver) = sync_channel(1);\n+\n+    // this returns immediately\n+    sender.send(1).unwrap();\n+\n+    thread::spawn(move || {\n+        // this will block until the previous message has been received\n+        sender.send(2).unwrap();\n+    });\n+\n+    assert_eq!(receiver.recv().unwrap(), 1);\n+    assert_eq!(receiver.recv().unwrap(), 2);\n+}\n+\n+// Check if Rust once statics are working.\n+\n+static mut VAL: usize = 0;\n+static INIT: Once = Once::new();\n+\n+fn get_cached_val() -> usize {\n+    unsafe {\n+        INIT.call_once(|| {\n+            VAL = expensive_computation();\n+        });\n+        VAL\n+    }\n+}\n+\n+fn expensive_computation() -> usize {\n+    let mut i = 1;\n+    let mut c = 1;\n+    while i < 10000 {\n+        i *= c;\n+        c += 1;\n+    }\n+    i\n+}\n+\n+/// The test taken from the Rust documentation.\n+fn check_once() {\n+    let handles: Vec<_> = (0..10)\n+        .map(|_| {\n+            thread::spawn(|| {\n+                thread::yield_now();\n+                let val = get_cached_val();\n+                assert_eq!(val, 40320);\n+            })\n+        })\n+        .collect();\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    check_barriers();\n+    check_conditional_variables();\n+    check_mutex();\n+    check_rwlock_write();\n+    check_rwlock_read_no_deadlock();\n+    simple_send();\n+    multiple_send();\n+    send_on_sync();\n+    check_once();\n+}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/sync.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/tests%2Frun-pass%2Fconcurrency%2Fsync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/tests%2Frun-pass%2Fconcurrency%2Fsync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.stderr?ref=6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "previous_filename": "tests/run-pass/concurrency/barrier.stderr"}, {"sha": "f2c036a1735eda7186df3a4b5249b8fc8abe5896", "filename": "tests/run-pass/concurrency/sync.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/tests%2Frun-pass%2Fconcurrency%2Fsync.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6e774dec86daeda8aa6ae2fa20c2334cd8841db6/tests%2Frun-pass%2Fconcurrency%2Fsync.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.stdout?ref=6e774dec86daeda8aa6ae2fa20c2334cd8841db6", "previous_filename": "tests/run-pass/concurrency/barrier.stdout"}]}