{"sha": "f75fc857839ff71e89d968bb1952e54a3969fb9f", "node_id": "C_kwDOAAsO6NoAKGY3NWZjODU3ODM5ZmY3MWU4OWQ5NjhiYjE5NTJlNTRhMzk2OWZiOWY", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-11-15T18:24:18Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-11-15T18:24:18Z"}, "message": "Extend `needless_borrowed_reference` to structs and tuples, ignore _", "tree": {"sha": "d04b7715807d1b9d00cfb42bb696fc3d445ddae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04b7715807d1b9d00cfb42bb696fc3d445ddae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f75fc857839ff71e89d968bb1952e54a3969fb9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f75fc857839ff71e89d968bb1952e54a3969fb9f", "html_url": "https://github.com/rust-lang/rust/commit/f75fc857839ff71e89d968bb1952e54a3969fb9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f75fc857839ff71e89d968bb1952e54a3969fb9f/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e059028f0ecdaeb5af2b1b2509bd57f19871c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e059028f0ecdaeb5af2b1b2509bd57f19871c7", "html_url": "https://github.com/rust-lang/rust/commit/38e059028f0ecdaeb5af2b1b2509bd57f19871c7"}], "stats": {"total": 470, "additions": 356, "deletions": 114}, "files": [{"sha": "7add358e8e4eed57a81c2c417a4e98588378aad0", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -250,7 +250,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n         let item_name = item.ident.name.as_str();\n         let item_camel = to_camel_case(item_name);\n         if !item.span.from_expansion() && is_present_in_source(cx, item.span) {\n-            if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n+            if let Some((mod_name, mod_camel)) = self.modules.last() {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {\n                     if mod_name == &item.ident.name {"}, {"sha": "51757592c02d7c81e4f34ae7d83b3d5f1d24adfc", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -62,58 +62,54 @@ impl IntPlusOne {\n     fn check_binop(cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.kind, &rhs.kind) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n-            (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n+            (BinOpKind::Ge, ExprKind::Binary(lhskind, lhslhs, lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n                 }\n             },\n             // case where `... >= y + 1` or `... >= 1 + y`\n-            (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs))\n-                if rhskind.node == BinOpKind::Add =>\n-            {\n+            (BinOpKind::Ge, _, ExprKind::Binary(rhskind, rhslhs, rhsrhs)) if rhskind.node == BinOpKind::Add => {\n                 match (&rhslhs.kind, &rhsrhs.kind) {\n                     // `y + 1` and `1 + y`\n-                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                    (ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n-                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (_, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,\n                 }\n             },\n             // case where `x + 1 <= ...` or `1 + x <= ...`\n-            (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _)\n-                if lhskind.node == BinOpKind::Add =>\n-            {\n+            (BinOpKind::Le, ExprKind::Binary(lhskind, lhslhs, lhsrhs), _) if lhskind.node == BinOpKind::Add => {\n                 match (&lhslhs.kind, &lhsrhs.kind) {\n                     // `1 + x` and `x + 1`\n-                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                    (ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n-                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (_, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n                 }\n             },\n             // case where `... >= y - 1` or `... >= -1 + y`\n-            (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n+            (BinOpKind::Le, _, ExprKind::Binary(rhskind, rhslhs, rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,"}, {"sha": "76b0c21327c870a296583c12e18d33bc294ce021", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -366,8 +366,7 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n-    {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), ExprKind::Lit(lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {"}, {"sha": "498e1408e52a064836a713f5d184f5a5ad1bd64d", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -36,14 +36,14 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessBorrowedRef => [NEEDLESS_BORROWED_REFERENCE]);\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if pat.span.from_expansion() {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, ref_pat: &'tcx Pat<'_>) {\n+        if ref_pat.span.from_expansion() {\n             // OK, simple enough, lints doesn't check in macro.\n             return;\n         }\n \n         // Do not lint patterns that are part of an OR `|` pattern, the binding mode must match in all arms\n-        for (_, node) in cx.tcx.hir().parent_iter(pat.hir_id) {\n+        for (_, node) in cx.tcx.hir().parent_iter(ref_pat.hir_id) {\n             let Node::Pat(pat) = node else { break };\n \n             if matches!(pat.kind, PatKind::Or(_)) {\n@@ -52,20 +52,20 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n         }\n \n         // Only lint immutable refs, because `&mut ref T` may be useful.\n-        let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind else { return };\n+        let PatKind::Ref(pat, Mutability::Not) = ref_pat.kind else { return };\n \n-        match sub_pat.kind {\n+        match pat.kind {\n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n             PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n                 span_lint_and_then(\n                     cx,\n                     NEEDLESS_BORROWED_REFERENCE,\n-                    pat.span,\n+                    ref_pat.span,\n                     \"this pattern takes a reference on something that is being dereferenced\",\n                     |diag| {\n                         // `&ref ident`\n                         //  ^^^^^\n-                        let span = pat.span.until(ident.span);\n+                        let span = ref_pat.span.until(ident.span);\n                         diag.span_suggestion_verbose(\n                             span,\n                             \"try removing the `&ref` part\",\n@@ -84,41 +84,71 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n                 }),\n                 after,\n             ) => {\n-                let mut suggestions = Vec::new();\n-\n-                for element_pat in itertools::chain(before, after) {\n-                    if let PatKind::Binding(BindingAnnotation::REF, _, ident, None) = element_pat.kind {\n-                        // `&[..., ref ident, ...]`\n-                        //         ^^^^\n-                        let span = element_pat.span.until(ident.span);\n-                        suggestions.push((span, String::new()));\n-                    } else {\n-                        return;\n-                    }\n-                }\n+                check_subpatterns(\n+                    cx,\n+                    \"dereferencing a slice pattern where every element takes a reference\",\n+                    ref_pat,\n+                    pat,\n+                    itertools::chain(before, after),\n+                );\n+            },\n+            PatKind::Tuple(subpatterns, _) | PatKind::TupleStruct(_, subpatterns, _) => {\n+                check_subpatterns(\n+                    cx,\n+                    \"dereferencing a tuple pattern where every element takes a reference\",\n+                    ref_pat,\n+                    pat,\n+                    subpatterns,\n+                );\n+            },\n+            PatKind::Struct(_, fields, _) => {\n+                check_subpatterns(\n+                    cx,\n+                    \"dereferencing a struct pattern where every field's pattern takes a reference\",\n+                    ref_pat,\n+                    pat,\n+                    fields.iter().map(|field| field.pat),\n+                );\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n \n-                if !suggestions.is_empty() {\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_BORROWED_REFERENCE,\n-                        pat.span,\n-                        \"dereferencing a slice pattern where every element takes a reference\",\n-                        |diag| {\n-                            // `&[...]`\n-                            //  ^\n-                            let span = pat.span.until(sub_pat.span);\n-                            suggestions.push((span, String::new()));\n+fn check_subpatterns<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    message: &str,\n+    ref_pat: &Pat<'_>,\n+    pat: &Pat<'_>,\n+    subpatterns: impl IntoIterator<Item = &'tcx Pat<'tcx>>,\n+) {\n+    let mut suggestions = Vec::new();\n \n-                            diag.multipart_suggestion(\n-                                \"try removing the `&` and `ref` parts\",\n-                                suggestions,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        },\n-                    );\n-                }\n+    for subpattern in subpatterns {\n+        match subpattern.kind {\n+            PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n+                // `ref ident`\n+                //  ^^^^\n+                let span = subpattern.span.until(ident.span);\n+                suggestions.push((span, String::new()));\n             },\n-            _ => {},\n+            PatKind::Wild => {},\n+            _ => return,\n         }\n     }\n+\n+    if !suggestions.is_empty() {\n+        span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, ref_pat.span, message, |diag| {\n+            // `&pat`\n+            //  ^\n+            let span = ref_pat.span.until(pat.span);\n+            suggestions.push((span, String::new()));\n+\n+            diag.multipart_suggestion(\n+                \"try removing the `&` and `ref` parts\",\n+                suggestions,\n+                Applicability::MachineApplicable,\n+            );\n+        });\n+    }\n }"}, {"sha": "952586527689af042908087005a2c5974580b1ad", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -50,7 +50,7 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext<'_>, span: Span) {\n         },\n         UseTreeKind::Simple(None, ..) | UseTreeKind::Glob => {},\n         UseTreeKind::Nested(ref nested_use_tree) => {\n-            for &(ref use_tree, _) in nested_use_tree {\n+            for (use_tree, _) in nested_use_tree {\n                 check_use_tree(use_tree, cx, span);\n             }\n         },"}, {"sha": "315aea9aa091bc3b4f8f8f3d3e83fb0cc3c83b2f", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -51,8 +51,8 @@ pub enum Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n-            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (Self::Str(ls), Self::Str(rs)) => ls == rs,\n+            (Self::Binary(l), Self::Binary(r)) => l == r,\n             (&Self::Char(l), &Self::Char(r)) => l == r,\n             (&Self::Int(l), &Self::Int(r)) => l == r,\n             (&Self::F64(l), &Self::F64(r)) => {\n@@ -69,8 +69,8 @@ impl PartialEq for Constant {\n             },\n             (&Self::Bool(l), &Self::Bool(r)) => l == r,\n             (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n+            (Self::Repeat(lv, ls), Self::Repeat(rv, rs)) => ls == rs && lv == rv,\n+            (Self::Ref(lb), Self::Ref(rb)) => *lb == *rb,\n             // TODO: are there inter-type equalities?\n             _ => false,\n         }\n@@ -126,17 +126,17 @@ impl Hash for Constant {\n impl Constant {\n     pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (Self::Str(ls), Self::Str(rs)) => Some(ls.cmp(rs)),\n+            (Self::Char(l), Self::Char(r)) => Some(l.cmp(r)),\n             (&Self::Int(l), &Self::Int(r)) => match *cmp_type.kind() {\n                 ty::Int(int_ty) => Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty))),\n                 ty::Uint(_) => Some(l.cmp(&r)),\n                 _ => bug!(\"Not an int type\"),\n             },\n             (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n             (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n-            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) if l.len() == r.len() => match *cmp_type.kind() {\n+            (Self::Bool(l), Self::Bool(r)) => Some(l.cmp(r)),\n+            (Self::Tuple(l), Self::Tuple(r)) if l.len() == r.len() => match *cmp_type.kind() {\n                 ty::Tuple(tys) if tys.len() == l.len() => l\n                     .iter()\n                     .zip(r)\n@@ -146,7 +146,7 @@ impl Constant {\n                     .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n                 _ => None,\n             },\n-            (&Self::Vec(ref l), &Self::Vec(ref r)) => {\n+            (Self::Vec(l), Self::Vec(r)) => {\n                 let (ty::Array(cmp_type, _) | ty::Slice(cmp_type)) = *cmp_type.kind() else {\n                     return None\n                 };\n@@ -155,7 +155,7 @@ impl Constant {\n                     .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n                     .unwrap_or_else(|| Some(l.len().cmp(&r.len())))\n             },\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n+            (Self::Repeat(lv, ls), Self::Repeat(rv, rs)) => {\n                 match Self::partial_cmp(\n                     tcx,\n                     match *cmp_type.kind() {\n@@ -169,7 +169,7 @@ impl Constant {\n                     x => x,\n                 }\n             },\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(\n+            (Self::Ref(lb), Self::Ref(rb)) => Self::partial_cmp(\n                 tcx,\n                 match *cmp_type.kind() {\n                     ty::Ref(_, ty, _) => ty,"}, {"sha": "0231a51adf48286103381c147be10b9d9c457502", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -266,7 +266,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::Let(l), &ExprKind::Let(r)) => {\n                 self.eq_pat(l.pat, r.pat) && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && self.eq_expr(l.init, r.init)\n             },\n-            (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n+            (ExprKind::Lit(l), ExprKind::Lit(r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n@@ -291,8 +291,8 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::Repeat(le, ll), &ExprKind::Repeat(re, rl)) => {\n                 self.eq_expr(le, re) && self.eq_array_length(ll, rl)\n             },\n-            (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (ExprKind::Ret(l), ExprKind::Ret(r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n+            (ExprKind::Path(l), ExprKind::Path(r)) => self.eq_qpath(l, r),\n             (&ExprKind::Struct(l_path, lf, ref lo), &ExprKind::Struct(r_path, rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path)\n                     && both(lo, ro, |l, r| self.eq_expr(l, r))\n@@ -362,7 +362,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 }\n                 eq\n             },\n-            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (PatKind::Path(l), PatKind::Path(r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(l), &PatKind::Lit(r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(l, ls), &PatKind::Tuple(r, rs)) => ls == rs && over(l, r, |l, r| self.eq_pat(l, r)),\n             (&PatKind::Range(ref ls, ref le, li), &PatKind::Range(ref rs, ref re, ri)) => {\n@@ -429,13 +429,11 @@ impl HirEqInterExpr<'_, '_, '_> {\n         match (&left.kind, &right.kind) {\n             (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(lt, ll), &TyKind::Array(rt, rl)) => self.eq_ty(lt, rt) && self.eq_array_length(ll, rl),\n-            (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n-                l_mut.mutbl == r_mut.mutbl && self.eq_ty(l_mut.ty, r_mut.ty)\n-            },\n-            (&TyKind::Rptr(_, ref l_rmut), &TyKind::Rptr(_, ref r_rmut)) => {\n+            (TyKind::Ptr(l_mut), TyKind::Ptr(r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(l_mut.ty, r_mut.ty),\n+            (TyKind::Rptr(_, l_rmut), TyKind::Rptr(_, r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(l_rmut.ty, r_rmut.ty)\n             },\n-            (&TyKind::Path(ref l), &TyKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (TyKind::Path(l), TyKind::Path(r)) => self.eq_qpath(l, r),\n             (&TyKind::Tup(l), &TyKind::Tup(r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyKind::Infer, &TyKind::Infer) => true,\n             _ => false,"}, {"sha": "968f462f8a029d19f2d5dfae483dcc976d403496", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -2,7 +2,12 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::match_like_matches_macro)]\n-#![allow(unreachable_patterns, dead_code, clippy::equatable_if_let)]\n+#![allow(\n+    unreachable_patterns,\n+    dead_code,\n+    clippy::equatable_if_let,\n+    clippy::needless_borrowed_reference\n+)]\n \n fn main() {\n     let x = Some(5);"}, {"sha": "c6b479e27c5aca477a73e782291f7663412669bb", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -2,7 +2,12 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::match_like_matches_macro)]\n-#![allow(unreachable_patterns, dead_code, clippy::equatable_if_let)]\n+#![allow(\n+    unreachable_patterns,\n+    dead_code,\n+    clippy::equatable_if_let,\n+    clippy::needless_borrowed_reference\n+)]\n \n fn main() {\n     let x = Some(5);"}, {"sha": "a4df8008ac239288436dc9919382b7f2304e58d6", "filename": "tests/ui/match_expr_like_matches_macro.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -1,5 +1,5 @@\n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:11:14\n+  --> $DIR/match_expr_like_matches_macro.rs:16:14\n    |\n LL |       let _y = match x {\n    |  ______________^\n@@ -11,7 +11,7 @@ LL | |     };\n    = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:17:14\n+  --> $DIR/match_expr_like_matches_macro.rs:22:14\n    |\n LL |       let _w = match x {\n    |  ______________^\n@@ -21,7 +21,7 @@ LL | |     };\n    | |_____^ help: try this: `matches!(x, Some(_))`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/match_expr_like_matches_macro.rs:23:14\n+  --> $DIR/match_expr_like_matches_macro.rs:28:14\n    |\n LL |       let _z = match x {\n    |  ______________^\n@@ -33,7 +33,7 @@ LL | |     };\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:29:15\n+  --> $DIR/match_expr_like_matches_macro.rs:34:15\n    |\n LL |       let _zz = match x {\n    |  _______________^\n@@ -43,13 +43,13 @@ LL | |     };\n    | |_____^ help: try this: `!matches!(x, Some(r) if r == 0)`\n \n error: if let .. else expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:35:16\n+  --> $DIR/match_expr_like_matches_macro.rs:40:16\n    |\n LL |     let _zzz = if let Some(5) = x { true } else { false };\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:59:20\n+  --> $DIR/match_expr_like_matches_macro.rs:64:20\n    |\n LL |           let _ans = match x {\n    |  ____________________^\n@@ -60,7 +60,7 @@ LL | |         };\n    | |_________^ help: try this: `matches!(x, E::A(_) | E::B(_))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:69:20\n+  --> $DIR/match_expr_like_matches_macro.rs:74:20\n    |\n LL |           let _ans = match x {\n    |  ____________________^\n@@ -73,7 +73,7 @@ LL | |         };\n    | |_________^ help: try this: `matches!(x, E::A(_) | E::B(_))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:79:20\n+  --> $DIR/match_expr_like_matches_macro.rs:84:20\n    |\n LL |           let _ans = match x {\n    |  ____________________^\n@@ -84,7 +84,7 @@ LL | |         };\n    | |_________^ help: try this: `!matches!(x, E::B(_) | E::C)`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:139:18\n+  --> $DIR/match_expr_like_matches_macro.rs:144:18\n    |\n LL |           let _z = match &z {\n    |  __________________^\n@@ -94,7 +94,7 @@ LL | |         };\n    | |_________^ help: try this: `matches!(z, Some(3))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:148:18\n+  --> $DIR/match_expr_like_matches_macro.rs:153:18\n    |\n LL |           let _z = match &z {\n    |  __________________^\n@@ -104,7 +104,7 @@ LL | |         };\n    | |_________^ help: try this: `matches!(&z, Some(3))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:165:21\n+  --> $DIR/match_expr_like_matches_macro.rs:170:21\n    |\n LL |               let _ = match &z {\n    |  _____________________^\n@@ -114,7 +114,7 @@ LL | |             };\n    | |_____________^ help: try this: `matches!(&z, AnEnum::X)`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:179:20\n+  --> $DIR/match_expr_like_matches_macro.rs:184:20\n    |\n LL |           let _res = match &val {\n    |  ____________________^\n@@ -124,7 +124,7 @@ LL | |         };\n    | |_________^ help: try this: `matches!(&val, &Some(ref _a))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:191:20\n+  --> $DIR/match_expr_like_matches_macro.rs:196:20\n    |\n LL |           let _res = match &val {\n    |  ____________________^\n@@ -134,7 +134,7 @@ LL | |         };\n    | |_________^ help: try this: `matches!(&val, &Some(ref _a))`\n \n error: match expression looks like `matches!` macro\n-  --> $DIR/match_expr_like_matches_macro.rs:251:14\n+  --> $DIR/match_expr_like_matches_macro.rs:256:14\n    |\n LL |       let _y = match Some(5) {\n    |  ______________^"}, {"sha": "0c47ceb7b6791594e877bbb0e9388bfec9815bee", "filename": "tests/ui/needless_borrowed_ref.fixed", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fneedless_borrowed_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fneedless_borrowed_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.fixed?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -1,11 +1,32 @@\n // run-rustfix\n \n #![warn(clippy::needless_borrowed_reference)]\n-#![allow(unused, clippy::needless_borrow)]\n+#![allow(\n+    unused,\n+    irrefutable_let_patterns,\n+    non_shorthand_field_patterns,\n+    clippy::needless_borrow\n+)]\n \n fn main() {}\n \n-fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+struct Struct {\n+    a: usize,\n+    b: usize,\n+    c: usize,\n+}\n+\n+struct TupleStruct(u8, u8, u8);\n+\n+fn should_lint(\n+    array: [u8; 4],\n+    slice: &[u8],\n+    slice_of_refs: &[&u8],\n+    vec: Vec<u8>,\n+    tuple: (u8, u8, u8),\n+    tuple_struct: TupleStruct,\n+    s: Struct,\n+) {\n     let mut v = Vec::<String>::new();\n     let _ = v.iter_mut().filter(|a| a.is_empty());\n \n@@ -24,16 +45,54 @@ fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>\n     if let [a, b, ..] = slice {}\n     if let [a, .., b] = slice {}\n     if let [.., a, b] = slice {}\n+\n+    if let [a, _] = slice {}\n+\n+    if let (a, b, c) = &tuple {}\n+    if let (a, _, c) = &tuple {}\n+    if let (a, ..) = &tuple {}\n+\n+    if let TupleStruct(a, ..) = &tuple_struct {}\n+\n+    if let Struct {\n+        a,\n+        b: b,\n+        c: renamed,\n+    } = &s\n+    {}\n+\n+    if let Struct { a, b: _, .. } = &s {}\n }\n \n-fn should_not_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+fn should_not_lint(\n+    array: [u8; 4],\n+    slice: &[u8],\n+    slice_of_refs: &[&u8],\n+    vec: Vec<u8>,\n+    tuple: (u8, u8, u8),\n+    tuple_struct: TupleStruct,\n+    s: Struct,\n+) {\n     if let [ref a] = slice {}\n     if let &[ref a, b] = slice {}\n     if let &[ref a, .., b] = slice {}\n \n+    if let &(ref a, b, ..) = &tuple {}\n+    if let &TupleStruct(ref a, b, ..) = &tuple_struct {}\n+    if let &Struct { ref a, b, .. } = &s {}\n+\n     // must not be removed as variables must be bound consistently across | patterns\n     if let (&[ref a], _) | ([], ref a) = (slice_of_refs, &1u8) {}\n \n+    // the `&`s here technically could be removed, but it'd be noisy and without a `ref` doesn't match\n+    // the lint name\n+    if let &[] = slice {}\n+    if let &[_] = slice {}\n+    if let &[..] = slice {}\n+    if let &(..) = &tuple {}\n+    if let &TupleStruct(..) = &tuple_struct {}\n+    if let &Struct { .. } = &s {}\n+\n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n     if let Some(&mut ref mut v) = thingy2 {\n@@ -59,6 +118,6 @@ fn foo(a: &Animal, b: &Animal) {\n         // lifetime mismatch error if there is no '&ref' before `feature(nll)` stabilization in 1.63\n         (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (),\n         //                  ^    and   ^ should **not** be linted\n-        (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n+        (Animal::Dog(a), &Animal::Dog(_)) => (),\n     }\n }"}, {"sha": "f883bb0c889172c64a4155647e34055bd430fadb", "filename": "tests/ui/needless_borrowed_ref.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.rs?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -1,11 +1,32 @@\n // run-rustfix\n \n #![warn(clippy::needless_borrowed_reference)]\n-#![allow(unused, clippy::needless_borrow)]\n+#![allow(\n+    unused,\n+    irrefutable_let_patterns,\n+    non_shorthand_field_patterns,\n+    clippy::needless_borrow\n+)]\n \n fn main() {}\n \n-fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+struct Struct {\n+    a: usize,\n+    b: usize,\n+    c: usize,\n+}\n+\n+struct TupleStruct(u8, u8, u8);\n+\n+fn should_lint(\n+    array: [u8; 4],\n+    slice: &[u8],\n+    slice_of_refs: &[&u8],\n+    vec: Vec<u8>,\n+    tuple: (u8, u8, u8),\n+    tuple_struct: TupleStruct,\n+    s: Struct,\n+) {\n     let mut v = Vec::<String>::new();\n     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n \n@@ -24,16 +45,54 @@ fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>\n     if let &[ref a, ref b, ..] = slice {}\n     if let &[ref a, .., ref b] = slice {}\n     if let &[.., ref a, ref b] = slice {}\n+\n+    if let &[ref a, _] = slice {}\n+\n+    if let &(ref a, ref b, ref c) = &tuple {}\n+    if let &(ref a, _, ref c) = &tuple {}\n+    if let &(ref a, ..) = &tuple {}\n+\n+    if let &TupleStruct(ref a, ..) = &tuple_struct {}\n+\n+    if let &Struct {\n+        ref a,\n+        b: ref b,\n+        c: ref renamed,\n+    } = &s\n+    {}\n+\n+    if let &Struct { ref a, b: _, .. } = &s {}\n }\n \n-fn should_not_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+fn should_not_lint(\n+    array: [u8; 4],\n+    slice: &[u8],\n+    slice_of_refs: &[&u8],\n+    vec: Vec<u8>,\n+    tuple: (u8, u8, u8),\n+    tuple_struct: TupleStruct,\n+    s: Struct,\n+) {\n     if let [ref a] = slice {}\n     if let &[ref a, b] = slice {}\n     if let &[ref a, .., b] = slice {}\n \n+    if let &(ref a, b, ..) = &tuple {}\n+    if let &TupleStruct(ref a, b, ..) = &tuple_struct {}\n+    if let &Struct { ref a, b, .. } = &s {}\n+\n     // must not be removed as variables must be bound consistently across | patterns\n     if let (&[ref a], _) | ([], ref a) = (slice_of_refs, &1u8) {}\n \n+    // the `&`s here technically could be removed, but it'd be noisy and without a `ref` doesn't match\n+    // the lint name\n+    if let &[] = slice {}\n+    if let &[_] = slice {}\n+    if let &[..] = slice {}\n+    if let &(..) = &tuple {}\n+    if let &TupleStruct(..) = &tuple_struct {}\n+    if let &Struct { .. } = &s {}\n+\n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n     if let Some(&mut ref mut v) = thingy2 {\n@@ -59,6 +118,6 @@ fn foo(a: &Animal, b: &Animal) {\n         // lifetime mismatch error if there is no '&ref' before `feature(nll)` stabilization in 1.63\n         (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (),\n         //                  ^    and   ^ should **not** be linted\n-        (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n+        (Animal::Dog(a), &Animal::Dog(_)) => (),\n     }\n }"}, {"sha": "8d0f0c258dd26cc292d6e3eff5ab58140de082e9", "filename": "tests/ui/needless_borrowed_ref.stderr", "status": "modified", "additions": 102, "deletions": 11, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fneedless_borrowed_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f75fc857839ff71e89d968bb1952e54a3969fb9f/tests%2Fui%2Fneedless_borrowed_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.stderr?ref=f75fc857839ff71e89d968bb1952e54a3969fb9f", "patch": "@@ -1,5 +1,5 @@\n error: this pattern takes a reference on something that is being dereferenced\n-  --> $DIR/needless_borrowed_ref.rs:10:34\n+  --> $DIR/needless_borrowed_ref.rs:31:34\n    |\n LL |     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n    |                                  ^^^^^^\n@@ -12,7 +12,7 @@ LL +     let _ = v.iter_mut().filter(|a| a.is_empty());\n    |\n \n error: this pattern takes a reference on something that is being dereferenced\n-  --> $DIR/needless_borrowed_ref.rs:14:17\n+  --> $DIR/needless_borrowed_ref.rs:35:17\n    |\n LL |     if let Some(&ref v) = thingy {}\n    |                 ^^^^^^\n@@ -24,7 +24,7 @@ LL +     if let Some(v) = thingy {}\n    |\n \n error: this pattern takes a reference on something that is being dereferenced\n-  --> $DIR/needless_borrowed_ref.rs:16:14\n+  --> $DIR/needless_borrowed_ref.rs:37:14\n    |\n LL |     if let &[&ref a, ref b] = slice_of_refs {}\n    |              ^^^^^^\n@@ -36,7 +36,7 @@ LL +     if let &[a, ref b] = slice_of_refs {}\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:18:9\n+  --> $DIR/needless_borrowed_ref.rs:39:9\n    |\n LL |     let &[ref a, ..] = &array;\n    |         ^^^^^^^^^^^^\n@@ -48,7 +48,7 @@ LL +     let [a, ..] = &array;\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:19:9\n+  --> $DIR/needless_borrowed_ref.rs:40:9\n    |\n LL |     let &[ref a, ref b, ..] = &array;\n    |         ^^^^^^^^^^^^^^^^^^^\n@@ -60,7 +60,7 @@ LL +     let [a, b, ..] = &array;\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:21:12\n+  --> $DIR/needless_borrowed_ref.rs:42:12\n    |\n LL |     if let &[ref a, ref b] = slice {}\n    |            ^^^^^^^^^^^^^^^\n@@ -72,7 +72,7 @@ LL +     if let [a, b] = slice {}\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:22:12\n+  --> $DIR/needless_borrowed_ref.rs:43:12\n    |\n LL |     if let &[ref a, ref b] = &vec[..] {}\n    |            ^^^^^^^^^^^^^^^\n@@ -84,7 +84,7 @@ LL +     if let [a, b] = &vec[..] {}\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:24:12\n+  --> $DIR/needless_borrowed_ref.rs:45:12\n    |\n LL |     if let &[ref a, ref b, ..] = slice {}\n    |            ^^^^^^^^^^^^^^^^^^^\n@@ -96,7 +96,7 @@ LL +     if let [a, b, ..] = slice {}\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:25:12\n+  --> $DIR/needless_borrowed_ref.rs:46:12\n    |\n LL |     if let &[ref a, .., ref b] = slice {}\n    |            ^^^^^^^^^^^^^^^^^^^\n@@ -108,7 +108,7 @@ LL +     if let [a, .., b] = slice {}\n    |\n \n error: dereferencing a slice pattern where every element takes a reference\n-  --> $DIR/needless_borrowed_ref.rs:26:12\n+  --> $DIR/needless_borrowed_ref.rs:47:12\n    |\n LL |     if let &[.., ref a, ref b] = slice {}\n    |            ^^^^^^^^^^^^^^^^^^^\n@@ -119,5 +119,96 @@ LL -     if let &[.., ref a, ref b] = slice {}\n LL +     if let [.., a, b] = slice {}\n    |\n \n-error: aborting due to 10 previous errors\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:49:12\n+   |\n+LL |     if let &[ref a, _] = slice {}\n+   |            ^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, _] = slice {}\n+LL +     if let [a, _] = slice {}\n+   |\n+\n+error: dereferencing a tuple pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:51:12\n+   |\n+LL |     if let &(ref a, ref b, ref c) = &tuple {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &(ref a, ref b, ref c) = &tuple {}\n+LL +     if let (a, b, c) = &tuple {}\n+   |\n+\n+error: dereferencing a tuple pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:52:12\n+   |\n+LL |     if let &(ref a, _, ref c) = &tuple {}\n+   |            ^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &(ref a, _, ref c) = &tuple {}\n+LL +     if let (a, _, c) = &tuple {}\n+   |\n+\n+error: dereferencing a tuple pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:53:12\n+   |\n+LL |     if let &(ref a, ..) = &tuple {}\n+   |            ^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &(ref a, ..) = &tuple {}\n+LL +     if let (a, ..) = &tuple {}\n+   |\n+\n+error: dereferencing a tuple pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:55:12\n+   |\n+LL |     if let &TupleStruct(ref a, ..) = &tuple_struct {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &TupleStruct(ref a, ..) = &tuple_struct {}\n+LL +     if let TupleStruct(a, ..) = &tuple_struct {}\n+   |\n+\n+error: dereferencing a struct pattern where every field's pattern takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:57:12\n+   |\n+LL |       if let &Struct {\n+   |  ____________^\n+LL | |         ref a,\n+LL | |         b: ref b,\n+LL | |         c: ref renamed,\n+LL | |     } = &s\n+   | |_____^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL ~     if let Struct {\n+LL ~         a,\n+LL ~         b: b,\n+LL ~         c: renamed,\n+   |\n+\n+error: dereferencing a struct pattern where every field's pattern takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:64:12\n+   |\n+LL |     if let &Struct { ref a, b: _, .. } = &s {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &Struct { ref a, b: _, .. } = &s {}\n+LL +     if let Struct { a, b: _, .. } = &s {}\n+   |\n+\n+error: aborting due to 17 previous errors\n "}]}