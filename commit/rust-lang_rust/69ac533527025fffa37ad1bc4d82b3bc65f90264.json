{"sha": "69ac533527025fffa37ad1bc4d82b3bc65f90264", "node_id": "C_kwDOAAsO6NoAKDY5YWM1MzM1MjcwMjVmZmZhMzdhZDFiYzRkODJiM2JjNjVmOTAyNjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-15T22:32:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-15T22:32:56Z"}, "message": "Auto merge of #86986 - lcnr:simplify_type, r=nikomatsakis,oli-obk\n\nextend `simplify_type`\n\nmight cause a slight perf inprovement and imo more accurately represents what types there are.\n\nconsidering that I was going to use this in #85048 it seems like we might need this in the future anyways :shrug:", "tree": {"sha": "5950e920a18b9f3edd2022e1912ce5760f84c7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5950e920a18b9f3edd2022e1912ce5760f84c7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69ac533527025fffa37ad1bc4d82b3bc65f90264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69ac533527025fffa37ad1bc4d82b3bc65f90264", "html_url": "https://github.com/rust-lang/rust/commit/69ac533527025fffa37ad1bc4d82b3bc65f90264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69ac533527025fffa37ad1bc4d82b3bc65f90264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5ecc157043ba413568b09292001a4a74b541a4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ecc157043ba413568b09292001a4a74b541a4e", "html_url": "https://github.com/rust-lang/rust/commit/c5ecc157043ba413568b09292001a4a74b541a4e"}, {"sha": "00cbacb30966108cd106b8ebfc2053c4e067d214", "url": "https://api.github.com/repos/rust-lang/rust/commits/00cbacb30966108cd106b8ebfc2053c4e067d214", "html_url": "https://github.com/rust-lang/rust/commit/00cbacb30966108cd106b8ebfc2053c4e067d214"}], "stats": {"total": 259, "additions": 179, "deletions": 80}, "files": [{"sha": "3154859bc651b2b2f64283a7fa06c8bccf6174a1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -26,6 +26,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n+use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n@@ -2033,15 +2034,19 @@ impl EncodeContext<'a, 'tcx> {\n \n struct ImplVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    impls: FxHashMap<DefId, Vec<(DefIndex, Option<ty::fast_reject::SimplifiedType>)>>,\n+    impls: FxHashMap<DefId, Vec<(DefIndex, Option<fast_reject::SimplifiedType>)>>,\n }\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id.to_def_id()) {\n-                let simplified_self_ty =\n-                    ty::fast_reject::simplify_type(self.tcx, trait_ref.self_ty(), false);\n+                let simplified_self_ty = fast_reject::simplify_type(\n+                    self.tcx,\n+                    trait_ref.self_ty(),\n+                    SimplifyParams::No,\n+                    StripReferences::No,\n+                );\n \n                 self.impls\n                     .entry(trait_ref.def_id)"}, {"sha": "c4043d9698cc1c4565be8f23060c20aa841ce3a5", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -1,3 +1,4 @@\n+use crate::mir::Mutability;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n@@ -27,9 +28,12 @@ where\n     UintSimplifiedType(ty::UintTy),\n     FloatSimplifiedType(ty::FloatTy),\n     AdtSimplifiedType(D),\n+    ForeignSimplifiedType(D),\n     StrSimplifiedType,\n     ArraySimplifiedType,\n-    PtrSimplifiedType,\n+    SliceSimplifiedType,\n+    RefSimplifiedType(Mutability),\n+    PtrSimplifiedType(Mutability),\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n     /// A trait object, all of whose components are markers\n@@ -42,22 +46,48 @@ where\n     OpaqueSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n-    ForeignSimplifiedType(DefId),\n }\n \n-/// Tries to simplify a type by dropping type parameters, deref'ing away any reference types, etc.\n-/// The idea is to get something simple that we can use to quickly decide if two types could unify\n-/// during method lookup.\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub enum SimplifyParams {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub enum StripReferences {\n+    Yes,\n+    No,\n+}\n+\n+/// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n+///\n+/// The idea is to get something simple that we can use to quickly decide if two types could unify,\n+/// for example during method lookup.\n ///\n-/// If `can_simplify_params` is false, then we will fail to simplify type parameters entirely. This\n-/// is useful when those type parameters would be instantiated with fresh type variables, since\n-/// then we can't say much about whether two types would unify. Put another way,\n-/// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n-/// are to be considered bound.\n+/// A special case here are parameters and projections. Projections can be normalized to\n+/// a different type, meaning that `<T as Trait>::Assoc` and `u8` can be unified, even though\n+/// their outermost layer is different while parameters like `T` of impls are later replaced\n+/// with an inference variable, which then also allows unification with other types.\n+///\n+/// When using `SimplifyParams::Yes`, we still return a simplified type for params and projections\u00b2,\n+/// the reasoning for this can be seen at the places doing this.\n+///\n+/// For diagnostics we strip references with `StripReferences::Yes`. This is currently the best\n+/// way to skip some unhelpful suggestions.\n+///\n+/// \u00b9 meaning that if two outermost layers are different, then the whole types are also different.\n+/// \u00b2 FIXME(@lcnr): this seems like it can actually end up being unsound with the way it's used during\n+///   candidate selection. We do not consider non blanket impls for `<_ as Trait>::Assoc` even\n+///   though `_` can be inferred to a concrete type later at which point a concrete impl\n+///   could actually apply. After experimenting for about an hour I wasn't able to cause any issues\n+///   this way so I am not going to change this until we actually find an issue as I am really\n+///   interesting in getting an actual test for this.\n pub fn simplify_type(\n     tcx: TyCtxt<'_>,\n     ty: Ty<'_>,\n-    can_simplify_params: bool,\n+    can_simplify_params: SimplifyParams,\n+    strip_references: StripReferences,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -67,19 +97,24 @@ pub fn simplify_type(\n         ty::Float(float_type) => Some(FloatSimplifiedType(float_type)),\n         ty::Adt(def, _) => Some(AdtSimplifiedType(def.did)),\n         ty::Str => Some(StrSimplifiedType),\n-        ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n-        ty::RawPtr(_) => Some(PtrSimplifiedType),\n+        ty::Array(..) => Some(ArraySimplifiedType),\n+        ty::Slice(..) => Some(SliceSimplifiedType),\n+        ty::RawPtr(ptr) => Some(PtrSimplifiedType(ptr.mutbl)),\n         ty::Dynamic(ref trait_info, ..) => match trait_info.principal_def_id() {\n             Some(principal_def_id) if !tcx.trait_is_auto(principal_def_id) => {\n                 Some(TraitSimplifiedType(principal_def_id))\n             }\n             _ => Some(MarkerTraitObjectSimplifiedType),\n         },\n-        ty::Ref(_, ty, _) => {\n-            // since we introduce auto-refs during method lookup, we\n-            // just treat &T and T as equivalent from the point of\n-            // view of possibly unifying\n-            simplify_type(tcx, ty, can_simplify_params)\n+        ty::Ref(_, ty, mutbl) => {\n+            if strip_references == StripReferences::Yes {\n+                // For diagnostics, when recommending similar impls we want to\n+                // recommend impls even when there is a reference mismatch,\n+                // so we treat &T and T equivalently in that case.\n+                simplify_type(tcx, ty, can_simplify_params, strip_references)\n+            } else {\n+                Some(RefSimplifiedType(mutbl))\n+            }\n         }\n         ty::FnDef(def_id, _) | ty::Closure(def_id, _) => Some(ClosureSimplifiedType(def_id)),\n         ty::Generator(def_id, _, _) => Some(GeneratorSimplifiedType(def_id)),\n@@ -90,7 +125,7 @@ pub fn simplify_type(\n         ty::Tuple(ref tys) => Some(TupleSimplifiedType(tys.len())),\n         ty::FnPtr(ref f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n         ty::Projection(_) | ty::Param(_) => {\n-            if can_simplify_params {\n+            if can_simplify_params == SimplifyParams::Yes {\n                 // In normalized types, projections don't unify with\n                 // anything. when lazy normalization happens, this\n                 // will change. It would still be nice to have a way\n@@ -120,9 +155,12 @@ impl<D: Copy + Debug + Ord + Eq> SimplifiedTypeGen<D> {\n             UintSimplifiedType(t) => UintSimplifiedType(t),\n             FloatSimplifiedType(t) => FloatSimplifiedType(t),\n             AdtSimplifiedType(d) => AdtSimplifiedType(map(d)),\n+            ForeignSimplifiedType(d) => ForeignSimplifiedType(map(d)),\n             StrSimplifiedType => StrSimplifiedType,\n             ArraySimplifiedType => ArraySimplifiedType,\n-            PtrSimplifiedType => PtrSimplifiedType,\n+            SliceSimplifiedType => SliceSimplifiedType,\n+            RefSimplifiedType(m) => RefSimplifiedType(m),\n+            PtrSimplifiedType(m) => PtrSimplifiedType(m),\n             NeverSimplifiedType => NeverSimplifiedType,\n             MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n             TupleSimplifiedType(n) => TupleSimplifiedType(n),\n@@ -133,7 +171,6 @@ impl<D: Copy + Debug + Ord + Eq> SimplifiedTypeGen<D> {\n             OpaqueSimplifiedType(d) => OpaqueSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n             ParameterSimplifiedType => ParameterSimplifiedType,\n-            ForeignSimplifiedType(d) => ForeignSimplifiedType(d),\n         }\n     }\n }\n@@ -149,12 +186,13 @@ where\n             | CharSimplifiedType\n             | StrSimplifiedType\n             | ArraySimplifiedType\n-            | PtrSimplifiedType\n+            | SliceSimplifiedType\n             | NeverSimplifiedType\n             | ParameterSimplifiedType\n             | MarkerTraitObjectSimplifiedType => {\n                 // nothing to do\n             }\n+            RefSimplifiedType(m) | PtrSimplifiedType(m) => m.hash_stable(hcx, hasher),\n             IntSimplifiedType(t) => t.hash_stable(hcx, hasher),\n             UintSimplifiedType(t) => t.hash_stable(hcx, hasher),\n             FloatSimplifiedType(t) => t.hash_stable(hcx, hasher),"}, {"sha": "cbb88def7e27dbd326a28ee891f5dbeab710cfc8", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject;\n+use crate::ty::fast_reject::{self, SimplifyParams, StripReferences};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -146,6 +146,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n         mut f: F,\n     ) -> Option<T> {\n+        // FIXME: This depends on the set of all impls for the trait. That is\n+        // unfortunate wrt. incremental compilation.\n+        //\n+        // If we want to be faster, we could have separate queries for\n+        // blanket and non-blanket impls, and compare them separately.\n         let impls = self.trait_impls_of(def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n@@ -154,32 +159,16 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // simplify_type(.., false) basically replaces type parameters and\n-        // projections with infer-variables. This is, of course, done on\n-        // the impl trait-ref when it is instantiated, but not on the\n-        // predicate trait-ref which is passed here.\n-        //\n-        // for example, if we match `S: Copy` against an impl like\n-        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n-        // in `Option<T>` with an infer variable, to `Option<_>` (this\n-        // doesn't actually change fast_reject output), but we don't\n-        // replace `S` with anything - this impl of course can't be\n-        // selected, and as there are hundreds of similar impls,\n-        // considering them would significantly harm performance.\n-\n-        // This depends on the set of all impls for the trait. That is\n-        // unfortunate. When we get red-green recompilation, we would like\n-        // to have a way of knowing whether the set of relevant impls\n-        // changed. The most naive\n-        // way would be to compute the Vec of relevant impls and see whether\n-        // it differs between compilations. That shouldn't be too slow by\n-        // itself - we do quite a bit of work for each relevant impl anyway.\n-        //\n-        // If we want to be faster, we could have separate queries for\n-        // blanket and non-blanket impls, and compare them separately.\n+        // Note that we're using `SimplifyParams::Yes` to query `non_blanket_impls` while using\n+        // `SimplifyParams::No` while actually adding them.\n         //\n-        // I think we'll cross that bridge when we get to it.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, true) {\n+        // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n+        // whose outer level is not a parameter or projection. Especially for things like\n+        // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n+        // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n+        if let Some(simp) =\n+            fast_reject::simplify_type(self, self_ty, SimplifyParams::Yes, StripReferences::No)\n+        {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -238,7 +227,9 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n             continue;\n         }\n \n-        if let Some(simplified_self_ty) = fast_reject::simplify_type(tcx, impl_self_ty, false) {\n+        if let Some(simplified_self_ty) =\n+            fast_reject::simplify_type(tcx, impl_self_ty, SimplifyParams::No, StripReferences::No)\n+        {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {\n             impls.blanket_impls.push(impl_def_id);"}, {"sha": "5fac2e55b1d0d98a6ac777eeb5c07baed894ed06", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -12,9 +12,10 @@ use crate::traits::{\n     self, Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext,\n };\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, fast_reject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use std::iter;\n@@ -82,12 +83,11 @@ where\n         impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n     )\n     .any(|(ty1, ty2)| {\n-        let t1 = fast_reject::simplify_type(tcx, ty1, false);\n-        let t2 = fast_reject::simplify_type(tcx, ty2, false);\n+        let t1 = fast_reject::simplify_type(tcx, ty1, SimplifyParams::No, StripReferences::No);\n+        let t2 = fast_reject::simplify_type(tcx, ty2, SimplifyParams::No, StripReferences::No);\n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully\n-            // Types cannot unify if they differ in their reference mutability or simplify to different types\n-            t1 != t2 || ty1.ref_mutability() != ty2.ref_mutability()\n+            t1 != t2\n         } else {\n             // Types might unify\n             false"}, {"sha": "5ccc83d5ef9e00209660a1c895521a26822698f7", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -21,10 +21,10 @@ use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{\n-    self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n-    TypeFoldable,\n+    self, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_session::DiagnosticMessageId;\n use rustc_span::symbol::{kw, sym};\n@@ -1440,14 +1440,32 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Vec<ty::TraitRef<'tcx>> {\n-        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        // We simplify params and strip references here.\n+        //\n+        // This both removes a lot of unhelpful suggestions, e.g.\n+        // when searching for `&Foo: Trait` it doesn't suggestion `impl Trait for &Bar`,\n+        // while also suggesting impls for `&Foo` when we're looking for `Foo: Trait`.\n+        //\n+        // The second thing isn't necessarily always a good thing, but\n+        // any other simple setup results in a far worse output, so \ud83e\udd37\n+        let simp = fast_reject::simplify_type(\n+            self.tcx,\n+            trait_ref.skip_binder().self_ty(),\n+            SimplifyParams::Yes,\n+            StripReferences::Yes,\n+        );\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {\n             Some(simp) => all_impls\n                 .filter_map(|def_id| {\n                     let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    let imp_simp = fast_reject::simplify_type(\n+                        self.tcx,\n+                        imp.self_ty(),\n+                        SimplifyParams::Yes,\n+                        StripReferences::Yes,\n+                    );\n                     if let Some(imp_simp) = imp_simp {\n                         if simp != imp_simp {\n                             return None;"}, {"sha": "607deb8f90875cb9f589226b9472db6ed2c2ed75", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -35,7 +35,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::fast_reject;\n+use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -2089,10 +2089,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             |(obligation_arg, impl_arg)| {\n                 match (obligation_arg.unpack(), impl_arg.unpack()) {\n                     (GenericArgKind::Type(obligation_ty), GenericArgKind::Type(impl_ty)) => {\n-                        let simplified_obligation_ty =\n-                            fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n-                        let simplified_impl_ty =\n-                            fast_reject::simplify_type(self.tcx(), impl_ty, false);\n+                        // Note, we simplify parameters for the obligation but not the\n+                        // impl so that we do not reject a blanket impl but do reject\n+                        // more concrete impls if we're searching for `T: Trait`.\n+                        let simplified_obligation_ty = fast_reject::simplify_type(\n+                            self.tcx(),\n+                            obligation_ty,\n+                            SimplifyParams::Yes,\n+                            StripReferences::No,\n+                        );\n+                        let simplified_impl_ty = fast_reject::simplify_type(\n+                            self.tcx(),\n+                            impl_ty,\n+                            SimplifyParams::No,\n+                            StripReferences::No,\n+                        );\n \n                         simplified_obligation_ty.is_some()\n                             && simplified_impl_ty.is_some()"}, {"sha": "2f9d2c47b011fba28e3034d10f55e561f2b19746", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -2,7 +2,7 @@ use super::OverlapError;\n \n use crate::traits;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams, StripReferences};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n \n@@ -48,7 +48,12 @@ impl ChildrenExt for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            SimplifyParams::No,\n+            StripReferences::No,\n+        ) {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -63,7 +68,12 @@ impl ChildrenExt for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            SimplifyParams::No,\n+            StripReferences::No,\n+        ) {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -306,7 +316,12 @@ impl GraphExt for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n+        let simplified = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            SimplifyParams::No,\n+            StripReferences::No,\n+        );\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "168bdce32108ae9c7cd3ec4f86d956fb1a78c30a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::ty::fast_reject::simplify_type;\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams, StripReferences};\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::lev_distance;\n@@ -1703,7 +1703,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) = simplify_type(self.tcx, rcvr_ty, true) {\n+            } else if let Some(simp_rcvr_ty) =\n+                simplify_type(self.tcx, rcvr_ty, SimplifyParams::Yes, StripReferences::No)\n+            {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n                 for candidate in candidates {\n@@ -1716,7 +1718,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n-                            let imp_simp = simplify_type(self.tcx, imp.self_ty(), true);\n+                            let imp_simp = simplify_type(\n+                                self.tcx,\n+                                imp.self_ty(),\n+                                SimplifyParams::Yes,\n+                                StripReferences::No,\n+                            );\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "8ce70b1ac0677c53494c4bc7a86d75f82c85d6ab", "filename": "src/test/ui/auto-traits/typeck-default-trait-impl-precedence.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -4,7 +4,11 @@ error[E0277]: the trait bound `u32: Signed` is not satisfied\n LL |     is_defaulted::<&'static u32>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Signed` is not implemented for `u32`\n    |\n-   = note: required because of the requirements on the impl of `Defaulted` for `&'static u32`\n+note: required because of the requirements on the impl of `Defaulted` for `&'static u32`\n+  --> $DIR/typeck-default-trait-impl-precedence.rs:10:19\n+   |\n+LL | impl<'a,T:Signed> Defaulted for &'a T { }\n+   |                   ^^^^^^^^^     ^^^^^\n note: required by a bound in `is_defaulted`\n   --> $DIR/typeck-default-trait-impl-precedence.rs:12:19\n    |"}, {"sha": "fe48e92da5eacc7d44c4a758f24b0413679c0cd3", "filename": "src/test/ui/impl-trait/issues/issue-70877.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -5,8 +5,13 @@ LL | type FooRet = impl std::fmt::Debug;\n    |               -------------------- the found opaque type\n ...\n LL | type Foo = impl Iterator<Item = FooItem>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found opaque type\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n    |\n+note: expected this to be `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n+  --> $DIR/issue-70877.rs:13:17\n+   |\n+LL |     type Item = FooItem;\n+   |                 ^^^^^^^\n    = note: expected struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n               found struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> impl Debug + 'static)>`\n "}, {"sha": "355f2038df889ebf4e8c410b41182ce8d7fdbc90", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -4,9 +4,6 @@ error[E0277]: the trait bound `&[i8]: From<&[u8]>` is not satisfied\n LL |     let _: &[i8] = data.into();\n    |                         ^^^^ the trait `From<&[u8]>` is not implemented for `&[i8]`\n    |\n-   = help: the following implementations were found:\n-             <[T; LANES] as From<Simd<T, LANES>>>\n-             <[bool; LANES] as From<Mask<T, LANES>>>\n    = note: required because of the requirements on the impl of `Into<&[i8]>` for `&[u8]`\n \n error: aborting due to previous error"}, {"sha": "aef6db0a40b75658466ad1d45d20e12dc6e2ddad", "filename": "src/test/ui/wf/hir-wf-check-erase-regions.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69ac533527025fffa37ad1bc4d82b3bc65f90264/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr?ref=69ac533527025fffa37ad1bc4d82b3bc65f90264", "patch": "@@ -5,7 +5,11 @@ LL |     type IntoIter = std::iter::Flatten<std::slice::Iter<'a, T>>;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&T` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&T`\n-   = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n+note: required because of the requirements on the impl of `IntoIterator` for `&T`\n+  --> $DIR/hir-wf-check-erase-regions.rs:6:29\n+   |\n+LL | impl<'a, T, const N: usize> IntoIterator for &'a Table<T, N> {\n+   |                             ^^^^^^^^^^^^     ^^^^^^^^^^^^^^^\n note: required by a bound in `Flatten`\n   --> $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n    |\n@@ -19,7 +23,11 @@ LL |     fn into_iter(self) -> Self::IntoIter {\n    |                           ^^^^^^^^^^^^^^ `&T` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&T`\n-   = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n+note: required because of the requirements on the impl of `IntoIterator` for `&T`\n+  --> $DIR/hir-wf-check-erase-regions.rs:6:29\n+   |\n+LL | impl<'a, T, const N: usize> IntoIterator for &'a Table<T, N> {\n+   |                             ^^^^^^^^^^^^     ^^^^^^^^^^^^^^^\n note: required by a bound in `Flatten`\n   --> $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n    |"}]}