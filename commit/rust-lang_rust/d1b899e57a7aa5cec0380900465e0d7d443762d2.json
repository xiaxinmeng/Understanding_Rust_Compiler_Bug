{"sha": "d1b899e57a7aa5cec0380900465e0d7d443762d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYjg5OWU1N2E3YWE1Y2VjMDM4MDkwMDQ2NWUwZDdkNDQzNzYyZDI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-17T18:46:02Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-17T18:46:02Z"}, "message": "update subtyping to be a bit clearer about reference variance", "tree": {"sha": "b6740cf227169410a3d264faa8712312a0b9fe3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6740cf227169410a3d264faa8712312a0b9fe3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1b899e57a7aa5cec0380900465e0d7d443762d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b899e57a7aa5cec0380900465e0d7d443762d2", "html_url": "https://github.com/rust-lang/rust/commit/d1b899e57a7aa5cec0380900465e0d7d443762d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1b899e57a7aa5cec0380900465e0d7d443762d2/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5a1b87c6f95e023ab465514aac143bdbd88f56b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a1b87c6f95e023ab465514aac143bdbd88f56b", "html_url": "https://github.com/rust-lang/rust/commit/c5a1b87c6f95e023ab465514aac143bdbd88f56b"}], "stats": {"total": 119, "additions": 70, "deletions": 49}, "files": [{"sha": "1b33c9abaa1bbe4af32734130e091dd83d89e5b0", "filename": "src/doc/tarpl/subtyping.md", "status": "modified", "additions": 70, "deletions": 49, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d1b899e57a7aa5cec0380900465e0d7d443762d2/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1b899e57a7aa5cec0380900465e0d7d443762d2/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=d1b899e57a7aa5cec0380900465e0d7d443762d2", "patch": "@@ -1,65 +1,78 @@\n % Subtyping and Variance\n \n-Although Rust doesn't have any notion of inheritance, it *does* include subtyping.\n-In Rust, subtyping derives entirely from *lifetimes*. Since lifetimes are scopes,\n-we can partially order them based on the *contains* (outlives) relationship. We\n-can even express this as a generic bound.\n+Although Rust doesn't have any notion of inheritance, it *does* include\n+subtyping. In Rust, subtyping derives entirely from *lifetimes*. Since lifetimes\n+are scopes, we can partially order them based on the *contains* (outlives)\n+relationship. We can even express this as a generic bound.\n \n-Subtyping on lifetimes in terms of that relationship: if `'a: 'b`\n-(\"a contains b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a\n-large source of confusion, because it seems intuitively backwards to many:\n-the bigger scope is a *sub type* of the smaller scope.\n+Subtyping on lifetimes in terms of that relationship: if `'a: 'b` (\"a contains\n+b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a large source of\n+confusion, because it seems intuitively backwards to many: the bigger scope is a\n+*sub type* of the smaller scope.\n \n This does in fact make sense, though. The intuitive reason for this is that if\n-you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static u8`,\n-in the same way that if you expect an Animal in Java, it's totally fine for me to\n-hand you a Cat. Cats are just Animals *and more*, just as `'static` is just `'a`\n-*and more*.\n+you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static\n+u8`, in the same way that if you expect an Animal in Java, it's totally fine for\n+me to hand you a Cat. Cats are just Animals *and more*, just as `'static` is\n+just `'a` *and more*.\n \n-(Note, the subtyping relationship and typed-ness of lifetimes is a fairly arbitrary\n-construct that some disagree with. However it simplifies our analysis to treat\n-lifetimes and types uniformly.)\n+(Note, the subtyping relationship and typed-ness of lifetimes is a fairly\n+arbitrary construct that some disagree with. However it simplifies our analysis\n+to treat lifetimes and types uniformly.)\n \n-Higher-ranked lifetimes are also subtypes of every concrete lifetime. This is because\n-taking an arbitrary lifetime is strictly more general than taking a specific one.\n+Higher-ranked lifetimes are also subtypes of every concrete lifetime. This is\n+because taking an arbitrary lifetime is strictly more general than taking a\n+specific one.\n \n \n \n # Variance\n \n Variance is where things get a bit complicated.\n \n-Variance is a property that *type constructors* have. A type constructor in Rust\n-is a generic type with unbound arguments. For instance `Vec` is a type constructor\n-that takes a `T` and returns a `Vec<T>`. `&` and `&mut` are type constructors that\n-take a two types: a lifetime, and a type to point to.\n+Variance is a property that *type constructors* have with respect to their\n+arguments. A type constructor in Rust is a generic type with unbound arguments.\n+For instance `Vec` is a type constructor that takes a `T` and returns a\n+`Vec<T>`. `&` and `&mut` are type constructors that take a two types: a\n+lifetime, and a type to point to.\n \n A type constructor's *variance* is how the subtyping of its inputs affects the\n subtyping of its outputs. There are two kinds of variance in Rust:\n \n-* F is *variant* if `T` being a subtype of `U` implies `F<T>` is a subtype of `F<U>`\n-* F is *invariant* otherwise (no subtyping relation can be derived)\n+* F is *variant* over `T` if `T` being a subtype of `U` implies\n+  `F<T>` is a subtype of `F<U>` (subtyping \"passes through\")\n+* F is *invariant* over `T` otherwise (no subtyping relation can be derived)\n \n-(For those of you who are familiar with variance from other languages, what we refer\n-to as \"just\" variance is in fact *covariance*. Rust does not have contravariance.\n-Historically Rust did have some contravariance but it was scrapped due to poor\n-interactions with other features.)\n+(For those of you who are familiar with variance from other languages, what we\n+refer to as \"just\" variance is in fact *covariance*. Rust does not have\n+contravariance. Historically Rust did have some contravariance but it was\n+scrapped due to poor interactions with other features. If you experience\n+contravariance in Rust call your local compiler developer for medical advice.)\n \n Some important variances:\n \n-* `&` is variant (as is `*const` by metaphor)\n-* `&mut` is invariant\n-* `Fn(T) -> U` is invariant with respect to `T`, but variant with respect to `U`\n-* `Box`, `Vec`, and all other collections are variant\n-* `UnsafeCell`, `Cell`, `RefCell`, `Mutex` and all \"interior mutability\"\n-  types are invariant (as is `*mut` by metaphor)\n+* `&'a T` is variant over `'a` and `T` (as is `*const T` by metaphor)\n+* `&'a mut T` is variant with over `'a` but invariant over `T`\n+* `Fn(T) -> U` is invariant over `T`, but variant over `U`\n+* `Box`, `Vec`, and all other collections are variant over their contents\n+* `UnsafeCell<T>`, `Cell<T>`, `RefCell<T>`, `Mutex<T>` and all other\n+  interior mutability types are invariant over T (as is `*mut T` by metaphor)\n \n-To understand why these variances are correct and desirable, we will consider several\n-examples. We have already covered why `&` should be variant when introducing subtyping:\n-it's desirable to be able to pass longer-lived things where shorter-lived things are\n-needed.\n+To understand why these variances are correct and desirable, we will consider\n+several examples.\n \n-To see why `&mut` should be invariant, consider the following code:\n+\n+We have already covered why `&'a T` should be variant over `'a` when\n+introducing subtyping: it's desirable to be able to pass longer-lived things\n+where shorter-lived things are needed.\n+\n+Similar reasoning applies to why it should be variant over T. It is reasonable\n+to be able to pass `&&'static str` where an `&&'a str` is expected. The\n+additional level of indirection does not change the desire to be able to pass\n+longer lived things where shorted lived things are expected.\n+\n+However this logic *does not* apply to see why `&mut`. To see why &mut should\n+be invariant over T, consider the following code:\n \n ```rust,ignore\n fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n@@ -78,17 +91,24 @@ fn main() {\n ```\n \n The signature of `overwrite` is clearly valid: it takes mutable references to\n-two values of the same type, and overwrites one with the other. If `&mut` was\n-variant, then `&mut &'a str` would be a subtype of `&mut &'static str`, since\n-`&'a str` is a subtype of `&'static str`. Therefore the lifetime of\n+two values of the same type, and overwrites one with the other. If `&mut T` was\n+variant over T, then `&mut &'a str` would be a subtype of `&mut &'static str`,\n+since `&'a str` is a subtype of `&'static str`. Therefore the lifetime of\n `forever_str` would successfully be \"shrunk\" down to the shorter lifetime of\n `string`, and `overwrite` would be called successfully. `string` would\n subsequently be dropped, and `forever_str` would point to freed memory when we\n print it! Therefore `&mut` should be invariant.\n \n-This is the general theme of variance vs\n-invariance: if variance would allow you to *store* a short-lived value in a\n-longer-lived slot, then you must be invariant.\n+This is the general theme of variance vs invariance: if variance would allow you\n+to *store* a short-lived value over a longer-lived slot, then you must be\n+invariant.\n+\n+However it *is* sound for `&'a mut T` to be variant over `'a`. The key difference\n+between `'a` and T is that `'a` is a property of the reference itself,\n+while T is something the reference is borrowing. If you change T's type, then\n+the source still remembers the original type. However if you change the\n+lifetime's type, no one but the reference knows this information, so it's fine.\n+Put another way, `&'a mut T` owns `'a`, but only *borrows* T.\n \n `Box` and `Vec` are interesting cases because they're variant, but you can\n definitely store values in them! This is where Rust gets really clever: it's\n@@ -115,9 +135,9 @@ Weakening when you pass by-value is fine because there's no one else who\n trouble was because there's always someone else who remembers the original\n subtype: the actual owner.\n \n-The invariance of the cell types can be seen as follows: `&` is like an `&mut` for a\n-cell, because you can still store values in them through an `&`. Therefore cells\n-must be invariant to avoid lifetime smuggling.\n+The invariance of the cell types can be seen as follows: `&` is like an `&mut`\n+for a cell, because you can still store values in them through an `&`. Therefore\n+cells must be invariant to avoid lifetime smuggling.\n \n `Fn` is the most subtle case because it has mixed variance. To see why\n `Fn(T) -> U` should be invariant over T, consider the following function\n@@ -128,8 +148,9 @@ signature:\n fn foo(&'a str) -> usize;\n ```\n \n-This signature claims that it can handle any `&str` that lives *at least* as long\n-as `'a`. Now if this signature was variant with respect to `&str`, that would mean\n+This signature claims that it can handle any `&str` that lives *at least* as\n+long as `'a`. Now if this signature was variant over `&'a str`, that\n+would mean\n \n ```rust,ignore\n fn foo(&'static str) -> usize;"}]}