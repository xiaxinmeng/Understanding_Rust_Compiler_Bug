{"sha": "06076f95a7ca764696b055eb754e163f884eefaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MDc2Zjk1YTdjYTc2NDY5NmIwNTVlYjc1NGUxNjNmODg0ZWVmYWE=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-15T20:10:57Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-15T20:10:57Z"}, "message": "feat: improve dot completions in a struct literal expression\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "34c8978d4caa962e62c1e88fcdf6f7a0baaef80e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34c8978d4caa962e62c1e88fcdf6f7a0baaef80e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06076f95a7ca764696b055eb754e163f884eefaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06076f95a7ca764696b055eb754e163f884eefaa", "html_url": "https://github.com/rust-lang/rust/commit/06076f95a7ca764696b055eb754e163f884eefaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06076f95a7ca764696b055eb754e163f884eefaa/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5d18f570c9751ca9ec2db7c8530fd6095a6465d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d18f570c9751ca9ec2db7c8530fd6095a6465d", "html_url": "https://github.com/rust-lang/rust/commit/c5d18f570c9751ca9ec2db7c8530fd6095a6465d"}], "stats": {"total": 227, "additions": 196, "deletions": 31}, "files": [{"sha": "1854505086541e93be6c5b18744a528f7b519a6f", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=06076f95a7ca764696b055eb754e163f884eefaa", "patch": "@@ -95,7 +95,7 @@ pub(crate) fn completions(\n     complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n \n     // Reorder completion items if there is a sort_option\n-    acc.sort();\n+    acc.sort(&ctx);\n \n     Some(acc)\n }"}, {"sha": "2e228b63813699dbd38e1cc4af7f67c0976871f8", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 140, "deletions": 1, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=06076f95a7ca764696b055eb754e163f884eefaa", "patch": "@@ -50,7 +50,9 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Ty\n         let fields = receiver.fields(ctx.db);\n \n         // If we use this implementation we can delete call_info in the CompletionContext\n-        if let Some(call_info) = call_info(ctx.db, ctx.file_position) {\n+        if let Some(record_field) = &ctx.record_field_syntax {\n+            acc.with_sort_option(SortOption::RecordField(record_field.clone()));\n+        } else if let Some(call_info) = call_info(ctx.db, ctx.file_position) {\n             acc.with_sort_option(SortOption::CallFn(call_info));\n         }\n \n@@ -240,6 +242,143 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_field_completion_in_record_lit() {\n+        assert_debug_snapshot!(\n+        do_ref_completion_without_sort(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn foo(a: A) {\n+                    let b = B {\n+                        the_field: a.<|>\n+                    };\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_record_lit_and_fn_call() {\n+        assert_debug_snapshot!(\n+        do_ref_completion_without_sort(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn test(the_field: i64) -> i64 { the_field }\n+                fn foo(a: A) {\n+                    let b = B {\n+                        the_field: test(a.<|>)\n+                    };\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_fn_call_and_record_lit() {\n+        assert_debug_snapshot!(\n+        do_ref_completion_without_sort(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn test(the_field: i64) -> i64 { the_field }\n+                fn foo(a: A) {\n+                    test(B {\n+                        the_field: a.<|>\n+                    });\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_struct_field_completion_self() {\n         assert_debug_snapshot!("}, {"sha": "dd9cc7daa34ec669e3d31735a4cb862676879c19", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=06076f95a7ca764696b055eb754e163f884eefaa", "patch": "@@ -32,6 +32,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) use_item_syntax: Option<ast::UseItem>,\n     pub(super) record_lit_syntax: Option<ast::RecordLit>,\n     pub(super) record_pat_syntax: Option<ast::RecordPat>,\n+    pub(super) record_field_syntax: Option<ast::RecordField>,\n     pub(super) impl_def: Option<ast::ImplDef>,\n     pub(super) call_info: Option<CallInfo>,\n     pub(super) is_param: bool,\n@@ -98,6 +99,7 @@ impl<'a> CompletionContext<'a> {\n             use_item_syntax: None,\n             record_lit_syntax: None,\n             record_pat_syntax: None,\n+            record_field_syntax: None,\n             impl_def: None,\n             is_param: false,\n             is_pat_binding_or_const: false,\n@@ -274,6 +276,14 @@ impl<'a> CompletionContext<'a> {\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::FnDef::cast);\n \n+        self.record_field_syntax = self\n+            .sema\n+            .ancestors_with_macros(self.token.parent())\n+            .take_while(|it| {\n+                it.kind() != SOURCE_FILE && it.kind() != MODULE && it.kind() != CALL_EXPR\n+            })\n+            .find_map(ast::RecordField::cast);\n+\n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,\n             None => return,"}, {"sha": "c9c3fdc0eb639102416be9a38a200fd946fac3f0", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06076f95a7ca764696b055eb754e163f884eefaa/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=06076f95a7ca764696b055eb754e163f884eefaa", "patch": "@@ -2,9 +2,10 @@\n \n use std::{cmp::Ordering, fmt};\n \n+use super::completion_context::CompletionContext;\n use crate::CallInfo;\n-use hir::Documentation;\n-use ra_syntax::TextRange;\n+use hir::{Documentation, HirDisplay};\n+use ra_syntax::{ast::RecordField, TextRange};\n use ra_text_edit::TextEdit;\n \n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n@@ -301,7 +302,7 @@ impl<'a> Into<CompletionItem> for Builder {\n #[derive(Debug)]\n pub(crate) enum SortOption {\n     CallFn(CallInfo),\n-    // LitStruct,\n+    RecordField(RecordField),\n }\n \n /// Represents an in-progress set of completions being built.\n@@ -327,40 +328,55 @@ impl Completions {\n         self.sort_option = Some(sort_option);\n     }\n \n-    pub(crate) fn sort(&mut self) {\n+    pub(crate) fn sort(&mut self, ctx: &CompletionContext) {\n         if self.sort_option.is_none() {\n             return;\n         }\n-        let sort_option = self.sort_option.as_ref().unwrap();\n \n-        match sort_option {\n+        let (active_name, active_type) = match self.sort_option.as_ref().unwrap() {\n             SortOption::CallFn(call_info) => {\n-                if let Some(active_parameter_type) = call_info.active_parameter_type() {\n-                    let active_parameter_name = call_info.active_parameter_name().unwrap();\n-\n-                    self.buf.sort_by(|a, b| {\n-                        // For the same type\n-                        if let Some(a_parameter_type) = &a.detail {\n-                            if &active_parameter_type == a_parameter_type {\n-                                // If same type + same name then go top position\n-                                if active_parameter_name != a.label {\n-                                    if let Some(b_parameter_type) = &b.detail {\n-                                        if &active_parameter_type == b_parameter_type {\n-                                            return Ordering::Equal;\n-                                        }\n-                                    }\n-                                }\n-                                Ordering::Less\n-                            } else {\n-                                Ordering::Greater\n+                if call_info.active_parameter_type().is_none()\n+                    || call_info.active_parameter_name().is_none()\n+                {\n+                    return;\n+                }\n+                (\n+                    call_info.active_parameter_name().unwrap(),\n+                    call_info.active_parameter_type().unwrap(),\n+                )\n+            }\n+            SortOption::RecordField(record_field) => {\n+                if let Some((struct_field, _)) = ctx.sema.resolve_record_field(record_field) {\n+                    (\n+                        struct_field.name(ctx.db).to_string(),\n+                        struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n+                    )\n+                } else {\n+                    return;\n+                }\n+            }\n+        };\n+\n+        self.buf.sort_by(|a, b| {\n+            // For the same type\n+            if let Some(a_parameter_type) = &a.detail {\n+                if &active_type == a_parameter_type {\n+                    // If same type + same name then go top position\n+                    if active_name != a.label {\n+                        if let Some(b_parameter_type) = &b.detail {\n+                            if &active_type == b_parameter_type {\n+                                return Ordering::Equal;\n                             }\n-                        } else {\n-                            Ordering::Greater\n                         }\n-                    });\n+                    }\n+                    Ordering::Less\n+                } else {\n+                    Ordering::Greater\n                 }\n-            } // _ => unimplemented!(\"sort options not already implemented\"),\n-        }\n+            } else {\n+                Ordering::Greater\n+            }\n+        });\n     }\n }\n "}]}