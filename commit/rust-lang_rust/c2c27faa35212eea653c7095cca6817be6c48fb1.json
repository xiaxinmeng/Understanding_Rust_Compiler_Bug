{"sha": "c2c27faa35212eea653c7095cca6817be6c48fb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYzI3ZmFhMzUyMTJlZWE2NTNjNzA5NWNjYTY4MTdiZTZjNDhmYjE=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-03T20:53:20Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-03T22:29:47Z"}, "message": "Fix #12285\n\nUnit-like struct patterns are irrefutable, no need for a branch.", "tree": {"sha": "843fbaf895f37e358a0e6d08cc69b1edac18444d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/843fbaf895f37e358a0e6d08cc69b1edac18444d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2c27faa35212eea653c7095cca6817be6c48fb1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2c27faa35212eea653c7095cca6817be6c48fb1", "html_url": "https://github.com/rust-lang/rust/commit/c2c27faa35212eea653c7095cca6817be6c48fb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2c27faa35212eea653c7095cca6817be6c48fb1/comments", "author": null, "committer": null, "parents": [{"sha": "eda75bcf42ad99e3e4c99585d39705fccac606ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda75bcf42ad99e3e4c99585d39705fccac606ee", "html_url": "https://github.com/rust-lang/rust/commit/eda75bcf42ad99e3e4c99585d39705fccac606ee"}], "stats": {"total": 171, "additions": 78, "deletions": 93}, "files": [{"sha": "8b5c7061a149faf4587ff9eecfd6a742ec6e5140", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 51, "deletions": 73, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c2c27faa35212eea653c7095cca6817be6c48fb1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c27faa35212eea653c7095cca6817be6c48fb1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c2c27faa35212eea653c7095cca6817be6c48fb1", "patch": "@@ -93,9 +93,10 @@ pub enum Constructor {\n     Slice(uint)\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, PartialEq)]\n enum Usefulness {\n-    Useful(Vec<Gc<Pat>>),\n+    Useful,\n+    UsefulWithWitness(Vec<Gc<Pat>>),\n     NotUseful\n }\n \n@@ -104,15 +105,6 @@ enum WitnessPreference {\n     LeaveOutWitness\n }\n \n-impl Usefulness {\n-    fn useful(self) -> Option<Vec<Gc<Pat>>> {\n-        match self {\n-            Useful(pats) => Some(pats),\n-            _ => None\n-        }\n-    }\n-}\n-\n impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n@@ -203,7 +195,8 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n             let v = vec!(*pat);\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => cx.tcx.sess.span_err(pat.span, \"unreachable pattern\"),\n-                _ => ()\n+                Useful => (),\n+                UsefulWithWitness(_) => unreachable!()\n             }\n             if arm.guard.is_none() {\n                 let Matrix(mut rows) = seen;\n@@ -223,7 +216,7 @@ fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n \n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n     match is_useful(cx, m, [wild()], ConstructWitness) {\n-        Useful(pats) => {\n+        UsefulWithWitness(pats) => {\n             let witness = match pats.as_slice() {\n                 [witness] => witness,\n                 [] => wild(),\n@@ -234,7 +227,8 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n-        }\n+        },\n+        _ => unreachable!()\n     }\n }\n \n@@ -404,11 +398,14 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m @ &Matrix(ref rows): &Matrix,\n+fn is_useful(cx: &MatchCheckCtxt, matrix @ &Matrix(ref rows): &Matrix,\n              v: &[Gc<Pat>], witness: WitnessPreference) -> Usefulness {\n-    debug!(\"{:}\", m);\n+    debug!(\"{:}\", matrix);\n     if rows.len() == 0u {\n-        return Useful(vec!());\n+        return match witness {\n+            ConstructWitness => UsefulWithWitness(vec!()),\n+            LeaveOutWitness => Useful\n+        };\n     }\n     if rows.get(0).len() == 0u {\n         return NotUseful;\n@@ -438,53 +435,46 @@ fn is_useful(cx: &MatchCheckCtxt, m @ &Matrix(ref rows): &Matrix,\n \n     let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n     if constructors.is_empty() {\n-        match missing_constructor(cx, m, left_ty, max_slice_length) {\n+        match missing_constructor(cx, matrix, left_ty, max_slice_length) {\n             None => {\n-                all_constructors(cx, left_ty, max_slice_length).move_iter().filter_map(|c| {\n-                    is_useful_specialized(cx, m, v, c.clone(),\n-                                          left_ty, witness).useful().map(|pats| {\n-                        Useful(match witness {\n-                            ConstructWitness => {\n-                                let arity = constructor_arity(cx, &c, left_ty);\n-                                let subpats = {\n-                                    let pat_slice = pats.as_slice();\n-                                    Vec::from_fn(arity, |i| {\n-                                        pat_slice.get(i).map(|p| p.clone())\n-                                            .unwrap_or_else(|| wild())\n-                                    })\n-                                };\n-                                let mut result = vec!(construct_witness(cx, &c, subpats, left_ty));\n-                                result.extend(pats.move_iter().skip(arity));\n-                                result\n-                            }\n-                            LeaveOutWitness => vec!()\n-                        })\n-                    })\n-                }).nth(0).unwrap_or(NotUseful)\n+                all_constructors(cx, left_ty, max_slice_length).move_iter().map(|c| {\n+                    match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n+                        UsefulWithWitness(pats) => UsefulWithWitness({\n+                            let arity = constructor_arity(cx, &c, left_ty);\n+                            let subpats = {\n+                                let pat_slice = pats.as_slice();\n+                                Vec::from_fn(arity, |i| {\n+                                    pat_slice.get(i).map(|p| p.clone())\n+                                        .unwrap_or_else(|| wild())\n+                                })\n+                            };\n+                            let mut result = vec!(construct_witness(cx, &c, subpats, left_ty));\n+                            result.extend(pats.move_iter().skip(arity));\n+                            result\n+                        }),\n+                        result => result\n+                    }\n+                }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n             },\n \n             Some(constructor) => {\n                 let matrix = Matrix(rows.iter().filter_map(|r|\n                     default(cx, r.as_slice())).collect());\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n-                    Useful(pats) => Useful(match witness {\n-                        ConstructWitness => {\n-                            let arity = constructor_arity(cx, &constructor, left_ty);\n-                            let wild_pats = Vec::from_elem(arity, wild());\n-                            let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n-                            (vec!(enum_pat)).append(pats.as_slice())\n-                        }\n-                        LeaveOutWitness => vec!()\n-                    }),\n+                    UsefulWithWitness(pats) => {\n+                        let arity = constructor_arity(cx, &constructor, left_ty);\n+                        let wild_pats = Vec::from_elem(arity, wild());\n+                        let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n+                        UsefulWithWitness(vec!(enum_pat).append(pats.as_slice()))\n+                    },\n                     result => result\n                 }\n             }\n         }\n     } else {\n-        constructors.move_iter().filter_map(|c| {\n-            is_useful_specialized(cx, m, v, c.clone(), left_ty, witness)\n-                .useful().map(|pats| Useful(pats))\n-        }).nth(0).unwrap_or(NotUseful)\n+        constructors.move_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness)\n+        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n     }\n }\n \n@@ -519,6 +509,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n+                Some(&DefStruct(_)) => vec!(Single),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n@@ -560,21 +551,6 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n     }\n }\n \n-fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n-    let pat = raw_pat(p);\n-    match pat.node {\n-        PatWild | PatWildMulti => true,\n-        PatIdent(_, _, _) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => false,\n-                _ => true\n-            },\n-        PatVec(ref before, Some(_), ref after) =>\n-            before.is_empty() && after.is_empty(),\n-        _ => false\n-    }\n-}\n-\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n@@ -780,7 +756,7 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n }\n \n fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {\n-    if is_wild(cx, r[0]) {\n+    if pat_is_binding_or_wild(&cx.tcx.def_map, &*raw_pat(r[0])) {\n         Some(Vec::from_slice(r.tail()))\n     } else {\n         None\n@@ -833,12 +809,14 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n     let pats = Matrix(vec!(vec!(pat)));\n-    is_useful(cx, &pats, [wild()], ConstructWitness)\n-        .useful()\n-        .map(|pats| {\n+    match is_useful(cx, &pats, [wild()], ConstructWitness) {\n+        UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n-            pats.get(0).clone()\n-        })\n+            Some(pats.get(0).clone())\n+        },\n+        NotUseful => None,\n+        Useful => unreachable!()\n+    }\n }\n \n // Legality of move bindings checking"}, {"sha": "3e0fd0cf7618255386cdf48c582be71e00e9a534", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c2c27faa35212eea653c7095cca6817be6c48fb1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c27faa35212eea653c7095cca6817be6c48fb1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c2c27faa35212eea653c7095cca6817be6c48fb1", "patch": "@@ -212,7 +212,6 @@ use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::controlflow;\n-use middle::trans::datum;\n use middle::trans::datum::*;\n use middle::trans::expr::Dest;\n use middle::trans::expr;\n@@ -236,10 +235,8 @@ use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n \n-// An option identifying a literal: either a unit-like struct or an\n-// expression.\n+// An option identifying a literal: either an expression or a DefId of a static expression.\n enum Lit {\n-    UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n     ExprLit(Gc<ast::Expr>),\n     ConstLit(ast::DefId),              // the def ID of the constant\n }\n@@ -262,14 +259,12 @@ enum Opt {\n fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> Gc<ast::Expr> {\n     match *a {\n         ExprLit(existing_a_expr) => existing_a_expr,\n-        ConstLit(a_const) => const_eval::lookup_const_by_id(tcx, a_const).unwrap(),\n-        UnitLikeStructLit(_) => fail!(\"lit_to_expr: unexpected struct lit\"),\n+        ConstLit(a_const) => const_eval::lookup_const_by_id(tcx, a_const).unwrap()\n     }\n }\n \n fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n-        (&lit(UnitLikeStructLit(a)), &lit(UnitLikeStructLit(b))) => a == b,\n         (&lit(a), &lit(b)) => {\n             let a_expr = lit_to_expr(tcx, &a);\n             let b_expr = lit_to_expr(tcx, &b);\n@@ -310,11 +305,6 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));\n         }\n-        lit(UnitLikeStructLit(pat_id)) => {\n-            let struct_ty = ty::node_id_to_type(bcx.tcx(), pat_id);\n-            let datum = datum::rvalue_scratch_datum(bcx, struct_ty, \"\");\n-            return single_result(Result::new(bcx, datum.val));\n-        }\n         lit(l @ ConstLit(ref def_id)) => {\n             let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_to_expr(bcx.tcx(), &l).id);\n             let (llval, _) = consts::get_const_val(bcx.ccx(), *def_id);\n@@ -347,9 +337,6 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n             let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n             var(variant.disr_val, adt::represent_node(bcx, pat_id), var_id)\n         }\n-        def::DefFn(..) | def::DefStruct(_) => {\n-            lit(UnitLikeStructLit(pat_id))\n-        }\n         _ => {\n             ccx.sess().bug(\"non-variant or struct in variant_opt()\");\n         }\n@@ -567,7 +554,6 @@ fn enter_opt<'a, 'b>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &lit(UnitLikeStructLit(_)) => check_match::Single,\n         &lit(x) => check_match::ConstantValue(const_eval::eval_const_expr(\n             bcx.tcx(), lit_to_expr(bcx.tcx(), &x))),\n         &range(ref lo, ref hi) => check_match::ConstantRange(\n@@ -672,11 +658,10 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 add_to_set(ccx.tcx(), &mut found, lit(ExprLit(l)));\n             }\n             ast::PatIdent(..) => {\n-                // This is one of: an enum variant, a unit-like struct, or a\n-                // variable binding.\n+                // This is either an enum variant or a variable binding.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(def::DefVariant(..)) | Some(def::DefStruct(..)) => {\n+                    Some(def::DefVariant(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n@@ -827,7 +812,7 @@ fn any_irrefutable_adt_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n         let pat = *br.pats.get(col);\n         match pat.node {\n             ast::PatTup(_) => true,\n-            ast::PatStruct(_, _, _) | ast::PatEnum(_, _) =>\n+            ast::PatEnum(..) | ast::PatIdent(_, _, None) | ast::PatStruct(..) =>\n                 match bcx.tcx().def_map.borrow().find(&pat.id) {\n                     Some(&def::DefFn(..)) |\n                     Some(&def::DefStruct(..)) => true,"}, {"sha": "563771212aa3df8df9860b57b2143ae166a037d8", "filename": "src/test/run-pass/issue-12285.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c2c27faa35212eea653c7095cca6817be6c48fb1/src%2Ftest%2Frun-pass%2Fissue-12285.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c27faa35212eea653c7095cca6817be6c48fb1/src%2Ftest%2Frun-pass%2Fissue-12285.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12285.rs?ref=c2c27faa35212eea653c7095cca6817be6c48fb1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+fn main() {\n+    match Some(&S) {\n+        Some(&S) => {},\n+        _x => unreachable!()\n+    }\n+    match Some(&S) {\n+        Some(&S) => {},\n+        None => unreachable!()\n+    }\n+}"}]}