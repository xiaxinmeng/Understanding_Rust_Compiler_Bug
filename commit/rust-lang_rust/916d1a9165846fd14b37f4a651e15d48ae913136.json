{"sha": "916d1a9165846fd14b37f4a651e15d48ae913136", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNmQxYTkxNjU4NDZmZDE0YjM3ZjRhNjUxZTE1ZDQ4YWU5MTMxMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-01T01:21:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-01T01:21:40Z"}, "message": "auto merge of #5176 : brson/rust/unwrap_shared_mutable_state, r=nikomatsakis\n\nr?\r\n\r\nThis fixes the current [random failures](http://buildbot.rust-lang.org/builders/auto-linux/builds/291/steps/test/logs/stdio) on the bots and closes #4436 by removing `unwrap_shared_mutable_state` and the code that depends on it. The result is that ARC-like things will not be unwrappable. This feature is complex and is not used outside of test cases.\r\n\r\nNote that there is not consensus to remove it.\r\n\r\n(second commit)", "tree": {"sha": "b9341b569d465c49af57d0cdf8ddcf94c4809bde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9341b569d465c49af57d0cdf8ddcf94c4809bde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/916d1a9165846fd14b37f4a651e15d48ae913136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/916d1a9165846fd14b37f4a651e15d48ae913136", "html_url": "https://github.com/rust-lang/rust/commit/916d1a9165846fd14b37f4a651e15d48ae913136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/916d1a9165846fd14b37f4a651e15d48ae913136/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5680ec027088c57f8b9fa3a9aa91daaf2428a57c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5680ec027088c57f8b9fa3a9aa91daaf2428a57c", "html_url": "https://github.com/rust-lang/rust/commit/5680ec027088c57f8b9fa3a9aa91daaf2428a57c"}, {"sha": "78d5091a4f09f0f7c613437e502db95b63a0c538", "url": "https://api.github.com/repos/rust-lang/rust/commits/78d5091a4f09f0f7c613437e502db95b63a0c538", "html_url": "https://github.com/rust-lang/rust/commit/78d5091a4f09f0f7c613437e502db95b63a0c538"}], "stats": {"total": 263, "additions": 10, "deletions": 253}, "files": [{"sha": "d19951e76dbd5e102c09075584a974caa0a63f00", "filename": "src/libcore/private.rs", "status": "modified", "additions": 4, "deletions": 186, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/916d1a9165846fd14b37f4a651e15d48ae913136/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/916d1a9165846fd14b37f4a651e15d48ae913136/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=916d1a9165846fd14b37f4a651e15d48ae913136", "patch": "@@ -107,20 +107,9 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n  * Shared state & exclusive ARC\n  ****************************************************************************/\n \n-struct UnwrapProtoInner {\n-    contents: Option<(comm::ChanOne<()>,  comm::PortOne<bool>)>,\n-}\n-\n-// An unwrapper uses this protocol to communicate with the \"other\" task that\n-// drops the last refcount on an arc. Unfortunately this can't be a proper\n-// pipe protocol because the unwrapper has to access both stages at once.\n-type UnwrapProto = ~UnwrapProtoInner;\n-\n struct ArcData<T> {\n     mut count:     libc::intptr_t,\n-    mut unwrapper: int, // either a UnwrapProto or 0\n-    // FIXME(#3224) should be able to make this non-option to save memory, and\n-    // in unwrap() use \"let ~ArcData { data: result, _ } = thing\" to unwrap it\n+    // FIXME(#3224) should be able to make this non-option to save memory\n     mut data:      Option<T>,\n }\n \n@@ -131,37 +120,13 @@ struct ArcDestruct<T> {\n impl<T> Drop for ArcDestruct<T>{\n     fn finalize(&self) {\n         unsafe {\n-            if self.data.is_null() {\n-                return; // Happens when destructing an unwrapper's handle.\n-            }\n             do task::unkillable {\n                 let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n                 let new_count =\n                     intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n                 assert new_count >= 0;\n                 if new_count == 0 {\n-                    // Were we really last, or should we hand off to an\n-                    // unwrapper? It's safe to not xchg because the unwrapper\n-                    // will set the unwrap lock *before* dropping his/her\n-                    // reference. In effect, being here means we're the only\n-                    // *awake* task with the data.\n-                    if data.unwrapper != 0 {\n-                        let mut p: UnwrapProto =\n-                            cast::reinterpret_cast(&data.unwrapper);\n-                        let (message, response) =\n-                            option::swap_unwrap(&mut p.contents);\n-                        // Send 'ready' and wait for a response.\n-                        comm::send_one(message, ());\n-                        // Unkillable wait. Message guaranteed to come.\n-                        if comm::recv_one(response) {\n-                            // Other task got the data.\n-                            cast::forget(data);\n-                        } else {\n-                            // Other task was killed. drop glue takes over.\n-                        }\n-                    } else {\n-                        // drop glue takes over.\n-                    }\n+                    // drop glue takes over.\n                 } else {\n                     cast::forget(data);\n                 }\n@@ -176,79 +141,6 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-pub unsafe fn unwrap_shared_mutable_state<T:Owned>(rc: SharedMutableState<T>)\n-        -> T {\n-    struct DeathThroes<T> {\n-        mut ptr:      Option<~ArcData<T>>,\n-        mut response: Option<comm::ChanOne<bool>>,\n-    }\n-\n-    impl<T> Drop for DeathThroes<T>{\n-        fn finalize(&self) {\n-            unsafe {\n-                let response = option::swap_unwrap(&mut self.response);\n-                // In case we get killed early, we need to tell the person who\n-                // tried to wake us whether they should hand-off the data to\n-                // us.\n-                if task::failing() {\n-                    comm::send_one(response, false);\n-                    // Either this swap_unwrap or the one below (at \"Got\n-                    // here\") ought to run.\n-                    cast::forget(option::swap_unwrap(&mut self.ptr));\n-                } else {\n-                    assert self.ptr.is_none();\n-                    comm::send_one(response, true);\n-                }\n-            }\n-        }\n-    }\n-\n-    do task::unkillable {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n-        let (p1,c1) = comm::oneshot(); // ()\n-        let (p2,c2) = comm::oneshot(); // bool\n-        let mut server: UnwrapProto = ~UnwrapProtoInner {\n-            contents: Some((c1,p2))\n-        };\n-        let serverp: int = cast::transmute(server);\n-        // Try to put our server end in the unwrapper slot.\n-        if compare_and_swap(&mut ptr.unwrapper, 0, serverp) {\n-            // Got in. Step 0: Tell destructor not to run. We are now it.\n-            rc.data = ptr::null();\n-            // Step 1 - drop our own reference.\n-            let new_count = intrinsics::atomic_xsub(&mut ptr.count, 1) - 1;\n-            //assert new_count >= 0;\n-            if new_count == 0 {\n-                // We were the last owner. Can unwrap immediately.\n-                // Also we have to free the server endpoints.\n-                let _server: UnwrapProto = cast::transmute(serverp);\n-                option::swap_unwrap(&mut ptr.data)\n-                // drop glue takes over.\n-            } else {\n-                // The *next* person who sees the refcount hit 0 will wake us.\n-                let end_result =\n-                    DeathThroes { ptr: Some(ptr),\n-                                  response: Some(c2) };\n-                let mut p1 = Some(p1); // argh\n-                do task::rekillable {\n-                    comm::recv_one(option::swap_unwrap(&mut p1));\n-                }\n-                // Got here. Back in the 'unkillable' without getting killed.\n-                // Recover ownership of ptr, then take the data out.\n-                let ptr = option::swap_unwrap(&mut end_result.ptr);\n-                option::swap_unwrap(&mut ptr.data)\n-                // drop glue takes over.\n-            }\n-        } else {\n-            // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n-            cast::forget(ptr);\n-            // Also we have to free the (rejected) server endpoints.\n-            let _server: UnwrapProto = cast::transmute(serverp);\n-            fail!(~\"Another task is already unwrapping this ARC!\");\n-        }\n-    }\n-}\n-\n /**\n  * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n  *\n@@ -259,7 +151,7 @@ pub type SharedMutableState<T> = ArcDestruct<T>;\n \n pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n         SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, unwrapper: 0, data: Some(data) };\n+    let data = ~ArcData { count: 1, data: Some(data) };\n     unsafe {\n         let ptr = cast::transmute(data);\n         ArcDestruct(ptr)\n@@ -413,22 +305,14 @@ pub impl<T:Owned> Exclusive<T> {\n     }\n }\n \n-// FIXME(#3724) make this a by-move method on the exclusive\n-pub fn unwrap_exclusive<T:Owned>(arc: Exclusive<T>) -> T {\n-    let Exclusive { x: x } = arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(x) };\n-    let ExData { data: data, _ } = inner;\n-    data\n-}\n-\n #[cfg(test)]\n pub mod tests {\n     use core::option::{None, Some};\n \n     use cell::Cell;\n     use comm;\n     use option;\n-    use private::{exclusive, unwrap_exclusive};\n+    use private::exclusive;\n     use result;\n     use task;\n     use uint;\n@@ -479,70 +363,4 @@ pub mod tests {\n             assert *one == 1;\n         }\n     }\n-\n-    #[test]\n-    pub fn exclusive_unwrap_basic() {\n-        let x = exclusive(~~\"hello\");\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n-    }\n-\n-    #[test]\n-    pub fn exclusive_unwrap_contended() {\n-        let x = exclusive(~~\"hello\");\n-        let x2 = Cell(x.clone());\n-        do task::spawn {\n-            let x2 = x2.take();\n-            do x2.with |_hello| { }\n-            task::yield();\n-        }\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n-\n-        // Now try the same thing, but with the child task blocking.\n-        let x = exclusive(~~\"hello\");\n-        let x2 = Cell(x.clone());\n-        let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn {\n-            let x2 = x2.take();\n-            assert unwrap_exclusive(x2) == ~~\"hello\";\n-        }\n-        // Have to get rid of our reference before blocking.\n-        { let _x = x; } // FIXME(#3161) util::ignore doesn't work here\n-        let res = option::swap_unwrap(&mut res);\n-        res.recv();\n-    }\n-\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn exclusive_unwrap_conflict() {\n-        let x = exclusive(~~\"hello\");\n-        let x2 = Cell(x.clone());\n-        let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn {\n-            let x2 = x2.take();\n-            assert unwrap_exclusive(x2) == ~~\"hello\";\n-        }\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n-        let res = option::swap_unwrap(&mut res);\n-        // See #4689 for why this can't be just \"res.recv()\".\n-        assert res.recv() == task::Success;\n-    }\n-\n-    #[test] #[ignore(cfg(windows))]\n-    pub fn exclusive_unwrap_deadlock() {\n-        // This is not guaranteed to get to the deadlock before being killed,\n-        // but it will show up sometimes, and if the deadlock were not there,\n-        // the test would nondeterministically fail.\n-        let result = do task::try {\n-            // a task that has two references to the same exclusive will\n-            // deadlock when it unwraps. nothing to be done about that.\n-            let x = exclusive(~~\"hello\");\n-            let x2 = x.clone();\n-            do task::spawn {\n-                for 10.times { task::yield(); } // try to let the unwrapper go\n-                fail!(); // punt it awake from its deadlock\n-            }\n-            let _z = unwrap_exclusive(x);\n-            do x2.with |_hello| { }\n-        };\n-        assert result.is_err();\n-    }\n }"}, {"sha": "69c5026cbd1ff2f100be9f36fe5d4df3b5361b90", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/916d1a9165846fd14b37f4a651e15d48ae913136/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/916d1a9165846fd14b37f4a651e15d48ae913136/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=916d1a9165846fd14b37f4a651e15d48ae913136", "patch": "@@ -21,7 +21,7 @@ use core::cell::Cell;\n use core::pipes;\n use core::prelude::*;\n use core::private::{SharedMutableState, shared_mutable_state};\n-use core::private::{clone_shared_mutable_state, unwrap_shared_mutable_state};\n+use core::private::{clone_shared_mutable_state};\n use core::private::{get_shared_mutable_state, get_shared_immutable_state};\n use core::ptr;\n use core::task;\n@@ -104,20 +104,6 @@ pub fn clone<T:Const + Owned>(rc: &ARC<T>) -> ARC<T> {\n     ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n }\n \n-/**\n- * Retrieve the data back out of the ARC. This function blocks until the\n- * reference given to it is the last existing one, and then unwrap the data\n- * instead of destroying it.\n- *\n- * If multiple tasks call unwrap, all but the first will fail. Do not call\n- * unwrap from a task that holds another reference to the same ARC; it is\n- * guaranteed to deadlock.\n- */\n-pub fn unwrap<T:Const + Owned>(rc: ARC<T>) -> T {\n-    let ARC { x: x } = rc;\n-    unsafe { unwrap_shared_mutable_state(x) }\n-}\n-\n impl<T:Const + Owned> Clone for ARC<T> {\n     fn clone(&self) -> ARC<T> {\n         clone(self)\n@@ -213,23 +199,6 @@ pub impl<T:Owned> &MutexARC<T> {\n     }\n }\n \n-/**\n- * Retrieves the data, blocking until all other references are dropped,\n- * exactly as arc::unwrap.\n- *\n- * Will additionally fail if another task has failed while accessing the arc.\n- */\n-// FIXME(#3724) make this a by-move method on the arc\n-pub fn unwrap_mutex_arc<T:Owned>(arc: MutexARC<T>) -> T {\n-    let MutexARC { x: x } = arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(x) };\n-    let MutexARCInner { failed: failed, data: data, _ } = inner;\n-    if failed {\n-        fail!(~\"Can't unwrap poisoned MutexARC - another task failed inside!\")\n-    }\n-    data\n-}\n-\n // Common code for {mutex.access,rwlock.write}{,_cond}.\n #[inline(always)]\n #[doc(hidden)]\n@@ -411,24 +380,6 @@ pub impl<T:Const + Owned> &RWARC<T> {\n     }\n }\n \n-/**\n- * Retrieves the data, blocking until all other references are dropped,\n- * exactly as arc::unwrap.\n- *\n- * Will additionally fail if another task has failed while accessing the arc\n- * in write mode.\n- */\n-// FIXME(#3724) make this a by-move method on the arc\n-pub fn unwrap_rw_arc<T:Const + Owned>(arc: RWARC<T>) -> T {\n-    let RWARC { x: x, _ } = arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(x) };\n-    let RWARCInner { failed: failed, data: data, _ } = inner;\n-    if failed {\n-        fail!(~\"Can't unwrap poisoned RWARC - another task failed inside!\")\n-    }\n-    data\n-}\n-\n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n@@ -586,21 +537,6 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_mutex_arc_unwrap_poison() {\n-        let arc = MutexARC(1);\n-        let arc2 = ~(&arc).clone();\n-        let (p, c) = comm::stream();\n-        do task::spawn || {\n-            do arc2.access |one| {\n-                c.send(());\n-                assert *one == 2;\n-            }\n-        }\n-        let _ = p.recv();\n-        let one = unwrap_mutex_arc(arc);\n-        assert one == 1;\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();"}, {"sha": "761dbeade538bf6ee0cbdd95800379114cd455c2", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/916d1a9165846fd14b37f4a651e15d48ae913136/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/916d1a9165846fd14b37f4a651e15d48ae913136/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=916d1a9165846fd14b37f4a651e15d48ae913136", "patch": "@@ -342,8 +342,11 @@ rust_kernel::register_exit_function(spawn_fn runner, fn_env_pair *f) {\n     assert(!at_exit_started && \"registering at_exit function after exit\");\n \n     if (at_exit_runner) {\n-        assert(runner == at_exit_runner\n-               && \"there can be only one at_exit_runner\");\n+        // FIXME #2912 Would be very nice to assert this but we can't because\n+        // of the way coretest works (the test case ends up using its own\n+        // function)\n+        //assert(runner == at_exit_runner\n+        //       && \"there can be only one at_exit_runner\");\n     }\n \n     at_exit_runner = runner;"}]}