{"sha": "2fc85718615a4261eba5ef0e696e1d995cdfd375", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzg1NzE4NjE1YTQyNjFlYmE1ZWYwZTY5NmUxZDk5NWNkZmQzNzU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-01T20:07:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-01T20:08:40Z"}, "message": "Fix deadlocks with RUST_LOG=rustc::middle::ty\n\nThese are RefCell deadlocks that cause the rustc task to die with the stderr\nlock held, causing a real deadlock.\n\nFixes #26717.", "tree": {"sha": "48aa7e1b48ec5dc1ff3a56cbc3b9b5a346ad2e2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48aa7e1b48ec5dc1ff3a56cbc3b9b5a346ad2e2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc85718615a4261eba5ef0e696e1d995cdfd375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc85718615a4261eba5ef0e696e1d995cdfd375", "html_url": "https://github.com/rust-lang/rust/commit/2fc85718615a4261eba5ef0e696e1d995cdfd375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc85718615a4261eba5ef0e696e1d995cdfd375/comments", "author": null, "committer": null, "parents": [{"sha": "40db46c6ba0d59e5ad9aa056a73055d2d3b83d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/40db46c6ba0d59e5ad9aa056a73055d2d3b83d04", "html_url": "https://github.com/rust-lang/rust/commit/40db46c6ba0d59e5ad9aa056a73055d2d3b83d04"}], "stats": {"total": 124, "additions": 68, "deletions": 56}, "files": [{"sha": "a0efc50d0d781143b87e088bd1d1e5e503f325aa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2fc85718615a4261eba5ef0e696e1d995cdfd375", "patch": "@@ -1656,7 +1656,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-                        dcx.tcx.tcache.borrow_mut().insert(lid, type_scheme);\n+                        dcx.tcx.register_item_type(lid, type_scheme);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(dcx);"}, {"sha": "4ec59926eaef24ffc8c5c7795a6c6cc378a530a7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2fc85718615a4261eba5ef0e696e1d995cdfd375", "patch": "@@ -3198,10 +3198,10 @@ pub trait ClosureTyper<'tcx> {\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n-           interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>)\n+           interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>)\n            -> CommonTypes<'tcx>\n     {\n-        let mut mk = |sty| ctxt::intern_ty(arena, interner, sty);\n+        let mk = |sty| ctxt::intern_ty(arena, interner, sty);\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n@@ -3430,12 +3430,12 @@ impl<'tcx> ctxt<'tcx> {\n                                  f: F) -> (Session, R)\n                                  where F: FnOnce(&ctxt<'tcx>) -> R\n     {\n-        let mut interner = FnvHashMap();\n-        let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n+        let interner = RefCell::new(FnvHashMap());\n+        let common_types = CommonTypes::new(&arenas.type_, &interner);\n \n         tls::enter(ctxt {\n             arenas: arenas,\n-            interner: RefCell::new(interner),\n+            interner: interner,\n             substs_interner: RefCell::new(FnvHashMap()),\n             bare_fn_interner: RefCell::new(FnvHashMap()),\n             region_interner: RefCell::new(FnvHashMap()),\n@@ -3563,35 +3563,37 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     fn intern_ty(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n-                 interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>,\n+                 interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n                  st: TypeVariants<'tcx>)\n                  -> Ty<'tcx> {\n-        match interner.get(&st) {\n-            Some(ty) => return *ty,\n-            _ => ()\n-        }\n+        let ty: Ty /* don't be &mut TyS */ = {\n+            let mut interner = interner.borrow_mut();\n+            match interner.get(&st) {\n+                Some(ty) => return *ty,\n+                _ => ()\n+            }\n \n-        let flags = FlagComputation::for_sty(&st);\n+            let flags = FlagComputation::for_sty(&st);\n+\n+            let ty = match () {\n+                () => type_arena.alloc(TyS { sty: st,\n+                                             flags: Cell::new(flags.flags),\n+                                             region_depth: flags.depth, }),\n+            };\n \n-        let ty = match () {\n-            () => type_arena.alloc(TyS { sty: st,\n-                                        flags: Cell::new(flags.flags),\n-                                        region_depth: flags.depth, }),\n+            interner.insert(InternedTy { ty: ty }, ty);\n+            ty\n         };\n \n         debug!(\"Interned type: {:?} Pointer: {:?}\",\n             ty, ty as *const TyS);\n-\n-        interner.insert(InternedTy { ty: ty }, ty);\n-\n         ty\n     }\n \n     // Interns a type/name combination, stores the resulting box in cx.interner,\n     // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n     pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n-        let mut interner = self.interner.borrow_mut();\n-        ctxt::intern_ty(&self.arenas.type_, &mut *interner, st)\n+        ctxt::intern_ty(&self.arenas.type_, &self.interner, st)\n     }\n \n     pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n@@ -5930,6 +5932,10 @@ impl<'tcx> ctxt<'tcx> {\n                                    .clone()\n     }\n \n+    // Register a given item type\n+    pub fn register_item_type(&self, did: ast::DefId, ty: TypeScheme<'tcx>) {\n+        self.tcache.borrow_mut().insert(did, ty);\n+    }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n@@ -6006,8 +6012,8 @@ impl<'tcx> ctxt<'tcx> {\n         if id.krate == ast::LOCAL_CRATE {\n             self.node_id_to_type(id.node)\n         } else {\n-            let mut tcache = self.tcache.borrow_mut();\n-            tcache.entry(id).or_insert_with(|| csearch::get_field_type(self, struct_id, id)).ty\n+            memoized(&self.tcache, id,\n+                     |id| csearch::get_field_type(self, struct_id, id)).ty\n         }\n     }\n "}, {"sha": "91b547e967952b2d8646da9dd5d4f98730b822b9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2fc85718615a4261eba5ef0e696e1d995cdfd375", "patch": "@@ -680,8 +680,15 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n             TyEnum(did, substs) | TyStruct(did, substs) => {\n-                parameterized(f, substs, did, &[],\n-                              |tcx| tcx.lookup_item_type(did).generics)\n+                ty::tls::with(|tcx| {\n+                    if did.krate == ast::LOCAL_CRATE &&\n+                          !tcx.tcache.borrow().contains_key(&did) {\n+                        write!(f, \"{}<..>\", tcx.item_path_str(did))\n+                    } else {\n+                        parameterized(f, substs, did, &[],\n+                                      |tcx| tcx.lookup_item_type(did).generics)\n+                    }\n+                })\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),"}, {"sha": "020aac2c197af3631e9c7c8172e21a327cdcd553", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2fc85718615a4261eba5ef0e696e1d995cdfd375", "patch": "@@ -4007,7 +4007,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n+    let declty = fcx.ccx.tcx.lookup_item_type(local_def(id)).ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n "}, {"sha": "da7851b18f9d029bf6e1311747772a81beeb390a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=2fc85718615a4261eba5ef0e696e1d995cdfd375", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             };\n             debug!(\"new_polytype={:?}\", new_polytype);\n \n-            tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n+            tcx.register_item_type(new_did, new_polytype);\n             tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n             tcx.impl_or_trait_items\n                .borrow_mut()"}, {"sha": "4ac100f4c1012b873de3fe88aaf18048d39ab0dc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc85718615a4261eba5ef0e696e1d995cdfd375/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2fc85718615a4261eba5ef0e696e1d995cdfd375", "patch": "@@ -596,7 +596,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(variant_def_id, variant_scheme.clone());\n+        tcx.register_item_type(variant_def_id, variant_scheme.clone());\n         tcx.predicates.borrow_mut().insert(variant_def_id, enum_predicates.clone());\n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n@@ -635,7 +635,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n     debug!(\"method {} (id {}) has type {:?}\",\n             ident, id, fty);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n+    ccx.tcx.register_item_type(def_id, TypeScheme {\n         generics: ty_method.generics.clone(),\n         ty: fty\n     });\n@@ -661,11 +661,11 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n-                                       ty::TypeScheme {\n-                                           generics: struct_generics.clone(),\n-                                           ty: tt\n-                                       });\n+    ccx.tcx.register_item_type(local_def(v.node.id),\n+                               ty::TypeScheme {\n+                                   generics: struct_generics.clone(),\n+                                   ty: tt\n+                               });\n     ccx.tcx.predicates.borrow_mut().insert(local_def(v.node.id),\n                                            struct_predicates.clone());\n \n@@ -841,9 +841,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id),\n-                                           TypeScheme { generics: ty_generics.clone(),\n-                                                        ty: selfty });\n+            tcx.register_item_type(local_def(it.id),\n+                                   TypeScheme { generics: ty_generics.clone(),\n+                                                ty: selfty });\n             tcx.predicates.borrow_mut().insert(local_def(it.id),\n                                                ty_predicates.clone());\n \n@@ -863,11 +863,11 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 if let ast::ConstImplItem(ref ty, ref expr) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &*ty);\n-                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n-                                                   TypeScheme {\n-                                                       generics: ty_generics.clone(),\n-                                                       ty: ty,\n-                                                   });\n+                    tcx.register_item_type(local_def(impl_item.id),\n+                                           TypeScheme {\n+                                               generics: ty_generics.clone(),\n+                                               ty: ty,\n+                                           });\n                     convert_associated_const(ccx, ImplContainer(local_def(it.id)),\n                                              impl_item.ident, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n@@ -954,11 +954,11 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                     ast::ConstTraitItem(ref ty, ref default) => {\n                         let ty = ccx.icx(&trait_predicates)\n                                     .to_ty(&ExplicitRscope, ty);\n-                        tcx.tcache.borrow_mut().insert(local_def(trait_item.id),\n-                                                       TypeScheme {\n-                                                           generics: trait_def.generics.clone(),\n-                                                           ty: ty,\n-                                                       });\n+                        tcx.register_item_type(local_def(trait_item.id),\n+                                               TypeScheme {\n+                                                   generics: trait_def.generics.clone(),\n+                                                   ty: ty,\n+                                               });\n                         convert_associated_const(ccx, TraitContainer(local_def(it.id)),\n                                                  trait_item.ident, trait_item.id,\n                                                  ast::Public, ty, default.as_ref().map(|d| &**d));\n@@ -1099,26 +1099,25 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n-                tcx.tcache.borrow_mut().insert(local_def(ctor_id), scheme);\n+                tcx.register_item_type(local_def(ctor_id), scheme);\n                 tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> =\n                     struct_def.fields\n                               .iter()\n-                              .map(|field| tcx.tcache.borrow().get(&local_def(field.node.id))\n-                                                              .unwrap()\n-                                                              .ty)\n+                              .map(|field| tcx.lookup_item_type(\n+                                  local_def(field.node.id)).ty)\n                               .collect();\n                 let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n                                                 &inputs[..],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-                tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n-                                               TypeScheme {\n-                                                   generics: scheme.generics,\n-                                                   ty: ctor_fn_ty\n-                                               });\n+                tcx.register_item_type(local_def(ctor_id),\n+                                       TypeScheme {\n+                                           generics: scheme.generics,\n+                                           ty: ctor_fn_ty\n+                                       });\n                 tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             }\n         }"}]}