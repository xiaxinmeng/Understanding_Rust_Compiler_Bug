{"sha": "708100767848cf0bd52047ab552f945768164ab2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwODEwMDc2Nzg0OGNmMGJkNTIwNDdhYjU1MmY5NDU3NjgxNjRhYjI=", "commit": {"author": {"name": "Raphael Speyer", "email": "rspeyer@gmail.com", "date": "2014-10-13T11:09:30Z"}, "committer": {"name": "Raphael Speyer", "email": "rspeyer@gmail.com", "date": "2014-10-15T17:39:58Z"}, "message": "impl Buffer for ChanReader", "tree": {"sha": "d2fec32be90ad785780e4a8ade210f3a34e6503a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2fec32be90ad785780e4a8ade210f3a34e6503a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/708100767848cf0bd52047ab552f945768164ab2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/708100767848cf0bd52047ab552f945768164ab2", "html_url": "https://github.com/rust-lang/rust/commit/708100767848cf0bd52047ab552f945768164ab2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/708100767848cf0bd52047ab552f945768164ab2/comments", "author": {"login": "rapha", "id": 29763, "node_id": "MDQ6VXNlcjI5NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/29763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rapha", "html_url": "https://github.com/rapha", "followers_url": "https://api.github.com/users/rapha/followers", "following_url": "https://api.github.com/users/rapha/following{/other_user}", "gists_url": "https://api.github.com/users/rapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/rapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rapha/subscriptions", "organizations_url": "https://api.github.com/users/rapha/orgs", "repos_url": "https://api.github.com/users/rapha/repos", "events_url": "https://api.github.com/users/rapha/events{/privacy}", "received_events_url": "https://api.github.com/users/rapha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rapha", "id": 29763, "node_id": "MDQ6VXNlcjI5NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/29763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rapha", "html_url": "https://github.com/rapha", "followers_url": "https://api.github.com/users/rapha/followers", "following_url": "https://api.github.com/users/rapha/following{/other_user}", "gists_url": "https://api.github.com/users/rapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/rapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rapha/subscriptions", "organizations_url": "https://api.github.com/users/rapha/orgs", "repos_url": "https://api.github.com/users/rapha/repos", "events_url": "https://api.github.com/users/rapha/events{/privacy}", "received_events_url": "https://api.github.com/users/rapha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "html_url": "https://github.com/rust-lang/rust/commit/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "bd9577c8cfc8cf3dcf8a1d70e8a46c7800ce34c7", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/708100767848cf0bd52047ab552f945768164ab2/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/708100767848cf0bd52047ab552f945768164ab2/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=708100767848cf0bd52047ab552f945768164ab2", "patch": "@@ -13,10 +13,10 @@ use cmp;\n use collections::Collection;\n use comm::{Sender, Receiver};\n use io;\n-use option::{None, Option, Some};\n+use option::{None, Some};\n use result::{Ok, Err};\n use slice::{bytes, CloneableVector};\n-use super::{Reader, Writer, IoResult};\n+use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n \n /// Allows reading from a rx.\n@@ -37,7 +37,7 @@ use vec::Vec;\n /// }\n /// ```\n pub struct ChanReader {\n-    buf: Option<Vec<u8>>,  // A buffer of bytes received but not consumed.\n+    buf: Vec<u8>,          // A buffer of bytes received but not consumed.\n     pos: uint,             // How many of the buffered bytes have already be consumed.\n     rx: Receiver<Vec<u8>>, // The Receiver to pull data from.\n     closed: bool,          // Whether the channel this Receiver connects to has been closed.\n@@ -47,35 +47,59 @@ impl ChanReader {\n     /// Wraps a `Port` in a `ChanReader` structure\n     pub fn new(rx: Receiver<Vec<u8>>) -> ChanReader {\n         ChanReader {\n-            buf: None,\n+            buf: Vec::new(),\n             pos: 0,\n             rx: rx,\n             closed: false,\n         }\n     }\n }\n \n+impl Buffer for ChanReader {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        if self.pos >= self.buf.len() {\n+            self.pos = 0;\n+            match self.rx.recv_opt() {\n+                Ok(bytes) => {\n+                    self.buf = bytes;\n+                },\n+                Err(()) => {\n+                    self.closed = true;\n+                    self.buf = Vec::new();\n+                }\n+            }\n+        }\n+        if self.closed {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else {\n+            Ok(self.buf.slice_from(self.pos))\n+        }\n+    }\n+\n+    fn consume(&mut self, amt: uint) {\n+        self.pos += amt;\n+        assert!(self.pos <= self.buf.len());\n+    }\n+}\n+\n impl Reader for ChanReader {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut num_read = 0;\n         loop {\n-            match self.buf {\n-                Some(ref prev) => {\n+            let count = match self.fill_buf().ok() {\n+                Some(src) => {\n                     let dst = buf[mut num_read..];\n-                    let src = prev[self.pos..];\n-                    let count = cmp::min(dst.len(), src.len());\n+                    let count = cmp::min(src.len(), dst.len());\n                     bytes::copy_memory(dst, src[..count]);\n-                    num_read += count;\n-                    self.pos += count;\n+                    count\n                 },\n-                None => (),\n+                None => 0,\n             };\n+            self.consume(count);\n+            num_read += count;\n             if num_read == buf.len() || self.closed {\n                 break;\n             }\n-            self.pos = 0;\n-            self.buf = self.rx.recv_opt().ok();\n-            self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n             Err(io::standard_error(io::EndOfFile))\n@@ -149,7 +173,6 @@ mod test {\n         let mut reader = ChanReader::new(rx);\n         let mut buf = [0u8, ..3];\n \n-\n         assert_eq!(Ok(0), reader.read([]));\n \n         assert_eq!(Ok(3), reader.read(buf));\n@@ -178,6 +201,28 @@ mod test {\n         assert_eq!(a, buf.as_slice());\n     }\n \n+    #[test]\n+    fn test_rx_buffer() {\n+        let (tx, rx) = channel();\n+        task::spawn(proc() {\n+          tx.send(b\"he\".to_vec());\n+          tx.send(b\"llo wo\".to_vec());\n+          tx.send(b\"\".to_vec());\n+          tx.send(b\"rld\\nhow \".to_vec());\n+          tx.send(b\"are you?\".to_vec());\n+          tx.send(b\"\".to_vec());\n+        });\n+\n+        let mut reader = ChanReader::new(rx);\n+\n+        assert_eq!(Ok(\"hello world\\n\".to_string()), reader.read_line());\n+        assert_eq!(Ok(\"how are you?\".to_string()), reader.read_line());\n+        match reader.read_line() {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n+    }\n+\n     #[test]\n     fn test_chan_writer() {\n         let (tx, rx) = channel();"}]}