{"sha": "76856e19ff3c7c699931d0acee8e61bc0dfec512", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ODU2ZTE5ZmYzYzdjNjk5OTMxZDBhY2VlOGU2MWJjMGRmZWM1MTI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-10T04:40:59Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-17T00:16:46Z"}, "message": "Add an early lint pass for lints that operate on the AST\n\nThere is a minor [breaking-change] for lint authors - some functions which were previously defined on `lint::Context` have moved to a trait - `LintContext`, you may need to import that trait to avoid name resolution errors.", "tree": {"sha": "f2d6dad6b68b38ea34394544ded83069e8344c67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2d6dad6b68b38ea34394544ded83069e8344c67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76856e19ff3c7c699931d0acee8e61bc0dfec512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76856e19ff3c7c699931d0acee8e61bc0dfec512", "html_url": "https://github.com/rust-lang/rust/commit/76856e19ff3c7c699931d0acee8e61bc0dfec512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76856e19ff3c7c699931d0acee8e61bc0dfec512/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f18c2aaf203e4e428c46c651b34c7a3e4ca91572", "url": "https://api.github.com/repos/rust-lang/rust/commits/f18c2aaf203e4e428c46c651b34c7a3e4ca91572", "html_url": "https://github.com/rust-lang/rust/commit/f18c2aaf203e4e428c46c651b34c7a3e4ca91572"}], "stats": {"total": 775, "additions": 563, "deletions": 212}, "files": [{"sha": "3f1a1ed48a1478e1611e5e7c6521e04865f54d29", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 391, "deletions": 85, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -36,15 +36,15 @@ use util::nodemap::FnvHashMap;\n use std::cell::RefCell;\n use std::cmp;\n use std::mem;\n-use syntax::ast_util::IdVisitingOperation;\n+use syntax::ast_util::{self, IdVisitingOperation};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor, FnKind};\n use rustc_front::util;\n-use syntax::visit::Visitor as SyntaxVisitor;\n+use rustc_front::visit as hir_visit;\n+use syntax::visit as ast_visit;\n use syntax::diagnostic;\n \n /// Information about the registered lints.\n@@ -248,8 +248,8 @@ impl LintStore {\n     }\n }\n \n-/// Context for lint checking.\n-pub struct Context<'a, 'tcx: 'a> {\n+/// Context for lint checking after type checking.\n+pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n@@ -272,15 +272,35 @@ pub struct Context<'a, 'tcx: 'a> {\n     node_levels: RefCell<FnvHashMap<(ast::NodeId, LintId), LevelSource>>,\n }\n \n+pub type Context<'a, 'tcx: 'a> = LateContext<'a, 'tcx>;\n+\n+/// Context for lint checking of the AST, after expansion, before lowering to\n+/// HIR.\n+pub struct EarlyContext<'a> {\n+    /// Type context we're checking in.\n+    pub sess: &'a Session,\n+\n+    /// The crate being checked.\n+    pub krate: &'a ast::Crate,\n+\n+    /// The store of registered lints.\n+    lints: LintStore,\n+\n+    /// When recursing into an attributed node of the ast which modifies lint\n+    /// levels, this stack keeps track of the previous lint levels of whatever\n+    /// was modified.\n+    level_stack: Vec<(LintId, LevelSource)>,\n+}\n+\n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lints.passes.take().unwrap();\n+    let mut passes = $cx.mut_lints().passes.take().unwrap();\n     for obj in &mut passes {\n         obj.$f($cx, $($args),*);\n     }\n-    $cx.lints.passes = Some(passes);\n+    $cx.mut_lints().passes = Some(passes);\n }) }\n \n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n@@ -364,65 +384,50 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     }\n }\n \n-impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn new(tcx: &'a ty::ctxt<'tcx>,\n-           krate: &'a hir::Crate,\n-           exported_items: &'a ExportedItems) -> Context<'a, 'tcx> {\n-        // We want to own the lint store, so move it out of the session.\n-        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n-                                      LintStore::new());\n-\n-        Context {\n-            tcx: tcx,\n-            krate: krate,\n-            exported_items: exported_items,\n-            lints: lint_store,\n-            level_stack: vec![],\n-            node_levels: RefCell::new(FnvHashMap()),\n-        }\n-    }\n-\n-    /// Get the overall compiler `Session` object.\n-    pub fn sess(&'a self) -> &'a Session {\n-        &self.tcx.sess\n-    }\n+pub trait LintContext: Sized {\n+    fn sess(&self) -> &Session;\n+    fn lints(&self) -> &LintStore;\n+    fn mut_lints(&mut self) -> &mut LintStore;\n+    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)>;\n+    fn enter_attrs(&mut self, attrs: &[hir::Attribute]);\n+    fn exit_attrs(&mut self, attrs: &[hir::Attribute]);\n \n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n-    pub fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lints.levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n+    fn current_level(&self, lint: &'static Lint) -> Level {\n+        self.lints().levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n     }\n \n     fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n-        let (level, src) = match self.lints.levels.get(&LintId::of(lint)) {\n+        let (level, src) = match self.lints().levels.get(&LintId::of(lint)) {\n             None => return,\n             Some(&(Warn, src)) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n-                (self.lints.get_level_source(lint_id).0, src)\n+                (self.lints().get_level_source(lint_id).0, src)\n             }\n             Some(&pair) => pair,\n         };\n \n-        raw_emit_lint(&self.tcx.sess, lint, (level, src), span, msg);\n-    }\n-\n-    /// Emit a lint at the appropriate level, with no associated span.\n-    pub fn lint(&self, lint: &'static Lint, msg: &str) {\n-        self.lookup_and_emit(lint, None, msg);\n+        raw_emit_lint(&self.sess(), lint, (level, src), span, msg);\n     }\n \n     /// Emit a lint at the appropriate level, for a particular span.\n-    pub fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+    fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n+    /// Emit a lint at the appropriate level, with no associated span.\n+    fn lint(&self, lint: &'static Lint, msg: &str) {\n+        self.lookup_and_emit(lint, None, msg);\n+    }\n+\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n                           attrs: &[ast::Attribute],\n-                          f: F) where\n-        F: FnOnce(&mut Context),\n+                          f: F)\n+        where F: FnOnce(&mut Self),\n     {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n@@ -433,15 +438,15 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         for result in gather_attrs(attrs) {\n             let v = match result {\n                 Err(span) => {\n-                    span_err!(self.tcx.sess, span, E0452,\n+                    span_err!(self.sess(), span, E0452,\n                               \"malformed lint attribute\");\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints.find_lint(&lint_name, &self.tcx.sess, Some(span)) {\n+                    match self.lints().find_lint(&lint_name, &self.sess(), Some(span)) {\n                         Ok(lint_id) => vec![(lint_id, level, span)],\n                         Err(FindLintError::NotFound) => {\n-                            match self.lints.lint_groups.get(&lint_name[..]) {\n+                            match self.lints().lint_groups.get(&lint_name[..]) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -460,35 +465,90 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             };\n \n             for (lint_id, level, span) in v {\n-                let now = self.lints.get_level_source(lint_id).0;\n+                let now = self.lints().get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n-                    span_err!(self.tcx.sess, span, E0453,\n+                    span_err!(self.sess(), span, E0453,\n                               \"{}({}) overruled by outer forbid({})\",\n                               level.as_str(), lint_name,\n                               lint_name);\n                 } else if now != level {\n-                    let src = self.lints.get_level_source(lint_id).1;\n-                    self.level_stack.push((lint_id, (now, src)));\n+                    let src = self.lints().get_level_source(lint_id).1;\n+                    self.level_stack().push((lint_id, (now, src)));\n                     pushed += 1;\n-                    self.lints.set_level(lint_id, (level, Node(span)));\n+                    self.mut_lints().set_level(lint_id, (level, Node(span)));\n                 }\n             }\n         }\n \n-        run_lints!(self, enter_lint_attrs, attrs);\n+        self.enter_attrs(attrs);\n         f(self);\n-        run_lints!(self, exit_lint_attrs, attrs);\n+        self.exit_attrs(attrs);\n \n         // rollback\n         for _ in 0..pushed {\n-            let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n-            self.lints.set_level(lint, lvlsrc);\n+            let (lint, lvlsrc) = self.level_stack().pop().unwrap();\n+            self.mut_lints().set_level(lint, lvlsrc);\n+        }\n+    }\n+\n+    fn with_ast_lint_attrs<F>(&mut self,\n+                          attrs: &[ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self),\n+    {\n+        self.with_lint_attrs(&lower_attrs(attrs), f)\n+    }\n+}\n+\n+\n+impl<'a> EarlyContext<'a> {\n+    fn new(sess: &'a Session,\n+           krate: &'a ast::Crate) -> EarlyContext<'a> {\n+        // We want to own the lint store, so move it out of the session.\n+        let lint_store = mem::replace(&mut *sess.lint_store.borrow_mut(),\n+                                      LintStore::new());\n+\n+        EarlyContext {\n+            sess: sess,\n+            krate: krate,\n+            lints: lint_store,\n+            level_stack: vec![],\n         }\n     }\n \n-    fn visit_ids<F>(&mut self, f: F) where\n-        F: FnOnce(&mut util::IdVisitor<Context>)\n+    fn visit_ids<F>(&mut self, f: F)\n+        where F: FnOnce(&mut ast_util::IdVisitor<EarlyContext>)\n+    {\n+        let mut v = ast_util::IdVisitor {\n+            operation: self,\n+            pass_through_items: false,\n+            visited_outermost: false,\n+        };\n+        f(&mut v);\n+    }\n+}\n+\n+impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n+           krate: &'a hir::Crate,\n+           exported_items: &'a ExportedItems) -> LateContext<'a, 'tcx> {\n+        // We want to own the lint store, so move it out of the session.\n+        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n+                                      LintStore::new());\n+\n+        LateContext {\n+            tcx: tcx,\n+            krate: krate,\n+            exported_items: exported_items,\n+            lints: lint_store,\n+            level_stack: vec![],\n+            node_levels: RefCell::new(FnvHashMap()),\n+        }\n+    }\n+\n+    fn visit_ids<F>(&mut self, f: F)\n+        where F: FnOnce(&mut util::IdVisitor<LateContext>)\n     {\n         let mut v = util::IdVisitor {\n             operation: self,\n@@ -499,41 +559,95 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n+impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n+    /// Get the overall compiler `Session` object.\n+    fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn lints(&self) -> &LintStore {\n+        &self.lints\n+    }\n+\n+    fn mut_lints(&mut self) -> &mut LintStore {\n+        &mut self.lints\n+    }\n+\n+    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)> {\n+        &mut self.level_stack\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &[hir::Attribute]) {\n+        run_lints!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &[hir::Attribute]) {\n+        run_lints!(self, exit_lint_attrs, attrs);\n+    }\n+}\n+\n+impl<'a> LintContext for EarlyContext<'a> {\n+    /// Get the overall compiler `Session` object.\n+    fn sess(&self) -> &Session {\n+        &self.sess\n+    }\n+\n+    fn lints(&self) -> &LintStore {\n+        &self.lints\n+    }\n+\n+    fn mut_lints(&mut self) -> &mut LintStore {\n+        &mut self.lints\n+    }\n+\n+    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)> {\n+        &mut self.level_stack\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &[hir::Attribute]) {\n+        run_lints!(self, ast_enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &[hir::Attribute]) {\n+        run_lints!(self, ast_exit_lint_attrs, attrs);\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     fn visit_item(&mut self, it: &hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n-            visit::walk_item(cx, it);\n+            hir_visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, it);\n-            visit::walk_foreign_item(cx, it);\n+            hir_visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_pat(&mut self, p: &hir::Pat) {\n         run_lints!(self, check_pat, p);\n-        visit::walk_pat(self, p);\n+        hir_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n         run_lints!(self, check_expr, e);\n-        visit::walk_expr(self, e);\n+        hir_visit::walk_expr(self, e);\n     }\n \n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n         run_lints!(self, check_stmt, s);\n-        visit::walk_stmt(self, s);\n+        hir_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n                 body: &'v hir::Block, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, fk, decl, body, span, id);\n-        visit::walk_fn(self, fk, decl, body, span);\n+        hir_visit::walk_fn(self, fk, decl, body, span);\n     }\n \n     fn visit_struct_def(&mut self,\n@@ -542,28 +656,28 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                         g: &hir::Generics,\n                         id: ast::NodeId) {\n         run_lints!(self, check_struct_def, s, ident, g, id);\n-        visit::walk_struct_def(self, s);\n+        hir_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, s, ident, g, id);\n     }\n \n     fn visit_struct_field(&mut self, s: &hir::StructField) {\n         self.with_lint_attrs(&s.node.attrs, |cx| {\n             run_lints!(cx, check_struct_field, s);\n-            visit::walk_struct_field(cx, s);\n+            hir_visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n-            visit::walk_variant(cx, v, g);\n+            hir_visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n         run_lints!(self, check_ty, t);\n-        visit::walk_ty(self, t);\n+        hir_visit::walk_ty(self, t);\n     }\n \n     fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n@@ -572,27 +686,27 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, m, s, n);\n-        visit::walk_mod(self, m);\n+        hir_visit::walk_mod(self, m);\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n         run_lints!(self, check_local, l);\n-        visit::walk_local(self, l);\n+        hir_visit::walk_local(self, l);\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {\n         run_lints!(self, check_block, b);\n-        visit::walk_block(self, b);\n+        hir_visit::walk_block(self, b);\n     }\n \n     fn visit_arm(&mut self, a: &hir::Arm) {\n         run_lints!(self, check_arm, a);\n-        visit::walk_arm(self, a);\n+        hir_visit::walk_arm(self, a);\n     }\n \n     fn visit_decl(&mut self, d: &hir::Decl) {\n         run_lints!(self, check_decl, d);\n-        visit::walk_decl(self, d);\n+        hir_visit::walk_decl(self, d);\n     }\n \n     fn visit_expr_post(&mut self, e: &hir::Expr) {\n@@ -601,22 +715,22 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_generics(&mut self, g: &hir::Generics) {\n         run_lints!(self, check_generics, g);\n-        visit::walk_generics(self, g);\n+        hir_visit::walk_generics(self, g);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, trait_item);\n             cx.visit_ids(|v| v.visit_trait_item(trait_item));\n-            visit::walk_trait_item(cx, trait_item);\n+            hir_visit::walk_trait_item(cx, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, impl_item);\n             cx.visit_ids(|v| v.visit_impl_item(impl_item));\n-            visit::walk_impl_item(cx, impl_item);\n+            hir_visit::walk_impl_item(cx, impl_item);\n         });\n     }\n \n@@ -634,23 +748,183 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_explicit_self(&mut self, es: &hir::ExplicitSelf) {\n         run_lints!(self, check_explicit_self, es);\n-        visit::walk_explicit_self(self, es);\n+        hir_visit::walk_explicit_self(self, es);\n     }\n \n     fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, p, id);\n-        visit::walk_path(self, p);\n+        hir_visit::walk_path(self, p);\n     }\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         run_lints!(self, check_attribute, attr);\n     }\n }\n \n+impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n+    fn visit_item(&mut self, it: &ast::Item) {\n+        self.with_ast_lint_attrs(&it.attrs, |cx| {\n+            run_lints!(cx, check_ast_item, it);\n+            cx.visit_ids(|v| v.visit_item(it));\n+            ast_visit::walk_item(cx, it);\n+        })\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n+        self.with_ast_lint_attrs(&it.attrs, |cx| {\n+            run_lints!(cx, check_ast_foreign_item, it);\n+            ast_visit::walk_foreign_item(cx, it);\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        run_lints!(self, check_ast_pat, p);\n+        ast_visit::walk_pat(self, p);\n+    }\n+\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n+        run_lints!(self, check_ast_expr, e);\n+        ast_visit::walk_expr(self, e);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        run_lints!(self, check_ast_stmt, s);\n+        ast_visit::walk_stmt(self, s);\n+    }\n+\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, decl: &'v ast::FnDecl,\n+                body: &'v ast::Block, span: Span, id: ast::NodeId) {\n+        run_lints!(self, check_ast_fn, fk, decl, body, span, id);\n+        ast_visit::walk_fn(self, fk, decl, body, span);\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        s: &ast::StructDef,\n+                        ident: ast::Ident,\n+                        g: &ast::Generics,\n+                        id: ast::NodeId) {\n+        run_lints!(self, check_ast_struct_def, s, ident, g, id);\n+        ast_visit::walk_struct_def(self, s);\n+        run_lints!(self, check_ast_struct_def_post, s, ident, g, id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+        self.with_ast_lint_attrs(&s.node.attrs, |cx| {\n+            run_lints!(cx, check_ast_struct_field, s);\n+            ast_visit::walk_struct_field(cx, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n+        self.with_ast_lint_attrs(&v.node.attrs, |cx| {\n+            run_lints!(cx, check_ast_variant, v, g);\n+            ast_visit::walk_variant(cx, v, g);\n+            run_lints!(cx, check_ast_variant_post, v, g);\n+        })\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        run_lints!(self, check_ast_ty, t);\n+        ast_visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n+        run_lints!(self, check_ast_ident, sp, id);\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId) {\n+        run_lints!(self, check_ast_mod, m, s, n);\n+        ast_visit::walk_mod(self, m);\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local) {\n+        run_lints!(self, check_ast_local, l);\n+        ast_visit::walk_local(self, l);\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block) {\n+        run_lints!(self, check_ast_block, b);\n+        ast_visit::walk_block(self, b);\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n+        run_lints!(self, check_ast_arm, a);\n+        ast_visit::walk_arm(self, a);\n+    }\n+\n+    fn visit_decl(&mut self, d: &ast::Decl) {\n+        run_lints!(self, check_ast_decl, d);\n+        ast_visit::walk_decl(self, d);\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &ast::Expr) {\n+        run_lints!(self, check_ast_expr_post, e);\n+    }\n+\n+    fn visit_generics(&mut self, g: &ast::Generics) {\n+        run_lints!(self, check_ast_generics, g);\n+        ast_visit::walk_generics(self, g);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        self.with_ast_lint_attrs(&trait_item.attrs, |cx| {\n+            run_lints!(cx, check_ast_trait_item, trait_item);\n+            cx.visit_ids(|v| v.visit_trait_item(trait_item));\n+            ast_visit::walk_trait_item(cx, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        self.with_ast_lint_attrs(&impl_item.attrs, |cx| {\n+            run_lints!(cx, check_ast_impl_item, impl_item);\n+            cx.visit_ids(|v| v.visit_impl_item(impl_item));\n+            ast_visit::walk_impl_item(cx, impl_item);\n+        });\n+    }\n+\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {\n+        run_lints!(self, check_ast_opt_lifetime_ref, sp, lt);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime) {\n+        run_lints!(self, check_ast_lifetime_ref, lt);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {\n+        run_lints!(self, check_ast_lifetime_def, lt);\n+    }\n+\n+    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {\n+        run_lints!(self, check_ast_explicit_self, es);\n+        ast_visit::walk_explicit_self(self, es);\n+    }\n+\n+    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n+        run_lints!(self, check_ast_path, p, id);\n+        ast_visit::walk_path(self, p);\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        run_lints!(self, check_ast_attribute, attr);\n+    }\n+}\n+\n // Output any lints that were previously added to the session.\n-impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n+impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n+        match self.sess().lints.borrow_mut().remove(&id) {\n+            None => {}\n+            Some(lints) => {\n+                for (lint_id, span, msg) in lints {\n+                    self.span_lint(lint_id.lint, span, &msg[..])\n+                }\n+            }\n+        }\n+    }\n+}\n+impl<'a> IdVisitingOperation for EarlyContext<'a> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.borrow_mut().remove(&id) {\n+        match self.sess.lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints {\n@@ -661,7 +935,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n     }\n }\n \n-// This lint pass is defined here because it touches parts of the `Context`\n+// This lint pass is defined here because it touches parts of the `LateContext`\n // that we don't want to expose. It records the lint level at certain AST\n // nodes, so that the variant size difference check in trans can call\n // `raw_emit_lint`.\n@@ -673,7 +947,7 @@ impl LintPass for GatherNodeLevels {\n         lint_array!()\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemEnum(..) => {\n                 let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n@@ -698,21 +972,21 @@ pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &hir::Crate,\n                    exported_items: &ExportedItems) {\n \n-    let mut cx = Context::new(tcx, krate, exported_items);\n+    let mut cx = LateContext::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n-            visit::walk_crate(v, krate);\n+            hir_visit::walk_crate(v, krate);\n         });\n \n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         run_lints!(cx, check_crate, krate);\n \n-        visit::walk_crate(cx, krate);\n+        hir_visit::walk_crate(cx, krate);\n     });\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n@@ -727,3 +1001,35 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n }\n+\n+pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n+    let mut cx = EarlyContext::new(sess, krate);\n+\n+    // Visit the whole crate.\n+    cx.with_ast_lint_attrs(&krate.attrs, |cx| {\n+        cx.visit_id(ast::CRATE_NODE_ID);\n+        cx.visit_ids(|v| {\n+            v.visited_outermost = true;\n+            ast_visit::walk_crate(v, krate);\n+        });\n+\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_lints!(cx, check_ast_crate, krate);\n+\n+        ast_visit::walk_crate(cx, krate);\n+    });\n+\n+    // Put the lint store back in the session.\n+    mem::replace(&mut *sess.lint_store.borrow_mut(), cx.lints);\n+\n+    // If we missed any lints added to the session, then there's a bug somewhere\n+    // in the iteration code.\n+    for (_, v) in sess.lints.borrow().iter() {\n+        for &(lint, span, ref msg) in v {\n+            sess.span_bug(span,\n+                          &format!(\"unprocessed lint {}: {}\",\n+                                   lint.as_str(), *msg))\n+        }\n+    }\n+}"}, {"sha": "d30f8f3c53ad2a27580c9192fbb864baa3d4cf42", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 81, "deletions": 33, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -35,10 +35,12 @@ use std::hash;\n use std::ascii::AsciiExt;\n use syntax::codemap::Span;\n use rustc_front::visit::FnKind;\n+use syntax::visit as ast_visit;\n use syntax::ast;\n use rustc_front::hir;\n \n-pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs,\n+pub use lint::context::{LateContext, EarlyContext, Context, LintContext, LintStore,\n+                        raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n                         GatherNodeLevels};\n \n /// Specification of a single lint.\n@@ -126,46 +128,92 @@ pub trait LintPass {\n     /// `Lint`, make it a private `static` item in its own module.\n     fn get_lints(&self) -> LintArray;\n \n-    fn check_crate(&mut self, _: &Context, _: &hir::Crate) { }\n-    fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n-    fn check_mod(&mut self, _: &Context, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_foreign_item(&mut self, _: &Context, _: &hir::ForeignItem) { }\n-    fn check_item(&mut self, _: &Context, _: &hir::Item) { }\n-    fn check_local(&mut self, _: &Context, _: &hir::Local) { }\n-    fn check_block(&mut self, _: &Context, _: &hir::Block) { }\n-    fn check_stmt(&mut self, _: &Context, _: &hir::Stmt) { }\n-    fn check_arm(&mut self, _: &Context, _: &hir::Arm) { }\n-    fn check_pat(&mut self, _: &Context, _: &hir::Pat) { }\n-    fn check_decl(&mut self, _: &Context, _: &hir::Decl) { }\n-    fn check_expr(&mut self, _: &Context, _: &hir::Expr) { }\n-    fn check_expr_post(&mut self, _: &Context, _: &hir::Expr) { }\n-    fn check_ty(&mut self, _: &Context, _: &hir::Ty) { }\n-    fn check_generics(&mut self, _: &Context, _: &hir::Generics) { }\n-    fn check_fn(&mut self, _: &Context,\n+    fn check_ident(&mut self, _: &LateContext, _: Span, _: ast::Ident) { }\n+    fn check_crate(&mut self, _: &LateContext, _: &hir::Crate) { }\n+    fn check_mod(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_foreign_item(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n+    fn check_item(&mut self, _: &LateContext, _: &hir::Item) { }\n+    fn check_local(&mut self, _: &LateContext, _: &hir::Local) { }\n+    fn check_block(&mut self, _: &LateContext, _: &hir::Block) { }\n+    fn check_stmt(&mut self, _: &LateContext, _: &hir::Stmt) { }\n+    fn check_arm(&mut self, _: &LateContext, _: &hir::Arm) { }\n+    fn check_pat(&mut self, _: &LateContext, _: &hir::Pat) { }\n+    fn check_decl(&mut self, _: &LateContext, _: &hir::Decl) { }\n+    fn check_expr(&mut self, _: &LateContext, _: &hir::Expr) { }\n+    fn check_expr_post(&mut self, _: &LateContext, _: &hir::Expr) { }\n+    fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n+    fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n+    fn check_fn(&mut self, _: &LateContext,\n         _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n-    fn check_trait_item(&mut self, _: &Context, _: &hir::TraitItem) { }\n-    fn check_impl_item(&mut self, _: &Context, _: &hir::ImplItem) { }\n-    fn check_struct_def(&mut self, _: &Context,\n+    fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n+    fn check_struct_def(&mut self, _: &LateContext,\n         _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_def_post(&mut self, _: &Context,\n+    fn check_struct_def_post(&mut self, _: &LateContext,\n         _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_field(&mut self, _: &Context, _: &hir::StructField) { }\n-    fn check_variant(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_variant_post(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<hir::Lifetime>) { }\n-    fn check_lifetime_ref(&mut self, _: &Context, _: &hir::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &Context, _: &hir::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &Context, _: &hir::ExplicitSelf) { }\n-    fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n-    fn check_path(&mut self, _: &Context, _: &hir::Path, _: ast::NodeId) { }\n-    fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n+    fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n+    fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n+    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n+    fn check_opt_lifetime_ref(&mut self, _: &LateContext, _: Span, _: &Option<hir::Lifetime>) { }\n+    fn check_lifetime_ref(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n+    fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n+    fn check_explicit_self(&mut self, _: &LateContext, _: &hir::ExplicitSelf) { }\n+    // Note that you shouldn't implement both check_mac and check_ast_mac,\n+    // because then your lint will be called twice. Prefer check_ast_mac.\n+    fn check_mac(&mut self, _: &LateContext, _: &ast::Mac) { }\n+    fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n+\n+    fn check_ast_ident(&mut self, _: &EarlyContext, _: Span, _: ast::Ident) { }\n+    fn check_ast_crate(&mut self, _: &EarlyContext, _: &ast::Crate) { }\n+    fn check_ast_mod(&mut self, _: &EarlyContext, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_ast_foreign_item(&mut self, _: &EarlyContext, _: &ast::ForeignItem) { }\n+    fn check_ast_item(&mut self, _: &EarlyContext, _: &ast::Item) { }\n+    fn check_ast_local(&mut self, _: &EarlyContext, _: &ast::Local) { }\n+    fn check_ast_block(&mut self, _: &EarlyContext, _: &ast::Block) { }\n+    fn check_ast_stmt(&mut self, _: &EarlyContext, _: &ast::Stmt) { }\n+    fn check_ast_arm(&mut self, _: &EarlyContext, _: &ast::Arm) { }\n+    fn check_ast_pat(&mut self, _: &EarlyContext, _: &ast::Pat) { }\n+    fn check_ast_decl(&mut self, _: &EarlyContext, _: &ast::Decl) { }\n+    fn check_ast_expr(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n+    fn check_ast_expr_post(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n+    fn check_ast_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n+    fn check_ast_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n+    fn check_ast_fn(&mut self, _: &EarlyContext,\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+    fn check_ast_trait_item(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n+    fn check_ast_impl_item(&mut self, _: &EarlyContext, _: &ast::ImplItem) { }\n+    fn check_ast_struct_def(&mut self, _: &EarlyContext,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_ast_struct_def_post(&mut self, _: &EarlyContext,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_ast_struct_field(&mut self, _: &EarlyContext, _: &ast::StructField) { }\n+    fn check_ast_variant(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n+    fn check_ast_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n+    fn check_ast_opt_lifetime_ref(&mut self,\n+                                  _: &EarlyContext,\n+                                  _: Span,\n+                                  _: &Option<ast::Lifetime>) { }\n+    fn check_ast_lifetime_ref(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n+    fn check_ast_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n+    fn check_ast_explicit_self(&mut self, _: &EarlyContext, _: &ast::ExplicitSelf) { }\n+    fn check_ast_mac(&mut self, _: &EarlyContext, _: &ast::Mac) { }\n+    fn check_ast_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }\n+    fn check_ast_attribute(&mut self, _: &EarlyContext, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such\n     /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+    fn enter_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n \n     /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+\n+    /// Called when entering a syntax node that can have lint attributes such\n+    /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n+    fn ast_enter_lint_attrs(&mut self, _: &EarlyContext, _: &[ast::Attribute]) { }\n+\n+    /// Counterpart to `ast_enter_lint_attrs`.\n+    fn ast_exit_lint_attrs(&mut self, _: &EarlyContext, _: &[ast::Attribute]) { }\n }\n \n /// A lint pass boxed up as a trait object."}, {"sha": "ca7ce2308a1cbd86b427f5edd53ad73db4d45f01", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -89,7 +89,6 @@ impl<'a> Registry<'a> {\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n-    #[allow(deprecated)]\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n         self.syntax_exts.push((name, match extension {\n             NormalTT(ext, _, allow_internal_unstable) => {"}, {"sha": "4ec13ba35993d0a1e54bd813eb5a26439b6be06e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -132,7 +132,6 @@ pub fn compile_input(sess: Session,\n \n         phase_3_run_analysis_passes(sess,\n                                     ast_map,\n-                                    &expanded_crate,\n                                     &arenas,\n                                     id,\n                                     control.make_glob_map,\n@@ -598,6 +597,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         sess.abort_if_errors();\n     });\n \n+    time(time_passes, \"early lint checks\", || {\n+        lint::check_ast_crate(sess, &krate)\n+    });\n+\n     Some(krate)\n }\n \n@@ -641,7 +644,6 @@ pub fn make_map<'ast>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                                                ast_map: front::map::Map<'tcx>,\n-                                               ast_crate: &ast::Crate,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: String,\n                                                make_glob_map: resolve::MakeGlobMap,\n@@ -765,7 +767,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                 &tcx.sess, lib_features_used));\n \n         time(time_passes, \"lint checking\", ||\n-            lint::check_crate(tcx, &lower_crate(ast_crate), &exported_items));\n+            lint::check_crate(tcx, krate, &exported_items));\n \n         // The above three passes generate errors w/o aborting\n         tcx.sess.abort_if_errors();"}, {"sha": "75b57341d48dfcc88de5cec39806486c537666ac", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -157,7 +157,6 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n-                                               ast_crate: &ast::Crate,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: String,\n                                                payload: B,\n@@ -180,7 +179,6 @@ impl PpSourceMode {\n             PpmTyped => {\n                 driver::phase_3_run_analysis_passes(sess,\n                                                     ast_map.clone(),\n-                                                    ast_crate,\n                                                     arenas,\n                                                     id,\n                                                     resolve::MakeGlobMap::No,\n@@ -715,7 +713,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(\n-                sess, &ast_map.unwrap(), &krate, &arenas, id, box out, |annotation, out, krate| {\n+                sess, &ast_map.unwrap(), &arenas, id, box out, |annotation, out, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust_hir::print_crate(sess.codemap(),\n@@ -733,7 +731,6 @@ pub fn pretty_print_input(sess: Session,\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(sess,\n                                        &ast_map.unwrap(),\n-                                       &krate,\n                                        &arenas,\n                                        id,\n                                        (out,uii),\n@@ -782,7 +779,6 @@ pub fn pretty_print_input(sess: Session,\n                     let variants = gather_flowgraph_variants(&sess);\n                     driver::phase_3_run_analysis_passes(sess,\n                                                         ast_map,\n-                                                        &krate,\n                                                         &arenas,\n                                                         id,\n                                                         resolve::MakeGlobMap::No,"}, {"sha": "c092049258c9b364a6b9ef02e335b7747ac1b340", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 85, "deletions": 84, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -38,7 +38,7 @@ use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n-use lint::{Level, Context, LintPass, LintArray, Lint};\n+use lint::{Level, LateContext, LintContext, LintPass, LintArray, Lint};\n \n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -73,7 +73,7 @@ impl LintPass for WhileTrue {\n         lint_array!(WHILE_TRUE)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprWhile(ref cond, _, _) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n                 if let ast::LitBool(true) = lit.node {\n@@ -122,7 +122,7 @@ impl LintPass for TypeLimits {\n         lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 match expr.node  {\n@@ -377,7 +377,7 @@ impl LintPass for TypeLimits {\n             }\n         }\n \n-        fn check_unsigned_negation_feature(cx: &Context, span: Span) {\n+        fn check_unsigned_negation_feature(cx: &LateContext, span: Span) {\n             if !cx.sess().features.borrow().negate_unsigned {\n                 // FIXME(#27141): change this to syntax::feature_gate::emit_feature_err\u2026\n                 cx.sess().span_warn(span,\n@@ -398,7 +398,7 @@ declare_lint! {\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n-    cx: &'a Context<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>\n }\n \n enum FfiResult {\n@@ -703,13 +703,13 @@ impl LintPass for ImproperCTypes {\n         lint_array!(IMPROPER_CTYPES)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n-        fn check_ty(cx: &Context, ty: &hir::Ty) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        fn check_ty(cx: &LateContext, ty: &hir::Ty) {\n             let mut vis = ImproperCTypesVisitor { cx: cx };\n             vis.visit_ty(ty);\n         }\n \n-        fn check_foreign_fn(cx: &Context, decl: &hir::FnDecl) {\n+        fn check_foreign_fn(cx: &LateContext, decl: &hir::FnDecl) {\n             for input in &decl.inputs {\n                 check_ty(cx, &*input.ty);\n             }\n@@ -747,7 +747,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n         for leaf_ty in ty.walk() {\n             if let ty::TyBox(_) = leaf_ty.sty {\n@@ -763,7 +763,7 @@ impl LintPass for BoxPointers {\n         lint_array!(BOX_POINTERS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(..) |\n             hir::ItemTy(..) |\n@@ -786,7 +786,7 @@ impl LintPass for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         let ty = cx.tcx.node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -799,7 +799,7 @@ declare_lint! {\n }\n \n struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n-    cx: &'a Context<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n@@ -832,7 +832,7 @@ impl LintPass for RawPointerDerive {\n         lint_array!(RAW_POINTER_DERIVE)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n             return;\n         }\n@@ -888,7 +888,7 @@ impl LintPass for UnusedAttributes {\n         lint_array!(UNUSED_ATTRIBUTES)\n     }\n \n-    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n             match ty {\n@@ -948,7 +948,7 @@ impl LintPass for PathStatements {\n         lint_array!(PATH_STATEMENTS)\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         match s.node {\n             hir::StmtSemi(ref expr, _) => {\n                 match expr.node {\n@@ -982,7 +982,7 @@ impl LintPass for UnusedResults {\n         lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtSemi(ref expr, _) => &**expr,\n             _ => return\n@@ -1015,7 +1015,7 @@ impl LintPass for UnusedResults {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n+        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n             for attr in attrs {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n@@ -1046,7 +1046,7 @@ declare_lint! {\n pub struct NonCamelCaseTypes;\n \n impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = ident.name.as_str();\n             if ident.is_empty() {\n@@ -1088,7 +1088,7 @@ impl LintPass for NonCamelCaseTypes {\n         lint_array!(NON_CAMEL_CASE_TYPES)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let extern_repr_count = it.attrs.iter().filter(|attr| {\n             attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n                 .any(|r| r == &attr::ReprExtern)\n@@ -1119,29 +1119,29 @@ impl LintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_generics(&mut self, cx: &Context, it: &hir::Generics) {\n+    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n             self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n         }\n     }\n }\n \n #[derive(PartialEq)]\n-enum MethodContext {\n+enum MethodLateContext {\n     TraitDefaultImpl,\n     TraitImpl,\n     PlainImpl\n }\n \n-fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n+fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n         None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n         Some(item) => match item.container() {\n-            ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n             ty::ImplContainer(cid) => {\n                 match cx.tcx.impl_trait_ref(cid) {\n-                    Some(_) => MethodContext::TraitImpl,\n-                    None => MethodContext::PlainImpl\n+                    Some(_) => MethodLateContext::TraitImpl,\n+                    None => MethodLateContext::PlainImpl\n                 }\n             }\n         }\n@@ -1190,7 +1190,7 @@ impl NonSnakeCase {\n         words.join(\"_\")\n     }\n \n-    fn check_snake_case(&self, cx: &Context, sort: &str, name: &str, span: Option<Span>) {\n+    fn check_snake_case(&self, cx: &LateContext, sort: &str, name: &str, span: Option<Span>) {\n         fn is_snake_case(ident: &str) -> bool {\n             if ident.is_empty() {\n                 return true;\n@@ -1234,7 +1234,7 @@ impl LintPass for NonSnakeCase {\n         lint_array!(NON_SNAKE_CASE)\n     }\n \n-    fn check_crate(&mut self, cx: &Context, cr: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n         let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n                                       .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n@@ -1244,15 +1244,15 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context,\n+    fn check_fn(&mut self, cx: &LateContext,\n                 fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n-                MethodContext::PlainImpl => {\n+                MethodLateContext::PlainImpl => {\n                     self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n                 },\n-                MethodContext::TraitDefaultImpl => {\n+                MethodLateContext::TraitDefaultImpl => {\n                     self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n                 },\n                 _ => (),\n@@ -1264,25 +1264,25 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemMod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n             self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n \n-    fn check_lifetime_def(&mut self, cx: &Context, t: &hir::LifetimeDef) {\n+    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n         self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n-    fn check_pat(&mut self, cx: &Context, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &hir::PatIdent(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(def::DefLocal(_)) = def {\n@@ -1291,7 +1291,7 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &Context, s: &hir::StructDef,\n+    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n                         _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n             if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n@@ -1312,7 +1312,7 @@ declare_lint! {\n pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n         let s = ident.name.as_str();\n \n         if s.chars().any(|c| c.is_lowercase()) {\n@@ -1335,7 +1335,7 @@ impl LintPass for NonUpperCaseGlobals {\n         lint_array!(NON_UPPER_CASE_GLOBALS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             // only check static constants\n             hir::ItemStatic(_, hir::MutImmutable, _) => {\n@@ -1348,7 +1348,7 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, ti: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n@@ -1358,7 +1358,7 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, ii: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ConstImplItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n@@ -1368,7 +1368,7 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &Context, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n             (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n@@ -1390,7 +1390,7 @@ declare_lint! {\n pub struct UnusedParens;\n \n impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &Context, value: &hir::Expr, msg: &str,\n+    fn check_unused_parens_core(&self, cx: &LateContext, value: &hir::Expr, msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let hir::ExprParen(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n@@ -1441,7 +1441,7 @@ impl LintPass for UnusedParens {\n         lint_array!(UNUSED_PARENS)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n             hir::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n             hir::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n@@ -1459,7 +1459,7 @@ impl LintPass for UnusedParens {\n         self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let (value, msg) = match s.node {\n             hir::StmtDecl(ref decl, _) => match decl.node {\n                 hir::DeclLocal(ref local) => match local.init {\n@@ -1488,7 +1488,7 @@ impl LintPass for UnusedImportBraces {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUse(ref view_path) = item.node {\n             if let hir::ViewPathList(_, ref items) = view_path.node {\n                 if items.len() == 1 {\n@@ -1518,7 +1518,7 @@ impl LintPass for NonShorthandFieldPatterns {\n         lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n     }\n \n-    fn check_pat(&mut self, cx: &Context, pat: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n         if let hir::PatStruct(_, ref v, _) = pat.node {\n             let field_pats = v.iter().filter(|fieldpat| {\n@@ -1557,7 +1557,7 @@ impl LintPass for UnusedUnsafe {\n         lint_array!(UNUSED_UNSAFE)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n@@ -1582,7 +1582,7 @@ impl LintPass for UnsafeCode {\n         lint_array!(UNSAFE_CODE)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n@@ -1591,7 +1591,7 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemTrait(hir::Unsafety::Unsafe, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n@@ -1603,7 +1603,7 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fk: FnKind, _: &hir::FnDecl,\n+    fn check_fn(&mut self, cx: &LateContext, fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, _: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, _, _, _) =>\n@@ -1619,7 +1619,7 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE, trait_item.span,\n@@ -1639,7 +1639,7 @@ declare_lint! {\n pub struct UnusedMut;\n \n impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<hir::Pat>]) {\n+    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n@@ -1673,23 +1673,23 @@ impl LintPass for UnusedMut {\n         lint_array!(UNUSED_MUT)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n                 self.check_unused_mut_pat(cx, &a.pats)\n             }\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtDecl(ref d, _) = s.node {\n             if let hir::DeclLocal(ref l) = d.node {\n                 self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n             }\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context,\n+    fn check_fn(&mut self, cx: &LateContext,\n                 _: FnKind, decl: &hir::FnDecl,\n                 _: &hir::Block, _: Span, _: ast::NodeId) {\n         for a in &decl.inputs {\n@@ -1712,7 +1712,7 @@ impl LintPass for UnusedAllocation {\n         lint_array!(UNUSED_ALLOCATION)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnUniq, _) => (),\n             _ => return\n@@ -1774,7 +1774,7 @@ impl MissingDoc {\n     }\n \n     fn check_missing_docs_attrs(&self,\n-                               cx: &Context,\n+                               cx: &LateContext,\n                                id: Option<ast::NodeId>,\n                                attrs: &[ast::Attribute],\n                                sp: Span,\n@@ -1817,7 +1817,7 @@ impl LintPass for MissingDoc {\n         lint_array!(MISSING_DOCS)\n     }\n \n-    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n@@ -1827,26 +1827,26 @@ impl LintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &Context, _: &hir::StructDef,\n+    fn check_struct_def(&mut self, _: &LateContext, _: &hir::StructDef,\n                         _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n         self.struct_def_stack.push(id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &Context, _: &hir::StructDef,\n+    fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::StructDef,\n                              _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == id);\n     }\n \n-    fn check_crate(&mut self, cx: &Context, krate: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let desc = match it.node {\n             hir::ItemFn(..) => \"a function\",\n             hir::ItemMod(..) => \"a module\",\n@@ -1886,7 +1886,7 @@ impl LintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if self.private_traits.contains(&trait_item.id) { return }\n \n         let desc = match trait_item.node {\n@@ -1900,9 +1900,9 @@ impl LintPass for MissingDoc {\n                                       trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.id, impl_item.span) == MethodContext::TraitImpl {\n+        if method_context(cx, impl_item.id, impl_item.span) == MethodLateContext::TraitImpl {\n             return;\n         }\n \n@@ -1916,7 +1916,7 @@ impl LintPass for MissingDoc {\n                                       impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &Context, sf: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n         if let hir::NamedField(_, vis) = sf.node.kind {\n             if vis == hir::Public || self.in_variant {\n                 let cur_struct_def = *self.struct_def_stack.last()\n@@ -1928,13 +1928,13 @@ impl LintPass for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &Context, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs, v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n \n-    fn check_variant_post(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) {\n         assert!(self.in_variant);\n         self.in_variant = false;\n     }\n@@ -1954,7 +1954,7 @@ impl LintPass for MissingCopyImplementations {\n         lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n@@ -2016,7 +2016,7 @@ impl LintPass for MissingDebugImplementations {\n         lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n@@ -2066,7 +2066,7 @@ declare_lint! {\n pub struct Stability;\n \n impl Stability {\n-    fn lint(&self, cx: &Context, _id: DefId,\n+    fn lint(&self, cx: &LateContext, _id: DefId,\n             span: Span, stability: &Option<&attr::Stability>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n@@ -2077,7 +2077,7 @@ impl Stability {\n \n         output(cx, span, stability, lint, label);\n \n-        fn output(cx: &Context, span: Span, stability: &Option<&attr::Stability>,\n+        fn output(cx: &LateContext, span: Span, stability: &Option<&attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n                 Some(&attr::Stability { reason: Some(ref s), .. }) => {\n@@ -2110,28 +2110,28 @@ impl LintPass for Stability {\n         lint_array!(DEPRECATED)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         stability::check_item(cx.tcx, item, false,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_path(&mut self, cx: &Context, path: &hir::Path, id: ast::NodeId) {\n+    fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n         stability::check_path(cx.tcx, path, id,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_pat(&mut self, cx: &Context, pat: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         stability::check_pat(cx.tcx, pat,\n                              &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n@@ -2154,7 +2154,7 @@ impl LintPass for UnconditionalRecursion {\n         lint_array![UNCONDITIONAL_RECURSION]\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fn_kind: FnKind, _: &hir::FnDecl,\n+    fn check_fn(&mut self, cx: &LateContext, fn_kind: FnKind, _: &hir::FnDecl,\n                 blk: &hir::Block, sp: Span, id: ast::NodeId) {\n         type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n@@ -2401,7 +2401,7 @@ impl LintPass for PluginAsLibrary {\n         lint_array![PLUGIN_AS_LIBRARY]\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if cx.sess().plugin_registrar_fn.get().is_some() {\n             // We're compiling a plugin; it's fine to link other plugins.\n             return;\n@@ -2457,7 +2457,7 @@ impl LintPass for InvalidNoMangleItems {\n                     NO_MANGLE_CONST_ITEMS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n@@ -2503,7 +2503,7 @@ impl LintPass for MutableTransmutes {\n         lint_array!(MUTABLE_TRANSMUTES)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         use syntax::abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n@@ -2518,7 +2518,7 @@ impl LintPass for MutableTransmutes {\n             _ => ()\n         }\n \n-        fn get_transmute_from_to<'a, 'tcx>(cx: &Context<'a, 'tcx>, expr: &hir::Expr)\n+        fn get_transmute_from_to<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr)\n             -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n                 hir::ExprPath(..) => (),\n@@ -2542,7 +2542,7 @@ impl LintPass for MutableTransmutes {\n             None\n         }\n \n-        fn def_id_is_transmute(cx: &Context, def_id: DefId) -> bool {\n+        fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n             match cx.tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyBareFn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n@@ -2569,7 +2569,8 @@ impl LintPass for UnstableFeatures {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n-    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n+\n+    fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n         if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n             if let Some(items) = attr.node.value.meta_item_list() {\n                 for item in items {\n@@ -2595,7 +2596,7 @@ impl LintPass for DropWithReprExtern {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DROP_WITH_REPR_EXTERN)\n     }\n-    fn check_crate(&mut self, ctx: &Context, _: &hir::Crate) {\n+    fn check_crate(&mut self, ctx: &LateContext, _: &hir::Crate) {\n         for dtor_did in ctx.tcx.destructors.borrow().iter() {\n             let (drop_impl_did, dtor_self_type) =\n                 if dtor_did.is_local() {"}, {"sha": "d7238c827ab57506b6fcd3e48496b3511c77da62", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76856e19ff3c7c699931d0acee8e61bc0dfec512/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=76856e19ff3c7c699931d0acee8e61bc0dfec512", "patch": "@@ -141,7 +141,6 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n     driver::phase_3_run_analysis_passes(sess,\n                                         hir_map,\n-                                        &krate,\n                                         &arenas,\n                                         name,\n                                         resolve::MakeGlobMap::No,"}]}