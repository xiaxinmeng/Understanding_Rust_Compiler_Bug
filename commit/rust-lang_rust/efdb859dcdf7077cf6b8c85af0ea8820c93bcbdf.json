{"sha": "efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZGI4NTlkY2RmNzA3N2NmNmI4Yzg1YWYwZWE4ODIwYzkzYmNiZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-16T07:12:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-16T07:12:12Z"}, "message": "Auto merge of #80873 - ssomers:btree_cleanup_slices_4, r=Mark-Simulacrum\n\nBTreeMap: tougher checks on code using raw into_kv_pointers\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "cdaa1e017ba13b029f1efabdfb4195ddc7446348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdaa1e017ba13b029f1efabdfb4195ddc7446348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "html_url": "https://github.com/rust-lang/rust/commit/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "635ccfe01c0be19d9fb0a99facbd9e06290f0ab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/635ccfe01c0be19d9fb0a99facbd9e06290f0ab1", "html_url": "https://github.com/rust-lang/rust/commit/635ccfe01c0be19d9fb0a99facbd9e06290f0ab1"}, {"sha": "c1dfb4a9c493e2c3a627a87d2d446bb5ac9c9521", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1dfb4a9c493e2c3a627a87d2d446bb5ac9c9521", "html_url": "https://github.com/rust-lang/rust/commit/c1dfb4a9c493e2c3a627a87d2d446bb5ac9c9521"}], "stats": {"total": 169, "additions": 88, "deletions": 81}, "files": [{"sha": "e7d66a9a6a83eb92d2751dd86d69426449957be7", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 88, "deletions": 81, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "patch": "@@ -712,13 +712,6 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             (key, val, edge)\n         }\n     }\n-\n-    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n-        let leaf = self.as_leaf_mut();\n-        let keys = MaybeUninit::slice_as_mut_ptr(&mut leaf.keys);\n-        let vals = MaybeUninit::slice_as_mut_ptr(&mut leaf.vals);\n-        (keys, vals)\n-    }\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n@@ -1428,36 +1421,42 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n \n             // Move leaf data.\n             {\n-                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n-                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n-                let parent_kv = {\n-                    let kv = self.parent.kv_mut();\n-                    (kv.0 as *mut K, kv.1 as *mut V)\n-                };\n-\n                 // Make room for stolen elements in the right child.\n-                ptr::copy(right_kv.0, right_kv.0.add(count), old_right_len);\n-                ptr::copy(right_kv.1, right_kv.1.add(count), old_right_len);\n+                slice_shr(right_node.key_area_mut(..new_right_len), count);\n+                slice_shr(right_node.val_area_mut(..new_right_len), count);\n \n                 // Move elements from the left child to the right one.\n-                move_kv(left_kv, new_left_len + 1, right_kv, 0, count - 1);\n-\n-                // Move parent's key-value pair to the right child.\n-                move_kv(parent_kv, 0, right_kv, count - 1, 1);\n+                move_to_slice(\n+                    left_node.key_area_mut(new_left_len + 1..old_left_len),\n+                    right_node.key_area_mut(..count - 1),\n+                );\n+                move_to_slice(\n+                    left_node.val_area_mut(new_left_len + 1..old_left_len),\n+                    right_node.val_area_mut(..count - 1),\n+                );\n \n                 // Move the left-most stolen pair to the parent.\n-                move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n+                let k = left_node.key_area_mut(new_left_len).assume_init_read();\n+                let v = left_node.val_area_mut(new_left_len).assume_init_read();\n+                let (k, v) = self.parent.replace_kv(k, v);\n+\n+                // Move parent's key-value pair to the right child.\n+                right_node.key_area_mut(count - 1).write(k);\n+                right_node.val_area_mut(count - 1).write(v);\n             }\n \n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n-                (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n+                (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n-                    let right_edges = right.edge_area_mut(..).as_mut_ptr();\n-                    ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n-                    right.correct_childrens_parent_links(count..new_right_len + 1);\n+                    slice_shr(right.edge_area_mut(..new_right_len + 1), count);\n \n                     // Steal edges.\n-                    move_edges(left, new_left_len + 1, right, 0, count);\n+                    move_to_slice(\n+                        left.edge_area_mut(new_left_len + 1..old_left_len + 1),\n+                        right.edge_area_mut(..count),\n+                    );\n+\n+                    right.correct_childrens_parent_links(0..new_right_len + 1);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                 _ => unreachable!(),\n@@ -1485,36 +1484,43 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n \n             // Move leaf data.\n             {\n-                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n-                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n-                let parent_kv = {\n-                    let kv = self.parent.kv_mut();\n-                    (kv.0 as *mut K, kv.1 as *mut V)\n-                };\n+                // Move the right-most stolen pair to the parent.\n+                let k = right_node.key_area_mut(count - 1).assume_init_read();\n+                let v = right_node.val_area_mut(count - 1).assume_init_read();\n+                let (k, v) = self.parent.replace_kv(k, v);\n \n                 // Move parent's key-value pair to the left child.\n-                move_kv(parent_kv, 0, left_kv, old_left_len, 1);\n+                left_node.key_area_mut(old_left_len).write(k);\n+                left_node.val_area_mut(old_left_len).write(v);\n \n                 // Move elements from the right child to the left one.\n-                move_kv(right_kv, 0, left_kv, old_left_len + 1, count - 1);\n-\n-                // Move the right-most stolen pair to the parent.\n-                move_kv(right_kv, count - 1, parent_kv, 0, 1);\n+                move_to_slice(\n+                    right_node.key_area_mut(..count - 1),\n+                    left_node.key_area_mut(old_left_len + 1..new_left_len),\n+                );\n+                move_to_slice(\n+                    right_node.val_area_mut(..count - 1),\n+                    left_node.val_area_mut(old_left_len + 1..new_left_len),\n+                );\n \n                 // Fill gap where stolen elements used to be.\n-                ptr::copy(right_kv.0.add(count), right_kv.0, new_right_len);\n-                ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n+                slice_shl(right_node.key_area_mut(..old_right_len), count);\n+                slice_shl(right_node.val_area_mut(..old_right_len), count);\n             }\n \n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n-                (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n+                (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {\n                     // Steal edges.\n-                    move_edges(right.reborrow_mut(), 0, left, old_left_len + 1, count);\n+                    move_to_slice(\n+                        right.edge_area_mut(..count),\n+                        left.edge_area_mut(old_left_len + 1..new_left_len + 1),\n+                    );\n \n                     // Fill gap where stolen edges used to be.\n-                    let right_edges = right.edge_area_mut(..).as_mut_ptr();\n-                    ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n-                    right.correct_childrens_parent_links(0..=new_right_len);\n+                    slice_shl(right.edge_area_mut(..old_right_len + 1), count);\n+\n+                    left.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n+                    right.correct_childrens_parent_links(0..new_right_len + 1);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                 _ => unreachable!(),\n@@ -1523,35 +1529,6 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     }\n }\n \n-unsafe fn move_kv<K, V>(\n-    source: (*mut K, *mut V),\n-    source_offset: usize,\n-    dest: (*mut K, *mut V),\n-    dest_offset: usize,\n-    count: usize,\n-) {\n-    unsafe {\n-        ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n-        ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n-    }\n-}\n-\n-// Source and destination must have the same height.\n-unsafe fn move_edges<'a, K: 'a, V: 'a>(\n-    mut source: NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n-    source_offset: usize,\n-    mut dest: NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n-    dest_offset: usize,\n-    count: usize,\n-) {\n-    unsafe {\n-        let source_ptr = source.edge_area_mut(..).as_ptr();\n-        let dest_ptr = dest.edge_area_mut(dest_offset..).as_mut_ptr();\n-        ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr, count);\n-        dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n-    }\n-}\n-\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n     /// Removes any static information asserting that this node is a `Leaf` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n@@ -1629,25 +1606,33 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n         unsafe {\n             let new_left_len = self.idx;\n             let mut left_node = self.reborrow_mut().into_node();\n+            let old_left_len = left_node.len();\n \n-            let new_right_len = left_node.len() - new_left_len;\n+            let new_right_len = old_left_len - new_left_len;\n             let mut right_node = right.reborrow_mut();\n \n             assert!(right_node.len() == 0);\n             assert!(left_node.height == right_node.height);\n \n             if new_right_len > 0 {\n-                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n-                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n-\n-                move_kv(left_kv, new_left_len, right_kv, 0, new_right_len);\n-\n                 *left_node.len_mut() = new_left_len as u16;\n                 *right_node.len_mut() = new_right_len as u16;\n \n+                move_to_slice(\n+                    left_node.key_area_mut(new_left_len..old_left_len),\n+                    right_node.key_area_mut(..new_right_len),\n+                );\n+                move_to_slice(\n+                    left_node.val_area_mut(new_left_len..old_left_len),\n+                    right_node.val_area_mut(..new_right_len),\n+                );\n                 match (left_node.force(), right_node.force()) {\n-                    (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n-                        move_edges(left, new_left_len + 1, right, 1, new_right_len);\n+                    (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {\n+                        move_to_slice(\n+                            left.edge_area_mut(new_left_len + 1..old_left_len + 1),\n+                            right.edge_area_mut(1..new_right_len + 1),\n+                        );\n+                        right.correct_childrens_parent_links(1..new_right_len + 1);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                     _ => unreachable!(),\n@@ -1737,6 +1722,28 @@ unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {\n     }\n }\n \n+/// Shifts the elements in a slice `distance` positions to the left.\n+///\n+/// # Safety\n+/// The slice has at least `distance` elements.\n+unsafe fn slice_shl<T>(slice: &mut [MaybeUninit<T>], distance: usize) {\n+    unsafe {\n+        let slice_ptr = slice.as_mut_ptr();\n+        ptr::copy(slice_ptr.add(distance), slice_ptr, slice.len() - distance);\n+    }\n+}\n+\n+/// Shifts the elements in a slice `distance` positions to the right.\n+///\n+/// # Safety\n+/// The slice has at least `distance` elements.\n+unsafe fn slice_shr<T>(slice: &mut [MaybeUninit<T>], distance: usize) {\n+    unsafe {\n+        let slice_ptr = slice.as_mut_ptr();\n+        ptr::copy(slice_ptr, slice_ptr.add(distance), slice.len() - distance);\n+    }\n+}\n+\n /// Moves all values from a slice of initialized elements to a slice\n /// of uninitialized elements, leaving behind `src` as all uninitialized.\n /// Works like `dst.copy_from_slice(src)` but does not require `T` to be `Copy`."}]}