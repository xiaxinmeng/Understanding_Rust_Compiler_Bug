{"sha": "55fd13bff45c9a1ba1740a387996b5bce4e275db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZmQxM2JmZjQ1YzlhMWJhMTc0MGEzODc5OTZiNWJjZTRlMjc1ZGI=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-24T04:47:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-24T04:47:26Z"}, "message": "Rollup merge of #86137 - GuillaumeGomez:error-code-cleanup, r=Mark-Simulacrum\n\nError code cleanup and enforce checks\n\nFixes #86097.\n\nIt now checks if an error code is unused, and if so, will report an error if the error code wasn't commented out in the `error_codes.rs` file. It also checks that the constant used in the tidy check is up-to-date.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "7bd707d93e7202059337716ca72406c75a187f11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bd707d93e7202059337716ca72406c75a187f11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55fd13bff45c9a1ba1740a387996b5bce4e275db", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg1A5fCRBK7hj4Ov3rIwAAU9IIABRSNOVVfVx7940LKh/zsaN2\nm88vFWSP97k9RlY90s11pdJ4eJLPvSyaM+/03cmezH1yCWTyyKVRZ8cKNgr/faJH\nKKlVUjXca0D4I7eqo6SWl2veQEGl+5XOMNIeS316qlRygtn3bblebVOk41zOph+J\nu8xGSc4nMqkbjqkAvsMLuC97utc7HB4/vL7ydO/S1aCNSEIqiK8xnsNJyhM5Ulie\n7AF+U2I81maZ7H2QL8wr96Se5VkX4mWdw2UFSbimDWe206dfiBYbOs2XBb80iRxW\n/NBf/wBXKw3Dc3Ip73XQ0XL976AZJoc0ax4+arV+MtVFi1XdVJoZvTlbiOWthxk=\n=dT8q\n-----END PGP SIGNATURE-----\n", "payload": "tree 7bd707d93e7202059337716ca72406c75a187f11\nparent f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d\nparent 0ab9d01dbdc2f495fc4e62510195d5729fd5d57c\nauthor Yuki Okushi <jtitor@2k36.org> 1624510046 +0900\ncommitter GitHub <noreply@github.com> 1624510046 +0900\n\nRollup merge of #86137 - GuillaumeGomez:error-code-cleanup, r=Mark-Simulacrum\n\nError code cleanup and enforce checks\n\nFixes #86097.\n\nIt now checks if an error code is unused, and if so, will report an error if the error code wasn't commented out in the `error_codes.rs` file. It also checks that the constant used in the tidy check is up-to-date.\n\nr? `@Mark-Simulacrum`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55fd13bff45c9a1ba1740a387996b5bce4e275db", "html_url": "https://github.com/rust-lang/rust/commit/55fd13bff45c9a1ba1740a387996b5bce4e275db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55fd13bff45c9a1ba1740a387996b5bce4e275db/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d", "html_url": "https://github.com/rust-lang/rust/commit/f1e691da2e640bb45fe18f8a5bd8f7afa65ce21d"}, {"sha": "0ab9d01dbdc2f495fc4e62510195d5729fd5d57c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab9d01dbdc2f495fc4e62510195d5729fd5d57c", "html_url": "https://github.com/rust-lang/rust/commit/0ab9d01dbdc2f495fc4e62510195d5729fd5d57c"}], "stats": {"total": 123, "additions": 97, "deletions": 26}, "files": [{"sha": "ff7a2344e69537543e5eb6ed2a6263216e3713ca", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55fd13bff45c9a1ba1740a387996b5bce4e275db/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55fd13bff45c9a1ba1740a387996b5bce4e275db/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=55fd13bff45c9a1ba1740a387996b5bce4e275db", "patch": "@@ -609,7 +609,7 @@ E0783: include_str!(\"./error_codes/E0783.md\"),\n //  E0540, // multiple rustc_deprecated attributes\n     E0544, // multiple stability levels\n //  E0548, // replaced with a generic attribute input check\n-    E0553, // multiple rustc_const_unstable attributes\n+//  E0553, // multiple rustc_const_unstable attributes\n //  E0555, // replaced with a generic attribute input check\n //  E0558, // replaced with a generic attribute input check\n //  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n@@ -620,10 +620,9 @@ E0783: include_str!(\"./error_codes/E0783.md\"),\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n     E0625, // thread-local statics cannot be accessed at compile-time\n-    E0629, // missing 'feature' (rustc_const_unstable)\n-    // rustc_const_unstable attribute must be paired with stable/unstable\n-    // attribute\n-    E0630,\n+//  E0629, // missing 'feature' (rustc_const_unstable)\n+//  E0630, // rustc_const_unstable attribute must be paired with stable/unstable\n+           // attribute\n     E0632, // cannot provide explicit generic arguments when `impl Trait` is\n            // used in argument position\n     E0640, // infer outlives requirements"}, {"sha": "63fbee34bd6e405eb7981e0db0993d8579b8909f", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 93, "deletions": 21, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/55fd13bff45c9a1ba1740a387996b5bce4e275db/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55fd13bff45c9a1ba1740a387996b5bce4e275db/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=55fd13bff45c9a1ba1740a387996b5bce4e275db", "patch": "@@ -6,20 +6,33 @@ use std::ffi::OsStr;\n use std::fs::read_to_string;\n use std::path::Path;\n \n+use regex::Regex;\n+\n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0461\", \"E0462\", \"E0464\",\n-    \"E0465\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\", \"E0480\", \"E0481\", \"E0482\", \"E0483\",\n-    \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\", \"E0514\", \"E0519\", \"E0523\", \"E0553\",\n-    \"E0554\", \"E0570\", \"E0629\", \"E0630\", \"E0640\", \"E0717\", \"E0729\",\n+    \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0464\", \"E0465\", \"E0476\",\n+    \"E0482\", \"E0514\", \"E0519\", \"E0523\", \"E0554\", \"E0570\", \"E0640\", \"E0717\", \"E0729\",\n ];\n \n // Some error codes don't have any tests apparently...\n const IGNORE_EXPLANATION_CHECK: &[&str] = &[\"E0570\", \"E0601\", \"E0602\", \"E0729\"];\n \n+// If the file path contains any of these, we don't want to try to extract error codes from it.\n+//\n+// We need to declare each path in the windows version (with backslash).\n+const PATHS_TO_IGNORE_FOR_EXTRACTION: &[&str] =\n+    &[\"src/test/\", \"src\\\\test\\\\\", \"src/doc/\", \"src\\\\doc\\\\\", \"src/tools/\", \"src\\\\tools\\\\\"];\n+\n+#[derive(Default, Debug)]\n+struct ErrorCodeStatus {\n+    has_test: bool,\n+    has_explanation: bool,\n+    is_used: bool,\n+}\n+\n fn check_error_code_explanation(\n     f: &str,\n-    error_codes: &mut HashMap<String, bool>,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n     err_code: String,\n ) -> bool {\n     let mut invalid_compile_fail_format = false;\n@@ -30,15 +43,15 @@ fn check_error_code_explanation(\n         if s.starts_with(\"```\") {\n             if s.contains(\"compile_fail\") && s.contains('E') {\n                 if !found_error_code {\n-                    error_codes.insert(err_code.clone(), true);\n+                    error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n                     found_error_code = true;\n                 }\n             } else if s.contains(\"compile-fail\") {\n                 invalid_compile_fail_format = true;\n             }\n         } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n             if !found_error_code {\n-                error_codes.get_mut(&err_code).map(|x| *x = true);\n+                error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n                 found_error_code = true;\n             }\n         }\n@@ -77,7 +90,7 @@ macro_rules! some_or_continue {\n \n fn extract_error_codes(\n     f: &str,\n-    error_codes: &mut HashMap<String, bool>,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n     path: &Path,\n     errors: &mut Vec<String>,\n ) {\n@@ -90,15 +103,16 @@ fn extract_error_codes(\n                 .split_once(':')\n                 .expect(\n                     format!(\n-                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} without a `:` delimiter\",\n+                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} \\\n+                         without a `:` delimiter\",\n                         s,\n-                    ).as_str()\n+                    )\n+                    .as_str(),\n                 )\n                 .0\n                 .to_owned();\n-            if !error_codes.contains_key(&err_code) {\n-                error_codes.insert(err_code.clone(), false);\n-            }\n+            error_codes.entry(err_code.clone()).or_default().has_explanation = true;\n+\n             // Now we extract the tests from the markdown file!\n             let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n                 None => continue,\n@@ -145,15 +159,15 @@ fn extract_error_codes(\n             .to_string();\n             if !error_codes.contains_key(&err_code) {\n                 // this check should *never* fail!\n-                error_codes.insert(err_code, false);\n+                error_codes.insert(err_code, ErrorCodeStatus::default());\n             }\n         } else if s == \";\" {\n             reached_no_explanation = true;\n         }\n     }\n }\n \n-fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, bool>) {\n+fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, ErrorCodeStatus>) {\n     for line in f.lines() {\n         let s = line.trim();\n         if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n@@ -164,8 +178,24 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n                     Some((_, err_code)) => err_code,\n                 },\n             };\n-            let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n-            *nb = true;\n+            error_codes.entry(err_code.to_owned()).or_default().has_test = true;\n+        }\n+    }\n+}\n+\n+fn extract_error_codes_from_source(\n+    f: &str,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n+    regex: &Regex,\n+) {\n+    for line in f.lines() {\n+        if line.trim_start().starts_with(\"//\") {\n+            continue;\n+        }\n+        for cap in regex.captures_iter(line) {\n+            if let Some(error_code) = cap.get(1) {\n+                error_codes.entry(error_code.as_str().to_owned()).or_default().is_used = true;\n+            }\n         }\n     }\n }\n@@ -174,8 +204,17 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     let mut errors = Vec::new();\n     let mut found_explanations = 0;\n     let mut found_tests = 0;\n+    let mut error_codes: HashMap<String, ErrorCodeStatus> = HashMap::new();\n+    // We want error codes which match the following cases:\n+    //\n+    // * foo(a, E0111, a)\n+    // * foo(a, E0111)\n+    // * foo(E0111, a)\n+    // * #[error = \"E0111\"]\n+    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n+\n     println!(\"Checking which error codes lack tests...\");\n-    let mut error_codes: HashMap<String, bool> = HashMap::new();\n+\n     for path in paths {\n         super::walk(path, &mut |path| super::filter_dirs(path), &mut |entry, contents| {\n             let file_name = entry.file_name();\n@@ -185,6 +224,11 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n             } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n                 extract_error_codes_from_tests(contents, &mut error_codes);\n                 found_tests += 1;\n+            } else if entry.path().extension() == Some(OsStr::new(\"rs\")) {\n+                let path = entry.path().to_string_lossy();\n+                if PATHS_TO_IGNORE_FOR_EXTRACTION.iter().all(|c| !path.contains(c)) {\n+                    extract_error_codes_from_source(contents, &mut error_codes, &regex);\n+                }\n             }\n         });\n     }\n@@ -199,15 +243,43 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     if errors.is_empty() {\n         println!(\"Found {} error codes\", error_codes.len());\n \n-        for (err_code, nb) in &error_codes {\n-            if !*nb && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n+        for (err_code, error_status) in &error_codes {\n+            if !error_status.has_test && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n-            } else if *nb && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n+            } else if error_status.has_test && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\n                     \"Error code {} has a UI test, it shouldn't be listed into EXEMPTED_FROM_TEST!\",\n                     err_code\n                 ));\n             }\n+            if !error_status.is_used && !error_status.has_explanation {\n+                errors.push(format!(\n+                    \"Error code {} isn't used and doesn't have an error explanation, it should be \\\n+                     commented in error_codes.rs file\",\n+                    err_code\n+                ));\n+            }\n+        }\n+    }\n+    if errors.is_empty() {\n+        // Checking if local constants need to be cleaned.\n+        for err_code in EXEMPTED_FROM_TEST {\n+            match error_codes.get(err_code.to_owned()) {\n+                Some(status) => {\n+                    if status.has_test {\n+                        errors.push(format!(\n+                            \"{} error code has a test and therefore should be \\\n+                            removed from the `EXEMPTED_FROM_TEST` constant\",\n+                            err_code\n+                        ));\n+                    }\n+                }\n+                None => errors.push(format!(\n+                    \"{} error code isn't used anymore and therefore should be removed \\\n+                        from `EXEMPTED_FROM_TEST` constant\",\n+                    err_code\n+                )),\n+            }\n         }\n     }\n     errors.sort();"}]}