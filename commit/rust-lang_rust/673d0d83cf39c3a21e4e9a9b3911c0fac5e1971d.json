{"sha": "673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3M2QwZDgzY2YzOWMzYTIxZTRlOWE5YjM5MTFjMGZhYzVlMTk3MWQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-24T01:42:14Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-24T02:07:56Z"}, "message": "Less confusing error message when copying into heap closures (close #2942)", "tree": {"sha": "d108fe588958b75c86fab38d6d0a90e1b8e07633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d108fe588958b75c86fab38d6d0a90e1b8e07633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d", "html_url": "https://github.com/rust-lang/rust/commit/673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d320848bf771c73db072d5149d9e4171d2d0a582", "url": "https://api.github.com/repos/rust-lang/rust/commits/d320848bf771c73db072d5149d9e4171d2d0a582", "html_url": "https://github.com/rust-lang/rust/commit/d320848bf771c73db072d5149d9e4171d2d0a582"}], "stats": {"total": 61, "additions": 40, "deletions": 21}, "files": [{"sha": "87b4ac140b6c46c0ba78ebe88f0827ed67ae23ba", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=673d0d83cf39c3a21e4e9a9b3911c0fac5e1971d", "patch": "@@ -103,7 +103,13 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n-        if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n+        if !is_move {\n+            check_copy(cx, id, var_t, sp, is_implicit,\n+                       some((\"non-copyable value cannot be copied into a \\\n+                              ~fn closure\",\n+                             \"to copy values into a ~fn closure, use a \\\n+                              capture clause: `fn~(copy x)` or `|copy x|`\")));\n+        }\n \n         // check that only immutable variables are implicitly copied in\n         for fv.each |fv| {\n@@ -118,7 +124,13 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n-        if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n+        if !is_move {\n+            check_copy(cx, id, var_t, sp, is_implicit,\n+                       some((\"non-copyable value cannot be copied into a \\\n+                              @fn closure\",\n+                             \"to copy values into a @fn closure, use a \\\n+                              capture clause: `fn~(copy x)` or `|copy x|`\")));\n+        }\n \n         // check that only immutable variables are implicitly copied in\n         for fv.each |fv| {\n@@ -207,7 +219,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n     match b.node.expr {\n-      some(ex) => maybe_copy(cx, ex),\n+      some(ex) => maybe_copy(cx, ex, none),\n       _ => ()\n     }\n     visit::visit_block(b, cx, v);\n@@ -247,21 +259,21 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(some(ex)) => {\n-        maybe_copy(cx, ex);\n+        maybe_copy(cx, ex, none);\n       }\n       expr_cast(source, _) => {\n-        maybe_copy(cx, source);\n+        maybe_copy(cx, source, none);\n         check_cast_for_escaping_regions(cx, source, e);\n       }\n-      expr_copy(expr) => check_copy_ex(cx, expr, false),\n+      expr_copy(expr) => check_copy_ex(cx, expr, false, none),\n       // Vector add copies, but not \"implicitly\"\n-      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false),\n+      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false, none),\n       expr_binary(add, ls, rs) => {\n-        check_copy_ex(cx, ls, false);\n-        check_copy_ex(cx, rs, false);\n+        check_copy_ex(cx, ls, false, none);\n+        check_copy_ex(cx, rs, false, none);\n       }\n       expr_rec(fields, def) => {\n-        for fields.each |field| { maybe_copy(cx, field.node.expr); }\n+        for fields.each |field| { maybe_copy(cx, field.node.expr, none); }\n         match def {\n           some(ex) => {\n             // All noncopyable fields must be overridden\n@@ -282,13 +294,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) => {\n-        for exprs.each |expr| { maybe_copy(cx, expr); }\n+        for exprs.each |expr| { maybe_copy(cx, expr, none); }\n       }\n       expr_call(f, args, _) => {\n         let mut i = 0u;\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n             match ty::arg_mode(cx.tcx, arg_t) {\n-              by_copy => maybe_copy(cx, args[i]),\n+              by_copy => maybe_copy(cx, args[i], none),\n               by_ref | by_val | by_mutbl_ref | by_move => ()\n             }\n             i += 1u;\n@@ -298,17 +310,17 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         // If this is a method call with a by-val argument, we need\n         // to check the copy\n         match cx.method_map.find(e.id) {\n-          some({self_mode: by_copy, _}) => maybe_copy(cx, lhs),\n+          some({self_mode: by_copy, _}) => maybe_copy(cx, lhs, none),\n           _ => ()\n         }\n       }\n       expr_repeat(element, count_expr, _) => {\n         let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n         if count == 1 {\n-            maybe_copy(cx, element);\n+            maybe_copy(cx, element, none);\n         } else {\n             let element_ty = ty::expr_ty(cx.tcx, element);\n-            check_copy(cx, element.id, element_ty, element.span, true);\n+            check_copy(cx, element.id, element_ty, element.span, true, none);\n         }\n       }\n       _ => { }\n@@ -321,7 +333,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n       stmt_decl(@{node: decl_local(locals), _}, _) => {\n         for locals.each |local| {\n             match local.node.init {\n-              some({op: init_assign, expr}) => maybe_copy(cx, expr),\n+              some({op: init_assign, expr}) => maybe_copy(cx, expr, none),\n               _ => {}\n             }\n         }\n@@ -373,8 +385,8 @@ fn check_bounds(cx: ctx, id: node_id, sp: span,\n     }\n }\n \n-fn maybe_copy(cx: ctx, ex: @expr) {\n-    check_copy_ex(cx, ex, true);\n+fn maybe_copy(cx: ctx, ex: @expr, why: option<(&str,&str)>) {\n+    check_copy_ex(cx, ex, true, why);\n }\n \n fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n@@ -391,7 +403,8 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     }\n }\n \n-fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool) {\n+fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n+                 why: option<(&str,&str)>) {\n     if ty::expr_is_lval(cx.method_map, ex) &&\n \n         // this is a move\n@@ -405,7 +418,7 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool) {\n         !cx.tcx.borrowings.contains_key(ex.id)\n     {\n         let ty = ty::expr_ty(cx.tcx, ex);\n-        check_copy(cx, ex.id, ty, ex.span, implicit_copy);\n+        check_copy(cx, ex.id, ty, ex.span, implicit_copy, why);\n     }\n }\n \n@@ -439,15 +452,21 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n }\n \n fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n-              implicit_copy: bool) {\n+              implicit_copy: bool, why: option<(&str,&str)>) {\n     let k = ty::type_kind(cx.tcx, ty);\n     if !ty::kind_can_be_copied(k) {\n         cx.tcx.sess.span_err(sp, ~\"copying a noncopyable value\");\n+        do why.map |reason| {\n+            cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason.first()));\n+        };\n     } else if implicit_copy && !ty::kind_can_be_implicitly_copied(k) {\n         cx.tcx.sess.span_lint(\n             implicit_copies, id, cx.current_item,\n             sp,\n             ~\"implicitly copying a non-implicitly-copyable value\");\n+        do why.map |reason| {\n+            cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason.second()));\n+        };\n     }\n }\n "}]}