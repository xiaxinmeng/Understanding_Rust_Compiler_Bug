{"sha": "fd276218ecdfd64f915460be3b68aaa5dc58a18e", "node_id": "C_kwDOAAsO6NoAKGZkMjc2MjE4ZWNkZmQ2NGY5MTU0NjBiZTNiNjhhYWE1ZGM1OGExOGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-11T14:34:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-11T14:34:47Z"}, "message": "Auto merge of #14549 - lowr:patch/no-unstable-item-compl-on-stable, r=Veykril\n\nDon't suggest unstable items on stable toolchain\n\nCloses #3020\n\nThis PR implements stability check in `ide-completion` so that unstable items are only suggested if you're on nightly toolchain.\n\nIt's a bit unfortunate `CompletionContext::check_stability()` is spammed all over the crate, but we should call it before building `CompletionItem` as you cannot get attributes on the item it's completing from that struct. I looked up every callsite of `Builder::add_to()`, `Completions::add[_opt]()`, and`Completions::add_all()` and inserted the check wherever necessary.\n\nThe tests are admittedly incomplete in that I didn't add tests for every kind of item as I thought that would be too big and not worthwhile. I copy-pasted some existing basic tests in every test module and adjusted them.", "tree": {"sha": "26af886bc27885387c44bfe9f2f8c60d3eb5dd05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26af886bc27885387c44bfe9f2f8c60d3eb5dd05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd276218ecdfd64f915460be3b68aaa5dc58a18e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd276218ecdfd64f915460be3b68aaa5dc58a18e", "html_url": "https://github.com/rust-lang/rust/commit/fd276218ecdfd64f915460be3b68aaa5dc58a18e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd276218ecdfd64f915460be3b68aaa5dc58a18e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "600283f2de12b40fbe60a6cade3650785ef0bbbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/600283f2de12b40fbe60a6cade3650785ef0bbbc", "html_url": "https://github.com/rust-lang/rust/commit/600283f2de12b40fbe60a6cade3650785ef0bbbc"}, {"sha": "e6e48728da1c4500304e022d6dfe29bb5afb0699", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e48728da1c4500304e022d6dfe29bb5afb0699", "html_url": "https://github.com/rust-lang/rust/commit/e6e48728da1c4500304e022d6dfe29bb5afb0699"}], "stats": {"total": 682, "additions": 602, "deletions": 80}, "files": [{"sha": "f01f75b13874341dd378b708d3f4c30cb82ab52e", "filename": "crates/base-db/src/fixture.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -4,15 +4,16 @@ use std::{mem, str::FromStr, sync::Arc};\n use cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use test_utils::{\n-    extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER, ESCAPED_CURSOR_MARKER,\n+    extract_range_or_offset, Fixture, FixtureWithProjectMeta, RangeOrOffset, CURSOR_MARKER,\n+    ESCAPED_CURSOR_MARKER,\n };\n use tt::token_id::{Leaf, Subtree, TokenTree};\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n     input::{CrateName, CrateOrigin, LangCrateOrigin},\n     Change, CrateDisplayName, CrateGraph, CrateId, Dependency, Edition, Env, FileId, FilePosition,\n-    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacros,\n+    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacros, ReleaseChannel,\n     SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n \n@@ -102,7 +103,14 @@ impl ChangeFixture {\n         ra_fixture: &str,\n         mut proc_macro_defs: Vec<(String, ProcMacro)>,\n     ) -> ChangeFixture {\n-        let (mini_core, proc_macro_names, fixture) = Fixture::parse(ra_fixture);\n+        let FixtureWithProjectMeta { fixture, mini_core, proc_macro_names, toolchain } =\n+            FixtureWithProjectMeta::parse(ra_fixture);\n+        let toolchain = toolchain\n+            .map(|it| {\n+                ReleaseChannel::from_str(&it)\n+                    .unwrap_or_else(|| panic!(\"unknown release channel found: {it}\"))\n+            })\n+            .unwrap_or(ReleaseChannel::Stable);\n         let mut change = Change::new();\n \n         let mut files = Vec::new();\n@@ -166,7 +174,7 @@ impl ChangeFixture {\n                         .as_deref()\n                         .map(Arc::from)\n                         .ok_or_else(|| \"target_data_layout unset\".into()),\n-                    None,\n+                    Some(toolchain),\n                 );\n                 let prev = crates.insert(crate_name.clone(), crate_id);\n                 assert!(prev.is_none());\n@@ -205,7 +213,7 @@ impl ChangeFixture {\n                 default_target_data_layout\n                     .map(|x| x.into())\n                     .ok_or_else(|| \"target_data_layout unset\".into()),\n-                None,\n+                Some(toolchain),\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -247,7 +255,7 @@ impl ChangeFixture {\n                 false,\n                 CrateOrigin::Lang(LangCrateOrigin::Core),\n                 target_layout.clone(),\n-                None,\n+                Some(toolchain),\n             );\n \n             for krate in all_crates {\n@@ -286,7 +294,7 @@ impl ChangeFixture {\n                 true,\n                 CrateOrigin::Local { repo: None, name: None },\n                 target_layout,\n-                None,\n+                Some(toolchain),\n             );\n             proc_macros.insert(proc_macros_crate, Ok(proc_macro));\n "}, {"sha": "cc59e780938c8b8c8400040abea6dc4b292fb75e", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -269,6 +269,10 @@ impl Attrs {\n     pub fn is_proc_macro_derive(&self) -> bool {\n         self.by_key(\"proc_macro_derive\").exists()\n     }\n+\n+    pub fn is_unstable(&self) -> bool {\n+        self.by_key(\"unstable\").exists()\n+    }\n }\n \n use std::slice::Iter as SliceIter;"}, {"sha": "6f23bc5c747297cc7032655c75d4a4cef342605d", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -23,7 +23,7 @@ pub(crate) mod env_vars;\n \n use std::iter;\n \n-use hir::{known, ScopeDef, Variant};\n+use hir::{known, HasAttrs, ScopeDef, Variant};\n use ide_db::{imports::import_assets::LocatedImport, SymbolKind};\n use syntax::ast;\n \n@@ -181,6 +181,9 @@ impl Completions {\n         resolution: hir::ScopeDef,\n         doc_aliases: Vec<syntax::SmolStr>,\n     ) {\n+        if !ctx.check_stability(resolution.attrs(ctx.db).as_deref()) {\n+            return;\n+        }\n         let is_private_editable = match ctx.def_is_visible(&resolution) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -206,6 +209,9 @@ impl Completions {\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n     ) {\n+        if !ctx.check_stability(resolution.attrs(ctx.db).as_deref()) {\n+            return;\n+        }\n         let is_private_editable = match ctx.def_is_visible(&resolution) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -228,6 +234,9 @@ impl Completions {\n         path_ctx: &PathCompletionCtx,\n         e: hir::Enum,\n     ) {\n+        if !ctx.check_stability(Some(&e.attrs(ctx.db))) {\n+            return;\n+        }\n         e.variants(ctx.db)\n             .into_iter()\n             .for_each(|variant| self.add_enum_variant(ctx, path_ctx, variant, None));\n@@ -241,6 +250,9 @@ impl Completions {\n         local_name: hir::Name,\n         doc_aliases: Vec<syntax::SmolStr>,\n     ) {\n+        if !ctx.check_stability(Some(&module.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_path_resolution(\n             ctx,\n             path_ctx,\n@@ -257,6 +269,9 @@ impl Completions {\n         mac: hir::Macro,\n         local_name: hir::Name,\n     ) {\n+        if !ctx.check_stability(Some(&mac.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&mac) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -280,6 +295,9 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&func.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&func) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -304,6 +322,9 @@ impl Completions {\n         receiver: Option<hir::Name>,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&func.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&func) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -328,6 +349,9 @@ impl Completions {\n         func: hir::Function,\n         import: LocatedImport,\n     ) {\n+        if !ctx.check_stability(Some(&func.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&func) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -348,6 +372,9 @@ impl Completions {\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext<'_>, konst: hir::Const) {\n+        if !ctx.check_stability(Some(&konst.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&konst) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -364,6 +391,9 @@ impl Completions {\n         ctx: &CompletionContext<'_>,\n         type_alias: hir::TypeAlias,\n     ) {\n+        if !ctx.check_stability(Some(&type_alias.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&type_alias) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -380,6 +410,9 @@ impl Completions {\n         ctx: &CompletionContext<'_>,\n         type_alias: hir::TypeAlias,\n     ) {\n+        if !ctx.check_stability(Some(&type_alias.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));\n     }\n \n@@ -390,6 +423,9 @@ impl Completions {\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         if let Some(builder) =\n             render_variant_lit(RenderContext::new(ctx), path_ctx, None, variant, Some(path))\n         {\n@@ -404,6 +440,9 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         if let PathCompletionCtx { kind: PathKind::Pat { pat_ctx }, .. } = path_ctx {\n             cov_mark::hit!(enum_variant_pattern_path);\n             self.add_variant_pat(ctx, pat_ctx, Some(path_ctx), variant, local_name);\n@@ -425,6 +464,9 @@ impl Completions {\n         field: hir::Field,\n         ty: &hir::Type,\n     ) {\n+        if !ctx.check_stability(Some(&field.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&field) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -448,6 +490,9 @@ impl Completions {\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&strukt.attrs(ctx.db))) {\n+            return;\n+        }\n         if let Some(builder) =\n             render_struct_literal(RenderContext::new(ctx), path_ctx, strukt, path, local_name)\n         {\n@@ -462,6 +507,9 @@ impl Completions {\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&un.attrs(ctx.db))) {\n+            return;\n+        }\n         let item = render_union_literal(RenderContext::new(ctx), un, path, local_name);\n         self.add_opt(item);\n     }\n@@ -473,6 +521,8 @@ impl Completions {\n         field: usize,\n         ty: &hir::Type,\n     ) {\n+        // Only used for (unnamed) tuples, whose all fields *are* stable. No need to check\n+        // stability here.\n         let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);\n         self.add(item);\n     }\n@@ -494,6 +544,9 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n             pattern_ctx,\n@@ -511,6 +564,9 @@ impl Completions {\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         let path = Some(&path);\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n@@ -529,6 +585,9 @@ impl Completions {\n         strukt: hir::Struct,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&strukt.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_opt(render_struct_pat(RenderContext::new(ctx), pattern_ctx, strukt, local_name));\n     }\n }"}, {"sha": "ba7663401613a659cd08ad6deac239b87bf6fe0c", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -172,6 +172,43 @@ fn foo(s: S) { s.$0 }\n         );\n     }\n \n+    #[test]\n+    fn no_unstable_method_on_stable() {\n+        check(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+fn foo(s: std::S) { s.$0 }\n+//- /std.rs crate:std\n+pub struct S;\n+impl S {\n+    #[unstable]\n+    pub fn bar(&self) {}\n+}\n+\"#,\n+            expect![\"\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn unstable_method_on_nightly() {\n+        check(\n+            r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+fn foo(s: std::S) { s.$0 }\n+//- /std.rs crate:std\n+pub struct S;\n+impl S {\n+    #[unstable]\n+    pub fn bar(&self) {}\n+}\n+\"#,\n+            expect![[r#\"\n+                me bar() fn(&self)\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_struct_field_completion_self() {\n         check("}, {"sha": "32d3fb8c624fa85bb1799590ea449a60445de156", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -267,8 +267,10 @@ fn import_on_the_fly(\n             .into_iter()\n             .filter(ns_filter)\n             .filter(|import| {\n-                !ctx.is_item_hidden(&import.item_to_import)\n-                    && !ctx.is_item_hidden(&import.original_item)\n+                let item = &import.item_to_import;\n+                !ctx.is_item_hidden(item)\n+                    && !ctx.is_item_hidden(item)\n+                    && ctx.check_stability(item.attrs(ctx.db).as_deref())\n             })\n             .sorted_by_key(|located_import| {\n                 compute_fuzzy_completion_order_key(\n@@ -315,8 +317,10 @@ fn import_on_the_fly_pat_(\n             .into_iter()\n             .filter(ns_filter)\n             .filter(|import| {\n-                !ctx.is_item_hidden(&import.item_to_import)\n-                    && !ctx.is_item_hidden(&import.original_item)\n+                let item = &import.item_to_import;\n+                !ctx.is_item_hidden(item)\n+                    && !ctx.is_item_hidden(item)\n+                    && ctx.check_stability(item.attrs(ctx.db).as_deref())\n             })\n             .sorted_by_key(|located_import| {\n                 compute_fuzzy_completion_order_key("}, {"sha": "e82908a361e60b97fa0774b3598fa356be3f7d1d", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -150,21 +150,24 @@ fn complete_trait_impl(\n     impl_def: &ast::Impl,\n ) {\n     if let Some(hir_impl) = ctx.sema.to_def(impl_def) {\n-        get_missing_assoc_items(&ctx.sema, impl_def).into_iter().for_each(|item| {\n-            use self::ImplCompletionKind::*;\n-            match (item, kind) {\n-                (hir::AssocItem::Function(func), All | Fn) => {\n-                    add_function_impl(acc, ctx, replacement_range, func, hir_impl)\n+        get_missing_assoc_items(&ctx.sema, impl_def)\n+            .into_iter()\n+            .filter(|item| ctx.check_stability(Some(&item.attrs(ctx.db))))\n+            .for_each(|item| {\n+                use self::ImplCompletionKind::*;\n+                match (item, kind) {\n+                    (hir::AssocItem::Function(func), All | Fn) => {\n+                        add_function_impl(acc, ctx, replacement_range, func, hir_impl)\n+                    }\n+                    (hir::AssocItem::TypeAlias(type_alias), All | TypeAlias) => {\n+                        add_type_alias_impl(acc, ctx, replacement_range, type_alias, hir_impl)\n+                    }\n+                    (hir::AssocItem::Const(const_), All | Const) => {\n+                        add_const_impl(acc, ctx, replacement_range, const_, hir_impl)\n+                    }\n+                    _ => {}\n                 }\n-                (hir::AssocItem::TypeAlias(type_alias), All | TypeAlias) => {\n-                    add_type_alias_impl(acc, ctx, replacement_range, type_alias, hir_impl)\n-                }\n-                (hir::AssocItem::Const(const_), All | Const) => {\n-                    add_const_impl(acc, ctx, replacement_range, const_, hir_impl)\n-                }\n-                _ => {}\n-            }\n-        });\n+            });\n     }\n }\n "}, {"sha": "45be4fb20540cf9f54231740c3e7648ead98e604", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -52,6 +52,9 @@ pub(crate) fn complete_use_path(\n                         )\n                     };\n                     for (name, def) in module_scope {\n+                        if !ctx.check_stability(def.attrs(ctx.db).as_deref()) {\n+                            continue;\n+                        }\n                         let is_name_already_imported = name\n                             .as_text()\n                             .map_or(false, |text| already_imported_names.contains(text.as_str()));"}, {"sha": "d99414fe358295e27d50a50f95dd5a6546762517", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -367,6 +367,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) krate: hir::Crate,\n     /// The module of the `scope`.\n     pub(super) module: hir::Module,\n+    /// Whether nightly toolchain is used. Cached since this is looked up a lot.\n+    is_nightly: bool,\n \n     /// The expected name of what we are completing.\n     /// This is usually the parameter name of the function argument we are completing.\n@@ -386,7 +388,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) depth_from_crate_root: usize,\n }\n \n-impl<'a> CompletionContext<'a> {\n+impl CompletionContext<'_> {\n     /// The range of the identifier that is being completed.\n     pub(crate) fn source_range(&self) -> TextRange {\n         let kind = self.original_token.kind();\n@@ -451,6 +453,12 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n+    /// Checks whether this item should be listed in regards to stability. Returns `true` if we should.\n+    pub(crate) fn check_stability(&self, attrs: Option<&hir::Attrs>) -> bool {\n+        let Some(attrs) = attrs else { return true; };\n+        !attrs.is_unstable() || self.is_nightly\n+    }\n+\n     /// Whether the given trait is an operator trait or not.\n     pub(crate) fn is_ops_trait(&self, trait_: hir::Trait) -> bool {\n         match trait_.attrs(self.db).lang() {\n@@ -624,6 +632,11 @@ impl<'a> CompletionContext<'a> {\n         let krate = scope.krate();\n         let module = scope.module();\n \n+        let toolchain = db.crate_graph()[krate.into()].channel;\n+        // `toolchain == None` means we're in some detached files. Since we have no information on\n+        // the toolchain being used, let's just allow unstable items to be listed.\n+        let is_nightly = matches!(toolchain, Some(base_db::ReleaseChannel::Nightly) | None);\n+\n         let mut locals = FxHashMap::default();\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n@@ -643,6 +656,7 @@ impl<'a> CompletionContext<'a> {\n             token,\n             krate,\n             module,\n+            is_nightly,\n             expected_name,\n             expected_type,\n             qualifier_ctx,"}, {"sha": "79c1f98f3bde6c8aad37a9850507aa07c7e27844", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -23,6 +23,7 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n+use expect_test::Expect;\n use hir::PrefixKind;\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n@@ -215,6 +216,11 @@ pub(crate) fn check_edit_with_config(\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n \n+fn check_empty(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,"}, {"sha": "36465be23d84db45e996db6cfba5c784ff526e91", "filename": "crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -1,18 +1,13 @@\n //! Completion tests for expressions.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_edit, check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n \n-fn check_empty(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(ra_fixture);\n-    expect.assert_eq(&actual);\n-}\n-\n #[test]\n fn complete_literal_struct_with_a_private_field() {\n     // `FooDesc.bar` is private, the completion should not be triggered.\n@@ -997,3 +992,105 @@ fn foo() { if foo {} el$0 { let x = 92; } }\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn expr_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn main() {\n+    $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct UnstableThisShouldNotBeListed;\n+\"#,\n+        expect![[r#\"\n+            fn main()      fn()\n+            md std\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn expr_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn main() {\n+    $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct UnstableButWeAreOnNightlyAnyway;\n+\"#,\n+        expect![[r#\"\n+            fn main()                 fn()\n+            md std\n+            st UnstableButWeAreOnNightlyAnyway\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}, {"sha": "d727320b5148959002f69744bea960ca17fc30ba", "filename": "crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -1107,6 +1107,41 @@ fn function() {\n     );\n }\n \n+#[test]\n+fn flyimport_pattern_no_unstable_item_on_stable() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn function() {\n+    let foo$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct FooStruct {}\n+\"#,\n+        expect![\"\"],\n+    );\n+}\n+\n+#[test]\n+fn flyimport_pattern_unstable_item_on_nightly() {\n+    check(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+fn function() {\n+    let foo$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct FooStruct {}\n+\"#,\n+        expect![[r#\"\n+            st FooStruct (use std::FooStruct)\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn flyimport_item_name() {\n     check("}, {"sha": "2b5b4dd773c878c9b6b7f1af041766e472be80be", "filename": "crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for item list position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_edit, check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n@@ -297,6 +297,58 @@ impl Test for () {\n     );\n }\n \n+#[test]\n+fn in_trait_impl_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+trait Test {\n+    #[unstable]\n+    type Type;\n+    #[unstable]\n+    const CONST: ();\n+    #[unstable]\n+    fn function();\n+}\n+\n+impl Test for () {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_trait_impl_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+trait Test {\n+    #[unstable]\n+    type Type;\n+    #[unstable]\n+    const CONST: ();\n+    #[unstable]\n+    fn function();\n+}\n+\n+impl Test for () {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            ct const CONST: () =\n+            fn fn function()\n+            ta type Type =\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn after_unit_struct() {\n     check("}, {"sha": "8af6cce98f6358529d641bcd523448b94687f876", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -1,12 +1,7 @@\n //! Completion tests for pattern position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n-\n-fn check_empty(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(ra_fixture);\n-    expect.assert_eq(&actual)\n-}\n+use crate::tests::{check_edit, check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n@@ -742,3 +737,56 @@ fn f(x: EnumAlias<u8>) {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn pat_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn foo() {\n+    let a$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub enum Enum {\n+    Variant\n+}\n+\"#,\n+        expect![[r#\"\n+            md std\n+            kw mut\n+            kw ref\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn pat_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn foo() {\n+    let a$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub enum Enum {\n+    Variant\n+}\n+\"#,\n+        expect![[r#\"\n+            en Enum\n+            md std\n+            st S\n+            kw mut\n+            kw ref\n+        \"#]],\n+    );\n+}"}, {"sha": "789ad66345b12dd3199975ee47b4fb4daeeda127", "filename": "crates/ide-completion/src/tests/predicate.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for predicates and bounds.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n@@ -129,3 +129,43 @@ impl Record {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn pred_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo<T> where T: $0 {}\n+//- /std.rs crate:std\n+#[unstable]\n+pub trait Trait {}\n+\"#,\n+        expect![[r#\"\n+            md std\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn pred_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo<T> where T: $0 {}\n+//- /std.rs crate:std\n+#[unstable]\n+pub trait Trait {}\n+\"#,\n+        expect![[r#\"\n+            md std\n+            tt Trait\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}"}, {"sha": "8cb1ff4a125f70c66fec059923ef2bab18979ff4", "filename": "crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for type position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n@@ -669,3 +669,53 @@ fn f(t: impl MyTrait<Item1 = u8, Item2 = $0\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn type_pos_no_unstable_type_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo {\n+    f: $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+\"#,\n+        expect![[r#\"\n+            md std\n+            sp Self\n+            st Foo\n+            bt u32\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn type_pos_unstable_type_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo {\n+    f: $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+\"#,\n+        expect![[r#\"\n+            md std\n+            sp Self\n+            st Foo\n+            st S\n+            bt u32\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    )\n+}"}, {"sha": "ba2e047999ef1c17b535a088a68738ba804dc768", "filename": "crates/ide-completion/src/tests/use_tree.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -382,3 +382,51 @@ use self::foo::impl$0\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn use_tree_no_unstable_items_on_stable() {\n+    check(\n+        r#\"\n+//- toolchain:stable\n+//- /lib.rs crate:main deps:std\n+use std::$0\n+//- /std.rs crate:std\n+#[unstable]\n+pub mod simd {}\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub fn foo() {}\n+#[unstable]\n+#[macro_export]\n+marco_rules! m { () => {} }\n+\"#,\n+        expect![\"\"],\n+    );\n+}\n+\n+#[test]\n+fn use_tree_unstable_items_on_nightly() {\n+    check(\n+        r#\"\n+//- toolchain:nightly\n+//- /lib.rs crate:main deps:std\n+use std::$0\n+//- /std.rs crate:std\n+#[unstable]\n+pub mod simd {}\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub fn foo() {}\n+#[unstable]\n+#[macro_export]\n+marco_rules! m { () => {} }\n+\"#,\n+        expect![[r#\"\n+            fn foo  fn()\n+            md simd\n+            st S\n+        \"#]],\n+    );\n+}"}, {"sha": "b6b46c4508888c2094d6c5d7bb42cfa6d2700a56", "filename": "crates/ide/src/doc_links/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -116,7 +116,7 @@ fn external_docs_doc_url_std_crate() {\n //- /main.rs crate:std\n use self$0;\n \"#,\n-        expect![[r#\"https://doc.rust-lang.org/nightly/std/index.html\"#]],\n+        expect![\"https://doc.rust-lang.org/stable/std/index.html\"],\n     );\n }\n "}, {"sha": "73ab3d2e16fe267319a7ac152783846cc94bade1", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -4242,7 +4242,7 @@ fn foo() {\n /// [threads]: ../book/ch16-01-threads.html#using-move-closures-with-threads\n mod move_keyword {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             *move*\n \n             ```rust\n@@ -4251,11 +4251,11 @@ mod move_keyword {}\n \n             ---\n \n-            [closure](https://doc.rust-lang.org/nightly/book/ch13-01-closures.html)\n-            [closures](https://doc.rust-lang.org/nightly/book/ch13-01-closures.html)\n-            [threads](https://doc.rust-lang.org/nightly/book/ch16-01-threads.html#using-move-closures-with-threads)\n+            [closure](https://doc.rust-lang.org/stable/book/ch13-01-closures.html)\n+            [closures](https://doc.rust-lang.org/stable/book/ch13-01-closures.html)\n+            [threads](https://doc.rust-lang.org/stable/book/ch16-01-threads.html#using-move-closures-with-threads)\n             <https://doc.rust-lang.org/nightly/book/ch13-01-closures.html>\n-        \"##]],\n+        \"#]],\n     );\n }\n "}, {"sha": "df62dcd7ddc15c97fb775ff1669c96b7dbe35dec", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -13,7 +13,7 @@ use project_model::ProjectManifest;\n use rust_analyzer::{config::Config, lsp_ext, main_loop};\n use serde::Serialize;\n use serde_json::{json, to_string_pretty, Value};\n-use test_utils::Fixture;\n+use test_utils::FixtureWithProjectMeta;\n use vfs::AbsPathBuf;\n \n use crate::testdir::TestDir;\n@@ -84,10 +84,12 @@ impl<'a> Project<'a> {\n             profile::init_from(crate::PROFILE);\n         });\n \n-        let (mini_core, proc_macros, fixtures) = Fixture::parse(self.fixture);\n-        assert!(proc_macros.is_empty());\n+        let FixtureWithProjectMeta { fixture, mini_core, proc_macro_names, toolchain } =\n+            FixtureWithProjectMeta::parse(self.fixture);\n+        assert!(proc_macro_names.is_empty());\n         assert!(mini_core.is_none());\n-        for entry in fixtures {\n+        assert!(toolchain.is_none());\n+        for entry in fixture {\n             let path = tmp_dir.path().join(&entry.path['/'.len_utf8()..]);\n             fs::create_dir_all(path.parent().unwrap()).unwrap();\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();"}, {"sha": "dffc7fccdab1801a3e050fe52a3603d156d69f82", "filename": "crates/test-utils/src/fixture.rs", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Ffixture.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -86,7 +86,14 @@ pub struct MiniCore {\n     valid_flags: Vec<String>,\n }\n \n-impl Fixture {\n+pub struct FixtureWithProjectMeta {\n+    pub fixture: Vec<Fixture>,\n+    pub mini_core: Option<MiniCore>,\n+    pub proc_macro_names: Vec<String>,\n+    pub toolchain: Option<String>,\n+}\n+\n+impl FixtureWithProjectMeta {\n     /// Parses text which looks like this:\n     ///\n     ///  ```not_rust\n@@ -96,37 +103,40 @@ impl Fixture {\n     ///  //- other meta\n     ///  ```\n     ///\n-    /// Fixture can also start with a proc_macros and minicore declaration(in that order):\n+    /// Fixture can also start with a proc_macros and minicore declaration (in that order):\n     ///\n     /// ```\n+    /// //- toolchain: nightly\n     /// //- proc_macros: identity\n     /// //- minicore: sized\n     /// ```\n     ///\n     /// That will include predefined proc macros and a subset of `libcore` into the fixture, see\n     /// `minicore.rs` for what's available.\n-    pub fn parse(ra_fixture: &str) -> (Option<MiniCore>, Vec<String>, Vec<Fixture>) {\n+    pub fn parse(ra_fixture: &str) -> Self {\n         let fixture = trim_indent(ra_fixture);\n         let mut fixture = fixture.as_str();\n+        let mut toolchain = None;\n         let mut mini_core = None;\n         let mut res: Vec<Fixture> = Vec::new();\n-        let mut test_proc_macros = vec![];\n-\n-        if fixture.starts_with(\"//- proc_macros:\") {\n-            let first_line = fixture.split_inclusive('\\n').next().unwrap();\n-            test_proc_macros = first_line\n-                .strip_prefix(\"//- proc_macros:\")\n-                .unwrap()\n-                .split(',')\n-                .map(|it| it.trim().to_string())\n-                .collect();\n-            fixture = &fixture[first_line.len()..];\n+        let mut proc_macro_names = vec![];\n+\n+        if let Some(meta) = fixture.strip_prefix(\"//- toolchain:\") {\n+            let (meta, remain) = meta.split_once('\\n').unwrap();\n+            toolchain = Some(meta.trim().to_string());\n+            fixture = remain;\n         }\n \n-        if fixture.starts_with(\"//- minicore:\") {\n-            let first_line = fixture.split_inclusive('\\n').next().unwrap();\n-            mini_core = Some(MiniCore::parse(first_line));\n-            fixture = &fixture[first_line.len()..];\n+        if let Some(meta) = fixture.strip_prefix(\"//- proc_macros:\") {\n+            let (meta, remain) = meta.split_once('\\n').unwrap();\n+            proc_macro_names = meta.split(',').map(|it| it.trim().to_string()).collect();\n+            fixture = remain;\n+        }\n+\n+        if let Some(meta) = fixture.strip_prefix(\"//- minicore:\") {\n+            let (meta, remain) = meta.split_once('\\n').unwrap();\n+            mini_core = Some(MiniCore::parse(meta));\n+            fixture = remain;\n         }\n \n         let default = if fixture.contains(\"//-\") { None } else { Some(\"//- /main.rs\") };\n@@ -142,7 +152,7 @@ impl Fixture {\n             }\n \n             if line.starts_with(\"//-\") {\n-                let meta = Fixture::parse_meta_line(line);\n+                let meta = Self::parse_meta_line(line);\n                 res.push(meta);\n             } else {\n                 if line.starts_with(\"// \")\n@@ -160,7 +170,7 @@ impl Fixture {\n             }\n         }\n \n-        (mini_core, test_proc_macros, res)\n+        Self { fixture: res, mini_core, proc_macro_names, toolchain }\n     }\n \n     //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n@@ -257,8 +267,7 @@ impl MiniCore {\n     fn parse(line: &str) -> MiniCore {\n         let mut res = MiniCore { activated_flags: Vec::new(), valid_flags: Vec::new() };\n \n-        let line = line.strip_prefix(\"//- minicore:\").unwrap().trim();\n-        for entry in line.split(\", \") {\n+        for entry in line.trim().split(\", \") {\n             if res.has_flag(entry) {\n                 panic!(\"duplicate minicore flag: {entry:?}\");\n             }\n@@ -372,7 +381,7 @@ impl MiniCore {\n #[test]\n #[should_panic]\n fn parse_fixture_checks_further_indented_metadata() {\n-    Fixture::parse(\n+    FixtureWithProjectMeta::parse(\n         r\"\n         //- /lib.rs\n           mod bar;\n@@ -386,15 +395,18 @@ fn parse_fixture_checks_further_indented_metadata() {\n \n #[test]\n fn parse_fixture_gets_full_meta() {\n-    let (mini_core, proc_macros, parsed) = Fixture::parse(\n-        r#\"\n+    let FixtureWithProjectMeta { fixture: parsed, mini_core, proc_macro_names, toolchain } =\n+        FixtureWithProjectMeta::parse(\n+            r#\"\n+//- toolchain: nightly\n //- proc_macros: identity\n //- minicore: coerce_unsized\n //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n mod m;\n \"#,\n-    );\n-    assert_eq!(proc_macros, vec![\"identity\".to_string()]);\n+        );\n+    assert_eq!(toolchain, Some(\"nightly\".to_string()));\n+    assert_eq!(proc_macro_names, vec![\"identity\".to_string()]);\n     assert_eq!(mini_core.unwrap().activated_flags, vec![\"coerce_unsized\".to_string()]);\n     assert_eq!(1, parsed.len());\n "}, {"sha": "5abadaad6295e2d20fd32483a1baf854a69f123a", "filename": "crates/test-utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Ftest-utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd276218ecdfd64f915460be3b68aaa5dc58a18e/crates%2Ftest-utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Flib.rs?ref=fd276218ecdfd64f915460be3b68aaa5dc58a18e", "patch": "@@ -27,7 +27,7 @@ pub use rustc_hash::FxHashMap;\n \n pub use crate::{\n     assert_linear::AssertLinear,\n-    fixture::{Fixture, MiniCore},\n+    fixture::{Fixture, FixtureWithProjectMeta, MiniCore},\n };\n \n pub const CURSOR_MARKER: &str = \"$0\";"}]}