{"sha": "d7270712cb446aad0817040bbca73a8d024f67b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MjcwNzEyY2I0NDZhYWQwODE3MDQwYmJjYTczYThkMDI0ZjY3YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T02:21:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T02:21:23Z"}, "message": "Auto merge of #63180 - varkor:trait-alias-impl-trait, r=Centril\n\nChange opaque type syntax from `existential type` to type alias `impl Trait`\n\nThis implements a new feature gate `type_alias_impl_trait` (this is slightly different from the originally proposed feature name, but matches what has been used in discussion since), deprecating the old `existential_types` feature.\n\nThe syntax for opaque types has been changed. In addition, the \"existential\" terminology has been replaced with \"opaque\", as per previous discussion and the RFC.\n\nThis makes partial progress towards implementing https://github.com/rust-lang/rust/issues/63063.\n\nr? @Centril", "tree": {"sha": "22cf18615b2177381934d771fc3710e6fd04c257", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22cf18615b2177381934d771fc3710e6fd04c257"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7270712cb446aad0817040bbca73a8d024f67b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7270712cb446aad0817040bbca73a8d024f67b0", "html_url": "https://github.com/rust-lang/rust/commit/d7270712cb446aad0817040bbca73a8d024f67b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7270712cb446aad0817040bbca73a8d024f67b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9bd4b289f07956819c59704d88d9eed61af3a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9bd4b289f07956819c59704d88d9eed61af3a6d", "html_url": "https://github.com/rust-lang/rust/commit/d9bd4b289f07956819c59704d88d9eed61af3a6d"}, {"sha": "fbd7e0cf0e31ab612343311a61fe4f58a76a1698", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd7e0cf0e31ab612343311a61fe4f58a76a1698", "html_url": "https://github.com/rust-lang/rust/commit/fbd7e0cf0e31ab612343311a61fe4f58a76a1698"}], "stats": {"total": 2083, "additions": 1050, "deletions": 1033}, "files": [{"sha": "db90e44b892563c8d34de3bcebd02554a8e18614", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -27,7 +27,7 @@ pub(crate) enum Target {\n     ForeignMod,\n     GlobalAsm,\n     Ty,\n-    Existential,\n+    OpaqueTy,\n     Enum,\n     Struct,\n     Union,\n@@ -51,7 +51,7 @@ impl Display for Target {\n             Target::ForeignMod => \"foreign module\",\n             Target::GlobalAsm => \"global asm\",\n             Target::Ty => \"type alias\",\n-            Target::Existential => \"existential type\",\n+            Target::OpaqueTy => \"opaque type\",\n             Target::Enum => \"enum\",\n             Target::Struct => \"struct\",\n             Target::Union => \"union\",\n@@ -76,7 +76,7 @@ impl Target {\n             hir::ItemKind::ForeignMod(..) => Target::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => Target::GlobalAsm,\n             hir::ItemKind::Ty(..) => Target::Ty,\n-            hir::ItemKind::Existential(..) => Target::Existential,\n+            hir::ItemKind::OpaqueTy(..) => Target::OpaqueTy,\n             hir::ItemKind::Enum(..) => Target::Enum,\n             hir::ItemKind::Struct(..) => Target::Struct,\n             hir::ItemKind::Union(..) => Target::Union,"}, {"sha": "40992e927444b1a920f75a6d91fa74561b94ea53", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -55,15 +55,15 @@ pub enum DefKind {\n     /// Refers to the variant itself, `DefKind::Ctor` refers to its constructor if it exists.\n     Variant,\n     Trait,\n-    /// `existential type Foo: Bar;`\n-    Existential,\n+    /// `type Foo = impl Bar;`\n+    OpaqueTy,\n     /// `type Foo = Bar;`\n     TyAlias,\n     ForeignTy,\n     TraitAlias,\n     AssocTy,\n-    /// `existential type Foo: Bar;`\n-    AssocExistential,\n+    /// `type Foo = impl Bar;`\n+    AssocOpaqueTy,\n     TyParam,\n \n     // Value namespace\n@@ -96,11 +96,11 @@ impl DefKind {\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive) =>\n                 bug!(\"impossible struct constructor\"),\n-            DefKind::Existential => \"existential type\",\n+            DefKind::OpaqueTy => \"opaque type\",\n             DefKind::TyAlias => \"type alias\",\n             DefKind::TraitAlias => \"trait alias\",\n             DefKind::AssocTy => \"associated type\",\n-            DefKind::AssocExistential => \"associated existential type\",\n+            DefKind::AssocOpaqueTy => \"associated opaque type\",\n             DefKind::Union => \"union\",\n             DefKind::Trait => \"trait\",\n             DefKind::ForeignTy => \"foreign type\",\n@@ -118,9 +118,9 @@ impl DefKind {\n         match *self {\n             DefKind::AssocTy\n             | DefKind::AssocConst\n-            | DefKind::AssocExistential\n+            | DefKind::AssocOpaqueTy\n             | DefKind::Enum\n-            | DefKind::Existential => \"an\",\n+            | DefKind::OpaqueTy => \"an\",\n             DefKind::Macro(macro_kind) => macro_kind.article(),\n             _ => \"a\",\n         }"}, {"sha": "625e746c24fec0b15a5f58bf7b37025d93ddf75f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -505,7 +505,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n-        ItemKind::Existential(ExistTy {\n+        ItemKind::OpaqueTy(OpaqueTy {\n             ref generics,\n             ref bounds,\n             ..\n@@ -930,7 +930,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n         }\n-        ImplItemKind::Existential(ref bounds) => {\n+        ImplItemKind::OpaqueTy(ref bounds) => {\n             visitor.visit_id(impl_item.hir_id);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }"}, {"sha": "20ec7b1f3868ff4a3f684c3d5d7488edd817c067", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -189,14 +189,14 @@ enum ImplTraitContext<'a> {\n     /// Newly generated parameters should be inserted into the given `Vec`.\n     Universal(&'a mut Vec<hir::GenericParam>),\n \n-    /// Treat `impl Trait` as shorthand for a new existential parameter.\n+    /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n-    /// equivalent to a fresh existential parameter like `existential type T; fn foo() -> T`.\n+    /// equivalent to a new opaque type like `type T = impl Debug; fn foo() -> T`.\n     ///\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n     /// information later. It is `None` when no information about the context should be stored\n     /// (e.g., for consts and statics).\n-    Existential(Option<DefId> /* fn def-ID */),\n+    OpaqueTy(Option<DefId> /* fn def-ID */),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n@@ -222,7 +222,7 @@ impl<'a> ImplTraitContext<'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            Existential(fn_def_id) => Existential(*fn_def_id),\n+            OpaqueTy(fn_def_id) => OpaqueTy(*fn_def_id),\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -487,7 +487,7 @@ impl<'a> LoweringContext<'a> {\n                     | ItemKind::Union(_, ref generics)\n                     | ItemKind::Enum(_, ref generics)\n                     | ItemKind::Ty(_, ref generics)\n-                    | ItemKind::Existential(_, ref generics)\n+                    | ItemKind::OpaqueTy(_, ref generics)\n                     | ItemKind::Trait(_, _, ref generics, ..) => {\n                         let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n                         let count = generics\n@@ -1422,7 +1422,7 @@ impl<'a> LoweringContext<'a> {\n                     // so desugar to\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n-                    ImplTraitContext::Existential(_) => (true, itctx),\n+                    ImplTraitContext::OpaqueTy(_) => (true, itctx),\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1436,11 +1436,11 @@ impl<'a> LoweringContext<'a> {\n                     // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n                     // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n                     // \"impl trait context\" to permit `impl Debug` in this position (it desugars\n-                    // then to an existential type).\n+                    // then to an opaque type).\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n-                        (true, ImplTraitContext::Existential(None)),\n+                        (true, ImplTraitContext::OpaqueTy(None)),\n \n                     // We are in the argument position, but not within a dyn type:\n                     //\n@@ -1634,8 +1634,8 @@ impl<'a> LoweringContext<'a> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::Existential(fn_def_id) => {\n-                        self.lower_existential_impl_trait(\n+                    ImplTraitContext::OpaqueTy(fn_def_id) => {\n+                        self.lower_opaque_impl_trait(\n                             span, fn_def_id, def_node_id,\n                             |this| this.lower_param_bounds(bounds, itctx),\n                         )\n@@ -1717,42 +1717,42 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_existential_impl_trait(\n+    fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n         fn_def_id: Option<DefId>,\n-        exist_ty_node_id: NodeId,\n+        opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile, as\n         // frequently opened issues show.\n-        let exist_ty_span = self.mark_span_with_reason(\n-            DesugaringKind::ExistentialType,\n+        let opaque_ty_span = self.mark_span_with_reason(\n+            DesugaringKind::OpaqueTy,\n             span,\n             None,\n         );\n \n-        let exist_ty_def_index = self\n+        let opaque_ty_def_index = self\n             .resolver\n             .definitions()\n-            .opt_def_index(exist_ty_node_id)\n+            .opt_def_index(opaque_ty_node_id)\n             .unwrap();\n \n-        self.allocate_hir_id_counter(exist_ty_node_id);\n+        self.allocate_hir_id_counter(opaque_ty_node_id);\n \n-        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n+        let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n \n         let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-            exist_ty_node_id,\n-            exist_ty_def_index,\n+            opaque_ty_node_id,\n+            opaque_ty_def_index,\n             &hir_bounds,\n         );\n \n-        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-            let exist_ty_item = hir::ExistTy {\n+        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n+            let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n@@ -1763,54 +1763,54 @@ impl<'a> LoweringContext<'a> {\n                 },\n                 bounds: hir_bounds,\n                 impl_trait_fn: fn_def_id,\n-                origin: hir::ExistTyOrigin::ReturnImplTrait,\n+                origin: hir::OpaqueTyOrigin::FnReturn,\n             };\n \n-            trace!(\"exist ty from impl trait def-index: {:#?}\", exist_ty_def_index);\n-            let exist_ty_id = lctx.generate_existential_type(\n-                exist_ty_node_id,\n-                exist_ty_item,\n+            trace!(\"exist ty from impl trait def-index: {:#?}\", opaque_ty_def_index);\n+            let opaque_ty_id = lctx.generate_opaque_type(\n+                opaque_ty_node_id,\n+                opaque_ty_item,\n                 span,\n-                exist_ty_span,\n+                opaque_ty_span,\n             );\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::Def(hir::ItemId { id: exist_ty_id }, lifetimes)\n+            hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, lifetimes)\n         })\n     }\n \n-    /// Registers a new existential type with the proper `NodeId`s and\n-    /// returns the lowered node-ID for the existential type.\n-    fn generate_existential_type(\n+    /// Registers a new opaque type with the proper `NodeId`s and\n+    /// returns the lowered node-ID for the opaque type.\n+    fn generate_opaque_type(\n         &mut self,\n-        exist_ty_node_id: NodeId,\n-        exist_ty_item: hir::ExistTy,\n+        opaque_ty_node_id: NodeId,\n+        opaque_ty_item: hir::OpaqueTy,\n         span: Span,\n-        exist_ty_span: Span,\n+        opaque_ty_span: Span,\n     ) -> hir::HirId {\n-        let exist_ty_item_kind = hir::ItemKind::Existential(exist_ty_item);\n-        let exist_ty_id = self.lower_node_id(exist_ty_node_id);\n-        // Generate an `existential type Foo: Trait;` declaration.\n-        trace!(\"registering existential type with id {:#?}\", exist_ty_id);\n-        let exist_ty_item = hir::Item {\n-            hir_id: exist_ty_id,\n+        let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n+        let opaque_ty_id = self.lower_node_id(opaque_ty_node_id);\n+        // Generate an `type Foo = impl Trait;` declaration.\n+        trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n+        let opaque_ty_item = hir::Item {\n+            hir_id: opaque_ty_id,\n             ident: Ident::invalid(),\n             attrs: Default::default(),\n-            node: exist_ty_item_kind,\n+            node: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n-            span: exist_ty_span,\n+            span: opaque_ty_span,\n         };\n \n         // Insert the item into the global item list. This usually happens\n-        // automatically for all AST items. But this existential type item\n+        // automatically for all AST items. But this opaque type item\n         // does not actually exist in the AST.\n-        self.insert_item(exist_ty_item);\n-        exist_ty_id\n+        self.insert_item(opaque_ty_item);\n+        opaque_ty_id\n     }\n \n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n-        exist_ty_id: NodeId,\n+        opaque_ty_id: NodeId,\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n@@ -1820,7 +1820,7 @@ impl<'a> LoweringContext<'a> {\n         struct ImplTraitLifetimeCollector<'r, 'a> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n-            exist_ty_id: NodeId,\n+            opaque_ty_id: NodeId,\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n@@ -1894,7 +1894,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n                         if self.collect_elided_lifetimes {\n                             // Use `'_` for both implicit and underscore lifetimes in\n-                            // `abstract type Foo<'_>: SomeTrait<'_>;`.\n+                            // `type Foo<'_> = impl SomeTrait<'_>;`.\n                             hir::LifetimeName::Underscore\n                         } else {\n                             return;\n@@ -1916,7 +1916,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let def_node_id = self.context.sess.next_node_id();\n                     let hir_id =\n-                        self.context.lower_node_id_with_owner(def_node_id, self.exist_ty_id);\n+                        self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n@@ -1952,7 +1952,7 @@ impl<'a> LoweringContext<'a> {\n         let mut lifetime_collector = ImplTraitLifetimeCollector {\n             context: self,\n             parent: parent_index,\n-            exist_ty_id,\n+            opaque_ty_id,\n             collect_elided_lifetimes: true,\n             currently_bound_lifetimes: Vec::new(),\n             already_defined_lifetimes: FxHashSet::default(),\n@@ -2439,7 +2439,7 @@ impl<'a> LoweringContext<'a> {\n                 .as_ref()\n                 .map(|t| self.lower_ty(t,\n                     if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::Existential(Some(parent_def_id))\n+                        ImplTraitContext::OpaqueTy(Some(parent_def_id))\n                     } else {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     }\n@@ -2500,7 +2500,7 @@ impl<'a> LoweringContext<'a> {\n         let lt_mode = if make_ret_async.is_some() {\n             // In `async fn`, argument-position elided lifetimes\n             // must be transformed into fresh generic parameters so that\n-            // they can be applied to the existential return type.\n+            // they can be applied to the opaque `impl Trait` return type.\n             AnonymousLifetimeMode::CreateParameter\n         } else {\n             self.anonymous_lifetime_mode\n@@ -2539,7 +2539,7 @@ impl<'a> LoweringContext<'a> {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n                         hir::Return(self.lower_ty(ty,\n-                            ImplTraitContext::Existential(Some(def_id))\n+                            ImplTraitContext::OpaqueTy(Some(def_id))\n                         ))\n                     }\n                     _ => {\n@@ -2582,40 +2582,40 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    // Transforms `-> T` for `async fn` into `-> ExistTy { .. }`\n-    // combined with the following definition of `ExistTy`:\n+    // Transforms `-> T` for `async fn` into `-> OpaqueTy { .. }`\n+    // combined with the following definition of `OpaqueTy`:\n     //\n-    //     existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n+    //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n     // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n-    // `exist_ty_node_id`: `NodeId` of the existential type that should be created\n+    // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n     // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n-        exist_ty_node_id: NodeId,\n+        opaque_ty_node_id: NodeId,\n         elided_lt_replacement: LtReplacement,\n     ) -> hir::FunctionRetTy {\n         let span = output.span();\n \n-        let exist_ty_span = self.mark_span_with_reason(\n+        let opaque_ty_span = self.mark_span_with_reason(\n             DesugaringKind::Async,\n             span,\n             None,\n         );\n \n-        let exist_ty_def_index = self\n+        let opaque_ty_def_index = self\n             .resolver\n             .definitions()\n-            .opt_def_index(exist_ty_node_id)\n+            .opt_def_index(opaque_ty_node_id)\n             .unwrap();\n \n-        self.allocate_hir_id_counter(exist_ty_node_id);\n+        self.allocate_hir_id_counter(opaque_ty_node_id);\n \n-        let (exist_ty_id, lifetime_params) = self.with_hir_id_owner(exist_ty_node_id, |this| {\n+        let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             let future_bound = this.with_anonymous_lifetime_mode(\n                 AnonymousLifetimeMode::Replace(elided_lt_replacement),\n                 |this| this.lower_async_fn_output_type_to_future_bound(\n@@ -2626,7 +2626,7 @@ impl<'a> LoweringContext<'a> {\n             );\n \n             // Calculate all the lifetimes that should be captured\n-            // by the existential type. This should include all in-scope\n+            // by the opaque type. This should include all in-scope\n             // lifetime parameters, including those defined in-band.\n             //\n             // Note: this must be done after lowering the output type,\n@@ -2642,11 +2642,11 @@ impl<'a> LoweringContext<'a> {\n                 lifetime_params\n                     .iter().cloned()\n                     .map(|(span, hir_name)| {\n-                        this.lifetime_to_generic_param(span, hir_name, exist_ty_def_index)\n+                        this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_index)\n                     })\n                     .collect();\n \n-            let exist_ty_item = hir::ExistTy {\n+            let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: generic_params,\n                     where_clause: hir::WhereClause {\n@@ -2657,18 +2657,18 @@ impl<'a> LoweringContext<'a> {\n                 },\n                 bounds: hir_vec![future_bound],\n                 impl_trait_fn: Some(fn_def_id),\n-                origin: hir::ExistTyOrigin::AsyncFn,\n+                origin: hir::OpaqueTyOrigin::AsyncFn,\n             };\n \n-            trace!(\"exist ty from async fn def index: {:#?}\", exist_ty_def_index);\n-            let exist_ty_id = this.generate_existential_type(\n-                exist_ty_node_id,\n-                exist_ty_item,\n+            trace!(\"exist ty from async fn def index: {:#?}\", opaque_ty_def_index);\n+            let opaque_ty_id = this.generate_opaque_type(\n+                opaque_ty_node_id,\n+                opaque_ty_item,\n                 span,\n-                exist_ty_span,\n+                opaque_ty_span,\n             );\n \n-            (exist_ty_id, lifetime_params)\n+            (opaque_ty_id, lifetime_params)\n         });\n \n         let generic_args =\n@@ -2683,10 +2683,10 @@ impl<'a> LoweringContext<'a> {\n                 })\n                 .collect();\n \n-        let exist_ty_ref = hir::TyKind::Def(hir::ItemId { id: exist_ty_id }, generic_args);\n+        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n \n         hir::FunctionRetTy::Return(P(hir::Ty {\n-            node: exist_ty_ref,\n+            node: opaque_ty_ref,\n             span,\n             hir_id: self.next_id(),\n         }))\n@@ -2702,7 +2702,7 @@ impl<'a> LoweringContext<'a> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n             FunctionRetTy::Ty(ty) => {\n-                self.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n+                self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id)))\n             }\n             FunctionRetTy::Default(ret_ty_span) => {\n                 P(hir::Ty {\n@@ -2905,7 +2905,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, ImplTraitContext::Existential(None))\n+                        self.lower_ty(x, ImplTraitContext::OpaqueTy(None))\n                     }),\n                     synthetic: param.attrs.iter()\n                                           .filter(|attr| attr.check_name(sym::rustc_synthetic))\n@@ -3384,7 +3384,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_ty(\n                         t,\n                         if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::Existential(None)\n+                            ImplTraitContext::OpaqueTy(None)\n                         } else {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n@@ -3398,7 +3398,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_ty(\n                         t,\n                         if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::Existential(None)\n+                            ImplTraitContext::OpaqueTy(None)\n                         } else {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n@@ -3444,14 +3444,14 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_ty(t, ImplTraitContext::disallowed()),\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n-            ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(\n-                hir::ExistTy {\n+            ItemKind::OpaqueTy(ref b, ref generics) => hir::ItemKind::OpaqueTy(\n+                hir::OpaqueTy {\n                     generics: self.lower_generics(generics,\n-                        ImplTraitContext::Existential(None)),\n+                        ImplTraitContext::OpaqueTy(None)),\n                     bounds: self.lower_param_bounds(b,\n-                        ImplTraitContext::Existential(None)),\n+                        ImplTraitContext::OpaqueTy(None)),\n                     impl_trait_fn: None,\n-                    origin: hir::ExistTyOrigin::ExistentialType,\n+                    origin: hir::OpaqueTyOrigin::TypeAlias,\n                 },\n             ),\n             ItemKind::Enum(ref enum_definition, ref generics) => {\n@@ -3918,9 +3918,9 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::ImplItemKind::Type(self.lower_ty(ty, ImplTraitContext::disallowed())),\n             ),\n-            ImplItemKind::Existential(ref bounds) => (\n+            ImplItemKind::OpaqueTy(ref bounds) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::ImplItemKind::Existential(\n+                hir::ImplItemKind::OpaqueTy(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                 ),\n             ),\n@@ -3951,7 +3951,7 @@ impl<'a> LoweringContext<'a> {\n             kind: match i.node {\n                 ImplItemKind::Const(..) => hir::AssocItemKind::Const,\n                 ImplItemKind::Type(..) => hir::AssocItemKind::Type,\n-                ImplItemKind::Existential(..) => hir::AssocItemKind::Existential,\n+                ImplItemKind::OpaqueTy(..) => hir::AssocItemKind::OpaqueTy,\n                 ImplItemKind::Method(ref sig, _) => hir::AssocItemKind::Method {\n                     has_self: sig.decl.has_self(),\n                 },"}, {"sha": "c44942a162685693ba03fc909065c959476f23a3", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -92,7 +92,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             }\n             ItemKind::Mod(..) | ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n-            ItemKind::Existential(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n+            ItemKind::OpaqueTy(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n             ItemKind::Ty(..) => DefPathData::TypeNs(i.ident.as_interned_str()),\n             ItemKind::Fn(\n                 ref decl,\n@@ -223,7 +223,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.as_interned_str()),\n             ImplItemKind::Type(..) |\n-            ImplItemKind::Existential(..) => {\n+            ImplItemKind::OpaqueTy(..) => {\n                 DefPathData::TypeNs(ii.ident.as_interned_str())\n             },\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),"}, {"sha": "b93961a1239160c10f00661caf06e20c7f2094e8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -301,7 +301,7 @@ impl<'hir> Map<'hir> {\n                     ItemKind::Const(..) => DefKind::Const,\n                     ItemKind::Fn(..) => DefKind::Fn,\n                     ItemKind::Mod(..) => DefKind::Mod,\n-                    ItemKind::Existential(..) => DefKind::Existential,\n+                    ItemKind::OpaqueTy(..) => DefKind::OpaqueTy,\n                     ItemKind::Ty(..) => DefKind::TyAlias,\n                     ItemKind::Enum(..) => DefKind::Enum,\n                     ItemKind::Struct(..) => DefKind::Struct,\n@@ -334,7 +334,7 @@ impl<'hir> Map<'hir> {\n                     ImplItemKind::Const(..) => DefKind::AssocConst,\n                     ImplItemKind::Method(..) => DefKind::Method,\n                     ImplItemKind::Type(..) => DefKind::AssocTy,\n-                    ImplItemKind::Existential(..) => DefKind::AssocExistential,\n+                    ImplItemKind::OpaqueTy(..) => DefKind::AssocOpaqueTy,\n                 }\n             }\n             Node::Variant(_) => DefKind::Variant,\n@@ -816,7 +816,7 @@ impl<'hir> Map<'hir> {\n         }, |_| false).ok()\n     }\n \n-    /// Returns the defining scope for an existential type definition.\n+    /// Returns the defining scope for an opaque type definition.\n     pub fn get_defining_scope(&self, id: HirId) -> Option<HirId> {\n         let mut scope = id;\n         loop {\n@@ -827,7 +827,7 @@ impl<'hir> Map<'hir> {\n             match self.get(scope) {\n                 Node::Item(i) => {\n                     match i.node {\n-                        ItemKind::Existential(ExistTy { impl_trait_fn: None, .. }) => {}\n+                        ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {}\n                         _ => break,\n                     }\n                 }\n@@ -1270,7 +1270,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n                 ItemKind::ForeignMod(..) => \"foreign mod\",\n                 ItemKind::GlobalAsm(..) => \"global asm\",\n                 ItemKind::Ty(..) => \"ty\",\n-                ItemKind::Existential(..) => \"existential type\",\n+                ItemKind::OpaqueTy(..) => \"opaque type\",\n                 ItemKind::Enum(..) => \"enum\",\n                 ItemKind::Struct(..) => \"struct\",\n                 ItemKind::Union(..) => \"union\",\n@@ -1294,8 +1294,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n                 ImplItemKind::Type(_) => {\n                     format!(\"assoc type {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n-                ImplItemKind::Existential(_) => {\n-                    format!(\"assoc existential type {} in {}{}\", ii.ident, path_str(), id_str)\n+                ImplItemKind::OpaqueTy(_) => {\n+                    format!(\"assoc opaque type {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n             }\n         }"}, {"sha": "5fe8069e3326ac567785facba811dc97aa58c130", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1815,7 +1815,7 @@ pub struct ImplItemId {\n     pub hir_id: HirId,\n }\n \n-/// Represents anything within an `impl` block\n+/// Represents anything within an `impl` block.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n     pub ident: Ident,\n@@ -1832,14 +1832,14 @@ pub struct ImplItem {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n-    /// of the expression\n+    /// of the expression.\n     Const(P<Ty>, BodyId),\n-    /// A method implementation with the given signature and body\n+    /// A method implementation with the given signature and body.\n     Method(MethodSig, BodyId),\n-    /// An associated type\n+    /// An associated type.\n     Type(P<Ty>),\n-    /// An associated existential type\n-    Existential(GenericBounds),\n+    /// An associated `type = impl Trait`.\n+    OpaqueTy(GenericBounds),\n }\n \n /// Bind a type to an associated type (i.e., `A = Foo`).\n@@ -1922,20 +1922,20 @@ pub struct BareFnTy {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct ExistTy {\n+pub struct OpaqueTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n-    pub origin: ExistTyOrigin,\n+    pub origin: OpaqueTyOrigin,\n }\n \n-/// Where the existential type came from\n+/// From whence the opaque type came.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ExistTyOrigin {\n-    /// `existential type Foo: Trait;`\n-    ExistentialType,\n+pub enum OpaqueTyOrigin {\n+    /// `type Foo = impl Trait;`\n+    TypeAlias,\n     /// `-> impl Trait`\n-    ReturnImplTrait,\n+    FnReturn,\n     /// `async fn`\n     AsyncFn,\n }\n@@ -1962,7 +1962,7 @@ pub enum TyKind {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath),\n-    /// A type definition itself. This is currently only used for the `existential type`\n+    /// A type definition itself. This is currently only used for the `type Foo = impl Trait`\n     /// item that `impl Trait` in return position desugars to.\n     ///\n     /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n@@ -2421,17 +2421,17 @@ pub enum ItemKind {\n     GlobalAsm(P<GlobalAsm>),\n     /// A type alias, e.g., `type Foo = Bar<u8>`\n     Ty(P<Ty>, Generics),\n-    /// An existential type definition, e.g., `existential type Foo: Bar;`\n-    Existential(ExistTy),\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`\n+    OpaqueTy(OpaqueTy),\n     /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n     Enum(EnumDef, Generics),\n     /// A struct definition, e.g., `struct Foo<A> {x: A}`\n     Struct(VariantData, Generics),\n     /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n     Union(VariantData, Generics),\n-    /// Represents a Trait Declaration\n+    /// A trait definition\n     Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n-    /// Represents a Trait Alias Declaration\n+    /// A trait alias\n     TraitAlias(Generics, GenericBounds),\n \n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n@@ -2456,7 +2456,7 @@ impl ItemKind {\n             ItemKind::ForeignMod(..) => \"foreign module\",\n             ItemKind::GlobalAsm(..) => \"global asm\",\n             ItemKind::Ty(..) => \"type alias\",\n-            ItemKind::Existential(..) => \"existential type\",\n+            ItemKind::OpaqueTy(..) => \"opaque type\",\n             ItemKind::Enum(..) => \"enum\",\n             ItemKind::Struct(..) => \"struct\",\n             ItemKind::Union(..) => \"union\",\n@@ -2479,7 +2479,7 @@ impl ItemKind {\n         Some(match *self {\n             ItemKind::Fn(_, _, ref generics, _) |\n             ItemKind::Ty(_, ref generics) |\n-            ItemKind::Existential(ExistTy { ref generics, impl_trait_fn: None, .. }) |\n+            ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. }) |\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Struct(_, ref generics) |\n             ItemKind::Union(_, ref generics) |\n@@ -2528,7 +2528,7 @@ pub enum AssocItemKind {\n     Const,\n     Method { has_self: bool },\n     Type,\n-    Existential,\n+    OpaqueTy,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]"}, {"sha": "a8760438fc02079d3d9639e456547ea16f095971", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -450,6 +450,24 @@ impl<'a> State<'a> {\n         self.s.word(\";\")\n     }\n \n+    fn print_item_type(\n+        &mut self,\n+        item: &hir::Item,\n+        generics: &hir::Generics,\n+        inner: impl Fn(&mut Self),\n+    ) {\n+        self.head(visibility_qualified(&item.vis, \"type\"));\n+        self.print_ident(item.ident);\n+        self.print_generic_params(&generics.params);\n+        self.end(); // end the inner ibox\n+\n+        self.print_where_clause(&generics.where_clause);\n+        self.s.space();\n+        inner(self);\n+        self.s.word(\";\");\n+        self.end(); // end the outer ibox\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) {\n         self.hardbreak_if_not_bol();\n@@ -553,43 +571,28 @@ impl<'a> State<'a> {\n                 self.end()\n             }\n             hir::ItemKind::Ty(ref ty, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"type\"));\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                self.end(); // end the inner ibox\n-\n-                self.print_where_clause(&generics.where_clause);\n-                self.s.space();\n-                self.word_space(\"=\");\n-                self.print_type(&ty);\n-                self.s.word(\";\");\n-                self.end(); // end the outer ibox\n+                self.print_item_type(item, &generics, |state| {\n+                    state.word_space(\"=\");\n+                    state.print_type(&ty);\n+                });\n             }\n-            hir::ItemKind::Existential(ref exist) => {\n-                self.head(visibility_qualified(&item.vis, \"existential type\"));\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&exist.generics.params);\n-                self.end(); // end the inner ibox\n-\n-                self.print_where_clause(&exist.generics.where_clause);\n-                self.s.space();\n-                let mut real_bounds = Vec::with_capacity(exist.bounds.len());\n-                for b in exist.bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b);\n+            hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n+                self.print_item_type(item, &opaque_ty.generics, |state| {\n+                    let mut real_bounds = Vec::with_capacity(opaque_ty.bounds.len());\n+                    for b in opaque_ty.bounds.iter() {\n+                        if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                            state.s.space();\n+                            state.word_space(\"for ?\");\n+                            state.print_trait_ref(&ptr.trait_ref);\n+                        } else {\n+                            real_bounds.push(b);\n+                        }\n                     }\n-                }\n-                self.print_bounds(\":\", real_bounds);\n-                self.s.word(\";\");\n-                self.end(); // end the outer ibox\n+                    state.print_bounds(\"= impl\", real_bounds);\n+                });\n             }\n             hir::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.ident.name, item.span,\n-                                    &item.vis);\n+                self.print_enum_def(enum_definition, params, item.ident.name, item.span, &item.vis);\n             }\n             hir::ItemKind::Struct(ref struct_def, ref generics) => {\n                 self.head(visibility_qualified(&item.vis, \"struct\"));\n@@ -908,9 +911,11 @@ impl<'a> State<'a> {\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.ident, None, Some(ty));\n             }\n-            hir::ImplItemKind::Existential(ref bounds) => {\n-                self.word_space(\"existential\");\n-                self.print_associated_type(ii.ident, Some(bounds), None);\n+            hir::ImplItemKind::OpaqueTy(ref bounds) => {\n+                self.word_space(\"type\");\n+                self.print_ident(ii.ident);\n+                self.print_bounds(\"= impl\", bounds);\n+                self.s.word(\";\");\n             }\n         }\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id))"}, {"sha": "0c9c9adcf9da62bf459ef946b1d2d6ac138133f8", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -418,7 +418,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     Async,\n     Await,\n     QuestionMark,\n-    ExistentialType,\n+    OpaqueTy,\n     ForLoop,\n     TryBlock\n });"}, {"sha": "f92e03362447ffd644292a193f64c2bb76318776", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -269,7 +269,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         match item.node {\n             hir::ImplItemKind::Method(..) => \"method body\",\n             hir::ImplItemKind::Const(..)\n-            | hir::ImplItemKind::Existential(..)\n+            | hir::ImplItemKind::OpaqueTy(..)\n             | hir::ImplItemKind::Type(..) => \"associated item\",\n         }\n     }"}, {"sha": "5c62f76e3bb31e5b1912cf62d59ff891ac4fe46f", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 61, "deletions": 54, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -18,19 +18,19 @@ use syntax_pos::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n-/// Information about the opaque, abstract types whose values we\n+/// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n #[derive(Copy, Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n-    /// The substitutions that we apply to the abstract that this\n+    /// The substitutions that we apply to the opaque type that this\n     /// `impl Trait` desugars to. e.g., if:\n     ///\n     ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n     ///\n     /// winds up desugared to:\n     ///\n-    ///     abstract type Foo<'x, X>: Trait<'x>\n+    ///     type Foo<'x, X> = impl Trait<'x>\n     ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n     ///\n     /// then `substs` would be `['a, T]`.\n@@ -40,7 +40,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// for example:\n     ///\n     /// ```\n-    /// existential type Foo;\n+    /// type Foo = impl Baz;\n     /// fn bar() -> Foo {\n     ///             ^^^ This is the span we are looking for!\n     /// ```\n@@ -50,7 +50,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// over-approximated, but better than nothing.\n     pub definition_span: Span,\n \n-    /// The type variable that represents the value of the abstract type\n+    /// The type variable that represents the value of the opaque type\n     /// that we require. In other words, after we compile this function,\n     /// we will be created a constraint like:\n     ///\n@@ -87,8 +87,8 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// check.)\n     pub has_required_region_bounds: bool,\n \n-    /// The origin of the existential type\n-    pub origin: hir::ExistTyOrigin,\n+    /// The origin of the opaque type.\n+    pub origin: hir::OpaqueTyOrigin,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -143,8 +143,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         InferOk { value: (value, instantiator.opaque_types), obligations: instantiator.obligations }\n     }\n \n-    /// Given the map `opaque_types` containing the existential `impl\n-    /// Trait` types whose underlying, hidden types are being\n+    /// Given the map `opaque_types` containing the opaque\n+    /// `impl Trait` types whose underlying, hidden types are being\n     /// inferred, this method adds constraints to the regions\n     /// appearing in those underlying hidden types to ensure that they\n     /// at least do not refer to random scopes within the current\n@@ -164,12 +164,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Here, we have two `impl Trait` types whose values are being\n     /// inferred (the `impl Bar<'a>` and the `impl\n     /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n-    /// define underlying abstract types (`Foo1`, `Foo2`) and then, in\n+    /// define underlying opaque types (`Foo1`, `Foo2`) and then, in\n     /// the return type of `foo`, we *reference* those definitions:\n     ///\n     /// ```text\n-    /// abstract type Foo1<'x>: Bar<'x>;\n-    /// abstract type Foo2<'x>: Bar<'x>;\n+    /// type Foo1<'x> = impl Bar<'x>;\n+    /// type Foo2<'x> = impl Bar<'x>;\n     /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n     ///                    //  ^^^^ ^^\n     ///                    //  |    |\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// This is actually a bit of a tricky constraint in general. We\n     /// want to say that each variable (e.g., `'0`) can only take on\n-    /// values that were supplied as arguments to the abstract type\n+    /// values that were supplied as arguments to the opaque type\n     /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n     /// scope. We don't have a constraint quite of this kind in the current\n     /// region checker.\n@@ -265,24 +265,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// }\n     ///\n     /// // Equivalent to:\n-    /// existential type FooReturn<'a, T>: Foo<'a>;\n+    /// type FooReturn<'a, T> = impl Foo<'a>;\n     /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n     /// ```\n     ///\n     /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n     /// is an inference variable). If we generated a constraint that\n     /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n-    /// but this is not necessary, because the existential type we\n+    /// but this is not necessary, because the opaque type we\n     /// create will be allowed to reference `T`. So we only generate a\n     /// constraint that `'0: 'a`.\n     ///\n     /// # The `free_region_relations` parameter\n     ///\n     /// The `free_region_relations` argument is used to find the\n-    /// \"minimum\" of the regions supplied to a given abstract type.\n+    /// \"minimum\" of the regions supplied to a given opaque type.\n     /// It must be a relation that can answer whether `'a <= 'b`,\n     /// where `'a` and `'b` are regions that appear in the \"substs\"\n-    /// for the abstract type references (the `<'a>` in `Foo1<'a>`).\n+    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n     ///\n     /// Note that we do not impose the constraints based on the\n     /// generic regions from the `Foo1` definition (e.g., `'x`). This\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// Here, the fact that `'b: 'a` is known only because of the\n     /// implied bounds from the `&'a &'b u32` parameter, and is not\n-    /// \"inherent\" to the abstract type definition.\n+    /// \"inherent\" to the opaque type definition.\n     ///\n     /// # Parameters\n     ///\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // There were no `required_region_bounds`,\n         // so we have to search for a `least_region`.\n         // Go through all the regions used as arguments to the\n-        // abstract type. These are the parameters to the abstract\n+        // opaque type. These are the parameters to the opaque\n         // type; so in our example above, `substs` would contain\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n@@ -492,11 +492,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Without a feature-gate, we only generate member-constraints for async-await.\n         let context_name = match opaque_defn.origin {\n             // No feature-gate required for `async fn`.\n-            hir::ExistTyOrigin::AsyncFn => return false,\n+            hir::OpaqueTyOrigin::AsyncFn => return false,\n \n             // Otherwise, generate the label we'll use in the error message.\n-            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n-            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n+            hir::OpaqueTyOrigin::TypeAlias => \"impl Trait\",\n+            hir::OpaqueTyOrigin::FnReturn => \"impl Trait\",\n         };\n         let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n         let mut err = self.tcx.sess.struct_span_err(span, &msg);\n@@ -528,12 +528,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n-    /// (*), computes the \"definition type\" for an abstract type\n+    /// (*), computes the \"definition type\" for an opaque type\n     /// definition -- that is, the inferred value of `Foo1<'x>` or\n     /// `Foo2<'x>` that we would conceptually use in its definition:\n     ///\n-    ///     abstract type Foo1<'x>: Bar<'x> = AAA; <-- this type AAA\n-    ///     abstract type Foo2<'x>: Bar<'x> = BBB; <-- or this type BBB\n+    ///     type Foo1<'x> = impl Bar<'x> = AAA; <-- this type AAA\n+    ///     type Foo2<'x> = impl Bar<'x> = BBB; <-- or this type BBB\n     ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n     ///\n     /// Note that these values are defined in terms of a distinct set of\n@@ -842,12 +842,12 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 self.tcx.sess\n                     .struct_span_err(\n                         self.span,\n-                        \"non-defining existential type use in defining scope\"\n+                        \"non-defining opaque type use in defining scope\"\n                     )\n                     .span_label(\n                         self.span,\n                         format!(\"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of existential type\", r),\n+                                 parameter list of the `impl Trait` type alias\", r),\n                     )\n                     .emit();\n \n@@ -863,7 +863,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // we encounter a closure here, it is always a closure\n                 // from within the function that we are currently\n                 // type-checking -- one that is now being encapsulated\n-                // in an existential abstract type. Ideally, we would\n+                // in an opaque type. Ideally, we would\n                 // go through the types/lifetimes that it references\n                 // and treat them just like we would any other type,\n                 // which means we would error out if we find any\n@@ -918,15 +918,16 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list; replace with the parameter from the\n-                    // existential type.\n+                    // opaque type.\n                     Some(UnpackedKind::Type(t1)) => t1,\n                     Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         self.tcx.sess\n                             .struct_span_err(\n                                 self.span,\n                                 &format!(\"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for existential type\", ty),\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                         ty),\n                             )\n                             .emit();\n \n@@ -947,15 +948,16 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list, replace with the parameter from the\n-                    // existential type.\n+                    // opaque type.\n                     Some(UnpackedKind::Const(c1)) => c1,\n                     Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         self.tcx.sess\n                             .struct_span_err(\n                                 self.span,\n                                 &format!(\"const parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for existential type\", ct)\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                         ct)\n                             )\n                             .emit();\n \n@@ -992,15 +994,15 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // value we are inferring.  At present, this is\n                     // always true during the first phase of\n                     // type-check, but not always true later on during\n-                    // NLL. Once we support named abstract types more fully,\n+                    // NLL. Once we support named opaque types more fully,\n                     // this same scenario will be able to arise during all phases.\n                     //\n-                    // Here is an example using `abstract type` that indicates\n-                    // the distinction we are checking for:\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n                     //\n                     // ```rust\n                     // mod a {\n-                    //   pub abstract type Foo: Iterator;\n+                    //   pub type Foo = impl Iterator;\n                     //   pub fn make_foo() -> Foo { .. }\n                     // }\n                     //\n@@ -1031,36 +1033,40 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // Anonymous `impl Trait`\n-                                hir::ItemKind::Existential(hir::ExistTy {\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: Some(parent),\n                                     origin,\n                                     ..\n                                 }) => (parent == self.parent_def_id, origin),\n-                                // Named `existential type`\n-                                hir::ItemKind::Existential(hir::ExistTy {\n+                                // Named `type Foo = impl Bar;`\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: None,\n                                     origin,\n                                     ..\n                                 }) => (\n-                                    may_define_existential_type(\n+                                    may_define_opaque_type(\n                                         tcx,\n                                         self.parent_def_id,\n                                         opaque_hir_id,\n                                     ),\n                                     origin,\n                                 ),\n-                                _ => (def_scope_default(), hir::ExistTyOrigin::ExistentialType),\n+                                _ => {\n+                                    (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias)\n+                                }\n                             },\n                             Some(Node::ImplItem(item)) => match item.node {\n-                                hir::ImplItemKind::Existential(_) => (\n-                                    may_define_existential_type(\n+                                hir::ImplItemKind::OpaqueTy(_) => (\n+                                    may_define_opaque_type(\n                                         tcx,\n                                         self.parent_def_id,\n                                         opaque_hir_id,\n                                     ),\n-                                    hir::ExistTyOrigin::ExistentialType,\n+                                    hir::OpaqueTyOrigin::TypeAlias,\n                                 ),\n-                                _ => (def_scope_default(), hir::ExistTyOrigin::ExistentialType),\n+                                _ => {\n+                                    (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias)\n+                                }\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n@@ -1092,7 +1098,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n-        origin: hir::ExistTyOrigin,\n+        origin: hir::OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n@@ -1123,7 +1129,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n-        // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n+        // (e.g., `type Foo<T: Bound> = impl Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n         debug!(\"instantiate_opaque_types: param_env={:#?}\", self.param_env,);\n         debug!(\"instantiate_opaque_types: generics={:#?}\", tcx.generics_of(def_id),);\n@@ -1171,7 +1177,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n /// ```rust\n /// pub mod foo {\n ///     pub mod bar {\n-///         pub existential type Baz;\n+///         pub trait Bar { .. }\n+///\n+///         pub type Baz = impl Bar;\n ///\n ///         fn f1() -> Baz { .. }\n ///     }\n@@ -1180,18 +1188,17 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` is the `DefId` of the defining use of the existential type (e.g., `f1` or `f2`),\n-/// and `opaque_hir_id` is the `HirId` of the definition of the existential type `Baz`.\n+/// Here, `def_id` is the `DefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n+/// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n /// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n-pub fn may_define_existential_type(\n+pub fn may_define_opaque_type(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n-\n-    // Named existential types can be defined by any siblings or children of siblings.\n+    // Named opaque types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n@@ -1200,7 +1207,7 @@ pub fn may_define_existential_type(\n     // Syntactically, we are allowed to define the concrete type if:\n     let res = hir_id == scope;\n     trace!(\n-        \"may_define_existential_type(def={:?}, opaque_node={:?}) = {}\",\n+        \"may_define_opaque_type(def={:?}, opaque_node={:?}) = {}\",\n         tcx.hir().get(hir_id),\n         tcx.hir().get(opaque_hir_id),\n         res"}, {"sha": "1e4e3531e5fa02328227f0f8f1dc66630cd39ebb", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -638,7 +638,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 }\n                 self.visit_nested_body(body_id)\n             }\n-            hir::ImplItemKind::Existential(..) |\n+            hir::ImplItemKind::OpaqueTy(..) |\n             hir::ImplItemKind::Type(..) => {}\n         }\n     }"}, {"sha": "233cec2ef7d431729906bc1d2581fac0b208a672", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    hir::ImplItemKind::Existential(..) |\n+                    hir::ImplItemKind::OpaqueTy(..) |\n                     hir::ImplItemKind::Type(_) => false,\n                 }\n             }\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // worklist, as determined by the privacy pass\n                     hir::ItemKind::ExternCrate(_) |\n                     hir::ItemKind::Use(..) |\n-                    hir::ItemKind::Existential(..) |\n+                    hir::ItemKind::OpaqueTy(..) |\n                     hir::ItemKind::Ty(..) |\n                     hir::ItemKind::Static(..) |\n                     hir::ItemKind::Mod(..) |\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             self.visit_nested_body(body)\n                         }\n                     }\n-                    hir::ImplItemKind::Existential(..) |\n+                    hir::ImplItemKind::OpaqueTy(..) |\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }"}, {"sha": "80f85bec879d895b1d614554bf750ade77544b6b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -268,17 +268,17 @@ enum Scope<'a> {\n         track_lifetime_uses: bool,\n \n         /// Whether or not this binder would serve as the parent\n-        /// binder for abstract types introduced within. For example:\n+        /// binder for opaque types introduced within. For example:\n         ///\n         ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n         ///\n-        /// Here, the abstract types we create for the `impl Trait`\n+        /// Here, the opaque types we create for the `impl Trait`\n         /// and `impl Trait2` references will both have the `foo` item\n         /// as their parent. When we get to `impl Trait2`, we find\n         /// that it is nested within the `for<>` binder -- this flag\n         /// allows us to skip that when looking for the parent binder\n-        /// of the resulting abstract type.\n-        abstract_type_parent: bool,\n+        /// of the resulting opaque type.\n+        opaque_type_parent: bool,\n \n         s: ScopeRef<'a>,\n     },\n@@ -480,16 +480,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::Existential(hir::ExistTy {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 impl_trait_fn: Some(_),\n                 ..\n             }) => {\n-                // currently existential type declarations are just generated from impl Trait\n-                // items. doing anything on this node is irrelevant, as we currently don't need\n+                // Currently opaque type declarations are just generated from `impl Trait`\n+                // items. Doing anything on this node is irrelevant, as we currently don't need\n                 // it.\n             }\n             hir::ItemKind::Ty(_, ref generics)\n-            | hir::ItemKind::Existential(hir::ExistTy {\n+            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 impl_trait_fn: None,\n                 ref generics,\n                 ..\n@@ -526,7 +526,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                     track_lifetime_uses,\n                     s: ROOT_SCOPE,\n                 };\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: false,\n+                    opaque_type_parent: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -622,30 +622,30 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n-                // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n-                //                          ^            ^ this gets resolved in the scope of\n-                //                                         the exist_ty generics\n+                // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n+                //                 ^                  ^ this gets resolved in the scope of\n+                //                                      the opaque_ty generics\n                 let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node\n                 {\n-                    // named existential types are reached via TyKind::Path\n-                    // this arm is for `impl Trait` in the types of statics, constants and locals\n-                    hir::ItemKind::Existential(hir::ExistTy {\n+                    // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n+                    // This arm is for `impl Trait` in the types of statics, constants and locals.\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         impl_trait_fn: None,\n                         ..\n                     }) => {\n                         intravisit::walk_ty(self, ty);\n                         return;\n                     }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::Existential(hir::ExistTy {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         ref generics,\n                         ref bounds,\n                         ..\n                     }) => (generics, bounds),\n-                    ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n+                    ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n-                // Resolve the lifetimes that are applied to the existential type.\n+                // Resolve the lifetimes that are applied to the opaque type.\n                 // These are resolved in the current scope.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n                 // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_abstract_type();\n+                let mut index = self.next_early_index_for_opaque_type();\n                 debug!(\"visit_ty: index = {}\", index);\n \n                 let mut elision = None;\n@@ -728,7 +728,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             s: this.scope,\n                             track_lifetime_uses: true,\n-                            abstract_type_parent: false,\n+                            opaque_type_parent: false,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         next_early_index,\n                         s: self.scope,\n                         track_lifetime_uses: true,\n-                        abstract_type_parent: false,\n+                        opaque_type_parent: false,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n@@ -796,7 +796,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -848,14 +848,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });\n             }\n-            Existential(ref bounds) => {\n+            OpaqueTy(ref bounds) => {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n@@ -879,7 +879,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -967,7 +967,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             s: self.scope,\n                             next_early_index,\n                             track_lifetime_uses: true,\n-                            abstract_type_parent: false,\n+                            opaque_type_parent: false,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n-                abstract_type_parent: false,\n+                opaque_type_parent: false,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n@@ -1254,7 +1254,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Existential(hir::ExistTy {\n+            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 ref generics,\n                 impl_trait_fn: None,\n                 ..\n@@ -1753,7 +1753,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n-            abstract_type_parent: true,\n+            opaque_type_parent: true,\n             track_lifetime_uses: false,\n         };\n         self.with(scope, move |old_scope, this| {\n@@ -1762,17 +1762,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         });\n     }\n \n-    fn next_early_index_helper(&self, only_abstract_type_parent: bool) -> u32 {\n+    fn next_early_index_helper(&self, only_opaque_type_parent: bool) -> u32 {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n                 Scope::Root => return 0,\n \n                 Scope::Binder {\n                     next_early_index,\n-                    abstract_type_parent,\n+                    opaque_type_parent,\n                     ..\n-                } if (!only_abstract_type_parent || abstract_type_parent) =>\n+                } if (!only_opaque_type_parent || opaque_type_parent) =>\n                 {\n                     return next_early_index\n                 }\n@@ -1792,10 +1792,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     /// Returns the next index one would use for an `impl Trait` that\n-    /// is being converted into an `abstract type`. This will be the\n+    /// is being converted into an opaque type alias `impl Trait`. This will be the\n     /// next early index from the enclosing item, for the most\n-    /// part. See the `abstract_type_parent` field for more info.\n-    fn next_early_index_for_abstract_type(&self) -> u32 {\n+    /// part. See the `opaque_type_parent` field for more info.\n+    fn next_early_index_for_opaque_type(&self) -> u32 {\n         self.next_early_index_helper(false)\n     }\n "}, {"sha": "38263f26a59a039953210159a01c79df9f1669c9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1492,7 +1492,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n         };\n     }\n     let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n-    let ty = if let ty::AssocKind::Existential = assoc_ty.item.kind {\n+    let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n         let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n     } else {"}, {"sha": "b43881defdb859819768e66a8fc2cc5e1858f2fd", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -484,13 +484,13 @@ impl<'tcx> Ancestors<'tcx> {\n                 | (Const, Const)\n                 | (Method, Method)\n                 | (Type, Type)\n-                | (Type, Existential)\n+                | (Type, OpaqueTy)\n                 => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n \n                 | (Const, _)\n                 | (Method, _)\n                 | (Type, _)\n-                | (Existential, _)\n+                | (OpaqueTy, _)\n                 => false,\n             }).map(move |item| NodeItem { node: node, item: item })\n         })"}, {"sha": "ca6603b58530d76a79d4f7ccd1e2a656316ae367", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -281,14 +281,14 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n     }\n }\n \n-/// All information necessary to validate and reveal an `impl Trait` or `existential Type`\n+/// All information necessary to validate and reveal an `impl Trait`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ResolvedOpaqueTy<'tcx> {\n     /// The revealed type as seen by this function.\n     pub concrete_type: Ty<'tcx>,\n     /// Generic parameters on the opaque type as passed by this function.\n-    /// For `existential type Foo<A, B>; fn foo<T, U>() -> Foo<T, U> { .. }` this is `[T, U]`, not\n-    /// `[A, B]`\n+    /// For `type Foo<A, B> = impl Bar<A, B>; fn foo<T, U>() -> Foo<T, U> { .. }`\n+    /// this is `[T, U]`, not `[A, B]`.\n     pub substs: SubstsRef<'tcx>,\n }\n \n@@ -392,9 +392,9 @@ pub struct TypeckTables<'tcx> {\n     /// read-again by borrowck.\n     pub free_region_map: FreeRegionMap<'tcx>,\n \n-    /// All the existential types that are restricted to concrete types\n-    /// by this function\n-    pub concrete_existential_types: FxHashMap<DefId, ResolvedOpaqueTy<'tcx>>,\n+    /// All the opaque types that are restricted to concrete types\n+    /// by this function.\n+    pub concrete_opaque_types: FxHashMap<DefId, ResolvedOpaqueTy<'tcx>>,\n \n     /// Given the closure ID this map provides the list of UpvarIDs used by it.\n     /// The upvarID contains the HIR node ID and it also contains the full path\n@@ -424,7 +424,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: false,\n             free_region_map: Default::default(),\n-            concrete_existential_types: Default::default(),\n+            concrete_opaque_types: Default::default(),\n             upvar_list: Default::default(),\n         }\n     }\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref free_region_map,\n-            ref concrete_existential_types,\n+            ref concrete_opaque_types,\n             ref upvar_list,\n \n         } = *self;\n@@ -777,7 +777,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);\n-            concrete_existential_types.hash_stable(hcx, hasher);\n+            concrete_opaque_types.hash_stable(hcx, hasher);\n             upvar_list.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "8e170578227c0a624f36cf78b96c70b380949d69", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -185,7 +185,7 @@ pub struct AssocItem {\n pub enum AssocKind {\n     Const,\n     Method,\n-    Existential,\n+    OpaqueTy,\n     Type\n }\n \n@@ -195,15 +195,15 @@ impl AssocItem {\n             AssocKind::Const => DefKind::AssocConst,\n             AssocKind::Method => DefKind::Method,\n             AssocKind::Type => DefKind::AssocTy,\n-            AssocKind::Existential => DefKind::AssocExistential,\n+            AssocKind::OpaqueTy => DefKind::AssocOpaqueTy,\n         }\n     }\n \n     /// Tests whether the associated item admits a non-trivial implementation\n     /// for !\n     pub fn relevant_for_never(&self) -> bool {\n         match self.kind {\n-            AssocKind::Existential |\n+            AssocKind::OpaqueTy |\n             AssocKind::Const |\n             AssocKind::Type => true,\n             // FIXME(canndrew): Be more thorough here, check if any argument is uninhabited.\n@@ -221,7 +221,8 @@ impl AssocItem {\n                 tcx.fn_sig(self.def_id).skip_binder().to_string()\n             }\n             ty::AssocKind::Type => format!(\"type {};\", self.ident),\n-            ty::AssocKind::Existential => format!(\"existential type {};\", self.ident),\n+            // FIXME(type_alias_impl_trait): we should print bounds here too.\n+            ty::AssocKind::OpaqueTy => format!(\"type {};\", self.ident),\n             ty::AssocKind::Const => {\n                 format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n             }\n@@ -2822,7 +2823,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 (ty::AssocKind::Method, has_self)\n             }\n             hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-            hir::AssocItemKind::Existential => bug!(\"only impls can have existentials\"),\n+            hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n         };\n \n         AssocItem {\n@@ -2848,7 +2849,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 (ty::AssocKind::Method, has_self)\n             }\n             hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-            hir::AssocItemKind::Existential => (ty::AssocKind::Existential, false),\n+            hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n         };\n \n         AssocItem {\n@@ -3213,8 +3214,8 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         if let Node::Item(item) = tcx.hir().get(hir_id) {\n-            if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n-                return exist_ty.impl_trait_fn;\n+            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.node {\n+                return opaque_ty.impl_trait_fn;\n             }\n         }\n     }"}, {"sha": "b8533424740fd1abbe402ab8cf505cda7029b4a5", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -185,7 +185,7 @@ pub enum TyKind<'tcx> {\n     /// Opaque (`impl Trait`) type found in a return type.\n     /// The `DefId` comes either from\n     /// * the `impl Trait` ast::Ty node,\n-    /// * or the `existential type` declaration\n+    /// * or the `type Foo = impl Trait` declaration\n     /// The substitutions are for the generics of the function in question.\n     /// After typeck, the concrete type can be found in the `types` map.\n     Opaque(DefId, SubstsRef<'tcx>),"}, {"sha": "d32c32af29e0d5beda60e800814dce6c9d3abe20", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // should've been checked by the instantiation\n                     // of whatever returned this exact `impl Trait`.\n \n-                    // for named existential types we still need to check them\n+                    // for named opaque `impl Trait` types we still need to check them\n                     if super::is_impl_trait_defn(self.infcx.tcx, did).is_none() {\n                         let obligations = self.nominal_obligations(did, substs);\n                         self.out.extend(obligations);"}, {"sha": "e621101324d3440160673d71a1a19780c3526dca", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -406,7 +406,7 @@ impl DirtyCleanVisitor<'tcx> {\n                     ImplItemKind::Method(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                     ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n-                    ImplItemKind::Existential(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n+                    ImplItemKind::OpaqueTy(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n                 }\n             },\n             _ => self.tcx.sess.span_fatal("}, {"sha": "08a8d4007791379876a4186d9695b4e1f5ed20fc", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Type(_) => \"an associated type\",\n-            hir::ImplItemKind::Existential(_) => \"an associated existential type\",\n+            hir::ImplItemKind::OpaqueTy(_) => \"an associated `impl Trait` type\",\n         };\n         self.check_missing_docs_attrs(cx,\n                                       Some(impl_item.hir_id),"}, {"sha": "335ce868894136066dec59fc00a24275324f614e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -413,9 +413,9 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Type => DefKind::TyAlias,\n             EntryKind::TypeParam => DefKind::TyParam,\n             EntryKind::ConstParam => DefKind::ConstParam,\n-            EntryKind::Existential => DefKind::Existential,\n+            EntryKind::OpaqueTy => DefKind::OpaqueTy,\n             EntryKind::AssocType(_) => DefKind::AssocTy,\n-            EntryKind::AssocExistential(_) => DefKind::AssocExistential,\n+            EntryKind::AssocOpaqueTy(_) => DefKind::AssocOpaqueTy,\n             EntryKind::Mod(_) => DefKind::Mod,\n             EntryKind::Variant(_) => DefKind::Variant,\n             EntryKind::Trait(_) => DefKind::Trait,\n@@ -910,8 +910,8 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::AssocType(container) => {\n                 (ty::AssocKind::Type, container, false)\n             }\n-            EntryKind::AssocExistential(container) => {\n-                (ty::AssocKind::Existential, container, false)\n+            EntryKind::AssocOpaqueTy(container) => {\n+                (ty::AssocKind::OpaqueTy, container, false)\n             }\n             _ => bug!(\"cannot get associated-item of `{:?}`\", def_key)\n         };"}, {"sha": "28252117dd2945af6e64f44b2fc473704b8ea998", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -868,8 +868,7 @@ impl EncodeContext<'tcx> {\n                 }))\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n-            ty::AssocKind::Existential =>\n-                span_bug!(ast_item.span, \"existential type in trait\"),\n+            ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n         };\n \n         Entry {\n@@ -893,7 +892,7 @@ impl EncodeContext<'tcx> {\n                         None\n                     }\n                 }\n-                ty::AssocKind::Existential => unreachable!(),\n+                ty::AssocKind::OpaqueTy => unreachable!(),\n             },\n             inherent_impls: LazySeq::empty(),\n             variances: if trait_item.kind == ty::AssocKind::Method {\n@@ -964,7 +963,7 @@ impl EncodeContext<'tcx> {\n                     has_self: impl_item.method_has_self_argument,\n                 }))\n             }\n-            ty::AssocKind::Existential => EntryKind::AssocExistential(container),\n+            ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         };\n \n@@ -980,7 +979,7 @@ impl EncodeContext<'tcx> {\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     needs_inline || is_const_fn || always_encode_mir\n                 },\n-                hir::ImplItemKind::Existential(..) |\n+                hir::ImplItemKind::OpaqueTy(..) |\n                 hir::ImplItemKind::Type(..) => false,\n             };\n \n@@ -1096,7 +1095,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n             hir::ItemKind::Ty(..) => EntryKind::Type,\n-            hir::ItemKind::Existential(..) => EntryKind::Existential,\n+            hir::ItemKind::OpaqueTy(..) => EntryKind::OpaqueTy,\n             hir::ItemKind::Enum(..) => EntryKind::Enum(get_repr_options(tcx, def_id)),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n@@ -1229,7 +1228,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n                 hir::ItemKind::Ty(..) |\n-                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::OpaqueTy(..) |\n                 hir::ItemKind::Enum(..) |\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n@@ -1253,7 +1252,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Impl(..) |\n-                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::OpaqueTy(..) |\n                 hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n                 hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n@@ -1267,7 +1266,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Impl(..) |\n-                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::OpaqueTy(..) |\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates(def_id)),\n                 _ => None,\n@@ -1763,7 +1762,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::Use(..) |\n             hir::ItemKind::Ty(..) |\n-            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n             hir::ItemKind::TraitAlias(..) => {\n                 // no sub-item recording needed in these cases\n             }"}, {"sha": "c0ac69159330e9a9ab4920783313bda4bd8cb687", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -239,7 +239,7 @@ pub enum EntryKind<'tcx> {\n     Type,\n     TypeParam,\n     ConstParam,\n-    Existential,\n+    OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n     Variant(Lazy<VariantData<'tcx>>),\n@@ -255,7 +255,7 @@ pub enum EntryKind<'tcx> {\n     Impl(Lazy<ImplData<'tcx>>),\n     Method(Lazy<MethodData<'tcx>>),\n     AssocType(AssocContainer),\n-    AssocExistential(AssocContainer),\n+    AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n     TraitAlias(Lazy<TraitAliasData<'tcx>>),\n }"}, {"sha": "99661b1f7370ab888f7b8ff1f1c5f9d2e651bf51", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,7 +1,7 @@\n //! This module contains code to equate the input/output types appearing\n //! in the MIR with the expected input/output types from the function\n //! signature. This requires a bit of processing, as the expected types\n-//! are supplied to us before normalization and may contain existential\n+//! are supplied to us before normalization and may contain opaque\n //! `impl Trait` instances. In contrast, the input/output types found in\n //! the MIR (specifically, in the special local variables for the\n //! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n@@ -113,8 +113,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty, yield_span);\n         }\n \n-        // Return types are a bit more complex. They may contain existential `impl Trait`\n-        // types.\n+        // Return types are a bit more complex. They may contain opaque `impl Trait` types.\n         let mir_output_ty = body.local_decls[RETURN_PLACE].ty;\n         let output_span = body.local_decls[RETURN_PLACE].source_info.span;\n         if let Err(terr) = self.eq_opaque_type_and_type("}, {"sha": "b27be43dda2963bd3ac48a06f5b2e568d836bff6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1291,10 +1291,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             concrete_is_opaque\n                         );\n \n-                        // concrete_is_opaque is `true` when we're using an existential\n+                        // concrete_is_opaque is `true` when we're using an opaque `impl Trait`\n                         // type without 'revealing' it. For example, code like this:\n                         //\n-                        // existential type Foo: Debug;\n+                        // type Foo = impl Debug;\n                         // fn foo1() -> Foo { ... }\n                         // fn foo2() -> Foo { foo1() }\n                         //\n@@ -1303,8 +1303,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         //\n                         // When this occurs, we do *not* want to try to equate\n                         // the concrete type with the underlying defining type\n-                        // of the existential type - this will always fail, since\n-                        // the defining type of an existential type is always\n+                        // of the opaque type - this will always fail, since\n+                        // the defining type of an opaque type is always\n                         // some other type (e.g. not itself)\n                         // Essentially, none of the normal obligations apply here -\n                         // we're just passing around some unknown opaque type,"}, {"sha": "b378dadce58a3d0ea846bd216157e6b82b55dc3f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -972,7 +972,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::Ty(..)          |\n             hir::ItemKind::Trait(..)       |\n             hir::ItemKind::TraitAlias(..)  |\n-            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n             hir::ItemKind::Mod(..)         => {\n                 // Nothing to do, just keep recursing...\n             }"}, {"sha": "3c31bcef32b7ad2ff31d7020601548aee223b097", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -667,7 +667,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                                 \"unions cannot have zero fields\");\n                 }\n             }\n-            ItemKind::Existential(ref bounds, _) => {\n+            ItemKind::OpaqueTy(ref bounds, _) => {\n                 if !bounds.iter()\n                           .any(|b| if let GenericBound::Trait(..) = *b { true } else { false }) {\n                     let msp = MultiSpan::from_spans(bounds.iter()"}, {"sha": "ac18f0e440b781d683d3659655e68c65b6647f18", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -533,7 +533,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Fn(..) | hir::ItemKind::Mod(..) |\n             hir::ItemKind::Static(..) | hir::ItemKind::Struct(..) |\n             hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) |\n-            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n             hir::ItemKind::Ty(..) | hir::ItemKind::Union(..) | hir::ItemKind::Use(..) => {\n                 if item.vis.node.is_pub() { self.prev_level } else { None }\n             }\n@@ -584,7 +584,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n             hir::ItemKind::Use(..) |\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n@@ -612,7 +612,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::Existential(..) => {\n+            hir::ItemKind::OpaqueTy(..) => {\n                 // FIXME: This is some serious pessimization intended to workaround deficiencies\n                 // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                 // reachable if they are returned via `impl Trait`, even from private functions.\n@@ -1113,7 +1113,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 DefKind::Method\n                 | DefKind::AssocConst\n                 | DefKind::AssocTy\n-                | DefKind::AssocExistential\n+                | DefKind::AssocOpaqueTy\n                 | DefKind::Static => true,\n                 _ => false,\n             }\n@@ -1370,7 +1370,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                              self.access_levels.is_reachable(\n                                                 impl_item_ref.id.hir_id)\n                                          }\n-                                         hir::ImplItemKind::Existential(..) |\n+                                         hir::ImplItemKind::OpaqueTy(..) |\n                                          hir::ImplItemKind::Type(_) => false,\n                                      }\n                                  });\n@@ -1707,9 +1707,9 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssocItemKind::Const | AssocItemKind::Method { .. } => (true, false),\n             AssocItemKind::Type => (defaultness.has_value(), true),\n-            // `ty()` for existential types is the underlying type,\n+            // `ty()` for opaque types is the underlying type,\n             // it's not a part of interface, so we skip it.\n-            AssocItemKind::Existential => (false, true),\n+            AssocItemKind::OpaqueTy => (false, true),\n         };\n         check.in_assoc_ty = is_assoc_ty;\n         check.generics().predicates();\n@@ -1742,8 +1742,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 self.check(item.hir_id, item_visibility).generics().predicates().ty();\n             }\n-            hir::ItemKind::Existential(..) => {\n-                // `ty()` for existential types is the underlying type,\n+            hir::ItemKind::OpaqueTy(..) => {\n+                // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n             }"}, {"sha": "b66cc9e57f7f89029ace1b8e4d0ed63d2a5782bd", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -464,8 +464,8 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n-            ItemKind::Existential(_, _) => {\n-                let res = Res::Def(DefKind::Existential, self.definitions.local_def_id(item.id));\n+            ItemKind::OpaqueTy(_, _) => {\n+                let res = Res::Def(DefKind::OpaqueTy, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n@@ -656,7 +656,7 @@ impl<'a> Resolver<'a> {\n             Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::ForeignTy, _)\n-            | Res::Def(DefKind::Existential, _)\n+            | Res::Def(DefKind::OpaqueTy, _)\n             | Res::Def(DefKind::TraitAlias, _)\n             | Res::PrimTy(..)\n             | Res::ToolMod => {"}, {"sha": "a49be7c27c94ac377a48e3efb2df6fe4c9dd0c40", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -605,7 +605,7 @@ impl<'a> PathSource<'a> {\n                 | Res::PrimTy(..)\n                 | Res::Def(DefKind::TyParam, _)\n                 | Res::SelfTy(..)\n-                | Res::Def(DefKind::Existential, _)\n+                | Res::Def(DefKind::OpaqueTy, _)\n                 | Res::Def(DefKind::ForeignTy, _) => true,\n                 _ => false,\n             },\n@@ -2710,7 +2710,7 @@ impl<'a> Resolver<'a> {\n \n         match item.node {\n             ItemKind::Ty(_, ref generics) |\n-            ItemKind::Existential(_, ref generics) |\n+            ItemKind::OpaqueTy(_, ref generics) |\n             ItemKind::Fn(_, _, ref generics, _) => {\n                 self.with_generic_param_rib(\n                     HasGenericParams(generics, ItemRibKind),\n@@ -3089,7 +3089,7 @@ impl<'a> Resolver<'a> {\n \n                                                 this.visit_ty(ty);\n                                             }\n-                                            ImplItemKind::Existential(ref bounds) => {\n+                                            ImplItemKind::OpaqueTy(ref bounds) => {\n                                                 // If this is a trait impl, ensure the type\n                                                 // exists in trait\n                                                 this.check_trait_item(impl_item.ident,"}, {"sha": "3abec9307eea41047ad52bbdf8c32676e98a6ff4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1173,7 +1173,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 // trait.\n                 self.visit_ty(ty)\n             }\n-            ast::ImplItemKind::Existential(ref bounds) => {\n+            ast::ImplItemKind::OpaqueTy(ref bounds) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n@@ -1428,7 +1428,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.visit_ty(&ty);\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n-            Existential(ref _bounds, ref ty_params) => {\n+            OpaqueTy(ref _bounds, ref ty_params) => {\n                 let qualname = format!(\"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n                 // FIXME do something with _bounds"}, {"sha": "c699a8834e0e0666108295d01db5fc2dc22bd0b3", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -725,10 +725,10 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::TyAlias, def_id) |\n             Res::Def(HirDefKind::ForeignTy, def_id) |\n             Res::Def(HirDefKind::TraitAlias, def_id) |\n-            Res::Def(HirDefKind::AssocExistential, def_id) |\n+            Res::Def(HirDefKind::AssocOpaqueTy, def_id) |\n             Res::Def(HirDefKind::AssocTy, def_id) |\n             Res::Def(HirDefKind::Trait, def_id) |\n-            Res::Def(HirDefKind::Existential, def_id) |\n+            Res::Def(HirDefKind::OpaqueTy, def_id) |\n             Res::Def(HirDefKind::TyParam, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Type,"}, {"sha": "cbfaf91cdfc998d4e7352cec4634371bfa7934a0", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -438,18 +438,6 @@ impl Sig for ast::Item {\n                     refs: vec![],\n                 })\n             }\n-            ast::ItemKind::Existential(ref bounds, ref generics) => {\n-                let text = \"existential type \".to_owned();\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n-\n-                if !bounds.is_empty() {\n-                    sig.text.push_str(\": \");\n-                    sig.text.push_str(&pprust::bounds_to_string(bounds));\n-                }\n-                sig.text.push(';');\n-\n-                Ok(sig)\n-            }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n                 let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n@@ -461,6 +449,16 @@ impl Sig for ast::Item {\n \n                 Ok(merge_sigs(sig.text.clone(), vec![sig, ty]))\n             }\n+            ast::ItemKind::OpaqueTy(ref bounds, ref generics) => {\n+                let text = \"type \".to_owned();\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+\n+                sig.text.push_str(\" = impl \");\n+                sig.text.push_str(&pprust::bounds_to_string(bounds));\n+                sig.text.push(';');\n+\n+                Ok(sig)\n+            }\n             ast::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n                 let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;"}, {"sha": "1558ce1bced5242ecde30f1ce2ae8efc41b23665", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -173,7 +173,7 @@ crate fn program_clauses_for(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n             | Some(DefKind::Enum)\n             | Some(DefKind::TyAlias)\n             | Some(DefKind::Union)\n-            | Some(DefKind::Existential) => program_clauses_for_type_def(tcx, def_id),\n+            | Some(DefKind::OpaqueTy) => program_clauses_for_type_def(tcx, def_id),\n             _ => List::empty(),\n         },\n         DefPathData::Impl => program_clauses_for_impl(tcx, def_id),"}, {"sha": "e8e0dd8425bab4c4c3a39a2fae3a365a876a40b4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1956,7 +1956,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let span = path.span;\n         match path.res {\n-            Res::Def(DefKind::Existential, did) => {\n+            Res::Def(DefKind::OpaqueTy, did) => {\n                 // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();"}, {"sha": "1c01c8408be6ce2ee0ae1e0e94ac3a2d0c1922f8", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1489,7 +1489,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         match self.mode {\n             Mode::MethodCall => item.method_has_self_argument,\n             Mode::Path => match item.kind {\n-                ty::AssocKind::Existential |\n+                ty::AssocKind::OpaqueTy |\n                 ty::AssocKind::Type => false,\n                 ty::AssocKind::Method | ty::AssocKind::Const => true\n             },"}, {"sha": "8d6f9185962be8066e28087d6e0ca265d82bf337", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1330,10 +1330,10 @@ fn check_opaque<'tcx>(\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n-    origin: &hir::ExistTyOrigin\n+    origin: &hir::OpaqueTyOrigin\n ) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n-        if let hir::ExistTyOrigin::AsyncFn = origin {\n+        if let hir::OpaqueTyOrigin::AsyncFn = origin {\n             struct_span_err!(\n                 tcx.sess, span, E0733,\n                 \"recursion in an `async fn` requires boxing\",\n@@ -1403,7 +1403,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n         hir::ItemKind::Union(..) => {\n             check_union(tcx, it.hir_id, it.span);\n         }\n-        hir::ItemKind::Existential(hir::ExistTy{origin, ..}) => {\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy{origin, ..}) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1542,7 +1542,7 @@ fn check_specialization_validity<'tcx>(\n     let kind = match impl_item.node {\n         hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n         hir::ImplItemKind::Method(..) => ty::AssocKind::Method,\n-        hir::ImplItemKind::Existential(..) => ty::AssocKind::Existential,\n+        hir::ImplItemKind::OpaqueTy(..) => ty::AssocKind::OpaqueTy,\n         hir::ImplItemKind::Type(_) => ty::AssocKind::Type\n     };\n \n@@ -1639,7 +1639,7 @@ fn check_impl_items_against_trait<'tcx>(\n                          err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Existential(..) |\n+                hir::ImplItemKind::OpaqueTy(..) |\n                 hir::ImplItemKind::Type(_) => {\n                     if ty_trait_item.kind == ty::AssocKind::Type {\n                         if ty_trait_item.defaultness.has_value() {"}, {"sha": "c1d8fde3be15b38462d97aeb123514c375bcb7a5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::ConstValue;\n use rustc::middle::lang_items;\n-use rustc::infer::opaque_types::may_define_existential_type;\n+use rustc::infer::opaque_types::may_define_opaque_type;\n \n use syntax::ast;\n use syntax::feature_gate::{self, GateIssue};\n@@ -218,8 +218,8 @@ fn check_associated_item(\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n             }\n-            ty::AssocKind::Existential => {\n-                // do nothing, existential types check themselves\n+            ty::AssocKind::OpaqueTy => {\n+                // Do nothing: opaque types check themselves.\n             }\n         }\n \n@@ -560,7 +560,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     let mut predicates = predicates.instantiate_identity(fcx.tcx);\n \n     if let Some(return_ty) = return_ty {\n-        predicates.predicates.extend(check_existential_types(tcx, fcx, def_id, span, return_ty));\n+        predicates.predicates.extend(check_opaque_types(tcx, fcx, def_id, span, return_ty));\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n@@ -605,14 +605,14 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     check_where_clauses(tcx, fcx, span, def_id, Some(sig.output()));\n }\n \n-/// Checks \"defining uses\" of existential types to ensure that they meet the restrictions laid for\n-/// \"higher-order pattern unification\".\n+/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n+/// laid for \"higher-order pattern unification\".\n /// This ensures that inference is tractable.\n-/// In particular, definitions of existential types can only use other generics as arguments,\n+/// In particular, definitions of opaque types can only use other generics as arguments,\n /// and they cannot repeat an argument. Example:\n ///\n /// ```rust\n-/// existential type Foo<A, B>;\n+/// type Foo<A, B> = impl Bar<A, B>;\n ///\n /// // Okay -- `Foo` is applied to two distinct, generic types.\n /// fn a<T, U>() -> Foo<T, U> { .. }\n@@ -624,26 +624,26 @@ fn check_fn_or_method<'fcx, 'tcx>(\n /// fn b<T>() -> Foo<T, u32> { .. }\n /// ```\n ///\n-fn check_existential_types<'fcx, 'tcx>(\n+fn check_opaque_types<'fcx, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     fn_def_id: DefId,\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n-    trace!(\"check_existential_types(ty={:?})\", ty);\n+    trace!(\"check_opaque_types(ty={:?})\", ty);\n     let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.sty {\n-                trace!(\"check_existential_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n+                trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // Only check named existential types defined in this crate.\n+                // Only check named `impl Trait` types defined in this crate.\n                 if generics.parent.is_none() && def_id.is_local() {\n                     let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-                    if may_define_existential_type(tcx, fn_def_id, opaque_hir_id) {\n-                        trace!(\"check_existential_types: may define, generics={:#?}\", generics);\n+                    if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n+                        trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n@@ -654,7 +654,7 @@ fn check_existential_types<'fcx, 'tcx>(\n                                         tcx.sess\n                                             .struct_span_err(\n                                                 span,\n-                                                \"non-defining existential type use \\\n+                                                \"non-defining opaque type use \\\n                                                  in defining scope\",\n                                             )\n                                             .span_note(\n@@ -676,14 +676,14 @@ fn check_existential_types<'fcx, 'tcx>(\n                                             .sess\n                                             .struct_span_err(\n                                                 span,\n-                                                \"non-defining existential type use \\\n+                                                \"non-defining opaque type use \\\n                                                     in defining scope\",\n                                             )\n                                             .span_label(\n                                                 param_span,\n-                                                \"cannot use static lifetime, use a bound lifetime \\\n+                                                \"cannot use static lifetime; use a bound lifetime \\\n                                                 instead or remove the lifetime parameter from the \\\n-                                                existential type\",\n+                                                opaque type\",\n                                             )\n                                             .emit();\n                                     } else {\n@@ -697,7 +697,7 @@ fn check_existential_types<'fcx, 'tcx>(\n                                         tcx.sess\n                                             .struct_span_err(\n                                                 span,\n-                                                \"non-defining existential type use \\\n+                                                \"non-defining opaque type use \\\n                                                 in defining scope\",\n                                             )\n                                             .span_note(\n@@ -719,7 +719,7 @@ fn check_existential_types<'fcx, 'tcx>(\n                                     .sess\n                                     .struct_span_err(\n                                         span,\n-                                        \"non-defining existential type use \\\n+                                        \"non-defining opaque type use \\\n                                             in defining scope\",\n                                     ).\n                                     span_note(\n@@ -729,21 +729,21 @@ fn check_existential_types<'fcx, 'tcx>(\n                                     .emit();\n                             }\n                         }\n-                    } // if may_define_existential_type\n+                    } // if may_define_opaque_type\n \n-                    // Now register the bounds on the parameters of the existential type\n+                    // Now register the bounds on the parameters of the opaque type\n                     // so the parameters given by the function need to fulfill them.\n                     //\n-                    //     existential type Foo<T: Bar>: 'static;\n+                    //     type Foo<T: Bar> = impl Baz + 'static;\n                     //     fn foo<U>() -> Foo<U> { .. *}\n                     //\n                     // becomes\n                     //\n-                    //     existential type Foo<T: Bar>: 'static;\n+                    //     type Foo<T: Bar> = impl Baz + 'static;\n                     //     fn foo<U: Bar>() -> Foo<U> { .. *}\n                     let predicates = tcx.predicates_of(def_id);\n                     trace!(\n-                        \"check_existential_types: may define, predicates={:#?}\",\n+                        \"check_opaque_types: may define, predicates={:#?}\",\n                         predicates,\n                     );\n                     for &(pred, _) in predicates.predicates.iter() {\n@@ -753,7 +753,7 @@ fn check_existential_types<'fcx, 'tcx>(\n                             substituted_predicates.push(substituted_pred);\n                         }\n                     }\n-                } // if is_named_existential_type\n+                } // if is_named_opaque_type\n             } // if let Opaque\n             ty\n         },"}, {"sha": "67a8ecaf1da85d2ed44a9623666a57a042ee4805", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -443,10 +443,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // * `fn foo<T: Bound + Other>() -> Foo<T>`\n             // from being defining.\n \n-            // Also replace all generic params with the ones from the existential type\n+            // Also replace all generic params with the ones from the opaque type\n             // definition so that\n             // ```rust\n-            // existential type Foo<T>: 'static;\n+            // type Foo<T> = impl Baz + 'static;\n             // fn foo<U>() -> Foo<U> { .. }\n             // ```\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n@@ -464,8 +464,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             }\n \n             if !opaque_defn.substs.has_local_value() {\n-                // We only want to add an entry into `concrete_existential_types`\n-                // if we actually found a defining usage of this existential type.\n+                // We only want to add an entry into `concrete_opaque_types`\n+                // if we actually found a defining usage of this opaque type.\n                 // Otherwise, we do nothing - we'll either find a defining usage\n                 // in some other location, or we'll end up emitting an error due\n                 // to the lack of defining usage\n@@ -476,14 +476,14 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     };\n \n                     let old = self.tables\n-                        .concrete_existential_types\n+                        .concrete_opaque_types\n                         .insert(def_id, new);\n                     if let Some(old) = old {\n                         if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n                             span_bug!(\n                                 span,\n                                 \"visit_opaque_types tried to write different types for the same \\\n-                                existential type: {:?}, {:?}, {:?}, {:?}\",\n+                                opaque type: {:?}, {:?}, {:?}, {:?}\",\n                                 def_id,\n                                 definition_ty,\n                                 opaque_defn,"}, {"sha": "15687eaa943e115da6456cb380731e1aa3925c5a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -294,7 +294,7 @@ fn type_param_predicates(\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n                 | ItemKind::Ty(_, ref generics)\n-                | ItemKind::Existential(ExistTy {\n+                | ItemKind::OpaqueTy(OpaqueTy {\n                     ref generics,\n                     impl_trait_fn: None,\n                     ..\n@@ -456,12 +456,12 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         }\n \n         // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::Existential(hir::ExistTy {\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n             impl_trait_fn: Some(_),\n             ..\n         }) => {}\n \n-        hir::ItemKind::Existential(..)\n+        hir::ItemKind::OpaqueTy(..)\n         | hir::ItemKind::Ty(..)\n         | hir::ItemKind::Static(..)\n         | hir::ItemKind::Const(..)\n@@ -896,7 +896,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n         Node::Item(item) => match item.node {\n-            ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n+            ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n         _ => None,\n@@ -920,7 +920,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                 ItemKind::Ty(_, ref generics)\n                 | ItemKind::Enum(_, ref generics)\n                 | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Existential(hir::ExistTy { ref generics, .. })\n+                | ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, .. })\n                 | ItemKind::Union(_, ref generics) => {\n                     allow_defaults = true;\n                     generics\n@@ -1210,15 +1210,15 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     icx.to_ty(ty)\n                 }\n             },\n-            ImplItemKind::Existential(_) => {\n+            ImplItemKind::OpaqueTy(_) => {\n                 if tcx\n                     .impl_trait_ref(tcx.hir().get_parent_did(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n                 }\n \n-                find_existential_constraints(tcx, def_id)\n+                find_opaque_ty_constraints(tcx, def_id)\n             }\n             ImplItemKind::Type(ref ty) => {\n                 if tcx\n@@ -1253,27 +1253,27 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n-                ItemKind::Existential(hir::ExistTy {\n+                ItemKind::OpaqueTy(hir::OpaqueTy {\n                     impl_trait_fn: None,\n                     ..\n-                }) => find_existential_constraints(tcx, def_id),\n-                // Existential types desugared from `impl Trait`.\n-                ItemKind::Existential(hir::ExistTy {\n+                }) => find_opaque_ty_constraints(tcx, def_id),\n+                // Opaque types desugared from `impl Trait`.\n+                ItemKind::OpaqueTy(hir::OpaqueTy {\n                     impl_trait_fn: Some(owner),\n                     ..\n                 }) => {\n                     tcx.typeck_tables_of(owner)\n-                        .concrete_existential_types\n+                        .concrete_opaque_types\n                         .get(&def_id)\n                         .map(|opaque| opaque.concrete_type)\n                         .unwrap_or_else(|| {\n                             // This can occur if some error in the\n                             // owner fn prevented us from populating\n-                            // the `concrete_existential_types` table.\n+                            // the `concrete_opaque_types` table.\n                             tcx.sess.delay_span_bug(\n                                 DUMMY_SP,\n                                 &format!(\n-                                    \"owner {:?} has no existential type for {:?} in its tables\",\n+                                    \"owner {:?} has no opaque type for {:?} in its tables\",\n                                     owner, def_id,\n                                 ),\n                             );\n@@ -1505,20 +1505,20 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n     })\n }\n \n-fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n-    debug!(\"find_existential_constraints({:?})\", def_id);\n+    debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n \n     struct ConstraintLocator<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        // (first found type span, actual type, mapping from the existential type's generic\n+        // (first found type span, actual type, mapping from the opaque type's generic\n         // parameters to the concrete type's generic parameters)\n         //\n         // The mapping is an index for each use site of a generic parameter in the concrete type\n         //\n-        // The indices index into the generic parameters on the existential type.\n+        // The indices index into the generic parameters on the opaque type.\n         found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n     }\n \n@@ -1527,7 +1527,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             // Don't try to check items that cannot possibly constrain the type.\n             if !self.tcx.has_typeck_tables(def_id) {\n                 debug!(\n-                    \"find_existential_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n                     self.def_id,\n                     def_id,\n                 );\n@@ -1536,11 +1536,11 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             let ty = self\n                 .tcx\n                 .typeck_tables_of(def_id)\n-                .concrete_existential_types\n+                .concrete_opaque_types\n                 .get(&self.def_id);\n             if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n                 debug!(\n-                    \"find_existential_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n+                    \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n                     self.def_id,\n                     def_id,\n                     ty,\n@@ -1561,7 +1561,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 self.tcx.sess.span_err(\n                                     span,\n                                     &format!(\n-                                        \"defining existential type use restricts existential \\\n+                                        \"defining opaque type use restricts opaque \\\n                                          type by using the generic parameter `{}` twice\",\n                                         p.name\n                                     ),\n@@ -1572,14 +1572,14 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                             self.tcx.sess.delay_span_bug(\n                                 span,\n                                 &format!(\n-                                    \"non-defining exist ty use in defining scope: {:?}, {:?}\",\n+                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n                                     concrete_type, substs,\n                                 ),\n                             );\n                         }\n                     }\n                 }\n-                // Compute the index within the existential type for each generic parameter used in\n+                // Compute the index within the opaque type for each generic parameter used in\n                 // the concrete type.\n                 let indices = concrete_type\n                     .subst(self.tcx, substs)\n@@ -1595,7 +1595,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 if !substs.types().all(is_param) {\n                     self.tcx.sess.span_err(\n                         span,\n-                        \"defining existential type use does not fully define existential type\",\n+                        \"defining opaque type use does not fully define opaque type\",\n                     );\n                 } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n                     let mut ty = concrete_type.walk().fuse();\n@@ -1608,11 +1608,11 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         _ => t == p,\n                     });\n                     if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n-                        debug!(\"find_existential_constraints: span={:?}\", span);\n-                        // Found different concrete types for the existential type.\n+                        debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n+                        // Found different concrete types for the opaque type.\n                         let mut err = self.tcx.sess.struct_span_err(\n                             span,\n-                            \"concrete type differs from previous defining existential type use\",\n+                            \"concrete type differs from previous defining opaque type use\",\n                         );\n                         err.span_label(\n                             span,\n@@ -1651,7 +1651,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n             } else {\n                 debug!(\n-                    \"find_existential_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n                     self.def_id,\n                     def_id,\n                 );\n@@ -1666,7 +1666,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn visit_item(&mut self, it: &'tcx Item) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            // The existential type itself or its children are not within its reveal scope.\n+            // The opaque type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_item(self, it);\n@@ -1675,7 +1675,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            // The existential type itself or its children are not within its reveal scope.\n+            // The opaque type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n@@ -1699,12 +1699,12 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         found: None,\n     };\n \n-    debug!(\"find_existential_constraints: scope={:?}\", scope);\n+    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n \n     if scope == hir::CRATE_HIR_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n-        debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get(scope));\n+        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n             // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n             // This allows our visitor to process the defining item itself, causing\n@@ -1713,7 +1713,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             // For example, this code:\n             // ```\n             // fn foo() {\n-            //     existential type Blah: Debug;\n+            //     type Blah = impl Debug;\n             //     let my_closure = || -> Blah { true };\n             // }\n             // ```\n@@ -1724,7 +1724,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             Node::ImplItem(ref it) => locator.visit_impl_item(it),\n             Node::TraitItem(ref it) => locator.visit_trait_item(it),\n             other => bug!(\n-                \"{:?} is not a valid scope for an existential type item\",\n+                \"{:?} is not a valid scope for an opaque type item\",\n                 other\n             ),\n         }\n@@ -2010,7 +2010,7 @@ fn explicit_predicates_of(\n         Node::TraitItem(item) => &item.generics,\n \n         Node::ImplItem(item) => match item.node {\n-            ImplItemKind::Existential(ref bounds) => {\n+            ImplItemKind::OpaqueTy(ref bounds) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n@@ -2051,7 +2051,7 @@ fn explicit_predicates_of(\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), &empty_trait_items));\n                     generics\n                 }\n-                ItemKind::Existential(ExistTy {\n+                ItemKind::OpaqueTy(OpaqueTy {\n                     ref bounds,\n                     impl_trait_fn,\n                     ref generics,\n@@ -2077,7 +2077,7 @@ fn explicit_predicates_of(\n                             predicates: bounds_predicates,\n                         });\n                     } else {\n-                        // named existential types\n+                        // named opaque types\n                         predicates.extend(bounds_predicates);\n                         generics\n                     }"}, {"sha": "732f0d3ebf2ffa476eea81b8bb15c18099434a68", "filename": "src/librustc_typeck/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustc_typeck%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fnamespace.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -11,7 +11,7 @@ pub enum Namespace {\n impl From<ty::AssocKind> for Namespace {\n     fn from(a_kind: ty::AssocKind) -> Self {\n         match a_kind {\n-            ty::AssocKind::Existential |\n+            ty::AssocKind::OpaqueTy |\n             ty::AssocKind::Type => Namespace::Type,\n             ty::AssocKind::Const |\n             ty::AssocKind::Method => Namespace::Value,\n@@ -22,7 +22,7 @@ impl From<ty::AssocKind> for Namespace {\n impl<'a> From <&'a hir::ImplItemKind> for Namespace {\n     fn from(impl_kind: &'a hir::ImplItemKind) -> Self {\n         match *impl_kind {\n-            hir::ImplItemKind::Existential(..) |\n+            hir::ImplItemKind::OpaqueTy(..) |\n             hir::ImplItemKind::Type(..) => Namespace::Type,\n             hir::ImplItemKind::Const(..) |\n             hir::ImplItemKind::Method(..) => Namespace::Value,"}, {"sha": "a41b12e29b055b7cbcfb2925e006673a5d75e5be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -538,7 +538,7 @@ pub enum ItemEnum {\n     FunctionItem(Function),\n     ModuleItem(Module),\n     TypedefItem(Typedef, bool /* is associated type */),\n-    ExistentialItem(Existential, bool /* is associated type */),\n+    OpaqueTyItem(OpaqueTy, bool /* is associated type */),\n     StaticItem(Static),\n     ConstantItem(Constant),\n     TraitItem(Trait),\n@@ -574,7 +574,7 @@ impl ItemEnum {\n             ItemEnum::EnumItem(ref e) => &e.generics,\n             ItemEnum::FunctionItem(ref f) => &f.generics,\n             ItemEnum::TypedefItem(ref t, _) => &t.generics,\n-            ItemEnum::ExistentialItem(ref t, _) => &t.generics,\n+            ItemEnum::OpaqueTyItem(ref t, _) => &t.generics,\n             ItemEnum::TraitItem(ref t) => &t.generics,\n             ItemEnum::ImplItem(ref i) => &i.generics,\n             ItemEnum::TyMethodItem(ref i) => &i.generics,\n@@ -623,7 +623,7 @@ impl Clean<Item> for doctree::Module<'_> {\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.typedefs.iter().map(|x| x.clean(cx)));\n-        items.extend(self.existentials.iter().map(|x| x.clean(cx)));\n+        items.extend(self.opaque_tys.iter().map(|x| x.clean(cx)));\n         items.extend(self.statics.iter().map(|x| x.clean(cx)));\n         items.extend(self.constants.iter().map(|x| x.clean(cx)));\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n@@ -2257,7 +2257,7 @@ impl Clean<Item> for hir::ImplItem {\n                 type_: ty.clean(cx),\n                 generics: Generics::default(),\n             }, true),\n-            hir::ImplItemKind::Existential(ref bounds) => ExistentialItem(Existential {\n+            hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(OpaqueTy {\n                 bounds: bounds.clean(cx),\n                 generics: Generics::default(),\n             }, true),\n@@ -2415,7 +2415,7 @@ impl Clean<Item> for ty::AssocItem {\n                     }, true)\n                 }\n             }\n-            ty::AssocKind::Existential => unimplemented!(),\n+            ty::AssocKind::OpaqueTy => unimplemented!(),\n         };\n \n         let visibility = match self.container {\n@@ -2776,7 +2776,7 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n                 let item = cx.tcx.hir().expect_item(item_id.id);\n-                if let hir::ItemKind::Existential(ref ty) = item.node {\n+                if let hir::ItemKind::OpaqueTy(ref ty) = item.node {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n                     unreachable!()\n@@ -3648,12 +3648,12 @@ impl Clean<Item> for doctree::Typedef<'_> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct Existential {\n+pub struct OpaqueTy {\n     pub bounds: Vec<GenericBound>,\n     pub generics: Generics,\n }\n \n-impl Clean<Item> for doctree::Existential<'_> {\n+impl Clean<Item> for doctree::OpaqueTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3663,9 +3663,9 @@ impl Clean<Item> for doctree::Existential<'_> {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            inner: ExistentialItem(Existential {\n-                bounds: self.exist_ty.bounds.clean(cx),\n-                generics: self.exist_ty.generics.clean(cx),\n+            inner: OpaqueTyItem(OpaqueTy {\n+                bounds: self.opaque_ty.bounds.clean(cx),\n+                generics: self.opaque_ty.generics.clean(cx),\n             }, false),\n         }\n     }"}, {"sha": "ec60241a92d4ec0b1a4bc87b0195b98ec55c4a7b", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -26,7 +26,7 @@ pub struct Module<'hir> {\n     pub mods: Vec<Module<'hir>>,\n     pub id: NodeId,\n     pub typedefs: Vec<Typedef<'hir>>,\n-    pub existentials: Vec<Existential<'hir>>,\n+    pub opaque_tys: Vec<OpaqueTy<'hir>>,\n     pub statics: Vec<Static<'hir>>,\n     pub constants: Vec<Constant<'hir>>,\n     pub traits: Vec<Trait<'hir>>,\n@@ -64,7 +64,7 @@ impl Module<'hir> {\n             fns        :   Vec::new(),\n             mods       :   Vec::new(),\n             typedefs   :   Vec::new(),\n-            existentials:  Vec::new(),\n+            opaque_tys :  Vec::new(),\n             statics    :   Vec::new(),\n             constants  :   Vec::new(),\n             traits     :   Vec::new(),\n@@ -162,8 +162,8 @@ pub struct Typedef<'hir> {\n     pub depr: Option<attr::Deprecation>,\n }\n \n-pub struct Existential<'hir> {\n-    pub exist_ty: &'hir hir::ExistTy,\n+pub struct OpaqueTy<'hir> {\n+    pub opaque_ty: &'hir hir::OpaqueTy,\n     pub name: Name,\n     pub id: hir::HirId,\n     pub attrs: &'hir hir::HirVec<ast::Attribute>,"}, {"sha": "cf51a4eb5a5be862e799e720c645d61d99b9e463", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -39,7 +39,7 @@ pub enum ItemType {\n     Union           = 19,\n     ForeignType     = 20,\n     Keyword         = 21,\n-    Existential     = 22,\n+    OpaqueTy        = 22,\n     ProcAttribute   = 23,\n     ProcDerive      = 24,\n     TraitAlias      = 25,\n@@ -70,7 +70,7 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::EnumItem(..)            => ItemType::Enum,\n             clean::FunctionItem(..)        => ItemType::Function,\n             clean::TypedefItem(..)         => ItemType::Typedef,\n-            clean::ExistentialItem(..)     => ItemType::Existential,\n+            clean::OpaqueTyItem(..)        => ItemType::OpaqueTy,\n             clean::StaticItem(..)          => ItemType::Static,\n             clean::ConstantItem(..)        => ItemType::Constant,\n             clean::TraitItem(..)           => ItemType::Trait,\n@@ -144,7 +144,7 @@ impl ItemType {\n             ItemType::AssocConst      => \"associatedconstant\",\n             ItemType::ForeignType     => \"foreigntype\",\n             ItemType::Keyword         => \"keyword\",\n-            ItemType::Existential     => \"existential\",\n+            ItemType::OpaqueTy        => \"opaque\",\n             ItemType::ProcAttribute   => \"attr\",\n             ItemType::ProcDerive      => \"derive\",\n             ItemType::TraitAlias      => \"traitalias\",\n@@ -161,7 +161,7 @@ impl ItemType {\n             ItemType::Trait |\n             ItemType::Primitive |\n             ItemType::AssocType |\n-            ItemType::Existential |\n+            ItemType::OpaqueTy |\n             ItemType::TraitAlias |\n             ItemType::ForeignType => NameSpace::Type,\n "}, {"sha": "2774f2b4751bac64ec759942f1f872a8c94423e7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1886,7 +1886,7 @@ struct AllTypes {\n     macros: FxHashSet<ItemEntry>,\n     functions: FxHashSet<ItemEntry>,\n     typedefs: FxHashSet<ItemEntry>,\n-    existentials: FxHashSet<ItemEntry>,\n+    opaque_tys: FxHashSet<ItemEntry>,\n     statics: FxHashSet<ItemEntry>,\n     constants: FxHashSet<ItemEntry>,\n     keywords: FxHashSet<ItemEntry>,\n@@ -1907,7 +1907,7 @@ impl AllTypes {\n             macros: new_set(100),\n             functions: new_set(100),\n             typedefs: new_set(100),\n-            existentials: new_set(100),\n+            opaque_tys: new_set(100),\n             statics: new_set(100),\n             constants: new_set(100),\n             keywords: new_set(100),\n@@ -1932,7 +1932,7 @@ impl AllTypes {\n                 ItemType::Macro => self.macros.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Function => self.functions.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Typedef => self.typedefs.insert(ItemEntry::new(new_url, name)),\n-                ItemType::Existential => self.existentials.insert(ItemEntry::new(new_url, name)),\n+                ItemType::OpaqueTy => self.opaque_tys.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Static => self.statics.insert(ItemEntry::new(new_url, name)),\n                 ItemType::Constant => self.constants.insert(ItemEntry::new(new_url, name)),\n                 ItemType::ProcAttribute => self.attributes.insert(ItemEntry::new(new_url, name)),\n@@ -1982,7 +1982,7 @@ impl fmt::Display for AllTypes {\n         print_entries(f, &self.functions, \"Functions\", \"functions\")?;\n         print_entries(f, &self.typedefs, \"Typedefs\", \"typedefs\")?;\n         print_entries(f, &self.trait_aliases, \"Trait Aliases\", \"trait-aliases\")?;\n-        print_entries(f, &self.existentials, \"Existentials\", \"existentials\")?;\n+        print_entries(f, &self.opaque_tys, \"Opaque Types\", \"opaque-types\")?;\n         print_entries(f, &self.statics, \"Statics\", \"statics\")?;\n         print_entries(f, &self.constants, \"Constants\", \"constants\")\n     }\n@@ -2480,7 +2480,7 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n             clean::ForeignTypeItem => write!(fmt, \"Foreign Type \")?,\n             clean::KeywordItem(..) => write!(fmt, \"Keyword \")?,\n-            clean::ExistentialItem(..) => write!(fmt, \"Existential Type \")?,\n+            clean::OpaqueTyItem(..) => write!(fmt, \"Opaque Type \")?,\n             clean::TraitAliasItem(..) => write!(fmt, \"Trait Alias \")?,\n             _ => {\n                 // We don't generate pages for any other type.\n@@ -2519,7 +2519,7 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::ConstantItem(ref c) => item_constant(fmt, self.cx, self.item, c),\n             clean::ForeignTypeItem => item_foreign_type(fmt, self.cx, self.item),\n             clean::KeywordItem(ref k) => item_keyword(fmt, self.cx, self.item, k),\n-            clean::ExistentialItem(ref e, _) => item_existential(fmt, self.cx, self.item, e),\n+            clean::OpaqueTyItem(ref e, _) => item_opaque_ty(fmt, self.cx, self.item, e),\n             clean::TraitAliasItem(ref ta) => item_trait_alias(fmt, self.cx, self.item, ta),\n             _ => {\n                 // We don't generate pages for any other type.\n@@ -4390,15 +4390,15 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n     Ok(())\n }\n \n-fn item_existential(\n+fn item_opaque_ty(\n     w: &mut fmt::Formatter<'_>,\n     cx: &Context,\n     it: &clean::Item,\n-    t: &clean::Existential,\n+    t: &clean::OpaqueTy,\n ) -> fmt::Result {\n-    write!(w, \"<pre class='rust existential'>\")?;\n+    write!(w, \"<pre class='rust opaque'>\")?;\n     render_attributes(w, it, false)?;\n-    write!(w, \"existential type {}{}{where_clause}: {bounds};</pre>\",\n+    write!(w, \"type {}{}{where_clause} = impl {bounds};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n@@ -4986,7 +4986,7 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n         ItemType::AssocConst      => (\"associated-consts\", \"Associated Constants\"),\n         ItemType::ForeignType     => (\"foreign-types\", \"Foreign Types\"),\n         ItemType::Keyword         => (\"keywords\", \"Keywords\"),\n-        ItemType::Existential     => (\"existentials\", \"Existentials\"),\n+        ItemType::OpaqueTy        => (\"opaque-types\", \"Opaque Types\"),\n         ItemType::ProcAttribute   => (\"attributes\", \"Attribute Macros\"),\n         ItemType::ProcDerive      => (\"derives\", \"Derive Macros\"),\n         ItemType::TraitAlias      => (\"trait-aliases\", \"Trait aliases\"),"}, {"sha": "ca40d6d02f86dc934a3ef652f0c95fe441790264", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -159,7 +159,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                 return ret;\n             }\n             // These items can all get re-exported\n-            clean::ExistentialItem(..)\n+            clean::OpaqueTyItem(..)\n             | clean::TypedefItem(..)\n             | clean::StaticItem(..)\n             | clean::StructItem(..)"}, {"sha": "098cecef95c8df8ee23dc26c33569d57ff18edd7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -472,9 +472,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.typedefs.push(t);\n             },\n-            hir::ItemKind::Existential(ref exist_ty) => {\n-                let t = Existential {\n-                    exist_ty,\n+            hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n+                let t = OpaqueTy {\n+                    opaque_ty,\n                     name: ident.name,\n                     id: item.hir_id,\n                     attrs: &item.attrs,\n@@ -483,7 +483,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n-                om.existentials.push(t);\n+                om.opaque_tys.push(t);\n             },\n             hir::ItemKind::Static(ref type_, mutability, expr) => {\n                 let s = Static {"}, {"sha": "60db7a16a774921540eaef0c03aca84fe59d218b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1488,6 +1488,7 @@ pub enum TraitItemKind {\n     Macro(Mac),\n }\n \n+/// Represents anything within an `impl` block.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n@@ -1502,12 +1503,13 @@ pub struct ImplItem {\n     pub tokens: Option<TokenStream>,\n }\n \n+/// Represents various kinds of content within an `impl`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ImplItemKind {\n     Const(P<Ty>, P<Expr>),\n     Method(MethodSig, P<Block>),\n     Type(P<Ty>),\n-    Existential(GenericBounds),\n+    OpaqueTy(GenericBounds),\n     Macro(Mac),\n }\n \n@@ -1710,7 +1712,7 @@ pub enum TyKind {\n     ///\n     /// The `NodeId` exists to prevent lowering from having to\n     /// generate `NodeId`s on the fly, which would complicate\n-    /// the generation of `existential type` items significantly.\n+    /// the generation of opaque `type Foo = impl Trait` items significantly.\n     ImplTrait(NodeId, GenericBounds),\n     /// No-op; kept solely so that we can pretty-print faithfully.\n     Paren(P<Ty>),\n@@ -2334,10 +2336,10 @@ pub enum ItemKind {\n     ///\n     /// E.g., `type Foo = Bar<u8>;`.\n     Ty(P<Ty>, Generics),\n-    /// An existential type declaration (`existential type`).\n+    /// An opaque `impl Trait` type alias.\n     ///\n-    /// E.g., `existential type Foo: Bar + Boo;`.\n-    Existential(GenericBounds, Generics),\n+    /// E.g., `type Foo = impl Bar + Boo;`.\n+    OpaqueTy(GenericBounds, Generics),\n     /// An enum definition (`enum` or `pub enum`).\n     ///\n     /// E.g., `enum Foo<A, B> { C<A>, D<B> }`.\n@@ -2391,7 +2393,7 @@ impl ItemKind {\n             ItemKind::ForeignMod(..) => \"foreign module\",\n             ItemKind::GlobalAsm(..) => \"global asm\",\n             ItemKind::Ty(..) => \"type alias\",\n-            ItemKind::Existential(..) => \"existential type\",\n+            ItemKind::OpaqueTy(..) => \"opaque type\",\n             ItemKind::Enum(..) => \"enum\",\n             ItemKind::Struct(..) => \"struct\",\n             ItemKind::Union(..) => \"union\","}, {"sha": "33d10b269e1e3e69569b2bfe76ee12a707d2ac92", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -453,9 +453,6 @@ declare_features! (\n     // Allows `#[doc(alias = \"...\")]`.\n     (active, doc_alias, \"1.27.0\", Some(50146), None),\n \n-    // Allows defining `existential type`s.\n-    (active, existential_type, \"1.28.0\", Some(63063), None),\n-\n     // Allows inconsistent bounds in where clauses.\n     (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n \n@@ -560,6 +557,9 @@ declare_features! (\n     // Allows `[x; N]` where `x` is a constant (RFC 2203).\n     (active, const_in_array_repeat_expressions, \"1.37.0\", Some(49147), None),\n \n+    // Allows `impl Trait` to be used inside type aliases (RFC 2515).\n+    (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -625,6 +625,9 @@ declare_features! (\n     (removed, dropck_parametricity, \"1.38.0\", Some(28498), None, None),\n     (removed, await_macro, \"1.38.0\", Some(50547), None,\n      Some(\"subsumed by `.await` syntax\")),\n+    // Allows defining `existential type`s.\n+    (removed, existential_type, \"1.38.0\", Some(63063), None,\n+     Some(\"removed in favor of `#![feature(type_alias_impl_trait)]`\")),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: removed features\n@@ -2014,12 +2017,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }\n \n-            ast::ItemKind::Existential(..) => {\n+            ast::ItemKind::OpaqueTy(..) => {\n                 gate_feature_post!(\n                     &self,\n-                    existential_type,\n+                    type_alias_impl_trait,\n                     i.span,\n-                    \"existential types are unstable\"\n+                    \"`impl Trait` in type aliases is unstable\"\n                 );\n             }\n \n@@ -2243,12 +2246,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n         match ii.node {\n             ast::ImplItemKind::Method(..) => {}\n-            ast::ImplItemKind::Existential(..) => {\n+            ast::ImplItemKind::OpaqueTy(..) => {\n                 gate_feature_post!(\n                     &self,\n-                    existential_type,\n+                    type_alias_impl_trait,\n                     ii.span,\n-                    \"existential types are unstable\"\n+                    \"`impl Trait` in type aliases is unstable\"\n                 );\n             }\n             ast::ImplItemKind::Type(_) => {"}, {"sha": "176bcf1959a9d566ac11fc6ced27e6ea03edcff4", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -851,7 +851,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_ty(ty);\n             vis.visit_generics(generics);\n         }\n-        ItemKind::Existential(bounds, generics) => {\n+        ItemKind::OpaqueTy(bounds, generics) => {\n             visit_bounds(bounds, vis);\n             vis.visit_generics(generics);\n         }\n@@ -934,7 +934,7 @@ pub fn noop_flat_map_impl_item<T: MutVisitor>(mut item: ImplItem, visitor: &mut\n             visitor.visit_block(body);\n         }\n         ImplItemKind::Type(ty) => visitor.visit_ty(ty),\n-        ImplItemKind::Existential(bounds) => visit_bounds(bounds, visitor),\n+        ImplItemKind::OpaqueTy(bounds) => visit_bounds(bounds, visitor),\n         ImplItemKind::Macro(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);"}, {"sha": "eca1e218fcabc1f5b20b3005881d11b4c2df6d1c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -62,12 +62,12 @@ use std::path::{self, Path, PathBuf};\n use std::slice;\n \n #[derive(Debug)]\n-/// Whether the type alias or associated type is a concrete type or an existential type\n+/// Whether the type alias or associated type is a concrete type or an opaque type\n pub enum AliasKind {\n     /// Just a new name for the same type\n     Weak(P<Ty>),\n     /// Only trait impls of the type will be usable, not the actual type itself\n-    Existential(GenericBounds),\n+    OpaqueTy(GenericBounds),\n }\n \n bitflags::bitflags! {\n@@ -4273,11 +4273,6 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }\n \n-    fn is_existential_type_decl(&self) -> bool {\n-        self.token.is_keyword(kw::Existential) &&\n-        self.is_keyword_ahead(1, &[kw::Type])\n-    }\n-\n     fn is_auto_trait_item(&self) -> bool {\n         // auto trait\n         (self.token.is_keyword(kw::Auto) &&\n@@ -4375,7 +4370,6 @@ impl<'a> Parser<'a> {\n                   !self.token.is_qpath_start() &&\n                   !self.is_union_item() &&\n                   !self.is_crate_vis() &&\n-                  !self.is_existential_type_decl() &&\n                   !self.is_auto_trait_item() &&\n                   !self.is_async_fn() {\n             let path = self.parse_path(PathStyle::Expr)?;\n@@ -5694,7 +5688,7 @@ impl<'a> Parser<'a> {\n             let (name, alias, generics) = type_?;\n             let kind = match alias {\n                 AliasKind::Weak(typ) => ast::ImplItemKind::Type(typ),\n-                AliasKind::Existential(bounds) => ast::ImplItemKind::Existential(bounds),\n+                AliasKind::OpaqueTy(bounds) => ast::ImplItemKind::OpaqueTy(bounds),\n             };\n             (name, kind, generics)\n         } else if self.is_const_item() {\n@@ -6813,40 +6807,29 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n     }\n \n-    /// Parses `type Foo = Bar;`\n-    /// or\n-    /// `existential type Foo: Bar;`\n-    /// or\n-    /// `return `None``\n+    /// Parses `type Foo = Bar;` or returns `None`\n     /// without modifying the parser state.\n     fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, ast::Generics)>> {\n         // This parses the grammar:\n         //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n-        if self.check_keyword(kw::Type) ||\n-           self.check_keyword(kw::Existential) &&\n-                self.is_keyword_ahead(1, &[kw::Type]) {\n-            let existential = self.eat_keyword(kw::Existential);\n-            assert!(self.eat_keyword(kw::Type));\n-            Some(self.parse_existential_or_alias(existential))\n+        if self.eat_keyword(kw::Type) {\n+            Some(self.parse_type_alias())\n         } else {\n             None\n         }\n     }\n \n-    /// Parses a type alias or existential type.\n-    fn parse_existential_or_alias(\n-        &mut self,\n-        existential: bool,\n-    ) -> PResult<'a, (Ident, AliasKind, ast::Generics)> {\n+    /// Parses a type alias or opaque type.\n+    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, AliasKind, ast::Generics)> {\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n         tps.where_clause = self.parse_where_clause()?;\n-        let alias = if existential {\n-            self.expect(&token::Colon)?;\n+        self.expect(&token::Eq)?;\n+        let alias = if self.check_keyword(kw::Impl) {\n+            self.bump();\n             let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-            AliasKind::Existential(bounds)\n+            AliasKind::OpaqueTy(bounds)\n         } else {\n-            self.expect(&token::Eq)?;\n             let ty = self.parse_ty()?;\n             AliasKind::Weak(ty)\n         };\n@@ -7268,7 +7251,7 @@ impl<'a> Parser<'a> {\n             // TYPE ITEM\n             let item_ = match alias {\n                 AliasKind::Weak(ty) => ItemKind::Ty(ty, generics),\n-                AliasKind::Existential(bounds) => ItemKind::Existential(bounds, generics),\n+                AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n             };\n             let prev_span = self.prev_span;\n             let item = self.mk_item(lo.to(prev_span),"}, {"sha": "e61e1113dca614130ef90c3a08517697ca988b4a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1221,9 +1221,10 @@ impl<'a> State<'a> {\n                 self.s.word(\";\");\n                 self.end(); // end the outer ibox\n             }\n-            ast::ItemKind::Existential(ref bounds, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"existential type\"));\n+            ast::ItemKind::OpaqueTy(ref bounds, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"type\"));\n                 self.print_ident(item.ident);\n+                self.word_space(\"= impl\");\n                 self.print_generic_params(&generics.params);\n                 self.end(); // end the inner ibox\n \n@@ -1581,9 +1582,12 @@ impl<'a> State<'a> {\n             ast::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.ident, None, Some(ty));\n             }\n-            ast::ImplItemKind::Existential(ref bounds) => {\n-                self.word_space(\"existential\");\n-                self.print_associated_type(ii.ident, Some(bounds), None);\n+            ast::ImplItemKind::OpaqueTy(ref bounds) => {\n+                self.word_space(\"type\");\n+                self.print_ident(ii.ident);\n+                self.word_space(\"= impl\");\n+                self.print_type_bounds(\":\", bounds);\n+                self.s.word(\";\");\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);"}, {"sha": "67226c2177fd6754f4e4ec5e2a2bdb512c671602", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -259,7 +259,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_generics(generics)\n         }\n-        ItemKind::Existential(ref bounds, ref generics) => {\n+        ItemKind::OpaqueTy(ref bounds, ref generics) => {\n             walk_list!(visitor, visit_param_bound, bounds);\n             visitor.visit_generics(generics)\n         }\n@@ -619,7 +619,7 @@ pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplIt\n         ImplItemKind::Type(ref ty) => {\n             visitor.visit_ty(ty);\n         }\n-        ImplItemKind::Existential(ref bounds) => {\n+        ImplItemKind::OpaqueTy(ref bounds) => {\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n         ImplItemKind::Macro(ref mac) => {"}, {"sha": "f91a22915445c15c4dae51ba8beca8a4df0ea06a", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -744,9 +744,9 @@ pub enum DesugaringKind {\n     QuestionMark,\n     TryBlock,\n     /// Desugaring of an `impl Trait` in return type position\n-    /// to an `existential type Foo: Trait;` and replacing the\n+    /// to an `type Foo = impl Trait;` and replacing the\n     /// `impl Trait` with `Foo`.\n-    ExistentialType,\n+    OpaqueTy,\n     Async,\n     Await,\n     ForLoop,\n@@ -761,7 +761,7 @@ impl DesugaringKind {\n             DesugaringKind::Await => \"`await` expression\",\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n-            DesugaringKind::ExistentialType => \"`existential type`\",\n+            DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop => \"`for` loop\",\n         }\n     }"}, {"sha": "12c4ba059feb6393d2a6830cd365f36b7cf2e81f", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -98,7 +98,6 @@ symbols! {\n         Auto:               \"auto\",\n         Catch:              \"catch\",\n         Default:            \"default\",\n-        Existential:        \"existential\",\n         Union:              \"union\",\n     }\n \n@@ -680,6 +679,7 @@ symbols! {\n         tuple_indexing,\n         Ty,\n         ty,\n+        type_alias_impl_trait,\n         TyCtxt,\n         TyKind,\n         type_alias_enum_variants,"}, {"sha": "97f73b4e1f224085509d45515b8c03559592af43", "filename": "src/test/rustdoc-ui/coverage/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -29,9 +29,10 @@ impl ThisTrait for SomeStruct {\n /// but what about those aliases? i hear they're pretty exotic\n pub trait MyAlias = ThisTrait + Send + Sync;\n \n-// FIXME(58624): once rustdoc can process existential types, we need to make sure they're counted\n-// /// woah, getting all existential in here\n-// pub existential type ThisExists: ThisTrait;\n+// FIXME(58624): once rustdoc can process opaque `impl Trait` types,\n+// we need to make sure they're counted\n+// /// woah, getting all opaque in here\n+// pub type ThisExists = impl ThisTrait;\n //\n // /// why don't we get a little more concrete\n // pub fn defines() -> ThisExists { SomeStruct {} }"}, {"sha": "9db5233e21e57f6a0f7b102b157f05eedb7af457", "filename": "src/test/ui/associated-type-bounds/bounds-on-assoc-in-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -28,7 +28,7 @@ impl Case1 for S1 {\n     type B = Range<u16>;\n }\n \n-// Ensure we don't have existential desugaring:\n+// Ensure we don't have opaque `impl Trait` desugaring:\n \n pub trait Foo { type Out: Baz<Assoc: Default>; }\n pub trait Baz { type Assoc; }"}, {"sha": "1f2d755ed71abc4d08a362c25a4591d53b821321", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -3,7 +3,7 @@\n // error-pattern:could not find defining uses\n \n #![feature(associated_type_bounds)]\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n #![feature(impl_trait_in_bindings)]\n #![feature(untagged_unions)]\n \n@@ -107,17 +107,17 @@ type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n-existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n-existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n-existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n-existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n-existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n-existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n //~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}"}, {"sha": "7f3a65ab696d617f8adf96c5bc8833375411b502", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -369,86 +369,86 @@ LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n error: could not find defining uses\n   --> $DIR/duplicate.rs:110:1\n    |\n-LL | existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:110:48\n+  --> $DIR/duplicate.rs:110:36\n    |\n-LL | existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n-   |                                    ----------  ^^^^^^^^^^ re-bound here\n-   |                                    |\n-   |                                    `Item` bound here first\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n \n error: could not find defining uses\n   --> $DIR/duplicate.rs:112:1\n    |\n-LL | existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:112:48\n+  --> $DIR/duplicate.rs:112:36\n    |\n-LL | existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n-   |                                    ----------  ^^^^^^^^^^ re-bound here\n-   |                                    |\n-   |                                    `Item` bound here first\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n \n error: could not find defining uses\n   --> $DIR/duplicate.rs:114:1\n    |\n-LL | existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:114:51\n+  --> $DIR/duplicate.rs:114:39\n    |\n-LL | existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n-   |                                    -------------  ^^^^^^^^^^^^^ re-bound here\n-   |                                    |\n-   |                                    `Item` bound here first\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   |                        -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n \n error: could not find defining uses\n   --> $DIR/duplicate.rs:116:1\n    |\n-LL | existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:116:46\n+  --> $DIR/duplicate.rs:116:40\n    |\n-LL | existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n-   |                                  ----------  ^^^^^^^^^^ re-bound here\n-   |                                  |\n-   |                                  `Item` bound here first\n+LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n \n error: could not find defining uses\n   --> $DIR/duplicate.rs:118:1\n    |\n-LL | existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:118:46\n+  --> $DIR/duplicate.rs:118:40\n    |\n-LL | existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n-   |                                  ----------  ^^^^^^^^^^ re-bound here\n-   |                                  |\n-   |                                  `Item` bound here first\n+LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n \n error: could not find defining uses\n   --> $DIR/duplicate.rs:120:1\n    |\n-LL | existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:120:49\n+  --> $DIR/duplicate.rs:120:43\n    |\n-LL | existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n-   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n-   |                                  |\n-   |                                  `Item` bound here first\n+LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:123:36"}, {"sha": "fd9e52a6ff2f9eac8591419161b375c9427bd61f", "filename": "src/test/ui/associated-type-bounds/dyn-impl-trait-type.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-impl-trait-type.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n \n #![feature(associated_type_bounds)]\n-#![feature(existential_type)]\n \n use std::ops::Add;\n ", "previous_filename": "src/test/ui/associated-type-bounds/dyn-existential-type.rs"}, {"sha": "9ee33e4149aafa3ef13f6baf4e1203cd60dd272e", "filename": "src/test/ui/associated-type-bounds/trait-alias-impl-trait.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-alias-impl-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n \n #![feature(associated_type_bounds)]\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::ops::Add;\n \n@@ -17,15 +17,15 @@ struct S1;\n struct S2;\n impl Tr1 for S1 { type As1 = S2; fn mk(self) -> Self::As1 { S2 } }\n \n-existential type Et1: Tr1<As1: Copy>;\n+type Et1 = impl Tr1<As1: Copy>;\n fn def_et1() -> Et1 { S1 }\n pub fn use_et1() { assert_copy(def_et1().mk()); }\n \n-existential type Et2: Tr1<As1: 'static>;\n+type Et2 = impl Tr1<As1: 'static>;\n fn def_et2() -> Et2 { S1 }\n pub fn use_et2() { assert_static(def_et2().mk()); }\n \n-existential type Et3: Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>;\n+type Et3 = impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>;\n fn def_et3() -> Et3 {\n     struct A;\n     impl Tr1 for A {\n@@ -44,7 +44,7 @@ pub fn use_et3() {\n     assert_eq!(s, (0..10).map(|x| x + 1).sum());\n }\n \n-existential type Et4: Tr1<As1: for<'a> Tr2<'a>>;\n+type Et4 = impl Tr1<As1: for<'a> Tr2<'a>>;\n fn def_et4() -> Et4 {\n     #[derive(Copy, Clone)]\n     struct A;", "previous_filename": "src/test/ui/associated-type-bounds/existential-type.rs"}, {"sha": "8a15eb8c573b1fd02d0ced5d5b659ee398054946", "filename": "src/test/ui/async-await/async-await.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fasync-await%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fasync-await%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -99,12 +99,10 @@ fn async_fn_with_impl_future_named_lifetime<'a>(x: &'a u8) -> impl Future<Output\n     }\n }\n \n-/* FIXME(cramertj) support when `existential type T<'a, 'b>:;` works\n async fn async_fn_multiple_args(x: &u8, _y: &u8) -> u8 {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     *x\n }\n-*/\n \n async fn async_fn_multiple_args_named_lifetime<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n     wake_and_yield_once().await;"}, {"sha": "99213e64d16dfd9038f27793fd9edff38b70c025", "filename": "src/test/ui/async-await/issues/issue-60655-latebound-regions.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60655-latebound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60655-latebound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60655-latebound-regions.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,13 +1,14 @@\n-// Test that existential types are allowed to contain late-bound regions.\n+// Test that opaque `impl Trait` types are allowed to contain late-bound regions.\n \n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await, existential_type)]\n+#![feature(async_await)]\n+#![feature(type_alias_impl_trait)]\n \n use std::future::Future;\n \n-pub existential type Func: Sized;\n+pub type Func = impl Sized;\n \n // Late bound region should be allowed to escape the function, since it's bound\n // in the type.\n@@ -17,7 +18,7 @@ fn null_function_ptr() -> Func {\n \n async fn async_nop(_: &u8) {}\n \n-pub existential type ServeFut: Future<Output=()>;\n+pub type ServeFut = impl Future<Output=()>;\n \n // Late bound regions occur in the generator witness type here.\n fn serve() -> ServeFut {"}, {"sha": "b2bbc1f1549985e135fe1a6713fba5806edd97a7", "filename": "src/test/ui/existential-type/issue-52843-closure-constrain.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,12 +0,0 @@\n-// Checks to ensure that we properly detect when a closure constrains an existential type\n-#![feature(existential_type)]\n-\n-use std::fmt::Debug;\n-\n-fn main() {\n-    existential type Existential: Debug;\n-    fn _unused() -> Existential { String::new() }\n-    //~^ ERROR: concrete type differs from previous defining existential type use\n-    let null = || -> Existential { 0 };\n-    println!(\"{:?}\", null());\n-}"}, {"sha": "424d65a193c92de7c77729ce454df3ab4ca3c5c9", "filename": "src/test/ui/existential-type/issue-52843-closure-constrain.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,20 +0,0 @@\n-error: concrete type differs from previous defining existential type use\n-  --> $DIR/issue-52843-closure-constrain.rs:8:5\n-   |\n-LL |     fn _unused() -> Existential { String::new() }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, got `std::string::String`\n-   |\n-note: previous use here\n-  --> $DIR/issue-52843-closure-constrain.rs:6:1\n-   |\n-LL | / fn main() {\n-LL | |     existential type Existential: Debug;\n-LL | |     fn _unused() -> Existential { String::new() }\n-LL | |\n-LL | |     let null = || -> Existential { 0 };\n-LL | |     println!(\"{:?}\", null());\n-LL | | }\n-   | |_^\n-\n-error: aborting due to previous error\n-"}, {"sha": "96ab476061d2afb0c6137a7a23a00ab277ad2f9d", "filename": "src/test/ui/existential_types/auxiliary/cross_crate_ice.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,11 +0,0 @@\n-// Crate that exports an existential type. Used for testing cross-crate.\n-\n-#![crate_type=\"rlib\"]\n-\n-#![feature(existential_type)]\n-\n-pub existential type Foo: std::fmt::Debug;\n-\n-pub fn foo() -> Foo {\n-    5\n-}"}, {"sha": "ff253391f2aaafc906851cf9d7e028cc6a752c9a", "filename": "src/test/ui/existential_types/declared_but_never_defined.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fdeclared_but_never_defined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fdeclared_but_never_defined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fdeclared_but_never_defined.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,6 +0,0 @@\n-#![feature(existential_type)]\n-\n-fn main() {}\n-\n-// declared but never defined\n-existential type Bar: std::fmt::Debug; //~ ERROR could not find defining uses"}, {"sha": "a6311ee964df3082fa8d2af1bee34cebc399fb42", "filename": "src/test/ui/existential_types/declared_but_not_defined_in_scope.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fdeclared_but_not_defined_in_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fdeclared_but_not_defined_in_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fdeclared_but_not_defined_in_scope.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,12 +0,0 @@\n-#![feature(existential_type)]\n-\n-fn main() {}\n-\n-mod boo {\n-    // declared in module but not defined inside of it\n-    pub existential type Boo: ::std::fmt::Debug; //~ ERROR could not find defining uses\n-}\n-\n-fn bomp() -> boo::Boo {\n-    \"\"\n-}"}, {"sha": "98a269d5271a222691209e55992755f9e9990967", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,8 +0,0 @@\n-error: could not find defining uses\n-  --> $DIR/existential-types-with-cycle-error.rs:3:1\n-   |\n-LL | existential type Foo: Fn() -> Foo;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "830305d863119bc8d1e085e8b0fa9b1900c0c328", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,8 +0,0 @@\n-error: could not find defining uses\n-  --> $DIR/existential-types-with-cycle-error2.rs:7:1\n-   |\n-LL | existential type Foo: Bar<Foo, Item = Foo>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "e9943beddbf3700bb5c7b49569274c001b98aa28", "filename": "src/test/ui/existential_types/generic_duplicate_lifetime_param.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,9 +0,0 @@\n-#![feature(existential_type)]\n-\n-fn main() {}\n-\n-existential type Two<'a, 'b>: std::fmt::Debug;\n-\n-fn one<'a>(t: &'a ()) -> Two<'a, 'a> { //~ ERROR non-defining existential type use\n-    t\n-}"}, {"sha": "9d628d069d36cf8c95b47bb3a0042f974229026e", "filename": "src/test/ui/existential_types/unused_generic_param.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,14 +0,0 @@\n-error: at least one trait must be specified\n-  --> $DIR/unused_generic_param.rs:6:39\n-   |\n-LL | existential type PartiallyDefined<T>: 'static;\n-   |                                       ^^^^^^^\n-\n-error: at least one trait must be specified\n-  --> $DIR/unused_generic_param.rs:13:40\n-   |\n-LL | existential type PartiallyDefined2<T>: 'static;\n-   |                                        ^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "6dfd2d10870e076dfc7d077488a429f2a1ecf76c", "filename": "src/test/ui/feature-gates/feature-gate-existential-type.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,17 +0,0 @@\n-// Check that existential types must be ungated to use the `existential` keyword\n-\n-existential type Foo: std::fmt::Debug; //~ ERROR existential types are unstable\n-\n-trait Bar {\n-    type Baa: std::fmt::Debug;\n-    fn define() -> Self::Baa;\n-}\n-\n-impl Bar for () {\n-    existential type Baa: std::fmt::Debug; //~ ERROR existential types are unstable\n-    fn define() -> Self::Baa { 0 }\n-}\n-\n-fn define() -> Foo { 0 }\n-\n-fn main() {}"}, {"sha": "30e25e55aff12ecb07ac19d16a2f9122146a1bcd", "filename": "src/test/ui/feature-gates/feature-gate-existential-type.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1,21 +0,0 @@\n-error[E0658]: existential types are unstable\n-  --> $DIR/feature-gate-existential-type.rs:3:1\n-   |\n-LL | existential type Foo: std::fmt::Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n-   = help: add `#![feature(existential_type)]` to the crate attributes to enable\n-\n-error[E0658]: existential types are unstable\n-  --> $DIR/feature-gate-existential-type.rs:11:5\n-   |\n-LL |     existential type Baa: std::fmt::Debug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n-   = help: add `#![feature(existential_type)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "4a0c8c52c4ed7656fc086cd290a679e5c3f0d49e", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,15 @@\n+type Foo = impl std::fmt::Debug; //~ ERROR `impl Trait` in type aliases is unstable\n+\n+trait Bar {\n+    type Baa: std::fmt::Debug;\n+    fn define() -> Self::Baa;\n+}\n+\n+impl Bar for () {\n+    type Baa = impl std::fmt::Debug; //~ ERROR `impl Trait` in type aliases is unstable\n+    fn define() -> Self::Baa { 0 }\n+}\n+\n+fn define() -> Foo { 0 }\n+\n+fn main() {}"}, {"sha": "2d0710ea37cf64e54e7e1da7ee3e36daa8747533", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `impl Trait` in type aliases is unstable\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:1:1\n+   |\n+LL | type Foo = impl std::fmt::Debug;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n+   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n+\n+error[E0658]: `impl Trait` in type aliases is unstable\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:9:5\n+   |\n+LL |     type Baa = impl std::fmt::Debug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n+   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "6c7c46b0e3dbbedb83184ced46bf061757a82363", "filename": "src/test/ui/impl-trait/associated-impl-trait-type-generic-trait.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type-generic-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type-generic-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type-generic-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n // build-pass (FIXME(62277): could be check-pass?)\n \n trait Bar {}\n@@ -11,7 +11,7 @@ trait Foo<T> {\n }\n \n impl<W> Foo<W> for i32 {\n-    existential type Assoc: Bar;\n+    type Assoc = impl Bar;\n     fn foo(w: W) -> Self::Assoc {\n         Dummy(w)\n     }\n@@ -21,7 +21,7 @@ struct NonGeneric;\n impl Bar for NonGeneric {}\n \n impl<W> Foo<W> for u32 {\n-    existential type Assoc: Bar;\n+    type Assoc = impl Bar;\n     fn foo(_: W) -> Self::Assoc {\n         NonGeneric\n     }", "previous_filename": "src/test/ui/impl-trait/associated-existential-type-generic-trait.rs"}, {"sha": "cdda341cad87ab1bcfb827eb4c7408b0da86da81", "filename": "src/test/ui/impl-trait/associated-impl-trait-type-trivial.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type-trivial.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n // build-pass (FIXME(62277): could be check-pass?)\n \n trait Bar {}\n@@ -11,7 +11,7 @@ trait Foo {\n }\n \n impl Foo for i32 {\n-    existential type Assoc: Bar;\n+    type Assoc = impl Bar;\n     fn foo() -> Self::Assoc {\n         Dummy\n     }", "previous_filename": "src/test/ui/impl-trait/associated-existential-type-trivial.rs"}, {"sha": "d0661d66f4b48dd25508aba00c6dffe98e0af2bd", "filename": "src/test/ui/impl-trait/associated-impl-trait-type.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-impl-trait-type.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n // build-pass (FIXME(62277): could be check-pass?)\n \n trait Bar {}\n@@ -12,7 +12,7 @@ trait Foo {\n }\n \n impl Foo for i32 {\n-    existential type Assoc: Bar;\n+    type Assoc = impl Bar;\n     fn foo() -> Self::Assoc {\n         Dummy\n     }", "previous_filename": "src/test/ui/impl-trait/associated-existential-type.rs"}, {"sha": "c33261bfd09091b2aa7d949a3fa25ddccb3081b8", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -2,7 +2,6 @@\n // edition:2018\n \n #![feature(async_await)]\n-#![feature(existential_type)]\n #![feature(impl_trait_in_bindings)]\n //~^ WARNING the feature `impl_trait_in_bindings` is incomplete\n "}, {"sha": "aa306a7e08a4c768553a17d3f6cd7d4e6a045cf0", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,13 +1,13 @@\n warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n-  --> $DIR/bound-normalization-fail.rs:6:12\n+  --> $DIR/bound-normalization-fail.rs:5:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:30:32\n+  --> $DIR/bound-normalization-fail.rs:29:32\n    |\n LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found associated type\n@@ -17,7 +17,7 @@ LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    = note: the return type of a function must have a statically known size\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:47:41\n+  --> $DIR/bound-normalization-fail.rs:46:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output=T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found associated type"}, {"sha": "5b634e3106e3b85ff2eb0e77ceaaa7f795ac5831", "filename": "src/test/ui/impl-trait/bound-normalization-pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -2,7 +2,7 @@\n // edition:2018\n \n #![feature(async_await)]\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n #![feature(impl_trait_in_bindings)]\n //~^ WARNING the feature `impl_trait_in_bindings` is incomplete\n \n@@ -81,9 +81,9 @@ mod impl_trait_in_bindings {\n }\n \n /////////////////////////////////////////////\n-// The same applied to `existential type`s\n+// The same applied to `type Foo = impl Bar`s\n \n-mod existential_types {\n+mod opaque_types {\n     trait Implemented {\n         type Assoc;\n     }\n@@ -99,7 +99,7 @@ mod existential_types {\n         type Out = u8;\n     }\n \n-    existential type Ex: Trait<Out = <() as Implemented>::Assoc>;\n+    type Ex = impl Trait<Out = <() as Implemented>::Assoc>;\n \n     fn define() -> Ex {\n         ()"}, {"sha": "f99096b4d5829464d224a95c7c11bb90ad32aea6", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,5 +1,5 @@\n // ignore-tidy-linelength\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n pub trait Bar\n {\n@@ -9,12 +9,12 @@ pub trait Bar\n }\n \n impl<S: Default> Bar for S {\n-    existential type E: Copy;\n+    type E = impl Copy;\n     //~^ ERROR the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)` [E0277]\n     //~^^ ERROR the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)` [E0277]\n \n     fn foo<T: Default>() -> Self::E {\n-    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         (S::default(), T::default())\n     }\n }"}, {"sha": "d5756c015596e5aa0f07283c1ed8adb580f5399c", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)`\n   --> $DIR/issue-55872-1.rs:12:5\n    |\n-LL |     existential type E: Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n+LL |     type E = impl Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n    |\n    = help: consider adding a `where S: std::marker::Copy` bound\n    = note: required because it appears within the type `(S, T)`\n@@ -11,14 +11,14 @@ LL |     existential type E: Copy;\n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)`\n   --> $DIR/issue-55872-1.rs:12:5\n    |\n-LL |     existential type E: Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n+LL |     type E = impl Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n    |\n    = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size\n \n-error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-55872-1.rs:16:37\n    |\n LL |       fn foo<T: Default>() -> Self::E {"}, {"sha": "dfee20ca649deb6f5745ffc50f2cbfb30a3230c1", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n // ignore-tidy-linelength\n-#![feature(async_await, existential_type)]\n+#![feature(async_await, type_alias_impl_trait)]\n \n pub trait Bar {\n     type E: Copy;\n@@ -9,10 +9,10 @@ pub trait Bar {\n }\n \n impl<S> Bar for S {\n-    existential type E: Copy;\n+    type E = impl Copy;\n     //~^ ERROR the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied [E0277]\n     fn foo<T>() -> Self::E {\n-    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         async {}\n     }\n }"}, {"sha": "676c3fe3d4c92c6f16619d7a5a12950cac0ce2af", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,12 +1,12 @@\n error[E0277]: the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied\n   --> $DIR/issue-55872-2.rs:12:5\n    |\n-LL |     existential type E: Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `impl std::future::Future`\n+LL |     type E = impl Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `impl std::future::Future`\n    |\n    = note: the return type of a function must have a statically known size\n \n-error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-55872-2.rs:14:28\n    |\n LL |       fn foo<T>() -> Self::E {"}, {"sha": "bc91aae70c7086e5ccf59811cb25d73aeb4e5572", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,5 +1,5 @@\n // ignore-tidy-linelength\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n pub trait Bar {\n     type E: Copy;\n@@ -8,10 +8,10 @@ pub trait Bar {\n }\n \n impl<S> Bar for S {\n-    existential type E: Copy;\n+    type E = impl Copy;\n \n     fn foo<T>() -> Self::E {\n-    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         || ()\n     }\n }"}, {"sha": "60654ec34610fc24321c244905b55dc66950a454", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-55872.rs:13:28\n    |\n LL |       fn foo<T>() -> Self::E {"}, {"sha": "de8c579743fc0e74b5666dcfae31593f0fd0a899", "filename": "src/test/ui/impl-trait/issues/issue-53457.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-53457.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-53457.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-53457.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n // run-pass\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n-existential type X: Clone;\n+type X = impl Clone;\n \n fn bar<F: Fn(&i32) + Clone>(f: F) -> F {\n     f"}, {"sha": "b226cf058aa7533992e1e0e7a4590189112db07b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,14 +1,14 @@\n // compile-flags:-Zborrowck=mir\n \n #![feature(member_constraints)]\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n #[derive(Clone)]\n struct CopyIfEq<T, U>(T, U);\n \n impl<T: Copy> Copy for CopyIfEq<T, T> {}\n \n-existential type E<'a, 'b>: Sized;\n+type E<'a, 'b> = impl Sized;\n \n fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n     //~^ ERROR lifetime may not live long enough"}, {"sha": "f27e6ff44a65c76d5613a7e6b0ab3691f0fd2521", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -5,7 +5,7 @@ LL | fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n    |        -- lifetime `'a` defined here                   ^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n    |\n-LL | existential type E<'a, 'b>: Sized; + 'a\n+LL | type E<'a, 'b> = impl Sized; + 'a\n    |\n \n error: aborting due to previous error"}, {"sha": "ae44b371f4ff815f87d9da40d2dd446af722370d", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-type-alias-impl-trait.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -4,15 +4,15 @@\n //[mir]compile-flags: -Z borrowck=mir\n \n #![feature(member_constraints)]\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n trait Trait<'a, 'b> { }\n impl<T> Trait<'_, '_> for T { }\n \n // Here we wind up selecting `'a` and `'b` in the hidden type because\n // those are the types that appear in the original values.\n \n-existential type Foo<'a, 'b>: Trait<'a, 'b>;\n+type Foo<'a, 'b> = impl Trait<'a, 'b>;\n \n fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> Foo<'a, 'b> {\n     // In this simple case, you have a hidden type `(&'0 u8, &'1 u8)` and constraints like", "previous_filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-existential.rs"}, {"sha": "6d3c0692970dc614151b6f71c372889420b6d024", "filename": "src/test/ui/impl-trait/return-position-impl-trait-minimal.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Freturn-position-impl-trait-minimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Freturn-position-impl-trait-minimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Freturn-position-impl-trait-minimal.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "previous_filename": "src/test/ui/impl-trait/existential-minimal.rs"}, {"sha": "91be4efd56a154889cd6908b0337802312bffe5b", "filename": "src/test/ui/impl-trait/type-alias-impl-trait-in-fn-body.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-impl-trait-in-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-impl-trait-in-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-impl-trait-in-fn-body.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n // build-pass (FIXME(62277): could be check-pass?)\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {\n-    existential type Existential: Debug;\n+    type Existential = impl Debug;\n \n     fn f() -> Existential {}\n     println!(\"{:?}\", f());", "previous_filename": "src/test/ui/impl-trait/existential_type_in_fn_body.rs"}, {"sha": "9eac6b714de37a422afa9d2644ddde75250dd869", "filename": "src/test/ui/impl-trait/where-allowed.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -120,7 +120,8 @@ trait DummyTrait {\n }\n impl DummyTrait for () {\n     type Out = impl Debug;\n-    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+    //~^ ERROR `impl Trait` in type aliases is unstable\n+    //~^^ ERROR could not find defining uses\n \n     fn in_trait_impl_parameter(_: impl Debug) { }\n     // Allowed\n@@ -155,7 +156,8 @@ extern \"C\" fn in_extern_fn_return() -> impl Debug {\n }\n \n type InTypeAlias<R> = impl Debug;\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+//~^ ERROR `impl Trait` in type aliases is unstable\n+//~^^ ERROR could not find defining uses\n \n type InReturnInTypeAlias<R> = fn() -> impl Debug;\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types"}, {"sha": "1332fff84f50a837a24bd9c76fcae613257d9614", "filename": "src/test/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -16,6 +16,24 @@ LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic\n    |                                                 |       nested `impl Trait` here\n    |                                                 outer `impl Trait`\n \n+error[E0658]: `impl Trait` in type aliases is unstable\n+  --> $DIR/where-allowed.rs:122:5\n+   |\n+LL |     type Out = impl Debug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n+   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n+\n+error[E0658]: `impl Trait` in type aliases is unstable\n+  --> $DIR/where-allowed.rs:158:1\n+   |\n+LL | type InTypeAlias<R> = impl Debug;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n+   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n+\n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n   --> $DIR/where-allowed.rs:18:40\n    |\n@@ -137,109 +155,110 @@ LL |     fn in_return() -> impl Debug;\n    |                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:122:16\n-   |\n-LL |     type Out = impl Debug;\n-   |                ^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:128:34\n+  --> $DIR/where-allowed.rs:129:34\n    |\n LL |     fn in_trait_impl_return() -> impl Debug { () }\n    |                                  ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:141:33\n+  --> $DIR/where-allowed.rs:142:33\n    |\n LL |     fn in_foreign_parameters(_: impl Debug);\n    |                                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:144:31\n+  --> $DIR/where-allowed.rs:145:31\n    |\n LL |     fn in_foreign_return() -> impl Debug;\n    |                               ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:157:23\n-   |\n-LL | type InTypeAlias<R> = impl Debug;\n-   |                       ^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:160:39\n+  --> $DIR/where-allowed.rs:162:39\n    |\n LL | type InReturnInTypeAlias<R> = fn() -> impl Debug;\n    |                                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:164:16\n+  --> $DIR/where-allowed.rs:166:16\n    |\n LL | impl PartialEq<impl Debug> for () {\n    |                ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:169:24\n+  --> $DIR/where-allowed.rs:171:24\n    |\n LL | impl PartialEq<()> for impl Debug {\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:174:6\n+  --> $DIR/where-allowed.rs:176:6\n    |\n LL | impl impl Debug {\n    |      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:180:24\n+  --> $DIR/where-allowed.rs:182:24\n    |\n LL | impl InInherentImplAdt<impl Debug> {\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:186:11\n+  --> $DIR/where-allowed.rs:188:11\n    |\n LL |     where impl Debug: Debug\n    |           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:193:15\n+  --> $DIR/where-allowed.rs:195:15\n    |\n LL |     where Vec<impl Debug>: Debug\n    |               ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:200:24\n+  --> $DIR/where-allowed.rs:202:24\n    |\n LL |     where T: PartialEq<impl Debug>\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:207:17\n+  --> $DIR/where-allowed.rs:209:17\n    |\n LL |     where T: Fn(impl Debug)\n    |                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:214:22\n+  --> $DIR/where-allowed.rs:216:22\n    |\n LL |     where T: Fn() -> impl Debug\n    |                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:220:29\n+  --> $DIR/where-allowed.rs:222:29\n    |\n LL |     let _in_local_variable: impl Fn() = || {};\n    |                             ^^^^^^^^^\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:222:46\n+  --> $DIR/where-allowed.rs:224:46\n    |\n LL |     let _in_return_in_local_variable = || -> impl Fn() { || {} };\n    |                                              ^^^^^^^^^\n \n-error: aborting due to 39 previous errors\n+error: could not find defining uses\n+  --> $DIR/where-allowed.rs:158:1\n+   |\n+LL | type InTypeAlias<R> = impl Debug;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: could not find defining uses\n+  --> $DIR/where-allowed.rs:122:5\n+   |\n+LL |     type Out = impl Debug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 41 previous errors\n \n-For more information about this error, try `rustc --explain E0562`.\n+Some errors have detailed explanations: E0562, E0658.\n+For more information about an error, try `rustc --explain E0562`."}, {"sha": "9b2e1fe83c1cc2015d00d527e1e4244c71b1c83f", "filename": "src/test/ui/in-band-lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fin-band-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fin-band-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -77,19 +77,19 @@ fn impl_trait_in_band(x: &impl MyTrait<'a>) {}\n \n trait FunkyTrait<'a> { }\n impl<'a, T> FunkyTrait<'a> for T { }\n-fn existential_impl_trait_in_band_outlives(x: &'a u32) -> impl ::std::fmt::Debug + 'a {\n+fn ret_pos_impl_trait_in_band_outlives(x: &'a u32) -> impl ::std::fmt::Debug + 'a {\n     x\n }\n-fn existential_impl_trait_in_band_param(x: &'a u32) -> impl FunkyTrait<'a> {\n+fn ret_pos_impl_trait_in_band_param(x: &'a u32) -> impl FunkyTrait<'a> {\n     x\n }\n-fn existential_impl_trait_in_band_param_static(x: &'a u32) -> impl FunkyTrait<'static> + 'a {\n+fn ret_pos_impl_trait_in_band_param_static(x: &'a u32) -> impl FunkyTrait<'static> + 'a {\n     x\n }\n-fn existential_impl_trait_in_band_param_outlives(x: &'a u32) -> impl FunkyTrait<'a> + 'a {\n+fn ret_pos_impl_trait_in_band_param_outlives(x: &'a u32) -> impl FunkyTrait<'a> + 'a {\n     x\n }\n-fn existential_impl_trait_in_band_higher_ranked(x: &'a u32) -> impl for<'b> FunkyTrait<'b> + 'a {\n+fn ret_pos_impl_trait_in_band_higher_ranked(x: &'a u32) -> impl for<'b> FunkyTrait<'b> + 'a {\n     x\n }\n "}, {"sha": "745f0300bd5ad27eeceaa536670588108cc6f743", "filename": "src/test/ui/issues/issue-58856-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -9,6 +9,6 @@ impl Howness for () {\n         Empty\n     }\n }\n-//~^ ERROR expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`,\n+//~^ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`,\n \n fn main() {}"}, {"sha": "a83dd674a87f98dace7d39993f1b02e0078171ba", "filename": "src/test/ui/issues/issue-58856-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -7,11 +7,11 @@ LL |     fn how_are_you(&self -> Empty {\n    |                   |     help: `)` may belong here\n    |                   unclosed delimiter\n \n-error: expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `)`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `)`\n   --> $DIR/issue-58856-2.rs:11:1\n    |\n LL |     }\n-   |      - expected one of 11 possible tokens here\n+   |      - expected one of 10 possible tokens here\n LL | }\n    | ^ unexpected token\n "}, {"sha": "dcf935c5780c5a030cc72ea8d84f31ab66ee3892", "filename": "src/test/ui/issues/issue-60662.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-60662.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-60662.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60662.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // compile-flags: -Z unpretty=hir\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n trait Animal {\n }\n \n fn main() {\n-    pub existential type ServeFut: Animal;\n+    pub type ServeFut = impl Animal;\n }"}, {"sha": "e2a88dec97f7c4c4da385965732ab7bcf554d2ae", "filename": "src/test/ui/issues/issue-60662.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,7 +1,7 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // compile-flags: -Z unpretty=hir\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n #[prelude_import]\n use ::std::prelude::v1::*;\n #[macro_use]\n@@ -10,5 +10,5 @@ extern crate std;\n trait Animal { }\n \n fn main() {\n-              pub existential type ServeFut : Animal;\n+              pub type ServeFut = impl Animal;\n           }"}, {"sha": "e199045134e7846d611bc19cc6573abde6607941", "filename": "src/test/ui/parser/default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `existential`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+error: expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n   --> $DIR/default.rs:22:13\n    |\n LL |     default pub fn foo<T: Default>() -> T { T::default() }\n-   |             ^^^ expected one of 7 possible tokens here\n+   |             ^^^ expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe` here\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/default.rs:16:5"}, {"sha": "0063a334182f433e7d30ec4388df47e6f97f7a2b", "filename": "src/test/ui/parser/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,9 @@\n-// ignore-tidy-linelength\n-\n struct Foo;\n \n impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`, or\n+} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n \n fn main() {}"}, {"sha": "56749c107d13ebc4b49da94fb7fff7357570422a", "filename": "src/test/ui/parser/issue-20711-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n-  --> $DIR/issue-20711-2.rs:9:1\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+  --> $DIR/issue-20711-2.rs:7:1\n    |\n LL |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-   |                                                  - expected one of 10 possible tokens here\n+   |                                                  - expected one of 9 possible tokens here\n LL | }\n    | ^ unexpected token\n "}, {"sha": "dc216167b8a4f68d466de2f1d807213681b16e2c", "filename": "src/test/ui/parser/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,7 @@\n-// ignore-tidy-linelength\n-\n struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`, or\n+} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n \n fn main() {}"}, {"sha": "f7b99a91b51b103b80f56b3baaf917f143b10f12", "filename": "src/test/ui/parser/issue-20711.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n-  --> $DIR/issue-20711.rs:7:1\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+  --> $DIR/issue-20711.rs:5:1\n    |\n LL |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-   |                                                  - expected one of 10 possible tokens here\n+   |                                                  - expected one of 9 possible tokens here\n LL | }\n    | ^ unexpected token\n "}, {"sha": "624d1a3d11ebd479dcb38ac4c977b17d3b6b8d19", "filename": "src/test/ui/parser/issue-41155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `default`, `existential`, `extern`, `fn`, `type`, or `unsafe`, found `}`\n+error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found `}`\n   --> $DIR/issue-41155.rs:5:1\n    |\n LL |     pub\n-   |        - expected one of 9 possible tokens here\n+   |        - expected one of 8 possible tokens here\n LL | }\n    | ^ unexpected token\n "}, {"sha": "0caddb9855d83224a7d0eadb56ff329ede03e5c9", "filename": "src/test/ui/parser/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,8 @@\n-// ignore-tidy-linelength\n-\n struct S;\n \n impl S {\n     static fn f() {}\n+    //~^ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`,\n }\n-//~^^ ERROR expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`,\n \n fn main() {}"}, {"sha": "21cb71df65751b087400640239ee223bf564cd05", "filename": "src/test/ui/parser/removed-syntax-static-fn.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `existential`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`\n-  --> $DIR/removed-syntax-static-fn.rs:6:5\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`\n+  --> $DIR/removed-syntax-static-fn.rs:4:5\n    |\n LL | impl S {\n-   |         - expected one of 11 possible tokens here\n+   |         - expected one of 10 possible tokens here\n LL |     static fn f() {}\n    |     ^^^^^^ unexpected token\n "}, {"sha": "3c42f24d5ff738e55f7232e8f4b68b9a83deec19", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,7 +1,8 @@\n // Private types and traits are not allowed in interfaces of associated types.\n // This test also ensures that the checks are performed even inside private modules.\n \n-#![feature(associated_type_defaults, existential_type)]\n+#![feature(associated_type_defaults)]\n+#![feature(type_alias_impl_trait)]\n \n mod m {\n     struct Priv;\n@@ -31,7 +32,7 @@ mod m {\n         type Alias1 = Priv;\n         //~^ ERROR private type `m::Priv` in public interface\n \n-        existential type Exist: PrivTr;\n+        type Exist = impl PrivTr;\n         //~^ ERROR private trait `m::PrivTr` in public interface\n         fn infer_exist() -> Self::Exist { Priv }\n     }"}, {"sha": "158862f9228cccf95ad08038ada914491a0b0780", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,5 +1,5 @@\n warning: private trait `m::PrivTr` in public interface (error E0445)\n-  --> $DIR/private-in-public-assoc-ty.rs:15:5\n+  --> $DIR/private-in-public-assoc-ty.rs:16:5\n    |\n LL | /     pub trait PubTr {\n LL | |\n@@ -15,7 +15,7 @@ LL | |     }\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n warning: private type `m::Priv` in public interface (error E0446)\n-  --> $DIR/private-in-public-assoc-ty.rs:15:5\n+  --> $DIR/private-in-public-assoc-ty.rs:16:5\n    |\n LL | /     pub trait PubTr {\n LL | |\n@@ -30,7 +30,7 @@ LL | |     }\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:24:9\n+  --> $DIR/private-in-public-assoc-ty.rs:25:9\n    |\n LL |     struct Priv;\n    |     - `m::Priv` declared as private\n@@ -39,7 +39,7 @@ LL |         type Alias4 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:31:9\n+  --> $DIR/private-in-public-assoc-ty.rs:32:9\n    |\n LL |     struct Priv;\n    |     - `m::Priv` declared as private\n@@ -48,13 +48,13 @@ LL |         type Alias1 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0445]: private trait `m::PrivTr` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:34:9\n+  --> $DIR/private-in-public-assoc-ty.rs:35:9\n    |\n LL |     trait PrivTr {}\n    |     - `m::PrivTr` declared as private\n ...\n-LL |         existential type Exist: PrivTr;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n+LL |         type Exist = impl PrivTr;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error: aborting due to 3 previous errors\n "}, {"sha": "40bba720b0fa21afe69d72fe7d59202cc23b7c02", "filename": "src/test/ui/privacy/private-in-public-type-alias-impl-trait.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-type-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-type-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-type-alias-impl-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n // build-pass (FIXME(62277): could be check-pass?)\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n #![deny(private_in_public)]\n \n-pub existential type Pub: Default;\n+pub type Pub = impl Default;\n \n #[derive(Default)]\n struct Priv;\n@@ -18,7 +18,7 @@ pub trait Trait {\n }\n \n impl Trait for u8 {\n-    existential type Pub: Default;\n+    type Pub = impl Default;\n     fn method() -> Self::Pub { Priv }\n }\n ", "previous_filename": "src/test/ui/privacy/private-in-public-existential.rs"}, {"sha": "941f66c056104081da515f7994f1553eb62abd85", "filename": "src/test/ui/traits/trait-bounds-in-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-in-arc.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(unused_must_use)]\n-// Tests that a heterogeneous list of existential types can be put inside an Arc\n+// Tests that a heterogeneous list of existential `dyn` types can be put inside an Arc\n // and shared between threads as long as all types fulfill Send.\n \n // ignore-emscripten no threads support"}, {"sha": "42f07d49ffe25355e713f06e17f7dc3c600f2854", "filename": "src/test/ui/type-alias-impl-trait/associated-type-alias-impl-trait.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-alias-impl-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n // build-pass (FIXME(62277): could be check-pass?)\n \n trait Bar {}\n@@ -11,7 +11,7 @@ trait Foo {\n     fn bar() -> Self::Assoc;\n }\n \n-existential type Helper: Bar;\n+type Helper = impl Bar;\n \n impl Foo for i32 {\n     type Assoc = Helper;", "previous_filename": "src/test/ui/existential_types/existential-associated-type.rs"}, {"sha": "f61807cbdbd584c961062af273bd8aabab379aff", "filename": "src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fcross_crate_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fcross_crate_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fcross_crate_ice.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,11 @@\n+// Crate that exports an opaque `impl Trait` type. Used for testing cross-crate.\n+\n+#![crate_type=\"rlib\"]\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub type Foo = impl std::fmt::Debug;\n+\n+pub fn foo() -> Foo {\n+    5\n+}"}, {"sha": "0082345626729c2ec022679f1920bbd625e7a4ff", "filename": "src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fcross_crate_ice2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fcross_crate_ice2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fcross_crate_ice2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-// Crate that exports an existential type. Used for testing cross-crate.\n+// Crate that exports an opaque `impl Trait` type. Used for testing cross-crate.\n \n #![crate_type=\"rlib\"]\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n pub trait View {\n     type Tmp: Iterator<Item = u32>;\n@@ -13,7 +13,7 @@ pub trait View {\n pub struct X;\n \n impl View for X {\n-    existential type Tmp: Iterator<Item = u32>;\n+    type Tmp = impl Iterator<Item = u32>;\n \n     fn test(&self) -> Self::Tmp {\n         vec![1,2,3].into_iter()", "previous_filename": "src/test/ui/existential_types/auxiliary/cross_crate_ice2.rs"}, {"sha": "18c840d8ed9c7065bd849e9fafd3628debccb84b", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -2,12 +2,12 @@\n \n #![allow(warnings)]\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {\n }\n \n-existential type Foo<V>: std::fmt::Debug;\n+type Foo<V> = impl std::fmt::Debug;\n \n trait Trait<U> {}\n ", "previous_filename": "src/test/ui/existential_types/bound_reduction.rs"}, {"sha": "919446877a14254e9e265b7410015a32eaaf0e1f", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {\n }\n@@ -7,7 +7,7 @@ trait TraitWithAssoc {\n     type Assoc;\n }\n \n-existential type Foo<V>: Trait<V>;\n+type Foo<V> = impl Trait<V>;\n //~^ ERROR could not find defining uses\n \n trait Trait<U> {}", "previous_filename": "src/test/ui/existential_types/bound_reduction2.rs"}, {"sha": "886d17aca36ed04076cb40777be0a8cfeb3c5e73", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: defining existential type use does not fully define existential type\n+error: defining opaque type use does not fully define opaque type\n   --> $DIR/bound_reduction2.rs:17:1\n    |\n LL | / fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n@@ -9,8 +9,8 @@ LL | | }\n error: could not find defining uses\n   --> $DIR/bound_reduction2.rs:10:1\n    |\n-LL | existential type Foo<V>: Trait<V>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type Foo<V> = impl Trait<V>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n ", "previous_filename": "src/test/ui/existential_types/bound_reduction2.stderr"}, {"sha": "c30608176aada702875d7374cec095bffb021602", "filename": "src/test/ui/type-alias-impl-trait/cross_crate_ice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_crate_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_crate_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_crate_ice.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "previous_filename": "src/test/ui/existential_types/cross_crate_ice.rs"}, {"sha": "3a7e490260f3fbccf389518fb8b661e68d799c4d", "filename": "src/test/ui/type-alias-impl-trait/cross_crate_ice2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_crate_ice2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_crate_ice2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_crate_ice2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "previous_filename": "src/test/ui/existential_types/cross_crate_ice2.rs"}, {"sha": "c4bf56a919721140d2f3168ebd76ef65c9673ecc", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,6 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+// declared but never defined\n+type Bar = impl std::fmt::Debug; //~ ERROR could not find defining uses"}, {"sha": "ae0fee4333b5b6664857f6498947129d8a74e2e0", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n   --> $DIR/declared_but_never_defined.rs:6:1\n    |\n-LL | existential type Bar: std::fmt::Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type Bar = impl std::fmt::Debug;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/existential_types/declared_but_never_defined.stderr"}, {"sha": "09873a8c8c3da4fbf1c06cc329ea13f95ce69e45", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,12 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+mod boo {\n+    // declared in module but not defined inside of it\n+    pub type Boo = impl ::std::fmt::Debug; //~ ERROR could not find defining uses\n+}\n+\n+fn bomp() -> boo::Boo {\n+    \"\"\n+}"}, {"sha": "0642407aba3cd37b84bb44b83bfe7d48d70465b4", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n   --> $DIR/declared_but_not_defined_in_scope.rs:7:5\n    |\n-LL |     pub existential type Boo: ::std::fmt::Debug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     pub type Boo = impl ::std::fmt::Debug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/existential_types/declared_but_not_defined_in_scope.stderr"}, {"sha": "2d7780a126cce954e1227f60ab7978747052302f", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n // two definitions with different types\n-existential type Foo: std::fmt::Debug;\n+type Foo = impl std::fmt::Debug;\n \n fn foo() -> Foo {\n     \"\"", "previous_filename": "src/test/ui/existential_types/different_defining_uses.rs"}, {"sha": "87ed997ec59b14b6a77471c705cc87d3fd4646c8", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/different_defining_uses.rs:12:1\n    |\n LL | / fn bar() -> Foo {", "previous_filename": "src/test/ui/existential_types/different_defining_uses.stderr"}, {"sha": "289b97b00ada71d9abace4ab29934e5d053b90e6", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n // two definitions with different types\n-existential type Foo: std::fmt::Debug;\n+type Foo = impl std::fmt::Debug;\n \n fn foo() -> Foo {\n     \"\"", "previous_filename": "src/test/ui/existential_types/different_defining_uses_never_type.rs"}, {"sha": "5be656e8f446169c989a181a4028562ce7bf66c3", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/different_defining_uses_never_type.rs:12:1\n    |\n LL | / fn bar() -> Foo {\n@@ -14,7 +14,7 @@ LL | |     \"\"\n LL | | }\n    | |_^\n \n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/different_defining_uses_never_type.rs:16:1\n    |\n LL | / fn boo() -> Foo {", "previous_filename": "src/test/ui/existential_types/different_defining_uses_never_type.stderr"}, {"sha": "8549687ea78145ffafddbdef704065771492ac4c", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type2.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n // build-pass (FIXME(62277): could be check-pass?)\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n // two definitions with different types\n-existential type Foo: std::fmt::Debug;\n+type Foo = impl std::fmt::Debug;\n \n fn foo() -> Foo {\n     \"\"", "previous_filename": "src/test/ui/existential_types/different_defining_uses_never_type2.rs"}, {"sha": "ac87c2d446a89954cdff239771a6d6880b5a347a", "filename": "src/test/ui/type-alias-impl-trait/generic_different_defining_uses.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_different_defining_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_different_defining_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_different_defining_uses.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n-existential type MyIter<T>: Iterator<Item = T>;\n+type MyIter<T> = impl Iterator<Item = T>;\n \n fn my_iter<T>(t: T) -> MyIter<T> {\n     std::iter::once(t)", "previous_filename": "src/test/ui/existential_types/generic_different_defining_uses.rs"}, {"sha": "4bcd2e1cb12908a982674e1efbdc53fe8c0af80b", "filename": "src/test/ui/type-alias-impl-trait/generic_different_defining_uses.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_different_defining_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_different_defining_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_different_defining_uses.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_different_defining_uses.rs:11:1\n    |\n LL | / fn my_iter2<T>(t: T) -> MyIter<T> {", "previous_filename": "src/test/ui/existential_types/generic_different_defining_uses.stderr"}, {"sha": "c18a711675876c01a46bd8206957c3477eb401c1", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,9 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+type Two<'a, 'b> = impl std::fmt::Debug;\n+\n+fn one<'a>(t: &'a ()) -> Two<'a, 'a> { //~ ERROR non-defining opaque type use\n+    t\n+}"}, {"sha": "a4d9a672154fbac44b2ad93c3e181dd3ddfa5041", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: non-defining existential type use in defining scope\n+error: non-defining opaque type use in defining scope\n   --> $DIR/generic_duplicate_lifetime_param.rs:7:1\n    |\n LL | / fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n@@ -7,10 +7,10 @@ LL | | }\n    | |_^\n    |\n note: lifetime used multiple times\n-  --> $DIR/generic_duplicate_lifetime_param.rs:5:22\n+  --> $DIR/generic_duplicate_lifetime_param.rs:5:10\n    |\n-LL | existential type Two<'a, 'b>: std::fmt::Debug;\n-   |                      ^^  ^^\n+LL | type Two<'a, 'b> = impl std::fmt::Debug;\n+   |          ^^  ^^\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/existential_types/generic_duplicate_lifetime_param.stderr"}, {"sha": "165e320be5e9a1a0fd0b6b14528b20cbca7e14ec", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,14 +1,14 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n //~^ could not find defining uses\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ ERROR defining existential type use restricts existential type\n+//~^ ERROR defining opaque type use restricts opaque type\n     t\n }", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use.rs"}, {"sha": "e1794034e20dd420e6dc594af5c8922e574e2f43", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: defining existential type use restricts existential type by using the generic parameter `T` twice\n+error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n   --> $DIR/generic_duplicate_param_use.rs:11:1\n    |\n LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n@@ -10,8 +10,8 @@ LL | | }\n error: could not find defining uses\n   --> $DIR/generic_duplicate_param_use.rs:8:1\n    |\n-LL | existential type Two<T, U>: Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type Two<T, U> = impl Debug;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n ", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use.stderr"}, {"sha": "898dab1b0b9602808b58671eb45540e2e7b3be66", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use10.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use10.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n // build-pass (FIXME(62277): could be check-pass?)\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn two<T: Debug, U: Debug>(t: T, _: U) -> Two<T, U> {\n     (t, 4u32)", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use10.rs"}, {"sha": "0adce817c5c3759c7a3652195a93eb3a52122b1b", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,14 +1,14 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ defining existential type use restricts existential type\n+//~^ defining opaque type use restricts opaque type\n     t\n }\n ", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use2.rs"}, {"sha": "a9a51fa0b4badf456fb5d7ca90b6f9ce1d07e3a5", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: defining existential type use restricts existential type by using the generic parameter `T` twice\n+error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n   --> $DIR/generic_duplicate_param_use2.rs:10:1\n    |\n LL | / fn one<T: Debug>(t: T) -> Two<T, T> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use2.stderr"}, {"sha": "8d3e7f9f424979f154e41a547049322a920a6769", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,14 +1,14 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ defining existential type use restricts existential type\n+//~^ defining opaque type use restricts opaque type\n     t\n }\n ", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use3.rs"}, {"sha": "04dcdc295f9cb273aadad91c2b6c66af6d0217bc", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: defining existential type use restricts existential type by using the generic parameter `T` twice\n+error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n   --> $DIR/generic_duplicate_param_use3.rs:10:1\n    |\n LL | / fn one<T: Debug>(t: T) -> Two<T, T> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use3.stderr"}, {"sha": "65f7d7f485d495803fccae67f24d283d77f25473", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,14 +1,14 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ ERROR defining existential type use restricts existential type\n+//~^ ERROR defining opaque type use restricts opaque type\n     t\n }\n ", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use4.rs"}, {"sha": "082177b82128d59306bcc80ce969bcae330bcad1", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: defining existential type use restricts existential type by using the generic parameter `T` twice\n+error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n   --> $DIR/generic_duplicate_param_use4.rs:10:1\n    |\n LL | / fn one<T: Debug>(t: T) -> Two<T, T> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use4.stderr"}, {"sha": "ac8773104147e21444b0b731bafdc45742cd26d0", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use5.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn two<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n     (t, u)", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use5.rs"}, {"sha": "589ea749319d1faaec32f386a3070ee67c0df8dc", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use5.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_duplicate_param_use5.rs:14:1\n    |\n LL | / fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use5.stderr"}, {"sha": "59e7de413a2c6da522717ec1915de4a4ea31bac7", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use6.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn two<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n     (t, t)", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use6.rs"}, {"sha": "66649413d382b78cffde9953a84eb180dc5ee930", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use6.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_duplicate_param_use6.rs:14:1\n    |\n LL | / fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use6.stderr"}, {"sha": "712a6539f0153720b887aaa6452e784221185b0d", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use7.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use7.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n // build-pass (FIXME(62277): could be check-pass?)\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-existential type Two<A, B>: Debug;\n+type Two<A, B> = impl Debug;\n \n fn two<T: Debug + Copy, U>(t: T, u: U) -> Two<T, U> {\n     (t, t)", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use7.rs"}, {"sha": "777ded52609b8abb4c217a0b896d5a4ab5c54f0e", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use8.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn two<T: Debug, U: Debug>(t: T, _: U) -> Two<T, U> {\n     (t, 4u32)", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use8.rs"}, {"sha": "8f4cf4c60847734e4b4f7947d2196cc1f5364e21", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use8.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_duplicate_param_use8.rs:13:1\n    |\n LL | / fn three<T: Debug, U: Debug>(_: T, u: U) -> Two<T, U> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use8.stderr"}, {"sha": "491e6647f45d048085e256609b594d2d992d3a1b", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use9.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-existential type Two<A, B>: Debug;\n+type Two<A, B> = impl Debug;\n \n trait Foo {\n     type Bar: Debug;", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use9.rs"}, {"sha": "4d0b03ba5ed65f416e7dc2d98efc2e1cd7b3a827", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use9.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_duplicate_param_use9.rs:18:1\n    |\n LL | / fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {", "previous_filename": "src/test/ui/existential_types/generic_duplicate_param_use9.stderr"}, {"sha": "e109c38c98695a4302586bc478d4adacc65d12bf", "filename": "src/test/ui/type-alias-impl-trait/generic_lifetime_param.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_lifetime_param.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n // build-pass (FIXME(62277): could be check-pass?)\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n-existential type Region<'a>: std::fmt::Debug;\n+type Region<'a> = impl std::fmt::Debug;\n \n fn region<'b>(a: &'b ()) -> Region<'b> {\n     a", "previous_filename": "src/test/ui/existential_types/generic_lifetime_param.rs"}, {"sha": "60106eba1756ee9770c24c1756be32a6e7dd16e9", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,13 +1,13 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n-existential type Cmp<T>: 'static;\n+type Cmp<T> = impl 'static;\n //~^ ERROR could not find defining uses\n //~^^ ERROR: at least one trait must be specified\n \n \n // not a defining use, because it doesn't define *all* possible generics\n-fn cmp() -> Cmp<u32> { //~ ERROR defining existential type use does not fully define\n+fn cmp() -> Cmp<u32> { //~ ERROR defining opaque type use does not fully define\n     5u32\n }", "previous_filename": "src/test/ui/existential_types/generic_nondefining_use.rs"}, {"sha": "d98d349be3c84b5aadedb1a96a9ee08f9f6a84fe", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_nondefining_use.rs:5:26\n+  --> $DIR/generic_nondefining_use.rs:5:20\n    |\n-LL | existential type Cmp<T>: 'static;\n-   |                          ^^^^^^^\n+LL | type Cmp<T> = impl 'static;\n+   |                    ^^^^^^^\n \n-error: defining existential type use does not fully define existential type\n+error: defining opaque type use does not fully define opaque type\n   --> $DIR/generic_nondefining_use.rs:11:1\n    |\n LL | / fn cmp() -> Cmp<u32> {\n@@ -15,8 +15,8 @@ LL | | }\n error: could not find defining uses\n   --> $DIR/generic_nondefining_use.rs:5:1\n    |\n-LL | existential type Cmp<T>: 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type Cmp<T> = impl 'static;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/existential_types/generic_nondefining_use.stderr"}, {"sha": "ace52dc83ad79222d6365c1d43b1c4c66462c2f9", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n-existential type WrongGeneric<T: 'static>: 'static;\n+type WrongGeneric<T: 'static> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {", "previous_filename": "src/test/ui/existential_types/generic_not_used.rs"}, {"sha": "fe353f6e3d2a42a9788020b87c5b4b6f7e5eff82", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_not_used.rs:5:44\n+  --> $DIR/generic_not_used.rs:5:38\n    |\n-LL | existential type WrongGeneric<T: 'static>: 'static;\n-   |                                            ^^^^^^^\n+LL | type WrongGeneric<T: 'static> = impl 'static;\n+   |                                      ^^^^^^^\n \n-error: type parameter `V` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `V` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/generic_not_used.rs:8:73\n    |\n LL |   fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {", "previous_filename": "src/test/ui/existential_types/generic_not_used.stderr"}, {"sha": "3f25d5fbd9c463033cd891ca71099444b5bbe1fb", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:35\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:29\n    |\n-LL | existential type WrongGeneric<T>: 'static;\n-   |                                   ^^^^^^^\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                             ^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18", "previous_filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.nll.stderr"}, {"sha": "c0f939a50482fa7f657aa65406d36c7dc46de792", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,12 +1,12 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {\n     let y = 42;\n     let x = wrong_generic(&y);\n     let z: i32 = x; //~ ERROR mismatched types\n }\n \n-existential type WrongGeneric<T>: 'static;\n+type WrongGeneric<T> = impl 'static;\n //~^ ERROR the parameter type `T` may not live long enough\n //~^^ ERROR: at least one trait must be specified\n ", "previous_filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.rs"}, {"sha": "12569211df368178481f3b61d8ae0d1c5383146f", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:35\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:29\n    |\n-LL | existential type WrongGeneric<T>: 'static;\n-   |                                   ^^^^^^^\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                             ^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n@@ -16,17 +16,17 @@ LL |     let z: i32 = x;\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n    |\n-LL | existential type WrongGeneric<T>: 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type WrongGeneric<T> = impl 'static;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n    |                  - help: consider adding an explicit lifetime bound `T: 'static`...\n    |\n note: ...so that the type `T` will meet its required lifetime bounds\n   --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n    |\n-LL | existential type WrongGeneric<T>: 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type WrongGeneric<T> = impl 'static;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.stderr"}, {"sha": "589612d5ed69be9de6e919c32f74b320bfb8723e", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n trait Trait {}\n-existential type Underconstrained<T: Trait>: 'static; //~ ERROR the trait bound `T: Trait`\n+type Underconstrained<T: Trait> = impl 'static; //~ ERROR the trait bound `T: Trait`\n //~^ ERROR: at least one trait must be specified\n \n // no `Trait` bound", "previous_filename": "src/test/ui/existential_types/generic_underconstrained.rs"}, {"sha": "dd90dd1b06fe2e6c94679d240d049c29aa114345", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,14 +1,14 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_underconstrained.rs:6:46\n+  --> $DIR/generic_underconstrained.rs:6:40\n    |\n-LL | existential type Underconstrained<T: Trait>: 'static;\n-   |                                              ^^^^^^^\n+LL | type Underconstrained<T: Trait> = impl 'static;\n+   |                                        ^^^^^^^\n \n error[E0277]: the trait bound `T: Trait` is not satisfied\n   --> $DIR/generic_underconstrained.rs:6:1\n    |\n-LL | existential type Underconstrained<T: Trait>: 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `T`\n+LL | type Underconstrained<T: Trait> = impl 'static;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `T`\n    |\n    = help: consider adding a `where T: Trait` bound\n    = note: the return type of a function must have a statically known size", "previous_filename": "src/test/ui/existential_types/generic_underconstrained.stderr"}, {"sha": "87b8aaad95740d154eee7a8d487b694de2f6de24", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained2.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n-existential type Underconstrained<T: std::fmt::Debug>: 'static;\n+type Underconstrained<T: std::fmt::Debug> = impl 'static;\n //~^ ERROR `U` doesn't implement `std::fmt::Debug`\n //~^^ ERROR: at least one trait must be specified\n \n@@ -11,7 +11,7 @@ fn underconstrained<U>(_: U) -> Underconstrained<U> {\n     5u32\n }\n \n-existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n+type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n //~^ ERROR `V` doesn't implement `std::fmt::Debug`\n //~^^ ERROR: at least one trait must be specified\n ", "previous_filename": "src/test/ui/existential_types/generic_underconstrained2.rs"}, {"sha": "574432bdcf6de8e396467d665331f349893b390b", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained2.stderr", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,20 +1,20 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_underconstrained2.rs:5:56\n+  --> $DIR/generic_underconstrained2.rs:5:50\n    |\n-LL | existential type Underconstrained<T: std::fmt::Debug>: 'static;\n-   |                                                        ^^^^^^^\n+LL | type Underconstrained<T: std::fmt::Debug> = impl 'static;\n+   |                                                  ^^^^^^^\n \n error: at least one trait must be specified\n-  --> $DIR/generic_underconstrained2.rs:14:57\n+  --> $DIR/generic_underconstrained2.rs:14:51\n    |\n-LL | existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n-   |                                                         ^^^^^^^\n+LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n+   |                                                   ^^^^^^^\n \n error[E0277]: `U` doesn't implement `std::fmt::Debug`\n   --> $DIR/generic_underconstrained2.rs:5:1\n    |\n-LL | existential type Underconstrained<T: std::fmt::Debug>: 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+LL | type Underconstrained<T: std::fmt::Debug> = impl 'static;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `U`\n    = help: consider adding a `where U: std::fmt::Debug` bound\n@@ -23,8 +23,8 @@ LL | existential type Underconstrained<T: std::fmt::Debug>: 'static;\n error[E0277]: `V` doesn't implement `std::fmt::Debug`\n   --> $DIR/generic_underconstrained2.rs:14:1\n    |\n-LL | existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `V` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `V` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `V`\n    = help: consider adding a `where V: std::fmt::Debug` bound", "previous_filename": "src/test/ui/existential_types/generic_underconstrained2.stderr"}, {"sha": "a102d16078bed605d43bf140fb6de1dceff3ed55", "filename": "src/test/ui/type-alias-impl-trait/issue-52843-closure-constrain.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,13 @@\n+// Checks to ensure that we properly detect when a closure constrains an opaque type\n+\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    type Opaque = impl Debug;\n+    fn _unused() -> Opaque { String::new() }\n+    //~^ ERROR: concrete type differs from previous defining opaque type use\n+    let null = || -> Opaque { 0 };\n+    println!(\"{:?}\", null());\n+}"}, {"sha": "c994eb5986cb2c90defd8a78feaeb3948ebcb252", "filename": "src/test/ui/type-alias-impl-trait/issue-52843-closure-constrain.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,20 @@\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/issue-52843-closure-constrain.rs:9:5\n+   |\n+LL |     fn _unused() -> Opaque { String::new() }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, got `std::string::String`\n+   |\n+note: previous use here\n+  --> $DIR/issue-52843-closure-constrain.rs:7:1\n+   |\n+LL | / fn main() {\n+LL | |     type Opaque = impl Debug;\n+LL | |     fn _unused() -> Opaque { String::new() }\n+LL | |\n+LL | |     let null = || -> Opaque { 0 };\n+LL | |     println!(\"{:?}\", null());\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e7f93732430e7e4542684add6f4793fe5d59bde8", "filename": "src/test/ui/type-alias-impl-trait/issue-53678-generator-and-const-fn.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53678-generator-and-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53678-generator-and-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53678-generator-and-const-fn.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n // check-pass\n \n-#![feature(const_fn, generators, generator_trait, existential_type)]\n+#![feature(const_fn, generators, generator_trait, type_alias_impl_trait)]\n \n use std::ops::Generator;\n \n-existential type GenOnce<Y, R>: Generator<Yield = Y, Return = R>;\n+type GenOnce<Y, R> = impl Generator<Yield = Y, Return = R>;\n \n const fn const_generator<Y, R>(yielding: Y, returning: R) -> GenOnce<Y, R> {\n     move || {", "previous_filename": "src/test/ui/existential_types/issue-53678-generator-and-const-fn.rs"}, {"sha": "92ba50ae6cf1fe4901e0ebec50dee96eef04254e", "filename": "src/test/ui/type-alias-impl-trait/issue-58887.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n trait UnwrapItemsExt {\n     type Iter;\n@@ -10,7 +10,7 @@ where\n     I: Iterator<Item = Result<T, E>>,\n     E: std::fmt::Debug,\n {\n-    existential type Iter: Iterator<Item = T>;\n+    type Iter = impl Iterator<Item = T>;\n     //~^ ERROR: could not find defining uses\n \n     fn unwrap_items(self) -> Self::Iter {", "previous_filename": "src/test/ui/existential_types/issue-58887.rs"}, {"sha": "7e2895711d34550f44fba1094e38f97adcded536", "filename": "src/test/ui/type-alias-impl-trait/issue-58887.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-58887.rs:16:41\n    |\n LL |       fn unwrap_items(self) -> Self::Iter {\n@@ -9,7 +9,7 @@ LL | |         self.map(|x| x.unwrap())\n LL | |     }\n    | |_____^\n \n-error: type parameter `E` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `E` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-58887.rs:16:41\n    |\n LL |       fn unwrap_items(self) -> Self::Iter {\n@@ -23,8 +23,8 @@ LL | |     }\n error: could not find defining uses\n   --> $DIR/issue-58887.rs:13:5\n    |\n-LL |     existential type Iter: Iterator<Item = T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     type Iter = impl Iterator<Item = T>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/existential_types/issue-58887.stderr"}, {"sha": "3416c6745bb0d0fc9033ec46150247998fe8132d", "filename": "src/test/ui/type-alias-impl-trait/issue-58951.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,11 @@\n // check-pass\n-#![feature(existential_type)]\n \n-existential type A: Iterator;\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Iterator;\n+\n fn def_a() -> A { 0..1 }\n+\n pub fn use_a() {\n     def_a().map(|x| x);\n }", "previous_filename": "src/test/ui/existential_types/issue-58951.rs"}, {"sha": "50b9d1ac7933c8754775452911e27f4a957b7c8a", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -5,7 +5,7 @@ trait Bug {\n }\n \n impl Bug for &() {\n-    existential type Item: Bug; //~ ERROR existential types are unstable\n+    type Item = impl Bug; //~ ERROR `impl Trait` in type aliases is unstable\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n     //~^^ ERROR could not find defining uses\n ", "previous_filename": "src/test/ui/existential_types/issue-60371.rs"}, {"sha": "1e9b12ebc39aaeff3c121c50a196b3172833792d", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: existential types are unstable\n+error[E0658]: `impl Trait` in type aliases is unstable\n   --> $DIR/issue-60371.rs:8:5\n    |\n-LL |     existential type Item: Bug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     type Item = impl Bug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n-   = help: add `#![feature(existential_type)]` to the crate attributes to enable\n+   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0277]: the trait bound `(): Bug` is not satisfied\n   --> $DIR/issue-60371.rs:8:5\n    |\n-LL |     existential type Item: Bug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bug` is not implemented for `()`\n+LL |     type Item = impl Bug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n@@ -20,8 +20,8 @@ LL |     existential type Item: Bug;\n error: could not find defining uses\n   --> $DIR/issue-60371.rs:8:5\n    |\n-LL |     existential type Item: Bug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     type Item = impl Bug;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/existential_types/issue-60371.stderr"}, {"sha": "7d462f057cb84eefc7b8702e9af92fb8bd85f5ad", "filename": "src/test/ui/type-alias-impl-trait/issue-60407.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60407.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n // check-pass\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n-existential type Debuggable: core::fmt::Debug;\n+type Debuggable = impl core::fmt::Debug;\n \n static mut TEST: Option<Debuggable> = None;\n ", "previous_filename": "src/test/ui/existential_types/issue-60407.rs"}, {"sha": "91c4576597ea469117248c86f19bbcd5edc16cad", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n trait IterBits {\n     type BitsIter: Iterator<Item = u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter;\n }\n \n-existential type IterBitsIter<T, E, I>: std::iter::Iterator<Item = I>;\n+type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n //~^ ERROR could not find defining uses\n \n impl<T, E> IterBits for T", "previous_filename": "src/test/ui/existential_types/issue-60564.rs"}, {"sha": "ebb13fca1da9231a074d1f06322a96bd86a18fa4", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -2,7 +2,7 @@ error[E0601]: `main` function not found in crate `issue_60564`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-60564.rs`\n \n-error: type parameter `E` is part of concrete type but not used in parameter list for existential type\n+error: type parameter `E` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-60564.rs:20:49\n    |\n LL |       fn iter_bits(self, n: u8) -> Self::BitsIter {\n@@ -17,8 +17,8 @@ LL | |     }\n error: could not find defining uses\n   --> $DIR/issue-60564.rs:8:1\n    |\n-LL | existential type IterBitsIter<T, E, I>: std::iter::Iterator<Item = I>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/existential_types/issue-60564.stderr"}, {"sha": "82c9ecd2ac6bf6985de2b5af73a1bc332ff9b04f", "filename": "src/test/ui/type-alias-impl-trait/nested_type_alias_impl_trait.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested_type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested_type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested_type_alias_impl_trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n // build-pass (FIXME(62277): could be check-pass?)\n mod my_mod {\n   use std::fmt::Debug;\n \n-  pub existential type Foo: Debug;\n-  pub existential type Foot: Debug;\n+  pub type Foo = impl Debug;\n+  pub type Foot = impl Debug;\n \n   pub fn get_foo() -> Foo {\n       5i32", "previous_filename": "src/test/ui/existential_types/nested_existential_types.rs"}, {"sha": "8787c023eb0c78708e7a8554b3c4ef7eb4860889", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n // don't reveal the concrete type\n-existential type NoReveal: std::fmt::Debug;\n+type NoReveal = impl std::fmt::Debug;\n \n fn define_no_reveal() -> NoReveal {\n     \"\"", "previous_filename": "src/test/ui/existential_types/never_reveal_concrete_type.rs"}, {"sha": "7c195f1fad006172d6c159e6b4047d318e794081", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "previous_filename": "src/test/ui/existential_types/never_reveal_concrete_type.stderr"}, {"sha": "c9ca504f780979c8631c7239339cf6d6008fc3e5", "filename": "src/test/ui/type-alias-impl-trait/no_inferrable_concrete_type.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n-// Issue 52985: user code provides no use case that allows an existential type\n+// Issue 52985: user code provides no use case that allows a type alias `impl Trait`\n // We now emit a 'could not find defining uses' error\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n-existential type Foo: Copy; //~ could not find defining uses\n+type Foo = impl Copy; //~ could not find defining uses\n \n // make compiler happy about using 'Foo'\n fn bar(x: Foo) -> Foo { x }", "previous_filename": "src/test/ui/existential_types/no_inferrable_concrete_type.rs"}, {"sha": "444e6e8214ff283026b8b9864591f73493fae681", "filename": "src/test/ui/type-alias-impl-trait/no_inferrable_concrete_type.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n   --> $DIR/no_inferrable_concrete_type.rs:6:1\n    |\n-LL | existential type Foo: Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type Foo = impl Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/existential_types/no_inferrable_concrete_type.stderr"}, {"sha": "61153b1e17141ce5ffd6d123e12aa636f01b6f7e", "filename": "src/test/ui/type-alias-impl-trait/no_revealing_outside_defining_module.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,9 +1,9 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {}\n \n mod boo {\n-    pub existential type Boo: ::std::fmt::Debug;\n+    pub type Boo = impl ::std::fmt::Debug;\n     fn bomp() -> Boo {\n         \"\"\n     }", "previous_filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.rs"}, {"sha": "5e5826978fc7eb863c32495954fe2572ac8d91cd", "filename": "src/test/ui/type-alias-impl-trait/no_revealing_outside_defining_module.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "previous_filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.stderr"}, {"sha": "ca00e582d3442ffef85e0f5ce863992bd19c0f9a", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,13 +1,13 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-existential type Two<T, U>: Debug;\n+type Two<T, U> = impl Debug;\n \n fn two<T: Debug>(t: T) -> Two<T, u32> {\n-    //~^ ERROR defining existential type use does not fully define existential type\n+    //~^ ERROR defining opaque type use does not fully define opaque type\n     (t, 4i8)\n }\n ", "previous_filename": "src/test/ui/existential_types/not_a_defining_use.rs"}, {"sha": "7bb8939ccf5a282480fb8863e54125e2dbe22034", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-error: defining existential type use does not fully define existential type\n+error: defining opaque type use does not fully define opaque type\n   --> $DIR/not_a_defining_use.rs:9:1\n    |\n LL | / fn two<T: Debug>(t: T) -> Two<T, u32> {\n@@ -7,7 +7,7 @@ LL | |     (t, 4i8)\n LL | | }\n    | |_^\n \n-error: concrete type differs from previous defining existential type use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/not_a_defining_use.rs:30:1\n    |\n LL | / fn four<T: Debug, U: Bar>(t: T) -> Two<T, U> {", "previous_filename": "src/test/ui/existential_types/not_a_defining_use.stderr"}, {"sha": "36ec9b34ebdb1503acc3b17b5193f9e2ab9f97a3", "filename": "src/test/ui/type-alias-impl-trait/not_well_formed.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {\n }\n@@ -7,7 +7,7 @@ trait TraitWithAssoc {\n     type Assoc;\n }\n \n-existential type Foo<V>: Trait<V::Assoc>; //~ associated type `Assoc` not found for `V`\n+type Foo<V> = impl Trait<V::Assoc>; //~ associated type `Assoc` not found for `V`\n \n trait Trait<U> {}\n ", "previous_filename": "src/test/ui/existential_types/not_well_formed.rs"}, {"sha": "d374d6d33ee733cd47f07d57485b37267b1d8982", "filename": "src/test/ui/type-alias-impl-trait/not_well_formed.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,8 +1,8 @@\n error[E0220]: associated type `Assoc` not found for `V`\n-  --> $DIR/not_well_formed.rs:10:32\n+  --> $DIR/not_well_formed.rs:10:26\n    |\n-LL | existential type Foo<V>: Trait<V::Assoc>;\n-   |                                ^^^^^^^^ associated type `Assoc` not found\n+LL | type Foo<V> = impl Trait<V::Assoc>;\n+   |                          ^^^^^^^^ associated type `Assoc` not found\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/existential_types/not_well_formed.stderr"}, {"sha": "92268f1861d63535de87ea1563f9dfd4b41256e8", "filename": "src/test/ui/type-alias-impl-trait/private_unused.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fprivate_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fprivate_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fprivate_unused.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "previous_filename": "src/test/ui/existential_types/private_unused.rs"}, {"sha": "0fd4d26ef60b75b996fe67b68b258bec8a6bca38", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-const.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,18 +1,18 @@\n // check-pass\n \n-#![feature(existential_type)]\n-// Currently, the `existential_type` feature implicitly\n+#![feature(type_alias_impl_trait)]\n+// Currently, the `type_alias_impl_trait` feature implicitly\n // depends on `impl_trait_in_bindings` in order to work properly.\n // Specifically, this line requires `impl_trait_in_bindings` to be enabled:\n // https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src/librustc_typeck/check/mod.rs#L856\n #![feature(impl_trait_in_bindings)]\n //~^ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n \n-// Ensures that `const` items can constrain an `existential type`.\n+// Ensures that `const` items can constrain an opaque `impl Trait`.\n \n use std::fmt::Debug;\n \n-pub existential type Foo: Debug;\n+pub type Foo = impl Debug;\n \n const _FOO: Foo = 5;\n ", "previous_filename": "src/test/ui/existential_types/existential_type_const.rs"}, {"sha": "691de82c9d8382e06bbacad318a01f0c8b0ae995", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-const.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n-  --> $DIR/existential_type_const.rs:8:12\n+  --> $DIR/type-alias-impl-trait-const.rs:8:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/existential_types/existential_type_const.stderr"}, {"sha": "a22b12cae6bcbe879e83684de9abaf44bc19e3b6", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-fns.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-fns.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n // Regression test for issue #61863\n \n@@ -22,6 +22,6 @@ pub fn bla2() -> TE {\n }\n \n \n-existential type TE: MyTrait;\n+type TE = impl MyTrait;\n \n fn main() {}", "previous_filename": "src/test/ui/existential_types/existential_type_fns.rs"}, {"sha": "86c9d482143832135e0c278e0108b42e26ae3e63", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-tuple.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-tuple.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n pub trait MyTrait {}\n@@ -28,6 +28,6 @@ fn make_foo() -> Foo {\n     true\n }\n \n-existential type Foo: MyTrait;\n+type Foo = impl MyTrait;\n \n fn main() {}", "previous_filename": "src/test/ui/existential_types/existential_type_tuple.rs"}, {"sha": "c009952eab75051197e6698707e3e6d57120f40c", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-cycle-error.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,6 +1,6 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n-existential type Foo: Fn() -> Foo;\n+type Foo = impl Fn() -> Foo;\n //~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {", "previous_filename": "src/test/ui/existential_types/existential-types-with-cycle-error.rs"}, {"sha": "02ab3399ea6fa6d2010583a379ff1bb6760a428f", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-cycle-error.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,8 @@\n+error: could not find defining uses\n+  --> $DIR/type-alias-impl-trait-with-cycle-error.rs:3:1\n+   |\n+LL | type Foo = impl Fn() -> Foo;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "32ecc36661898547db97e7924871a1c756311fd7", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-cycle-error2.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,10 +1,10 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n pub trait Bar<T> {\n     type Item;\n }\n \n-existential type Foo: Bar<Foo, Item = Foo>;\n+type Foo = impl Bar<Foo, Item = Foo>;\n //~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {", "previous_filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.rs"}, {"sha": "e9abb795886833fa4f3ec7d29a4dd27e1196efc9", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-cycle-error2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,8 @@\n+error: could not find defining uses\n+  --> $DIR/type-alias-impl-trait-with-cycle-error2.rs:7:1\n+   |\n+LL | type Foo = impl Bar<Foo, Item = Foo>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "8ca279eec921b114ac74d188db0f3eb0ba62b04f", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-no-traits.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-no-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-no-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-no-traits.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,6 +1,6 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n-existential type Foo: 'static;\n+type Foo = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn foo() -> Foo {", "previous_filename": "src/test/ui/existential_types/existential-types-with-no-traits.rs"}, {"sha": "58028bd0861db0024fa60454afabfa5f7a49024e", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-no-traits.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-no-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-no-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-no-traits.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,11 +1,11 @@\n error: at least one trait must be specified\n-  --> $DIR/existential-types-with-no-traits.rs:3:23\n+  --> $DIR/type-alias-impl-trait-with-no-traits.rs:3:17\n    |\n-LL | existential type Foo: 'static;\n-   |                       ^^^^^^^\n+LL | type Foo = impl 'static;\n+   |                 ^^^^^^^\n \n error: at least one trait must be specified\n-  --> $DIR/existential-types-with-no-traits.rs:10:13\n+  --> $DIR/type-alias-impl-trait-with-no-traits.rs:10:13\n    |\n LL | fn bar() -> impl 'static {\n    |             ^^^^^^^^^^^^", "previous_filename": "src/test/ui/existential_types/existential-types-with-no-traits.stderr"}, {"sha": "209134acf01f9723d50d9421bdf0caeb0074c306", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -3,7 +3,7 @@\n #![allow(dead_code)]\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {\n     assert_eq!(foo().to_string(), \"foo\");\n@@ -16,14 +16,14 @@ fn main() {\n }\n \n // single definition\n-existential type Foo: std::fmt::Display;\n+type Foo = impl std::fmt::Display;\n \n fn foo() -> Foo {\n     \"foo\"\n }\n \n // two definitions\n-existential type Bar: std::fmt::Display;\n+type Bar = impl std::fmt::Display;\n \n fn bar1() -> Bar {\n     \"bar1\"\n@@ -34,15 +34,15 @@ fn bar2() -> Bar {\n }\n \n // definition in submodule\n-existential type Boo: std::fmt::Display;\n+type Boo = impl std::fmt::Display;\n \n mod boo {\n     pub fn boo() -> super::Boo {\n         \"boo\"\n     }\n }\n \n-existential type MyIter<T>: Iterator<Item = T>;\n+type MyIter<T> = impl Iterator<Item = T>;\n \n fn my_iter<T>(t: T) -> MyIter<T> {\n     std::iter::once(t)\n@@ -63,21 +63,21 @@ fn my_iter4<U, V>(_: U, v: V) -> MyIter<V> {\n }\n \n // param names should not have an effect!\n-existential type MyOtherIter<T>: Iterator<Item = T>;\n+type MyOtherIter<T> = impl Iterator<Item = T>;\n \n fn my_other_iter<U>(u: U) -> MyOtherIter<U> {\n     std::iter::once(u)\n }\n \n trait Trait {}\n-existential type GenericBound<'a, T: Trait>: Sized + 'a;\n+type GenericBound<'a, T: Trait> = impl Sized + 'a;\n \n fn generic_bound<'a, T: Trait + 'a>(t: T) -> GenericBound<'a, T> {\n     t\n }\n \n mod pass_through {\n-    pub existential type Passthrough<T>: Sized + 'static;\n+    pub type Passthrough<T> = impl Sized + 'static;\n \n     fn define_passthrough<T: 'static>(t: T) -> Passthrough<T> {\n         t", "previous_filename": "src/test/ui/existential_types/existential_type-pass.rs"}, {"sha": "a9ab727b193e4374c0a35e6596f682c0b47dcaf1", "filename": "src/test/ui/type-alias-impl-trait/unused_generic_param.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.rs?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -1,16 +1,16 @@\n-#![feature(existential_type)]\n+#![feature(type_alias_impl_trait)]\n \n fn main() {\n }\n \n-existential type PartiallyDefined<T>: 'static;\n+type PartiallyDefined<T> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn partially_defined<T: std::fmt::Debug>(_: T) -> PartiallyDefined<T> {\n     4u32\n }\n \n-existential type PartiallyDefined2<T>: 'static;\n+type PartiallyDefined2<T> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn partially_defined2<T: std::fmt::Debug>(_: T) -> PartiallyDefined2<T> {", "previous_filename": "src/test/ui/existential_types/unused_generic_param.rs"}, {"sha": "23105026964c1d33c5274132d3215e0f110f48ca", "filename": "src/test/ui/type-alias-impl-trait/unused_generic_param.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7270712cb446aad0817040bbca73a8d024f67b0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.stderr?ref=d7270712cb446aad0817040bbca73a8d024f67b0", "patch": "@@ -0,0 +1,14 @@\n+error: at least one trait must be specified\n+  --> $DIR/unused_generic_param.rs:6:33\n+   |\n+LL | type PartiallyDefined<T> = impl 'static;\n+   |                                 ^^^^^^^\n+\n+error: at least one trait must be specified\n+  --> $DIR/unused_generic_param.rs:13:34\n+   |\n+LL | type PartiallyDefined2<T> = impl 'static;\n+   |                                  ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}