{"sha": "909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwOWI5NGI1Y2NlYjA0NmE3YTNhYTcxMzRiZTFhM2UyNWY3NWZlYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-30T05:26:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-30T05:26:28Z"}, "message": "Auto merge of #46041 - zilbuz:issue-44837, r=arielb1\n\nMIR borrowck: finalize `check_access_permissions()`\n\nFix #44837 (hopefully for good)\n\nr? @arielb1", "tree": {"sha": "e8b5878167a7e85880ec5c2f129a7d32d86fe97a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b5878167a7e85880ec5c2f129a7d32d86fe97a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "html_url": "https://github.com/rust-lang/rust/commit/909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78fcf338833bd265c7f8dd1e46caf02b66039bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/78fcf338833bd265c7f8dd1e46caf02b66039bb8", "html_url": "https://github.com/rust-lang/rust/commit/78fcf338833bd265c7f8dd1e46caf02b66039bb8"}, {"sha": "1cd9d74a2d1998c18761369cad3d9dd53916bf9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd9d74a2d1998c18761369cad3d9dd53916bf9f", "html_url": "https://github.com/rust-lang/rust/commit/1cd9d74a2d1998c18761369cad3d9dd53916bf9f"}], "stats": {"total": 311, "additions": 232, "deletions": 79}, "files": [{"sha": "ec3954f734923c7ea481e18df7df2670c5d7ad77", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 193, "deletions": 63, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -271,6 +271,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                         self.access_lvalue(context,\n                                            (output, span),\n                                            (Deep, Read(ReadKind::Copy)),\n+                                           LocalMutationIsAllowed::No,\n                                            flow_state);\n                         self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n                                                     (output, span), flow_state);\n@@ -300,7 +301,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             StatementKind::StorageDead(local) => {\n                 self.access_lvalue(ContextKind::StorageDead.new(location),\n                     (&Lvalue::Local(local), span),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)), flow_state);\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    LocalMutationIsAllowed::Yes,\n+                    flow_state);\n             }\n         }\n     }\n@@ -322,6 +325,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 self.access_lvalue(ContextKind::Drop.new(loc),\n                                    (drop_lvalue, span),\n                                    (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                                   LocalMutationIsAllowed::Yes,\n                                    flow_state);\n             }\n             TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n@@ -391,6 +395,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                 ContextKind::StorageDead.new(loc),\n                                 (&root_lvalue, self.mir.source_info(borrow.location).span),\n                                 (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                                LocalMutationIsAllowed::Yes,\n                                 flow_state\n                             );\n                         }\n@@ -399,6 +404,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                                 ContextKind::StorageDead.new(loc),\n                                 (&root_lvalue, self.mir.source_info(borrow.location).span),\n                                 (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                                LocalMutationIsAllowed::Yes,\n                                 flow_state\n                             );\n                         }\n@@ -445,6 +451,8 @@ enum ShallowOrDeep {\n     Deep,\n }\n \n+/// Kind of access to a value: read or write\n+/// (For informational purposes only)\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ReadOrWrite {\n     /// From the RFC: \"A *read* means that the existing data may be\n@@ -457,12 +465,16 @@ enum ReadOrWrite {\n     Write(WriteKind),\n }\n \n+/// Kind of read access to a value\n+/// (For informational purposes only)\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ReadKind {\n     Borrow(BorrowKind),\n     Copy,\n }\n \n+/// Kind of write access to a value\n+/// (For informational purposes only)\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n     StorageDeadOrDrop,\n@@ -471,6 +483,20 @@ enum WriteKind {\n     Move,\n }\n \n+/// When checking permissions for an lvalue access, this flag is used to indicate that an immutable\n+/// local lvalue can be mutated.\n+///\n+/// FIXME: @nikomatsakis suggested that this flag could be removed with the following modifications:\n+/// - Merge `check_access_permissions()` and `check_if_reassignment_to_immutable_state()`\n+/// - Split `is_mutable()` into `is_assignable()` (can be directly assigned) and\n+///   `is_declared_mutable()`\n+/// - Take flow state into consideration in `is_assignable()` for local variables\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum LocalMutationIsAllowed {\n+    Yes,\n+    No\n+}\n+\n #[derive(Copy, Clone)]\n enum InitializationRequiringAction {\n     Update,\n@@ -510,6 +536,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                      context: Context,\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n+                     is_local_mutation_allowed: LocalMutationIsAllowed,\n                      flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let (sd, rw) = kind;\n \n@@ -526,9 +553,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // Check permissions\n-        self.check_access_permissions(lvalue_span, rw);\n+        let mut error_reported = self.check_access_permissions(lvalue_span,\n+                                                               rw,\n+                                                               is_local_mutation_allowed);\n \n-        let mut error_reported = false;\n         self.each_borrow_involving_path(\n             context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n@@ -614,7 +642,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.access_lvalue(context, lvalue_span, (kind, Write(WriteKind::Mutate)), flow_state);\n+        self.access_lvalue(context,\n+                           lvalue_span,\n+                           (kind, Write(WriteKind::Mutate)),\n+                           LocalMutationIsAllowed::Yes,\n+                           flow_state);\n \n         // check for reassignments to immutable local variables\n         self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n@@ -632,7 +664,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Unique |\n                     BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n                 };\n-                self.access_lvalue(context, (lvalue, span), access_kind, flow_state);\n+                self.access_lvalue(context,\n+                                   (lvalue, span),\n+                                   access_kind,\n+                                   LocalMutationIsAllowed::No,\n+                                   flow_state);\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Borrow,\n                                             (lvalue, span), flow_state);\n             }\n@@ -651,8 +687,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n                     _ => unreachable!(),\n                 };\n-                self.access_lvalue(\n-                    context, (lvalue, span), (Shallow(Some(af)), Read(ReadKind::Copy)), flow_state);\n+                self.access_lvalue(context,\n+                                   (lvalue, span),\n+                                   (Shallow(Some(af)), Read(ReadKind::Copy)),\n+                                   LocalMutationIsAllowed::No,\n+                                   flow_state);\n                 self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n                                             (lvalue, span), flow_state);\n             }\n@@ -690,6 +729,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.access_lvalue(context,\n                                    (lvalue, span),\n                                    (Deep, Read(ReadKind::Copy)),\n+                                   LocalMutationIsAllowed::No,\n                                    flow_state);\n \n                 // Finally, check if path was already moved.\n@@ -701,6 +741,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.access_lvalue(context,\n                                    (lvalue, span),\n                                    (Deep, Write(WriteKind::Move)),\n+                                   LocalMutationIsAllowed::Yes,\n                                    flow_state);\n \n                 // Finally, check if path was already moved.\n@@ -735,9 +776,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n                 Lvalue::Static(ref static_) => {\n                     // mutation of non-mut static is always illegal,\n-                    // independent of dataflow.\n+                    // independent of dataflow. However it will be catched by\n+                    // `check_access_permissions()`, we call delay_span_bug here\n+                    // to be sure that no case has been missed\n                     if !self.tcx.is_static_mut(static_.def_id) {\n-                        self.report_assignment_to_static(context, (lvalue, span));\n+                        let item_msg = match self.describe_lvalue(lvalue) {\n+                            Some(name) => format!(\"immutable static item `{}`\", name),\n+                            None => \"immutable static item\".to_owned()\n+                        };\n+                        self.tcx.sess.delay_span_bug(span,\n+                            &format!(\"cannot assign to {}, should have been caught by \\\n+                            `check_access_permissions()`\", item_msg));\n                     }\n                     return;\n                 }\n@@ -949,41 +998,101 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Check the permissions for the given lvalue and read or write kind\n-    fn check_access_permissions(&self, (lvalue, span): (&Lvalue<'tcx>, Span), kind: ReadOrWrite) {\n+    ///\n+    /// Returns true if an error is reported, false otherwise.\n+    fn check_access_permissions(&self,\n+                                (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                kind: ReadOrWrite,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed)\n+                                -> bool {\n+        debug!(\"check_access_permissions({:?}, {:?}, {:?})\",\n+               lvalue, kind, is_local_mutation_allowed);\n+        let mut error_reported = false;\n         match kind {\n             Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n                 if let Err(_lvalue_err) = self.is_unique(lvalue) {\n-                    span_bug!(span, \"&unique borrow for `{}` should not fail\",\n-                        self.describe_lvalue(lvalue));\n+                    span_bug!(span, \"&unique borrow for {:?} should not fail\", lvalue);\n                 }\n             },\n             Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => {\n-                if let Err(lvalue_err) = self.is_mutable(lvalue) {\n+                if let Err(lvalue_err) = self.is_mutable(lvalue, is_local_mutation_allowed) {\n+                    error_reported = true;\n+\n+                    let item_msg = match self.describe_lvalue(lvalue) {\n+                        Some(name) => format!(\"immutable item `{}`\", name),\n+                        None => \"immutable item\".to_owned()\n+                    };\n+\n                     let mut err = self.tcx.cannot_borrow_path_as_mutable(span,\n-                        &format!(\"immutable item `{}`\",\n-                                  self.describe_lvalue(lvalue)),\n+                        &item_msg,\n                         Origin::Mir);\n                     err.span_label(span, \"cannot borrow as mutable\");\n \n                     if lvalue != lvalue_err {\n-                        err.note(&format!(\"Value not mutable causing this error: `{}`\",\n-                            self.describe_lvalue(lvalue_err)));\n+                        if let Some(name) = self.describe_lvalue(lvalue_err) {\n+                            err.note(&format!(\"Value not mutable causing this error: `{}`\", name));\n+                        }\n+                    }\n+\n+                    err.emit();\n+                }\n+            },\n+            Write(WriteKind::Mutate) => {\n+                if let Err(lvalue_err) = self.is_mutable(lvalue, is_local_mutation_allowed) {\n+                    error_reported = true;\n+\n+                    let item_msg = match self.describe_lvalue(lvalue) {\n+                        Some(name) => format!(\"immutable item `{}`\", name),\n+                        None => \"immutable item\".to_owned()\n+                    };\n+\n+                    let mut err = self.tcx.cannot_assign(span,\n+                        &item_msg,\n+                        Origin::Mir);\n+                    err.span_label(span, \"cannot mutate\");\n+\n+                    if lvalue != lvalue_err {\n+                        if let Some(name) = self.describe_lvalue(lvalue_err) {\n+                            err.note(&format!(\"Value not mutable causing this error: `{}`\", name));\n+                        }\n                     }\n \n                     err.emit();\n                 }\n             },\n-            _ => {}// Access authorized\n+            Write(WriteKind::Move) |\n+            Write(WriteKind::StorageDeadOrDrop) |\n+            Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n+                if let Err(_lvalue_err) = self.is_mutable(lvalue, is_local_mutation_allowed) {\n+                    self.tcx.sess.delay_span_bug(span,\n+                        &format!(\"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n+                            lvalue,\n+                            kind));\n+                }\n+            },\n+            Read(ReadKind::Borrow(BorrowKind::Unique)) |\n+            Read(ReadKind::Borrow(BorrowKind::Mut)) |\n+            Read(ReadKind::Borrow(BorrowKind::Shared)) |\n+            Read(ReadKind::Copy) => {} // Access authorized\n         }\n+\n+        error_reported\n     }\n \n     /// Can this value be written or borrowed mutably\n-    fn is_mutable<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> Result<(), &'d Lvalue<'tcx>> {\n+    fn is_mutable<'d>(&self,\n+                      lvalue: &'d Lvalue<'tcx>,\n+                      is_local_mutation_allowed: LocalMutationIsAllowed)\n+                      -> Result<(), &'d Lvalue<'tcx>> {\n         match *lvalue {\n             Lvalue::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n-                    Mutability::Not => Err(lvalue),\n+                    Mutability::Not =>\n+                        match is_local_mutation_allowed {\n+                            LocalMutationIsAllowed::Yes => Ok(()),\n+                            LocalMutationIsAllowed::No => Err(lvalue),\n+                        },\n                     Mutability::Mut => Ok(())\n                 }\n             },\n@@ -1001,7 +1110,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         // `Box<T>` owns its content, so mutable if its location is mutable\n                         if base_ty.is_box() {\n-                            return self.is_mutable(&proj.base);\n+                            return self.is_mutable(&proj.base, LocalMutationIsAllowed::No);\n                         }\n \n                         // Otherwise we check the kind of deref to decide\n@@ -1035,7 +1144,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::ConstantIndex{..} |\n                     ProjectionElem::Subslice{..} |\n                     ProjectionElem::Downcast(..) =>\n-                        self.is_mutable(&proj.base)\n+                        self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n                 }\n             }\n         }\n@@ -1343,20 +1452,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             |moi| curr_move_out.contains(moi)).collect::<Vec<_>>();\n \n         if mois.is_empty() {\n+            let item_msg = match self.describe_lvalue(lvalue) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned()\n+            };\n             self.tcx.cannot_act_on_uninitialized_variable(span,\n                                                           desired_action.as_noun(),\n-                                                          &self.describe_lvalue(lvalue),\n+                                                          &self.describe_lvalue(lvalue)\n+                                                            .unwrap_or(\"_\".to_owned()),\n                                                           Origin::Mir)\n-                    .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n-                                              self.describe_lvalue(lvalue)))\n+                    .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n                     .emit();\n         } else {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n             let mut err = self.tcx.cannot_act_on_moved_value(span,\n                                                              desired_action.as_noun(),\n                                                              msg,\n-                                                             &self.describe_lvalue(lvalue),\n+                                                             &self.describe_lvalue(lvalue)\n+                                                                .unwrap_or(\"_\".to_owned()),\n                                                              Origin::Mir);\n \n             err.span_label(span, format!(\"value {} here after move\",\n@@ -1381,14 +1495,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                       _context: Context,\n                                       (lvalue, span): (&Lvalue<'tcx>, Span),\n                                       borrow: &BorrowData<'tcx>) {\n+        let value_msg = match self.describe_lvalue(lvalue) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned()\n+        };\n+        let borrow_msg = match self.describe_lvalue(&borrow.lvalue) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned()\n+        };\n         self.tcx.cannot_move_when_borrowed(span,\n-                                           &self.describe_lvalue(lvalue),\n+                                           &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n                                            Origin::Mir)\n                 .span_label(self.retrieve_borrow_span(borrow),\n-                            format!(\"borrow of `{}` occurs here\",\n-                                    self.describe_lvalue(&borrow.lvalue)))\n-                .span_label(span, format!(\"move out of `{}` occurs here\",\n-                                          self.describe_lvalue(lvalue)))\n+                            format!(\"borrow of {} occurs here\", borrow_msg))\n+                .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n                 .emit();\n     }\n \n@@ -1398,8 +1518,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                          borrow : &BorrowData<'tcx>) {\n \n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span, &self.describe_lvalue(lvalue),\n-            self.retrieve_borrow_span(borrow), &self.describe_lvalue(&borrow.lvalue),\n+            span,\n+            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+            self.retrieve_borrow_span(borrow),\n+            &self.describe_lvalue(&borrow.lvalue).unwrap_or(\"_\".to_owned()),\n             Origin::Mir);\n \n         err.emit();\n@@ -1488,7 +1610,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n         let issued_span = old_closure_span.map(|(args, _)| args).unwrap_or(issued_span);\n \n-        let desc_lvalue = self.describe_lvalue(lvalue);\n+        let desc_lvalue = self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned());\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (gen_borrow_kind, \"immutable\", \"mutable\",\n@@ -1566,7 +1688,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                            (lvalue, span): (&Lvalue<'tcx>, Span),\n                                            loan: &BorrowData) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n-            span, self.retrieve_borrow_span(loan), &self.describe_lvalue(lvalue), Origin::Mir);\n+            span,\n+            self.retrieve_borrow_span(loan),\n+            &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir);\n \n         err.emit();\n     }\n@@ -1576,31 +1701,29 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                    (lvalue, span): (&Lvalue<'tcx>, Span),\n                                    assigned_span: Span) {\n         let mut err = self.tcx.cannot_reassign_immutable(span,\n-                                           &self.describe_lvalue(lvalue),\n+                                           &self.describe_lvalue(lvalue).unwrap_or(\"_\".to_owned()),\n                                            Origin::Mir);\n         err.span_label(span, \"cannot assign twice to immutable variable\");\n         if span != assigned_span {\n-            err.span_label(assigned_span, format!(\"first assignment to `{}`\",\n-                                              self.describe_lvalue(lvalue)));\n+            let value_msg = match self.describe_lvalue(lvalue) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned()\n+            };\n+            err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n         }\n         err.emit();\n     }\n-\n-    fn report_assignment_to_static(&mut self,\n-                                   _context: Context,\n-                                   (lvalue, span): (&Lvalue<'tcx>, Span)) {\n-        let mut err = self.tcx.cannot_assign_static(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        err.emit();\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // End-user visible description of `lvalue`\n-    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> String {\n+    // End-user visible description of `lvalue` if one can be found. If the\n+    // lvalue is a temporary for instance, None will be returned.\n+    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> Option<String> {\n         let mut buf = String::new();\n-        self.append_lvalue_to_string(lvalue, &mut buf, false);\n-        buf\n+        match self.append_lvalue_to_string(lvalue, &mut buf, false) {\n+            Ok(()) => Some(buf),\n+            Err(()) => None\n+        }\n     }\n \n     /// If this is a field projection, and the field is being projected from a closure type,\n@@ -1632,10 +1755,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn append_lvalue_to_string(&self,\n                                lvalue: &Lvalue<'tcx>,\n                                buf: &mut String,\n-                               mut autoderef: bool) {\n+                               mut autoderef: bool) -> Result<(), ()> {\n         match *lvalue {\n             Lvalue::Local(local) => {\n-                self.append_local_to_string(local, buf, \"_\");\n+                self.append_local_to_string(local, buf,)?;\n             }\n             Lvalue::Static(ref static_) => {\n                 buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n@@ -1653,15 +1776,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                         } else {\n                             if autoderef {\n-                                self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                                self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                             } else {\n                                 buf.push_str(&\"*\");\n-                                self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                                self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                             }\n                         }\n                     },\n                     ProjectionElem::Downcast(..) => {\n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                     },\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n@@ -1672,38 +1795,45 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);\n-                            self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                            self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                             buf.push_str(&format!(\".{}\", field_name));\n                         }\n                     },\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n \n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                         buf.push_str(\"[\");\n-                        self.append_local_to_string(index, buf, \"..\");\n+                        if let Err(_) = self.append_local_to_string(index, buf) {\n+                            buf.push_str(\"..\");\n+                        }\n                         buf.push_str(\"]\");\n                     },\n                     ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n                         autoderef = true;\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        self.append_lvalue_to_string(&proj.base, buf, autoderef)?;\n                         buf.push_str(&\"[..]\");\n                     },\n                 };\n             }\n         }\n+\n+        Ok(())\n     }\n \n     // Appends end-user visible description of the `local` lvalue to `buf`. If `local` doesn't have\n-    // a name, then `none_string` is appended instead\n-    fn append_local_to_string(&self, local_index: Local, buf: &mut String, none_string: &str) {\n+    // a name, then `Err` is returned\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n         let local = &self.mir.local_decls[local_index];\n         match local.name {\n-            Some(name) => buf.push_str(&format!(\"{}\", name)),\n-            None => buf.push_str(none_string)\n+            Some(name) => {\n+                buf.push_str(&format!(\"{}\", name));\n+                Ok(())\n+            },\n+            None => Err(())\n         }\n     }\n "}, {"sha": "f3fbc3b8b54dbe98b1a2e00cdc41f48adcf064d4", "filename": "src/test/compile-fail/E0594.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2FE0594.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2FE0594.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0594.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -15,5 +15,5 @@ static NUM: i32 = 18;\n \n fn main() {\n     NUM = 20; //[ast]~ ERROR E0594\n-              //[mir]~^ ERROR cannot assign to immutable static item\n+              //[mir]~^ ERROR cannot assign to immutable item `NUM`\n }"}, {"sha": "76a670af3531c0675d08d5d29335b90ec405d3d5", "filename": "src/test/compile-fail/borrowck/borrowck-assign-to-constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-to-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-to-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-to-constants.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -16,5 +16,5 @@ static foo: isize = 5;\n fn main() {\n     // assigning to various global constants\n     foo = 6; //[ast]~ ERROR cannot assign to immutable static item\n-             //[mir]~^ ERROR cannot assign to immutable static item `foo`\n+             //[mir]~^ ERROR cannot assign to immutable item `foo`\n }"}, {"sha": "8a09ab3fd06c8e1ffa7f5dce75db2ecf07dbf57e", "filename": "src/test/compile-fail/borrowck/borrowck-issue-14498.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -14,6 +14,9 @@\n // Also includes tests of the errors reported when the Box in question\n // is immutable (#14270).\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(box_syntax)]\n \n struct A { a: isize }\n@@ -23,7 +26,8 @@ fn indirect_write_to_imm_box() {\n     let mut x: isize = 1;\n     let y: Box<_> = box &mut x;\n     let p = &y;\n-    ***p = 2; //~ ERROR cannot assign to data in a `&` reference\n+    ***p = 2; //[ast]~ ERROR cannot assign to data in a `&` reference\n+              //[mir]~^ ERROR cannot assign to immutable item `***p`\n     drop(p);\n }\n \n@@ -32,7 +36,8 @@ fn borrow_in_var_from_var() {\n     let mut y: Box<_> = box &mut x;\n     let p = &y;\n     let q = &***p;\n-    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    **y = 2; //[ast]~ ERROR cannot assign to `**y` because it is borrowed\n+             //[mir]~^ ERROR cannot assign to `**y` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -42,7 +47,8 @@ fn borrow_in_var_from_var_via_imm_box() {\n     let y: Box<_> = box &mut x;\n     let p = &y;\n     let q = &***p;\n-    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    **y = 2; //[ast]~ ERROR cannot assign to `**y` because it is borrowed\n+             //[mir]~^ ERROR cannot assign to `**y` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -52,7 +58,8 @@ fn borrow_in_var_from_field() {\n     let mut y: Box<_> = box &mut x.a;\n     let p = &y;\n     let q = &***p;\n-    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    **y = 2; //[ast]~ ERROR cannot assign to `**y` because it is borrowed\n+             //[mir]~^ ERROR cannot assign to `**y` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -62,7 +69,8 @@ fn borrow_in_var_from_field_via_imm_box() {\n     let y: Box<_> = box &mut x.a;\n     let p = &y;\n     let q = &***p;\n-    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    **y = 2; //[ast]~ ERROR cannot assign to `**y` because it is borrowed\n+             //[mir]~^ ERROR cannot assign to `**y` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -72,7 +80,8 @@ fn borrow_in_field_from_var() {\n     let mut y = B { a: box &mut x };\n     let p = &y.a;\n     let q = &***p;\n-    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    **y.a = 2; //[ast]~ ERROR cannot assign to `**y.a` because it is borrowed\n+               //[mir]~^ ERROR cannot assign to `**y.a` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -82,7 +91,8 @@ fn borrow_in_field_from_var_via_imm_box() {\n     let y = B { a: box &mut x };\n     let p = &y.a;\n     let q = &***p;\n-    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    **y.a = 2; //[ast]~ ERROR cannot assign to `**y.a` because it is borrowed\n+               //[mir]~^ ERROR cannot assign to `**y.a` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -92,7 +102,8 @@ fn borrow_in_field_from_field() {\n     let mut y = B { a: box &mut x.a };\n     let p = &y.a;\n     let q = &***p;\n-    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    **y.a = 2; //[ast]~ ERROR cannot assign to `**y.a` because it is borrowed\n+               //[mir]~^ ERROR cannot assign to `**y.a` because it is borrowed\n     drop(p);\n     drop(q);\n }\n@@ -102,7 +113,8 @@ fn borrow_in_field_from_field_via_imm_box() {\n     let y = B { a: box &mut x.a };\n     let p = &y.a;\n     let q = &***p;\n-    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    **y.a = 2; //[ast]~ ERROR cannot assign to `**y.a` because it is borrowed\n+               //[mir]~^ ERROR cannot assign to `**y.a` because it is borrowed\n     drop(p);\n     drop(q);\n }"}, {"sha": "3a4c22eb1395a0f6bfb915d48a804d0543aea9a1", "filename": "src/test/compile-fail/borrowck/borrowck-overloaded-index-ref-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -70,5 +70,5 @@ fn main() {\n     };\n     s[2] = 20;\n     //[ast]~^ ERROR cannot assign to immutable indexed content\n-    // FIXME Error for MIR\n+    //[mir]~^^ ERROR cannot assign to immutable item\n }"}, {"sha": "8eed61ec8d531cb58bace43eca97e0d0af3c8944", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(unboxed_closures)]\n \n use std::io::Read;\n@@ -17,9 +21,11 @@ fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n fn main() {\n     let x = 1;\n     to_fn_once(move|| { x = 2; });\n-    //~^ ERROR: cannot assign to immutable captured outer variable\n+    //[ast]~^ ERROR: cannot assign to immutable captured outer variable\n+    //[mir]~^^ ERROR: cannot assign to immutable item `x`\n \n     let s = std::io::stdin();\n     to_fn_once(move|| { s.read_to_end(&mut Vec::new()); });\n-    //~^ ERROR: cannot borrow immutable captured outer variable\n+    //[ast]~^ ERROR: cannot borrow immutable captured outer variable\n+    //[mir]~^^ ERROR: cannot borrow immutable item `s` as mutable\n }"}, {"sha": "75ff0a1210142bd29bc01c2fc2bab4a79064f596", "filename": "src/test/compile-fail/issue-5500-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -20,6 +20,7 @@ fn main() {\n     let _iter = TrieMapIterator{node: &a};\n     _iter.node = & //[ast]~ ERROR cannot assign to immutable field `_iter.node`\n                    //[mir]~^ ERROR cannot assign to immutable field `_iter.node` (Ast)\n-                   // FIXME Error for MIR\n+                   // MIR doesn't generate an error because the code isn't reachable. This is OK\n+                   // because the test is here to check that the compiler doesn't ICE (cf. #5500).\n     panic!()\n }"}, {"sha": "0dbd61413e053d9ebd23976eddff7f2665c55857", "filename": "src/test/compile-fail/unboxed-closures-mutated-upvar-from-fn-closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909b94b5cceb046a7a3aa7134be1a3e25f75fec4/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs?ref=909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n // Test that a by-ref `FnMut` closure gets an error when it tries to\n // mutate a value.\n \n@@ -19,6 +22,7 @@ fn main() {\n     let mut counter = 0;\n     call(|| {\n         counter += 1;\n-        //~^ ERROR cannot assign to data in a captured outer variable in an `Fn` closure\n+        //[ast]~^ ERROR cannot assign to data in a captured outer variable in an `Fn` closure\n+        //[mir]~^^ ERROR cannot assign to immutable item `counter`\n     });\n }"}]}