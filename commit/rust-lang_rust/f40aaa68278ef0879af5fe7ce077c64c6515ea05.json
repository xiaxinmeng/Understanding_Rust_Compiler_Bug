{"sha": "f40aaa68278ef0879af5fe7ce077c64c6515ea05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MGFhYTY4Mjc4ZWYwODc5YWY1ZmU3Y2UwNzdjNjRjNjUxNWVhMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-31T03:47:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-31T03:47:17Z"}, "message": "Auto merge of #58016 - Centril:rollup, r=Centril\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #57008 (suggest `|` when `,` founds in invalid match value)\n - #57106 (Mark str::trim.* functions as #[must_use].)\n - #57920 (use `SOURCE_DATE_EPOCH` for man page time if set)\n - #57934 (Introduce into_raw_non_null on Rc and Arc)\n - #57971 (SGX target: improve panic & exit handling)\n - #57980 (Add the edition guide to the bookshelf)\n - #57984 (Improve bug message in check_ty)\n - #57999 (Add MOVBE x86 CPU feature)\n - #58000 (Fixes and cleanups)\n - #58005 (update docs for fix_start/end_matches)\n - #58007 (Don't panic when accessing enum variant ctor using `Self` in match)\n - #58008 (Pass correct arguments to places_conflict)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4e07acbdc12409c4e340f11584f410286872197e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e07acbdc12409c4e340f11584f410286872197e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f40aaa68278ef0879af5fe7ce077c64c6515ea05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f40aaa68278ef0879af5fe7ce077c64c6515ea05", "html_url": "https://github.com/rust-lang/rust/commit/f40aaa68278ef0879af5fe7ce077c64c6515ea05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f40aaa68278ef0879af5fe7ce077c64c6515ea05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "147311c5fc62537da8eb9c6f69536bec6719d534", "url": "https://api.github.com/repos/rust-lang/rust/commits/147311c5fc62537da8eb9c6f69536bec6719d534", "html_url": "https://github.com/rust-lang/rust/commit/147311c5fc62537da8eb9c6f69536bec6719d534"}, {"sha": "877dee7c67d3300074d485e3ef48984732aa907d", "url": "https://api.github.com/repos/rust-lang/rust/commits/877dee7c67d3300074d485e3ef48984732aa907d", "html_url": "https://github.com/rust-lang/rust/commit/877dee7c67d3300074d485e3ef48984732aa907d"}], "stats": {"total": 408, "additions": 319, "deletions": 89}, "files": [{"sha": "d9bf95d13ac17722ce05c6cdb09ac5f59a8d9fab", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -23,7 +23,7 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::compile;\n use crate::tool::{self, Tool};\n use crate::cache::{INTERNER, Interned};\n-use time;\n+use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder, component: &str) -> String {\n     if component == \"cargo\" {\n@@ -528,7 +528,19 @@ impl Step for Rustc {\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n             let man_src = builder.src.join(\"src/doc/man\");\n             let man_dst = image.join(\"share/man/man1\");\n-            let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n+\n+            // Reproducible builds: If SOURCE_DATE_EPOCH is set, use that as the time.\n+            let time = env::var(\"SOURCE_DATE_EPOCH\")\n+                .map(|timestamp| {\n+                    let epoch = timestamp.parse().map_err(|err| {\n+                        format!(\"could not parse SOURCE_DATE_EPOCH: {}\", err)\n+                    }).unwrap();\n+\n+                    time::at(Timespec::new(epoch, 0))\n+                })\n+                .unwrap_or_else(|_| time::now());\n+\n+            let month_year = t!(time::strftime(\"%B %Y\", &time));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n             for file_entry in builder.read_dir(&man_src) {"}, {"sha": "7bd1854d86f40c2efa2f91900dac6e3e5b16f08c", "filename": "src/doc/index.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -71,6 +71,10 @@ accomplishing various tasks.\n   </form>\n </div>\n \n+## The Edition Guide\n+\n+[The Edition Guide](edition-guide/index.html) describes the Rust editions.\n+\n ## The Rustc Book\n \n [The Rustc Book](rustc/index.html) describes the Rust compiler, `rustc`."}, {"sha": "5efb74bc12080af2825eea1eea873e6c8e89d47b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -433,6 +433,27 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n+    /// Consumes the `Rc`, returning the wrapped pointer as `NonNull<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_into_raw_non_null)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let ptr = Rc::into_raw_non_null(x);\n+    /// let deref = unsafe { *ptr.as_ref() };\n+    /// assert_eq!(deref, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n+    #[inline]\n+    pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n+        // safe because Rc guarantees its pointer is non-null\n+        unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n+    }\n+\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n     /// [weak]: struct.Weak.html"}, {"sha": "5cffa93db11d4780f4c9edfc4b0643a527f82ed5", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -413,6 +413,27 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n+    /// Consumes the `Arc`, returning the wrapped pointer as `NonNull<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_into_raw_non_null)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let ptr = Arc::into_raw_non_null(x);\n+    /// let deref = unsafe { *ptr.as_ref() };\n+    /// assert_eq!(deref, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n+    #[inline]\n+    pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n+        // safe because Arc guarantees its pointer is non-null\n+        unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n+    }\n+\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n     /// [weak]: struct.Weak.html"}, {"sha": "3cb39360380938abdc282ee9200c862e45d61528", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -3489,6 +3489,8 @@ impl str {\n     ///\n     /// assert_eq!(\"Hello\\tworld\", s.trim());\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a slice, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim(&self) -> &str {\n         self.trim_matches(|c: char| c.is_whitespace())\n@@ -3524,6 +3526,8 @@ impl str {\n     /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea  \";\n     /// assert!(Some('\u05e2') == s.trim_start().chars().next());\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n     pub fn trim_start(&self) -> &str {\n         self.trim_start_matches(|c: char| c.is_whitespace())\n@@ -3559,6 +3563,8 @@ impl str {\n     /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea  \";\n     /// assert!(Some('\u05ea') == s.trim_end().chars().rev().next());\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n     pub fn trim_end(&self) -> &str {\n         self.trim_end_matches(|c: char| c.is_whitespace())\n@@ -3661,6 +3667,8 @@ impl str {\n     /// ```\n     /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: DoubleEndedSearcher<'a>\n@@ -3706,6 +3714,8 @@ impl str {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n     pub fn trim_start_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n         let mut i = self.len();\n@@ -3749,6 +3759,8 @@ impl str {\n     /// ```\n     /// assert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n     pub fn trim_end_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: ReverseSearcher<'a>\n@@ -3774,10 +3786,10 @@ impl str {\n     ///\n     /// # Text directionality\n     ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n+    /// A string is a sequence of bytes. `start` in this context means the first\n+    /// position of that byte string; for a left-to-right language like English or\n+    /// Russian, this will be left side; and for right-to-left languages like\n+    /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3806,10 +3818,10 @@ impl str {\n     ///\n     /// # Text directionality\n     ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n+    /// A string is a sequence of bytes. `end` in this context means the last\n+    /// position of that byte string; for a left-to-right language like English or\n+    /// Russian, this will be right side; and for right-to-left languages like\n+    /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1328a1aeeab962ec0a49597efe216d81e20e53e2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -14,7 +14,7 @@ pub struct RawConst<'tcx> {\n }\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n+/// matches the LocalState optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with layout::abi::Scalar ABI and ZSTs"}, {"sha": "b46e6ef84b98b4740eec5d7f706a221c7388a8c5", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -147,6 +147,7 @@ const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n     (\"fxsr\", None),\n     (\"lzcnt\", None),\n     (\"mmx\", Some(\"mmx_target_feature\")),\n+    (\"movbe\", Some(\"movbe_target_feature\")),\n     (\"pclmulqdq\", None),\n     (\"popcnt\", None),\n     (\"rdrand\", None),"}, {"sha": "72218e29cfd20f6b5eb8069e337005bd7a4a71cb", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -215,8 +215,8 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             if places_conflict::places_conflict(\n                 self.tcx,\n                 self.mir,\n-                place,\n                 &borrow_data.borrowed_place,\n+                place,\n                 places_conflict::PlaceConflictBias::NoOverlap,\n             ) {\n                 debug!("}, {"sha": "1b976d822ebff1a6d19a2a36afed9b7cc59471ce", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -76,8 +76,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n-    pub locals: IndexVec<mir::Local, LocalValue<Tag>>,\n-    pub local_layouts: IndexVec<mir::Local, Cell<Option<TyLayout<'tcx>>>>,\n+    pub locals: IndexVec<mir::Local, LocalState<'tcx, Tag>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -106,7 +105,15 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n-// State of a local variable\n+/// State of a local variable including a memoized layout\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n+    pub state: LocalValue<Tag, Id>,\n+    /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n+    pub layout: Cell<Option<TyLayout<'tcx>>>,\n+}\n+\n+/// State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     Dead,\n@@ -117,16 +124,16 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n     Live(Operand<Tag, Id>),\n }\n \n-impl<'tcx, Tag> LocalValue<Tag> {\n+impl<'tcx, Tag> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n-        match self {\n+        match self.state {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(ref val) => Ok(val),\n         }\n     }\n \n     pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand<Tag>> {\n-        match self {\n+        match self.state {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(ref mut val) => Ok(val),\n         }\n@@ -310,17 +317,21 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     pub fn layout_of_local(\n         &self,\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n-        local: mir::Local\n+        local: mir::Local,\n+        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n-        let cell = &frame.local_layouts[local];\n-        if cell.get().is_none() {\n-            let local_ty = frame.mir.local_decls[local].ty;\n-            let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n-            let layout = self.layout_of(local_ty)?;\n-            cell.set(Some(layout));\n+        match frame.locals[local].layout.get() {\n+            None => {\n+                let layout = ::interpret::operand::from_known_layout(layout, || {\n+                    let local_ty = frame.mir.local_decls[local].ty;\n+                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n+                    self.layout_of(local_ty)\n+                })?;\n+                frame.locals[local].layout.set(Some(layout));\n+                Ok(layout)\n+            }\n+            Some(layout) => Ok(layout),\n         }\n-\n-        Ok(cell.get().unwrap())\n     }\n \n     pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n@@ -454,7 +465,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n-            local_layouts: IndexVec::from_elem_n(Default::default(), mir.local_decls.len()),\n             span,\n             instance,\n             stmt: 0,\n@@ -466,12 +476,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // We put some marker immediate into the locals that we later want to initialize.\n             // This can be anything except for LocalValue::Dead -- because *that* is the\n             // value we use for things that we know are initially dead.\n-            let dummy =\n-                LocalValue::Live(Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef)));\n+            let dummy = LocalState {\n+                state: LocalValue::Live(Operand::Immediate(Immediate::Scalar(\n+                    ScalarMaybeUndef::Undef,\n+                ))),\n+                layout: Cell::new(None),\n+            };\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE] = LocalValue::Dead;\n+            locals[mir::RETURN_PLACE].state = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n@@ -484,7 +498,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                             match stmt.kind {\n                                 StorageLive(local) |\n                                 StorageDead(local) => {\n-                                    locals[local] = LocalValue::Dead;\n+                                    locals[local].state = LocalValue::Dead;\n                                 }\n                                 _ => {}\n                             }\n@@ -494,11 +508,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             }\n             // Finally, properly initialize all those that still have the dummy value\n             for (idx, local) in locals.iter_enumerated_mut() {\n-                match *local {\n+                match local.state {\n                     LocalValue::Live(_) => {\n-                        // This needs to be peoperly initialized.\n-                        let layout = self.layout_of_local(self.frame(), idx)?;\n-                        *local = LocalValue::Live(self.uninit_operand(layout)?);\n+                        // This needs to be properly initialized.\n+                        let ty = self.monomorphize(mir.local_decls[idx].ty)?;\n+                        let layout = self.layout_of(ty)?;\n+                        local.state = LocalValue::Live(self.uninit_operand(layout)?);\n+                        local.layout = Cell::new(Some(layout));\n                     }\n                     LocalValue::Dead => {\n                         // Nothing to do\n@@ -543,7 +559,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n         // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n-            self.deallocate_local(local)?;\n+            self.deallocate_local(local.state)?;\n         }\n         // Validate the return value. Do this after deallocating so that we catch dangling\n         // references.\n@@ -591,10 +607,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n-        let layout = self.layout_of_local(self.frame(), local)?;\n+        let layout = self.layout_of_local(self.frame(), local, None)?;\n         let init = LocalValue::Live(self.uninit_operand(layout)?);\n         // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local], init))\n+        Ok(mem::replace(&mut self.frame_mut().locals[local].state, init))\n     }\n \n     /// Returns the old value of the local.\n@@ -603,7 +619,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n+        mem::replace(&mut self.frame_mut().locals[local].state, LocalValue::Dead)\n     }\n \n     pub(super) fn deallocate_local("}, {"sha": "d2ab3fcb7a30a13ea8a402d53858867258d4e337", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup, LocalValue,\n+    EvalContext, Frame, StackPopCleanup, LocalState, LocalValue,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "37e421c2e7339fb9e6909ecdc212e1032c0e8d10", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -227,7 +227,7 @@ impl<'tcx, Tag> OpTy<'tcx, Tag>\n // Use the existing layout if given (but sanity check in debug mode),\n // or compute the layout.\n #[inline(always)]\n-fn from_known_layout<'tcx>(\n+pub(super) fn from_known_layout<'tcx>(\n     layout: Option<TyLayout<'tcx>>,\n     compute: impl FnOnce() -> EvalResult<'tcx, TyLayout<'tcx>>\n ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n@@ -457,14 +457,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n     /// This is used by [priroda](https://github.com/oli-obk/priroda) to get an OpTy from a local\n-    fn access_local(\n+    pub fn access_local(\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n+        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n         let op = *frame.locals[local].access()?;\n-        let layout = self.layout_of_local(frame, local)?;\n+        let layout = self.layout_of_local(frame, local, layout)?;\n         Ok(OpTy { op, layout })\n     }\n \n@@ -473,14 +474,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     fn eval_place_to_op(\n         &self,\n         mir_place: &mir::Place<'tcx>,\n+        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let op = match *mir_place {\n             Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n-            Local(local) => self.access_local(self.frame(), local)?,\n+            Local(local) => self.access_local(self.frame(), local, layout)?,\n \n             Projection(ref proj) => {\n-                let op = self.eval_place_to_op(&proj.base)?;\n+                let op = self.eval_place_to_op(&proj.base, None)?;\n                 self.operand_projection(op, &proj.elem)?\n             }\n \n@@ -504,7 +506,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n             Move(ref place) =>\n-                self.eval_place_to_op(place)?,\n+                self.eval_place_to_op(place, layout)?,\n \n             Constant(ref constant) => {\n                 let layout = from_known_layout(layout, || {"}, {"sha": "9ca7f9d8e27ff43214f0dd1817dd7339891e3b7d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -624,7 +624,7 @@ where\n                     // their layout on return.\n                     PlaceTy {\n                         place: *return_place,\n-                        layout: self.layout_of_local(self.frame(), mir::RETURN_PLACE)?,\n+                        layout: self.layout_of(self.monomorphize(self.frame().mir.return_ty())?)?,\n                     },\n                 None => return err!(InvalidNullPointerUsage),\n             },\n@@ -633,7 +633,7 @@ where\n                     frame: self.cur_frame(),\n                     local,\n                 },\n-                layout: self.layout_of_local(self.frame(), local)?,\n+                layout: self.layout_of_local(self.frame(), local, None)?,\n             },\n \n             Projection(ref proj) => {\n@@ -901,7 +901,7 @@ where\n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n-                        let local_layout = self.layout_of_local(&self.stack[frame], local)?;\n+                        let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack);\n                         // We don't have to validate as we can assume the local\n                         // was already valid for its type."}, {"sha": "5fae461bdc2033e42821b67944eb2e0e3b2104f2", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -23,8 +23,8 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n-use super::eval_context::{LocalValue, StackPopCleanup};\n-use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef};\n+use super::eval_context::{LocalState, StackPopCleanup};\n+use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef, LocalValue};\n use const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -321,7 +321,6 @@ impl_stable_hash_for!(impl<'mir, 'tcx: 'mir> for struct Frame<'mir, 'tcx> {\n     return_to_block,\n     return_place -> (return_place.as_ref().map(|r| &**r)),\n     locals,\n-    local_layouts -> _,\n     block,\n     stmt,\n     extra,\n@@ -340,7 +339,6 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             return_to_block,\n             return_place,\n             locals,\n-            local_layouts: _,\n             block,\n             stmt,\n             extra: _,\n@@ -358,6 +356,22 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     }\n }\n \n+impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let LocalState { state, layout: _ } = self;\n+        state.snapshot(ctx)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct LocalState<'tcx> {\n+    state,\n+    layout -> _,\n+});\n+\n impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n     for Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>\n {"}, {"sha": "7e823524c180c81de4c638401347fe3502b7fdc5", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         mir.spread_arg,\n                         mir.args_iter()\n                             .map(|local|\n-                                (local, self.layout_of_local(self.frame(), local).unwrap().ty)\n+                                (local, self.layout_of_local(self.frame(), local, None).unwrap().ty)\n                             )\n                             .collect::<Vec<_>>()\n                     );\n@@ -383,7 +383,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         }\n                     } else {\n                         let callee_layout =\n-                            self.layout_of_local(self.frame(), mir::RETURN_PLACE)?;\n+                            self.layout_of_local(self.frame(), mir::RETURN_PLACE, None)?;\n                         if !callee_layout.abi.is_uninhabited() {\n                             return err!(FunctionRetMismatch(\n                                 self.tcx.types.never, callee_layout.ty"}, {"sha": "4203c71a00a41735ed4d588ec9da78d668a1d342", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -784,7 +784,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Fictive) => {\n+            Def::VariantCtor(_, CtorKind::Fictive) |\n+            Def::VariantCtor(_, CtorKind::Fn) => {\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }"}, {"sha": "4275022c4f6d4eaa084ec0798fbb6cb583f907bb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -1303,12 +1303,12 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        Node::GenericParam(param) => match param.kind {\n+        Node::GenericParam(param) => match &param.kind {\n             hir::GenericParamKind::Type {\n                 default: Some(ref ty),\n                 ..\n             } => icx.to_ty(ty),\n-            _ => bug!(\"unexpected non-type NodeGenericParam\"),\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n         },\n \n         x => {\n@@ -2205,6 +2205,7 @@ fn from_target_feature(\n                 Some(\"wasm_target_feature\") => rust_features.wasm_target_feature,\n                 Some(\"cmpxchg16b_target_feature\") => rust_features.cmpxchg16b_target_feature,\n                 Some(\"adx_target_feature\") => rust_features.adx_target_feature,\n+                Some(\"movbe_target_feature\") => rust_features.movbe_target_feature,\n                 Some(name) => bug!(\"unknown target feature gate {}\", name),\n                 None => true,\n             };"}, {"sha": "9b46c2180d9a25a3a05853b6872b85272ff03f6d", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -66,7 +66,7 @@ IMAGE_BASE:\n     globvar EH_FRM_HDR_SIZE 8\n \n .Lreentry_panic_msg:\n-    .asciz \"Re-entered panicked enclave!\"\n+    .asciz \"Re-entered aborted enclave!\"\n .Lreentry_panic_msg_end:\n \n .Lusercall_panic_msg:\n@@ -80,7 +80,7 @@ IMAGE_BASE:\n     .org .+48 /*  reserved bits */\n \n .data\n-.Lpanicked:\n+.Laborted:\n     .byte 0\n \n /*  TCS local storage section */\n@@ -134,6 +134,9 @@ sgx_entry:\n     jz .Lskip_debug_init\n     mov %r10,%gs:tcsls_debug_panic_buf_ptr\n .Lskip_debug_init:\n+/*  check for abort */\n+    bt $0,.Laborted(%rip)\n+    jc .Lreentry_panic\n /*  check if returning from usercall */\n     mov %gs:tcsls_last_rsp,%r11\n     test %r11,%r11\n@@ -164,9 +167,6 @@ sgx_entry:\n     mov %r14,%r8\n     mov %r15,%r9\n .Lskip_init:\n-/*  check for panic */\n-    bt $0,.Lpanicked(%rip)\n-    jc .Lreentry_panic\n /*  call into main entry point */\n     load_tcsls_flag_secondary_bool cx /* RCX = entry() argument: secondary: bool */\n     call entry /* RDI, RSI, RDX, R8, R9 passed in from userspace */\n@@ -237,18 +237,18 @@ sgx_entry:\n     stmxcsr (%rsp)\n .endm\n \n-.global panic_exit\n-panic_exit:\n+.global usercall_exit\n+usercall_exit:\n /* save registers in DEBUG mode, so that debugger can reconstruct the stack */\n     testb $0xff,DEBUG(%rip)\n     jz .Lskip_save_registers\n     push_callee_saved_registers\n     movq %rsp,%gs:tcsls_panic_last_rsp\n .Lskip_save_registers:\n-/* set panicked bit */\n-    movb $1,.Lpanicked(%rip)\n+/* set aborted bit */\n+    movb $1,.Laborted(%rip)\n /* call usercall exit(true) */\n-    mov $1,%esi   /*  RSI = usercall() argument: panic = true */\n+    /* NOP: mov %rsi,%rsi */ /*  RSI = usercall() argument: panic */\n     xor %rdx,%rdx /*  RDX cleared */\n     movq $usercall_nr_exit,%rdi /*  RDI = usercall exit */\n     jmp .Lexit"}, {"sha": "d23fa9a9ec6f9783c4c653101d8a22b1bc49f271", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -1,12 +1,18 @@\n+use super::usercalls::alloc::UserRef;\n+use cmp;\n use io::{self, Write};\n-use slice::from_raw_parts_mut;\n+use mem;\n \n extern \"C\" {\n     fn take_debug_panic_buf_ptr() -> *mut u8;\n     static DEBUG: u8;\n }\n \n-pub(crate) struct SgxPanicOutput(Option<&'static mut [u8]>);\n+pub(crate) struct SgxPanicOutput(Option<&'static mut UserRef<[u8]>>);\n+\n+fn empty_user_slice() -> &'static mut UserRef<[u8]> {\n+    unsafe { UserRef::from_raw_parts_mut(1 as *mut u8, 0) }\n+}\n \n impl SgxPanicOutput {\n     pub(crate) fn new() -> Option<Self> {\n@@ -17,32 +23,36 @@ impl SgxPanicOutput {\n         }\n     }\n \n-    fn init(&mut self) -> &mut &'static mut [u8] {\n+    fn init(&mut self) -> &mut &'static mut UserRef<[u8]> {\n         self.0.get_or_insert_with(|| unsafe {\n             let ptr = take_debug_panic_buf_ptr();\n             if ptr.is_null() {\n-                &mut []\n+                empty_user_slice()\n             } else {\n-                from_raw_parts_mut(ptr, 1024)\n+                UserRef::from_raw_parts_mut(ptr, 1024)\n             }\n         })\n     }\n }\n \n impl Write for SgxPanicOutput {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.init().write(buf)\n+    fn write(&mut self, src: &[u8]) -> io::Result<usize> {\n+        let dst = mem::replace(self.init(), empty_user_slice());\n+        let written = cmp::min(src.len(), dst.len());\n+        dst[..written].copy_from_enclave(&src[..written]);\n+        self.0 = Some(&mut dst[written..]);\n+        Ok(written)\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        self.init().flush()\n+        Ok(())\n     }\n }\n \n #[no_mangle]\n pub extern \"C\" fn panic_msg(msg: &str) -> ! {\n     let _ = SgxPanicOutput::new().map(|mut out| out.write(msg.as_bytes()));\n-    unsafe { panic_exit(); }\n+    unsafe { usercall_exit(true); }\n }\n \n-extern \"C\" { pub fn panic_exit() -> !; }\n+extern \"C\" { pub fn usercall_exit(panic: bool) -> !; }"}, {"sha": "4e889c172ef38109fd9b2e2991b89007511bfa85", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -119,7 +119,7 @@ pub unsafe fn launch_thread() -> IoResult<()> {\n /// Usercall `exit`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn exit(panic: bool) -> ! {\n-    unsafe { raw::exit(panic) }\n+    unsafe { super::panic::usercall_exit(panic) }\n }\n \n /// Usercall `wait`. See the ABI documentation for more information."}, {"sha": "f2593c35bed14c6c79103d2716e6b0a098e9627f", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -125,7 +125,7 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    abi::panic::panic_exit()\n+    abi::panic::usercall_exit(true)\n }\n \n pub fn hashmap_random_keys() -> (u64, u64) {"}, {"sha": "9dd17b420aa44e890c1b49017bd55744cee1d0fc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -394,6 +394,7 @@ declare_features! (\n     (active, wasm_target_feature, \"1.30.0\", Some(44839), None),\n     (active, adx_target_feature, \"1.32.0\", Some(44839), None),\n     (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n+    (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n \n     // Allows macro invocations on modules expressions and statements and\n     // procedural macros to expand to non-items."}, {"sha": "514b2952c503679dfd59e9ff6ff32fc5d7a38b8d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -4381,9 +4381,14 @@ impl<'a> Parser<'a> {\n             if let Ok(seq_snippet) = self.sess.source_map().span_to_snippet(seq_span) {\n                 err.span_suggestion(\n                     seq_span,\n-                    \"try adding parentheses\",\n+                    \"try adding parentheses to match on a tuple..\",\n                     format!(\"({})\", seq_snippet),\n                     Applicability::MachineApplicable\n+                ).span_suggestion(\n+                    seq_span,\n+                    \"..or a vertical bar to match on multiple alternatives\",\n+                    format!(\"{}\", seq_snippet.replace(\",\", \" |\")),\n+                    Applicability::MachineApplicable\n                 );\n             }\n             return Err(err);"}, {"sha": "8099c3c0584fca5faa6f0aa960207baa0a6e4ae2", "filename": "src/test/ui/did_you_mean/issue-48492-tuple-destructure-missing-parens.stderr", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -2,37 +2,85 @@ error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:38:17\n    |\n LL |     while let b1, b2, b3 = reading_frame.next().expect(\"there should be a start codon\") {\n-   |               --^------- help: try adding parentheses: `(b1, b2, b3)`\n+   |                 ^\n+help: try adding parentheses to match on a tuple..\n+   |\n+LL |     while let (b1, b2, b3) = reading_frame.next().expect(\"there should be a start codon\") {\n+   |               ^^^^^^^^^^^^\n+help: ..or a vertical bar to match on multiple alternatives\n+   |\n+LL |     while let b1 | b2 | b3 = reading_frame.next().expect(\"there should be a start codon\") {\n+   |               ^^^^^^^^^^^^\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:49:14\n    |\n LL |     if let b1, b2, b3 = reading_frame.next().unwrap() {\n-   |            --^------- help: try adding parentheses: `(b1, b2, b3)`\n+   |              ^\n+help: try adding parentheses to match on a tuple..\n+   |\n+LL |     if let (b1, b2, b3) = reading_frame.next().unwrap() {\n+   |            ^^^^^^^^^^^^\n+help: ..or a vertical bar to match on multiple alternatives\n+   |\n+LL |     if let b1 | b2 | b3 = reading_frame.next().unwrap() {\n+   |            ^^^^^^^^^^^^\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:59:28\n    |\n LL |         Nucleotide::Adenine, Nucleotide::Cytosine, _ => true\n-   |         -------------------^------------------------ help: try adding parentheses: `(Nucleotide::Adenine, Nucleotide::Cytosine, _)`\n+   |                            ^\n+help: try adding parentheses to match on a tuple..\n+   |\n+LL |         (Nucleotide::Adenine, Nucleotide::Cytosine, _) => true\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ..or a vertical bar to match on multiple alternatives\n+   |\n+LL |         Nucleotide::Adenine | Nucleotide::Cytosine | _ => true\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:67:10\n    |\n LL |     for x, _barr_body in women.iter().map(|woman| woman.allosomes.clone()) {\n-   |         -^----------- help: try adding parentheses: `(x, _barr_body)`\n+   |          ^\n+help: try adding parentheses to match on a tuple..\n+   |\n+LL |     for (x, _barr_body) in women.iter().map(|woman| woman.allosomes.clone()) {\n+   |         ^^^^^^^^^^^^^^^\n+help: ..or a vertical bar to match on multiple alternatives\n+   |\n+LL |     for x | _barr_body in women.iter().map(|woman| woman.allosomes.clone()) {\n+   |         ^^^^^^^^^^^^^^\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:75:10\n    |\n LL |     for x, y @ Allosome::Y(_) in men.iter().map(|man| man.allosomes.clone()) {\n-   |         -^------------------- help: try adding parentheses: `(x, y @ Allosome::Y(_))`\n+   |          ^\n+help: try adding parentheses to match on a tuple..\n+   |\n+LL |     for (x, y @ Allosome::Y(_)) in men.iter().map(|man| man.allosomes.clone()) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+help: ..or a vertical bar to match on multiple alternatives\n+   |\n+LL |     for x | y @ Allosome::Y(_) in men.iter().map(|man| man.allosomes.clone()) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:84:14\n    |\n LL |     let women, men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n-   |         -----^---- help: try adding parentheses: `(women, men)`\n+   |              ^\n+help: try adding parentheses to match on a tuple..\n+   |\n+LL |     let (women, men): (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n+   |         ^^^^^^^^^^^^\n+help: ..or a vertical bar to match on multiple alternatives\n+   |\n+LL |     let women | men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n+   |         ^^^^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "1fb5fefa7596d26d1107e1aca2ed5bdaddbf5616", "filename": "src/test/ui/issues/issue-58006.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fissues%2Fissue-58006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fissues%2Fissue-58006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58006.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_enum_variants)]\n+pub enum Enum {\n+    A(usize),\n+}\n+\n+impl Enum {\n+    fn foo(&self) -> () {\n+        match self {\n+            Self::A => (),\n+            //~^ ERROR expected unit struct/variant or constant, found tuple variant\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c65e3e2777faea1901a5e606d2ca7dc24ecb6807", "filename": "src/test/ui/issues/issue-58006.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fissues%2Fissue-58006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fissues%2Fissue-58006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58006.stderr?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -0,0 +1,9 @@\n+error[E0533]: expected unit struct/variant or constant, found tuple variant `<Self>::A`\n+  --> $DIR/issue-58006.rs:9:13\n+   |\n+LL |             Self::A => (),\n+   |             ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0533`."}, {"sha": "4f21cca97cc093160a60f8fe5fd5a6e8c3aaec57", "filename": "src/test/ui/nll/issue-57989.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fnll%2Fissue-57989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fnll%2Fissue-57989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57989.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -0,0 +1,12 @@\n+// Test for ICE from issue 57989\n+\n+#![feature(nll)]\n+\n+fn f(x: &i32) {\n+    let g = &x;\n+    *x = 0;     //~ ERROR cannot assign to `*x` which is behind a `&` reference\n+                //~| ERROR cannot assign to `*x` because it is borrowed\n+    g;\n+}\n+\n+fn main() {}"}, {"sha": "4561c99096f148319b46a4f6fd276d89e3de56e9", "filename": "src/test/ui/nll/issue-57989.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fnll%2Fissue-57989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Fnll%2Fissue-57989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57989.stderr?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -0,0 +1,24 @@\n+error[E0594]: cannot assign to `*x` which is behind a `&` reference\n+  --> $DIR/issue-57989.rs:7:5\n+   |\n+LL | fn f(x: &i32) {\n+   |         ---- help: consider changing this to be a mutable reference: `&mut i32`\n+LL |     let g = &x;\n+LL |     *x = 0;     //~ ERROR cannot assign to `*x` which is behind a `&` reference\n+   |     ^^^^^^ `x` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-57989.rs:7:5\n+   |\n+LL |     let g = &x;\n+   |             -- borrow of `*x` occurs here\n+LL |     *x = 0;     //~ ERROR cannot assign to `*x` which is behind a `&` reference\n+   |     ^^^^^^ assignment to borrowed `*x` occurs here\n+LL |                 //~| ERROR cannot assign to `*x` because it is borrowed\n+LL |     g;\n+   |     - borrow later used here\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0506, E0594.\n+For more information about an error, try `rustc --explain E0506`."}, {"sha": "84300301b7629a56911bc352639979e890e01250", "filename": "src/test/ui/target-feature-gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.rs?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -22,6 +22,7 @@\n // gate-test-wasm_target_feature\n // gate-test-adx_target_feature\n // gate-test-cmpxchg16b_target_feature\n+// gate-test-movbe_target_feature\n // min-llvm-version 6.0\n \n #[target_feature(enable = \"avx512bw\")]"}, {"sha": "24141d0064fb0f2c0cf92dd52a710ad22bb54785", "filename": "src/test/ui/target-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f40aaa68278ef0879af5fe7ce077c64c6515ea05/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr?ref=f40aaa68278ef0879af5fe7ce077c64c6515ea05", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable (see issue #44839)\n-  --> $DIR/target-feature-gate.rs:27:18\n+  --> $DIR/target-feature-gate.rs:28:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^"}]}