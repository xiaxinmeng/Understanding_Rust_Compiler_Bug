{"sha": "e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "node_id": "C_kwDOAAsO6NoAKGU4YmM2ZTEzMjgyMGYyNDkwOWY0ZWY1MzZmODRlMGFhM2RkZjJkMmI", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-11T17:12:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-11T17:12:31Z"}, "message": "Rollup merge of #104051 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nNotable PRs:\n- https://github.com/rust-lang/miri/pull/2636\n- https://github.com/rust-lang/miri/pull/2641\n- https://github.com/rust-lang/miri/pull/2638", "tree": {"sha": "ec98aa5d2690001e1c37766df49668d196293eca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec98aa5d2690001e1c37766df49668d196293eca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjboJ/CRBK7hj4Ov3rIwAAeF0IAETu4fIkcf8Oquuj/svm5t5A\nDWcccLDJjD3e4eOmQaFttag1DXMrzl6kt8nNC43x9gnl3SSDc5KFM6E4vp6YrC3b\nsUtNR7jxXUH8qgdeH/HGMwpxHNPT4ol63FSb2jreWHSSHo1dOtxN1IfXjBJLcycC\nCf5v/a+4RsfPr/B4ORWaRZb+RbRRD+lUts+4U8UpOrT0iUUidCdjk9g9q6EzIXt7\nKXhcluMu/d8xKSGqT1SiTqWHG1qFnuck+e+KM+RjMayyct3j6xgtM2mTBB2ysREK\ncSKYrzF/x6+v5mJhs/QX+A6POzi7J1KrQ4pfKBarIISsSKB7c1dUderCIQhy4/U=\n=Z5+N\n-----END PGP SIGNATURE-----\n", "payload": "tree ec98aa5d2690001e1c37766df49668d196293eca\nparent a13809ae51bbe0c4c203ad17e533a083af8e15b9\nparent f60a2ae3e9aada6d42dd7e02f1d0107d4ba09f05\nauthor Manish Goregaokar <manishsmail@gmail.com> 1668186751 -0500\ncommitter GitHub <noreply@github.com> 1668186751 -0500\n\nRollup merge of #104051 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nNotable PRs:\n- https://github.com/rust-lang/miri/pull/2636\n- https://github.com/rust-lang/miri/pull/2641\n- https://github.com/rust-lang/miri/pull/2638\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "html_url": "https://github.com/rust-lang/rust/commit/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a13809ae51bbe0c4c203ad17e533a083af8e15b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a13809ae51bbe0c4c203ad17e533a083af8e15b9", "html_url": "https://github.com/rust-lang/rust/commit/a13809ae51bbe0c4c203ad17e533a083af8e15b9"}, {"sha": "f60a2ae3e9aada6d42dd7e02f1d0107d4ba09f05", "url": "https://api.github.com/repos/rust-lang/rust/commits/f60a2ae3e9aada6d42dd7e02f1d0107d4ba09f05", "html_url": "https://github.com/rust-lang/rust/commit/f60a2ae3e9aada6d42dd7e02f1d0107d4ba09f05"}], "stats": {"total": 1049, "additions": 831, "deletions": 218}, "files": [{"sha": "607ffe0cc59feb11d3c735ea3bddd0d7b53aa0c3", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -67,9 +67,9 @@ jobs:\n         shell: bash\n         run: |\n           if [[ ${{ github.event_name }} == 'schedule' ]]; then\n-            ./rustup-toolchain HEAD --host ${{ matrix.host_target }}\n+            ./miri toolchain HEAD --host ${{ matrix.host_target }}\n           else\n-            ./rustup-toolchain \"\" --host ${{ matrix.host_target }}\n+            ./miri toolchain \"\" --host ${{ matrix.host_target }}\n           fi\n \n       - name: Show Rust version\n@@ -118,7 +118,7 @@ jobs:\n       - name: Install \"master\" toolchain\n         shell: bash\n         run: |\n-          ./rustup-toolchain \"\" -c clippy\n+          ./miri toolchain\n \n       - name: Show Rust version\n         run: |"}, {"sha": "724cf26df2b9b3f85a26b45e7ea8144233dfea05", "filename": "src/tools/miri/.gitpod.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2F.gitpod.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2F.gitpod.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.gitpod.yml?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -4,6 +4,6 @@ tasks:\n   - before: echo \"...\"\n     init: |\n       cargo install rustup-toolchain-install-master\n-      ./rustup-toolchain\n+      ./miri toolchain\n       ./miri build\n-    command: echo \"Run tests with ./miri test\"\n\\ No newline at end of file\n+    command: echo \"Run tests with ./miri test\""}, {"sha": "5c41547616ec68d0e9c8d50673cbadf45f2ffef8", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -23,13 +23,13 @@ tested against. Other versions will likely not work. After installing\n [`rustup-toolchain-install-master`], you can run the following command to\n install that exact version of rustc as a toolchain:\n ```\n-./rustup-toolchain\n+./miri toolchain\n ```\n This will set up a rustup toolchain called `miri` and set it as an override for\n the current directory.\n \n You can also create a `.auto-everything` file (contents don't matter, can be empty), which\n-will cause any `./miri` command to automatically call `rustup-toolchain`, `clippy` and `rustfmt`\n+will cause any `./miri` command to automatically call `./miri toolchain`, `clippy` and `rustfmt`\n for you. If you don't want all of these to happen, you can add individual `.auto-toolchain`,\n `.auto-clippy` and `.auto-fmt` files respectively.\n \n@@ -132,12 +132,15 @@ development version of Miri using\n and then you can use it as if it was installed by `rustup`.  Make sure you use\n the same toolchain when calling `cargo miri` that you used when installing Miri!\n Usually this means you have to write `cargo +miri miri ...` to select the `miri`\n-toolchain that was installed by `./rustup-toolchain`.\n+toolchain that was installed by `./miri toolchain`.\n \n There's a test for the cargo wrapper in the `test-cargo-miri` directory; run\n `./run-test.py` in there to execute it. Like `./miri test`, this respects the\n `MIRI_TEST_TARGET` environment variable to execute the test for another target.\n \n+Note that installing Miri like this will \"take away\" Miri management from `rustup`.\n+If you want to later go back to a rustup-installed Miri, run `rustup update`.\n+\n ### Using a modified standard library\n \n Miri re-builds the standard library into a custom sysroot, so it is fairly easy\n@@ -214,7 +217,7 @@ for changes in rustc. In both cases, `rustc-version` needs updating.\n \n To update the `rustc-version` file and install the latest rustc, you can run:\n ```\n-./rustup-toolchain HEAD\n+./miri toolchain HEAD\n ```\n \n Now edit Miri until `./miri test` passes, and submit a PR. Generally, it is\n@@ -290,16 +293,14 @@ cargo run --release -p josh-proxy -- --local=$(pwd)/local --remote=https://githu\n \n ### Importing changes from the rustc repo\n \n+Josh needs to be running, as described above.\n We assume we start on an up-to-date master branch in the Miri repo.\n \n ```sh\n-# Fetch rustc side of the history. Takes ca 5 min the first time.\n-# Do NOT change that commit ID, it needs to be exactly this!\n-git fetch http://localhost:8000/rust-lang/rust.git:at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri.git master\n-# Include that history into ours.\n-git merge FETCH_HEAD -m \"merge rustc history\"\n+# Fetch and merge rustc side of the history. Takes ca 5 min the first time.\n+./miri rustc-pull\n # Update toolchain reference and apply formatting.\n-./rustup-toolchain HEAD && ./miri fmt\n+./miri toolchain HEAD && ./miri fmt\n git commit -am \"rustup\"\n ```\n \n@@ -310,16 +311,15 @@ needed.\n \n ### Exporting changes to the rustc repo\n \n-We will use the josh proxy to push to your fork of rustc. You need to make sure\n-that the master branch of your fork is up-to-date. Also make sure that there\n-exists no branch called `miri` in your fork. Then run the following in the Miri\n-repo, assuming we are on an up-to-date master branch:\n+Josh needs to be running, as described above. We will use the josh proxy to push\n+to your fork of rustc. Run the following in the Miri repo, assuming we are on an\n+up-to-date master branch:\n \n ```sh\n # Push the Miri changes to your rustc fork (substitute your github handle for YOUR_NAME).\n-# Do NOT change that commit ID, it needs to be exactly this!\n-git push http://localhost:8000/YOUR_NAME/rust.git:at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri.git -o base=master HEAD:miri\n+./miri rustc-push YOUR_NAME miri\n ```\n \n-This will create a new branch in your fork, and the output should include a link\n-to create a rustc PR that will integrate those changes into the main repository.\n+This will create a new branch called 'miri' in your fork, and the output should\n+include a link to create a rustc PR that will integrate those changes into the\n+main repository."}, {"sha": "1185525f6865c33cd3a3d8a3d2a2731c45209e92", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -374,14 +374,15 @@ to Miri failing to detect cases of undefined behavior in a program.\n   application instead of raising an error within the context of Miri (and halting\n   execution). Note that code might not expect these operations to ever panic, so\n   this flag can lead to strange (mis)behavior.\n-* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n+* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into *all* fields.\n   This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n   and in particular, they are protected when passed as function arguments.\n+  (The default is to recurse only in cases where rustc would actually emit a `noalias` attribute.)\n * `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n   fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n-  recurses (the default), `scalar` means it only recurses for types where we would also emit\n+  recurses, `scalar` (the default) means it only recurses for types where we would also emit\n   `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n-  scalars).\n+  scalars). Setting this to `none` is **unsound**.\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to\n   `0` disables the garbage collector, which causes some programs to have explosive memory usage\n@@ -419,9 +420,9 @@ Some native rustc `-Z` flags are also very relevant for Miri:\n \n Moreover, Miri recognizes some environment variables:\n \n-* `MIRI_AUTO_OPS` indicates whether the automatic execution of rustfmt, clippy and rustup-toolchain\n-  should be skipped. If it is set to any value, they are skipped. This is used for avoiding\n-  infinite recursion in `./miri` and to allow automated IDE actions to avoid the auto ops.\n+* `MIRI_AUTO_OPS` indicates whether the automatic execution of rustfmt, clippy and toolchain setup\n+  should be skipped. If it is set to any value, they are skipped. This is used for avoiding infinite\n+  recursion in `./miri` and to allow automated IDE actions to avoid the auto ops.\n * `MIRI_LOG`, `MIRI_BACKTRACE` control logging and backtrace printing during\n   Miri executions, also [see \"Testing the Miri driver\" in `CONTRIBUTING.md`][testing-miri].\n * `MIRIFLAGS` (recognized by `cargo miri` and the test suite) defines extra"}, {"sha": "df36041c75ed32f5af95b6a47907afc38fbfa7d6", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -528,7 +528,7 @@ pub fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: Runner\n     cmd.args(binary_args);\n \n     // Make sure we use the build-time working directory for interpreting Miri/rustc arguments.\n-    // But then we need to switch to the run-time one, which we instruct Miri do do by setting `MIRI_CWD`.\n+    // But then we need to switch to the run-time one, which we instruct Miri to do by setting `MIRI_CWD`.\n     cmd.current_dir(info.current_dir);\n     cmd.env(\"MIRI_CWD\", env::current_dir().unwrap());\n "}, {"sha": "f0986bfb1cdbe847216bff42cd684ee19924c745", "filename": "src/tools/miri/miri", "status": "modified", "additions": 125, "deletions": 31, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -42,6 +42,22 @@ many different seeds.\n Runs the benchmarks from bench-cargo-miri in hyperfine. hyperfine needs to be installed.\n <benches> can explicitly list the benchmarks to run; by default, all of them are run.\n \n+./miri rustc-pull:\n+Pull and merge Miri changes from the rustc repo.\n+\n+./miri rustc-push <github user> <branch>:\n+Push Miri changes back to the rustc repo. This will update the 'master' branch\n+in the Rust fork of the given user to upstream. It will also pull a copy of the\n+rustc history into the Miri repo, unless you set the RUSTC_GIT env var to an\n+existing clone of the rustc repo.\n+\n+./miri toolchain <commit> <flags>:\n+Update and activate the rustup toolchain 'miri'. If no commit is given, updates\n+to the commit given in the `rust-version` file. If the commit is `HEAD`, updates\n+to the latest upstream rustc commit.\n+`rustup-toolchain-install-master` must be installed for this to work. Any extra\n+flags are passed to `rustup-toolchain-install-master`.\n+\n   ENVIRONMENT VARIABLES\n \n MIRI_SYSROOT:\n@@ -52,37 +68,98 @@ Pass extra flags to all cargo invocations. (Ignored by `./miri cargo`.)\n EOF\n )\n \n-## We need to know where we are.\n+## We need to know which command to run and some global constants.\n+COMMAND=\"$1\"\n+if [ -z \"$COMMAND\" ]; then\n+    echo \"$USAGE\"\n+    exit 1\n+fi\n+shift\n # macOS does not have a useful readlink/realpath so we have to use Python instead...\n MIRIDIR=$(python3 -c 'import os, sys; print(os.path.dirname(os.path.realpath(sys.argv[1])))' \"$0\")\n+# Used for rustc syncs.\n+JOSH_FILTER=\":at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri\"\n+# Needed for `./miri bench`.\n+TOOLCHAIN=$(cd \"$MIRIDIR\"; rustup show active-toolchain | head -n 1 | cut -d ' ' -f 1)\n \n-## Run the auto-things.\n-if [ -z \"$MIRI_AUTO_OPS\" ]; then\n-    export MIRI_AUTO_OPS=42\n-\n-    # Run this first, so that the toolchain doesn't change after\n-    # other code has run.\n-    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-toolchain\" ] ; then\n-        (cd \"$MIRIDIR\" && ./rustup-toolchain)\n+## Early commands, that don't do auto-things and don't want the environment-altering things happening below.\n+case \"$COMMAND\" in\n+toolchain)\n+    cd \"$MIRIDIR\"\n+    # Make sure rustup-toolchain-install-master is installed.\n+    if ! which rustup-toolchain-install-master >/dev/null; then\n+        echo \"Please install rustup-toolchain-install-master by running 'cargo install rustup-toolchain-install-master'\"\n+        exit 1\n     fi\n-\n-    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-fmt\" ] ; then\n-        $0 fmt\n+    # Determine new commit.\n+    if [[ \"$1\" == \"\" ]]; then\n+        NEW_COMMIT=$(cat rust-version)\n+    elif [[ \"$1\" == \"HEAD\" ]]; then\n+        NEW_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n+    else\n+        NEW_COMMIT=\"$1\"\n     fi\n-\n-    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-clippy\" ] ; then\n-        $0 clippy -- -D warnings\n+    echo \"$NEW_COMMIT\" > rust-version\n+    shift || true # don't fail if shifting fails because no commit was given\n+    # Check if we already are at that commit.\n+    CUR_COMMIT=$(rustc +miri --version -v 2>/dev/null | grep \"^commit-hash: \" | cut -d \" \" -f 2)\n+    if [[ \"$CUR_COMMIT\" == \"$NEW_COMMIT\" ]]; then\n+        echo \"miri toolchain is already at commit $CUR_COMMIT.\"\n+        rustup override set miri\n+        exit 0\n     fi\n-fi\n-\n-## Determine command and toolchain.\n-COMMAND=\"$1\"\n-[ $# -gt 0 ] && shift\n-# Doing this *after* auto-toolchain logic above, since that might change the toolchain.\n-TOOLCHAIN=$(cd \"$MIRIDIR\"; rustup show active-toolchain | head -n 1 | cut -d ' ' -f 1)\n-\n-## Handle some commands early, since they should *not* alter the environment.\n-case \"$COMMAND\" in\n+    # Install and setup new toolchain.\n+    rustup toolchain uninstall miri\n+    rustup-toolchain-install-master -n miri -c cargo -c rust-src -c rustc-dev -c llvm-tools -c rustfmt -c clippy \"$@\" -- \"$NEW_COMMIT\"\n+    rustup override set miri\n+    # Cleanup.\n+    cargo clean\n+    # Call 'cargo metadata' on the sources in case that changes the lockfile\n+    # (which fails under some setups when it is done from inside vscode).\n+    cargo metadata --format-version 1 --manifest-path \"$(rustc --print sysroot)/lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml\" >/dev/null\n+    # Done!\n+    exit 0\n+    ;;\n+rustc-pull)\n+    cd \"$MIRIDIR\"\n+    git fetch http://localhost:8000/rust-lang/rust.git$JOSH_FILTER.git master\n+    git merge FETCH_HEAD --no-ff -m \"Merge from rustc\"\n+    exit 0\n+    ;;\n+rustc-push)\n+    USER=\"$1\"\n+    BRANCH=\"$2\"\n+    if [ -z \"$USER\" ] || [ -z \"$BRANCH\" ]; then\n+        echo \"Usage: $0 rustc-push <github user> <branch>\"\n+        exit 1\n+    fi\n+    if [ -n \"$RUSTC_GIT\" ]; then\n+        # Use an existing fork for the branch updates.\n+        cd \"$RUSTC_GIT\"\n+    else\n+        # Do this in the local Miri repo.\n+        echo \"This will pull a copy of the rust-lang/rust history into this Miri checkout, growing it by about 1GB.\"\n+        read -r -p \"To avoid that, abort now and set the RUSTC_GIT environment variable to an existing rustc checkout. Proceed? [y/N] \"\n+        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n+            exit 1\n+        fi\n+        cd \"$MIRIDIR\"\n+    fi\n+    # Prepare the branches. For reliable pushing we need to push to a non-existent branch\n+    # and set `-o base` to a branch that holds current rustc master.\n+    echo \"Preparing $USER/rust...\"\n+    if git fetch https://github.com/$USER/rust $BRANCH &>/dev/null; then\n+        echo \"The '$BRANCH' seems to already exist in $USER/rust. Please delete it and try again.\"\n+        exit 1\n+    fi\n+    git fetch https://github.com/rust-lang/rust master\n+    git push https://github.com/$USER/rust FETCH_HEAD:master\n+    # Do the actual push.\n+    cd \"$MIRIDIR\"\n+    echo \"Pushing Miri changes...\"\n+    git push http://localhost:8000/$USER/rust.git$JOSH_FILTER.git HEAD:$BRANCH -o base=master\n+    exit 0\n+    ;;\n many-seeds)\n     for SEED in $({ echo obase=16; seq 0 255; } | bc); do\n         echo \"Trying seed: $SEED\"\n@@ -106,9 +183,29 @@ bench)\n     ;;\n esac\n \n+## Run the auto-things.\n+if [ -z \"$MIRI_AUTO_OPS\" ]; then\n+    export MIRI_AUTO_OPS=42\n+\n+    # Run this first, so that the toolchain doesn't change after\n+    # other code has run.\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-toolchain\" ] ; then\n+        $0 toolchain\n+        # Let's make sure to actually use that toolchain, too.\n+        TOOLCHAIN=miri\n+    fi\n+\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-fmt\" ] ; then\n+        $0 fmt\n+    fi\n+\n+    if [ -f \"$MIRIDIR/.auto-everything\" ] || [ -f \"$MIRIDIR/.auto-clippy\" ] ; then\n+        $0 clippy -- -D warnings\n+    fi\n+fi\n+\n ## Prepare the environment\n # Determine some toolchain properties\n-# export the target so its available in miri\n TARGET=$(rustc +$TOOLCHAIN --version --verbose | grep \"^host:\" | cut -d ' ' -f 2)\n SYSROOT=$(rustc +$TOOLCHAIN --print sysroot)\n LIBDIR=$SYSROOT/lib/rustlib/$TARGET/lib\n@@ -227,10 +324,7 @@ cargo)\n     $CARGO \"$@\"\n     ;;\n *)\n-    if [ -n \"$COMMAND\" ]; then\n-      echo \"Unknown command: $COMMAND\"\n-      echo\n-    fi\n-    echo \"$USAGE\"\n+    echo \"Unknown command: $COMMAND\"\n     exit 1\n+    ;;\n esac"}, {"sha": "13492d183c99996c2a0c100fa8a45d270130c327", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1 +1 @@\n-85d089b41e2a0c0f07ab34f6c5a7c451389f25e6\n+b03502b35d111bef0399a66ab3cc765f0802e8ba"}, {"sha": "d7730f2b06d36a33cceb880461bef5213ff719c3", "filename": "src/tools/miri/rustup-toolchain", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a13809ae51bbe0c4c203ad17e533a083af8e15b9/src%2Ftools%2Fmiri%2Frustup-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a13809ae51bbe0c4c203ad17e533a083af8e15b9/src%2Ftools%2Fmiri%2Frustup-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frustup-toolchain?ref=a13809ae51bbe0c4c203ad17e533a083af8e15b9", "patch": "@@ -1,53 +0,0 @@\n-#!/bin/bash\n-set -e\n-# Manages a rustup toolchain called \"miri\".\n-#\n-# All commands set \"miri\" as the override toolchain for the current directory,\n-# and make the `rust-version` file match that toolchain.\n-#\n-# USAGE:\n-#\n-# ./rustup-toolchain: Update \"miri\" toolchain to match `rust-version` (the known-good version for this commit).\n-#\n-# ./rustup-toolchain HEAD: Update \"miri\" toolchain and `rust-version` file to latest rustc HEAD.\n-#\n-# ./rustup-toolchain $COMMIT: Update \"miri\" toolchain and `rust-version` file to match that commit.\n-#\n-# Any extra parameters are passed to `rustup-toolchain-install-master`.\n-\n-# Make sure rustup-toolchain-install-master is installed.\n-if ! which rustup-toolchain-install-master >/dev/null; then\n-    echo \"Please install rustup-toolchain-install-master by running 'cargo install rustup-toolchain-install-master'\"\n-    exit 1\n-fi\n-\n-# Determine new commit.\n-if [[ \"$1\" == \"\" ]]; then\n-    NEW_COMMIT=$(cat rust-version)\n-elif [[ \"$1\" == \"HEAD\" ]]; then\n-    NEW_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n-else\n-    NEW_COMMIT=\"$1\"\n-fi\n-echo \"$NEW_COMMIT\" > rust-version\n-shift || true # don't fail if shifting fails\n-\n-# Check if we already are at that commit.\n-CUR_COMMIT=$(rustc +miri --version -v 2>/dev/null | grep \"^commit-hash: \" | cut -d \" \" -f 2)\n-if [[ \"$CUR_COMMIT\" == \"$NEW_COMMIT\" ]]; then\n-    echo \"miri toolchain is already at commit $CUR_COMMIT.\"\n-    rustup override set miri\n-    exit 0\n-fi\n-\n-# Install and setup new toolchain.\n-rustup toolchain uninstall miri\n-rustup-toolchain-install-master -n miri -c cargo -c rust-src -c rustc-dev -c llvm-tools -c rustfmt -c clippy \"$@\" -- \"$NEW_COMMIT\"\n-rustup override set miri\n-\n-# Cleanup.\n-cargo clean\n-\n-# Call 'cargo metadata' on the sources in case that changes the lockfile\n-# (which fails under some setups when it is done from inside vscode).\n-cargo metadata --format-version 1 --manifest-path \"$(rustc --print sysroot)/lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml\" >/dev/null"}, {"sha": "eb42cdf80abbeb5de883a9dc009948fc5777f2df", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 55, "deletions": 31, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -3,7 +3,7 @@ use std::num::NonZeroU32;\n \n use rustc_index::vec::Idx;\n \n-use super::sync::EvalContextExtPriv;\n+use super::sync::EvalContextExtPriv as _;\n use super::thread::MachineCallback;\n use super::vector_clock::VClock;\n use crate::*;\n@@ -52,6 +52,43 @@ impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Synchronize with the previous initialization attempt of an InitOnce.\n+    #[inline]\n+    fn init_once_observe_attempt(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(\n+                &this.machine.threads.sync.init_onces[id].data_race,\n+                current_thread,\n+            );\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_wake_waiter(\n+        &mut self,\n+        id: InitOnceId,\n+        waiter: InitOnceWaiter<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        this.unblock_thread(waiter.thread);\n+\n+        // Call callback, with the woken-up thread as `current`.\n+        this.set_active_thread(waiter.thread);\n+        this.init_once_observe_attempt(id);\n+        waiter.callback.call(this)?;\n+        this.set_active_thread(current_thread);\n+\n+        Ok(())\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_get_or_create_id(\n@@ -141,20 +178,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Wake up everyone.\n         // need to take the queue to avoid having `this` be borrowed multiple times\n         for waiter in std::mem::take(&mut init_once.waiters) {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            // Call callback, with the woken-up thread as `current`.\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n+            this.init_once_wake_waiter(id, waiter)?;\n         }\n \n         Ok(())\n@@ -172,33 +196,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         );\n \n         // Each complete happens-before the end of the wait\n-        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n-        // but the docs don't talk about such details.\n         if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n         }\n \n         // Wake up one waiting thread, so they can go ahead and try to init this.\n         if let Some(waiter) = init_once.waiters.pop_front() {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            // Call callback, with the woken-up thread as `current`.\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n+            this.init_once_wake_waiter(id, waiter)?;\n         } else {\n             // Nobody there to take this, so go back to 'uninit'\n             init_once.status = InitOnceStatus::Uninitialized;\n         }\n \n         Ok(())\n     }\n+\n+    /// Synchronize with the previous completion of an InitOnce.\n+    /// Must only be called after checking that it is complete.\n+    #[inline]\n+    fn init_once_observe_completed(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+\n+        assert_eq!(\n+            this.init_once_status(id),\n+            InitOnceStatus::Complete,\n+            \"observing the completion of incomplete init once\"\n+        );\n+\n+        this.init_once_observe_attempt(id);\n+    }\n }"}, {"sha": "ba5ae852c5a960663d694ca6eb9ca0020047730c", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -116,13 +116,25 @@ struct RwLock {\n \n declare_id!(CondvarId);\n \n+#[derive(Debug, Copy, Clone)]\n+pub enum RwLockMode {\n+    Read,\n+    Write,\n+}\n+\n+#[derive(Debug)]\n+pub enum CondvarLock {\n+    Mutex(MutexId),\n+    RwLock { id: RwLockId, mode: RwLockMode },\n+}\n+\n /// A thread waiting on a conditional variable.\n #[derive(Debug)]\n struct CondvarWaiter {\n     /// The thread that is waiting on this variable.\n     thread: ThreadId,\n-    /// The mutex on which the thread is waiting.\n-    mutex: MutexId,\n+    /// The mutex or rwlock on which the thread is waiting.\n+    lock: CondvarLock,\n }\n \n /// The conditional variable state.\n@@ -569,16 +581,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark that the thread is waiting on the conditional variable.\n-    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, mutex: MutexId) {\n+    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, lock: CondvarLock) {\n         let this = self.eval_context_mut();\n         let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(CondvarWaiter { thread, mutex });\n+        waiters.push_back(CondvarWaiter { thread, lock });\n     }\n \n     /// Wake up some thread (if there is any) sleeping on the conditional\n     /// variable.\n-    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, MutexId)> {\n+    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, CondvarLock)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n@@ -592,7 +604,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n             }\n-            (waiter.thread, waiter.mutex)\n+            (waiter.thread, waiter.lock)\n         })\n     }\n "}, {"sha": "81132db94cf181ff1583031304e4535d47099dbc", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -163,7 +163,7 @@ impl Default for MiriConfig {\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n-            retag_fields: RetagFields::No,\n+            retag_fields: RetagFields::OnlyScalar,\n             external_so_file: None,\n             gc_interval: 10_000,\n             num_cpus: 1,"}, {"sha": "a7275646847e29ed42c09ceede08e0cea1f6ccb7", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -3,6 +3,7 @@ use std::time::SystemTime;\n use rustc_hir::LangItem;\n use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n \n+use crate::concurrency::sync::CondvarLock;\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n \n@@ -696,8 +697,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        if let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        if let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -710,8 +715,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n-        while let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        while let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -729,7 +738,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         Ok(0)\n     }\n@@ -768,7 +777,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;"}, {"sha": "e16749c986b168cfb6f77a350e69783271126d12", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -273,6 +273,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.InitOnceComplete(ptr, flags, context)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"SleepConditionVariableSRW\" => {\n+                let [condvar, lock, timeout, flags] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                let result = this.SleepConditionVariableSRW(condvar, lock, timeout, flags, dest)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"WakeConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeConditionVariable(condvar)?;\n+            }\n+            \"WakeAllConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeAllConditionVariable(condvar)?;\n+            }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {"}, {"sha": "8f414d98dba5f70a979aa132a0caac8bbdd979c5", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 165, "deletions": 2, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -3,11 +3,45 @@ use std::time::Duration;\n use rustc_target::abi::Size;\n \n use crate::concurrency::init_once::InitOnceStatus;\n+use crate::concurrency::sync::{CondvarLock, RwLockMode};\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n+const CONDVAR_ID_OFFSET: u64 = 0;\n+\n+impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Try to reacquire the lock associated with the condition variable after we\n+    /// were signaled.\n+    fn reacquire_cond_lock(\n+        &mut self,\n+        thread: ThreadId,\n+        lock: RwLockId,\n+        mode: RwLockMode,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.unblock_thread(thread);\n+\n+        match mode {\n+            RwLockMode::Read =>\n+                if this.rwlock_is_write_locked(lock) {\n+                    this.rwlock_enqueue_and_block_reader(lock, thread);\n+                } else {\n+                    this.rwlock_reader_lock(lock, thread);\n+                },\n+            RwLockMode::Write =>\n+                if this.rwlock_is_locked(lock) {\n+                    this.rwlock_enqueue_and_block_writer(lock, thread);\n+                } else {\n+                    this.rwlock_writer_lock(lock, thread);\n+                },\n+        }\n+\n+        Ok(())\n+    }\n+}\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n #[allow(non_snake_case)]\n@@ -177,8 +211,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     Box::new(Callback { init_once_id: id, pending_place }),\n                 )\n             }\n-            InitOnceStatus::Complete =>\n-                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+            InitOnceStatus::Complete => {\n+                this.init_once_observe_completed(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?;\n+            }\n         }\n \n         // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n@@ -325,4 +361,131 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn SleepConditionVariableSRW(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+        let lock_id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(this.machine.clock.now().checked_add(duration).unwrap())\n+        };\n+\n+        let shared_mode = 0x1; // CONDITION_VARIABLE_LOCKMODE_SHARED is not in std\n+        let mode = if flags == 0 {\n+            RwLockMode::Write\n+        } else if flags == shared_mode {\n+            RwLockMode::Read\n+        } else {\n+            throw_unsup_format!(\"unsupported `Flags` {flags} in `SleepConditionVariableSRW`\");\n+        };\n+\n+        let active_thread = this.get_active_thread();\n+\n+        let was_locked = match mode {\n+            RwLockMode::Read => this.rwlock_reader_unlock(lock_id, active_thread),\n+            RwLockMode::Write => this.rwlock_writer_unlock(lock_id, active_thread),\n+        };\n+\n+        if !was_locked {\n+            throw_ub_format!(\n+                \"calling SleepConditionVariableSRW with an SRWLock that is not locked by the current thread\"\n+            );\n+        }\n+\n+        this.block_thread(active_thread);\n+        this.condvar_wait(condvar_id, active_thread, CondvarLock::RwLock { id: lock_id, mode });\n+\n+        if let Some(timeout_time) = timeout_time {\n+            struct Callback<'tcx> {\n+                thread: ThreadId,\n+                condvar_id: CondvarId,\n+                lock_id: RwLockId,\n+                mode: RwLockMode,\n+                dest: PlaceTy<'tcx, Provenance>,\n+            }\n+\n+            impl<'tcx> VisitTags for Callback<'tcx> {\n+                fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    let Callback { thread: _, condvar_id: _, lock_id: _, mode: _, dest } = self;\n+                    dest.visit_tags(visit);\n+                }\n+            }\n+\n+            impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                    this.reacquire_cond_lock(self.thread, self.lock_id, self.mode)?;\n+\n+                    this.condvar_remove_waiter(self.condvar_id, self.thread);\n+\n+                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                    this.set_last_error(error_timeout)?;\n+                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &self.dest)?;\n+                    Ok(())\n+                }\n+            }\n+\n+            this.register_timeout_callback(\n+                active_thread,\n+                Time::Monotonic(timeout_time),\n+                Box::new(Callback {\n+                    thread: active_thread,\n+                    condvar_id,\n+                    lock_id,\n+                    mode,\n+                    dest: dest.clone(),\n+                }),\n+            );\n+        }\n+\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n+\n+    fn WakeConditionVariable(&mut self, condvar_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        if let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn WakeAllConditionVariable(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        while let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "7f18e5dbae052ebbeb7406964173c08ebf1e33ea", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -252,7 +252,7 @@ pub fn err_sb_ub<'tcx>(\n /// We need to make at least the following things true:\n ///\n /// U1: After creating a `Uniq`, it is at the top.\n-/// U2: If the top is `Uniq`, accesses must be through that `Uniq` or remove it it.\n+/// U2: If the top is `Uniq`, accesses must be through that `Uniq` or remove it.\n /// U3: If an access happens with a `Uniq`, it requires the `Uniq` to be in the stack.\n ///\n /// F1: After creating a `&`, the parts outside `UnsafeCell` have our `SharedReadOnly` on top."}, {"sha": "cc774500a3c69d69351c32d542743fe8f1f81730", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,4 +1,3 @@\n-//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32, i32);\n "}, {"sha": "1aa6e240e30f1699f5122d42d0b7a281092b7354", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,4 +1,3 @@\n-//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32);\n "}, {"sha": "5a9dc6afba8da9e85617915b52a0ecf2729eb232", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,16 +1,15 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in an `Option`.\n-// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 }; // let-bind to avoid 2phase\n     let ret = Some(ret);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+        Some(_x) => {}\n         None => {}\n     }\n }"}, {"sha": "c0ff35ebcde307aa39834ff5a11314ee51345033", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,26 +1,31 @@\n error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n-LL |         Some(_x) => {}\n-   |              ^^\n-   |              |\n-   |              trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n+LL |     ret\n+   |     ^^^\n+   |     |\n+   |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let ret = Some(ret);\n-   |                    ^^^\n+   |               ^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_mut_option.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_mut_option.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_mut_option.rs:LL:CC\n+  --> $DIR/return_invalid_mut_option.rs:LL:CC\n+   |\n+LL |     match foo(&mut (1, 2)) {\n+   |           ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "8fe7f15cab0c12c2f7b5df8d71fe90e059c6c26b", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,12 +1,11 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.\n-// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0;\n }"}, {"sha": "9abf43c29f08fb3e44601d09e248eeff7288fe9c", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n-LL |     foo(&mut (1, 2)).0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     ret\n+   |     ^^^\n    |     |\n    |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n    |     this error occurs as part of retag at ALLOC[0x4..0x8]\n@@ -13,14 +13,19 @@ help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &mut (*xraw).1 },);\n-   |                         ^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+  --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n+   |\n+LL |     foo(&mut (1, 2)).0;\n+   |     ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "094ce33b9c1f73c9540a20e66417ed8fcc990f1f", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,15 +1,14 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in an `Option`.\n-// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &(*xraw).1 });\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+        Some(_x) => {}\n         None => {}\n     }\n }"}, {"sha": "6066bf89f5d095806cab091431260eebca461801", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,26 +1,31 @@\n error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n-LL |         Some(_x) => {}\n-   |              ^^\n-   |              |\n-   |              trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n+LL |     ret\n+   |     ^^^\n+   |     |\n+   |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     let ret = Some(unsafe { &(*xraw).1 });\n-   |                             ^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_shr_option.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_shr_option.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_shr_option.rs:LL:CC\n+  --> $DIR/return_invalid_shr_option.rs:LL:CC\n+   |\n+LL |     match foo(&mut (1, 2)) {\n+   |           ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "d0fd53e06aa2624fa88ee8b3f4f85de319e1632c", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,12 +1,11 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in a tuple.\n-// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &(*xraw).1 },);\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0;\n }"}, {"sha": "52d365246a74441852bee7c4f2912844c3933159", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n-LL |     foo(&mut (1, 2)).0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     ret\n+   |     ^^^\n    |     |\n    |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n    |     this error occurs as part of retag at ALLOC[0x4..0x8]\n@@ -13,14 +13,19 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &(*xraw).1 },);\n-   |                         ^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+  --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n+   |\n+LL |     foo(&mut (1, 2)).0;\n+   |     ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "19ea6c130bdd8ceb980076b42b5d45736a4c4a20", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -230,20 +230,8 @@ fn main() {\n     check_once();\n     park_timeout();\n     park_unpark();\n-\n-    if !cfg!(windows) {\n-        // ignore-target-windows: Condvars on Windows are not supported yet\n-        check_barriers();\n-        check_conditional_variables_notify_one();\n-        check_conditional_variables_timed_wait_timeout();\n-        check_conditional_variables_timed_wait_notimeout();\n-    } else {\n-        // We need to fake the same output...\n-        for _ in 0..10 {\n-            println!(\"before wait\");\n-        }\n-        for _ in 0..10 {\n-            println!(\"after wait\");\n-        }\n-    }\n+    check_barriers();\n+    check_conditional_variables_notify_one();\n+    check_conditional_variables_timed_wait_timeout();\n+    check_conditional_variables_timed_wait_notimeout();\n }"}, {"sha": "c6cff038f81e0eafa5b993d0d0ab84ddc132f9e4", "filename": "src/tools/miri/tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n "}, {"sha": "d89320bfe59718988be92feab3da341baadea0ca", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -0,0 +1,227 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::ffi::c_void;\n+use std::ptr::null_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr<T>(*mut T);\n+\n+unsafe impl<T> Send for SendPtr<T> {}\n+\n+extern \"system\" {\n+    fn SleepConditionVariableSRW(\n+        condvar: *mut *mut c_void,\n+        lock: *mut *mut c_void,\n+        timeout: u32,\n+        flags: u32,\n+    ) -> i32;\n+    fn WakeAllConditionVariable(condvar: *mut *mut c_void);\n+\n+    fn AcquireSRWLockExclusive(lock: *mut *mut c_void);\n+    fn AcquireSRWLockShared(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockExclusive(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockShared(lock: *mut *mut c_void);\n+}\n+\n+const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;\n+const INFINITE: u32 = u32::MAX;\n+\n+/// threads should be able to reacquire the lock while it is locked by multiple other threads in shared mode\n+fn all_shared() {\n+    println!(\"all_shared\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+\n+    // waiters\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    // readers\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// reacquiring a lock should wait until the lock is not exclusively locked\n+fn shared_sleep_and_exclusive_lock() {\n+    println!(\"shared_sleep_and_exclusive_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut waiters = Vec::with_capacity(5);\n+    for i in 0..5 {\n+        waiters.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"shared waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"shared waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    unsafe {\n+        AcquireSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main locked\");\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    // waiters are now waiting for the lock to be unlocked\n+    thread::yield_now();\n+\n+    unsafe {\n+        ReleaseSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main unlocked\");\n+\n+    for handle in waiters {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// threads reacquiring locks should wait for all locks to be released first\n+fn exclusive_sleep_and_shared_lock() {\n+    println!(\"exclusive_sleep_and_shared_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockExclusive(lock_ptr.0);\n+            }\n+\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe { SleepConditionVariableSRW(condvar_ptr.0, lock_ptr.0, INFINITE, 0) };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // switch to next waiter or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockExclusive(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} unlocked\");\n+        }));\n+    }\n+\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    all_shared();\n+    shared_sleep_and_exclusive_lock();\n+    exclusive_sleep_and_shared_lock();\n+}"}, {"sha": "918b54668f201cfafb6aab0df18cdb9041b8bf9f", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.stdout", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -0,0 +1,60 @@\n+all_shared\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 4 reacquired lock\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+shared_sleep_and_exclusive_lock\n+shared waiter 0 locked\n+shared waiter 1 locked\n+shared waiter 2 locked\n+shared waiter 3 locked\n+shared waiter 4 locked\n+main locked\n+main unlocked\n+shared waiter 0 reacquired lock\n+shared waiter 1 reacquired lock\n+shared waiter 2 reacquired lock\n+shared waiter 3 reacquired lock\n+shared waiter 4 reacquired lock\n+exclusive_sleep_and_shared_lock\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 0 unlocked\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 1 unlocked\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 2 unlocked\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 3 unlocked\n+exclusive waiter 4 reacquired lock\n+exclusive waiter 4 unlocked"}, {"sha": "4eb88379620597dd28a36ef8ddfb60571b534a03", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -131,8 +131,46 @@ fn retry_on_fail() {\n     waiter2.join().unwrap();\n }\n \n+fn no_data_race_after_complete() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let mut place = 0;\n+    let place_ptr = SendPtr(&mut place);\n+\n+    let reader = thread::spawn(move || unsafe {\n+        let mut pending = 0;\n+\n+        // this doesn't block because reader only executes after `InitOnceComplete` is called\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+        // this should not data race\n+        place_ptr.0.read()\n+    });\n+\n+    unsafe {\n+        // this should not data race\n+        place_ptr.0.write(1);\n+    }\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+    }\n+\n+    // run reader (without preemption, it has not taken a step yet)\n+    assert_eq!(reader.join().unwrap(), 1);\n+}\n+\n fn main() {\n     single_thread();\n     block_until_complete();\n     retry_on_fail();\n+    no_data_race_after_complete();\n }"}, {"sha": "776bc2057f3501fd9d1773b717bce1e426b8407b", "filename": "src/tools/miri/tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "48fc8e8668ce041a37a9754ce3d706a04f137674", "filename": "src/tools/miri/tests/pass/stacked-borrows/no_field_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=none\n+\n+struct Newtype<'a>(&'a mut i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that we do *not* retag the fields of `Newtype`.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "296339e73845576ccc72d3c8912ac0984f7fc320", "filename": "src/tools/miri/tests/pass/stacked-borrows/stack-printing.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout?ref=e8bc6e132820f24909f4ef536f84e0aa3ddf2d2b", "patch": "@@ -1,6 +1,6 @@\n 0..1: [ SharedReadWrite<TAG> ]\n 0..1: [ SharedReadWrite<TAG> ]\n 0..1: [ SharedReadWrite<TAG> ]\n-0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n-0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]\n 0..1: [ unknown-bottom(..<TAG>) ]"}]}