{"sha": "9580a7115d2d75514f0b329a29fafaa3796bd950", "node_id": "C_kwDOAAsO6NoAKDk1ODBhNzExNWQyZDc1NTE0ZjBiMzI5YTI5ZmFmYWEzNzk2YmQ5NTA", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-03-14T16:11:58Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-03-14T16:25:17Z"}, "message": "debuginfo: Refactor debuginfo generation for types -- Address review comments.", "tree": {"sha": "d3939b8140e302c4bd013ef5f40da3f79ea0744a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3939b8140e302c4bd013ef5f40da3f79ea0744a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9580a7115d2d75514f0b329a29fafaa3796bd950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9580a7115d2d75514f0b329a29fafaa3796bd950", "html_url": "https://github.com/rust-lang/rust/commit/9580a7115d2d75514f0b329a29fafaa3796bd950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9580a7115d2d75514f0b329a29fafaa3796bd950/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19707b0ff2c0beb80f77eaa7274f4588a506309d", "url": "https://api.github.com/repos/rust-lang/rust/commits/19707b0ff2c0beb80f77eaa7274f4588a506309d", "html_url": "https://github.com/rust-lang/rust/commit/19707b0ff2c0beb80f77eaa7274f4588a506309d"}], "stats": {"total": 44, "additions": 25, "deletions": 19}, "files": [{"sha": "f02c7b2d2e11ab8b39b47f97593b2c17f0351dbc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=9580a7115d2d75514f0b329a29fafaa3796bd950", "patch": "@@ -359,7 +359,10 @@ fn build_dyn_type_di_node<'ll, 'tcx>(\n             NO_GENERICS,\n         )\n     } else {\n-        bug!(\"Only ty::Dynamic is valid for dyn_type_metadata(). Found {:?} instead.\", dyn_type)\n+        bug!(\n+            \"Only ty::Dynamic is valid for build_dyn_type_di_node(). Found {:?} instead.\",\n+            dyn_type\n+        )\n     }\n }\n \n@@ -390,15 +393,15 @@ fn build_slice_type_di_node<'ll, 'tcx>(\n         ty::Str => cx.tcx.types.u8,\n         _ => {\n             bug!(\n-                \"Only ty::Slice is valid for slice_type_metadata(). Found {:?} instead.\",\n+                \"Only ty::Slice is valid for build_slice_type_di_node(). Found {:?} instead.\",\n                 slice_type\n             )\n         }\n     };\n \n-    let element_type_metadata = type_di_node(cx, element_type);\n+    let element_type_di_node = type_di_node(cx, element_type);\n     return_if_di_node_created_in_meantime!(cx, unique_type_id);\n-    DINodeCreationResult { di_node: element_type_metadata, already_stored_in_typemap: false }\n+    DINodeCreationResult { di_node: element_type_di_node, already_stored_in_typemap: false }\n }\n \n /// Get the debuginfo node for the given type.\n@@ -445,7 +448,7 @@ pub fn type_di_node<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll D\n         ty::Tuple(_) => build_tuple_type_di_node(cx, unique_type_id),\n         // Type parameters from polymorphized functions.\n         ty::Param(_) => build_param_type_di_node(cx, t),\n-        _ => bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t),\n+        _ => bug!(\"debuginfo: unexpected type in type_di_node(): {:?}\", t),\n     };\n \n     {\n@@ -456,7 +459,7 @@ pub fn type_di_node<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll D\n                     Some(di_node) => di_node,\n                     None => {\n                         bug!(\n-                            \"expected type di_node for unique \\\n+                            \"expected type debuginfo node for unique \\\n                                type ID '{:?}' to already be in \\\n                                the `debuginfo::TypeMap` but it \\\n                                was not.\",\n@@ -754,7 +757,7 @@ pub fn build_compile_unit_di_node<'ll, 'tcx>(\n     name_in_debuginfo.push(\"@\");\n     name_in_debuginfo.push(codegen_unit_name);\n \n-    debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n+    debug!(\"build_compile_unit_di_node: {:?}\", name_in_debuginfo);\n     let rustc_producer =\n         format!(\"rustc version {}\", option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),);\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n@@ -1003,7 +1006,7 @@ fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) ->\n fn build_upvar_field_di_nodes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     closure_or_generator_ty: Ty<'tcx>,\n-    closure_or_generator_metadata: &'ll DIType,\n+    closure_or_generator_di_node: &'ll DIType,\n ) -> SmallVec<&'ll DIType> {\n     let (&def_id, up_var_tys) = match closure_or_generator_ty.kind() {\n         ty::Generator(def_id, substs, _) => {\n@@ -1016,7 +1019,7 @@ fn build_upvar_field_di_nodes<'ll, 'tcx>(\n         }\n         _ => {\n             bug!(\n-                \"new_upvar_member_descriptions() called with non-closure-or-generator-type: {:?}\",\n+                \"build_upvar_field_di_nodes() called with non-closure-or-generator-type: {:?}\",\n                 closure_or_generator_ty\n             )\n         }\n@@ -1038,7 +1041,7 @@ fn build_upvar_field_di_nodes<'ll, 'tcx>(\n         .map(|(index, (up_var_ty, capture_name))| {\n             build_field_di_node(\n                 cx,\n-                closure_or_generator_metadata,\n+                closure_or_generator_di_node,\n                 capture_name,\n                 cx.size_and_align_of(up_var_ty),\n                 layout.fields.offset(index),\n@@ -1074,14 +1077,14 @@ fn build_tuple_type_di_node<'ll, 'tcx>(\n             DIFlags::FlagZero,\n         ),\n         // Fields:\n-        |cx, tuple_metadata| {\n+        |cx, tuple_di_node| {\n             component_types\n                 .into_iter()\n                 .enumerate()\n                 .map(|(index, component_type)| {\n                     build_field_di_node(\n                         cx,\n-                        tuple_metadata,\n+                        tuple_di_node,\n                         &tuple_field_name(index),\n                         cx.size_and_align_of(component_type),\n                         tuple_type_and_layout.fields.offset(index),\n@@ -1095,14 +1098,14 @@ fn build_tuple_type_di_node<'ll, 'tcx>(\n     )\n }\n \n-/// Builds the debufinfo node for a closure environment.\n+/// Builds the debuginfo node for a closure environment.\n fn build_closure_env_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId<'tcx>,\n ) -> DINodeCreationResult<'ll> {\n     let closure_env_type = unique_type_id.expect_ty();\n     let &ty::Closure(def_id, _substs) = closure_env_type.kind() else {\n-        bug!(\"new_closure_env_metadata() called with non-closure-type: {:?}\", closure_env_type)\n+        bug!(\"build_closure_env_di_node() called with non-closure-type: {:?}\", closure_env_type)\n     };\n     let containing_scope = get_namespace_for_item(cx, def_id);\n     let type_name = compute_debuginfo_type_name(cx.tcx, closure_env_type, false);\n@@ -1225,15 +1228,15 @@ fn build_generic_type_param_di_nodes<'ll, 'tcx>(\n                     if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type =\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                        let actual_type_metadata = type_di_node(cx, actual_type);\n+                        let actual_type_di_node = type_di_node(cx, actual_type);\n                         let name = name.as_str();\n                         Some(unsafe {\n                             llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                 DIB(cx),\n                                 None,\n                                 name.as_ptr().cast(),\n                                 name.len(),\n-                                actual_type_metadata,\n+                                actual_type_di_node,\n                             )\n                         })\n                     } else {"}, {"sha": "1eafa9501c47f928ff2422410be16baf7c001415", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=9580a7115d2d75514f0b329a29fafaa3796bd950", "patch": "@@ -126,6 +126,8 @@ fn tag_base_type<'ll, 'tcx>(\n                     // If the niche is the NULL value of a reference, then `discr_enum_ty` will be\n                     // a RawPtr. CodeView doesn't know what to do with enums whose base type is a\n                     // pointer so we fix this up to just be `usize`.\n+                    // DWARF might be able to deal with this but with an integer type we are on\n+                    // the safe side there too.\n                     cx.data_layout().ptr_sized_integer()\n                 }\n             }"}, {"sha": "8ce44ada887735489e718116d736dd9cdb1852c8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=9580a7115d2d75514f0b329a29fafaa3796bd950", "patch": "@@ -145,7 +145,6 @@ impl<'ll> DINodeCreationResult<'ll> {\n     }\n }\n \n-#[allow(dead_code)]\n #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n pub enum Stub<'ll> {\n     Struct,\n@@ -233,7 +232,7 @@ pub(super) fn stub<'ll, 'tcx>(\n /// This function enables creating debuginfo nodes that can recursively refer to themselves.\n /// It will first insert the given stub into the type map and only then execute the `members`\n /// and `generics` closures passed in. These closures have access to the stub so they can\n-/// directly attach fields to them. If build the type of a field transitively refers back\n+/// directly attach fields to them. If the type of a field transitively refers back\n /// to the type currently being built, the stub will already be found in the type map,\n /// which effectively breaks the recursion cycle.\n pub(super) fn build_type_with_children<'ll, 'tcx>("}, {"sha": "fc2921fbd3fa03a5fc28560ad35896fc30dce541", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9580a7115d2d75514f0b329a29fafaa3796bd950/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=9580a7115d2d75514f0b329a29fafaa3796bd950", "patch": "@@ -364,7 +364,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // \"{async_fn_env#0}<T1, T2, ...>\", etc.\n             // In the case of cpp-like debuginfo, the name additionally gets wrapped inside of\n             // an artificial `enum$<>` type, as defined in msvc_enum_fallback().\n-            if cpp_like_debuginfo && matches!(t.kind(), ty::Generator(..)) {\n+            if cpp_like_debuginfo && t.is_generator() {\n                 let ty_and_layout = tcx.layout_of(ParamEnv::reveal_all().and(t)).unwrap();\n                 msvc_enum_fallback(\n                     tcx,"}, {"sha": "6b27d1ecbf550038f2846a3d1e2c4c289d1f27ff", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9580a7115d2d75514f0b329a29fafaa3796bd950/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9580a7115d2d75514f0b329a29fafaa3796bd950/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=9580a7115d2d75514f0b329a29fafaa3796bd950", "patch": "@@ -669,6 +669,8 @@ impl<'test> TestCx<'test> {\n         // type is present in the PDB, which is very confusing.\n         // Therefore we delete any existing PDB file before compiling the test\n         // case.\n+        // FIXME: If can reliably detect that MSVC's link.exe is used, then\n+        //        passing `/INCREMENTAL:NO` might be a cleaner way to do this.\n         let pdb_file = exe_file.with_extension(\".pdb\");\n         if pdb_file.exists() {\n             std::fs::remove_file(pdb_file).unwrap();"}]}