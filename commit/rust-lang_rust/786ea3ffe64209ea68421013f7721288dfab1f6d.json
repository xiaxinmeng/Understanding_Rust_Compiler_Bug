{"sha": "786ea3ffe64209ea68421013f7721288dfab1f6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NmVhM2ZmZTY0MjA5ZWE2ODQyMTAxM2Y3NzIxMjg4ZGZhYjFmNmQ=", "commit": {"author": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@langara.bc.ca", "date": "2013-06-09T06:29:32Z"}, "committer": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@langara.bc.ca", "date": "2013-06-13T00:32:13Z"}, "message": "Prototyped a dynamic library facility interface", "tree": {"sha": "7596dade1f156df944fc9d6a5ec4d2aaa79ee089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7596dade1f156df944fc9d6a5ec4d2aaa79ee089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786ea3ffe64209ea68421013f7721288dfab1f6d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786ea3ffe64209ea68421013f7721288dfab1f6d", "html_url": "https://github.com/rust-lang/rust/commit/786ea3ffe64209ea68421013f7721288dfab1f6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786ea3ffe64209ea68421013f7721288dfab1f6d/comments", "author": null, "committer": null, "parents": [{"sha": "78cddc83a44f04c7252435c9d6fff01b43cb44b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/78cddc83a44f04c7252435c9d6fff01b43cb44b3", "html_url": "https://github.com/rust-lang/rust/commit/78cddc83a44f04c7252435c9d6fff01b43cb44b3"}], "stats": {"total": 207, "additions": 207, "deletions": 0}, "files": [{"sha": "96aba1d2971e8ef23ebae9c8278ecd3ad135623b", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/786ea3ffe64209ea68421013f7721288dfab1f6d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786ea3ffe64209ea68421013f7721288dfab1f6d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=786ea3ffe64209ea68421013f7721288dfab1f6d", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Dynamic library facilities.\n+\n+A simple wrapper over the platforms dynamic library facilities\n+\n+*/\n+use ptr;\n+use cast;\n+use path;\n+use libc;\n+use ops::*;\n+use option::*;\n+use result::*;\n+\n+pub struct DynamicLibrary { priv handle: *libc::c_void }\n+\n+impl Drop for DynamicLibrary {\n+    fn finalize(&self) {\n+        match do dl::check_for_errors_in {\n+            unsafe {\n+                dl::close(self.handle)\n+            }\n+        } {\n+            Ok(()) => { },\n+            Err(str) => fail!(str)\n+        }\n+    }\n+}\n+\n+impl DynamicLibrary {\n+    /// Lazily open a dynamic library. When passed None it gives a\n+    /// handle to the calling process\n+    pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n+        let open_wrapper = |raw_ptr| {\n+            do dl::check_for_errors_in {\n+                unsafe {\n+                    DynamicLibrary { handle: dl::open(raw_ptr) }\n+                }\n+            }\n+        };\n+\n+        match filename {\n+            Some(name) => do name.to_str().as_c_str |raw_name| {\n+                open_wrapper(raw_name)\n+            },\n+            None => open_wrapper(ptr::null())\n+        }\n+    }\n+\n+    /// Access the value at the symbol of the dynamic library\n+    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, ~str> {\n+        // This function should have a lifetime constraint of 'self on\n+        // T but that feature is still unimplemented\n+\n+        do dl::check_for_errors_in {\n+            let symbol_value = do symbol.as_c_str |raw_string| {\n+                dl::symbol(self.handle, raw_string)\n+            };\n+\n+            cast::transmute(symbol_value)\n+        }\n+    }\n+}\n+\n+#[test]\n+priv fn test_loading_cosine () {\n+    // The math library does not need to be loaded since it is already\n+    // statically linked in\n+    let libm = match DynamicLibrary::open(None) {\n+        Err (error) => fail!(\"Could not load self as module: %s\", error),\n+        Ok (libm) => libm\n+    };\n+\n+    // Unfortunately due to issue #6194 it is not possible to call\n+    // this as a C function\n+    let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n+        match libm.symbol(\"cos\") {\n+            Err (error) => fail!(\"Could not load function cos: %s\", error),\n+            Ok (cosine) => cosine\n+        }\n+    };\n+\n+    let argument = 0.0;\n+    let expected_result = 1.0;\n+    let result = cosine(argument);\n+    if result != expected_result {\n+        fail!(\"cos(%?) != %? but equaled %? instead\", argument,\n+              expected_result, result)\n+    }\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+mod dl {\n+    use libc;\n+    use ptr;\n+    use str;\n+    use task;\n+    use result::*;\n+\n+    pub unsafe fn open(filename: *libc::c_char) -> *libc::c_void {\n+        dlopen(filename, Lazy as libc::c_int)\n+    }\n+\n+    pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        unsafe {\n+            do task::atomically {\n+                let _old_error = dlerror();\n+\n+                let result = f();\n+\n+                let last_error = dlerror();\n+                if ptr::null() == last_error {\n+                    Ok(result)\n+                } else {\n+                    Err(str::raw::from_c_str(last_error))\n+                }\n+            }\n+        }\n+    }\n+\n+    pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n+        dlsym(handle, symbol)\n+    }\n+    pub unsafe fn close(handle: *libc::c_void) {\n+        dlclose(handle); ()\n+    }\n+\n+    pub enum RTLD {\n+        Lazy = 1,\n+        Now = 2,\n+        Global = 256,\n+        Local = 0,\n+    }\n+\n+    #[link_name = \"dl\"]\n+    extern {\n+        fn dlopen(filename: *libc::c_char, flag: libc::c_int) -> *libc::c_void;\n+        fn dlerror() -> *libc::c_char;\n+        fn dlsym(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void;\n+        fn dlclose(handle: *libc::c_void) -> libc::c_int;\n+    }\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+mod dl {\n+    use os;\n+    use libc;\n+    use task;\n+    use result::*;\n+\n+    pub unsafe fn open(filename: *libc::c_char) -> *libc::c_void {\n+        LoadLibrary(filename)\n+    }\n+\n+    pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        unsafe {\n+            do task::atomically {\n+                SetLastError(0);\n+\n+                let result = f();\n+\n+                let error = os::errno();\n+                if 0 == error {\n+                    Ok(result)\n+                } else {\n+                    Err(fmt!(\"Error code %?\", error))\n+                }\n+            }\n+        }\n+    }\n+    pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n+        GetProcAddress(handle, symbol)\n+    }\n+    pub unsafe fn close(handle: *libc::c_void) {\n+        FreeLibrary(handle); ()\n+    }\n+\n+    #[link_name = \"kernel32\"]\n+    extern \"stdcall\" {\n+        fn SetLastError(error: u32);\n+        fn LoadLibrary(name: *libc::c_char) -> *libc::c_void;\n+        fn GetProcAddress(handle: *libc::c_void, name: *libc::c_char) -> *libc::c_void;\n+        fn FreeLibrary(handle: *libc::c_void);\n+    }\n+}"}, {"sha": "ae878050142552fd90a6e11d45ee32de0b6484c9", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/786ea3ffe64209ea68421013f7721288dfab1f6d/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786ea3ffe64209ea68421013f7721288dfab1f6d/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=786ea3ffe64209ea68421013f7721288dfab1f6d", "patch": "@@ -17,6 +17,14 @@ use prelude::*;\n use task;\n \n pub mod at_exit;\n+\n+// Currently only works for *NIXes\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub mod dynamic_lib;\n+\n pub mod global;\n pub mod finally;\n pub mod weak_task;"}]}