{"sha": "d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MTFkYzlkNTdiNzk5MmQxZDk0NmJhMWE3ZTEwZWU2NjkzMjkzYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-15T03:14:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-15T03:14:46Z"}, "message": "Auto merge of #50011 - varkor:partialord-opt-ii, r=Manishearth\n\nEnsure derive(PartialOrd) is no longer accidentally exponential\n\nPreviously, two comparison operations would be generated for each field, each of which could delegate to another derived PartialOrd. Now we use ordering and optional chaining to ensure each pair of fields is only compared once, addressing https://github.com/rust-lang/rust/issues/49650#issuecomment-379467572.\n\nCloses #49505.\n\nr? @Manishearth (sorry for changing it again so soon!)\n\nClose #50755", "tree": {"sha": "5e43767d166ad586bb6b5fc3c9423a3b66a3c1e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e43767d166ad586bb6b5fc3c9423a3b66a3c1e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "html_url": "https://github.com/rust-lang/rust/commit/d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "308b7b05c3acfbbf5e00f16bc9cf9481ae08f4f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/308b7b05c3acfbbf5e00f16bc9cf9481ae08f4f0", "html_url": "https://github.com/rust-lang/rust/commit/308b7b05c3acfbbf5e00f16bc9cf9481ae08f4f0"}, {"sha": "6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "url": "https://api.github.com/repos/rust-lang/rust/commits/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "html_url": "https://github.com/rust-lang/rust/commit/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04"}], "stats": {"total": 199, "additions": 102, "deletions": 97}, "files": [{"sha": "2e9169ce5b942920c16dc5426003888fd98ec8b7", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -122,7 +122,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 5),\n+                              ('PartialOrd', ['PartialEq'], 1),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "2b3930063f369028e9c23122ff398e1885d61c0a", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 101, "deletions": 66, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -147,34 +147,37 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n             // as the outermost one, and the last as the innermost.\n             false,\n             |cx, span, old, self_f, other_fs| {\n-        // match new {\n-        //     Some(::std::cmp::Ordering::Equal) => old,\n-        //     cmp => cmp\n-        // }\n+                // match new {\n+                //     Some(::std::cmp::Ordering::Equal) => old,\n+                //     cmp => cmp\n+                // }\n \n-        let new = {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-            };\n+                let new = {\n+                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                        (1, Some(o_f)) => o_f,\n+                                _ => {\n+                                    cx.span_bug(span,\n+                                        \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                                }\n+                    };\n \n-            let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n+                    let args = vec![\n+                            cx.expr_addr_of(span, self_f),\n+                            cx.expr_addr_of(span, other_f.clone()),\n+                        ];\n \n-            cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-        };\n+                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                };\n \n-        let eq_arm = cx.arm(span,\n-                            vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n-                            old);\n-        let neq_arm = cx.arm(span,\n-                             vec![cx.pat_ident(span, test_id)],\n-                             cx.expr_ident(span, test_id));\n+                let eq_arm = cx.arm(span,\n+                                    vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n+                                    old);\n+                let neq_arm = cx.arm(span,\n+                                    vec![cx.pat_ident(span, test_id)],\n+                                    cx.expr_ident(span, test_id));\n \n-        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-    },\n+                cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+            },\n             equals_expr.clone(),\n             Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n         if self_args.len() != 2 {\n@@ -189,78 +192,99 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let strict_op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n-    cs_fold1(false, // need foldr,\n+fn cs_op(less: bool,\n+         inclusive: bool,\n+         cx: &mut ExtCtxt,\n+         span: Span,\n+         substr: &Substructure) -> P<Expr> {\n+    let ordering_path = |cx: &mut ExtCtxt, name: &str| {\n+        cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", name])))\n+    };\n+\n+    let par_cmp = |cx: &mut ExtCtxt, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n+        let other_f = match (other_fs.len(), other_fs.get(0)) {\n+            (1, Some(o_f)) => o_f,\n+            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+        };\n+\n+        // `PartialOrd::partial_cmp(self.fi, other.fi)`\n+        let cmp_path = cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\",\n+                                                                       \"PartialOrd\",\n+                                                                       \"partial_cmp\"])));\n+        let cmp = cx.expr_call(span,\n+                               cmp_path,\n+                               vec![cx.expr_addr_of(span, self_f),\n+                                    cx.expr_addr_of(span, other_f.clone())]);\n+\n+        let default = ordering_path(cx, default);\n+        // `Option::unwrap_or(_, Ordering::Equal)`\n+        let unwrap_path = cx.expr_path(cx.path_global(span, cx.std_path(&[\"option\",\n+                                                                          \"Option\",\n+                                                                          \"unwrap_or\"])));\n+        cx.expr_call(span, unwrap_path, vec![cmp, default])\n+    };\n+\n+    let fold = cs_fold1(false, // need foldr\n         |cx, span, subexpr, self_f, other_fs| {\n-            // build up a series of chain ||'s and &&'s from the inside\n+            // build up a series of `partial_cmp`s from the inside\n             // out (hence foldr) to get lexical ordering, i.e. for op ==\n             // `ast::lt`\n             //\n             // ```\n-            // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-            // self.f2 < other.f2\n+            // Ordering::then_with(\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n+            //    ),\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n+            //    )\n             // )\n+            // == Ordering::Less\n             // ```\n             //\n             // and for op ==\n             // `ast::le`\n             //\n             // ```\n-            // self.f1 < other.f1 || (self.f1 == other.f1 &&\n-            // self.f2 <= other.f2\n+            // Ordering::then_with(\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n+            //    ),\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n+            //    )\n             // )\n+            // != Ordering::Greater\n             // ```\n             //\n             // The optimiser should remove the redundancy. We explicitly\n             // get use the binops to avoid auto-deref dereferencing too many\n             // layers of pointers, if the type includes pointers.\n-            //\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-            };\n \n-            let strict_ineq = cx.expr_binary(span, strict_op, self_f.clone(), other_f.clone());\n+            // `Option::unwrap_or(PartialOrd::partial_cmp(self.fi, other.fi), Ordering::Equal)`\n+            let par_cmp = par_cmp(cx, span, self_f, other_fs, \"Equal\");\n \n-            let deleg_cmp = if !equal {\n-                cx.expr_unary(span,\n-                            ast::UnOp::Not,\n-                            cx.expr_binary(span, strict_op, other_f.clone(), self_f))\n-            } else {\n-                cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone())\n-            };\n-\n-            let and = cx.expr_binary(span, BinOpKind::And, deleg_cmp, subexpr);\n-            cx.expr_binary(span, BinOpKind::Or, strict_ineq, and)\n+            // `Ordering::then_with(Option::unwrap_or(..), ..)`\n+            let then_with_path = cx.expr_path(cx.path_global(span,\n+                                                             cx.std_path(&[\"cmp\",\n+                                                                           \"Ordering\",\n+                                                                           \"then_with\"])));\n+            cx.expr_call(span, then_with_path, vec![par_cmp, cx.lambda0(span, subexpr)])\n         },\n         |cx, args| {\n             match args {\n                 Some((span, self_f, other_fs)) => {\n-                    // Special-case the base case to generate cleaner code with\n-                    // fewer operations (e.g. `<=` instead of `<` and `==`).\n-                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                        (1, Some(o_f)) => o_f,\n-                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-                    };\n-\n-                    let op = match (less, equal) {\n-                        (false, false) => BinOpKind::Gt,\n-                        (false, true) => BinOpKind::Ge,\n-                        (true, false) => BinOpKind::Lt,\n-                        (true, true) => BinOpKind::Le,\n-                    };\n-\n-                    cx.expr_binary(span, op, self_f, other_f.clone())\n-                }\n-                None => cx.expr_bool(span, equal)\n+                    let opposite = if less { \"Greater\" } else { \"Less\" };\n+                    par_cmp(cx, span, self_f, other_fs, opposite)\n+                },\n+                None => cx.expr_bool(span, inclusive)\n             }\n         },\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             } else {\n-                let op = match (less, equal) {\n+                let op = match (less, inclusive) {\n                     (false, false) => GtOp,\n                     (false, true) => GeOp,\n                     (true, false) => LtOp,\n@@ -271,5 +295,16 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substru\n         }),\n         cx,\n         span,\n-        substr)\n+        substr);\n+\n+    match *substr.fields {\n+        EnumMatching(.., ref all_fields) |\n+        Struct(.., ref all_fields) if !all_fields.is_empty() => {\n+            let ordering = ordering_path(cx, if less ^ inclusive { \"Less\" } else { \"Greater\" });\n+            let comp_op = if inclusive { BinOpKind::Ne } else { BinOpKind::Eq };\n+\n+            cx.expr_binary(span, comp_op, fold, ordering)\n+        }\n+        _ => fold\n+    }\n }"}, {"sha": "a5df717e06ba91401e86ed83f43d9ac2d04fc3f4", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum-struct-variant.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -17,10 +17,6 @@ struct Error;\n enum Enum {\n    A {\n      x: Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n    }\n }\n "}, {"sha": "3411d2f3119ec4af87418e9297bbd015bde6b29c", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -17,10 +17,6 @@ struct Error;\n enum Enum {\n    A(\n      Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n      )\n }\n "}, {"sha": "1feadc2fd83b5c2b4ef0472b413449dcc389f8d4", "filename": "src/test/compile-fail/derives-span-PartialOrd-struct.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -16,10 +16,6 @@ struct Error;\n #[derive(PartialOrd,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n }\n \n fn main() {}"}, {"sha": "9db0fed2d9e9d543dd4688ae5516e55afd55bf35", "filename": "src/test/compile-fail/derives-span-PartialOrd-tuple-struct.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -16,10 +16,6 @@ struct Error;\n #[derive(PartialOrd,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n );\n \n fn main() {}"}, {"sha": "32f9b83b6e2c77f556439d8e5cbf4851f1ecca11", "filename": "src/test/compile-fail/range_traits-1.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d711dc9d57b7992d1d946ba1a7e10ee6693293c2/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs?ref=d711dc9d57b7992d1d946ba1a7e10ee6693293c2", "patch": "@@ -15,35 +15,21 @@ struct AllTheRanges {\n     a: Range<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     b: RangeTo<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     c: RangeFrom<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     d: RangeFull,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     e: RangeInclusive<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n     f: RangeToInclusive<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n-    //~^^^^^ ERROR binary operation `<=` cannot be applied to type\n-    //~^^^^^^ ERROR binary operation `>=` cannot be applied to type\n }\n \n fn main() {}"}]}