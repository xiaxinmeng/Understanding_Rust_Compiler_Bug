{"sha": "ebcc6d2571aa462657ced6f1b917d2c99fcea008", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViY2M2ZDI1NzFhYTQ2MjY1N2NlZDZmMWI5MTdkMmM5OWZjZWEwMDg=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-26T20:35:41Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-26T20:35:41Z"}, "message": "Add part of missing UdpSocket's urls and examples", "tree": {"sha": "55d3af681306da32786234fbe6a0f494757d1d12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55d3af681306da32786234fbe6a0f494757d1d12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebcc6d2571aa462657ced6f1b917d2c99fcea008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebcc6d2571aa462657ced6f1b917d2c99fcea008", "html_url": "https://github.com/rust-lang/rust/commit/ebcc6d2571aa462657ced6f1b917d2c99fcea008", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebcc6d2571aa462657ced6f1b917d2c99fcea008/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e39c0ede524e491cfd1898649115e03d4b22b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e39c0ede524e491cfd1898649115e03d4b22b53", "html_url": "https://github.com/rust-lang/rust/commit/7e39c0ede524e491cfd1898649115e03d4b22b53"}], "stats": {"total": 226, "additions": 215, "deletions": 11}, "files": [{"sha": "b280f466dd439f3628f1bdb908380f9e4d76c1d0", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 215, "deletions": 11, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/ebcc6d2571aa462657ced6f1b917d2c99fcea008/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebcc6d2571aa462657ced6f1b917d2c99fcea008/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=ebcc6d2571aa462657ced6f1b917d2c99fcea008", "patch": "@@ -48,15 +48,36 @@ pub struct UdpSocket(net_imp::UdpSocket);\n impl UdpSocket {\n     /// Creates a UDP socket from the given address.\n     ///\n-    /// The address type can be any implementor of `ToSocketAddr` trait. See\n+    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n+    ///\n+    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let mut buf = [0; 10];\n+    /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n+    ///                                         .expect(\"Didn't receive data\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.0.recv_from(buf)\n@@ -65,11 +86,24 @@ impl UdpSocket {\n     /// Sends data on the socket to the given address. On success, returns the\n     /// number of bytes written.\n     ///\n-    /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n+    /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n     /// documentation for concrete examples.\n+    ///\n     /// This will return an error when the IP version of the local socket\n-    /// does not match that returned from `ToSocketAddrs`\n+    /// does not match that returned from [`ToSocketAddrs`].\n+    ///\n     /// See https://github.com/rust-lang/rust/issues/34202 for more details.\n+    ///\n+    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n                                      -> io::Result<usize> {\n@@ -81,6 +115,16 @@ impl UdpSocket {\n     }\n \n     /// Returns the socket address that this socket was created from.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// assert_eq!(socket.local_addr().unwrap(),\n+    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 34254)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n@@ -91,54 +135,119 @@ impl UdpSocket {\n     /// The returned `UdpSocket` is a reference to the same socket that this\n     /// object references. Both handles will read and write the same port, and\n     /// options set on one socket will be propagated to the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket_clone = socket.try_clone().expect(\"couldn't clone the socket\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<UdpSocket> {\n         self.0.duplicate().map(UdpSocket)\n     }\n \n     /// Sets the read timeout to the timeout specified.\n     ///\n-    /// If the value specified is `None`, then `read` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the value specified is [`None`], then [`read()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n     /// # Note\n     ///\n     /// Platforms may return a different error code whenever a read times out as\n     /// a result of setting this option. For example Unix typically returns an\n-    /// error of the kind `WouldBlock`, but Windows may return `TimedOut`.\n+    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n+    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n     }\n \n     /// Sets the write timeout to the timeout specified.\n     ///\n-    /// If the value specified is `None`, then `write` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the value specified is [`None`], then [`write()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n     /// # Note\n     ///\n     /// Platforms may return a different error code whenever a write times out\n     /// as a result of setting this option. For example Unix typically returns\n-    /// an error of the kind `WouldBlock`, but Windows may return `TimedOut`.\n+    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n+    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)\n     }\n \n     /// Returns the read timeout of this socket.\n     ///\n-    /// If the timeout is `None`, then `read` calls will block indefinitely.\n+    /// If the timeout is [`None`], then [`read()`] calls will block indefinitely.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), None);\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.read_timeout()\n     }\n \n     /// Returns the write timeout of this socket.\n     ///\n-    /// If the timeout is `None`, then `write` calls will block indefinitely.\n+    /// If the timeout is [`None`], then [`write()`] calls will block indefinitely.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), None);\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n@@ -148,6 +257,15 @@ impl UdpSocket {\n     ///\n     /// When enabled, this socket is allowed to send packets to a broadcast\n     /// address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n         self.0.set_broadcast(broadcast)\n@@ -159,6 +277,16 @@ impl UdpSocket {\n     /// [`set_broadcast`][link].\n     ///\n     /// [link]: #method.set_broadcast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n+    /// assert_eq!(socket.broadcast().unwrap(), false);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn broadcast(&self) -> io::Result<bool> {\n         self.0.broadcast()\n@@ -168,6 +296,15 @@ impl UdpSocket {\n     ///\n     /// If enabled, multicast packets will be looped back to the local socket.\n     /// Note that this may not have any affect on IPv6 sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n         self.0.set_multicast_loop_v4(multicast_loop_v4)\n@@ -179,6 +316,16 @@ impl UdpSocket {\n     /// [`set_multicast_loop_v4`][link].\n     ///\n     /// [link]: #method.set_multicast_loop_v4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n+    /// assert_eq!(socket.multicast_loop_v4().unwrap(), false);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v4()\n@@ -191,6 +338,15 @@ impl UdpSocket {\n     /// don't leave the local network unless explicitly requested.\n     ///\n     /// Note that this may not have any affect on IPv6 sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n         self.0.set_multicast_ttl_v4(multicast_ttl_v4)\n@@ -202,6 +358,16 @@ impl UdpSocket {\n     /// [`set_multicast_ttl_v4`][link].\n     ///\n     /// [link]: #method.set_multicast_ttl_v4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n+    /// assert_eq!(socket.multicast_ttl_v4().unwrap(), 42);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n         self.0.multicast_ttl_v4()\n@@ -211,6 +377,15 @@ impl UdpSocket {\n     ///\n     /// Controls whether this socket sees the multicast packets it sends itself.\n     /// Note that this may not have any affect on IPv4 sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n         self.0.set_multicast_loop_v6(multicast_loop_v6)\n@@ -222,6 +397,16 @@ impl UdpSocket {\n     /// [`set_multicast_loop_v6`][link].\n     ///\n     /// [link]: #method.set_multicast_loop_v6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n+    /// assert_eq!(socket.multicast_loop_v6().unwrap(), false);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v6()\n@@ -231,6 +416,15 @@ impl UdpSocket {\n     ///\n     /// This value sets the time-to-live field that is used in every packet sent\n     /// from this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n         self.0.set_ttl(ttl)\n@@ -241,6 +435,16 @@ impl UdpSocket {\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n     /// [link]: #method.set_ttl\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n+    /// assert_eq!(socket.ttl().unwrap(), 42);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()"}]}