{"sha": "5c3ccc55082838524f695ffe40138fd8e805db70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjM2NjYzU1MDgyODM4NTI0ZjY5NWZmZTQwMTM4ZmQ4ZTgwNWRiNzA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-14T08:56:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-14T08:56:48Z"}, "message": "Merge #2240\n\n2240: Move scopes to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "fe730c94b290f2004432908653941a4a8cd4506a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe730c94b290f2004432908653941a4a8cd4506a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c3ccc55082838524f695ffe40138fd8e805db70", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzRbQCRBK7hj4Ov3rIwAAdHIIAH/NKM78yL17HcVDfdeYwHXO\nI9BnnOx9dZK09tFa17y8IhEma2y0NmmAvvNkRY8tm4EN8ODQdmT1uLfvWoiUzKlW\nN9P3rEykndgzCK+3L0UOdbPjAd3UregW+k3/+SWby2kxU3BufGj71wnQHn1pCEZ/\nC8DDO+Tg4ztWR8OIPVarsgM2sLM4Zb6rczYHBT94IPTI4CES+9TCPqC2WCwDJ2kR\noirHGk0o3viw4oj9Z35T7NAnghJUJD1n3QVU3GheTLrAnSLeNSAGF08tIWENLnIt\n3IpHqdqFqa0a1CzVPOpkdoJ75AyQ0wQI5BumSjTUF4gUCHFQ4V4bG0qMvlc0QRE=\n=REsP\n-----END PGP SIGNATURE-----\n", "payload": "tree fe730c94b290f2004432908653941a4a8cd4506a\nparent 267f194c28940e2f8d8748e4708aa1c4a4a13e6f\nparent f924ae3b86dc5e978071b6f8308b9f357415780b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573721808 +0000\ncommitter GitHub <noreply@github.com> 1573721808 +0000\n\nMerge #2240\n\n2240: Move scopes to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3ccc55082838524f695ffe40138fd8e805db70", "html_url": "https://github.com/rust-lang/rust/commit/5c3ccc55082838524f695ffe40138fd8e805db70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c3ccc55082838524f695ffe40138fd8e805db70/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267f194c28940e2f8d8748e4708aa1c4a4a13e6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/267f194c28940e2f8d8748e4708aa1c4a4a13e6f", "html_url": "https://github.com/rust-lang/rust/commit/267f194c28940e2f8d8748e4708aa1c4a4a13e6f"}, {"sha": "f924ae3b86dc5e978071b6f8308b9f357415780b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f924ae3b86dc5e978071b6f8308b9f357415780b", "html_url": "https://github.com/rust-lang/rust/commit/f924ae3b86dc5e978071b6f8308b9f357415780b"}], "stats": {"total": 728, "additions": 360, "deletions": 368}, "files": [{"sha": "14f6b5df4169af46b64fdaec3f5d8018b82843bd", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=5c3ccc55082838524f695ffe40138fd8e805db70", "patch": "@@ -85,7 +85,7 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n #[salsa::query_group(HirDatabaseStorage)]\n #[salsa::requires(salsa::Database)]\n pub trait HirDatabase: DefDatabase + AstDatabase {\n-    #[salsa::invoke(ExprScopes::expr_scopes_query)]\n+    #[salsa::invoke(crate::expr::expr_scopes_query)]\n     fn expr_scopes(&self, def: DefWithBody) -> Arc<ExprScopes>;\n \n     #[salsa::invoke(crate::ty::infer_query)]"}, {"sha": "f02104b2d7b1a34c199fb12aa444d654079a5440", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 199, "deletions": 5, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=5c3ccc55082838524f695ffe40138fd8e805db70", "patch": "@@ -1,6 +1,5 @@\n //! FIXME: write short doc here\n \n-pub(crate) mod scope;\n pub(crate) mod validation;\n \n use std::sync::Arc;\n@@ -9,10 +8,11 @@ use ra_syntax::{ast, AstPtr};\n \n use crate::{db::HirDatabase, DefWithBody, HasSource, Resolver};\n \n-pub use self::scope::ExprScopes;\n-\n pub use hir_def::{\n-    body::{Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource},\n+    body::{\n+        scope::{ExprScopes, ScopeEntry, ScopeId},\n+        Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource,\n+    },\n     expr::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n@@ -49,6 +49,11 @@ pub(crate) fn body_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n     db.body_with_source_map(def).0\n }\n \n+pub(crate) fn expr_scopes_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<ExprScopes> {\n+    let body = db.body(def);\n+    Arc::new(ExprScopes::new(&*body))\n+}\n+\n // needs arbitrary_self_types to be a method... or maybe move to the def?\n pub(crate) fn resolver_for_expr(\n     db: &impl HirDatabase,\n@@ -62,7 +67,7 @@ pub(crate) fn resolver_for_expr(\n pub(crate) fn resolver_for_scope(\n     db: &impl HirDatabase,\n     owner: DefWithBody,\n-    scope_id: Option<scope::ScopeId>,\n+    scope_id: Option<ScopeId>,\n ) -> Resolver {\n     let mut r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n@@ -72,3 +77,192 @@ pub(crate) fn resolver_for_scope(\n     }\n     r\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use hir_expand::Source;\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n+    use test_utils::{assert_eq_text, extract_offset};\n+\n+    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let (off, code) = extract_offset(code);\n+        let code = {\n+            let mut buf = String::new();\n+            let off = u32::from(off) as usize;\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+\n+        let file = db.parse(file_id).ok().unwrap();\n+        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n+\n+        let scopes = analyzer.scopes();\n+        let expr_id = analyzer\n+            .body_source_map()\n+            .node_expr(Source { file_id: file_id.into(), ast: &marker.into() })\n+            .unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n+        let actual = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&expected, &actual);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    <|>\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_method_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    <|>\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        <|>\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    fn do_check_local_name(code: &str, expected_offset: u32) {\n+        let (off, code) = extract_offset(code);\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+        let file = db.parse(file_id).ok().unwrap();\n+        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n+            .expect(\"failed to find a name at the target offset\");\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n+\n+        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n+        let local_name =\n+            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: i32, y: u32) {\n+                {\n+                    let z = x * 2;\n+                }\n+                {\n+                    let t = x<|> * 3;\n+                }\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x;\n+                x<|>\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+\n+    #[test]\n+    fn ref_patterns_contribute_bindings() {\n+        do_check_local_name(\n+            r\"\n+            fn foo() {\n+                if let Some(&from) = bar() {\n+                    from<|>;\n+                }\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+}"}, {"sha": "afba66069869cae546fe146eab863d4fcc3c81cc", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "removed", "additions": 0, "deletions": 353, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/267f194c28940e2f8d8748e4708aa1c4a4a13e6f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267f194c28940e2f8d8748e4708aa1c4a4a13e6f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=267f194c28940e2f8d8748e4708aa1c4a4a13e6f", "patch": "@@ -1,353 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::sync::Arc;\n-\n-use ra_arena::{impl_arena_id, Arena, RawId};\n-use rustc_hash::FxHashMap;\n-\n-use crate::{\n-    db::HirDatabase,\n-    expr::{Body, Expr, ExprId, Pat, PatId, Statement},\n-    DefWithBody, Name,\n-};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ScopeId(RawId);\n-impl_arena_id!(ScopeId);\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ExprScopes {\n-    scopes: Arena<ScopeId, ScopeData>,\n-    scope_by_expr: FxHashMap<ExprId, ScopeId>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeEntry {\n-    name: Name,\n-    pat: PatId,\n-}\n-\n-impl ScopeEntry {\n-    pub(crate) fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub(crate) fn pat(&self) -> PatId {\n-        self.pat\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeData {\n-    parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>,\n-}\n-\n-impl ExprScopes {\n-    pub(crate) fn expr_scopes_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<ExprScopes> {\n-        let body = db.body(def);\n-        let res = ExprScopes::new(&*body);\n-        Arc::new(res)\n-    }\n-\n-    fn new(body: &Body) -> ExprScopes {\n-        let mut scopes =\n-            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n-        let root = scopes.root_scope();\n-        scopes.add_params_bindings(body, root, body.params());\n-        compute_expr_scopes(body.body_expr(), body, &mut scopes, root);\n-        scopes\n-    }\n-\n-    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n-    }\n-\n-    pub(crate) fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n-        std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n-    }\n-\n-    pub(crate) fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n-        self.scope_by_expr.get(&expr).copied()\n-    }\n-\n-    pub(crate) fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n-        &self.scope_by_expr\n-    }\n-\n-    fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: None, entries: vec![] })\n-    }\n-\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), entries: vec![] })\n-    }\n-\n-    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n-        match &body[pat] {\n-            Pat::Bind { name, .. } => {\n-                // bind can have a sub pattern, but it's actually not allowed\n-                // to bind to things in there\n-                let entry = ScopeEntry { name: name.clone(), pat };\n-                self.scopes[scope].entries.push(entry)\n-            }\n-            p => p.walk_child_pats(|pat| self.add_bindings(body, scope, pat)),\n-        }\n-    }\n-\n-    fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n-        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n-    }\n-\n-    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n-        self.scope_by_expr.insert(node, scope);\n-    }\n-}\n-\n-fn compute_block_scopes(\n-    statements: &[Statement],\n-    tail: Option<ExprId>,\n-    body: &Body,\n-    scopes: &mut ExprScopes,\n-    mut scope: ScopeId,\n-) {\n-    for stmt in statements {\n-        match stmt {\n-            Statement::Let { pat, initializer, .. } => {\n-                if let Some(expr) = initializer {\n-                    scopes.set_scope(*expr, scope);\n-                    compute_expr_scopes(*expr, body, scopes, scope);\n-                }\n-                scope = scopes.new_scope(scope);\n-                scopes.add_bindings(body, scope, *pat);\n-            }\n-            Statement::Expr(expr) => {\n-                scopes.set_scope(*expr, scope);\n-                compute_expr_scopes(*expr, body, scopes, scope);\n-            }\n-        }\n-    }\n-    if let Some(expr) = tail {\n-        compute_expr_scopes(expr, body, scopes, scope);\n-    }\n-}\n-\n-fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n-    scopes.set_scope(expr, scope);\n-    match &body[expr] {\n-        Expr::Block { statements, tail } => {\n-            compute_block_scopes(&statements, *tail, body, scopes, scope);\n-        }\n-        Expr::For { iterable, pat, body: body_expr } => {\n-            compute_expr_scopes(*iterable, body, scopes, scope);\n-            let scope = scopes.new_scope(scope);\n-            scopes.add_bindings(body, scope, *pat);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n-        }\n-        Expr::Lambda { args, body: body_expr, .. } => {\n-            let scope = scopes.new_scope(scope);\n-            scopes.add_params_bindings(body, scope, &args);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n-        }\n-        Expr::Match { expr, arms } => {\n-            compute_expr_scopes(*expr, body, scopes, scope);\n-            for arm in arms {\n-                let scope = scopes.new_scope(scope);\n-                for pat in &arm.pats {\n-                    scopes.add_bindings(body, scope, *pat);\n-                }\n-                scopes.set_scope(arm.expr, scope);\n-                compute_expr_scopes(arm.expr, body, scopes, scope);\n-            }\n-        }\n-        e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n-    };\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use hir_expand::Source;\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, extract_offset};\n-\n-    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let (off, code) = extract_offset(code);\n-        let code = {\n-            let mut buf = String::new();\n-            let off = u32::from(off) as usize;\n-            buf.push_str(&code[..off]);\n-            buf.push_str(\"marker\");\n-            buf.push_str(&code[off..]);\n-            buf\n-        };\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-        let file = db.parse(file_id).ok().unwrap();\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n-\n-        let scopes = analyzer.scopes();\n-        let expr_id = analyzer\n-            .body_source_map()\n-            .node_expr(Source { file_id: file_id.into(), ast: &marker.into() })\n-            .unwrap();\n-        let scope = scopes.scope_for(expr_id);\n-\n-        let actual = scopes\n-            .scope_chain(scope)\n-            .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        let expected = expected.join(\"\\n\");\n-        assert_eq_text!(&expected, &actual);\n-    }\n-\n-    #[test]\n-    fn test_lambda_scope() {\n-        do_check(\n-            r\"\n-            fn quux(foo: i32) {\n-                let f = |bar, baz: i32| {\n-                    <|>\n-                };\n-            }\",\n-            &[\"bar\", \"baz\", \"foo\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_method_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                z.f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_loop_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                loop {\n-                    let x = ();\n-                    <|>\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_match() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                match () {\n-                    Some(x) => {\n-                        <|>\n-                    }\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_shadow_variable() {\n-        do_check(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    fn do_check_local_name(code: &str, expected_offset: u32) {\n-        let (off, code) = extract_offset(code);\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-        let file = db.parse(file_id).ok().unwrap();\n-        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n-            .expect(\"failed to find a name at the target offset\");\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n-\n-        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n-        let local_name =\n-            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n-        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: i32, y: u32) {\n-                {\n-                    let z = x * 2;\n-                }\n-                {\n-                    let t = x<|> * 3;\n-                }\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_declaration() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_shadow() {\n-        do_check_local_name(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x;\n-                x<|>\n-            }\n-            \",\n-            53,\n-        );\n-    }\n-\n-    #[test]\n-    fn ref_patterns_contribute_bindings() {\n-        do_check_local_name(\n-            r\"\n-            fn foo() {\n-                if let Some(&from) = bar() {\n-                    from<|>;\n-                }\n-            }\n-            \",\n-            53,\n-        );\n-    }\n-}"}, {"sha": "2f3e12eb83dd933070b83bbb9aedaa7938d84055", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=5c3ccc55082838524f695ffe40138fd8e805db70", "patch": "@@ -13,10 +13,7 @@ use rustc_hash::FxHashSet;\n use crate::{\n     code_model::Crate,\n     db::{DefDatabase, HirDatabase},\n-    expr::{\n-        scope::{ExprScopes, ScopeId},\n-        PatId,\n-    },\n+    expr::{ExprScopes, PatId, ScopeId},\n     generics::GenericParams,\n     impl_block::ImplBlock,\n     Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, PerNs, Static, Struct, Trait,"}, {"sha": "e337a3d4a513934f969be67fdd4a53519b7710ee", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=5c3ccc55082838524f695ffe40138fd8e805db70", "patch": "@@ -23,11 +23,7 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    expr::{\n-        self,\n-        scope::{ExprScopes, ScopeId},\n-        BodySourceMap,\n-    },\n+    expr::{self, BodySourceMap, ExprScopes, ScopeId},\n     ids::LocationCtx,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::{self, implements_trait},"}, {"sha": "c3e9d0c23530940e823498a1fc0f85cd1a962ff2", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=5c3ccc55082838524f695ffe40138fd8e805db70", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n mod lower;\n+pub mod scope;\n \n use std::{ops::Index, sync::Arc};\n "}, {"sha": "dd8d06d1124c66d8d7095096cfd6afd6ed8f10a2", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ccc55082838524f695ffe40138fd8e805db70/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=5c3ccc55082838524f695ffe40138fd8e805db70", "patch": "@@ -0,0 +1,157 @@\n+//! FIXME: write short doc here\n+\n+use hir_expand::name::Name;\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    body::Body,\n+    expr::{Expr, ExprId, Pat, PatId, Statement},\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ScopeId(RawId);\n+impl_arena_id!(ScopeId);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ExprScopes {\n+    scopes: Arena<ScopeId, ScopeData>,\n+    scope_by_expr: FxHashMap<ExprId, ScopeId>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeEntry {\n+    name: Name,\n+    pat: PatId,\n+}\n+\n+impl ScopeEntry {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+\n+    pub fn pat(&self) -> PatId {\n+        self.pat\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeData {\n+    parent: Option<ScopeId>,\n+    entries: Vec<ScopeEntry>,\n+}\n+\n+impl ExprScopes {\n+    pub fn new(body: &Body) -> ExprScopes {\n+        let mut scopes =\n+            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let root = scopes.root_scope();\n+        scopes.add_params_bindings(body, root, body.params());\n+        compute_expr_scopes(body.body_expr(), body, &mut scopes, root);\n+        scopes\n+    }\n+\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n+    }\n+\n+    pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n+        std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n+    }\n+\n+    pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n+        self.scope_by_expr.get(&expr).copied()\n+    }\n+\n+    pub fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n+        &self.scope_by_expr\n+    }\n+\n+    fn root_scope(&mut self) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: None, entries: vec![] })\n+    }\n+\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: Some(parent), entries: vec![] })\n+    }\n+\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+        match &body[pat] {\n+            Pat::Bind { name, .. } => {\n+                // bind can have a sub pattern, but it's actually not allowed\n+                // to bind to things in there\n+                let entry = ScopeEntry { name: name.clone(), pat };\n+                self.scopes[scope].entries.push(entry)\n+            }\n+            p => p.walk_child_pats(|pat| self.add_bindings(body, scope, pat)),\n+        }\n+    }\n+\n+    fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n+        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n+    }\n+\n+    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n+        self.scope_by_expr.insert(node, scope);\n+    }\n+}\n+\n+fn compute_block_scopes(\n+    statements: &[Statement],\n+    tail: Option<ExprId>,\n+    body: &Body,\n+    scopes: &mut ExprScopes,\n+    mut scope: ScopeId,\n+) {\n+    for stmt in statements {\n+        match stmt {\n+            Statement::Let { pat, initializer, .. } => {\n+                if let Some(expr) = initializer {\n+                    scopes.set_scope(*expr, scope);\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n+                }\n+                scope = scopes.new_scope(scope);\n+                scopes.add_bindings(body, scope, *pat);\n+            }\n+            Statement::Expr(expr) => {\n+                scopes.set_scope(*expr, scope);\n+                compute_expr_scopes(*expr, body, scopes, scope);\n+            }\n+        }\n+    }\n+    if let Some(expr) = tail {\n+        compute_expr_scopes(expr, body, scopes, scope);\n+    }\n+}\n+\n+fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n+    scopes.set_scope(expr, scope);\n+    match &body[expr] {\n+        Expr::Block { statements, tail } => {\n+            compute_block_scopes(&statements, *tail, body, scopes, scope);\n+        }\n+        Expr::For { iterable, pat, body: body_expr } => {\n+            compute_expr_scopes(*iterable, body, scopes, scope);\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_bindings(body, scope, *pat);\n+            compute_expr_scopes(*body_expr, body, scopes, scope);\n+        }\n+        Expr::Lambda { args, body: body_expr, .. } => {\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_params_bindings(body, scope, &args);\n+            compute_expr_scopes(*body_expr, body, scopes, scope);\n+        }\n+        Expr::Match { expr, arms } => {\n+            compute_expr_scopes(*expr, body, scopes, scope);\n+            for arm in arms {\n+                let scope = scopes.new_scope(scope);\n+                for pat in &arm.pats {\n+                    scopes.add_bindings(body, scope, *pat);\n+                }\n+                scopes.set_scope(arm.expr, scope);\n+                compute_expr_scopes(arm.expr, body, scopes, scope);\n+            }\n+        }\n+        e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n+    };\n+}"}]}