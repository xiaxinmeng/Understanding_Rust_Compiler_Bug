{"sha": "fab0f9be32dd39b8b821bbc758101720d134fcf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYjBmOWJlMzJkZDM5YjhiODIxYmJjNzU4MTAxNzIwZDEzNGZjZjE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-14T01:41:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-14T01:41:23Z"}, "message": "Rollup merge of #58301 - RalfJung:fat-ptr-eq, r=oli-obk\n\nEnable comparing fat pointers\n\nAlso refactor our binops a bit to make that happen more easily.\n\nr? @oli-obk", "tree": {"sha": "ca09156b315e7d67bbd862f8b03c1560618d30f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca09156b315e7d67bbd862f8b03c1560618d30f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab0f9be32dd39b8b821bbc758101720d134fcf1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcZMdDCRBK7hj4Ov3rIwAAdHIIAH1LPWmehCf33B81npmFTHpP\nnexDp9oEFUt8+Bt2WESbiq84kuKYzBzNBHue6r9pFh7ONkd+m344EeCisUVs+BL1\nz1KmVoMIXbqaqXXvKlahuNgq9fspG8FCXOfCsnK1PbBjWygSTYkuoV+deei6+gWU\nyf3E89B8q/TuELeGQ8q41YEXt4uDQyl9SHVyCzbaO1gduEfoKGyEZxOD02i8qRFf\nEHm8kkjmsm0R+z4pdRHSAE95n0i74oJuzdsPu0yod/I4aY6TqwXmrvNo9bq3D/79\njq0XvmoNYkGGVgNB4TugaiRVbf9mR6CJT13w40/D5YeNy2tWU53KHuRElD93kEQ=\n=UmVS\n-----END PGP SIGNATURE-----\n", "payload": "tree ca09156b315e7d67bbd862f8b03c1560618d30f7\nparent 56e19160af42129b07b985d4cf32a3f49a907010\nparent 22d5e6a37a75db6b59931ee30c1de630f2b5016b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550108483 +0100\ncommitter GitHub <noreply@github.com> 1550108483 +0100\n\nRollup merge of #58301 - RalfJung:fat-ptr-eq, r=oli-obk\n\nEnable comparing fat pointers\n\nAlso refactor our binops a bit to make that happen more easily.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab0f9be32dd39b8b821bbc758101720d134fcf1", "html_url": "https://github.com/rust-lang/rust/commit/fab0f9be32dd39b8b821bbc758101720d134fcf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab0f9be32dd39b8b821bbc758101720d134fcf1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56e19160af42129b07b985d4cf32a3f49a907010", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e19160af42129b07b985d4cf32a3f49a907010", "html_url": "https://github.com/rust-lang/rust/commit/56e19160af42129b07b985d4cf32a3f49a907010"}, {"sha": "22d5e6a37a75db6b59931ee30c1de630f2b5016b", "url": "https://api.github.com/repos/rust-lang/rust/commits/22d5e6a37a75db6b59931ee30c1de630f2b5016b", "html_url": "https://github.com/rust-lang/rust/commit/22d5e6a37a75db6b59931ee30c1de630f2b5016b"}], "stats": {"total": 276, "additions": 146, "deletions": 130}, "files": [{"sha": "7be7f4b439289bc0615fc703f2711f9947fd0bd6", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n@@ -21,7 +21,8 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, RawConst, ConstValue, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Operand, Immediate, Scalar, Pointer,\n+    RawConst, ConstValue,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -77,7 +78,7 @@ pub fn op_to_const<'tcx>(\n     let normalized_op = if normalize {\n         ecx.try_read_immediate(op)?\n     } else {\n-        match op.op {\n+        match *op {\n             Operand::Indirect(mplace) => Err(mplace),\n             Operand::Immediate(val) => Ok(val)\n         }\n@@ -105,15 +106,6 @@ pub fn op_to_const<'tcx>(\n     Ok(ty::Const { val, ty: op.layout.ty })\n }\n \n-pub fn lazy_const_to_op<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n-    cnst: ty::LazyConst<'tcx>,\n-    ty: ty::Ty<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    let op = ecx.const_value_to_op(cnst)?;\n-    Ok(OpTy { op, layout: ecx.layout_of(ty)? })\n-}\n-\n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n@@ -388,10 +380,8 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn ptr_op(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        _left: Scalar,\n-        _left_layout: TyLayout<'tcx>,\n-        _right: Scalar,\n-        _right_layout: TyLayout<'tcx>,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n@@ -486,7 +476,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n-        let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(value), value.ty)?;\n+        let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(value), value.ty)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -512,7 +502,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(val), val.ty)?;\n+    let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(val), val.ty)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n "}, {"sha": "ce62d79e585a8bbf32d5695216950f18f73424e0", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{EvalContext, Machine, PlaceTy, OpTy, Immediate};\n+use super::{EvalContext, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -372,7 +372,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n                             assert_eq!(src_field_layout.size, src.layout.size);\n                             // just sawp out the layout\n-                            OpTy { op: src.op, layout: src_field_layout }\n+                            OpTy::from(ImmTy { imm: src.to_immediate(), layout: src_field_layout })\n                         }\n                     };\n                     if src_field.layout.ty == dst_field.layout.ty {"}, {"sha": "e002c3fd511d6d780a80e731f283b3f22ba53efb", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let is_add = intrinsic_name == \"saturating_add\";\n-                let (val, overflowed) = self.binary_op_imm(if is_add {\n+                let (val, overflowed) = self.binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n                     BinOp::Sub\n@@ -173,7 +173,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     \"unchecked_shr\" => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n-                let (val, overflowed) = self.binary_op_imm(bin_op, l, r)?;\n+                let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;"}, {"sha": "7fb4c47d92acb4d4d12c64fd47a18a130f5a5149", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    EvalContext, PlaceTy, MPlaceTy, OpTy, Pointer, MemoryKind,\n+    EvalContext, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -158,10 +158,8 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn ptr_op(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: Scalar<Self::PointerTag>,\n-        left_layout: TyLayout<'tcx>,\n-        right: Scalar<Self::PointerTag>,\n-        right_layout: TyLayout<'tcx>,\n+        left: ImmTy<'tcx, Self::PointerTag>,\n+        right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword."}, {"sha": "7da907028eebfd542a5bd62032991f77294d7b07", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -11,7 +11,10 @@ use rustc::mir::interpret::{\n     ConstValue, Pointer, Scalar,\n     EvalResult, EvalErrorKind,\n };\n-use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n+use super::{\n+    EvalContext, Machine, AllocMap, Allocation, AllocationExtra,\n+    MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n+};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n \n /// A `Value` represents a single immediate self-contained Rust value.\n@@ -41,6 +44,11 @@ impl Immediate {\n }\n \n impl<'tcx, Tag> Immediate<Tag> {\n+    #[inline]\n+    pub fn from_scalar(val: Scalar<Tag>) -> Self {\n+        Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n+    }\n+\n     #[inline]\n     pub fn erase_tag(self) -> Immediate\n     {\n@@ -112,15 +120,15 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    immediate: Immediate<Tag>,\n+    pub imm: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Immediate<Tag> {\n-        &self.immediate\n+        &self.imm\n     }\n }\n \n@@ -180,7 +188,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    crate op: Operand<Tag>, // ideally we'd make this private, but const_prop needs this\n+    op: Operand<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -206,12 +214,25 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n         OpTy {\n-            op: Operand::Immediate(val.immediate),\n+            op: Operand::Immediate(val.imm),\n             layout: val.layout\n         }\n     }\n }\n \n+impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n+{\n+    #[inline]\n+    pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n+        ImmTy { imm: Immediate::from_scalar(val), layout }\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(self) -> EvalResult<'tcx, u128> {\n+        self.to_scalar()?.to_bits(self.layout.size)\n+    }\n+}\n+\n impl<'tcx, Tag> OpTy<'tcx, Tag>\n {\n     #[inline]\n@@ -324,8 +345,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n-        if let Ok(immediate) = self.try_read_immediate(op)? {\n-            Ok(ImmTy { immediate, layout: op.layout })\n+        if let Ok(imm) = self.try_read_immediate(op)? {\n+            Ok(ImmTy { imm, layout: op.layout })\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -469,6 +490,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(OpTy { op, layout })\n     }\n \n+    /// Every place can be read from, so we can turm them into an operand\n+    #[inline(always)]\n+    pub fn place_to_op(\n+        &self,\n+        place: PlaceTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let op = match *place {\n+            Place::Ptr(mplace) => {\n+                Operand::Indirect(mplace)\n+            }\n+            Place::Local { frame, local } =>\n+                *self.stack[frame].locals[local].access()?\n+        };\n+        Ok(OpTy { op, layout: place.layout })\n+    }\n+\n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n     // avoid allocations.\n     fn eval_place_to_op(\n@@ -531,10 +568,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Used when miri runs into a constant, and by CTFE.\n-    // FIXME: CTFE should use allocations, then we can make this private (embed it into\n-    // `eval_operand`, ideally).\n-    pub(crate) fn const_value_to_op(\n+    // Used when Miri runs into a constant, and (indirectly through lazy_const_to_op) by CTFE.\n+    fn const_value_to_op(\n         &self,\n         val: ty::LazyConst<'tcx>,\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n@@ -666,3 +701,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n }\n+\n+impl<'a, 'mir, 'tcx, M> EvalContext<'a, 'mir, 'tcx, M>\n+where\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<(), M::AllocExtra>)>,\n+    M::AllocExtra: AllocationExtra<(), M::MemoryExtra>,\n+{\n+    // FIXME: CTFE should use allocations, then we can remove this.\n+    pub(crate) fn lazy_const_to_op(\n+        &self,\n+        cnst: ty::LazyConst<'tcx>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = self.const_value_to_op(cnst)?;\n+        Ok(OpTy { op, layout: self.layout_of(ty)? })\n+    }\n+}"}, {"sha": "b3b9c742d6c282bc020aaaa879d3a07d9029da3b", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -18,7 +18,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binary_op_imm(op, left, right)?;\n+        let (val, overflowed) = self.binary_op(op, left, right)?;\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n     }\n@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op_imm(op, left, right)?;\n+        let (val, _overflowed) = self.binary_op(op, left, right)?;\n         self.write_scalar(val, dest)\n     }\n }\n@@ -272,83 +272,70 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok((val, false))\n     }\n \n-    /// Convenience wrapper that's useful when keeping the layout together with the\n-    /// immediate value.\n+    /// Returns the result of the specified operation and whether it overflowed.\n     #[inline]\n-    pub fn binary_op_imm(\n+    pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n-        self.binary_op(\n-            bin_op,\n-            left.to_scalar()?, left.layout,\n-            right.to_scalar()?, right.layout,\n-        )\n-    }\n-\n-    /// Returns the result of the specified operation and whether it overflowed.\n-    pub fn binary_op(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Scalar<M::PointerTag>,\n-        left_layout: TyLayout<'tcx>,\n-        right: Scalar<M::PointerTag>,\n-        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n-            bin_op, left, left_layout.ty, right, right_layout.ty);\n+            bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n-        match left_layout.ty.sty {\n+        match left.layout.ty.sty {\n             ty::Char => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_char()?;\n-                let right = right.to_char()?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_scalar()?.to_char()?;\n+                let right = right.to_scalar()?.to_char()?;\n                 self.binary_char_op(bin_op, left, right)\n             }\n             ty::Bool => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_bool()?;\n-                let right = right.to_bool()?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_scalar()?.to_bool()?;\n+                let right = right.to_scalar()?.to_bool()?;\n                 self.binary_bool_op(bin_op, left, right)\n             }\n             ty::Float(fty) => {\n-                assert_eq!(left_layout.ty, right_layout.ty);\n-                let left = left.to_bits(left_layout.size)?;\n-                let right = right.to_bits(right_layout.size)?;\n+                assert_eq!(left.layout.ty, right.layout.ty);\n+                let left = left.to_bits()?;\n+                let right = right.to_bits()?;\n                 self.binary_float_op(bin_op, fty, left, right)\n             }\n             _ => {\n                 // Must be integer(-like) types.  Don't forget about == on fn pointers.\n-                assert!(left_layout.ty.is_integral() || left_layout.ty.is_unsafe_ptr() ||\n-                    left_layout.ty.is_fn());\n-                assert!(right_layout.ty.is_integral() || right_layout.ty.is_unsafe_ptr() ||\n-                    right_layout.ty.is_fn());\n+                assert!(left.layout.ty.is_integral() || left.layout.ty.is_unsafe_ptr() ||\n+                    left.layout.ty.is_fn());\n+                assert!(right.layout.ty.is_integral() || right.layout.ty.is_unsafe_ptr() ||\n+                    right.layout.ty.is_fn());\n \n                 // Handle operations that support pointer values\n-                if left.is_ptr() || right.is_ptr() || bin_op == mir::BinOp::Offset {\n-                    return M::ptr_op(self, bin_op, left, left_layout, right, right_layout);\n+                if left.to_scalar_ptr()?.is_ptr() ||\n+                    right.to_scalar_ptr()?.is_ptr() ||\n+                    bin_op == mir::BinOp::Offset\n+                {\n+                    return M::ptr_op(self, bin_op, left, right);\n                 }\n \n                 // Everything else only works with \"proper\" bits\n-                let left = left.to_bits(left_layout.size).expect(\"we checked is_ptr\");\n-                let right = right.to_bits(right_layout.size).expect(\"we checked is_ptr\");\n-                self.binary_int_op(bin_op, left, left_layout, right, right_layout)\n+                let l = left.to_bits().expect(\"we checked is_ptr\");\n+                let r = right.to_bits().expect(\"we checked is_ptr\");\n+                self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n         }\n     }\n \n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: Scalar<M::PointerTag>,\n-        layout: TyLayout<'tcx>,\n+        val: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n+        let layout = val.layout;\n+        let val = val.to_scalar()?;\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty.sty);\n \n         match layout.ty.sty {"}, {"sha": "b29e09900f6b1e2e1dc0b67eeda4ce7bb8c46837", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -244,10 +244,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: ::std::fmt::Debug> OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n-        match self.op {\n+        match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(imm) => Err(imm),\n         }\n@@ -487,9 +487,9 @@ where\n             Deref => self.deref_operand(base.into())?,\n \n             Index(local) => {\n-                let n = *self.frame().locals[local].access()?;\n-                let n_layout = self.layout_of(self.tcx.types.usize)?;\n-                let n = self.read_scalar(OpTy { op: n, layout: n_layout })?;\n+                let layout = self.layout_of(self.tcx.types.usize)?;\n+                let n = self.access_local(self.frame(), local, Some(layout))?;\n+                let n = self.read_scalar(n)?;\n                 let n = n.to_bits(self.tcx.data_layout.pointer_size)?;\n                 self.mplace_field(base, u64::try_from(n).unwrap())?\n             }\n@@ -991,22 +991,6 @@ where\n         Ok(())\n     }\n \n-    /// Every place can be read from, so we can turm them into an operand\n-    #[inline(always)]\n-    pub fn place_to_op(\n-        &self,\n-        place: PlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match place.place {\n-            Place::Ptr(mplace) => {\n-                Operand::Indirect(mplace)\n-            }\n-            Place::Local { frame, local } =>\n-                *self.stack[frame].locals[local].access()?\n-        };\n-        Ok(OpTy { op, layout: place.layout })\n-    }\n-\n     pub fn raw_const_to_mplace(\n         &self,\n         raw: RawConst<'tcx>,"}, {"sha": "97ef2b5fa3485342b1b58689ed74e204fb3b1721", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n+                let val = self.unary_op(un_op, val)?;\n                 self.write_scalar(val, dest)?;\n             }\n "}, {"sha": "c2ee3f5715bd370bafa580a2acbb1522affdaeb2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -7,7 +7,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Immediate, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -51,8 +51,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // Compare using binary_op, to also support pointer values\n                     let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n-                        discr.to_scalar()?, discr.layout,\n-                        const_int, discr.layout,\n+                        discr,\n+                        ImmTy::from_scalar(const_int, discr.layout),\n                     )?;\n                     if res.to_bool()? {\n                         target_block = targets[index];\n@@ -418,8 +418,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let mut args = args.to_vec();\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n-                args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?;\n-                args[0].op = Operand::Immediate(Immediate::Scalar(ptr.ptr.into())); // strip vtable\n+                args[0] = OpTy::from(ImmTy { // strip vtable\n+                    layout: self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?,\n+                    imm: Immediate::Scalar(ptr.ptr.into())\n+                });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n@@ -448,8 +450,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             _ => (instance, place),\n         };\n \n-        let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref()),\n+        let arg = ImmTy {\n+            imm: place.to_ref(),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n@@ -460,7 +462,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             instance,\n             span,\n             Abi::Rust,\n-            &[arg],\n+            &[arg.into()],\n             Some(dest.into()),\n             Some(target),\n         )"}, {"sha": "1b0a9b17d3686cab83e21d001292b571fa1a859a", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -22,6 +22,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n+            // This means we guarantee that there are no duplicate vtables, we will\n+            // always use the same vtable for the same (Type, Trait) combination.\n+            // That's not what happens in rustc, but emulating per-crate deduplication\n+            // does not sound like it actually makes anything any better.\n             return Ok(Pointer::from(vtable).with_default_tag());\n         }\n "}, {"sha": "7da00c4ea0c36f0d7bb1a80ce9f9308e47cf12d0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab0f9be32dd39b8b821bbc758101720d134fcf1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fab0f9be32dd39b8b821bbc758101720d134fcf1", "patch": "@@ -18,10 +18,9 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use crate::interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n+use crate::interpret::{EvalContext, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n-    lazy_const_to_op,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -254,7 +253,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match lazy_const_to_op(&self.ecx, *c.literal, c.ty) {\n+        match self.ecx.lazy_const_to_op(*c.literal, c.ty) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },\n@@ -345,15 +344,15 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    OpTy {\n-                        op: interpret::Operand::Immediate(Immediate::Scalar(\n+                    ImmTy {\n+                        imm: Immediate::Scalar(\n                             Scalar::Bits {\n                                 bits: n as u128,\n                                 size: self.tcx.data_layout.pointer_size.bytes() as u8,\n                             }.into()\n-                        )),\n+                        ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    },\n+                    }.into(),\n                     span,\n                 )))\n             }\n@@ -371,13 +370,12 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n                 let (arg, _) = self.eval_operand(arg, source_info)?;\n                 let val = self.use_ecx(source_info, |this| {\n-                    let prim = this.ecx.read_scalar(arg)?.not_undef()?;\n+                    let prim = this.ecx.read_immediate(arg)?;\n                     match op {\n                         UnOp::Neg => {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n-                            let size = arg.layout.size;\n-                            if prim.to_bits(size)? == (1 << (size.bits() - 1)) {\n+                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n                                 return err!(OverflowNeg);\n                             }\n                         }\n@@ -386,13 +384,13 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                         }\n                     }\n                     // Now run the actual operation.\n-                    this.ecx.unary_op(op, prim, arg.layout)\n+                    this.ecx.unary_op(op, prim)\n                 })?;\n-                let res = OpTy {\n-                    op: interpret::Operand::Immediate(Immediate::Scalar(val.into())),\n+                let res = ImmTy {\n+                    imm: Immediate::Scalar(val.into()),\n                     layout: place_layout,\n                 };\n-                Some((res, span))\n+                Some((res.into(), span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -447,7 +445,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op_imm(op, l, r)\n+                    this.ecx.binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Immediate::ScalarPair(\n@@ -462,11 +460,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     }\n                     Immediate::Scalar(val.into())\n                 };\n-                let res = OpTy {\n-                    op: interpret::Operand::Immediate(val),\n+                let res = ImmTy {\n+                    imm: val,\n                     layout: place_layout,\n                 };\n-                Some((res, span))\n+                Some((res.into(), span))\n             },\n         }\n     }"}]}