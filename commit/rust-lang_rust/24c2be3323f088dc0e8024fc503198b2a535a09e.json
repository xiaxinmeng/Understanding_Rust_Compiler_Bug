{"sha": "24c2be3323f088dc0e8024fc503198b2a535a09e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YzJiZTMzMjNmMDg4ZGMwZTgwMjRmYzUwMzE5OGIyYTUzNWEwOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-19T00:13:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-19T00:13:27Z"}, "message": "auto merge of #6597 : bjz/rust/core-char, r=brson", "tree": {"sha": "382b6cfaa5693179a654cfd7ec384a3041e881ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382b6cfaa5693179a654cfd7ec384a3041e881ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24c2be3323f088dc0e8024fc503198b2a535a09e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24c2be3323f088dc0e8024fc503198b2a535a09e", "html_url": "https://github.com/rust-lang/rust/commit/24c2be3323f088dc0e8024fc503198b2a535a09e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24c2be3323f088dc0e8024fc503198b2a535a09e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "html_url": "https://github.com/rust-lang/rust/commit/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8"}, {"sha": "f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "html_url": "https://github.com/rust-lang/rust/commit/f687b9d771fce39d1102ff13042a6dfc45f4bf8d"}], "stats": {"total": 461, "additions": 277, "deletions": 184}, "files": [{"sha": "f977845eb8a58da0c00d31058a8f75279ff7f885", "filename": "src/libcore/char.rs", "status": "modified", "additions": 276, "deletions": 184, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/24c2be3323f088dc0e8024fc503198b2a535a09e/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c2be3323f088dc0e8024fc503198b2a535a09e/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=24c2be3323f088dc0e8024fc503198b2a535a09e", "patch": "@@ -10,138 +10,144 @@\n \n //! Utilities for manipulating the char type\n \n-#[cfg(not(test))]\n-use cmp::Ord;\n use option::{None, Option, Some};\n use str;\n+#[cfg(stage0)]\n+use str::StrSlice;\n+#[cfg(not(stage0))]\n+use str::{StrSlice, OwnedStr};\n use u32;\n use uint;\n use unicode::{derived_property, general_category};\n \n-#[cfg(not(test))] use cmp::Eq;\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord};\n \n /*\n-    Lu  Uppercase_Letter    an uppercase letter\n-    Ll  Lowercase_Letter    a lowercase letter\n-    Lt  Titlecase_Letter    a digraphic character, with first part uppercase\n-    Lm  Modifier_Letter     a modifier letter\n-    Lo  Other_Letter    other letters, including syllables and ideographs\n-    Mn  Nonspacing_Mark     a nonspacing combining mark (zero advance width)\n-    Mc  Spacing_Mark    a spacing combining mark (positive advance width)\n-    Me  Enclosing_Mark  an enclosing combining mark\n-    Nd  Decimal_Number  a decimal digit\n-    Nl  Letter_Number   a letterlike numeric character\n-    No  Other_Number    a numeric character of other type\n+    Lu  Uppercase_Letter        an uppercase letter\n+    Ll  Lowercase_Letter        a lowercase letter\n+    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n+    Lm  Modifier_Letter         a modifier letter\n+    Lo  Other_Letter            other letters, including syllables and ideographs\n+    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n+    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n+    Me  Enclosing_Mark          an enclosing combining mark\n+    Nd  Decimal_Number          a decimal digit\n+    Nl  Letter_Number           a letterlike numeric character\n+    No  Other_Number            a numeric character of other type\n     Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n-    Pd  Dash_Punctuation    a dash or hyphen punctuation mark\n-    Ps  Open_Punctuation    an opening punctuation mark (of a pair)\n-    Pe  Close_Punctuation   a closing punctuation mark (of a pair)\n+    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n+    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n+    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n     Pi  Initial_Punctuation     an initial quotation mark\n-    Pf  Final_Punctuation   a final quotation mark\n-    Po  Other_Punctuation   a punctuation mark of other type\n-    Sm  Math_Symbol     a symbol of primarily mathematical use\n-    Sc  Currency_Symbol     a currency sign\n-    Sk  Modifier_Symbol     a non-letterlike modifier symbol\n-    So  Other_Symbol    a symbol of other type\n-    Zs  Space_Separator     a space character (of various non-zero widths)\n-    Zl  Line_Separator  U+2028 LINE SEPARATOR only\n+    Pf  Final_Punctuation       a final quotation mark\n+    Po  Other_Punctuation       a punctuation mark of other type\n+    Sm  Math_Symbol             a symbol of primarily mathematical use\n+    Sc  Currency_Symbol         a currency sign\n+    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n+    So  Other_Symbol            a symbol of other type\n+    Zs  Space_Separator         a space character (of various non-zero widths)\n+    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n     Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n-    Cc  Control     a C0 or C1 control code\n-    Cf  Format  a format control character\n-    Cs  Surrogate   a surrogate code point\n-    Co  Private_Use     a private-use character\n-    Cn  Unassigned  a reserved unassigned code point or a noncharacter\n+    Cc  Control                 a C0 or C1 control code\n+    Cf  Format                  a format control character\n+    Cs  Surrogate               a surrogate code point\n+    Co  Private_Use             a private-use character\n+    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n \n-/**\n- * Indicates whether a character is in lower case, defined\n- * in terms of the Unicode General Category 'Ll'\n- */\n+///\n+/// Indicates whether a character is in lower case, defined\n+/// in terms of the Unicode General Category 'Ll'\n+///\n #[inline(always)]\n-pub fn is_lowercase(c: char) -> bool {\n-    return general_category::Ll(c);\n-}\n+pub fn is_lowercase(c: char) -> bool { general_category::Ll(c) }\n \n-/**\n- * Indicates whether a character is in upper case, defined\n- * in terms of the Unicode General Category 'Lu'.\n- */\n+///\n+/// Indicates whether a character is in upper case, defined\n+/// in terms of the Unicode General Category 'Lu'.\n+///\n #[inline(always)]\n-pub fn is_uppercase(c: char) -> bool {\n-    return general_category::Lu(c);\n-}\n+pub fn is_uppercase(c: char) -> bool { general_category::Lu(c) }\n \n-/**\n- * Indicates whether a character is whitespace. Whitespace is defined in\n- * terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n- * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n- */\n+///\n+/// Indicates whether a character is whitespace. Whitespace is defined in\n+/// terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n+/// additional 'Cc'-category control codes in the range [0x09, 0x0d]\n+///\n #[inline(always)]\n pub fn is_whitespace(c: char) -> bool {\n-    return ('\\x09' <= c && c <= '\\x0d')\n+    ('\\x09' <= c && c <= '\\x0d')\n         || general_category::Zs(c)\n         || general_category::Zl(c)\n-        || general_category::Zp(c);\n+        || general_category::Zp(c)\n }\n \n-/**\n- * Indicates whether a character is alphanumeric. Alphanumericness is\n- * defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n- * and the Derived Core Property 'Alphabetic'.\n- */\n+///\n+/// Indicates whether a character is alphanumeric. Alphanumericness is\n+/// defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n+/// and the Derived Core Property 'Alphabetic'.\n+///\n #[inline(always)]\n pub fn is_alphanumeric(c: char) -> bool {\n-    return derived_property::Alphabetic(c) ||\n-        general_category::Nd(c) ||\n-        general_category::Nl(c) ||\n-        general_category::No(c);\n+    derived_property::Alphabetic(c)\n+        || general_category::Nd(c)\n+        || general_category::Nl(c)\n+        || general_category::No(c)\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n #[inline(always)]\n pub fn is_digit(c: char) -> bool {\n-    return general_category::Nd(c) ||\n-        general_category::Nl(c) ||\n-        general_category::No(c);\n+    general_category::Nd(c)\n+        || general_category::Nl(c)\n+        || general_category::No(c)\n }\n \n-/**\n- * Checks if a character parses as a numeric digit in the given radix.\n- * Compared to `is_digit()`, this function only recognizes the\n- * characters `0-9`, `a-z` and `A-Z`.\n- *\n- * Returns `true` if `c` is a valid digit under `radix`, and `false`\n- * otherwise.\n- *\n- * Fails if given a `radix` > 36.\n- *\n- * Note: This just wraps `to_digit()`.\n- */\n+///\n+/// Checks if a character parses as a numeric digit in the given radix.\n+/// Compared to `is_digit()`, this function only recognizes the\n+/// characters `0-9`, `a-z` and `A-Z`.\n+///\n+/// # Return value\n+///\n+/// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+/// otherwise.\n+///\n+/// # Failure\n+///\n+/// Fails if given a `radix` > 36.\n+///\n+/// # Note\n+///\n+/// This just wraps `to_digit()`.\n+///\n #[inline(always)]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n         Some(_) => true,\n-        None    => false\n+        None    => false,\n     }\n }\n \n-/**\n- * Convert a char to the corresponding digit.\n- *\n- * # Return value\n- *\n- * If `c` is between '0' and '9', the corresponding value\n- * between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n- * 'b' or 'B', 11, etc. Returns none if the char does not\n- * refer to a digit in the given radix.\n- *\n- * # Failure\n- * Fails if given a `radix` outside the range `[0..36]`.\n- */\n+///\n+/// Convert a char to the corresponding digit.\n+///\n+/// # Return value\n+///\n+/// If `c` is between '0' and '9', the corresponding value\n+/// between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n+/// 'b' or 'B', 11, etc. Returns none if the char does not\n+/// refer to a digit in the given radix.\n+///\n+/// # Failure\n+///\n+/// Fails if given a `radix` outside the range `[0..36]`.\n+///\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n@@ -151,20 +157,24 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n       '0' .. '9' => c as uint - ('0' as uint),\n       'a' .. 'z' => c as uint + 10u - ('a' as uint),\n       'A' .. 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return None\n+      _ => return None,\n     };\n     if val < radix { Some(val) }\n     else { None }\n }\n \n-/**\n- * Converts a number to the character representing it.\n- *\n- * Returns `Some(char)` if `num` represents one digit under `radix`,\n- * using one character of `0-9` or `a-z`, or `None` if it doesn't.\n- *\n- * Fails if given an `radix` > 36.\n- */\n+///\n+/// Converts a number to the character representing it.\n+///\n+/// # Return value\n+///\n+/// Returns `Some(char)` if `num` represents one digit under `radix`,\n+/// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n+///\n+/// # Failure\n+///\n+/// Fails if given an `radix` > 36.\n+///\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n@@ -181,15 +191,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-/**\n- * Return the hexadecimal unicode escape of a char.\n- *\n- * The rules are as follows:\n- *\n- *   - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n- *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n- *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n- */\n+#[cfg(stage0)]\n pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str_radix(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n@@ -204,32 +206,59 @@ pub fn escape_unicode(c: char) -> ~str {\n     out\n }\n \n-/**\n- * Return a 'default' ASCII and C++11-like char-literal escape of a char.\n- *\n- * The default is chosen with a bias toward producing literals that are\n- * legal in a variety of languages, including C++11 and similar C-family\n- * languages. The exact rules are:\n- *\n- *   - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n- *   - Single-quote, double-quote and backslash chars are backslash-escaped.\n- *   - Any other chars in the range [0x20,0x7e] are not escaped.\n- *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n- */\n+///\n+/// Return the hexadecimal unicode escape of a char.\n+///\n+/// The rules are as follows:\n+///\n+/// - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n+/// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n+/// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n+///\n+#[cfg(not(stage0))]\n+pub fn escape_unicode(c: char) -> ~str {\n+    let s = u32::to_str_radix(c as u32, 16u);\n+    let (c, pad) = cond!(\n+        (c <= '\\xff')   { ('x', 2u) }\n+        (c <= '\\uffff') { ('u', 4u) }\n+        _               { ('U', 8u) }\n+    );\n+    assert!(s.len() <= pad);\n+    let mut out = ~\"\\\\\";\n+    out.push_str(str::from_char(c));\n+    for uint::range(s.len(), pad) |_| {\n+        out.push_str(\"0\");\n+    }\n+    out.push_str(s);\n+    out\n+}\n+\n+///\n+/// Return a 'default' ASCII and C++11-like char-literal escape of a char.\n+///\n+/// The default is chosen with a bias toward producing literals that are\n+/// legal in a variety of languages, including C++11 and similar C-family\n+/// languages. The exact rules are:\n+///\n+/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n+/// - Any other chars in the range [0x20,0x7e] are not escaped.\n+/// - Any other chars are given hex unicode escapes; see `escape_unicode`.\n+///\n pub fn escape_default(c: char) -> ~str {\n     match c {\n-      '\\t' => ~\"\\\\t\",\n-      '\\r' => ~\"\\\\r\",\n-      '\\n' => ~\"\\\\n\",\n-      '\\\\' => ~\"\\\\\\\\\",\n-      '\\'' => ~\"\\\\'\",\n-      '\"'  => ~\"\\\\\\\"\",\n-      '\\x20' .. '\\x7e' => str::from_char(c),\n-      _ => escape_unicode(c)\n+        '\\t' => ~\"\\\\t\",\n+        '\\r' => ~\"\\\\r\",\n+        '\\n' => ~\"\\\\n\",\n+        '\\\\' => ~\"\\\\\\\\\",\n+        '\\'' => ~\"\\\\'\",\n+        '\"'  => ~\"\\\\\\\"\",\n+        '\\x20' .. '\\x7e' => str::from_char(c),\n+        _ => c.escape_unicode(),\n     }\n }\n \n-/// Returns the amount of bytes this character would need if encoded in utf8\n+#[cfg(stage0)]\n pub fn len_utf8_bytes(c: char) -> uint {\n     static max_one_b: uint = 128u;\n     static max_two_b: uint = 2048u;\n@@ -244,6 +273,71 @@ pub fn len_utf8_bytes(c: char) -> uint {\n     else { fail!(\"invalid character!\") }\n }\n \n+/// Returns the amount of bytes this character would need if encoded in utf8\n+#[cfg(not(stage0))]\n+pub fn len_utf8_bytes(c: char) -> uint {\n+    static MAX_ONE_B:   uint = 128u;\n+    static MAX_TWO_B:   uint = 2048u;\n+    static MAX_THREE_B: uint = 65536u;\n+    static MAX_FOUR_B:  uint = 2097152u;\n+\n+    let code = c as uint;\n+    cond!(\n+        (code < MAX_ONE_B)   { 1u }\n+        (code < MAX_TWO_B)   { 2u }\n+        (code < MAX_THREE_B) { 3u }\n+        (code < MAX_FOUR_B)  { 4u }\n+        _ { fail!(\"invalid character!\") }\n+    )\n+}\n+\n+pub trait Char {\n+    fn is_alphabetic(&self) -> bool;\n+    fn is_XID_start(&self) -> bool;\n+    fn is_XID_continue(&self) -> bool;\n+    fn is_lowercase(&self) -> bool;\n+    fn is_uppercase(&self) -> bool;\n+    fn is_whitespace(&self) -> bool;\n+    fn is_alphanumeric(&self) -> bool;\n+    fn is_digit(&self) -> bool;\n+    fn is_digit_radix(&self, radix: uint) -> bool;\n+    fn to_digit(&self, radix: uint) -> Option<uint>;\n+    fn from_digit(num: uint, radix: uint) -> Option<char>;\n+    fn escape_unicode(&self) -> ~str;\n+    fn escape_default(&self) -> ~str;\n+    fn len_utf8_bytes(&self) -> uint;\n+}\n+\n+impl Char for char {\n+    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n+\n+    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n+\n+    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n+\n+    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n+\n+    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n+\n+    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+\n+    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+\n+    fn is_digit(&self) -> bool { is_digit(*self) }\n+\n+    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n+\n+    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }\n+\n+    fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n+\n+    fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n+\n+    fn escape_default(&self) -> ~str { escape_default(*self) }\n+\n+    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n+}\n+\n #[cfg(not(test))]\n impl Eq for char {\n     #[inline(always)]\n@@ -266,84 +360,82 @@ impl Ord for char {\n \n #[test]\n fn test_is_lowercase() {\n-    assert!(is_lowercase('a'));\n-    assert!(is_lowercase('\u00f6'));\n-    assert!(is_lowercase('\u00df'));\n-    assert!(!is_lowercase('\u00dc'));\n-    assert!(!is_lowercase('P'));\n+    assert!('a'.is_lowercase());\n+    assert!('\u00f6'.is_lowercase());\n+    assert!('\u00df'.is_lowercase());\n+    assert!(!'\u00dc'.is_lowercase());\n+    assert!(!'P'.is_lowercase());\n }\n \n #[test]\n fn test_is_uppercase() {\n-    assert!(!is_uppercase('h'));\n-    assert!(!is_uppercase('\u00e4'));\n-    assert!(!is_uppercase('\u00df'));\n-    assert!(is_uppercase('\u00d6'));\n-    assert!(is_uppercase('T'));\n+    assert!(!'h'.is_uppercase());\n+    assert!(!'\u00e4'.is_uppercase());\n+    assert!(!'\u00df'.is_uppercase());\n+    assert!('\u00d6'.is_uppercase());\n+    assert!('T'.is_uppercase());\n }\n \n #[test]\n fn test_is_whitespace() {\n-    assert!(is_whitespace(' '));\n-    assert!(is_whitespace('\\u2007'));\n-    assert!(is_whitespace('\\t'));\n-    assert!(is_whitespace('\\n'));\n-\n-    assert!(!is_whitespace('a'));\n-    assert!(!is_whitespace('_'));\n-    assert!(!is_whitespace('\\u0000'));\n+    assert!(' '.is_whitespace());\n+    assert!('\\u2007'.is_whitespace());\n+    assert!('\\t'.is_whitespace());\n+    assert!('\\n'.is_whitespace());\n+    assert!(!'a'.is_whitespace());\n+    assert!(!'_'.is_whitespace());\n+    assert!(!'\\u0000'.is_whitespace());\n }\n \n #[test]\n fn test_to_digit() {\n-    assert_eq!(to_digit('0', 10u), Some(0u));\n-    assert_eq!(to_digit('1', 2u), Some(1u));\n-    assert_eq!(to_digit('2', 3u), Some(2u));\n-    assert_eq!(to_digit('9', 10u), Some(9u));\n-    assert_eq!(to_digit('a', 16u), Some(10u));\n-    assert_eq!(to_digit('A', 16u), Some(10u));\n-    assert_eq!(to_digit('b', 16u), Some(11u));\n-    assert_eq!(to_digit('B', 16u), Some(11u));\n-    assert_eq!(to_digit('z', 36u), Some(35u));\n-    assert_eq!(to_digit('Z', 36u), Some(35u));\n-\n-    assert!(to_digit(' ', 10u).is_none());\n-    assert!(to_digit('$', 36u).is_none());\n+    assert_eq!('0'.to_digit(10u), Some(0u));\n+    assert_eq!('1'.to_digit(2u), Some(1u));\n+    assert_eq!('2'.to_digit(3u), Some(2u));\n+    assert_eq!('9'.to_digit(10u), Some(9u));\n+    assert_eq!('a'.to_digit(16u), Some(10u));\n+    assert_eq!('A'.to_digit(16u), Some(10u));\n+    assert_eq!('b'.to_digit(16u), Some(11u));\n+    assert_eq!('B'.to_digit(16u), Some(11u));\n+    assert_eq!('z'.to_digit(36u), Some(35u));\n+    assert_eq!('Z'.to_digit(36u), Some(35u));\n+    assert_eq!(' '.to_digit(10u), None);\n+    assert_eq!('$'.to_digit(36u), None);\n }\n \n #[test]\n fn test_is_digit() {\n-   assert!(is_digit('2'));\n-   assert!(is_digit('7'));\n-   assert!(! is_digit('c'));\n-   assert!(! is_digit('i'));\n-   assert!(! is_digit('z'));\n-   assert!(! is_digit('Q'));\n+   assert!('2'.is_digit());\n+   assert!('7'.is_digit());\n+   assert!(!'c'.is_digit());\n+   assert!(!'i'.is_digit());\n+   assert!(!'z'.is_digit());\n+   assert!(!'Q'.is_digit());\n }\n \n #[test]\n fn test_escape_default() {\n-    assert_eq!(escape_default('\\n'), ~\"\\\\n\");\n-    assert_eq!(escape_default('\\r'), ~\"\\\\r\");\n-    assert_eq!(escape_default('\\''), ~\"\\\\'\");\n-    assert_eq!(escape_default('\"'), ~\"\\\\\\\"\");\n-    assert_eq!(escape_default(' '), ~\" \");\n-    assert_eq!(escape_default('a'), ~\"a\");\n-    assert_eq!(escape_default('~'), ~\"~\");\n-    assert_eq!(escape_default('\\x00'), ~\"\\\\x00\");\n-    assert_eq!(escape_default('\\x1f'), ~\"\\\\x1f\");\n-    assert_eq!(escape_default('\\x7f'), ~\"\\\\x7f\");\n-    assert_eq!(escape_default('\\xff'), ~\"\\\\xff\");\n-    assert_eq!(escape_default('\\u011b'), ~\"\\\\u011b\");\n-    assert_eq!(escape_default('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n+    assert_eq!('\\n'.escape_default(), ~\"\\\\n\");\n+    assert_eq!('\\r'.escape_default(), ~\"\\\\r\");\n+    assert_eq!('\\''.escape_default(), ~\"\\\\'\");\n+    assert_eq!('\"'.escape_default(), ~\"\\\\\\\"\");\n+    assert_eq!(' '.escape_default(), ~\" \");\n+    assert_eq!('a'.escape_default(), ~\"a\");\n+    assert_eq!('~'.escape_default(), ~\"~\");\n+    assert_eq!('\\x00'.escape_default(), ~\"\\\\x00\");\n+    assert_eq!('\\x1f'.escape_default(), ~\"\\\\x1f\");\n+    assert_eq!('\\x7f'.escape_default(), ~\"\\\\x7f\");\n+    assert_eq!('\\xff'.escape_default(), ~\"\\\\xff\");\n+    assert_eq!('\\u011b'.escape_default(), ~\"\\\\u011b\");\n+    assert_eq!('\\U0001d4b6'.escape_default(), ~\"\\\\U0001d4b6\");\n }\n \n #[test]\n fn test_escape_unicode() {\n-    assert_eq!(escape_unicode('\\x00'), ~\"\\\\x00\");\n-    assert_eq!(escape_unicode('\\n'), ~\"\\\\x0a\");\n-    assert_eq!(escape_unicode(' '), ~\"\\\\x20\");\n-    assert_eq!(escape_unicode('a'), ~\"\\\\x61\");\n-    assert_eq!(escape_unicode('\\u011b'), ~\"\\\\u011b\");\n-    assert_eq!(escape_unicode('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n+    assert_eq!('\\x00'.escape_unicode(), ~\"\\\\x00\");\n+    assert_eq!('\\n'.escape_unicode(), ~\"\\\\x0a\");\n+    assert_eq!(' '.escape_unicode(), ~\"\\\\x20\");\n+    assert_eq!('a'.escape_unicode(), ~\"\\\\x61\");\n+    assert_eq!('\\u011b'.escape_unicode(), ~\"\\\\u011b\");\n+    assert_eq!('\\U0001d4b6'.escape_unicode(), ~\"\\\\U0001d4b6\");\n }"}, {"sha": "78273c51b526a532118fd35c936409a1638ebdb5", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24c2be3323f088dc0e8024fc503198b2a535a09e/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c2be3323f088dc0e8024fc503198b2a535a09e/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=24c2be3323f088dc0e8024fc503198b2a535a09e", "patch": "@@ -29,6 +29,7 @@ pub use io::{print, println};\n \n pub use clone::{Clone, DeepClone};\n pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n+pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use old_iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};"}]}