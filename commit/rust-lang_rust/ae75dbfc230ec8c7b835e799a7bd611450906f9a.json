{"sha": "ae75dbfc230ec8c7b835e799a7bd611450906f9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNzVkYmZjMjMwZWM4YzdiODM1ZTc5OWE3YmQ2MTE0NTA5MDZmOWE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-06-01T04:09:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-01T04:09:21Z"}, "message": "Rollup merge of #42286 - ollie27:rustdoc_assoc_const, r=GuillaumeGomez\n\nrustdoc: Cleanup associated const value rendering\n\nRather than (ab)using Debug for outputting the type in plain text use the\nalternate format parameter which already does exactly that. This fixes\ntype parameters for example which would output raw HTML.\n\nAlso cleans up adding parens around references to trait objects.", "tree": {"sha": "8675f4b81929e50c9f8edc5538ab013261308b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8675f4b81929e50c9f8edc5538ab013261308b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae75dbfc230ec8c7b835e799a7bd611450906f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae75dbfc230ec8c7b835e799a7bd611450906f9a", "html_url": "https://github.com/rust-lang/rust/commit/ae75dbfc230ec8c7b835e799a7bd611450906f9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae75dbfc230ec8c7b835e799a7bd611450906f9a/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbc9d71b179bfe7e25704c17a574b8f579d3f776", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9d71b179bfe7e25704c17a574b8f579d3f776", "html_url": "https://github.com/rust-lang/rust/commit/dbc9d71b179bfe7e25704c17a574b8f579d3f776"}, {"sha": "86ea93e83cc0d0dbe59067d0154c6e32e73f094a", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ea93e83cc0d0dbe59067d0154c6e32e73f094a", "html_url": "https://github.com/rust-lang/rust/commit/86ea93e83cc0d0dbe59067d0154c6e32e73f094a"}], "stats": {"total": 230, "additions": 74, "deletions": 156}, "files": [{"sha": "593477b066583ecdd886b4f81160007d916f802c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ae75dbfc230ec8c7b835e799a7bd611450906f9a", "patch": "@@ -1487,7 +1487,7 @@ pub struct PolyTrait {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/TyCtxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Type {\n     /// structs/enums/traits (most that'd be an hir::TyPath)\n     ResolvedPath {"}, {"sha": "6111ea073dd1906b92e102615026e5210cda3a9c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 53, "deletions": 153, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ae75dbfc230ec8c7b835e799a7bd611450906f9a", "patch": "@@ -106,16 +106,6 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     }\n }\n \n-impl<'a, T: fmt::Debug> fmt::Debug for CommaSep<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        for (i, item) in self.0.iter().enumerate() {\n-            if i != 0 { write!(f, \", \")?; }\n-            fmt::Debug::fmt(item, f)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n impl<'a> fmt::Display for TyParamBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &TyParamBounds(bounds) = self;\n@@ -469,8 +459,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n-                 print_all: bool, use_absolute: bool, is_not_debug: bool,\n-                 need_paren: bool) -> fmt::Result {\n+                 print_all: bool, use_absolute: bool) -> fmt::Result {\n     let empty = clean::PathSegment {\n                     name: String::new(),\n                     params: clean::PathParameters::Parenthesized {\n@@ -499,13 +488,9 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                     } else {\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n-                        if is_not_debug {\n-                            write!(w, \"<a class=\\\"mod\\\" href=\\\"{}index.html\\\">{}</a>::\",\n-                                   root,\n-                                   seg.name)?;\n-                        } else {\n-                            write!(w, \"{}::\", seg.name)?;\n-                        }\n+                        write!(w, \"<a class=\\\"mod\\\" href=\\\"{}index.html\\\">{}</a>::\",\n+                               root,\n+                               seg.name)?;\n                     }\n                 }\n             }\n@@ -517,39 +502,21 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        if is_not_debug {\n-            write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n-        } else {\n-            write!(w, \"{:?}{}\", HRef::new(did, &last.name), last.params)?;\n-        }\n+        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n     } else {\n-        if is_not_debug {\n-            let path = if use_absolute {\n-                match href(did) {\n-                    Some((_, _, fqp)) => format!(\"{}::{}\",\n-                                                 fqp[..fqp.len()-1].join(\"::\"),\n-                                                 HRef::new(did, fqp.last()\n-                                                                   .unwrap_or(&String::new()))),\n-                    None => format!(\"{}\", HRef::new(did, &last.name)),\n+        let path = if use_absolute {\n+            match href(did) {\n+                Some((_, _, fqp)) => {\n+                    format!(\"{}::{}\",\n+                            fqp[..fqp.len() - 1].join(\"::\"),\n+                            HRef::new(did, fqp.last().unwrap_or(&String::new())))\n                 }\n-            } else {\n-                format!(\"{}\", HRef::new(did, &last.name))\n-            };\n-            write!(w, \"{}{}{}\", if need_paren { \"(\" } else { \"\" }, path, last.params)?;\n+                None => format!(\"{}\", HRef::new(did, &last.name)),\n+            }\n         } else {\n-            let path = if use_absolute {\n-                match href(did) {\n-                    Some((_, _, fqp)) => format!(\"{:?}::{:?}\",\n-                                                 fqp[..fqp.len()-1].join(\"::\"),\n-                                                 HRef::new(did, fqp.last()\n-                                                                   .unwrap_or(&String::new()))),\n-                    None => format!(\"{:?}\", HRef::new(did, &last.name)),\n-                }\n-            } else {\n-                format!(\"{:?}\", HRef::new(did, &last.name))\n-            };\n-            write!(w, \"{}{}{}\", if need_paren { \"(\" } else { \"\" }, path, last.params)?;\n-        }\n+            format!(\"{}\", HRef::new(did, &last.name))\n+        };\n+        write!(w, \"{}{}\", path, last.params)?;\n     }\n     Ok(())\n }\n@@ -600,17 +567,13 @@ fn primitive_link(f: &mut fmt::Formatter,\n \n /// Helper to render type parameters\n fn tybounds(w: &mut fmt::Formatter,\n-            typarams: &Option<Vec<clean::TyParamBound>>,\n-            need_paren: bool) -> fmt::Result {\n+            typarams: &Option<Vec<clean::TyParamBound>>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n             for param in params {\n                 write!(w, \" + \")?;\n                 fmt::Display::fmt(param, w)?;\n             }\n-            if need_paren {\n-                write!(w, \")\")?;\n-            }\n             Ok(())\n         }\n         None => Ok(())\n@@ -637,30 +600,18 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-impl<'a> fmt::Debug for HRef<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.text)\n-    }\n-}\n-\n-fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n-            is_not_debug: bool, is_ref: bool) -> fmt::Result {\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n     match *t {\n         clean::Generic(ref name) => {\n             f.write_str(name)\n         }\n         clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n             // Paths like T::Output and Self::Output should be rendered with all segments\n-            let need_paren = match *typarams {\n-                Some(ref v) => !v.is_empty(),\n-                _ => false,\n-            } && is_ref;\n-            resolved_path(f, did, path, is_generic, use_absolute, is_not_debug, need_paren)?;\n-            tybounds(f, typarams, need_paren)\n+            resolved_path(f, did, path, is_generic, use_absolute)?;\n+            tybounds(f, typarams)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) if is_not_debug => primitive_link(f, prim, prim.as_str()),\n-        clean::Primitive(prim) => write!(f, \"{}\", prim.as_str()),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(f, \"{}{}fn{:#}{:#}\",\n@@ -678,30 +629,26 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] if is_not_debug => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n-                &[] => write!(f, \"()\"),\n-                &[ref one] if is_not_debug => {\n+                &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n+                &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     //carry f.alternate() into this display w/o branching manually\n                     fmt::Display::fmt(one, f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-                &[ref one] => write!(f, \"({:?},)\", one),\n-                many if is_not_debug => {\n+                many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     fmt::Display::fmt(&CommaSep(&many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n-                many => write!(f, \"({:?})\", &CommaSep(&many)),\n             }\n         }\n-        clean::Vector(ref t) if is_not_debug => {\n+        clean::Vector(ref t) => {\n             primitive_link(f, PrimitiveType::Slice, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n-        clean::Vector(ref t) => write!(f, \"[{:?}]\", t),\n-        clean::FixedVector(ref t, ref s) if is_not_debug => {\n+        clean::FixedVector(ref t, ref s) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             if f.alternate() {\n@@ -712,17 +659,10 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                                &format!(\"; {}]\", Escape(s)))\n             }\n         }\n-        clean::FixedVector(ref t, ref s) => {\n-            if f.alternate() {\n-                write!(f, \"[{:?}; {}]\", t, s)\n-            } else {\n-                write!(f, \"[{:?}; {}]\", t, Escape(s))\n-            }\n-        }\n         clean::Never => f.write_str(\"!\"),\n         clean::RawPointer(m, ref t) => {\n             match **t {\n-                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} if is_not_debug => {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n@@ -731,21 +671,11 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                                        &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                 }\n-                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                    if f.alternate() {\n-                        write!(f, \"*{}{:#?}\", RawMutableSpace(m), t)\n-                    } else {\n-                        write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n-                    }\n-                }\n-                _ if is_not_debug => {\n+                _ => {\n                     primitive_link(f, clean::PrimitiveType::RawPointer,\n                                    &format!(\"*{}\", RawMutableSpace(m)))?;\n                     fmt::Display::fmt(t, f)\n                 }\n-                _ => {\n-                    write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n-                }\n             }\n         }\n         clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n@@ -757,7 +687,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n             match **ty {\n                 clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                     match **bt {\n-                        clean::Generic(_) if is_not_debug => {\n+                        clean::Generic(_) => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n@@ -766,14 +696,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n                             }\n                         }\n-                        clean::Generic(_) => {\n-                            if f.alternate() {\n-                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n-                            } else {\n-                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n-                            }\n-                        }\n-                        _ if is_not_debug => {\n+                        _ => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                                &format!(\"&{}{}[\", lt, m))?;\n@@ -785,26 +708,25 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n-                        _ => {\n-                            if f.alternate() {\n-                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n-                            } else {\n-                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n-                            }\n-                        }\n                     }\n                 }\n+                clean::ResolvedPath { typarams: Some(ref v), .. } if !v.is_empty() => {\n+                    if f.alternate() {\n+                        write!(f, \"&{}{}\", lt, m)?;\n+                    } else {\n+                        write!(f, \"&amp;{}{}\", lt, m)?;\n+                    }\n+                    write!(f, \"(\")?;\n+                    fmt_type(&ty, f, use_absolute)?;\n+                    write!(f, \")\")\n+                }\n                 _ => {\n                     if f.alternate() {\n                         write!(f, \"&{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute, is_not_debug, true)\n+                        fmt_type(&ty, f, use_absolute)\n                     } else {\n-                        if is_not_debug {\n-                            write!(f, \"&amp;{}{}\", lt, m)?;\n-                        } else {\n-                            write!(f, \"&{}{}\", lt, m)?;\n-                        }\n-                        fmt_type(&ty, f, use_absolute, is_not_debug, true)\n+                        write!(f, \"&amp;{}{}\", lt, m)?;\n+                        fmt_type(&ty, f, use_absolute)\n                     }\n                 }\n             }\n@@ -833,32 +755,16 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                 _ => true,\n             };\n             if f.alternate() {\n-                if is_not_debug {\n-                    if should_show_cast {\n-                        write!(f, \"<{:#} as {:#}>::\", self_type, trait_)?\n-                    } else {\n-                        write!(f, \"{:#}::\", self_type)?\n-                    }\n+                if should_show_cast {\n+                    write!(f, \"<{:#} as {:#}>::\", self_type, trait_)?\n                 } else {\n-                    if should_show_cast {\n-                        write!(f, \"<{:#?} as {:#?}>::\", self_type, trait_)?\n-                    } else {\n-                        write!(f, \"{:#?}::\", self_type)?\n-                    }\n+                    write!(f, \"{:#}::\", self_type)?\n                 }\n             } else {\n-                if is_not_debug {\n-                    if should_show_cast {\n-                        write!(f, \"&lt;{} as {}&gt;::\", self_type, trait_)?\n-                    } else {\n-                        write!(f, \"{}::\", self_type)?\n-                    }\n+                if should_show_cast {\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type, trait_)?\n                 } else {\n-                    if should_show_cast {\n-                        write!(f, \"<{:?} as {:?}>::\", self_type, trait_)?\n-                    } else {\n-                        write!(f, \"{:?}::\", self_type)?\n-                    }\n+                    write!(f, \"{}::\", self_type)?\n                 }\n             };\n             match *trait_ {\n@@ -874,7 +780,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                 //        look at).\n                 box clean::ResolvedPath { did, ref typarams, .. } => {\n                     let path = clean::Path::singleton(name.clone());\n-                    resolved_path(f, did, &path, true, use_absolute, is_not_debug, false)?;\n+                    resolved_path(f, did, &path, true, use_absolute)?;\n \n                     // FIXME: `typarams` are not rendered, and this seems bad?\n                     drop(typarams);\n@@ -893,13 +799,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n \n impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_type(self, f, false, true, false)\n-    }\n-}\n-\n-impl fmt::Debug for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_type(self, f, false, false, false)\n+        fmt_type(self, f, false)\n     }\n }\n \n@@ -933,7 +833,7 @@ fn fmt_impl(i: &clean::Impl,\n         write!(f, \" for \")?;\n     }\n \n-    fmt_type(&i.for_, f, use_absolute, true, false)?;\n+    fmt_type(&i.for_, f, use_absolute)?;\n \n     fmt::Display::fmt(&WhereClause { gens: &i.generics, indent: 0, end_newline: true }, f)?;\n     Ok(())\n@@ -1139,7 +1039,7 @@ impl fmt::Display for clean::Import {\n impl fmt::Display for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false, true, false),\n+            Some(did) => resolved_path(f, did, &self.path, true, false),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {"}, {"sha": "a588460d467d2cc6597acfc5214b90e0eea6708c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ae75dbfc230ec8c7b835e799a7bd611450906f9a", "patch": "@@ -1662,9 +1662,9 @@ fn md_render_assoc_item(item: &clean::Item) -> String {\n     match item.inner {\n         clean::AssociatedConstItem(ref ty, ref default) => {\n             if let Some(default) = default.as_ref() {\n-                format!(\"```\\n{}: {:?} = {}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty, default)\n+                format!(\"```\\n{}: {:#} = {}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty, default)\n             } else {\n-                format!(\"```\\n{}: {:?}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty)\n+                format!(\"```\\n{}: {:#}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty)\n             }\n         }\n         _ => String::new(),"}, {"sha": "04709407e58a89cbf2b93d1c80ff741be15cd24e", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae75dbfc230ec8c7b835e799a7bd611450906f9a/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=ae75dbfc230ec8c7b835e799a7bd611450906f9a", "patch": "@@ -26,3 +26,21 @@ impl Bar {\n     // @has - '//*[@class=\"docblock\"]' 'BAR: usize = 3'\n     pub const BAR: usize = 3;\n }\n+\n+pub struct Baz<'a, U: 'a, T>(T, &'a [U]);\n+\n+impl Bar {\n+    // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.BAZ\"]' \\\n+    //      \"const BAZ: Baz<'static, u8, u32>\"\n+    // @has - '//*[@class=\"docblock\"]' \"BAZ: Baz<'static, u8, u32> = Baz(321, &[1, 2, 3])\"\n+    pub const BAZ: Baz<'static, u8, u32> = Baz(321, &[1, 2, 3]);\n+}\n+\n+pub fn f(_: &(ToString + 'static)) {}\n+\n+impl Bar {\n+    // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.F\"]' \\\n+    //      \"const F: fn(_: &(ToString + 'static))\"\n+    // @has - '//*[@class=\"docblock\"]' \"F: fn(_: &(ToString + 'static)) = f\"\n+    pub const F: fn(_: &(ToString + 'static)) = f;\n+}"}]}