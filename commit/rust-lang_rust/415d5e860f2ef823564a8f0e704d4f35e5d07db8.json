{"sha": "415d5e860f2ef823564a8f0e704d4f35e5d07db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNWQ1ZTg2MGYyZWY4MjM1NjRhOGYwZTcwNGQ0ZjM1ZTVkMDdkYjg=", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-08-25T22:03:09Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-08-25T22:03:09Z"}, "message": "Remove BitRelations impls for SparseBitSet, add optimizations", "tree": {"sha": "240e361fb57068958b8d7292988cb33b37e1ccd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/240e361fb57068958b8d7292988cb33b37e1ccd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/415d5e860f2ef823564a8f0e704d4f35e5d07db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/415d5e860f2ef823564a8f0e704d4f35e5d07db8", "html_url": "https://github.com/rust-lang/rust/commit/415d5e860f2ef823564a8f0e704d4f35e5d07db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/415d5e860f2ef823564a8f0e704d4f35e5d07db8/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cf3786ba48198a54f447274d4928e538b9159bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf3786ba48198a54f447274d4928e538b9159bd", "html_url": "https://github.com/rust-lang/rust/commit/6cf3786ba48198a54f447274d4928e538b9159bd"}], "stats": {"total": 92, "additions": 29, "deletions": 63}, "files": [{"sha": "46b1c554a61df09d2b65fda38b743a7bdceea2a2", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 29, "deletions": 63, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/415d5e860f2ef823564a8f0e704d4f35e5d07db8/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/415d5e860f2ef823564a8f0e704d4f35e5d07db8/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=415d5e860f2ef823564a8f0e704d4f35e5d07db8", "patch": "@@ -262,86 +262,50 @@ fn sparse_intersect<T: Idx>(\n     set: &mut SparseBitSet<T>,\n     other_contains: impl Fn(&T) -> bool,\n ) -> bool {\n-    let mut changed = false;\n-    for i in (0..set.len()).rev() {\n-        if !other_contains(&set.elems[i]) {\n-            set.elems.remove(i);\n-            changed = true;\n-        }\n-    }\n-    changed\n-}\n-\n-impl<T: Idx> BitRelations<SparseBitSet<T>> for BitSet<T> {\n-    fn union(&mut self, other: &SparseBitSet<T>) -> bool {\n-        sequential_update(|elem| self.insert(elem), other.iter().cloned())\n-    }\n-\n-    fn subtract(&mut self, other: &SparseBitSet<T>) -> bool {\n-        sequential_update(|elem| self.remove(elem), other.iter().cloned())\n-    }\n-\n-    fn intersect(&mut self, other: &SparseBitSet<T>) -> bool {\n-        self.intersect(&other.to_dense())\n-    }\n+    let size = set.elems.len();\n+    set.elems.retain(|elem| other_contains(elem));\n+    set.elems.len() != size\n }\n \n-impl<T: Idx> BitRelations<BitSet<T>> for SparseBitSet<T> {\n-    fn union(&mut self, other: &BitSet<T>) -> bool {\n-        sequential_update(|elem| self.insert(elem), other.iter())\n-    }\n-\n-    fn subtract(&mut self, other: &BitSet<T>) -> bool {\n-        sequential_update(|elem| self.remove(elem), other.iter())\n-    }\n-\n-    fn intersect(&mut self, other: &BitSet<T>) -> bool {\n-        sparse_intersect(self, |el| other.contains(*el))\n-    }\n-}\n-\n-impl<T: Idx> BitRelations<SparseBitSet<T>> for SparseBitSet<T> {\n-    fn union(&mut self, other: &SparseBitSet<T>) -> bool {\n-        sequential_update(|elem| self.insert(elem), other.iter().cloned())\n-    }\n-\n-    fn subtract(&mut self, other: &SparseBitSet<T>) -> bool {\n-        sequential_update(|elem| self.insert(elem), other.iter().cloned())\n-    }\n-\n-    fn intersect(&mut self, other: &SparseBitSet<T>) -> bool {\n-        sparse_intersect(self, |el| other.contains(*el))\n-    }\n-}\n-\n-impl<T: Idx, S> BitRelations<HybridBitSet<T>> for S\n-where\n-    S: BitRelations<BitSet<T>> + BitRelations<SparseBitSet<T>>,\n-{\n+impl<T: Idx> BitRelations<HybridBitSet<T>> for BitSet<T> {\n     fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size());\n         match other {\n-            HybridBitSet::Sparse(sparse) => self.union(sparse),\n+            HybridBitSet::Sparse(sparse) => {\n+                sequential_update(|elem| self.insert(elem), sparse.iter().cloned())\n+            }\n             HybridBitSet::Dense(dense) => self.union(dense),\n         }\n     }\n \n     fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size());\n         match other {\n-            HybridBitSet::Sparse(sparse) => self.subtract(sparse),\n+            HybridBitSet::Sparse(sparse) => {\n+                sequential_update(|elem| self.remove(elem), sparse.iter().cloned())\n+            }\n             HybridBitSet::Dense(dense) => self.subtract(dense),\n         }\n     }\n \n     fn intersect(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size());\n         match other {\n-            HybridBitSet::Sparse(sparse) => self.intersect(sparse),\n+            HybridBitSet::Sparse(sparse) => {\n+                let n = self.count();\n+                let mut sparse_copy = sparse.clone();\n+                sparse_intersect(&mut sparse_copy, |el| !self.contains(*el));\n+                *self = sparse_copy.to_dense();\n+                self.count() != n\n+            }\n             HybridBitSet::Dense(dense) => self.intersect(dense),\n         }\n     }\n }\n \n impl<T: Idx> BitRelations<HybridBitSet<T>> for HybridBitSet<T> {\n     fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size());\n         match self {\n             HybridBitSet::Sparse(self_sparse) => {\n                 match other {\n@@ -385,20 +349,22 @@ impl<T: Idx> BitRelations<HybridBitSet<T>> for HybridBitSet<T> {\n     }\n \n     fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n-        // FIXME(willcrichton): should there be an optimized sparse / dense version?\n+        assert_eq!(self.domain_size(), other.domain_size());\n         match self {\n-            HybridBitSet::Sparse(self_sparse) => self_sparse.subtract(other),\n+            HybridBitSet::Sparse(self_sparse) => {\n+                sequential_update(|elem| self_sparse.remove(elem), other.iter())\n+            }\n             HybridBitSet::Dense(self_dense) => self_dense.subtract(other),\n         }\n     }\n \n     fn intersect(&mut self, other: &HybridBitSet<T>) -> bool {\n-        // FIXME(willcrichton): should there be an optimized sparse / dense version?\n+        assert_eq!(self.domain_size(), other.domain_size());\n         match self {\n-            HybridBitSet::Sparse(self_sparse) => self_sparse.intersect(other),\n-            HybridBitSet::Dense(self_dense) => {\n-                <BitSet<T> as BitRelations<HybridBitSet<T>>>::intersect(self_dense, other)\n+            HybridBitSet::Sparse(self_sparse) => {\n+                sparse_intersect(self_sparse, |elem| other.contains(*elem))\n             }\n+            HybridBitSet::Dense(self_dense) => self_dense.intersect(other),\n         }\n     }\n }"}]}