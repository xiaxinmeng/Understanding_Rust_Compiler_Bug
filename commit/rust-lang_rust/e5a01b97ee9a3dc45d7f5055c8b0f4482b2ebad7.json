{"sha": "e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "node_id": "C_kwDOAAsO6NoAKGU1YTAxYjk3ZWU5YTNkYzQ1ZDdmNTA1NWM4YjBmNDQ4MmIyZWJhZDc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-06T12:27:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-06T12:27:40Z"}, "message": "Rollup merge of #104439 - ferrocene:pa-generate-copyright, r=pnkfelix\n\nAdd prototype to generate `COPYRIGHT` from REUSE metadata\n\nThis PR adds a prototype to generate the `COPYRIGHT` file from the metadata gathered with REUSE. There are two new tools:\n\n* `src/tools/collect-license-metadata` invokes REUSE, parses its output and stores a concise JSON representation of the metadata in `src/etc/license-metadata.json`.\n* `src/tools/generate-copyright` parses the metadata generated above, (in the future will) gather crate dependencies metadata, and renders the `COPYRIGHT.md` file.\n\nNote that since the contents of those files are currently incorrect, rather than outputting in the paths above, the files will be stored in `build/` and not committed. This will be changed once we're confident about the metadata.\n\nEventually, `src/etc/license-metadata.json` will be committed into the repository and verified to be up to date by CI (similar to our GitHub Actions configuration), to avoid having people install REUSE on their local machine in most cases.\n\nYou can see the (incorrect) generated files in https://gist.github.com/pietroalbini/3f3f22b6f9cc8533abf7494b6a50cf97.\n\nr? `@pnkfelix`", "tree": {"sha": "f885419104becd80c9114c525cf823d993758d43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f885419104becd80c9114c525cf823d993758d43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjjzU8CRBK7hj4Ov3rIwAAgfcIAAIepIuXy4fuxqMPVN2JScm+\nfOgfKzjRIO5nZxV/xWPIl2WNrmBWPA0QMd+StplmOXOzZGhlpD3082FV7vJLMh97\nAeSgl9J8y9eGTMgzQwT9ckhJDKNxUakbhmoNFmmWeeVhYwdvMZ0ff4Q3bBw/YAlm\nL7F4HbBXKf9+wdfLN0wH8AlGJysX+1rSdq9apzQkAd5ogMVos07IDCrYJaHQetjK\n+vTC6W6FPq3aEMPoHffvsUoetXkZtICBDEZoRthwLuSC/8Z5TJXobxauTSf482i1\nkLbPQNITYZ3mJMB1dL5c6ykLoq9USEKQYAnkJpVbazR037fL2UyT/w0Q+hxdtP0=\n=PxmP\n-----END PGP SIGNATURE-----\n", "payload": "tree f885419104becd80c9114c525cf823d993758d43\nparent 9db224fc908059986c179fc6ec433944e9cfce50\nparent f8a7123b276ed18e6cdd488818a8f4e5e3e1cf94\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670329660 +0100\ncommitter GitHub <noreply@github.com> 1670329660 +0100\n\nRollup merge of #104439 - ferrocene:pa-generate-copyright, r=pnkfelix\n\nAdd prototype to generate `COPYRIGHT` from REUSE metadata\n\nThis PR adds a prototype to generate the `COPYRIGHT` file from the metadata gathered with REUSE. There are two new tools:\n\n* `src/tools/collect-license-metadata` invokes REUSE, parses its output and stores a concise JSON representation of the metadata in `src/etc/license-metadata.json`.\n* `src/tools/generate-copyright` parses the metadata generated above, (in the future will) gather crate dependencies metadata, and renders the `COPYRIGHT.md` file.\n\nNote that since the contents of those files are currently incorrect, rather than outputting in the paths above, the files will be stored in `build/` and not committed. This will be changed once we're confident about the metadata.\n\nEventually, `src/etc/license-metadata.json` will be committed into the repository and verified to be up to date by CI (similar to our GitHub Actions configuration), to avoid having people install REUSE on their local machine in most cases.\n\nYou can see the (incorrect) generated files in https://gist.github.com/pietroalbini/3f3f22b6f9cc8533abf7494b6a50cf97.\n\nr? `@pnkfelix`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "html_url": "https://github.com/rust-lang/rust/commit/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db224fc908059986c179fc6ec433944e9cfce50", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db224fc908059986c179fc6ec433944e9cfce50", "html_url": "https://github.com/rust-lang/rust/commit/9db224fc908059986c179fc6ec433944e9cfce50"}, {"sha": "f8a7123b276ed18e6cdd488818a8f4e5e3e1cf94", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a7123b276ed18e6cdd488818a8f4e5e3e1cf94", "html_url": "https://github.com/rust-lang/rust/commit/f8a7123b276ed18e6cdd488818a8f4e5e3e1cf94"}], "stats": {"total": 719, "additions": 719, "deletions": 0}, "files": [{"sha": "150a70341f5859c37b4a11800a6a5acb064ae6d8", "filename": "Cargo.lock", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -581,6 +581,7 @@ dependencies = [\n  \"libc\",\n  \"num-integer\",\n  \"num-traits\",\n+ \"serde\",\n  \"time\",\n  \"winapi\",\n ]\n@@ -730,6 +731,16 @@ dependencies = [\n  \"rustc-semver\",\n ]\n \n+[[package]]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"spdx-rs\",\n+]\n+\n [[package]]\n name = \"color-eyre\"\n version = \"0.6.2\"\n@@ -1552,6 +1563,15 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"generate-copyright\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"generic-array\"\n version = \"0.14.4\"\n@@ -4864,6 +4884,35 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"spdx-expression\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"53d7ac03c67c572d85049d6db815e20a4a19b41b3d5cca732ac582342021ad77\"\n+dependencies = [\n+ \"nom\",\n+ \"serde\",\n+ \"thiserror\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"spdx-rs\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3c02f6eb7e7b4100c272f685a9ccaccaab302324e8c7ec3e2ee72340fb29ff3\"\n+dependencies = [\n+ \"chrono\",\n+ \"log\",\n+ \"nom\",\n+ \"serde\",\n+ \"spdx-expression\",\n+ \"strum\",\n+ \"strum_macros\",\n+ \"thiserror\",\n+ \"uuid\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.2.0\"\n@@ -4967,6 +5016,25 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n \n+[[package]]\n+name = \"strum\"\n+version = \"0.24.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"063e6045c0e62079840579a7e47a355ae92f60eb74daaf156fb1e84ba164e63f\"\n+\n+[[package]]\n+name = \"strum_macros\"\n+version = \"0.24.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.102\"\n@@ -5596,6 +5664,15 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n \n+[[package]]\n+name = \"uuid\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+]\n+\n [[package]]\n name = \"valuable\"\n version = \"0.1.0\""}, {"sha": "000c10a1f906d6c161f1835651754679e35c3bd9", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -39,6 +39,8 @@ members = [\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\",\n   \"src/tools/lld-wrapper\",\n+  \"src/tools/collect-license-metadata\",\n+  \"src/tools/generate-copyright\",\n ]\n \n exclude = ["}, {"sha": "ca54cbd2d68dc213051f86673ddf3e7fa965cba7", "filename": "config.toml.example", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -255,6 +255,16 @@ changelog-seen = 2\n # Defaults to the Python interpreter used to execute x.py\n #python = \"python\"\n \n+# The path to the REUSE executable to use. Note that REUSE is not required in\n+# most cases, as our tooling relies on a cached (and shrinked) copy of the\n+# REUSE output present in the git repository and in our source tarballs.\n+#\n+# REUSE is only needed if your changes caused the overral licensing of the\n+# repository to change, and the cached copy has to be regenerated.\n+#\n+# Defaults to the \"reuse\" command in the system path.\n+#reuse = \"reuse\"\n+\n # Force Cargo to check that Cargo.lock describes the precise dependency\n # set that all the Cargo.toml files create, instead of updating it.\n #locked-deps = false"}, {"sha": "8ee6d49da8f0e419b4fc9ff2898a4e21f5c47bae", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -754,6 +754,8 @@ impl<'a> Builder<'a> {\n                 run::BumpStage0,\n                 run::ReplaceVersionPlaceholder,\n                 run::Miri,\n+                run::CollectLicenseMetadata,\n+                run::GenerateCopyright,\n             ),\n             // These commands either don't use paths, or they're special-cased in Build::build()\n             Kind::Clean | Kind::Format | Kind::Setup => vec![],"}, {"sha": "d8c15c76e2d615b3a936a0b4e8616077a92d3c87", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -213,6 +213,7 @@ pub struct Config {\n     pub npm: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n     pub python: Option<PathBuf>,\n+    pub reuse: Option<PathBuf>,\n     pub cargo_native_static: bool,\n     pub configure_args: Vec<String>,\n \n@@ -611,6 +612,7 @@ define_config! {\n         nodejs: Option<String> = \"nodejs\",\n         npm: Option<String> = \"npm\",\n         python: Option<String> = \"python\",\n+        reuse: Option<String> = \"reuse\",\n         locked_deps: Option<bool> = \"locked-deps\",\n         vendor: Option<bool> = \"vendor\",\n         full_bootstrap: Option<bool> = \"full-bootstrap\",\n@@ -1004,6 +1006,7 @@ impl Config {\n         config.npm = build.npm.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n+        config.reuse = build.reuse.map(PathBuf::from);\n         config.submodules = build.submodules;\n         set(&mut config.low_priority, build.low_priority);\n         set(&mut config.compiler_docs, build.compiler_docs);"}, {"sha": "05de51f8cc57933b886fb6a7b1d2436e4c728316", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -1,3 +1,4 @@\n+use std::path::PathBuf;\n use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -189,3 +190,65 @@ impl Step for Miri {\n         builder.run(&mut miri);\n     }\n }\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CollectLicenseMetadata;\n+\n+impl Step for CollectLicenseMetadata {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/collect-license-metadata\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(CollectLicenseMetadata);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let Some(reuse) = &builder.config.reuse else {\n+            panic!(\"REUSE is required to collect the license metadata\");\n+        };\n+\n+        // Temporary location, it will be moved to src/etc once it's accurate.\n+        let dest = builder.out.join(\"license-metadata.json\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::CollectLicenseMetadata);\n+        cmd.env(\"REUSE_EXE\", reuse);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct GenerateCopyright;\n+\n+impl Step for GenerateCopyright {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/generate-copyright\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(GenerateCopyright);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let license_metadata = builder.ensure(CollectLicenseMetadata);\n+\n+        // Temporary location, it will be moved to the proper one once it's accurate.\n+        let dest = builder.out.join(\"COPYRIGHT.md\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::GenerateCopyright);\n+        cmd.env(\"LICENSE_METADATA\", &license_metadata);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}"}, {"sha": "8a40b0f64f4b6c5673ce6fc1c885f4622958c0e0", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -140,6 +140,13 @@ than building it.\n         .map(|p| cmd_finder.must_have(p))\n         .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n+    build.config.reuse = build\n+        .config\n+        .reuse\n+        .take()\n+        .map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"reuse\"));\n+\n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in &build.targets {"}, {"sha": "e0be4c432f168baceeb1a32666d3a1c482d94e90", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -380,6 +380,8 @@ bootstrap_tool!(\n     HtmlChecker, \"src/tools/html-checker\", \"html-checker\";\n     BumpStage0, \"src/tools/bump-stage0\", \"bump-stage0\";\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";\n+    CollectLicenseMetadata, \"src/tools/collect-license-metadata\", \"collect-license-metadata\";\n+    GenerateCopyright, \"src/tools/generate-copyright\", \"generate-copyright\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "d0820cfc2a0e46b1b1919337824ea24c7b17ea51", "filename": "src/tools/collect-license-metadata/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+anyhow = \"1.0.65\"\n+serde = { version = \"1.0.147\", features = [\"derive\"] }\n+serde_json = \"1.0.85\"\n+spdx-rs = \"0.5.1\""}, {"sha": "1c95b1bc8e96cdedb3b3a56b4b823ca85dcfc294", "filename": "src/tools/collect-license-metadata/src/licenses.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,65 @@\n+use std::collections::HashMap;\n+\n+const COPYRIGHT_PREFIXES: &[&str] = &[\"SPDX-FileCopyrightText:\", \"Copyright\", \"(c)\", \"(C)\", \"\u00a9\"];\n+\n+pub(crate) struct LicensesInterner {\n+    by_id: Vec<License>,\n+    by_struct: HashMap<License, usize>,\n+}\n+\n+impl LicensesInterner {\n+    pub(crate) fn new() -> Self {\n+        LicensesInterner { by_id: Vec::new(), by_struct: HashMap::new() }\n+    }\n+\n+    pub(crate) fn intern(&mut self, mut license: License) -> LicenseId {\n+        license.simplify();\n+        if let Some(id) = self.by_struct.get(&license) {\n+            LicenseId(*id)\n+        } else {\n+            let id = self.by_id.len();\n+            self.by_id.push(license.clone());\n+            self.by_struct.insert(license, id);\n+            LicenseId(id)\n+        }\n+    }\n+\n+    pub(crate) fn resolve(&self, id: LicenseId) -> &License {\n+        &self.by_id[id.0]\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize)]\n+#[serde(transparent)]\n+pub(crate) struct LicenseId(usize);\n+\n+#[derive(Clone, Hash, PartialEq, Eq, serde::Serialize)]\n+pub(crate) struct License {\n+    pub(crate) spdx: String,\n+    pub(crate) copyright: Vec<String>,\n+}\n+\n+impl License {\n+    fn simplify(&mut self) {\n+        self.remove_copyright_prefixes();\n+        self.copyright.sort();\n+        self.copyright.dedup();\n+    }\n+\n+    fn remove_copyright_prefixes(&mut self) {\n+        for copyright in &mut self.copyright {\n+            let mut stripped = copyright.trim();\n+            let mut previous_stripped;\n+            loop {\n+                previous_stripped = stripped;\n+                for pattern in COPYRIGHT_PREFIXES {\n+                    stripped = stripped.trim_start_matches(pattern).trim_start();\n+                }\n+                if stripped == previous_stripped {\n+                    break;\n+                }\n+            }\n+            *copyright = stripped.into();\n+        }\n+    }\n+}"}, {"sha": "ca2a6f4b8c8a28f72b33f57a211b7993d7181208", "filename": "src/tools/collect-license-metadata/src/main.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,30 @@\n+mod licenses;\n+mod path_tree;\n+mod reuse;\n+\n+use crate::licenses::LicensesInterner;\n+use anyhow::Error;\n+use std::path::PathBuf;\n+\n+fn main() -> Result<(), Error> {\n+    let reuse_exe: PathBuf = std::env::var_os(\"REUSE_EXE\").expect(\"Missing REUSE_EXE\").into();\n+    let dest: PathBuf = std::env::var_os(\"DEST\").expect(\"Missing DEST\").into();\n+\n+    let mut interner = LicensesInterner::new();\n+    let paths = crate::reuse::collect(&reuse_exe, &mut interner)?;\n+\n+    let mut tree = crate::path_tree::build(paths);\n+    tree.simplify();\n+\n+    if let Some(parent) = dest.parent() {\n+        std::fs::create_dir_all(parent)?;\n+    }\n+    std::fs::write(\n+        &dest,\n+        &serde_json::to_vec_pretty(&serde_json::json!({\n+            \"files\": crate::path_tree::expand_interned_licenses(tree, &interner),\n+        }))?,\n+    )?;\n+\n+    Ok(())\n+}"}, {"sha": "133ff6837378e0ff78150714b05d2da5aeeb9812", "filename": "src/tools/collect-license-metadata/src/path_tree.rs", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,294 @@\n+//! Tools like REUSE output per-file licensing information, but we need to condense it in the\n+//! minimum amount of data that still represents the same licensing metadata. This module is\n+//! responsible for that, by turning the list of paths into a tree and executing simplification\n+//! passes over the tree to remove redundant information.\n+\n+use crate::licenses::{License, LicenseId, LicensesInterner};\n+use std::collections::BTreeMap;\n+use std::path::{Path, PathBuf};\n+\n+#[derive(serde::Serialize)]\n+#[serde(rename_all = \"kebab-case\", tag = \"type\")]\n+pub(crate) enum Node<L> {\n+    Root { childs: Vec<Node<L>> },\n+    Directory { name: PathBuf, childs: Vec<Node<L>>, license: Option<L> },\n+    File { name: PathBuf, license: L },\n+    FileGroup { names: Vec<PathBuf>, license: L },\n+    Empty,\n+}\n+\n+impl Node<LicenseId> {\n+    pub(crate) fn simplify(&mut self) {\n+        self.merge_directories();\n+        self.collapse_in_licensed_directories();\n+        self.merge_directory_licenses();\n+        self.merge_file_groups();\n+        self.remove_empty();\n+    }\n+\n+    /// Initially, the build() function constructs a list of separate paths from the file\n+    /// system root down to each file, like so:\n+    ///\n+    /// ```text\n+    ///         \u250c\u2500\u25ba ./ \u2500\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u25ba src/ \u2500\u2500\u25ba main.rs\n+    ///         \u2502\n+    /// <root> \u2500\u253c\u2500\u25ba ./ \u2500\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u25ba Cargo.toml\n+    ///         \u2502\n+    ///         \u2514\u2500\u25ba ./ \u2500\u2500\u25ba library/ \u2500\u2500\u2500\u25ba std/ \u2500\u2500\u25ba Cargo.toml\n+    /// ```\n+    ///\n+    /// This pass is responsible for turning that into a proper directory tree:\n+    ///\n+    /// ```text\n+    ///                 \u250c\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u252c\u2500\u25ba src/ \u2500\u2500\u25ba main.rs\n+    ///                 \u2502                          \u2502\n+    /// <root> \u2500\u2500\u25ba ./ \u2500\u2500\u2524                          \u2514\u2500\u25ba Cargo.toml\n+    ///                 \u2502\n+    ///                 \u2514\u2500\u25ba library/ \u2500\u2500\u2500\u25ba std/ \u2500\u2500\u25ba Cargo.toml\n+    /// ```\n+    fn merge_directories(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, license: None, .. } => {\n+                let mut directories = BTreeMap::new();\n+                let mut files = Vec::new();\n+\n+                for child in childs.drain(..) {\n+                    match child {\n+                        Node::Directory { name, mut childs, license: None } => {\n+                            directories.entry(name).or_insert_with(Vec::new).append(&mut childs);\n+                        }\n+                        file @ Node::File { .. } => {\n+                            files.push(file);\n+                        }\n+                        Node::Empty => {}\n+                        Node::Root { .. } => {\n+                            panic!(\"can't have a root inside another element\");\n+                        }\n+                        Node::FileGroup { .. } => {\n+                            panic!(\"FileGroup should not be present at this stage\");\n+                        }\n+                        Node::Directory { license: Some(_), .. } => {\n+                            panic!(\"license should not be set at this stage\");\n+                        }\n+                    }\n+                }\n+\n+                childs.extend(directories.into_iter().map(|(name, childs)| Node::Directory {\n+                    name,\n+                    childs,\n+                    license: None,\n+                }));\n+                childs.append(&mut files);\n+\n+                for child in &mut *childs {\n+                    child.merge_directories();\n+                }\n+            }\n+            Node::Empty => {}\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {\n+                panic!(\"FileGroup should not be present at this stage\");\n+            }\n+            Node::Directory { license: Some(_), .. } => {\n+                panic!(\"license should not be set at this stage\");\n+            }\n+        }\n+    }\n+\n+    /// In our codebase, most files in a directory have the same license as the other files in that\n+    /// same directory, so it's redundant to store licensing metadata for all the files. Instead,\n+    /// we can add a license for a whole directory, and only record the exceptions to a directory\n+    /// licensing metadata.\n+    ///\n+    /// We cannot instead record only the difference to Rust's standard licensing, as the majority\n+    /// of the files in our repository are *not* licensed under Rust's standard licensing due to\n+    /// our inclusion of LLVM.\n+    fn collapse_in_licensed_directories(&mut self) {\n+        match self {\n+            Node::Directory { childs, license, .. } => {\n+                for child in &mut *childs {\n+                    child.collapse_in_licensed_directories();\n+                }\n+\n+                let mut licenses_count = BTreeMap::new();\n+                for child in &*childs {\n+                    let Some(license) = child.license() else { continue };\n+                    *licenses_count.entry(license).or_insert(0) += 1;\n+                }\n+\n+                let most_popular_license = licenses_count\n+                    .into_iter()\n+                    .max_by_key(|(_, count)| *count)\n+                    .map(|(license, _)| license);\n+\n+                if let Some(most_popular_license) = most_popular_license {\n+                    childs.retain(|child| child.license() != Some(most_popular_license));\n+                    *license = Some(most_popular_license);\n+                }\n+            }\n+            Node::Root { childs } => {\n+                for child in &mut *childs {\n+                    child.collapse_in_licensed_directories();\n+                }\n+            }\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {}\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    /// Reduce the depth of the tree by merging subdirectories with the same license as their\n+    /// parent directory into their parent, and adjusting the paths of the childs accordingly.\n+    fn merge_directory_licenses(&mut self) {\n+        match self {\n+            Node::Root { childs } => {\n+                for child in &mut *childs {\n+                    child.merge_directory_licenses();\n+                }\n+            }\n+            Node::Directory { childs, license, .. } => {\n+                let mut to_add = Vec::new();\n+                for child in &mut *childs {\n+                    child.merge_directory_licenses();\n+\n+                    let Node::Directory {\n+                        name: child_name,\n+                        childs: child_childs,\n+                        license: child_license,\n+                    } = child else { continue };\n+\n+                    if child_license != license {\n+                        continue;\n+                    }\n+                    for mut child_child in child_childs.drain(..) {\n+                        match &mut child_child {\n+                            Node::Root { .. } => {\n+                                panic!(\"can't have a root inside another element\");\n+                            }\n+                            Node::FileGroup { .. } => {\n+                                panic!(\"FileGroup should not be present at this stage\");\n+                            }\n+                            Node::Directory { name: child_child_name, .. } => {\n+                                *child_child_name = child_name.join(&child_child_name);\n+                            }\n+                            Node::File { name: child_child_name, .. } => {\n+                                *child_child_name = child_name.join(&child_child_name);\n+                            }\n+                            Node::Empty => {}\n+                        }\n+                        to_add.push(child_child);\n+                    }\n+\n+                    *child = Node::Empty;\n+                }\n+                childs.append(&mut to_add);\n+            }\n+            Node::Empty => {}\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {}\n+        }\n+    }\n+\n+    /// This pass groups multiple files in a directory with the same license into a single\n+    /// \"FileGroup\", so that the license of all those files can be reported as a group.\n+    ///\n+    /// Crucially this pass runs after collapse_in_licensed_directories, so the most common license\n+    /// will already be marked as the directory's license and won't be turned into a group.\n+    fn merge_file_groups(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, .. } => {\n+                let mut grouped = BTreeMap::new();\n+\n+                for child in &mut *childs {\n+                    child.merge_file_groups();\n+                    if let Node::File { name, license } = child {\n+                        grouped.entry(*license).or_insert_with(Vec::new).push(name.clone());\n+                        *child = Node::Empty;\n+                    }\n+                }\n+\n+                for (license, mut names) in grouped.into_iter() {\n+                    if names.len() == 1 {\n+                        childs.push(Node::File { license, name: names.pop().unwrap() });\n+                    } else {\n+                        childs.push(Node::FileGroup { license, names });\n+                    }\n+                }\n+            }\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => panic!(\"FileGroup should not be present at this stage\"),\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    /// Some nodes were replaced with Node::Empty to mark them for deletion. As the last step, make\n+    /// sure to remove them from the tree.\n+    fn remove_empty(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, .. } => {\n+                for child in &mut *childs {\n+                    child.remove_empty();\n+                }\n+                childs.retain(|child| !matches!(child, Node::Empty));\n+            }\n+            Node::FileGroup { .. } => {}\n+            Node::File { .. } => {}\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    fn license(&self) -> Option<LicenseId> {\n+        match self {\n+            Node::Directory { childs, license: Some(license), .. } if childs.is_empty() => {\n+                Some(*license)\n+            }\n+            Node::File { license, .. } => Some(*license),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn build(mut input: Vec<(PathBuf, LicenseId)>) -> Node<LicenseId> {\n+    let mut childs = Vec::new();\n+\n+    // Ensure reproducibility of all future steps.\n+    input.sort();\n+\n+    for (path, license) in input {\n+        let mut node = Node::File { name: path.file_name().unwrap().into(), license };\n+        for component in path.parent().unwrap_or_else(|| Path::new(\".\")).components().rev() {\n+            node = Node::Directory {\n+                name: component.as_os_str().into(),\n+                childs: vec![node],\n+                license: None,\n+            };\n+        }\n+\n+        childs.push(node);\n+    }\n+\n+    Node::Root { childs }\n+}\n+\n+/// Convert a `Node<LicenseId>` into a `Node<&License>`, expanding all interned license IDs with a\n+/// reference to the actual license metadata.\n+pub(crate) fn expand_interned_licenses(\n+    node: Node<LicenseId>,\n+    interner: &LicensesInterner,\n+) -> Node<&License> {\n+    match node {\n+        Node::Root { childs } => Node::Root {\n+            childs: childs.into_iter().map(|child| strip_interning(child, interner)).collect(),\n+        },\n+        Node::Directory { name, childs, license } => Node::Directory {\n+            childs: childs.into_iter().map(|child| strip_interning(child, interner)).collect(),\n+            license: license.map(|license| interner.resolve(license)),\n+            name,\n+        },\n+        Node::File { name, license } => Node::File { name, license: interner.resolve(license) },\n+        Node::FileGroup { names, license } => {\n+            Node::FileGroup { names, license: interner.resolve(license) }\n+        }\n+        Node::Empty => Node::Empty,\n+    }\n+}"}, {"sha": "d6b3772ba5159a9e4debcbdcecfdb20d05596668", "filename": "src/tools/collect-license-metadata/src/reuse.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,49 @@\n+use crate::licenses::{License, LicenseId, LicensesInterner};\n+use anyhow::Error;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n+use std::time::Instant;\n+\n+pub(crate) fn collect(\n+    reuse_exe: &Path,\n+    interner: &mut LicensesInterner,\n+) -> Result<Vec<(PathBuf, LicenseId)>, Error> {\n+    eprintln!(\"gathering license information from REUSE\");\n+    let start = Instant::now();\n+    let raw = &obtain_spdx_document(reuse_exe)?;\n+    eprintln!(\"finished gathering the license information from REUSE in {:.2?}\", start.elapsed());\n+\n+    let document = spdx_rs::parsers::spdx_from_tag_value(&raw)?;\n+\n+    let mut result = Vec::new();\n+    for file in document.file_information {\n+        let license = interner.intern(License {\n+            spdx: file.concluded_license.to_string(),\n+            copyright: file.copyright_text.split('\\n').map(|s| s.into()).collect(),\n+        });\n+\n+        result.push((file.file_name.into(), license));\n+    }\n+\n+    Ok(result)\n+}\n+\n+fn obtain_spdx_document(reuse_exe: &Path) -> Result<String, Error> {\n+    let output = Command::new(reuse_exe)\n+        .args(&[\"spdx\", \"--add-license-concluded\", \"--creator-person=bors\"])\n+        .stdout(Stdio::piped())\n+        .spawn()?\n+        .wait_with_output()?;\n+\n+    if !output.status.success() {\n+        eprintln!();\n+        eprintln!(\"Note that Rust requires some REUSE features that might not be present in the\");\n+        eprintln!(\"release you're using. Make sure your REUSE release includes these PRs:\");\n+        eprintln!();\n+        eprintln!(\" - https://github.com/fsfe/reuse-tool/pull/623\");\n+        eprintln!();\n+        anyhow::bail!(\"collecting licensing information with REUSE failed\");\n+    }\n+\n+    Ok(String::from_utf8(output.stdout)?)\n+}"}, {"sha": "899ef0f8a6c2650012a89523124e7f04baa96967", "filename": "src/tools/generate-copyright/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fgenerate-copyright%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fgenerate-copyright%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-copyright%2FCargo.toml?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"generate-copyright\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+anyhow = \"1.0.65\"\n+serde = { version = \"1.0.147\", features = [\"derive\"] }\n+serde_json = \"1.0.85\""}, {"sha": "d172c9e157bc859a4df2858bde58a5cd6e13d275", "filename": "src/tools/generate-copyright/src/main.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs?ref=e5a01b97ee9a3dc45d7f5055c8b0f4482b2ebad7", "patch": "@@ -0,0 +1,94 @@\n+use anyhow::Error;\n+use std::io::Write;\n+use std::path::PathBuf;\n+\n+fn main() -> Result<(), Error> {\n+    let dest = env_path(\"DEST\")?;\n+    let license_metadata = env_path(\"LICENSE_METADATA\")?;\n+\n+    let metadata: Metadata = serde_json::from_slice(&std::fs::read(&license_metadata)?)?;\n+\n+    let mut buffer = Vec::new();\n+    render_recursive(&metadata.files, &mut buffer, 0)?;\n+\n+    std::fs::write(&dest, &buffer)?;\n+\n+    Ok(())\n+}\n+\n+fn render_recursive(node: &Node, buffer: &mut Vec<u8>, depth: usize) -> Result<(), Error> {\n+    let prefix = std::iter::repeat(\"> \").take(depth + 1).collect::<String>();\n+\n+    match node {\n+        Node::Root { childs } => {\n+            for child in childs {\n+                render_recursive(child, buffer, depth)?;\n+            }\n+        }\n+        Node::Directory { name, childs, license } => {\n+            render_license(&prefix, std::iter::once(name), license, buffer)?;\n+            if !childs.is_empty() {\n+                writeln!(buffer, \"{prefix}\")?;\n+                writeln!(buffer, \"{prefix}*Exceptions:*\")?;\n+                for child in childs {\n+                    writeln!(buffer, \"{prefix}\")?;\n+                    render_recursive(child, buffer, depth + 1)?;\n+                }\n+            }\n+        }\n+        Node::FileGroup { names, license } => {\n+            render_license(&prefix, names.iter(), license, buffer)?;\n+        }\n+        Node::File { name, license } => {\n+            render_license(&prefix, std::iter::once(name), license, buffer)?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn render_license<'a>(\n+    prefix: &str,\n+    names: impl Iterator<Item = &'a String>,\n+    license: &License,\n+    buffer: &mut Vec<u8>,\n+) -> Result<(), Error> {\n+    for name in names {\n+        writeln!(buffer, \"{prefix}**`{name}`**  \")?;\n+    }\n+    writeln!(buffer, \"{prefix}License: `{}`  \", license.spdx)?;\n+    for (i, copyright) in license.copyright.iter().enumerate() {\n+        let suffix = if i == license.copyright.len() - 1 { \"\" } else { \"  \" };\n+        writeln!(buffer, \"{prefix}Copyright: {copyright}{suffix}\")?;\n+    }\n+\n+    Ok(())\n+}\n+\n+#[derive(serde::Deserialize)]\n+struct Metadata {\n+    files: Node,\n+}\n+\n+#[derive(serde::Deserialize)]\n+#[serde(rename_all = \"kebab-case\", tag = \"type\")]\n+pub(crate) enum Node {\n+    Root { childs: Vec<Node> },\n+    Directory { name: String, childs: Vec<Node>, license: License },\n+    File { name: String, license: License },\n+    FileGroup { names: Vec<String>, license: License },\n+}\n+\n+#[derive(serde::Deserialize)]\n+struct License {\n+    spdx: String,\n+    copyright: Vec<String>,\n+}\n+\n+fn env_path(var: &str) -> Result<PathBuf, Error> {\n+    if let Some(var) = std::env::var_os(var) {\n+        Ok(var.into())\n+    } else {\n+        anyhow::bail!(\"missing environment variable {var}\")\n+    }\n+}"}]}