{"sha": "5f43b099cd3e198d8f804399feca6680fd840f39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNDNiMDk5Y2QzZTE5OGQ4ZjgwNDM5OWZlY2E2NjgwZmQ4NDBmMzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-31T19:52:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-09T18:14:41Z"}, "message": "instantiate traversed binders rather than saving the scopes", "tree": {"sha": "c3cf05969ed65d466b01f209cbb7a859a6fe0d14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3cf05969ed65d466b01f209cbb7a859a6fe0d14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f43b099cd3e198d8f804399feca6680fd840f39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f43b099cd3e198d8f804399feca6680fd840f39", "html_url": "https://github.com/rust-lang/rust/commit/5f43b099cd3e198d8f804399feca6680fd840f39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f43b099cd3e198d8f804399feca6680fd840f39/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b9281562b7103be23e4546de9a4e5a886d2747", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b9281562b7103be23e4546de9a4e5a886d2747", "html_url": "https://github.com/rust-lang/rust/commit/39b9281562b7103be23e4546de9a4e5a886d2747"}], "stats": {"total": 117, "additions": 103, "deletions": 14}, "files": [{"sha": "f6939332b294dc896640cd2d905af1b083a89964", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 103, "deletions": 14, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5f43b099cd3e198d8f804399feca6680fd840f39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f43b099cd3e198d8f804399feca6680fd840f39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=5f43b099cd3e198d8f804399feca6680fd840f39", "patch": "@@ -15,7 +15,7 @@ use borrow_check::nll::ToRegionVid;\n use rustc::infer::canonical::{Canonical, CanonicalVarInfos};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::traits::query::Fallible;\n-use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n@@ -128,7 +128,7 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     /// how can we enforce that? I guess I could add some kind of\n     /// \"minimum universe constraint\" that we can feed to the NLL checker.\n     /// --> also, we know this doesn't happen\n-    canonical_var_values: IndexVec<CanonicalVar, Option<ScopesAndKind<'tcx>>>,\n+    canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -264,6 +264,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     /// equated, then equate it again.\n     fn equate_var(\n         &mut self,\n+        universal_regions: &UniversalRegions<'tcx>,\n         var: CanonicalVar,\n         b_kind: Kind<'tcx>,\n     ) -> RelateResult<'tcx, Kind<'tcx>> {\n@@ -274,21 +275,25 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n \n         // The canonical variable already had a value. Equate that\n         // value with `b`.\n-        let old_value = self.canonical_var_values[var].clone();\n-        if let Some(ScopesAndKind { scopes, kind }) = old_value {\n-            debug!(\"equate_var: installing kind={:?} scopes={:?}\", kind, scopes);\n-            let old_a_scopes = mem::replace(&mut self.a_scopes, scopes);\n-            let result = self.relate(&kind, &b_kind);\n+        if let Some(a_kind) = self.canonical_var_values[var] {\n+            debug!(\"equate_var: a_kind={:?}\", a_kind);\n+\n+            // The values we extract from `canonical_var_values` have\n+            // been \"instantiated\" and hence the set of scopes we have\n+            // doesn't matter -- just to be sure, put an empty vector\n+            // in there.\n+            let old_a_scopes = mem::replace(&mut self.a_scopes, vec![]);\n+            let result = self.relate(&a_kind, &b_kind);\n             self.a_scopes = old_a_scopes;\n+\n             debug!(\"equate_var: complete, result = {:?}\", result);\n             return result;\n         }\n \n         // Not yet. Capture the value from the RHS and carry on.\n-        self.canonical_var_values[var] = Some(ScopesAndKind {\n-            scopes: self.b_scopes.clone(),\n-            kind: b_kind,\n-        });\n+        let closed_kind =\n+            self.instantiate_traversed_binders(universal_regions, &self.b_scopes, b_kind);\n+        self.canonical_var_values[var] = Some(closed_kind);\n         debug!(\n             \"equate_var: capturing value {:?}\",\n             self.canonical_var_values[var]\n@@ -303,6 +308,31 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         // of over look this right now.\n         Ok(b_kind)\n     }\n+\n+    /// As we traverse types and pass through binders, we push the\n+    /// values for each of the regions bound by those binders onto\n+    /// `scopes`. This function goes through `kind` and replaces any\n+    /// references into those scopes with the corresponding free\n+    /// region. Thus the resulting value should have no escaping\n+    /// references to bound things and can be transported into other\n+    /// scopes.\n+    fn instantiate_traversed_binders(\n+        &self,\n+        universal_regions: &UniversalRegions<'tcx>,\n+        scopes: &[BoundRegionScope],\n+        kind: Kind<'tcx>,\n+    ) -> Kind<'tcx> {\n+        let k = kind.fold_with(&mut BoundReplacer {\n+            type_rel: self,\n+            first_free_index: ty::INNERMOST,\n+            universal_regions,\n+            scopes: scopes,\n+        });\n+\n+        assert!(!k.has_escaping_regions());\n+\n+        k\n+    }\n }\n \n impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n@@ -352,8 +382,21 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         // Watch out for the case that we are matching a `?T` against the\n         // right-hand side.\n         if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n-            self.equate_var(var, b.into())?;\n-            Ok(a)\n+            if let Some(&mut BorrowCheckContext {\n+                universal_regions, ..\n+            }) = self.borrowck_context\n+            {\n+                self.equate_var(universal_regions, var, b.into())?;\n+                Ok(a)\n+            } else {\n+                // if NLL is not enabled just ignore these variables\n+                // for now; in that case we're just doing a \"sanity\n+                // check\" anyway, and this only affects user-given\n+                // annotations like `let x: Vec<_> = ...` -- and then\n+                // only if the user uses type aliases to make a type\n+                // variable repeat more than once.\n+                Ok(a)\n+            }\n         } else {\n             debug!(\n                 \"tys(a={:?}, b={:?}, variance={:?})\",\n@@ -374,7 +417,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         }) = self.borrowck_context\n         {\n             if let ty::ReCanonical(var) = a {\n-                self.equate_var(*var, b.into())?;\n+                self.equate_var(universal_regions, *var, b.into())?;\n                 return Ok(a);\n             }\n \n@@ -545,3 +588,49 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n         false\n     }\n }\n+\n+/// When we encounter a binder like `for<..> fn(..)`, we actually have\n+/// to walk the `fn` value to find all the values bound by the `for`\n+/// (these are not explicitly present in the ty representation right\n+/// now). This visitor handles that: it descends the type, tracking\n+/// binder depth, and finds late-bound regions targeting the\n+/// `for<..`>.  For each of those, it creates an entry in\n+/// `bound_region_scope`.\n+struct BoundReplacer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+    first_free_index: ty::DebruijnIndex,\n+    universal_regions: &'me UniversalRegions<'tcx>,\n+    scopes: &'me [BoundRegionScope],\n+}\n+\n+impl TypeFolder<'gcx, 'tcx> for BoundReplacer<'me, 'bccx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.type_rel.tcx()\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+        self.first_free_index.shift_in(1);\n+        let result = t.super_fold_with(self);\n+        self.first_free_index.shift_out(1);\n+        result\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let tcx = self.tcx();\n+\n+        if let ty::ReLateBound(debruijn, _) = r {\n+            if *debruijn < self.first_free_index {\n+                return r;\n+            }\n+        }\n+\n+        let region_vid = self.type_rel.replace_bound_region(\n+            self.universal_regions,\n+            r,\n+            self.first_free_index,\n+            self.scopes,\n+        );\n+\n+        tcx.mk_region(ty::ReVar(region_vid))\n+    }\n+}"}]}