{"sha": "22e491ac7ed454d34669151a8b6464cb643c9b41", "node_id": "C_kwDOAAsO6NoAKDIyZTQ5MWFjN2VkNDU0ZDM0NjY5MTUxYThiNjQ2NGNiNjQzYzliNDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-13T18:51:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-13T18:51:07Z"}, "message": "Auto merge of #89861 - nbdd0121:closure, r=wesleywiser\n\nClosure capture cleanup & refactor\n\nFollow up of #89648\n\nEach commit is self-contained and the rationale/changes are documented in the commit message, so it's advisable to review commit by commit.\n\nThe code is significantly cleaner (at least IMO), but that could have some perf implication, so I'd suggest a perf run.\n\nr? `@wesleywiser`\ncc `@arora-aman`", "tree": {"sha": "8e30fdbc16b29cd272052aad7f885453ff789841", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e30fdbc16b29cd272052aad7f885453ff789841"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22e491ac7ed454d34669151a8b6464cb643c9b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22e491ac7ed454d34669151a8b6464cb643c9b41", "html_url": "https://github.com/rust-lang/rust/commit/22e491ac7ed454d34669151a8b6464cb643c9b41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22e491ac7ed454d34669151a8b6464cb643c9b41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "256721ee519f6ff15dc5c1cfaf3ebf9af75efa4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/256721ee519f6ff15dc5c1cfaf3ebf9af75efa4a", "html_url": "https://github.com/rust-lang/rust/commit/256721ee519f6ff15dc5c1cfaf3ebf9af75efa4a"}, {"sha": "c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "html_url": "https://github.com/rust-lang/rust/commit/c84cea9c25e8db73b1b580ab9c7f72985a05da4d"}], "stats": {"total": 741, "additions": 323, "deletions": 418}, "files": [{"sha": "02935af8314f00f6f1c16297e53c5b6d78775539", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -706,13 +706,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         &origin_projection,\n                     ) {\n                         match captured_place.info.capture_kind {\n-                            ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                                kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n-                                ..\n-                            }) => {\n+                            ty::UpvarCapture::ByRef(\n+                                ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                            ) => {\n                                 capture_reason = format!(\"mutable borrow of `{}`\", upvar);\n                             }\n-                            ty::UpvarCapture::ByValue(_) => {\n+                            ty::UpvarCapture::ByValue => {\n                                 capture_reason = format!(\"possible mutation of `{}`\", upvar);\n                             }\n                             _ => bug!(\"upvar `{}` borrowed, but not mutably\", upvar),"}, {"sha": "7e961e1e750be9a3fb970442b87774ffe24f0129", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -186,7 +186,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         .map(|captured_place| {\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n-                ty::UpvarCapture::ByValue(_) => false,\n+                ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n             Upvar { place: captured_place.clone(), by_ref }"}, {"sha": "0ac2ea4db5e77c38cfc53e2dbf7bbf0d1c42d817", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -52,35 +52,18 @@ impl UpvarId {\n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n #[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub enum UpvarCapture<'tcx> {\n+pub enum UpvarCapture {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n     /// depending on inference.\n-    ///\n-    /// If the upvar was inferred to be captured by value (e.g. `move`\n-    /// was not used), then the `Span` points to a usage that\n-    /// required it. There may be more than one such usage\n-    /// (e.g. `|| { a; a; }`), in which case we pick an\n-    /// arbitrary one.\n-    ByValue(Option<Span>),\n+    ByValue,\n \n     /// Upvar is captured by reference.\n-    ByRef(UpvarBorrow<'tcx>),\n-}\n-\n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct UpvarBorrow<'tcx> {\n-    /// The kind of borrow: by-ref upvars have access to shared\n-    /// immutable borrows, which are not part of the normal language\n-    /// syntax.\n-    pub kind: BorrowKind,\n-\n-    /// Region of the resulting reference.\n-    pub region: ty::Region<'tcx>,\n+    ByRef(BorrowKind),\n }\n \n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n-pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n+pub type UpvarCaptureMap = FxHashMap<UpvarId, UpvarCapture>;\n \n /// Given the closure DefId this map provides a map of root variables to minimum\n /// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n@@ -150,10 +133,13 @@ pub struct CapturedPlace<'tcx> {\n     pub place: HirPlace<'tcx>,\n \n     /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n-    pub info: CaptureInfo<'tcx>,\n+    pub info: CaptureInfo,\n \n     /// Represents if `place` can be mutated or not.\n     pub mutability: hir::Mutability,\n+\n+    /// Region of the resulting reference if the upvar is captured by ref.\n+    pub region: Option<ty::Region<'tcx>>,\n }\n \n impl<'tcx> CapturedPlace<'tcx> {\n@@ -287,7 +273,7 @@ pub fn is_ancestor_or_same_capture(\n /// for a particular capture as well as identifying the part of the source code\n /// that triggered this capture to occur.\n #[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct CaptureInfo<'tcx> {\n+pub struct CaptureInfo {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///\n     /// Eg:\n@@ -325,7 +311,7 @@ pub struct CaptureInfo<'tcx> {\n     pub path_expr_id: Option<hir::HirId>,\n \n     /// Capture mode that was selected\n-    pub capture_kind: UpvarCapture<'tcx>,\n+    pub capture_kind: UpvarCapture,\n }\n \n pub fn place_to_string_for_capture<'tcx>(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {"}, {"sha": "f1868459f2702a664415ebadf06e37e5a7e8d24f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -57,8 +57,8 @@ pub use self::binding::BindingMode::*;\n pub use self::closure::{\n     is_ancestor_or_same_capture, place_to_string_for_capture, BorrowKind, CaptureInfo,\n     CapturedPlace, ClosureKind, MinCaptureInformationMap, MinCaptureList,\n-    RootVariableMinCaptureList, UpvarBorrow, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap,\n-    UpvarPath, CAPTURE_STRUCT_LOCAL,\n+    RootVariableMinCaptureList, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap, UpvarPath,\n+    CAPTURE_STRUCT_LOCAL,\n };\n pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, Unevaluated, ValTree};\n pub use self::context::{"}, {"sha": "bb8c2b180e40ebfaade721f5e129065429d49f59", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -47,12 +47,6 @@ impl fmt::Debug for ty::UpvarId {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\", self.kind, self.region)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_no_trimmed_paths(|| fmt::Display::fmt(self, f))"}, {"sha": "3c07077c2cbb83c2648355cfd12a3ac39f0c0aca", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -266,7 +266,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             // we need to deref it\n             upvar_resolved_place_builder = match capture.info.capture_kind {\n                 ty::UpvarCapture::ByRef(_) => upvar_resolved_place_builder.deref(),\n-                ty::UpvarCapture::ByValue(_) => upvar_resolved_place_builder,\n+                ty::UpvarCapture::ByValue => upvar_resolved_place_builder,\n             };\n \n             let next_projection = capture.place.projections.len();"}, {"sha": "a4f3a63e40b603bc586eb30f9dd5e457f1c3a9d2", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -930,7 +930,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let mut projs = closure_env_projs.clone();\n                     projs.push(ProjectionElem::Field(Field::new(i), ty));\n                     match capture {\n-                        ty::UpvarCapture::ByValue(_) => {}\n+                        ty::UpvarCapture::ByValue => {}\n                         ty::UpvarCapture::ByRef(..) => {\n                             projs.push(ProjectionElem::Deref);\n                         }"}, {"sha": "c62de1543883eb60e95be6852f5078b17669da24", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -1108,9 +1108,9 @@ impl<'tcx> Cx<'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n \n         match upvar_capture {\n-            ty::UpvarCapture::ByValue(_) => captured_place_expr,\n+            ty::UpvarCapture::ByValue => captured_place_expr,\n             ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                let borrow_kind = match upvar_borrow.kind {\n+                let borrow_kind = match upvar_borrow {\n                     ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                     ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n                     ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false },"}, {"sha": "2e3bf7ea548ac347dd39a9b1167b53ad2381455b", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -726,7 +726,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             );\n                             self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n                         }\n-                        ty::UpvarCapture::ByValue(_) => {}\n+                        ty::UpvarCapture::ByValue => {}\n                     }\n                 }\n             }\n@@ -1481,7 +1481,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         for (&var_hir_id, min_capture_list) in closure_min_captures {\n             for captured_place in min_capture_list {\n                 match captured_place.info.capture_kind {\n-                    ty::UpvarCapture::ByValue(_) => {}\n+                    ty::UpvarCapture::ByValue => {}\n                     ty::UpvarCapture::ByRef(..) => continue,\n                 };\n                 let span = captured_place.get_capture_kind_span(self.ir.tcx);"}, {"sha": "0c2f40733505d6a74379384fbc6fff1e855d284e", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -859,15 +859,15 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                     self.sub_regions(\n                         infer::ReborrowUpvar(span, upvar_id),\n                         borrow_region,\n-                        upvar_borrow.region,\n+                        captured_place.region.unwrap(),\n                     );\n-                    if let ty::ImmBorrow = upvar_borrow.kind {\n+                    if let ty::ImmBorrow = upvar_borrow {\n                         debug!(\"link_upvar_region: capture by shared ref\");\n                     } else {\n                         all_captures_are_imm_borrow = false;\n                     }\n                 }\n-                ty::UpvarCapture::ByValue(_) => {\n+                ty::UpvarCapture::ByValue => {\n                     all_captures_are_imm_borrow = false;\n                 }\n             }"}, {"sha": "8d3c70b05734fe7be65cb4b90e49ac305d940883", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 192, "deletions": 339, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -33,7 +33,6 @@\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -72,7 +71,7 @@ enum PlaceAncestryRelation {\n /// Intermediate format to store a captured `Place` and associated `ty::CaptureInfo`\n /// during capture analysis. Information in this map feeds into the minimum capture\n /// analysis pass.\n-type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>;\n+type InferredCaptureInformation<'tcx> = Vec<(Place<'tcx>, ty::CaptureInfo)>;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -207,8 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n-            closure_def_id,\n-            closure_span: span,\n+            closure_def_id: local_def_id,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n@@ -231,7 +229,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (capture_information, closure_kind, origin) = self\n             .process_collected_capture_information(capture_clause, delegate.capture_information);\n \n-        self.compute_min_captures(closure_def_id, capture_information);\n+        self.compute_min_captures(closure_def_id, capture_information, span);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n \n@@ -252,21 +250,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     debug!(\"seed place {:?}\", place);\n \n-                    let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n-                    let capture_kind =\n-                        self.init_capture_kind_for_place(&place, capture_clause, upvar_id, span);\n+                    let capture_kind = self.init_capture_kind_for_place(&place, capture_clause);\n                     let fake_info = ty::CaptureInfo {\n                         capture_kind_expr_id: None,\n                         path_expr_id: None,\n                         capture_kind,\n                     };\n \n-                    capture_information.insert(place, fake_info);\n+                    capture_information.push((place, fake_info));\n                 }\n             }\n \n             // This will update the min captures based on this new fake information.\n-            self.compute_min_captures(closure_def_id, capture_information);\n+            self.compute_min_captures(closure_def_id, capture_information, span);\n         }\n \n         let before_feature_tys = self.final_upvar_tys(closure_def_id);\n@@ -362,7 +358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     captured_place.place, upvar_ty, capture, captured_place.mutability,\n                 );\n \n-                apply_capture_kind_on_capture_ty(self.tcx, upvar_ty, capture)\n+                apply_capture_kind_on_capture_ty(self.tcx, upvar_ty, capture, captured_place.region)\n             })\n             .collect()\n     }\n@@ -387,77 +383,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         capture_clause: hir::CaptureBy,\n         capture_information: InferredCaptureInformation<'tcx>,\n     ) -> (InferredCaptureInformation<'tcx>, ty::ClosureKind, Option<(Span, Place<'tcx>)>) {\n-        let mut processed: InferredCaptureInformation<'tcx> = Default::default();\n-\n         let mut closure_kind = ty::ClosureKind::LATTICE_BOTTOM;\n         let mut origin: Option<(Span, Place<'tcx>)> = None;\n \n-        for (place, mut capture_info) in capture_information {\n-            // Apply rules for safety before inferring closure kind\n-            let (place, capture_kind) =\n-                restrict_capture_precision(place, capture_info.capture_kind);\n-            capture_info.capture_kind = capture_kind;\n+        let processed = capture_information\n+            .into_iter()\n+            .map(|(place, mut capture_info)| {\n+                // Apply rules for safety before inferring closure kind\n+                let (place, capture_kind) =\n+                    restrict_capture_precision(place, capture_info.capture_kind);\n \n-            let (place, capture_kind) =\n-                truncate_capture_for_optimization(place, capture_info.capture_kind);\n-            capture_info.capture_kind = capture_kind;\n+                let (place, capture_kind) = truncate_capture_for_optimization(place, capture_kind);\n \n-            let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n-                self.tcx.hir().span(usage_expr)\n-            } else {\n-                unreachable!()\n-            };\n+                let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n+                    self.tcx.hir().span(usage_expr)\n+                } else {\n+                    unreachable!()\n+                };\n \n-            let updated = match capture_info.capture_kind {\n-                ty::UpvarCapture::ByValue(..) => match closure_kind {\n-                    ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n-                        (ty::ClosureKind::FnOnce, Some((usage_span, place.clone())))\n-                    }\n-                    // If closure is already FnOnce, don't update\n-                    ty::ClosureKind::FnOnce => (closure_kind, origin),\n-                },\n+                let updated = match capture_kind {\n+                    ty::UpvarCapture::ByValue => match closure_kind {\n+                        ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                            (ty::ClosureKind::FnOnce, Some((usage_span, place.clone())))\n+                        }\n+                        // If closure is already FnOnce, don't update\n+                        ty::ClosureKind::FnOnce => (closure_kind, origin.take()),\n+                    },\n \n-                ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                    kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n-                    ..\n-                }) => {\n-                    match closure_kind {\n-                        ty::ClosureKind::Fn => {\n-                            (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n+                    ty::UpvarCapture::ByRef(\n+                        ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                    ) => {\n+                        match closure_kind {\n+                            ty::ClosureKind::Fn => {\n+                                (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n+                            }\n+                            // Don't update the origin\n+                            ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce => {\n+                                (closure_kind, origin.take())\n+                            }\n                         }\n-                        // Don't update the origin\n-                        ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce => (closure_kind, origin),\n                     }\n-                }\n \n-                _ => (closure_kind, origin),\n-            };\n-\n-            closure_kind = updated.0;\n-            origin = updated.1;\n+                    _ => (closure_kind, origin.take()),\n+                };\n \n-            let (place, capture_kind) = match capture_clause {\n-                hir::CaptureBy::Value => adjust_for_move_closure(place, capture_info.capture_kind),\n-                hir::CaptureBy::Ref => {\n-                    adjust_for_non_move_closure(place, capture_info.capture_kind)\n-                }\n-            };\n+                closure_kind = updated.0;\n+                origin = updated.1;\n \n-            // This restriction needs to be applied after we have handled adjustments for `move`\n-            // closures. We want to make sure any adjustment that might make us move the place into\n-            // the closure gets handled.\n-            let (place, capture_kind) =\n-                restrict_precision_for_drop_types(self, place, capture_kind, usage_span);\n+                let (place, capture_kind) = match capture_clause {\n+                    hir::CaptureBy::Value => adjust_for_move_closure(place, capture_kind),\n+                    hir::CaptureBy::Ref => adjust_for_non_move_closure(place, capture_kind),\n+                };\n \n-            capture_info.capture_kind = capture_kind;\n+                // This restriction needs to be applied after we have handled adjustments for `move`\n+                // closures. We want to make sure any adjustment that might make us move the place into\n+                // the closure gets handled.\n+                let (place, capture_kind) =\n+                    restrict_precision_for_drop_types(self, place, capture_kind, usage_span);\n \n-            let capture_info = if let Some(existing) = processed.get(&place) {\n-                determine_capture_info(*existing, capture_info)\n-            } else {\n-                capture_info\n-            };\n-            processed.insert(place, capture_info);\n-        }\n+                capture_info.capture_kind = capture_kind;\n+                (place, capture_info)\n+            })\n+            .collect();\n \n         (processed, closure_kind, origin)\n     }\n@@ -535,6 +522,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_def_id: DefId,\n         capture_information: InferredCaptureInformation<'tcx>,\n+        closure_span: Span,\n     ) {\n         if capture_information.is_empty() {\n             return;\n@@ -554,8 +542,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n                     let mutability = self.determine_capture_mutability(&typeck_results, &place);\n-                    let min_cap_list =\n-                        vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n+                    let min_cap_list = vec![ty::CapturedPlace {\n+                        place,\n+                        info: capture_info,\n+                        mutability,\n+                        region: None,\n+                    }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n                     continue;\n                 }\n@@ -608,8 +600,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if !descendant_found {\n                 for possible_ancestor in min_cap_list.iter_mut() {\n                     match determine_place_ancestry_relation(&place, &possible_ancestor.place) {\n+                        PlaceAncestryRelation::SamePlace => {\n+                            ancestor_found = true;\n+                            possible_ancestor.info = determine_capture_info(\n+                                possible_ancestor.info,\n+                                updated_capture_info,\n+                            );\n+\n+                            // Only one related place will be in the list.\n+                            break;\n+                        }\n                         // current place is descendant of possible_ancestor\n-                        PlaceAncestryRelation::Descendant | PlaceAncestryRelation::SamePlace => {\n+                        PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n                             let backup_path_expr_id = possible_ancestor.info.path_expr_id;\n \n@@ -629,7 +631,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // we need to keep the ancestor's `path_expr_id`\n                             possible_ancestor.info.path_expr_id = backup_path_expr_id;\n \n-                            // Only one ancestor of the current place will be in the list.\n+                            // Only one related place will be in the list.\n                             break;\n                         }\n                         _ => {}\n@@ -640,12 +642,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n-                let captured_place =\n-                    ty::CapturedPlace { place, info: updated_capture_info, mutability };\n+                let captured_place = ty::CapturedPlace {\n+                    place,\n+                    info: updated_capture_info,\n+                    mutability,\n+                    region: None,\n+                };\n                 min_cap_list.push(captured_place);\n             }\n         }\n \n+        // For each capture that is determined to be captured by ref, add region info.\n+        for (_, captures) in &mut root_var_min_capture_list {\n+            for capture in captures {\n+                match capture.info.capture_kind {\n+                    ty::UpvarCapture::ByRef(_) => {\n+                        let PlaceBase::Upvar(upvar_id) = capture.place.base else { bug!(\"expected upvar\") };\n+                        let origin = UpvarRegion(upvar_id, closure_span);\n+                        let upvar_region = self.next_region_var(origin);\n+                        capture.region = Some(upvar_region);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+\n         debug!(\n             \"For closure={:?}, min_captures before sorting={:?}\",\n             closure_def_id, root_var_min_capture_list\n@@ -947,7 +968,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     max_capture_info = determine_capture_info(max_capture_info, capture.info);\n                 }\n \n-                apply_capture_kind_on_capture_ty(self.tcx, ty, max_capture_info.capture_kind)\n+                apply_capture_kind_on_capture_ty(\n+                    self.tcx,\n+                    ty,\n+                    max_capture_info.capture_kind,\n+                    Some(&ty::ReErased),\n+                )\n             }\n         };\n \n@@ -977,6 +1003,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx,\n                 capture.place.ty(),\n                 capture.info.capture_kind,\n+                Some(&ty::ReErased),\n             );\n \n             // Checks if a capture implements any of the auto traits\n@@ -1086,7 +1113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for captured_place in root_var_min_capture_list.iter() {\n             match captured_place.info.capture_kind {\n                 // Only care about captures that are moved into the closure\n-                ty::UpvarCapture::ByValue(..) => {\n+                ty::UpvarCapture::ByValue => {\n                     projections_list.push(captured_place.place.projections.as_slice());\n                     diagnostics_info.insert(UpvarMigrationInfo::CapturingPrecise {\n                         source_expr: captured_place.info.path_expr_id,\n@@ -1470,9 +1497,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         place: &Place<'tcx>,\n         capture_clause: hir::CaptureBy,\n-        upvar_id: ty::UpvarId,\n-        closure_span: Span,\n-    ) -> ty::UpvarCapture<'tcx> {\n+    ) -> ty::UpvarCapture {\n         match capture_clause {\n             // In case of a move closure if the data is accessed through a reference we\n             // want to capture by ref to allow precise capture using reborrows.\n@@ -1481,14 +1506,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // at the first Deref in `adjust_upvar_borrow_kind_for_consume` and then moved into\n             // the closure.\n             hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n-                ty::UpvarCapture::ByValue(None)\n-            }\n-            hir::CaptureBy::Value | hir::CaptureBy::Ref => {\n-                let origin = UpvarRegion(upvar_id, closure_span);\n-                let upvar_region = self.next_region_var(origin);\n-                let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n-                ty::UpvarCapture::ByRef(upvar_borrow)\n+                ty::UpvarCapture::ByValue\n             }\n+            hir::CaptureBy::Value | hir::CaptureBy::Ref => ty::UpvarCapture::ByRef(ty::ImmBorrow),\n         }\n     }\n \n@@ -1513,7 +1533,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn log_capture_analysis_first_pass(\n         &self,\n         closure_def_id: rustc_hir::def_id::DefId,\n-        capture_information: &FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n+        capture_information: &InferredCaptureInformation<'tcx>,\n         closure_span: Span,\n     ) {\n         if self.should_log_capture_analysis(closure_def_id) {\n@@ -1629,9 +1649,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n fn restrict_repr_packed_field_ref_capture<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    place: &Place<'tcx>,\n-    mut curr_borrow_kind: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut place: Place<'tcx>,\n+    mut curr_borrow_kind: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let pos = place.projections.iter().enumerate().position(|(i, p)| {\n         let ty = place.ty_before_projection(i);\n \n@@ -1662,8 +1682,6 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         }\n     });\n \n-    let mut place = place.clone();\n-\n     if let Some(pos) = pos {\n         truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_borrow_kind, pos);\n     }\n@@ -1675,12 +1693,14 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n fn apply_capture_kind_on_capture_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    capture_kind: UpvarCapture<'tcx>,\n+    capture_kind: UpvarCapture,\n+    region: Option<ty::Region<'tcx>>,\n ) -> Ty<'tcx> {\n     match capture_kind {\n-        ty::UpvarCapture::ByValue(_) => ty,\n-        ty::UpvarCapture::ByRef(borrow) => tcx\n-            .mk_ref(borrow.region, ty::TypeAndMut { ty: ty, mutbl: borrow.kind.to_mutbl_lossy() }),\n+        ty::UpvarCapture::ByValue => ty,\n+        ty::UpvarCapture::ByRef(kind) => {\n+            tcx.mk_ref(region.unwrap(), ty::TypeAndMut { ty: ty, mutbl: kind.to_mutbl_lossy() })\n+        }\n     }\n }\n \n@@ -1708,9 +1728,7 @@ struct InferBorrowKind<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // The def-id of the closure whose kind and upvar accesses are being inferred.\n-    closure_def_id: DefId,\n-\n-    closure_span: Span,\n+    closure_def_id: LocalDefId,\n \n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n@@ -1742,184 +1760,38 @@ struct InferBorrowKind<'a, 'tcx> {\n     fake_reads: Vec<(Place<'tcx>, FakeReadCause, hir::HirId)>,\n }\n \n-impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind_for_consume(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        let tcx = self.fcx.tcx;\n-        let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else {\n-            return;\n-        };\n-\n-        debug!(?upvar_id);\n-\n-        let usage_span = tcx.hir().span(diag_expr_id);\n-\n-        let capture_info = ty::CaptureInfo {\n-            capture_kind_expr_id: Some(diag_expr_id),\n-            path_expr_id: Some(diag_expr_id),\n-            capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n-        };\n-\n-        let curr_info = self.capture_information[&place_with_id.place];\n-        let updated_info = determine_capture_info(curr_info, capture_info);\n-\n-        self.capture_information[&place_with_id.place] = updated_info;\n-    }\n-\n-    /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n-    /// to). If the place is based on a by-ref upvar, this implies that\n-    /// the upvar must be borrowed using an `&mut` borrow.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind_for_mut(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n-            // Raw pointers don't inherit mutability\n-            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n-                return;\n-            }\n-            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::MutBorrow);\n-        }\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind_for_unique(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n-            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n-                // Raw pointers don't inherit mutability.\n-                return;\n-            }\n-            // for a borrowed pointer to be unique, its base must be unique\n-            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::UniqueImmBorrow);\n-        }\n-    }\n-\n-    fn adjust_upvar_deref(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-        borrow_kind: ty::BorrowKind,\n-    ) {\n-        assert!(match borrow_kind {\n-            ty::MutBorrow => true,\n-            ty::UniqueImmBorrow => true,\n-\n-            // imm borrows never require adjusting any kinds, so we don't wind up here\n-            ty::ImmBorrow => false,\n-        });\n-\n-        // if this is an implicit deref of an\n-        // upvar, then we need to modify the\n-        // borrow_kind of the upvar to make sure it\n-        // is inferred to mutable if necessary\n-        self.adjust_upvar_borrow_kind(place_with_id, diag_expr_id, borrow_kind);\n-    }\n-\n-    /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n-    /// The borrow_kind basically follows a lattice of `imm < unique-imm < mut`,\n-    /// moving from left to right as needed (but never right to left).\n-    /// Here the argument `mutbl` is the borrow_kind that is required by\n-    /// some particular use.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-        kind: ty::BorrowKind,\n-    ) {\n-        let curr_capture_info = self.capture_information[&place_with_id.place];\n-\n-        debug!(?curr_capture_info);\n-\n-        if let ty::UpvarCapture::ByValue(_) = curr_capture_info.capture_kind {\n-            // It's already captured by value, we don't need to do anything here\n-            return;\n-        } else if let ty::UpvarCapture::ByRef(curr_upvar_borrow) = curr_capture_info.capture_kind {\n-            // Use the same region as the current capture information\n-            // Doesn't matter since only one of the UpvarBorrow will be used.\n-            let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n-\n-            let capture_info = ty::CaptureInfo {\n-                capture_kind_expr_id: Some(diag_expr_id),\n-                path_expr_id: Some(diag_expr_id),\n-                capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n-            };\n-            let updated_info = determine_capture_info(curr_capture_info, capture_info);\n-            self.capture_information[&place_with_id.place] = updated_info;\n-        };\n-    }\n-\n-    #[instrument(skip(self, diag_expr_id), level = \"debug\")]\n-    fn init_capture_info_for_place(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n-            assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n-\n-            // Initialize to ImmBorrow\n-            // We will escalate the CaptureKind based on any uses we see or in `process_collected_capture_information`.\n-            let origin = UpvarRegion(upvar_id, self.closure_span);\n-            let upvar_region = self.fcx.next_region_var(origin);\n-            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n-            let capture_kind = ty::UpvarCapture::ByRef(upvar_borrow);\n-\n-            let expr_id = Some(diag_expr_id);\n-            let capture_info = ty::CaptureInfo {\n-                capture_kind_expr_id: expr_id,\n-                path_expr_id: expr_id,\n-                capture_kind,\n-            };\n-\n-            debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n-\n-            self.capture_information.insert(place_with_id.place.clone(), capture_info);\n-        } else {\n-            debug!(\"Not upvar\");\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId) {\n-        if let PlaceBase::Upvar(_) = place.base {\n-            // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n-            // such as deref of a raw pointer.\n-            let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                kind: ty::BorrowKind::ImmBorrow,\n-                region: &ty::ReErased,\n-            });\n+        let PlaceBase::Upvar(_) = place.base else { return };\n \n-            let (place, _) = restrict_capture_precision(place, dummy_capture_kind);\n+        // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n+        // such as deref of a raw pointer.\n+        let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n \n-            let (place, _) = restrict_repr_packed_field_ref_capture(\n-                self.fcx.tcx,\n-                self.fcx.param_env,\n-                &place,\n-                dummy_capture_kind,\n-            );\n-            self.fake_reads.push((place, cause, diag_expr_id));\n-        }\n+        let (place, _) = restrict_capture_precision(place, dummy_capture_kind);\n+\n+        let (place, _) = restrict_repr_packed_field_ref_capture(\n+            self.fcx.tcx,\n+            self.fcx.param_env,\n+            place,\n+            dummy_capture_kind,\n+        );\n+        self.fake_reads.push((place, cause, diag_expr_id));\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n-        if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n-        }\n+        let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else { return };\n+        assert_eq!(self.closure_def_id, upvar_id.closure_expr_id);\n \n-        self.adjust_upvar_borrow_kind_for_consume(place_with_id, diag_expr_id);\n+        self.capture_information.push((\n+            place_with_id.place.clone(),\n+            ty::CaptureInfo {\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n+                capture_kind: ty::UpvarCapture::ByValue,\n+            },\n+        ));\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -1929,40 +1801,35 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         diag_expr_id: hir::HirId,\n         bk: ty::BorrowKind,\n     ) {\n+        let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else { return };\n+        assert_eq!(self.closure_def_id, upvar_id.closure_expr_id);\n+\n         // The region here will get discarded/ignored\n-        let dummy_capture_kind =\n-            ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: bk, region: &ty::ReErased });\n+        let capture_kind = ty::UpvarCapture::ByRef(bk);\n \n         // We only want repr packed restriction to be applied to reading references into a packed\n         // struct, and not when the data is being moved. Therefore we call this method here instead\n         // of in `restrict_capture_precision`.\n-        let (place, updated_kind) = restrict_repr_packed_field_ref_capture(\n+        let (place, mut capture_kind) = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n             self.fcx.param_env,\n-            &place_with_id.place,\n-            dummy_capture_kind,\n+            place_with_id.place.clone(),\n+            capture_kind,\n         );\n \n-        let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n-\n-        if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n+        // Raw pointers don't inherit mutability\n+        if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+            capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n         }\n \n-        match updated_kind {\n-            ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, .. }) => match kind {\n-                ty::ImmBorrow => {}\n-                ty::UniqueImmBorrow => {\n-                    self.adjust_upvar_borrow_kind_for_unique(&place_with_id, diag_expr_id);\n-                }\n-                ty::MutBorrow => {\n-                    self.adjust_upvar_borrow_kind_for_mut(&place_with_id, diag_expr_id);\n-                }\n+        self.capture_information.push((\n+            place,\n+            ty::CaptureInfo {\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n+                capture_kind,\n             },\n-\n-            // Just truncating the place will never cause capture kind to be updated to ByValue\n-            ty::UpvarCapture::ByValue(..) => unreachable!(),\n-        }\n+        ));\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -1975,12 +1842,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n fn restrict_precision_for_drop_types<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     mut place: Place<'tcx>,\n-    mut curr_mode: ty::UpvarCapture<'tcx>,\n+    mut curr_mode: ty::UpvarCapture,\n     span: Span,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let is_copy_type = fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, place.ty(), span);\n \n-    if let (false, UpvarCapture::ByValue(..)) = (is_copy_type, curr_mode) {\n+    if let (false, UpvarCapture::ByValue) = (is_copy_type, curr_mode) {\n         for i in 0..place.projections.len() {\n             match place.ty_before_projection(i).kind() {\n                 ty::Adt(def, _) if def.destructor(fcx.tcx).is_some() => {\n@@ -2001,8 +1868,8 @@ fn restrict_precision_for_drop_types<'a, 'tcx>(\n /// - No projections are applied on top of Union ADTs, since these require unsafe blocks.\n fn restrict_precision_for_unsafe<'tcx>(\n     mut place: Place<'tcx>,\n-    mut curr_mode: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut curr_mode: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     if place.base_ty.is_unsafe_ptr() {\n         truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n@@ -2034,8 +1901,8 @@ fn restrict_precision_for_unsafe<'tcx>(\n /// Returns the truncated place and updated cature mode.\n fn restrict_capture_precision<'tcx>(\n     place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    curr_mode: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let (mut place, mut curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n \n     if place.projections.is_empty() {\n@@ -2062,30 +1929,28 @@ fn restrict_capture_precision<'tcx>(\n /// Truncate deref of any reference.\n fn adjust_for_move_closure<'tcx>(\n     mut place: Place<'tcx>,\n-    mut kind: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut kind: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n     if let Some(idx) = first_deref {\n         truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx);\n     }\n \n-    // AMAN: I think we don't need the span inside the ByValue anymore\n-    //       we have more detailed span in CaptureInfo\n-    (place, ty::UpvarCapture::ByValue(None))\n+    (place, ty::UpvarCapture::ByValue)\n }\n \n /// Adjust closure capture just that if taking ownership of data, only move data\n /// from enclosing stack frame.\n fn adjust_for_non_move_closure<'tcx>(\n     mut place: Place<'tcx>,\n-    mut kind: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut kind: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let contains_deref =\n         place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n     match kind {\n-        ty::UpvarCapture::ByValue(..) => {\n+        ty::UpvarCapture::ByValue => {\n             if let Some(idx) = contains_deref {\n                 truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx);\n             }\n@@ -2123,13 +1988,13 @@ fn construct_place_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String\n fn construct_capture_kind_reason_string<'tcx>(\n     tcx: TyCtxt<'_>,\n     place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n+    capture_info: &ty::CaptureInfo,\n ) -> String {\n     let place_str = construct_place_string(tcx, place);\n \n     let capture_kind_str = match capture_info.capture_kind {\n-        ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n-        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+        ty::UpvarCapture::ByValue => \"ByValue\".into(),\n+        ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n \n     format!(\"{} captured as {} here\", place_str, capture_kind_str)\n@@ -2144,13 +2009,13 @@ fn construct_path_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n fn construct_capture_info_string<'tcx>(\n     tcx: TyCtxt<'_>,\n     place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n+    capture_info: &ty::CaptureInfo,\n ) -> String {\n     let place_str = construct_place_string(tcx, place);\n \n     let capture_kind_str = match capture_info.capture_kind {\n-        ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n-        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+        ty::UpvarCapture::ByValue => \"ByValue\".into(),\n+        ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n     format!(\"{} -> {}\", place_str, capture_kind_str)\n }\n@@ -2233,25 +2098,16 @@ fn migration_suggestion_for_2229(\n /// would've already handled `E1`, and have an existing capture_information for it.\n /// Calling `determine_capture_info(existing_info_e1, current_info_e2)` will return\n /// `existing_info_e1` in this case, allowing us to point to `E1` in case of diagnostics.\n-fn determine_capture_info<'tcx>(\n-    capture_info_a: ty::CaptureInfo<'tcx>,\n-    capture_info_b: ty::CaptureInfo<'tcx>,\n-) -> ty::CaptureInfo<'tcx> {\n+fn determine_capture_info(\n+    capture_info_a: ty::CaptureInfo,\n+    capture_info_b: ty::CaptureInfo,\n+) -> ty::CaptureInfo {\n     // If the capture kind is equivalent then, we don't need to escalate and can compare the\n     // expressions.\n     let eq_capture_kind = match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n-        (ty::UpvarCapture::ByValue(_), ty::UpvarCapture::ByValue(_)) => {\n-            // We don't need to worry about the spans being ignored here.\n-            //\n-            // The expr_id in capture_info corresponds to the span that is stored within\n-            // ByValue(span) and therefore it gets handled with priortizing based on\n-            // expressions below.\n-            true\n-        }\n-        (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n-            ref_a.kind == ref_b.kind\n-        }\n-        (ty::UpvarCapture::ByValue(_), _) | (ty::UpvarCapture::ByRef(_), _) => false,\n+        (ty::UpvarCapture::ByValue, ty::UpvarCapture::ByValue) => true,\n+        (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => ref_a == ref_b,\n+        (ty::UpvarCapture::ByValue, _) | (ty::UpvarCapture::ByRef(_), _) => false,\n     };\n \n     if eq_capture_kind {\n@@ -2263,10 +2119,10 @@ fn determine_capture_info<'tcx>(\n         // We select the CaptureKind which ranks higher based the following priority order:\n         // ByValue > MutBorrow > UniqueImmBorrow > ImmBorrow\n         match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n-            (ty::UpvarCapture::ByValue(_), _) => capture_info_a,\n-            (_, ty::UpvarCapture::ByValue(_)) => capture_info_b,\n+            (ty::UpvarCapture::ByValue, _) => capture_info_a,\n+            (_, ty::UpvarCapture::ByValue) => capture_info_b,\n             (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n-                match (ref_a.kind, ref_b.kind) {\n+                match (ref_a, ref_b) {\n                     // Take LHS:\n                     (ty::UniqueImmBorrow | ty::MutBorrow, ty::ImmBorrow)\n                     | (ty::MutBorrow, ty::UniqueImmBorrow) => capture_info_a,\n@@ -2294,7 +2150,7 @@ fn determine_capture_info<'tcx>(\n /// contained `Deref` of `&mut`.\n fn truncate_place_to_len_and_update_capture_kind<'tcx>(\n     place: &mut Place<'tcx>,\n-    curr_mode: &mut ty::UpvarCapture<'tcx>,\n+    curr_mode: &mut ty::UpvarCapture,\n     len: usize,\n ) {\n     let is_mut_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Mut));\n@@ -2304,22 +2160,19 @@ fn truncate_place_to_len_and_update_capture_kind<'tcx>(\n     // Note that if the place contained Deref of a raw pointer it would've not been MutBorrow, so\n     // we don't need to worry about that case here.\n     match curr_mode {\n-        ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: ty::BorrowKind::MutBorrow, region }) => {\n+        ty::UpvarCapture::ByRef(ty::BorrowKind::MutBorrow) => {\n             for i in len..place.projections.len() {\n                 if place.projections[i].kind == ProjectionKind::Deref\n                     && is_mut_ref(place.ty_before_projection(i))\n                 {\n-                    *curr_mode = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                        kind: ty::BorrowKind::UniqueImmBorrow,\n-                        region,\n-                    });\n+                    *curr_mode = ty::UpvarCapture::ByRef(ty::BorrowKind::UniqueImmBorrow);\n                     break;\n                 }\n             }\n         }\n \n         ty::UpvarCapture::ByRef(..) => {}\n-        ty::UpvarCapture::ByValue(..) => {}\n+        ty::UpvarCapture::ByValue => {}\n     }\n \n     place.projections.truncate(len);\n@@ -2390,8 +2243,8 @@ fn determine_place_ancestry_relation<'tcx>(\n /// ```\n fn truncate_capture_for_optimization<'tcx>(\n     mut place: Place<'tcx>,\n-    mut curr_mode: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut curr_mode: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n \n     // Find the right-most deref (if any). All the projections that come after this"}, {"sha": "352cdefc0b47b415a5e26974a7e6c1be84c5d4c4", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -796,14 +796,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     );\n \n                     match capture_info.capture_kind {\n-                        ty::UpvarCapture::ByValue(_) => {\n+                        ty::UpvarCapture::ByValue => {\n                             self.delegate_consume(&place_with_id, place_with_id.hir_id);\n                         }\n                         ty::UpvarCapture::ByRef(upvar_borrow) => {\n                             self.delegate.borrow(\n                                 &place_with_id,\n                                 place_with_id.hir_id,\n-                                upvar_borrow.kind,\n+                                upvar_borrow,\n                             );\n                         }\n                     }"}, {"sha": "2bcbd792e3a834186f1a86a1eb420fe1e21ed468", "filename": "src/test/ui/closures/2229_closure_analysis/arrays-completely-captured.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -15,6 +15,7 @@ fn main() {\n         //~^ NOTE: Capturing m[] -> MutBorrow\n         //~| NOTE: Min Capture m[] -> MutBorrow\n         m[1] += 40;\n+        //~^ NOTE: Capturing m[] -> MutBorrow\n     };\n \n     c();"}, {"sha": "129b26456ce1d5a6fd6abed645cac3303100c3f4", "filename": "src/test/ui/closures/2229_closure_analysis/arrays-completely-captured.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -15,7 +15,7 @@ LL | |\n LL | |\n LL | |         m[0] += 10;\n ...  |\n-LL | |         m[1] += 40;\n+LL | |\n LL | |     };\n    | |_____^\n    |\n@@ -24,6 +24,11 @@ note: Capturing m[] -> MutBorrow\n    |\n LL |         m[0] += 10;\n    |         ^\n+note: Capturing m[] -> MutBorrow\n+  --> $DIR/arrays-completely-captured.rs:17:9\n+   |\n+LL |         m[1] += 40;\n+   |         ^\n \n error: Min Capture analysis includes:\n   --> $DIR/arrays-completely-captured.rs:11:5\n@@ -33,7 +38,7 @@ LL | |\n LL | |\n LL | |         m[0] += 10;\n ...  |\n-LL | |         m[1] += 40;\n+LL | |\n LL | |     };\n    | |_____^\n    |"}, {"sha": "6c65a7bf87b96c4aa6c4884175315f7092acb7d5", "filename": "src/test/ui/closures/2229_closure_analysis/destructure_patterns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -15,6 +15,8 @@ fn arrays() {\n     //~| ERROR: Min Capture analysis includes:\n         let [a, b, .., e] = arr;\n         //~^ NOTE: Capturing arr[Index] -> ByValue\n+        //~| NOTE: Capturing arr[Index] -> ByValue\n+        //~| NOTE: Capturing arr[Index] -> ByValue\n         //~| NOTE: Min Capture arr[] -> ByValue\n         assert_eq!(a, \"A\");\n         assert_eq!(b, \"B\");"}, {"sha": "44fbe6d8158f221c07538151a3b2a0d4422fbf84", "filename": "src/test/ui/closures/2229_closure_analysis/destructure_patterns.stderr", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -8,7 +8,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure_patterns.rs:36:13\n+  --> $DIR/destructure_patterns.rs:38:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure_patterns.rs:56:13\n+  --> $DIR/destructure_patterns.rs:58:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,6 +42,16 @@ note: Capturing arr[Index] -> ByValue\n    |\n LL |         let [a, b, .., e] = arr;\n    |                             ^^^\n+note: Capturing arr[Index] -> ByValue\n+  --> $DIR/destructure_patterns.rs:16:29\n+   |\n+LL |         let [a, b, .., e] = arr;\n+   |                             ^^^\n+note: Capturing arr[Index] -> ByValue\n+  --> $DIR/destructure_patterns.rs:16:29\n+   |\n+LL |         let [a, b, .., e] = arr;\n+   |                             ^^^\n \n error: Min Capture analysis includes:\n   --> $DIR/destructure_patterns.rs:13:5\n@@ -62,7 +72,7 @@ LL |         let [a, b, .., e] = arr;\n    |                             ^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/destructure_patterns.rs:39:5\n+  --> $DIR/destructure_patterns.rs:41:5\n    |\n LL | /     || {\n LL | |\n@@ -74,18 +84,18 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing p[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n note: Capturing p[(2, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n \n error: Min Capture analysis includes:\n-  --> $DIR/destructure_patterns.rs:39:5\n+  --> $DIR/destructure_patterns.rs:41:5\n    |\n LL | /     || {\n LL | |\n@@ -97,18 +107,18 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture p[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n note: Min Capture p[(2, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n \n error: First Pass analysis includes:\n-  --> $DIR/destructure_patterns.rs:59:5\n+  --> $DIR/destructure_patterns.rs:61:5\n    |\n LL | /     || {\n LL | |\n@@ -120,23 +130,23 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing t[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Capturing t[(2, 0),(0, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n \n error: Min Capture analysis includes:\n-  --> $DIR/destructure_patterns.rs:59:5\n+  --> $DIR/destructure_patterns.rs:61:5\n    |\n LL | /     || {\n LL | |\n@@ -148,17 +158,17 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture t[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Min Capture t[(2, 0),(0, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^"}, {"sha": "46b54846e32ebdc1960692c7ca0204bec7ac94f6", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/union.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -0,0 +1,25 @@\n+// edition:2021\n+\n+// Test that we point to the correct location that results a union being captured.\n+// Union is special because it can't be disjointly captured.\n+\n+union A {\n+    y: u32,\n+    x: (),\n+}\n+\n+fn main() {\n+    let mut a = A { y: 1 };\n+    let mut c = || {\n+    //~^ borrow of `a.y` occurs here\n+        let _ = unsafe { &a.y };\n+        let _ = &mut a;\n+        //~^ borrow occurs due to use in closure\n+        let _ = unsafe { &mut a.y };\n+    };\n+    a.y = 1;\n+    //~^ cannot assign to `a.y` because it is borrowed [E0506]\n+    //~| assignment to borrowed `a.y` occurs here\n+    c();\n+    //~^ borrow later used here\n+}"}, {"sha": "7c34e2336c867487444c10479c9d8b43e81cfad8", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/union.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.stderr?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -0,0 +1,18 @@\n+error[E0506]: cannot assign to `a.y` because it is borrowed\n+  --> $DIR/union.rs:20:5\n+   |\n+LL |     let mut c = || {\n+   |                 -- borrow of `a.y` occurs here\n+...\n+LL |         let _ = &mut a;\n+   |                      - borrow occurs due to use in closure\n+...\n+LL |     a.y = 1;\n+   |     ^^^^^^^ assignment to borrowed `a.y` occurs here\n+...\n+LL |     c();\n+   |     - borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "22eae744b80806b57b3d9ceff67e23f95d3d265a", "filename": "src/test/ui/closures/2229_closure_analysis/nested-closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -40,6 +40,7 @@ fn main() {\n         //~| NOTE: Min Capture p[(1, 0)] -> MutBorrow\n         c2();\n         println!(\"{}\", p.y);\n+        //~^ NOTE: Capturing p[(1, 0)] -> ImmBorrow\n     };\n \n     c1();"}, {"sha": "a50d0c6a182bc5f393668d272012648120311532", "filename": "src/test/ui/closures/2229_closure_analysis/nested-closure.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -58,7 +58,7 @@ LL | |\n LL | |\n LL | |         println!(\"{}\", p.x);\n ...  |\n-LL | |         println!(\"{}\", p.y);\n+LL | |\n LL | |     };\n    | |_____^\n    |\n@@ -72,6 +72,11 @@ note: Capturing p[(1, 0)] -> MutBorrow\n    |\n LL |         || p.y += incr;\n    |            ^^^\n+note: Capturing p[(1, 0)] -> ImmBorrow\n+  --> $DIR/nested-closure.rs:42:24\n+   |\n+LL |         println!(\"{}\", p.y);\n+   |                        ^^^\n \n error: Min Capture analysis includes:\n   --> $DIR/nested-closure.rs:22:5\n@@ -81,7 +86,7 @@ LL | |\n LL | |\n LL | |         println!(\"{}\", p.x);\n ...  |\n-LL | |         println!(\"{}\", p.y);\n+LL | |\n LL | |     };\n    | |_____^\n    |"}, {"sha": "3ed780f51c73b6b6f4a54130faccad04c9afbdfc", "filename": "src/test/ui/closures/2229_closure_analysis/repr_packed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -48,6 +48,7 @@ fn test_alignment_affected() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let z1: &String = &foo.x;\n+        //~^ NOTE: Capturing foo[] -> ImmBorrow\n         let z2: &mut u16 = &mut foo.y;\n         //~^ NOTE: Capturing foo[] -> MutBorrow\n         //~| NOTE: Min Capture foo[] -> MutBorrow"}, {"sha": "580061ebc6ed900c675df833ae6988d13f564d40", "filename": "src/test/ui/closures/2229_closure_analysis/repr_packed.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -17,7 +17,7 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/repr_packed.rs:78:13\n+  --> $DIR/repr_packed.rs:79:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -83,8 +83,13 @@ LL | |         println!(\"({}, {})\", z1, z2);\n LL | |     };\n    | |_____^\n    |\n+note: Capturing foo[] -> ImmBorrow\n+  --> $DIR/repr_packed.rs:50:28\n+   |\n+LL |         let z1: &String = &foo.x;\n+   |                            ^^^^^\n note: Capturing foo[] -> MutBorrow\n-  --> $DIR/repr_packed.rs:51:33\n+  --> $DIR/repr_packed.rs:52:33\n    |\n LL |         let z2: &mut u16 = &mut foo.y;\n    |                                 ^^^^^\n@@ -102,13 +107,13 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture foo[] -> MutBorrow\n-  --> $DIR/repr_packed.rs:51:33\n+  --> $DIR/repr_packed.rs:52:33\n    |\n LL |         let z2: &mut u16 = &mut foo.y;\n    |                                 ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/repr_packed.rs:81:5\n+  --> $DIR/repr_packed.rs:82:5\n    |\n LL | /     || {\n LL | |\n@@ -120,18 +125,18 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing foo[] -> ImmBorrow\n-  --> $DIR/repr_packed.rs:84:24\n+  --> $DIR/repr_packed.rs:85:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^\n note: Capturing foo[(0, 0)] -> ByValue\n-  --> $DIR/repr_packed.rs:88:18\n+  --> $DIR/repr_packed.rs:89:18\n    |\n LL |         let _z = foo.x;\n    |                  ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/repr_packed.rs:81:5\n+  --> $DIR/repr_packed.rs:82:5\n    |\n LL | /     || {\n LL | |\n@@ -143,7 +148,7 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture foo[] -> ByValue\n-  --> $DIR/repr_packed.rs:84:24\n+  --> $DIR/repr_packed.rs:85:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^ foo[] used here"}, {"sha": "90f5baffd22fcb1602b65ce51ee77cf94db3b5c3", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e491ac7ed454d34669151a8b6464cb643c9b41/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=22e491ac7ed454d34669151a8b6464cb643c9b41", "patch": "@@ -976,8 +976,8 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n                         };\n                         if !self.locals.contains(&local_id) {\n                             let capture = match capture.info.capture_kind {\n-                                UpvarCapture::ByValue(_) => CaptureKind::Value,\n-                                UpvarCapture::ByRef(borrow) => match borrow.kind {\n+                                UpvarCapture::ByValue => CaptureKind::Value,\n+                                UpvarCapture::ByRef(kind) => match kind {\n                                     BorrowKind::ImmBorrow => CaptureKind::Ref(Mutability::Not),\n                                     BorrowKind::UniqueImmBorrow | BorrowKind::MutBorrow => {\n                                         CaptureKind::Ref(Mutability::Mut)"}]}