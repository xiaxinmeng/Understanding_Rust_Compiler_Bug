{"sha": "2b6ed3b675475abc01ce7e68bb75b457f0c85684", "node_id": "C_kwDOAAsO6NoAKDJiNmVkM2I2NzU0NzVhYmMwMWNlN2U2OGJiNzViNDU3ZjBjODU2ODQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-27T14:08:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-27T14:08:13Z"}, "message": "Auto merge of #89285 - jackh726:issue-88862, r=nikomatsakis\n\nDon't normalize opaque types with escaping late-bound regions\n\nFixes #88862\n\nTurns out, this has some really bad perf implications in large types (issue #88862). While we technically can handle them fine, it doesn't change test output either way. For now, revert with an added benchmark. Future attempts to change this back will have to consider perf.\n\nNeeds a perf run once https://github.com/rust-lang/rustc-perf/pull/1033 is merged\n\nr? `@nikomatsakis`", "tree": {"sha": "e17c038639d97f818bf2d3d19696d929320aa1e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e17c038639d97f818bf2d3d19696d929320aa1e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b6ed3b675475abc01ce7e68bb75b457f0c85684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b6ed3b675475abc01ce7e68bb75b457f0c85684", "html_url": "https://github.com/rust-lang/rust/commit/2b6ed3b675475abc01ce7e68bb75b457f0c85684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b6ed3b675475abc01ce7e68bb75b457f0c85684/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e8f32e1c52ca493c862facb7a69e7c3f1f97a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e8f32e1c52ca493c862facb7a69e7c3f1f97a18", "html_url": "https://github.com/rust-lang/rust/commit/3e8f32e1c52ca493c862facb7a69e7c3f1f97a18"}, {"sha": "a84e3fab307f562312c54991e3c7386246ba3f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a84e3fab307f562312c54991e3c7386246ba3f75", "html_url": "https://github.com/rust-lang/rust/commit/a84e3fab307f562312c54991e3c7386246ba3f75"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "47b006985ec569e74d77f7bb7f1caad7de937fb3", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b6ed3b675475abc01ce7e68bb75b457f0c85684/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b6ed3b675475abc01ce7e68bb75b457f0c85684/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=2b6ed3b675475abc01ce7e68bb75b457f0c85684", "patch": "@@ -388,15 +388,15 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         // to make sure we don't forget to fold the substs regardless.\n \n         match *ty.kind() {\n-            ty::Opaque(def_id, substs) => {\n+            // This is really important. While we *can* handle this, this has\n+            // severe performance implications for large opaque types with\n+            // late-bound regions. See `issue-88862` benchmark.\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n \n                     Reveal::All => {\n-                        // N.b. there is an assumption here all this code can handle\n-                        // escaping bound vars.\n-\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.depth) {\n                             let obligation = Obligation::with_depth("}, {"sha": "1364cf1c9953512f925106e382f141a3bc893a5d", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b6ed3b675475abc01ce7e68bb75b457f0c85684/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b6ed3b675475abc01ce7e68bb75b457f0c85684/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=2b6ed3b675475abc01ce7e68bb75b457f0c85684", "patch": "@@ -206,15 +206,15 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n         let res = (|| match *ty.kind() {\n-            ty::Opaque(def_id, substs) => {\n+            // This is really important. While we *can* handle this, this has\n+            // severe performance implications for large opaque types with\n+            // late-bound regions. See `issue-88862` benchmark.\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n \n                     Reveal::All => {\n-                        // N.b. there is an assumption here all this code can handle\n-                        // escaping bound vars.\n-\n                         let substs = substs.super_fold_with(self);\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {"}]}