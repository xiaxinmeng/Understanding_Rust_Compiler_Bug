{"sha": "99383f8f5c276d8060f2105ff7e678c81bf4df05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MzgzZjhmNWMyNzZkODA2MGYyMTA1ZmY3ZTY3OGM4MWJmNGRmMDU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-01T12:43:42Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-01T12:43:42Z"}, "message": "refactored compiletest following clippy's suggestions", "tree": {"sha": "ee63da0bffa6c8ef04983d002f5e793a698ecc2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee63da0bffa6c8ef04983d002f5e793a698ecc2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99383f8f5c276d8060f2105ff7e678c81bf4df05", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99383f8f5c276d8060f2105ff7e678c81bf4df05", "html_url": "https://github.com/rust-lang/rust/commit/99383f8f5c276d8060f2105ff7e678c81bf4df05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99383f8f5c276d8060f2105ff7e678c81bf4df05/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae75ef9e62b7df8c46865cfb907c56cab1f29f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae75ef9e62b7df8c46865cfb907c56cab1f29f81", "html_url": "https://github.com/rust-lang/rust/commit/ae75ef9e62b7df8c46865cfb907c56cab1f29f81"}], "stats": {"total": 367, "additions": 176, "deletions": 191}, "files": [{"sha": "f508798a8b6ed0297a74f60d1903340651931602", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=99383f8f5c276d8060f2105ff7e678c81bf4df05", "patch": "@@ -178,7 +178,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"filter: {}\",\n                     opt_str(&config.filter\n                                    .as_ref()\n-                                   .map(|re| re.to_string()))));\n+                                   .map(|re| re.to_owned()))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\",\n                     opt_str(&config.host_rustcflags)));\n@@ -205,19 +205,16 @@ pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n \n pub fn opt_str2(maybestr: Option<String>) -> String {\n     match maybestr {\n-        None => \"(none)\".to_string(),\n+        None => \"(none)\".to_owned(),\n         Some(s) => s,\n     }\n }\n \n pub fn run_tests(config: &Config) {\n     if config.target.contains(\"android\") {\n-        match config.mode {\n-            DebugInfoGdb => {\n-                println!(\"{} debug-info test uses tcp 5039 port.\\\n-                         please reserve it\", config.target);\n-            }\n-            _ =>{}\n+        if let DebugInfoGdb = config.mode {\n+            println!(\"{} debug-info test uses tcp 5039 port.\\\n+                     please reserve it\", config.target);\n         }\n \n         // android debug-info test uses remote debugger\n@@ -289,10 +286,10 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n-          Pretty => vec!(\".rs\".to_string()),\n-          _ => vec!(\".rc\".to_string(), \".rs\".to_string())\n+          Pretty => vec!(\".rs\".to_owned()),\n+          _ => vec!(\".rc\".to_owned(), \".rs\".to_owned())\n         };\n-    let invalid_prefixes = vec!(\".\".to_string(), \"#\".to_string(), \"~\".to_string());\n+    let invalid_prefixes = vec!(\".\".to_owned(), \"#\".to_owned(), \"~\".to_owned());\n     let name = testfile.file_name().unwrap().to_str().unwrap();\n \n     let mut valid = false;\n@@ -364,7 +361,7 @@ fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n                    full_version_line.char_at(pos + 3).is_digit(10) {\n                     continue\n                 }\n-                return Some(full_version_line[pos..pos+3].to_string());\n+                return Some(full_version_line[pos..pos+3].to_owned());\n             }\n             println!(\"Could not extract GDB version from line '{}'\",\n                      full_version_line);\n@@ -386,9 +383,8 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n     // We are only interested in the major version number, so this function\n     // will return `Some(\"179\")` and `Some(\"300\")` respectively.\n \n-    match full_version_line {\n-        Some(ref full_version_line)\n-          if !full_version_line.trim().is_empty() => {\n+    if let Some(ref full_version_line) = full_version_line {\n+        if !full_version_line.trim().is_empty() {\n             let full_version_line = full_version_line.trim();\n \n             for (pos, l) in full_version_line.char_indices() {\n@@ -410,8 +406,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n             }\n             println!(\"Could not extract LLDB version from line '{}'\",\n                      full_version_line);\n-            None\n-        },\n-        _ => None\n+        }\n     }\n+    None\n }"}, {"sha": "a3ad022ebd52faa65d16b11e1280ae5fa6263199", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=99383f8f5c276d8060f2105ff7e678c81bf4df05", "patch": "@@ -76,7 +76,7 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n     let letters = line[kind_start..].chars();\n     let msg = letters.skip_while(|c| c.is_whitespace())\n                      .skip_while(|c| !c.is_whitespace())\n-                     .collect::<String>().trim().to_string();\n+                     .collect::<String>().trim().to_owned();\n \n     let (which, line) = if follow {\n         assert!(adjusts == 0, \"use either //~| or //~^, not both.\");"}, {"sha": "9de46cef7455c150a681c3df228d6fbdef538d86", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 56, "deletions": 65, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=99383f8f5c276d8060f2105ff7e678c81bf4df05", "patch": "@@ -67,10 +67,9 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut pretty_compare_only = false;\n     let mut forbid_output = Vec::new();\n     iter_header(testfile, &mut |ln| {\n-        match parse_error_pattern(ln) {\n-          Some(ep) => error_patterns.push(ep),\n-          None => ()\n-        };\n+        if let Some(ep) = parse_error_pattern(ln) {\n+           error_patterns.push(ep);\n+        }\n \n         if compile_flags.is_none() {\n             compile_flags = parse_compile_flags(ln);\n@@ -108,24 +107,20 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             pretty_compare_only = parse_pretty_compare_only(ln);\n         }\n \n-        match parse_aux_build(ln) {\n-            Some(ab) => { aux_builds.push(ab); }\n-            None => {}\n+        if let  Some(ab) = parse_aux_build(ln) {\n+            aux_builds.push(ab);\n         }\n \n-        match parse_exec_env(ln) {\n-            Some(ee) => { exec_env.push(ee); }\n-            None => {}\n+        if let Some(ee) = parse_exec_env(ln) {\n+            exec_env.push(ee);\n         }\n \n-        match parse_check_line(ln) {\n-            Some(cl) => check_lines.push(cl),\n-            None => ()\n-        };\n+        if let Some(cl) =  parse_check_line(ln) {\n+            check_lines.push(cl);\n+        }\n \n-        match parse_forbid_output(ln) {\n-            Some(of) => forbid_output.push(of),\n-            None => (),\n+        if let Some(of) = parse_forbid_output(ln) {\n+            forbid_output.push(of);\n         }\n \n         true\n@@ -134,8 +129,8 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n         match env::var(key) {\n             Ok(val) =>\n-                if exec_env.iter().find(|&&(ref x, _)| *x == key.to_string()).is_none() {\n-                    exec_env.push((key.to_string(), val))\n+                if exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n+                    exec_env.push((key.to_owned(), val))\n                 },\n             Err(..) => {}\n         }\n@@ -153,7 +148,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         check_stdout: check_stdout,\n         no_prefer_dynamic: no_prefer_dynamic,\n         pretty_expanded: pretty_expanded,\n-        pretty_mode: pretty_mode.unwrap_or(\"normal\".to_string()),\n+        pretty_mode: pretty_mode.unwrap_or(\"normal\".to_owned()),\n         pretty_compare_only: pretty_compare_only,\n         forbid_output: forbid_output,\n     }\n@@ -182,22 +177,21 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n             return true;\n         }\n \n-        match config.gdb_version {\n-            Some(ref actual_version) => {\n-                if line.contains(\"min-gdb-version\") {\n-                    let min_version = line.trim()\n-                                          .split(' ')\n-                                          .last()\n-                                          .expect(\"Malformed GDB version directive\");\n-                    // Ignore if actual version is smaller the minimum required\n-                    // version\n-                    gdb_version_to_int(actual_version) <\n-                        gdb_version_to_int(min_version)\n-                } else {\n-                    false\n-                }\n+        if let Some(ref actual_version) = config.gdb_version {\n+            if line.contains(\"min-gdb-version\") {\n+                let min_version = line.trim()\n+                                      .split(' ')\n+                                      .last()\n+                                      .expect(\"Malformed GDB version directive\");\n+                // Ignore if actual version is smaller the minimum required\n+                // version\n+                gdb_version_to_int(actual_version) <\n+                    gdb_version_to_int(min_version)\n+            } else {\n+                false\n             }\n-            None => false\n+        } else {\n+            false\n         }\n     }\n \n@@ -210,22 +204,21 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n             return true;\n         }\n \n-        match config.lldb_version {\n-            Some(ref actual_version) => {\n-                if line.contains(\"min-lldb-version\") {\n-                    let min_version = line.trim()\n-                                          .split(' ')\n-                                          .last()\n-                                          .expect(\"Malformed lldb version directive\");\n-                    // Ignore if actual version is smaller the minimum required\n-                    // version\n-                    lldb_version_to_int(actual_version) <\n-                        lldb_version_to_int(min_version)\n-                } else {\n-                    false\n-                }\n+        if let Some(ref actual_version) = config.lldb_version {\n+            if line.contains(\"min-lldb-version\") {\n+                let min_version = line.trim()\n+                                      .split(' ')\n+                                      .last()\n+                                      .expect(\"Malformed lldb version directive\");\n+                // Ignore if actual version is smaller the minimum required\n+                // version\n+                lldb_version_to_int(actual_version) <\n+                    lldb_version_to_int(min_version)\n+            } else {\n+                false\n             }\n-            None => false\n+        } else {\n+            false\n         }\n     }\n \n@@ -316,11 +309,11 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<String> = nv\n                                       .splitn(2, '=')\n-                                      .map(|s| s.to_string())\n+                                      .map(str::to_owned)\n                                       .collect();\n \n         match strs.len() {\n-          1 => (strs.pop().unwrap(), \"\".to_string()),\n+          1 => (strs.pop().unwrap(), \"\".to_owned()),\n           2 => {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n@@ -331,33 +324,31 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n }\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n-    match parse_name_value_directive(line, \"pp-exact\") {\n-      Some(s) => Some(PathBuf::from(&s)),\n-      None => {\n+    if let Some(s) = parse_name_value_directive(line, \"pp-exact\") {\n+        Some(PathBuf::from(&s))\n+    } else {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.file_name().map(|s| PathBuf::from(s))\n+            testfile.file_name().map(PathBuf::from)\n         } else {\n             None\n         }\n-      }\n     }\n }\n \n fn parse_name_directive(line: &str, directive: &str) -> bool {\n     // This 'no-' rule is a quick hack to allow pretty-expanded and no-pretty-expanded to coexist\n-    line.contains(directive) && !line.contains(&(\"no-\".to_string() + directive))\n+    line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n }\n \n pub fn parse_name_value_directive(line: &str, directive: &str)\n                                   -> Option<String> {\n     let keycolon = format!(\"{}:\", directive);\n-    match line.find(&keycolon) {\n-        Some(colon) => {\n-            let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n-            debug!(\"{}: {}\", directive, value);\n-            Some(value)\n-        }\n-        None => None\n+    if let Some(colon) = line.find(&keycolon) {\n+        let value = line[(colon + keycolon.len()) .. line.len()].to_owned();\n+        debug!(\"{}: {}\", directive, value);\n+        Some(value)\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "66fa0dfecd4220d75617f98c000fa223f860786e", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=99383f8f5c276d8060f2105ff7e678c81bf4df05", "patch": "@@ -17,9 +17,8 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n     let mut path = DynamicLibrary::search_path();\n-    match aux_path {\n-        Some(p) => path.insert(0, PathBuf::from(p)),\n-        None => {}\n+    if let Some(p) = aux_path {\n+        path.insert(0, PathBuf::from(p))\n     }\n     path.insert(0, PathBuf::from(lib_path));\n "}, {"sha": "bed31b98b65c76798349c069e17f50b14dbcd6a8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=99383f8f5c276d8060f2105ff7e678c81bf4df05", "patch": "@@ -165,9 +165,9 @@ fn run_valgrind_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n-        logv(config, \"testing for exact pretty-printing\".to_string());\n+        logv(config, \"testing for exact pretty-printing\".to_owned());\n     } else {\n-        logv(config, \"testing for converging pretty-printing\".to_string());\n+        logv(config, \"testing for converging pretty-printing\".to_owned());\n     }\n \n     let rounds =\n@@ -183,7 +183,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = print_source(config,\n                                     props,\n                                     testfile,\n-                                    srcs[round].to_string(),\n+                                    srcs[round].to_owned(),\n                                     &props.pretty_mode);\n \n         if !proc_res.status.success() {\n@@ -209,9 +209,9 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n-        let cr = \"\\r\".to_string();\n-        actual = actual.replace(&cr, \"\").to_string();\n-        expected = expected.replace(&cr, \"\").to_string();\n+        let cr = \"\\r\".to_owned();\n+        actual = actual.replace(&cr, \"\").to_owned();\n+        expected = expected.replace(&cr, \"\").to_owned();\n     }\n \n     compare_source(&expected, &actual);\n@@ -253,7 +253,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                         make_pp_args(config,\n                                      props,\n                                      testfile,\n-                                     pretty_type.to_string()),\n+                                     pretty_type.to_owned()),\n                         props.exec_env.clone(),\n                         &config.compile_lib_path,\n                         Some(aux_dir.to_str().unwrap()),\n@@ -266,17 +266,17 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                     pretty_type: String) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_string(),\n-                            \"-Zunstable-options\".to_string(),\n-                            \"--pretty\".to_string(),\n+        let mut args = vec!(\"-\".to_owned(),\n+                            \"-Zunstable-options\".to_owned(),\n+                            \"--pretty\".to_owned(),\n                             pretty_type,\n                             format!(\"--target={}\", config.target),\n-                            \"-L\".to_string(),\n-                            aux_dir.to_str().unwrap().to_string());\n+                            \"-L\".to_owned(),\n+                            aux_dir.to_str().unwrap().to_owned());\n         args.extend(split_maybe_args(&config.target_rustcflags));\n         args.extend(split_maybe_args(&props.compile_flags));\n         return ProcArgs {\n-            prog: config.rustc_path.to_str().unwrap().to_string(),\n+            prog: config.rustc_path.to_str().unwrap().to_owned(),\n             args: args,\n         };\n     }\n@@ -313,18 +313,18 @@ actual:\\n\\\n             &*config.target\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_string(),\n-                            \"-Zno-trans\".to_string(),\n+        let mut args = vec!(\"-\".to_owned(),\n+                            \"-Zno-trans\".to_owned(),\n                             format!(\"--target={}\", target),\n-                            \"-L\".to_string(),\n-                            config.build_base.to_str().unwrap().to_string(),\n-                            \"-L\".to_string(),\n-                            aux_dir.to_str().unwrap().to_string());\n+                            \"-L\".to_owned(),\n+                            config.build_base.to_str().unwrap().to_owned(),\n+                            \"-L\".to_owned(),\n+                            aux_dir.to_str().unwrap().to_owned());\n         args.extend(split_maybe_args(&config.target_rustcflags));\n         args.extend(split_maybe_args(&props.compile_flags));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n-            prog: config.rustc_path.to_str().unwrap().to_string(),\n+            prog: config.rustc_path.to_str().unwrap().to_owned(),\n             args: args,\n         };\n     }\n@@ -387,24 +387,24 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          &config.adb_path,\n                          None,\n                          &[\n-                            \"push\".to_string(),\n-                            exe_file.to_str().unwrap().to_string(),\n+                            \"push\".to_owned(),\n+                            exe_file.to_str().unwrap().to_owned(),\n                             config.adb_test_dir.clone()\n                          ],\n-                         vec!((\"\".to_string(), \"\".to_string())),\n-                         Some(\"\".to_string()))\n+                         vec!((\"\".to_owned(), \"\".to_owned())),\n+                         Some(\"\".to_owned()))\n                 .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n \n             procsrv::run(\"\",\n                          &config.adb_path,\n                          None,\n                          &[\n-                            \"forward\".to_string(),\n-                            \"tcp:5039\".to_string(),\n-                            \"tcp:5039\".to_string()\n+                            \"forward\".to_owned(),\n+                            \"tcp:5039\".to_owned(),\n+                            \"tcp:5039\".to_owned()\n                          ],\n-                         vec!((\"\".to_string(), \"\".to_string())),\n-                         Some(\"\".to_string()))\n+                         vec!((\"\".to_owned(), \"\".to_owned())),\n+                         Some(\"\".to_owned()))\n                 .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n@@ -421,12 +421,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                             ,\n                                                       None,\n                                                       &[\n-                                                        \"shell\".to_string(),\n+                                                        \"shell\".to_owned(),\n                                                         adb_arg.clone()\n                                                       ],\n-                                                      vec!((\"\".to_string(),\n-                                                            \"\".to_string())),\n-                                                      Some(\"\".to_string()))\n+                                                      vec!((\"\".to_owned(),\n+                                                            \"\".to_owned())),\n+                                                      Some(\"\".to_owned()))\n                 .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n@@ -437,16 +437,16 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             }\n \n             let tool_path = match config.android_cross_path.to_str() {\n-                Some(x) => x.to_string(),\n+                Some(x) => x.to_owned(),\n                 None => fatal(\"cannot find android cross path\")\n             };\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let debugger_opts =\n-                vec!(\"-quiet\".to_string(),\n-                     \"-batch\".to_string(),\n-                     \"-nx\".to_string(),\n+                vec!(\"-quiet\".to_owned(),\n+                     \"-batch\".to_owned(),\n+                     \"-nx\".to_owned(),\n                      format!(\"-command={}\", debugger_script.to_str().unwrap()));\n \n             let mut gdb_path = tool_path;\n@@ -459,7 +459,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                              &gdb_path,\n                              None,\n                              &debugger_opts,\n-                             vec!((\"\".to_string(), \"\".to_string())),\n+                             vec!((\"\".to_owned(), \"\".to_owned())),\n                              None)\n                 .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n             let cmdline = {\n@@ -488,7 +488,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n                                                        .to_str()\n                                                        .unwrap()\n-                                                       .to_string();\n+                                                       .to_owned();\n             // write debugger script\n             let mut script_str = String::with_capacity(2048);\n             script_str.push_str(&format!(\"set charset {}\\n\", charset()));\n@@ -554,17 +554,17 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let debugger_opts =\n-                vec!(\"-quiet\".to_string(),\n-                     \"-batch\".to_string(),\n-                     \"-nx\".to_string(),\n+                vec!(\"-quiet\".to_owned(),\n+                     \"-batch\".to_owned(),\n+                     \"-nx\".to_owned(),\n                      format!(\"-command={}\", debugger_script.to_str().unwrap()));\n \n             let proc_args = ProcArgs {\n-                prog: debugger().to_string(),\n+                prog: debugger().to_owned(),\n                 args: debugger_opts,\n             };\n \n-            let environment = vec![(\"PYTHONPATH\".to_string(), rust_pp_module_abs_path)];\n+            let environment = vec![(\"PYTHONPATH\".to_owned(), rust_pp_module_abs_path)];\n \n             debugger_run_result = compose_and_run(config,\n                                                   testfile,\n@@ -650,7 +650,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n                                                .to_str()\n                                                .unwrap()\n-                                               .to_string();\n+                                               .to_owned();\n \n     script_str.push_str(&format!(\"command script import {}\\n\",\n                                  &rust_pp_module_abs_path[..])[..]);\n@@ -790,9 +790,9 @@ fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n \n     // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n     let options_to_remove = [\n-        \"-O\".to_string(),\n-        \"-g\".to_string(),\n-        \"--debuginfo\".to_string()\n+        \"-O\".to_owned(),\n+        \"-g\".to_owned(),\n+        \"--debuginfo\".to_owned()\n     ];\n     let new_options =\n         split_maybe_args(options).into_iter()\n@@ -812,7 +812,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                 s\n                  .trim()\n                  .split(\"[...]\")\n-                 .map(|x| x.to_string())\n+                 .map(str::to_owned)\n                  .collect()\n             }).collect();\n         // check if each line in props.check_lines appears in the\n@@ -1139,8 +1139,8 @@ fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_string(),\n-                         aux_dir.to_str().unwrap().to_string());\n+    let link_args = vec!(\"-L\".to_owned(),\n+                         aux_dir.to_str().unwrap().to_owned());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n@@ -1154,14 +1154,14 @@ fn document(config: &Config, props: &TestProps,\n     let out_dir = output_base_name(config, testfile);\n     let _ = fs::remove_dir_all(&out_dir);\n     ensure_dir(&out_dir);\n-    let mut args = vec![\"-L\".to_string(),\n-                        aux_dir.to_str().unwrap().to_string(),\n-                        \"-o\".to_string(),\n-                        out_dir.to_str().unwrap().to_string(),\n-                        testfile.to_str().unwrap().to_string()];\n+    let mut args = vec![\"-L\".to_owned(),\n+                        aux_dir.to_str().unwrap().to_owned(),\n+                        \"-o\".to_owned(),\n+                        out_dir.to_str().unwrap().to_owned(),\n+                        testfile.to_str().unwrap().to_owned()];\n     args.extend(split_maybe_args(&props.compile_flags));\n     let args = ProcArgs {\n-        prog: config.rustdoc_path.to_str().unwrap().to_string(),\n+        prog: config.rustdoc_path.to_str().unwrap().to_owned(),\n         args: args,\n     };\n     (compose_and_run_compiler(config, props, testfile, args, None), out_dir)\n@@ -1200,8 +1200,8 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n \n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let extra_link_args = vec![\"-L\".to_string(),\n-                               aux_dir.to_str().unwrap().to_string()];\n+    let extra_link_args = vec![\"-L\".to_owned(),\n+                               aux_dir.to_str().unwrap().to_owned()];\n \n     for rel_ab in &props.aux_builds {\n         let abs_ab = config.aux_base.join(rel_ab);\n@@ -1219,9 +1219,9 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n             // however, that if the library is built with `force_host` then it's\n             // ok to be a dylib as the host should always support dylibs.\n             if config.target.contains(\"musl\") && !aux_props.force_host {\n-                vec!(\"--crate-type=lib\".to_string())\n+                vec!(\"--crate-type=lib\".to_owned())\n             } else {\n-                vec!(\"--crate-type=dylib\".to_string())\n+                vec!(\"--crate-type=dylib\".to_owned())\n             }\n         };\n         crate_type.extend(extra_link_args.clone());\n@@ -1301,34 +1301,34 @@ fn make_compile_args<F>(config: &Config,\n         &*config.target\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = vec!(testfile.to_str().unwrap().to_string(),\n-                        \"-L\".to_string(),\n-                        config.build_base.to_str().unwrap().to_string(),\n+    let mut args = vec!(testfile.to_str().unwrap().to_owned(),\n+                        \"-L\".to_owned(),\n+                        config.build_base.to_str().unwrap().to_owned(),\n                         format!(\"--target={}\", target));\n     args.push_all(&extras);\n     if !props.no_prefer_dynamic {\n-        args.push(\"-C\".to_string());\n-        args.push(\"prefer-dynamic\".to_string());\n+        args.push(\"-C\".to_owned());\n+        args.push(\"prefer-dynamic\".to_owned());\n     }\n     let path = match xform_file {\n         TargetLocation::ThisFile(path) => {\n-            args.push(\"-o\".to_string());\n+            args.push(\"-o\".to_owned());\n             path\n         }\n         TargetLocation::ThisDirectory(path) => {\n-            args.push(\"--out-dir\".to_string());\n+            args.push(\"--out-dir\".to_owned());\n             path\n         }\n     };\n-    args.push(path.to_str().unwrap().to_string());\n+    args.push(path.to_str().unwrap().to_owned());\n     if props.force_host {\n         args.extend(split_maybe_args(&config.host_rustcflags));\n     } else {\n         args.extend(split_maybe_args(&config.target_rustcflags));\n     }\n     args.extend(split_maybe_args(&props.compile_flags));\n     return ProcArgs {\n-        prog: config.rustc_path.to_str().unwrap().to_string(),\n+        prog: config.rustc_path.to_str().unwrap().to_owned(),\n         args: args,\n     };\n }\n@@ -1358,7 +1358,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path)\n     let exe_file = make_exe_name(config, testfile);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    args.push(exe_file.to_str().unwrap().to_string());\n+    args.push(exe_file.to_str().unwrap().to_owned());\n \n     // Add the arguments in the run_flags directive\n     args.extend(split_maybe_args(&props.run_flags));\n@@ -1379,7 +1379,7 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n                  if s.chars().all(|c| c.is_whitespace()) {\n                      None\n                  } else {\n-                     Some(s.to_string())\n+                     Some(s.to_owned())\n                  }\n              }).collect()\n         }\n@@ -1514,7 +1514,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     // get bare program string\n     let mut tvec: Vec<String> = args.prog\n                                     .split('/')\n-                                    .map(|ts| ts.to_string())\n+                                    .map(str::to_owned)\n                                     .collect();\n     let prog_short = tvec.pop().unwrap();\n \n@@ -1523,12 +1523,12 @@ fn _arm_exec_compiled_test(config: &Config,\n                                    &config.adb_path,\n                                    None,\n                                    &[\n-                                    \"push\".to_string(),\n+                                    \"push\".to_owned(),\n                                     args.prog.clone(),\n                                     config.adb_test_dir.clone()\n                                    ],\n-                                   vec!((\"\".to_string(), \"\".to_string())),\n-                                   Some(\"\".to_string()))\n+                                   vec!((\"\".to_owned(), \"\".to_owned())),\n+                                   Some(\"\".to_owned()))\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n@@ -1544,7 +1544,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     let mut runargs = Vec::new();\n \n     // run test via adb_run_wrapper\n-    runargs.push(\"shell\".to_string());\n+    runargs.push(\"shell\".to_owned());\n     for (key, val) in env {\n         runargs.push(format!(\"{}={}\", key, val));\n     }\n@@ -1553,28 +1553,28 @@ fn _arm_exec_compiled_test(config: &Config,\n     runargs.push(format!(\"{}\", prog_short));\n \n     for tv in &args.args {\n-        runargs.push(tv.to_string());\n+        runargs.push(tv.to_owned());\n     }\n     procsrv::run(\"\",\n                  &config.adb_path,\n                  None,\n                  &runargs,\n-                 vec!((\"\".to_string(), \"\".to_string())), Some(\"\".to_string()))\n+                 vec!((\"\".to_owned(), \"\".to_owned())), Some(\"\".to_owned()))\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_string());\n-    runargs.push(\"cat\".to_string());\n+    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"cat\".to_owned());\n     runargs.push(format!(\"{}/{}.exitcode\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      &config.adb_path,\n                      None,\n                      &runargs,\n-                     vec!((\"\".to_string(), \"\".to_string())),\n-                     Some(\"\".to_string()))\n+                     vec!((\"\".to_owned(), \"\".to_owned())),\n+                     Some(\"\".to_owned()))\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     let mut exitcode: i32 = 0;\n@@ -1588,32 +1588,32 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     // get stdout of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_string());\n-    runargs.push(\"cat\".to_string());\n+    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"cat\".to_owned());\n     runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      &config.adb_path,\n                      None,\n                      &runargs,\n-                     vec!((\"\".to_string(), \"\".to_string())),\n-                     Some(\"\".to_string()))\n+                     vec!((\"\".to_owned(), \"\".to_owned())),\n+                     Some(\"\".to_owned()))\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_string());\n-    runargs.push(\"cat\".to_string());\n+    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"cat\".to_owned());\n     runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      &config.adb_path,\n                      None,\n                      &runargs,\n-                     vec!((\"\".to_string(), \"\".to_string())),\n-                     Some(\"\".to_string()))\n+                     vec!((\"\".to_owned(), \"\".to_owned())),\n+                     Some(\"\".to_owned()))\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config,\n@@ -1641,15 +1641,15 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n                                            &config.adb_path,\n                                            None,\n                                            &[\n-                                            \"push\".to_string(),\n+                                            \"push\".to_owned(),\n                                             file.to_str()\n                                                 .unwrap()\n-                                                .to_string(),\n-                                            config.adb_test_dir.to_string(),\n+                                                .to_owned(),\n+                                            config.adb_test_dir.to_owned(),\n                                            ],\n-                                           vec!((\"\".to_string(),\n-                                                 \"\".to_string())),\n-                                           Some(\"\".to_string()))\n+                                           vec!((\"\".to_owned(),\n+                                                 \"\".to_owned())),\n+                                           Some(\"\".to_owned()))\n                 .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n             if config.verbose {\n@@ -1667,10 +1667,10 @@ fn compile_test_and_save_ir(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut link_args = vec!(\"-L\".to_string(),\n-                             aux_dir.to_str().unwrap().to_string());\n-    let llvm_args = vec!(\"--emit=llvm-ir\".to_string(),\n-                         \"--crate-type=lib\".to_string());\n+    let mut link_args = vec!(\"-L\".to_owned(),\n+                             aux_dir.to_str().unwrap().to_owned());\n+    let llvm_args = vec!(\"--emit=llvm-ir\".to_owned(),\n+                         \"--crate-type=lib\".to_owned());\n     link_args.extend(llvm_args);\n     let args = make_compile_args(config,\n                                  props,\n@@ -1687,9 +1687,9 @@ fn check_ir_with_filecheck(config: &Config, testfile: &Path) -> ProcRes {\n     let prog = config.llvm_bin_path.as_ref().unwrap().join(\"FileCheck\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.to_str().unwrap().to_string(),\n+        prog: prog.to_str().unwrap().to_owned(),\n         args: vec!(format!(\"-input-file={}\", irfile.to_str().unwrap()),\n-                   testfile.to_str().unwrap().to_string())\n+                   testfile.to_str().unwrap().to_owned())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }"}, {"sha": "fbafee102e4b2a59e3ba05934f1c9be865560c74", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99383f8f5c276d8060f2105ff7e678c81bf4df05/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=99383f8f5c276d8060f2105ff7e678c81bf4df05", "patch": "@@ -73,7 +73,7 @@ pub fn make_new_path(path: &str) -> String {\n         Ok(curr) => {\n             format!(\"{}{}{}\", path, path_div(), curr)\n         }\n-        Err(..) => path.to_string()\n+        Err(..) => path.to_owned()\n     }\n }\n "}]}