{"sha": "e500659eb5482aea8b4675416449b03d5cfbe898", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MDA2NTllYjU0ODJhZWE4YjQ2NzU0MTY0NDliMDNkNWNmYmU4OTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-26T00:39:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-26T00:39:23Z"}, "message": "rustc: Reduce shape.rs to the bare minimum needed to not trigger bugs", "tree": {"sha": "cfbfeb9c4fe905bcc77d1d9e238dd1ea56b65e93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfbfeb9c4fe905bcc77d1d9e238dd1ea56b65e93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e500659eb5482aea8b4675416449b03d5cfbe898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e500659eb5482aea8b4675416449b03d5cfbe898", "html_url": "https://github.com/rust-lang/rust/commit/e500659eb5482aea8b4675416449b03d5cfbe898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e500659eb5482aea8b4675416449b03d5cfbe898/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "954eee53109e081f09cbccf2104752ed7eaa4119", "url": "https://api.github.com/repos/rust-lang/rust/commits/954eee53109e081f09cbccf2104752ed7eaa4119", "html_url": "https://github.com/rust-lang/rust/commit/954eee53109e081f09cbccf2104752ed7eaa4119"}], "stats": {"total": 169, "additions": 6, "deletions": 163}, "files": [{"sha": "cf58b5b51c4c3631fcc02440f3e8aecd35441d88", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 6, "deletions": 163, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e500659eb5482aea8b4675416449b03d5cfbe898/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500659eb5482aea8b4675416449b03d5cfbe898/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=e500659eb5482aea8b4675416449b03d5cfbe898", "patch": "@@ -23,92 +23,13 @@ use option::is_some;\n \n use ty_ctxt = middle::ty::ctxt;\n \n-type nominal_id_ = {did: ast::def_id, parent_id: Option<ast::def_id>,\n-                    tps: ~[ty::t]};\n-type nominal_id = @nominal_id_;\n-\n-impl nominal_id_ : core::cmp::Eq {\n-    pure fn eq(other: &nominal_id_) -> bool {\n-        if self.did != other.did ||\n-            self.parent_id != other.parent_id {\n-            false\n-        } else {\n-            do vec::all2(self.tps, other.tps) |m_tp, n_tp| {\n-                ty::type_id(m_tp) == ty::type_id(n_tp)\n-            }\n-        }\n-    }\n-    pure fn ne(other: &nominal_id_) -> bool {\n-        ! (self == *other)\n-    }\n-}\n-\n-impl nominal_id_ : to_bytes::IterBytes {\n-    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.did, &self.parent_id, lsb0, f);\n-        for self.tps.each |t| {\n-            ty::type_id(*t).iter_bytes(lsb0, f);\n-        }\n-    }\n-}\n-\n-fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n-                 parent_id: Option<ast::def_id>,\n-                 tps: ~[ty::t]) -> nominal_id {\n-    let tps_norm = tps.map(|t| ty::normalize_ty(tcx, *t));\n-    @{did: did, parent_id: parent_id, tps: tps_norm}\n-}\n-\n-fn new_nominal_id_hash<T: Copy>() -> HashMap<nominal_id, T> {\n-    return HashMap();\n-}\n-\n-type enum_data = {did: ast::def_id, substs: ty::substs};\n-\n-type ctxt =\n-    {mut next_tag_id: u16,\n-     pad: u16,\n-     tag_id_to_index: HashMap<nominal_id, u16>,\n-     tag_order: DVec<enum_data>,\n-     resources: interner::interner<nominal_id>,\n-     llshapetablesty: TypeRef,\n-     llshapetables: ValueRef};\n-\n-const shape_u8: u8 = 0u8;\n-const shape_u16: u8 = 1u8;\n-const shape_u32: u8 = 2u8;\n-const shape_u64: u8 = 3u8;\n-const shape_i8: u8 = 4u8;\n-const shape_i16: u8 = 5u8;\n-const shape_i32: u8 = 6u8;\n-const shape_i64: u8 = 7u8;\n-const shape_f32: u8 = 8u8;\n-const shape_f64: u8 = 9u8;\n-const shape_box: u8 = 10u8;\n-const shape_enum: u8 = 12u8;\n-const shape_struct: u8 = 17u8;\n-const shape_box_fn: u8 = 18u8;\n-const shape_res: u8 = 20u8;\n-const shape_uniq: u8 = 22u8;\n-const shape_opaque_closure_ptr: u8 = 23u8; // the closure itself.\n-const shape_uniq_fn: u8 = 25u8;\n-const shape_stack_fn: u8 = 26u8;\n-const shape_bare_fn: u8 = 27u8;\n-const shape_tydesc: u8 = 28u8;\n-const shape_send_tydesc: u8 = 29u8;\n-const shape_rptr: u8 = 31u8;\n-const shape_fixedvec: u8 = 32u8;\n-const shape_slice: u8 = 33u8;\n-const shape_unboxed_vec: u8 = 34u8;\n+type ctxt = {mut next_tag_id: u16, pad: u16, pad2: u32};\n \n fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n-    let llglobal =\n-        str::as_c_str(name,\n-                      |buf| {\n-                        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod,\n-                                                       val_ty(llval), buf)\n-                    });\n+    let llglobal = do str::as_c_str(name) |buf| {\n+        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+    };\n     lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n     lib::llvm::llvm::LLVMSetGlobalConstant(llglobal, True);\n \n@@ -119,91 +40,13 @@ fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n     return llglobal;\n }\n \n-\n-// Computes a set of variants of a enum that are guaranteed to have size and\n-// alignment at least as large as any other variant of the enum. This is an\n-// important performance optimization.\n-\n-fn round_up(size: u16, align: u8) -> u16 {\n-    assert (align >= 1u8);\n-    let alignment = align as u16;\n-    return size - 1u16 + alignment & !(alignment - 1u16);\n-}\n-\n-type size_align = {size: u16, align: u8};\n-\n-enum enum_kind {\n-    tk_unit,    // 1 variant, no data\n-    tk_enum,    // N variants, no data\n-    tk_newtype, // 1 variant, data\n-    tk_complex  // N variants, no data\n-}\n-\n-fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n-    let variants = ty::enum_variants(ccx.tcx, did);\n-    if vec::any(*variants, |v| vec::len(v.args) > 0u) {\n-        if vec::len(*variants) == 1u { tk_newtype }\n-        else { tk_complex }\n-    } else {\n-        if vec::len(*variants) <= 1u { tk_unit }\n-        else { tk_enum }\n-    }\n-}\n-\n-// Returns the code corresponding to the pointer size on this architecture.\n-fn s_int(tcx: ty_ctxt) -> u8 {\n-    return match tcx.sess.targ_cfg.arch {\n-        session::arch_x86 => shape_i32,\n-        session::arch_x86_64 => shape_i64,\n-        session::arch_arm => shape_i32\n-    };\n-}\n-\n-fn s_uint(tcx: ty_ctxt) -> u8 {\n-    return match tcx.sess.targ_cfg.arch {\n-        session::arch_x86 => shape_u32,\n-        session::arch_x86_64 => shape_u64,\n-        session::arch_arm => shape_u32\n-    };\n-}\n-\n-fn s_float(tcx: ty_ctxt) -> u8 {\n-    return match tcx.sess.targ_cfg.arch {\n-        session::arch_x86 => shape_f64,\n-        session::arch_x86_64 => shape_f64,\n-        session::arch_arm => shape_f64\n-    };\n-}\n-\n-fn s_variant_enum_t(tcx: ty_ctxt) -> u8 {\n-    return s_int(tcx);\n-}\n-\n-fn s_tydesc(_tcx: ty_ctxt) -> u8 {\n-    return shape_tydesc;\n-}\n-\n-fn s_send_tydesc(_tcx: ty_ctxt) -> u8 {\n-    return shape_send_tydesc;\n-}\n-\n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     let llshapetablesty = trans::common::T_named_struct(~\"shapes\");\n-    let llshapetables = str::as_c_str(~\"shapes\", |buf| {\n+    let _llshapetables = str::as_c_str(~\"shapes\", |buf| {\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });\n \n-    return {mut next_tag_id: 0u16,\n-         pad: 0u16,\n-         tag_id_to_index: new_nominal_id_hash(),\n-         tag_order: DVec(),\n-         resources: interner::mk(),\n-         llshapetablesty: llshapetablesty,\n-         llshapetables: llshapetables};\n-}\n-\n-fn add_bool(&dest: ~[u8], val: bool) {\n-    dest += ~[if val { 1u8 } else { 0u8 }];\n+    return {mut next_tag_id: 0u16, pad: 0u16, pad2: 0u32};\n }\n \n fn add_u16(&dest: ~[u8], val: u16) {"}]}