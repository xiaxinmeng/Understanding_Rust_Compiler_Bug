{"sha": "93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZDA5N2ViMTJmYzBiN2UzNDE4N2QyY2FjMTliMDA1OWZhMThlZDQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-23T11:19:13Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-29T08:45:18Z"}, "message": "better simplification", "tree": {"sha": "d300550895f693138ef0c3338ff8d72f9a51bbc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d300550895f693138ef0c3338ff8d72f9a51bbc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "html_url": "https://github.com/rust-lang/rust/commit/93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94f10ee69a98dec32961240376e3d87831ced4ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/94f10ee69a98dec32961240376e3d87831ced4ae", "html_url": "https://github.com/rust-lang/rust/commit/94f10ee69a98dec32961240376e3d87831ced4ae"}], "stats": {"total": 171, "additions": 169, "deletions": 2}, "files": [{"sha": "93886e214e012d45daed688ffcc89eacfdc8efdf", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "patch": "@@ -23,6 +23,7 @@ regex_macros = { version = \"0.1.33\", optional = true }\n semver = \"0.2.1\"\n toml = \"0.1\"\n unicode-normalization = \"0.1\"\n+quine-mc_cluskey = \"0.2\"\n \n [dev-dependencies]\n compiletest_rs = \"0.1.0\""}, {"sha": "cd8b0257c6e7d5a828c8ee7a058fdea09c6cbb5c", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 137 lints included in this crate:\n+There are 138 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -97,6 +97,7 @@ name\n [new_without_default](https://github.com/Manishearth/rust-clippy/wiki#new_without_default)                           | warn    | `fn new() -> Self` method without `Default` implementation\n [no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                               | warn    | statements with no effect\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+[nonminimal_bool](https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool)                                   | warn    | checks for boolean expressions that can be written more concisely\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)                 | warn    | nonsensical combination of options for opening a file\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                               | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n [option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                         | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`"}, {"sha": "90e4dee976940fab5cf8133df0b2b8891577dc9f", "filename": "src/booleans.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/src%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/src%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbooleans.rs?ref=93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "patch": "@@ -0,0 +1,155 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use rustc_front::intravisit::*;\n+use syntax::ast::LitKind;\n+use utils::{span_lint_and_then, in_macro, snippet_opt};\n+\n+/// **What it does:** This lint checks for boolean expressions that can be written more concisely\n+///\n+/// **Why is this bad?** Readability of boolean expressions suffers from unnecesessary duplication\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `if a && b || a` should be `if a`\n+declare_lint! {\n+    pub NONMINIMAL_BOOL, Warn,\n+    \"checks for boolean expressions that can be written more concisely\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct NonminimalBool;\n+\n+impl LintPass for NonminimalBool {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NONMINIMAL_BOOL)\n+    }\n+}\n+\n+impl LateLintPass for NonminimalBool {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &Crate) {\n+        krate.visit_all_items(&mut NonminimalBoolVisitor(cx))\n+    }\n+}\n+\n+struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+\n+use quine_mc_cluskey::Bool;\n+struct Hir2Qmm<'tcx>(Vec<&'tcx Expr>);\n+\n+impl<'tcx> Hir2Qmm<'tcx> {\n+    fn extract(&mut self, op: BinOp_, a: &[&'tcx Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n+        for a in a {\n+            if let ExprBinary(binop, ref lhs, ref rhs) = a.node {\n+                if binop.node == op {\n+                    v = self.extract(op, &[lhs, rhs], v)?;\n+                    continue;\n+                }\n+            }\n+            v.push(self.run(a)?);\n+        }\n+        Ok(v)\n+    }\n+\n+    fn run(&mut self, e: &'tcx Expr) -> Result<Bool, String> {\n+        match e.node {\n+            ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+            ExprBinary(binop, ref lhs, ref rhs) => {\n+                match binop.node {\n+                    BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n+                    BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n+                    _ => {},\n+                }\n+            },\n+            ExprLit(ref lit) => {\n+                match lit.node {\n+                    LitKind::Bool(true) => return Ok(Bool::True),\n+                    LitKind::Bool(false) => return Ok(Bool::False),\n+                    _ => {},\n+                }\n+            },\n+            _ => {},\n+        }\n+        let n = self.0.len();\n+        self.0.push(e);\n+        if n < 32 {\n+            #[allow(cast_possible_truncation)]\n+            Ok(Bool::Term(n as u8))\n+        } else {\n+            Err(\"too many literals\".to_owned())\n+        }\n+    }\n+}\n+\n+fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n+    fn recurse(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr], mut s: String) -> String {\n+        use quine_mc_cluskey::Bool::*;\n+        match *suggestion {\n+            True => {\n+                s.extend(\"true\".chars());\n+                s\n+            },\n+            False => {\n+                s.extend(\"false\".chars());\n+                s\n+            },\n+            Not(ref inner) => {\n+                s.push('!');\n+                recurse(cx, inner, terminals, s)\n+            },\n+            And(ref v) => {\n+                s = recurse(cx, &v[0], terminals, s);\n+                for inner in &v[1..] {\n+                    s.extend(\" && \".chars());\n+                    s = recurse(cx, inner, terminals, s);\n+                }\n+                s\n+            },\n+            Or(ref v) => {\n+                s = recurse(cx, &v[0], terminals, s);\n+                for inner in &v[1..] {\n+                    s.extend(\" || \".chars());\n+                    s = recurse(cx, inner, terminals, s);\n+                }\n+                s\n+            },\n+            Term(n) => {\n+                s.extend(snippet_opt(cx, terminals[n as usize].span).expect(\"don't try to improve booleans created by macros\").chars());\n+                s\n+            }\n+        }\n+    }\n+    recurse(cx, suggestion, terminals, String::new())\n+}\n+\n+impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n+    fn bool_expr(&self, e: &Expr) {\n+        let mut h2q = Hir2Qmm(Vec::new());\n+        if let Ok(expr) = h2q.run(e) {\n+            let simplified = expr.simplify();\n+            if !simplified.iter().any(|s| *s == expr) {\n+                span_lint_and_then(self.0, NONMINIMAL_BOOL, e.span, \"this boolean expression can be simplified\", |db| {\n+                    for suggestion in &simplified {\n+                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.0));\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'v Expr) {\n+        if in_macro(self.0, e.span) { return }\n+        match e.node {\n+            ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n+            ExprUnary(UnNot, ref inner) => {\n+                if self.0.tcx.node_types()[&inner.id].is_bool() {\n+                    self.bool_expr(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            },\n+            _ => walk_expr(self, e),\n+        }\n+    }\n+}"}, {"sha": "575e318e7ad8ad66f7238489c9e59e38fc25a19f", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "patch": "@@ -4,6 +4,8 @@\n #![feature(iter_arith)]\n #![feature(custom_attribute)]\n #![feature(slice_patterns)]\n+#![feature(question_mark)]\n+#![feature(stmt_expr_attributes)]\n #![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n \n // this only exists to allow the \"dogfood\" integration test to work\n@@ -35,6 +37,9 @@ extern crate semver;\n // for regex checking\n extern crate regex_syntax;\n \n+// for finding minimal boolean expressions\n+extern crate quine_mc_cluskey;\n+\n extern crate rustc_plugin;\n extern crate rustc_const_eval;\n use rustc_plugin::Registry;\n@@ -50,6 +55,7 @@ pub mod attrs;\n pub mod bit_mask;\n pub mod blacklisted_name;\n pub mod block_in_if_condition;\n+pub mod booleans;\n pub mod collapsible_if;\n pub mod copies;\n pub mod cyclomatic_complexity;\n@@ -149,6 +155,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     reg.register_late_lint_pass(box types::TypePass);\n+    reg.register_late_lint_pass(box booleans::NonminimalBool);\n     reg.register_late_lint_pass(box misc::TopLevelRefPass);\n     reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n@@ -260,6 +267,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         blacklisted_name::BLACKLISTED_NAME,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n+        booleans::NONMINIMAL_BOOL,\n         collapsible_if::COLLAPSIBLE_IF,\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,"}, {"sha": "19fa949fb84f282a4a9e7c6b7a9f39fc2ad3e453", "filename": "tests/compile-fail/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblock_in_if_condition.rs?ref=93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "patch": "@@ -67,7 +67,7 @@ fn pred_test() {\n \n fn condition_is_normal() -> i32 {\n     let x = 3;\n-    if true && x == 3 {\n+    if true && x == 3 { //~ WARN this boolean expression can be simplified\n         6\n     } else {\n         10"}, {"sha": "bd76695e6ad980c767cb59ad5de4b87ce89054e2", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93d097eb12fc0b7e34187d2cac19b0059fa18ed4/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=93d097eb12fc0b7e34187d2cac19b0059fa18ed4", "patch": "@@ -38,7 +38,9 @@ fn main() {\n     1 - 1; //~ERROR equal expressions\n     1 / 1; //~ERROR equal expressions\n     true && true; //~ERROR equal expressions\n+    //~|WARN this boolean expression can be simplified\n     true || true; //~ERROR equal expressions\n+    //~|WARN this boolean expression can be simplified\n \n     let mut a = vec![1];\n     a == a; //~ERROR equal expressions"}]}