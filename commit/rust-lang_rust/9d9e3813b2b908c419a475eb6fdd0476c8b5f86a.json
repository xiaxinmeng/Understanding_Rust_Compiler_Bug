{"sha": "9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkOWUzODEzYjJiOTA4YzQxOWE0NzVlYjZmZGQwNDc2YzhiNWY4NmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-21T04:33:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-21T04:33:21Z"}, "message": "Rollup merge of #70111 - Mark-Simulacrum:btree-no-shared, r=cuviper\n\nBTreeMap: remove shared root\n\nThis replaces the shared root with `Option`s in the BTreeMap code, and then slightly cleans up the node manipulation code taking advantage of the removal of the shared root. I expect that further simplification is possible, but wanted to get this posted for initial review.\n\nNote that `BTreeMap::new()` continues to not allocate.\n\nBenchmarks seem within the margin of error/unaffected, as expected for an entirely predictable branch.\n\n```\n name                                 alloc-bench-a ns/iter  alloc-bench-b ns/iter  diff ns/iter  diff %  speedup\n btree::map::iter_mut_20              20                     21                                1   5.00%   x 0.95\n btree::set::clone_100                1,360                  1,439                            79   5.81%   x 0.95\n btree::set::clone_100_and_into_iter  1,319                  1,434                           115   8.72%   x 0.92\n btree::set::clone_10k                143,515                150,991                       7,476   5.21%   x 0.95\n btree::set::clone_10k_and_clear      142,792                152,916                      10,124   7.09%   x 0.93\n btree::set::clone_10k_and_into_iter  146,019                154,561                       8,542   5.85%   x 0.94\n```", "tree": {"sha": "7f5e579b1637d363864189edd91509fe9a5aafb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f5e579b1637d363864189edd91509fe9a5aafb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedZkRCRBK7hj4Ov3rIwAAdHIIAD8Zd2+8uZ1CtVIfN1BZjIws\nJ17I1xWKcWz5zO3zaQl2HWDG/gVMjjBIvfhtAMiAKHzPmqkU+KAO4QfPJm02T+gY\nNcm203o1e2BfgRjuUSE4ULkYGGxM38WqBZQ9AKBTDgwdGSxcOtLu8lwrhZeC7bb/\nA3cax5idhhDEkblDlr0sAfcL+0GdlC0+gPzCfJnRzq1NHPq7rviZk/awbHIU2pEC\nQ9G7LjWKg16VaRaeY03XCO53Mtr0Opr+9z8NCt/aGVWzE097Xtc6EuREtfXu+sJk\nKy7vD2kjAGxF7HNeZjE60o9w58luinyqdZbDcowsK5idHweYrRk2ESOnfqxaM4w=\n=TxBW\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f5e579b1637d363864189edd91509fe9a5aafb3\nparent 67e418ce75b6aab0918268e4268570b7215abe68\nparent bce7f6f3a09c0dc2e56c8b3a9f17c8a18cada009\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584765201 +0100\ncommitter GitHub <noreply@github.com> 1584765201 +0100\n\nRollup merge of #70111 - Mark-Simulacrum:btree-no-shared, r=cuviper\n\nBTreeMap: remove shared root\n\nThis replaces the shared root with `Option`s in the BTreeMap code, and then slightly cleans up the node manipulation code taking advantage of the removal of the shared root. I expect that further simplification is possible, but wanted to get this posted for initial review.\n\nNote that `BTreeMap::new()` continues to not allocate.\n\nBenchmarks seem within the margin of error/unaffected, as expected for an entirely predictable branch.\n\n```\n name                                 alloc-bench-a ns/iter  alloc-bench-b ns/iter  diff ns/iter  diff %  speedup\n btree::map::iter_mut_20              20                     21                                1   5.00%   x 0.95\n btree::set::clone_100                1,360                  1,439                            79   5.81%   x 0.95\n btree::set::clone_100_and_into_iter  1,319                  1,434                           115   8.72%   x 0.92\n btree::set::clone_10k                143,515                150,991                       7,476   5.21%   x 0.95\n btree::set::clone_10k_and_clear      142,792                152,916                      10,124   7.09%   x 0.93\n btree::set::clone_10k_and_into_iter  146,019                154,561                       8,542   5.85%   x 0.94\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "html_url": "https://github.com/rust-lang/rust/commit/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67e418ce75b6aab0918268e4268570b7215abe68", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e418ce75b6aab0918268e4268570b7215abe68", "html_url": "https://github.com/rust-lang/rust/commit/67e418ce75b6aab0918268e4268570b7215abe68"}, {"sha": "bce7f6f3a09c0dc2e56c8b3a9f17c8a18cada009", "url": "https://api.github.com/repos/rust-lang/rust/commits/bce7f6f3a09c0dc2e56c8b3a9f17c8a18cada009", "html_url": "https://github.com/rust-lang/rust/commit/bce7f6f3a09c0dc2e56c8b3a9f17c8a18cada009"}], "stats": {"total": 489, "additions": 223, "deletions": 266}, "files": [{"sha": "cae64ef6665bb0b64fc5c827cca265f97c7104dd", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "patch": "@@ -370,12 +370,17 @@ def to_string(self):\n                 (\"(len: %i)\" % self.__val.get_wrapped_value()['map']['length']))\n \n     def children(self):\n-        root = self.__val.get_wrapped_value()['map']['root']\n-        node_ptr = root['node']\n-        i = 0\n-        for child in children_of_node(node_ptr, root['height'], False):\n-            yield (str(i), child)\n-            i = i + 1\n+        prev_idx = None\n+        innermap = GdbValue(self.__val.get_wrapped_value()['map'])\n+        if innermap.get_wrapped_value()['length'] > 0:\n+            root = GdbValue(innermap.get_wrapped_value()['root'])\n+            type_name = str(root.type.ty.name).replace('core::option::Option<', '')[:-1]\n+            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n+            node_ptr = root['node']\n+            i = 0\n+            for child in children_of_node(node_ptr, root['height'], False):\n+                yield (str(i), child)\n+                i = i + 1\n \n \n class RustStdBTreeMapPrinter(object):\n@@ -391,13 +396,16 @@ def to_string(self):\n                 (\"(len: %i)\" % self.__val.get_wrapped_value()['length']))\n \n     def children(self):\n-        root = self.__val.get_wrapped_value()['root']\n-        node_ptr = root['node']\n-        i = 0\n-        for child in children_of_node(node_ptr, root['height'], True):\n-            yield (str(i), child[0])\n-            yield (str(i), child[1])\n-            i = i + 1\n+        if self.__val.get_wrapped_value()['length'] > 0:\n+            root = GdbValue(self.__val.get_wrapped_value()['root'])\n+            type_name = str(root.type.ty.name).replace('core::option::Option<', '')[:-1]\n+            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n+            node_ptr = root['node']\n+            i = 0\n+            for child in children_of_node(node_ptr, root['height'], True):\n+                yield (str(i), child[0])\n+                yield (str(i), child[1])\n+                i = i + 1\n \n \n class RustStdStringPrinter(object):"}, {"sha": "3ba7befc0460924215d4890e5df2fa494ac5f5f0", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 116, "deletions": 83, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "patch": "@@ -122,7 +122,7 @@ use UnderflowResult::*;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: node::Root<K, V>,\n+    root: Option<node::Root<K, V>>,\n     length: usize,\n }\n \n@@ -147,10 +147,11 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: node::Root::new_leaf(), length: 0 };\n+                    let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n \n                     {\n-                        let mut out_node = match out_tree.root.as_mut().force() {\n+                        let root = out_tree.root.as_mut().unwrap();\n+                        let mut out_node = match root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -169,9 +170,14 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n+                    out_tree.ensure_root_is_owned();\n \n                     {\n-                        let mut out_node = out_tree.root.push_level();\n+                        // Ideally we'd use the return of ensure_root_is_owned\n+                        // instead of re-unwrapping here but unfortunately that\n+                        // borrows all of out_tree and we need access to the\n+                        // length below.\n+                        let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -190,7 +196,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot);\n+                            out_node.push(k, v, subroot.unwrap_or_else(|| node::Root::new_leaf()));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -203,9 +209,9 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n-            BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+            BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref())\n+            clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n \n@@ -271,14 +277,14 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_kv()\n@@ -290,7 +296,7 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut(), &key) {\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut()?.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -344,15 +350,18 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n     length: usize,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -417,8 +426,8 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -437,8 +446,8 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -447,7 +456,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -544,7 +556,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n-        BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+        BTreeMap { root: None, length: 0 }\n     }\n \n     /// Clears the map, removing all elements.\n@@ -589,7 +601,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -616,7 +628,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), k) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -645,7 +657,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = self.root.as_ref().first_leaf_edge();\n+        let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -674,7 +686,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = self.root.as_mut().first_leaf_edge();\n+        let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n         if let Ok(kv) = front.right_kv() {\n             Some(OccupiedEntry {\n                 handle: kv.forget_node_type(),\n@@ -708,7 +720,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = self.root.as_ref().last_leaf_edge();\n+        let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -737,7 +749,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = self.root.as_mut().last_leaf_edge();\n+        let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n         if let Ok(kv) = back.left_kv() {\n             Some(OccupiedEntry {\n                 handle: kv.forget_node_type(),\n@@ -801,7 +813,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n             GoDown(_) => None,\n         }\n@@ -896,7 +908,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_entry(),\n@@ -992,11 +1004,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_ref();\n-        let root2 = self.root.as_ref();\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &self.root {\n+            let root1 = root.as_ref();\n+            let root2 = root.as_ref();\n+            let (f, b) = range_search(root1, root2, range);\n \n-        Range { front: f, back: b }\n+            Range { front: Some(f), back: Some(b) }\n+        } else {\n+            Range { front: None, back: None }\n+        }\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -1036,11 +1052,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &mut self.root {\n+            let root1 = root.as_mut();\n+            let root2 = unsafe { ptr::read(&root1) };\n+            let (f, b) = range_search(root1, root2, range);\n \n-        RangeMut { front: f, back: b, _marker: PhantomData }\n+            RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n+        } else {\n+            RangeMut { front: None, back: None, _marker: PhantomData }\n+        }\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1065,7 +1085,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         self.ensure_root_is_owned();\n-        match search::search_tree(self.root.as_mut(), &key) {\n+        match search::search_tree(self.root.as_mut().unwrap().as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1077,7 +1097,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1126,7 +1146,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn fix_right_edge(&mut self) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.root.as_mut();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1187,14 +1207,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n-        right.root = node::Root::new_leaf();\n-        for _ in 0..(self.root.as_ref().height()) {\n-            right.root.push_level();\n+        let right_root = right.ensure_root_is_owned();\n+        for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n+            right_root.push_level();\n         }\n \n         {\n-            let mut left_node = self.root.as_mut();\n-            let mut right_node = right.root.as_mut();\n+            let mut left_node = self.root.as_mut().unwrap().as_mut();\n+            let mut right_node = right.root.as_mut().unwrap().as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1223,7 +1243,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_right_border();\n         right.fix_left_border();\n \n-        if self.root.as_ref().height() < right.root.as_ref().height() {\n+        if self.root.as_ref().unwrap().as_ref().height()\n+            < right.root.as_ref().unwrap().as_ref().height()\n+        {\n             self.recalc_length();\n             right.length = total_num - self.len();\n         } else {\n@@ -1261,27 +1283,27 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             res\n         }\n \n-        self.length = dfs(self.root.as_ref());\n+        self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n \n     /// Removes empty levels on the top.\n     fn fix_top(&mut self) {\n         loop {\n             {\n-                let node = self.root.as_ref();\n+                let node = self.root.as_ref().unwrap().as_ref();\n                 if node.height() == 0 || node.len() > 0 {\n                     break;\n                 }\n             }\n-            self.root.pop_level();\n+            self.root.as_mut().unwrap().pop_level();\n         }\n     }\n \n     fn fix_right_border(&mut self) {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -1307,7 +1329,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();\n@@ -1326,13 +1348,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.fix_top();\n     }\n-\n-    /// If the root node is the shared root node, allocate our own node.\n-    fn ensure_root_is_owned(&mut self) {\n-        if self.root.is_shared_root() {\n-            self.root = node::Root::new_leaf();\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1458,12 +1473,21 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n-        let root1 = unsafe { ptr::read(&self.root).into_ref() };\n-        let root2 = unsafe { ptr::read(&self.root).into_ref() };\n+        if self.root.is_none() {\n+            mem::forget(self);\n+            return IntoIter { front: None, back: None, length: 0 };\n+        }\n+\n+        let root1 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n+        let root2 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n+        IntoIter {\n+            front: Some(root1.first_leaf_edge()),\n+            back: Some(root2.last_leaf_edge()),\n+            length: len,\n+        }\n     }\n }\n \n@@ -1478,9 +1502,9 @@ impl<K, V> Drop for IntoIter<K, V> {\n                 // don't have to care about panics this time (they'll abort).\n                 while let Some(_) = self.0.next() {}\n \n-                // No need to avoid the shared root, because the tree was definitely not empty.\n                 unsafe {\n-                    let mut node = ptr::read(&self.0.front).into_node().forget_type();\n+                    let mut node =\n+                        unwrap_unchecked(ptr::read(&self.0.front)).into_node().forget_type();\n                     while let Some(parent) = node.deallocate_and_ascend() {\n                         node = parent.into_node().forget_type();\n                     }\n@@ -1495,14 +1519,13 @@ impl<K, V> Drop for IntoIter<K, V> {\n         }\n \n         unsafe {\n-            let mut node = ptr::read(&self.front).into_node().forget_type();\n-            if node.is_shared_root() {\n-                return;\n-            }\n-            // Most of the nodes have been deallocated while traversing\n-            // but one pile from a leaf up to the root is left standing.\n-            while let Some(parent) = node.deallocate_and_ascend() {\n-                node = parent.into_node().forget_type();\n+            if let Some(front) = ptr::read(&self.front) {\n+                let mut node = front.into_node().forget_type();\n+                // Most of the nodes have been deallocated while traversing\n+                // but one pile from a leaf up to the root is left standing.\n+                while let Some(parent) = node.deallocate_and_ascend() {\n+                    node = parent.into_node().forget_type();\n+                }\n             }\n         }\n     }\n@@ -1517,7 +1540,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.front.next_unchecked() })\n+            Some(unsafe { self.front.as_mut().unwrap().next_unchecked() })\n         }\n     }\n \n@@ -1533,7 +1556,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.back.next_back_unchecked() })\n+            Some(unsafe { self.back.as_mut().unwrap().next_back_unchecked() })\n         }\n     }\n }\n@@ -1683,7 +1706,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.front.next_unchecked()\n+        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n     }\n }\n \n@@ -1696,7 +1719,7 @@ impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.back.next_back_unchecked()\n+        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n     }\n }\n \n@@ -1734,7 +1757,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.front.next_unchecked()\n+        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n     }\n }\n \n@@ -1755,7 +1778,7 @@ impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.back.next_back_unchecked()\n+        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n     }\n }\n \n@@ -1969,8 +1992,8 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n-                front: self.root.as_ref().first_leaf_edge(),\n-                back: self.root.as_ref().last_leaf_edge(),\n+                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n+                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n             },\n             length: self.length,\n         }\n@@ -1999,13 +2022,17 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n-            range: RangeMut {\n-                front: root1.first_leaf_edge(),\n-                back: root2.last_leaf_edge(),\n-                _marker: PhantomData,\n+            range: if let Some(root) = &mut self.root {\n+                let root1 = root.as_mut();\n+                let root2 = unsafe { ptr::read(&root1) };\n+                RangeMut {\n+                    front: Some(root1.first_leaf_edge()),\n+                    back: Some(root2.last_leaf_edge()),\n+                    _marker: PhantomData,\n+                }\n+            } else {\n+                RangeMut { front: None, back: None, _marker: PhantomData }\n             },\n             length: self.length,\n         }\n@@ -2116,6 +2143,12 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// If the root node is the empty (non-allocated) root node, allocate our\n+    /// own node.\n+    fn ensure_root_is_owned(&mut self) -> &mut node::Root<K, V> {\n+        self.root.get_or_insert_with(|| node::Root::new_leaf())\n+    }\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {"}, {"sha": "6ebb98c42cd4f8ecef6fee0628ed665325a0003e", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 60, "deletions": 144, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "patch": "@@ -44,34 +44,7 @@ const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n \n-/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n-/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n-/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n-/// case.\n-///\n-/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n-/// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n-/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n-/// by `as_header`.)\n-#[repr(C)]\n-struct NodeHeader<K, V> {\n-    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n-    /// This either points to an actual node or is null.\n-    parent: *const InternalNode<K, V>,\n-\n-    /// This node's index into the parent node's `edges` array.\n-    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n-    /// This is only guaranteed to be initialized when `parent` is non-null.\n-    parent_idx: MaybeUninit<u16>,\n-\n-    /// The number of keys and values this node stores.\n-    ///\n-    /// This next to `parent_idx` to encourage the compiler to join `len` and\n-    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n-    len: u16,\n-}\n+/// The underlying representation of leaf nodes.\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -111,21 +84,6 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-impl<K, V> NodeHeader<K, V> {\n-    fn is_shared_root(&self) -> bool {\n-        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n-    }\n-}\n-\n-// We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for NodeHeader<(), ()> {}\n-\n-// An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use just a header in order to save space, since no operation on an empty tree will\n-// ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n-\n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n /// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n@@ -154,12 +112,9 @@ impl<K, V> InternalNode<K, V> {\n }\n \n /// A managed, non-null pointer to a node. This is either an owned pointer to\n-/// `LeafNode<K, V>`, an owned pointer to `InternalNode<K, V>`, or a (not owned)\n-/// pointer to `NodeHeader<(), ()` (more specifically, the pointer to EMPTY_ROOT_NODE).\n-/// All of these types have a `NodeHeader<K, V>` prefix, meaning that they have at\n-/// least the same size as `NodeHeader<K, V>` and store the same kinds of data at the same\n-/// offsets; and they have a pointer alignment at least as large as `NodeHeader<K, V>`'s.\n-/// However, `BoxedNode` contains no information as to which of the three types\n+/// `LeafNode<K, V>` or an owned pointer to `InternalNode<K, V>`.\n+///\n+/// However, `BoxedNode` contains no information as to which of the two types\n /// of nodes it actually contains, and, partially due to this lack of information,\n /// has no destructor.\n struct BoxedNode<K, V> {\n@@ -184,8 +139,9 @@ impl<K, V> BoxedNode<K, V> {\n     }\n }\n \n-/// Either an owned tree or a shared, empty tree.  Note that this does not have a destructor,\n-/// and must be cleaned up manually if it is an owned tree.\n+/// An owned tree.\n+///\n+/// Note that this does not have a destructor, and must be cleaned up manually.\n pub struct Root<K, V> {\n     node: BoxedNode<K, V>,\n     /// The number of levels below the root node.\n@@ -196,20 +152,6 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n-    /// Whether the instance of `Root` wraps a shared, empty root node. If not,\n-    /// the entire tree is uniquely owned by the owner of the `Root` instance.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_ref().is_shared_root()\n-    }\n-\n-    /// Returns a shared tree, wrapping a shared root node that is eternally empty.\n-    pub fn shared_empty_root() -> Self {\n-        Root {\n-            node: unsafe { BoxedNode::from_ptr(NonNull::from(&EMPTY_ROOT_NODE).cast()) },\n-            height: 0,\n-        }\n-    }\n-\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n@@ -245,7 +187,6 @@ impl<K, V> Root<K, V> {\n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -308,11 +249,6 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!\n-///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n-///   Shared references must be dereferenceable *for the entire size of their pointee*,\n-///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n-///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node.\n     height: usize,\n@@ -354,7 +290,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Note that, despite being safe, calling this function can have the side effect\n     /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n-        self.as_header().len as usize\n+        self.as_leaf().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -374,35 +310,24 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// Unsafe because the node must not be the shared root. For more information,\n-    /// see the `NodeRef` comments.\n-    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n-        debug_assert!(!self.is_shared_root());\n-        self.node.as_ref()\n-    }\n-\n-    fn as_header(&self) -> &NodeHeader<K, V> {\n-        unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n-    }\n-\n-    /// Returns whether the node is the shared, empty root.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_header().is_shared_root()\n+    fn as_leaf(&self) -> &LeafNode<K, V> {\n+        // The node must be valid for at least the LeafNode portion.\n+        // This is not a reference in the NodeRef type because we don't know if\n+        // it should be unique or shared.\n+        unsafe { self.node.as_ref() }\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    pub unsafe fn keys(&self) -> &[K] {\n+    pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals(&self) -> &[V] {\n+    fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -416,7 +341,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn ascend(\n         self,\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n-        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -425,7 +350,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData,\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n+                idx: unsafe { usize::from(*self.as_leaf().parent_idx.as_ptr()) },\n                 _marker: PhantomData,\n             })\n         } else {\n@@ -464,7 +389,6 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        assert!(!self.is_shared_root());\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n@@ -507,41 +431,37 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// (header, keys and values), and this function exposes that.\n     ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n-    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n-    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n         self.node.as_ptr()\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn keys_mut(&mut self) -> &mut [K] {\n-        self.reborrow_mut().into_key_slice_mut()\n+    fn keys_mut(&mut self) -> &mut [K] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals_mut(&mut self) -> &mut [V] {\n-        self.reborrow_mut().into_val_slice_mut()\n+    fn vals_mut(&mut self) -> &mut [V] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice(self) -> &'a [K] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n+    fn into_key_slice(self) -> &'a [K] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice(self) -> &'a [V] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n+    fn into_val_slice(self) -> &'a [V] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = ptr::read(&self);\n+    fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n+        let k = unsafe { ptr::read(&self) };\n         (k.into_key_slice(), self.into_val_slice())\n     }\n }\n@@ -553,37 +473,41 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf_mut` is okay.\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-            self.len(),\n-        )\n+    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        debug_assert!(!self.is_shared_root());\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-            self.len(),\n-        )\n+    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        debug_assert!(!self.is_shared_root());\n+    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n         let len = self.len();\n         let leaf = self.as_leaf_mut();\n-        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        // SAFETY: The keys and values of a node must always be initialized up to length.\n+        let keys = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len)\n+        };\n+        let vals = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+        };\n         (keys, vals)\n     }\n }\n@@ -592,7 +516,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -607,7 +530,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -624,7 +546,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -658,7 +579,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -744,8 +664,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n@@ -904,7 +823,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n-        debug_assert!(!self.node.is_shared_root());\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n@@ -1081,7 +999,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1113,7 +1030,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);"}, {"sha": "4e80f7f21ebff5c6817a82f9e9436acf3ea5d9d2", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "patch": "@@ -67,19 +67,16 @@ where\n     Q: Ord,\n     K: Borrow<Q>,\n {\n-    // This function is defined over all borrow types (immutable, mutable, owned),\n-    // and may be called on the shared root in each case.\n+    // This function is defined over all borrow types (immutable, mutable, owned).\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n     let len = node.len();\n-    if len > 0 {\n-        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n-        for (i, k) in keys.iter().enumerate() {\n-            match key.cmp(k.borrow()) {\n-                Ordering::Greater => {}\n-                Ordering::Equal => return (i, true),\n-                Ordering::Less => return (i, false),\n-            }\n+    let keys = node.keys();\n+    for (i, k) in keys.iter().enumerate() {\n+        match key.cmp(k.borrow()) {\n+            Ordering::Greater => {}\n+            Ordering::Equal => return (i, true),\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (len, false)"}, {"sha": "3a3462d546f7a9b363178d2b0c07c98cdccc95bf", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "patch": "@@ -67,7 +67,7 @@ fn test_basic_large() {\n #[test]\n fn test_basic_small() {\n     let mut map = BTreeMap::new();\n-    // Empty, shared root:\n+    // Empty, root is absent (None):\n     assert_eq!(map.remove(&1), None);\n     assert_eq!(map.len(), 0);\n     assert_eq!(map.get(&1), None);\n@@ -123,7 +123,7 @@ fn test_basic_small() {\n     assert_eq!(map.values().collect::<Vec<_>>(), vec![&4]);\n     assert_eq!(map.remove(&2), Some(4));\n \n-    // Empty but private root:\n+    // Empty but root is owned (Some(...)):\n     assert_eq!(map.len(), 0);\n     assert_eq!(map.get(&1), None);\n     assert_eq!(map.get_mut(&1), None);\n@@ -263,13 +263,6 @@ fn test_iter_mut_mutation() {\n     do_test_iter_mut_mutation::<Align32>(144);\n }\n \n-#[test]\n-fn test_into_key_slice_with_shared_root_past_bounds() {\n-    let mut map: BTreeMap<Align32, ()> = BTreeMap::new();\n-    assert_eq!(map.get(&Align32(1)), None);\n-    assert_eq!(map.get_mut(&Align32(1)), None);\n-}\n-\n #[test]\n fn test_values_mut() {\n     let mut a = BTreeMap::new();"}, {"sha": "3d2d88a676d0d911d196da7695d57fcef72097d8", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9e3813b2b908c419a475eb6fdd0476c8b5f86a/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=9d9e3813b2b908c419a475eb6fdd0476c8b5f86a", "patch": "@@ -17,35 +17,43 @@\n // gdb-command: print btree_set\n // gdb-check:$1 = BTreeSet<i32>(len: 15) = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}\n \n+// gdb-command: print empty_btree_set\n+// gdb-check:$2 = BTreeSet<i32>(len: 0)\n+\n // gdb-command: print btree_map\n-// gdb-check:$2 = BTreeMap<i32, i32>(len: 15) = {[0] = 0, [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9, [10] = 10, [11] = 11, [12] = 12, [13] = 13, [14] = 14}\n+// gdb-check:$3 = BTreeMap<i32, i32>(len: 15) = {[0] = 0, [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9, [10] = 10, [11] = 11, [12] = 12, [13] = 13, [14] = 14}\n+\n+// gdb-command: print empty_btree_map\n+// gdb-check:$4 = BTreeMap<i32, u32>(len: 0)\n \n // gdb-command: print vec_deque\n-// gdb-check:$3 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n+// gdb-check:$5 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n \n // gdb-command: print vec_deque2\n-// gdb-check:$4 = VecDeque<i32>(len: 7, cap: 8) = {2, 3, 4, 5, 6, 7, 8}\n+// gdb-check:$6 = VecDeque<i32>(len: 7, cap: 8) = {2, 3, 4, 5, 6, 7, 8}\n \n #![allow(unused_variables)]\n-use std::collections::BTreeSet;\n use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n use std::collections::VecDeque;\n \n-\n fn main() {\n-\n     // BTreeSet\n     let mut btree_set = BTreeSet::new();\n     for i in 0..15 {\n         btree_set.insert(i);\n     }\n \n+    let mut empty_btree_set: BTreeSet<i32> = BTreeSet::new();\n+\n     // BTreeMap\n     let mut btree_map = BTreeMap::new();\n     for i in 0..15 {\n         btree_map.insert(i, i);\n     }\n \n+    let mut empty_btree_map: BTreeMap<i32, u32> = BTreeMap::new();\n+\n     // VecDeque\n     let mut vec_deque = VecDeque::new();\n     vec_deque.push_back(5);\n@@ -63,4 +71,6 @@ fn main() {\n     zzz(); // #break\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}]}