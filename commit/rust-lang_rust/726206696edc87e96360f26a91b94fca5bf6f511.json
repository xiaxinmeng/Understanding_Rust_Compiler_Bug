{"sha": "726206696edc87e96360f26a91b94fca5bf6f511", "node_id": "C_kwDOAAsO6NoAKDcyNjIwNjY5NmVkYzg3ZTk2MzYwZjI2YTkxYjk0ZmNhNWJmNmY1MTE", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-03-18T13:48:21Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-03-21T15:02:18Z"}, "message": "use `format-args-capture` and remove unnecessary nested if blocks in some parts of rustc_passes\n\nbreak before the `&&`\n\nUpdate compiler/rustc_passes/src/check_const.rs\n\nCo-authored-by: bjorn3 <bjorn3@users.noreply.github.com>", "tree": {"sha": "003e901bcf092ca481b22295791bb5633f8d21b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/003e901bcf092ca481b22295791bb5633f8d21b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/726206696edc87e96360f26a91b94fca5bf6f511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/726206696edc87e96360f26a91b94fca5bf6f511", "html_url": "https://github.com/rust-lang/rust/commit/726206696edc87e96360f26a91b94fca5bf6f511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/726206696edc87e96360f26a91b94fca5bf6f511/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6f3a4ecb48ead838638e902f2fa4e5f3059779b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f3a4ecb48ead838638e902f2fa4e5f3059779b", "html_url": "https://github.com/rust-lang/rust/commit/d6f3a4ecb48ead838638e902f2fa4e5f3059779b"}], "stats": {"total": 139, "additions": 61, "deletions": 78}, "files": [{"sha": "4f9e1d3fa3bcaf1a4e8375bdef0478130f267dc6", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=726206696edc87e96360f26a91b94fca5bf6f511", "patch": "@@ -196,8 +196,7 @@ impl CheckAttrVisitor<'_> {\n     fn inline_attr_str_error_with_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n         self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n             lint.build(&format!(\n-                \"`#[{}]` is ignored on struct fields, match arms and macro defs\",\n-                sym,\n+                \"`#[{sym}]` is ignored on struct fields, match arms and macro defs\",\n             ))\n             .warn(\n                 \"this was previously accepted by the compiler but is \\\n@@ -214,7 +213,7 @@ impl CheckAttrVisitor<'_> {\n \n     fn inline_attr_str_error_without_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n         self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(&format!(\"`#[{}]` is ignored on struct fields and match arms\", sym))\n+            lint.build(&format!(\"`#[{sym}]` is ignored on struct fields and match arms\"))\n                 .warn(\n                     \"this was previously accepted by the compiler but is \\\n                  being phased out; it will become a hard error in \\\n@@ -721,7 +720,7 @@ impl CheckAttrVisitor<'_> {\n                 .sess\n                 .struct_span_err(\n                     meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                    &format!(\"`{}` is not a valid identifier\", doc_keyword),\n+                    &format!(\"`{doc_keyword}` is not a valid identifier\"),\n                 )\n                 .emit();\n             return false;\n@@ -805,8 +804,7 @@ impl CheckAttrVisitor<'_> {\n                 .struct_span_err(\n                     meta.span(),\n                     &format!(\n-                        \"`#![doc({} = \\\"...\\\")]` isn't allowed as a crate-level attribute\",\n-                        attr_name,\n+                        \"`#![doc({attr_name} = \\\"...\\\")]` isn't allowed as a crate-level attribute\",\n                     ),\n                 )\n                 .emit();\n@@ -1035,8 +1033,7 @@ impl CheckAttrVisitor<'_> {\n                                                 attr.meta().unwrap().span,\n                                                 \"use `doc = include_str!` instead\",\n                                                 format!(\n-                                                    \"#{}[doc = include_str!(\\\"{}\\\")]\",\n-                                                    inner, value\n+                                                    \"#{inner}[doc = include_str!(\\\"{value}\\\")]\",\n                                                 ),\n                                                 applicability,\n                                             );\n@@ -1230,7 +1227,7 @@ impl CheckAttrVisitor<'_> {\n                         if let Some(value) = attr.value_str() {\n                             diag.span_help(\n                                 attr.span,\n-                                &format!(r#\"try `#[link(name = \"{}\")]` instead\"#, value),\n+                                &format!(r#\"try `#[link(name = \"{value}\")]` instead\"#),\n                             );\n                         } else {\n                             diag.span_help(attr.span, r#\"try `#[link(name = \"...\")]` instead\"#);\n@@ -1518,15 +1515,14 @@ impl CheckAttrVisitor<'_> {\n                 };\n                 self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n                     lint.build(&format!(\n-                        \"`#[no_mangle]` has no effect on a foreign {}\",\n-                        foreign_item_kind\n+                        \"`#[no_mangle]` has no effect on a foreign {foreign_item_kind}\"\n                     ))\n                     .warn(\n                         \"this was previously accepted by the compiler but is \\\n                             being phased out; it will become a hard error in \\\n                             a future release!\",\n                     )\n-                    .span_label(span, format!(\"foreign {}\", foreign_item_kind))\n+                    .span_label(span, format!(\"foreign {foreign_item_kind}\"))\n                     .note(\"symbol names in extern blocks are not mangled\")\n                     .span_suggestion(\n                         attr.span,\n@@ -1692,9 +1688,9 @@ impl CheckAttrVisitor<'_> {\n                 hint.span(),\n                 E0517,\n                 \"{}\",\n-                &format!(\"attribute should be applied to {} {}\", article, allowed_targets)\n+                &format!(\"attribute should be applied to {article} {allowed_targets}\")\n             )\n-            .span_label(span, &format!(\"not {} {}\", article, allowed_targets))\n+            .span_label(span, &format!(\"not {article} {allowed_targets}\"))\n             .emit();\n         }\n "}, {"sha": "0e04a2cfb11adf68ba2217ab1a52cf3317362df5", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=726206696edc87e96360f26a91b94fca5bf6f511", "patch": "@@ -80,8 +80,7 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n     /// of the trait being implemented; as those provided functions can be non-const.\n     fn visit_item<'hir>(&mut self, item: &'hir hir::Item<'hir>) {\n         let _: Option<_> = try {\n-            if let hir::ItemKind::Impl(ref imp) = item.kind {\n-                if let hir::Constness::Const = imp.constness {\n+            if let hir::ItemKind::Impl(ref imp) = item.kind && let hir::Constness::Const = imp.constness {\n                     let trait_def_id = imp.of_trait.as_ref()?.trait_def_id()?;\n                     let ancestors = self\n                         .tcx\n@@ -132,7 +131,6 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n                             .note(&format!(\"`{}` not implemented\", to_implement.join(\"`, `\")))\n                             .emit();\n                     }\n-                }\n             }\n         };\n     }"}, {"sha": "9cbb7917e9a32de6a84ddda1d55c548480f27d57", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=726206696edc87e96360f26a91b94fca5bf6f511", "patch": "@@ -61,10 +61,9 @@ fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item\n     if let Some(original_def_id) = items.name_to_id.insert(name, item_def_id) {\n         if original_def_id != item_def_id {\n             let mut err = match tcx.hir().span_if_local(item_def_id) {\n-                Some(span) => tcx.sess.struct_span_err(\n-                    span,\n-                    &format!(\"duplicate diagnostic item found: `{}`.\", name),\n-                ),\n+                Some(span) => tcx\n+                    .sess\n+                    .struct_span_err(span, &format!(\"duplicate diagnostic item found: `{name}`.\")),\n                 None => tcx.sess.struct_err(&format!(\n                     \"duplicate diagnostic item in crate `{}`: `{}`.\",\n                     tcx.crate_name(item_def_id.krate),"}, {"sha": "5a1373ad1a218dc94c0987cc3a6b2023ca0e4811", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=726206696edc87e96360f26a91b94fca5bf6f511", "patch": "@@ -148,33 +148,29 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n     } else if let Some((def_id, _)) = visitor.attr_main_fn {\n         Some((def_id.to_def_id(), EntryFnType::Main))\n     } else {\n-        if let Some(main_def) = tcx.resolutions(()).main_def {\n-            if let Some(def_id) = main_def.opt_fn_def_id() {\n-                // non-local main imports are handled below\n-                if let Some(def_id) = def_id.as_local() {\n-                    if matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n-                        tcx.sess\n-                            .struct_span_err(\n-                                tcx.def_span(def_id),\n-                                \"the `main` function cannot be declared in an `extern` block\",\n-                            )\n-                            .emit();\n-                        return None;\n-                    }\n-                }\n-\n-                if main_def.is_import && !tcx.features().imported_main {\n-                    let span = main_def.span;\n-                    feature_err(\n-                        &tcx.sess.parse_sess,\n-                        sym::imported_main,\n-                        span,\n-                        \"using an imported function as entry point `main` is experimental\",\n+        if let Some(main_def) = tcx.resolutions(()).main_def && let Some(def_id) = main_def.opt_fn_def_id() {\n+            // non-local main imports are handled below\n+            if let Some(def_id) = def_id.as_local() && matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n+                tcx.sess\n+                    .struct_span_err(\n+                        tcx.def_span(def_id),\n+                        \"the `main` function cannot be declared in an `extern` block\",\n                     )\n                     .emit();\n-                }\n-                return Some((def_id, EntryFnType::Main));\n+                return None;\n             }\n+\n+            if main_def.is_import && !tcx.features().imported_main {\n+                let span = main_def.span;\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    sym::imported_main,\n+                    span,\n+                    \"using an imported function as entry point `main` is experimental\",\n+                )\n+                .emit();\n+            }\n+            return Some((def_id, EntryFnType::Main));\n         }\n         no_main_err(tcx, visitor);\n         None\n@@ -225,11 +221,9 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n         err.note(&note);\n     }\n \n-    if let Some(main_def) = tcx.resolutions(()).main_def {\n-        if main_def.opt_fn_def_id().is_none() {\n-            // There is something at `crate::main`, but it is not a function definition.\n-            err.span_label(main_def.span, \"non-function item at `crate::main` is found\");\n-        }\n+    if let Some(main_def) = tcx.resolutions(()).main_def && main_def.opt_fn_def_id().is_none(){\n+        // There is something at `crate::main`, but it is not a function definition.\n+        err.span_label(main_def.span, \"non-function item at `crate::main` is found\");\n     }\n \n     if tcx.sess.teach(&err.get_code().unwrap()) {"}, {"sha": "027eac16bad305d5629bf6a1ce6ce6ee2c96603d", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726206696edc87e96360f26a91b94fca5bf6f511/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=726206696edc87e96360f26a91b94fca5bf6f511", "patch": "@@ -79,27 +79,25 @@ impl<'tcx> ExprVisitor<'tcx> {\n             // Special-case transmuting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(self.tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) {\n-                if size_to == Pointer.size(&self.tcx) {\n-                    struct_span_err!(self.tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n-                        .note(&format!(\"source type: {}\", from))\n-                        .note(&format!(\"target type: {}\", to))\n-                        .help(\"cast with `as` to a pointer instead\")\n-                        .emit();\n-                    return;\n-                }\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&self.tcx) {\n+                struct_span_err!(self.tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n+                    .note(&format!(\"source type: {from}\"))\n+                    .note(&format!(\"target type: {to}\"))\n+                    .help(\"cast with `as` to a pointer instead\")\n+                    .emit();\n+                return;\n             }\n         }\n \n         // Try to display a sensible error with as much information as possible.\n         let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n             Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n-            Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{}`\", tail),\n+            Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n             Err(LayoutError::Unknown(bad)) => {\n                 if bad == ty {\n                     \"this type does not have a fixed size\".to_owned()\n                 } else {\n-                    format!(\"size can vary because of {}\", bad)\n+                    format!(\"size can vary because of {bad}\")\n                 }\n             }\n             Err(err) => err.to_string(),\n@@ -113,7 +111,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                                         or dependently-sized types\"\n         );\n         if from == to {\n-            err.note(&format!(\"`{}` does not have a fixed size\", from));\n+            err.note(&format!(\"`{from}` does not have a fixed size\"));\n         } else {\n             err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n                 .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n@@ -201,7 +199,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n             _ => None,\n         };\n         let Some(asm_ty) = asm_ty else {\n-            let msg = &format!(\"cannot use value of type `{}` for inline assembly\", ty);\n+            let msg = &format!(\"cannot use value of type `{ty}` for inline assembly\");\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(\n                 \"only integers, floats, SIMD vectors, pointers and function pointers \\\n@@ -216,7 +214,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         if !ty.is_copy_modulo_regions(self.tcx.at(DUMMY_SP), self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n-            err.note(&format!(\"`{}` does not implement the Copy trait\", ty));\n+            err.note(&format!(\"`{ty}` does not implement the Copy trait\"));\n             err.emit();\n         }\n \n@@ -237,7 +235,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                     in_expr.span,\n                     &format!(\"type `{}`\", self.typeck_results.expr_ty_adjusted(in_expr)),\n                 );\n-                err.span_label(expr.span, &format!(\"type `{}`\", ty));\n+                err.span_label(expr.span, &format!(\"type `{ty}`\"));\n                 err.note(\n                     \"asm inout arguments must have the same type, \\\n                     unless they are both pointers or integers of the same size\",\n@@ -256,7 +254,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         let reg_class = reg.reg_class();\n         let supported_tys = reg_class.supported_types(asm_arch);\n         let Some((_, feature)) = supported_tys.iter().find(|&&(t, _)| t == asm_ty) else {\n-            let msg = &format!(\"type `{}` cannot be used with this register class\", ty);\n+            let msg = &format!(\"type `{ty}` cannot be used with this register class\");\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             let supported_tys: Vec<_> =\n                 supported_tys.iter().map(|(t, _)| t.to_string()).collect();\n@@ -326,12 +324,10 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         let mut err = lint.build(msg);\n                         err.span_label(expr.span, \"for this argument\");\n                         err.help(&format!(\n-                            \"use the `{}` modifier to have the register formatted as `{}`\",\n-                            suggested_modifier, suggested_result,\n+                            \"use the `{suggested_modifier}` modifier to have the register formatted as `{suggested_result}`\",\n                         ));\n                         err.help(&format!(\n-                            \"or use the `{}` modifier to keep the default formatting of `{}`\",\n-                            default_modifier, default_result,\n+                            \"or use the `{default_modifier}` modifier to keep the default formatting of `{default_result}`\",\n                         ));\n                         err.emit();\n                     },\n@@ -509,14 +505,14 @@ impl<'tcx> Visitor<'tcx> for ExprVisitor<'tcx> {\n         match expr.kind {\n             hir::ExprKind::Path(ref qpath) => {\n                 let res = self.typeck_results.qpath_res(qpath, expr.hir_id);\n-                if let Res::Def(DefKind::Fn, did) = res {\n-                    if self.def_id_is_transmute(did) {\n-                        let typ = self.typeck_results.node_type(expr.hir_id);\n-                        let sig = typ.fn_sig(self.tcx);\n-                        let from = sig.inputs().skip_binder()[0];\n-                        let to = sig.output().skip_binder();\n-                        self.check_transmute(expr.span, from, to);\n-                    }\n+                if let Res::Def(DefKind::Fn, did) = res\n+                    && self.def_id_is_transmute(did)\n+                {\n+                    let typ = self.typeck_results.node_type(expr.hir_id);\n+                    let sig = typ.fn_sig(self.tcx);\n+                    let from = sig.inputs().skip_binder()[0];\n+                    let to = sig.output().skip_binder();\n+                    self.check_transmute(expr.span, from, to);\n                 }\n             }\n "}]}