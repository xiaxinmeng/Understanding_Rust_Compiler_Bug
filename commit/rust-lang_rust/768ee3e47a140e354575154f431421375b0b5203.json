{"sha": "768ee3e47a140e354575154f431421375b0b5203", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2OGVlM2U0N2ExNDBlMzU0NTc1MTU0ZjQzMTQyMTM3NWIwYjUyMDM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-06T19:09:52Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-06T19:10:22Z"}, "message": "Align `InferenceVar` to Chalk", "tree": {"sha": "8db339ad4a14cde9a63235d7616f648d4e560e56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db339ad4a14cde9a63235d7616f648d4e560e56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/768ee3e47a140e354575154f431421375b0b5203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/768ee3e47a140e354575154f431421375b0b5203", "html_url": "https://github.com/rust-lang/rust/commit/768ee3e47a140e354575154f431421375b0b5203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/768ee3e47a140e354575154f431421375b0b5203/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d280538174eb51382dc49b934fd5e096f3b36554", "url": "https://api.github.com/repos/rust-lang/rust/commits/d280538174eb51382dc49b934fd5e096f3b36554", "html_url": "https://github.com/rust-lang/rust/commit/d280538174eb51382dc49b934fd5e096f3b36554"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "75d633c960c996cc73215478825168183c3954ab", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=768ee3e47a140e354575154f431421375b0b5203", "patch": "@@ -683,25 +683,6 @@ impl<'a> InferenceContext<'a> {\n     }\n }\n \n-/// The kinds of placeholders we need during type inference. There's separate\n-/// values for general types, and for integer and float variables. The latter\n-/// two are used for inference of literal values (e.g. `100` could be one of\n-/// several integer types).\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct InferenceVar {\n-    index: u32,\n-}\n-\n-impl InferenceVar {\n-    fn to_inner(self) -> unify::TypeVarId {\n-        unify::TypeVarId(self.index)\n-    }\n-\n-    fn from_inner(unify::TypeVarId(index): unify::TypeVarId) -> Self {\n-        InferenceVar { index }\n-    }\n-}\n-\n /// When inferring an expression, we propagate downward whatever type hint we\n /// are able in the form of an `Expectation`.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "d717e33759f7afbf518fece059a40e3d194dfbe1", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=768ee3e47a140e354575154f431421375b0b5203", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n         t.fold_binders(\n             &mut |ty, binders| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(var, kind) => {\n-                    let inner = var.to_inner();\n+                    let inner = from_inference_var(var);\n                     if self.var_stack.contains(&inner) {\n                         // recursive type\n                         return self.ctx.table.type_variable_table.fallback_value(var, kind);\n@@ -65,7 +65,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n                         result\n                     } else {\n                         let root = self.ctx.table.var_unification_table.find(inner);\n-                        let position = self.add(InferenceVar::from_inner(root), kind);\n+                        let position = self.add(to_inference_var(root), kind);\n                         TyKind::BoundVar(BoundVar::new(binders, position)).intern(&Interner)\n                     }\n                 }\n@@ -207,16 +207,16 @@ impl TypeVariableTable {\n     }\n \n     pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.inner[iv.to_inner().0 as usize].diverging = diverging;\n+        self.inner[from_inference_var(iv).0 as usize].diverging = diverging;\n     }\n \n     fn is_diverging(&mut self, iv: InferenceVar) -> bool {\n-        self.inner[iv.to_inner().0 as usize].diverging\n+        self.inner[from_inference_var(iv).0 as usize].diverging\n     }\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n-            _ if self.inner[iv.to_inner().0 as usize].diverging => TyKind::Never,\n+            _ if self.inner[from_inference_var(iv).0 as usize].diverging => TyKind::Never,\n             TyVariableKind::General => TyKind::Error,\n             TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n             TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n@@ -250,7 +250,7 @@ impl InferenceTable {\n         self.type_variable_table.push(TypeVariableData { diverging });\n         let key = self.var_unification_table.new_key(TypeVarValue::Unknown);\n         assert_eq!(key.0 as usize, self.type_variable_table.inner.len() - 1);\n-        TyKind::InferenceVar(InferenceVar::from_inner(key), kind).intern(&Interner)\n+        TyKind::InferenceVar(to_inference_var(key), kind).intern(&Interner)\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n@@ -369,8 +369,12 @@ impl InferenceTable {\n                 == self.type_variable_table.is_diverging(*tv2) =>\n             {\n                 // both type vars are unknown since we tried to resolve them\n-                if !self.var_unification_table.unioned(tv1.to_inner(), tv2.to_inner()) {\n-                    self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n+                if !self\n+                    .var_unification_table\n+                    .unioned(from_inference_var(*tv1), from_inference_var(*tv2))\n+                {\n+                    self.var_unification_table\n+                        .union(from_inference_var(*tv1), from_inference_var(*tv2));\n                     self.revision += 1;\n                 }\n                 true\n@@ -407,7 +411,7 @@ impl InferenceTable {\n             ) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(\n-                    tv.to_inner(),\n+                    from_inference_var(*tv),\n                     TypeVarValue::Known(other.clone().intern(&Interner)),\n                 );\n                 self.revision += 1;\n@@ -462,7 +466,7 @@ impl InferenceTable {\n             }\n             match ty.kind(&Interner) {\n                 TyKind::InferenceVar(tv, _) => {\n-                    let inner = tv.to_inner();\n+                    let inner = from_inference_var(*tv);\n                     match self.var_unification_table.inlined_probe_value(inner).known() {\n                         Some(known_ty) => {\n                             // The known_ty can't be a type var itself\n@@ -485,7 +489,7 @@ impl InferenceTable {\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty.kind(&Interner) {\n             &TyKind::InferenceVar(tv, kind) => {\n-                let inner = tv.to_inner();\n+                let inner = from_inference_var(tv);\n                 if tv_stack.contains(&inner) {\n                     cov_mark::hit!(type_var_cycles_resolve_as_possible);\n                     // recursive type\n@@ -512,7 +516,7 @@ impl InferenceTable {\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty.kind(&Interner) {\n             &TyKind::InferenceVar(tv, kind) => {\n-                let inner = tv.to_inner();\n+                let inner = from_inference_var(tv);\n                 if tv_stack.contains(&inner) {\n                     cov_mark::hit!(type_var_cycles_resolve_completely);\n                     // recursive type\n@@ -555,6 +559,14 @@ impl UnifyKey for TypeVarId {\n     }\n }\n \n+fn from_inference_var(var: InferenceVar) -> TypeVarId {\n+    TypeVarId(var.index())\n+}\n+\n+fn to_inference_var(TypeVarId(index): TypeVarId) -> InferenceVar {\n+    index.into()\n+}\n+\n /// The value of a type variable: either we already know the type, or we don't\n /// know it yet.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "5c83a508d45c1c5d4ac17d0943cbf92dede11c9b", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=768ee3e47a140e354575154f431421375b0b5203", "patch": "@@ -42,7 +42,7 @@ use crate::{db::HirDatabase, display::HirDisplay, utils::generics};\n pub use autoderef::autoderef;\n pub use builder::TyBuilder;\n pub use chalk_ext::{ProjectionTyExt, TyExt};\n-pub use infer::{could_unify, InferenceResult, InferenceVar};\n+pub use infer::{could_unify, InferenceResult};\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, CallableDefId, ImplTraitLoweringMode,\n     TyDefId, TyLoweringContext, ValueTyDefId,"}, {"sha": "eac1b790009619919799fe88873750f49c002316", "filename": "crates/hir_ty/src/types.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/768ee3e47a140e354575154f431421375b0b5203/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=768ee3e47a140e354575154f431421375b0b5203", "patch": "@@ -11,8 +11,7 @@ use smallvec::SmallVec;\n \n use crate::{\n     AssocTypeId, CanonicalVarKinds, ChalkTraitId, ClosureId, Const, FnDefId, FnSig, ForeignDefId,\n-    InferenceVar, Interner, Lifetime, OpaqueTyId, PlaceholderIndex, TypeWalk, VariableKind,\n-    VariableKinds,\n+    Interner, Lifetime, OpaqueTyId, PlaceholderIndex, TypeWalk, VariableKind, VariableKinds,\n };\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -524,3 +523,25 @@ pub enum Guidance {\n     /// There's no useful information to feed back to type inference\n     Unknown,\n }\n+\n+/// The kinds of placeholders we need during type inference. There's separate\n+/// values for general types, and for integer and float variables. The latter\n+/// two are used for inference of literal values (e.g. `100` could be one of\n+/// several integer types).\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct InferenceVar {\n+    index: u32,\n+}\n+\n+impl From<u32> for InferenceVar {\n+    fn from(index: u32) -> InferenceVar {\n+        InferenceVar { index }\n+    }\n+}\n+\n+impl InferenceVar {\n+    /// Gets the underlying index value.\n+    pub fn index(self) -> u32 {\n+        self.index\n+    }\n+}"}]}