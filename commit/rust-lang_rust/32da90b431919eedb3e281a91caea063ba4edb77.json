{"sha": "32da90b431919eedb3e281a91caea063ba4edb77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZGE5MGI0MzE5MTllZWRiM2UyODFhOTFjYWVhMDYzYmE0ZWRiNzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-22T23:59:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-22T23:59:48Z"}, "message": "Auto merge of #79319 - m-ou-se:rollup-d9n5viq, r=m-ou-se\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #76941 (Add f{32,64}::is_subnormal)\n - #77697 (Split each iterator adapter and source into individual modules)\n - #78305 (Stabilize alloc::Layout const functions)\n - #78608 (Stabilize refcell_take)\n - #78793 (Clean up `StructuralEq` docs)\n - #79267 (BTreeMap: address namespace conflicts)\n - #79293 (Add test for eval order for a+=b)\n - #79295 (BTreeMap: fix minor testing mistakes in #78903)\n - #79297 (BTreeMap: swap the names of NodeRef::new and Root::new_leaf)\n - #79299 (Stabilise `then`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8b730b4ad40ba1357221d5944e49071e1ccf0182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b730b4ad40ba1357221d5944e49071e1ccf0182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32da90b431919eedb3e281a91caea063ba4edb77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32da90b431919eedb3e281a91caea063ba4edb77", "html_url": "https://github.com/rust-lang/rust/commit/32da90b431919eedb3e281a91caea063ba4edb77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32da90b431919eedb3e281a91caea063ba4edb77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0d664bae6ca79c54cc054aa2403198e105190a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d664bae6ca79c54cc054aa2403198e105190a2", "html_url": "https://github.com/rust-lang/rust/commit/a0d664bae6ca79c54cc054aa2403198e105190a2"}, {"sha": "41c033b2f7b2eb770bb9b4169e0bbaf051c6c7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/41c033b2f7b2eb770bb9b4169e0bbaf051c6c7b1", "html_url": "https://github.com/rust-lang/rust/commit/41c033b2f7b2eb770bb9b4169e0bbaf051c6c7b1"}], "stats": {"total": 7327, "additions": 3777, "deletions": 3550}, "files": [{"sha": "eaef4c7b54a625d05f72ce44e88acd074481f30d", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,5 +1,4 @@\n #![feature(allow_internal_unstable)]\n-#![feature(bool_to_option)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(extend_one)]"}, {"sha": "2560cfa74624a2bede8ae22a5fea14008e9a05fc", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,5 +1,4 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(bool_to_option)]\n #![feature(core_intrinsics)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]"}, {"sha": "8a6b0230023ffa967f742fa6194a92205cba51e5", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,6 +1,5 @@\n //! The main parser interface.\n \n-#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n #![feature(iter_order_by)]"}, {"sha": "bd99c4ed2f14e7e24bc21fd61efa22d7b6e7a3d2", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -67,7 +67,7 @@ impl<K, V> Root<K, V> {\n \n                 // Push key-value pair and new right subtree.\n                 let tree_height = open_node.height() - 1;\n-                let mut right_tree = Root::new_leaf();\n+                let mut right_tree = Root::new();\n                 for _ in 0..tree_height {\n                     right_tree.push_internal_level();\n                 }"}, {"sha": "383f4487aff3d742b7a5eac282d295095878ecf8", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -9,7 +9,7 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n+use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n \n@@ -128,7 +128,7 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: Option<node::Root<K, V>>,\n+    root: Option<Root<K, V>>,\n     length: usize,\n }\n \n@@ -145,15 +145,15 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n         fn clone_subtree<'a, K: Clone, V: Clone>(\n-            node: node::NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n+            node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n         ) -> BTreeMap<K, V>\n         where\n             K: 'a,\n             V: 'a,\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n+                    let mut out_tree = BTreeMap { root: Some(Root::new()), length: 0 };\n \n                     {\n                         let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n@@ -198,7 +198,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot.unwrap_or_else(node::Root::new_leaf));\n+                            out_node.push(k, v, subroot.unwrap_or_else(Root::new));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -1558,7 +1558,7 @@ pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     /// Burried reference to the root field in the borrowed map.\n     /// Wrapped in `Option` to allow drop handler to `take` it.\n-    dormant_root: Option<DormantMutRef<'a, node::Root<K, V>>>,\n+    dormant_root: Option<DormantMutRef<'a, Root<K, V>>>,\n     /// Contains a leaf edge preceding the next element to be returned, or the last leaf edge.\n     /// Empty if the map has no root, if iteration went beyond the last leaf edge,\n     /// or if a panic occurred in the predicate.\n@@ -2160,8 +2160,8 @@ impl<K, V> BTreeMap<K, V> {\n \n     /// If the root node is the empty (non-allocated) root node, allocate our\n     /// own node. Is an associated function to avoid borrowing the entire BTreeMap.\n-    fn ensure_is_owned(root: &mut Option<node::Root<K, V>>) -> &mut node::Root<K, V> {\n-        root.get_or_insert_with(node::Root::new_leaf)\n+    fn ensure_is_owned(root: &mut Option<Root<K, V>>) -> &mut Root<K, V> {\n+        root.get_or_insert_with(Root::new)\n     }\n }\n "}, {"sha": "23cd4f3d83d624c09078e9819f00d1f73a90e6b4", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -6,13 +6,14 @@ use crate::fmt::Debug;\n use crate::rc::Rc;\n use crate::string::{String, ToString};\n use crate::vec::Vec;\n+use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::iter::{self, FromIterator};\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n mod ord_chaos;\n use ord_chaos::{Cyclic3, Governed, Governor};\n@@ -56,24 +57,23 @@ impl<K, V> BTreeMap<K, V> {\n             assert!(root_node.ascend().is_err());\n             root_node.assert_back_pointers();\n \n-            // Check consistenty of `length` and some of the navigation.\n+            // Check consistency of `length` with what navigation code encounters.\n             assert_eq!(self.length, root_node.calc_length());\n-            assert_eq!(self.length, self.keys().count());\n \n             // Lastly, check the invariant causing the least harm.\n             root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n-            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, 0);\n-            assert_eq!(self.length, self.keys().count());\n         }\n+\n+        // Check that `assert_strictly_ascending` will encounter all keys.\n+        assert_eq!(self.length, self.keys().count());\n     }\n \n     // Panics if the map is corrupted or if the keys are not in strictly\n     // ascending order, in the current opinion of the `Ord` implementation.\n-    // If the `Ord` implementation does not honor transitivity, this method\n-    // does not guarantee that all the keys are unique, just that adjacent\n-    // keys are unique.\n+    // If the `Ord` implementation violates transitivity, this method does not\n+    // guarantee that all keys are unique, just that adjacent keys are unique.\n     fn check(&self)\n     where\n         K: Debug + Ord,\n@@ -879,6 +879,7 @@ mod test_drain_filter {\n         map.check();\n     }\n \n+    // Explicitly consumes the iterator, where most test cases drop it instantly.\n     #[test]\n     fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n@@ -887,6 +888,7 @@ mod test_drain_filter {\n         map.check();\n     }\n \n+    // Explicitly consumes the iterator, where most test cases drop it instantly.\n     #[test]\n     fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n@@ -896,15 +898,7 @@ mod test_drain_filter {\n         map.check();\n     }\n \n-    #[test]\n-    fn dropped_removing_all() {\n-        let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n-        map.drain_filter(|_, _| true);\n-        assert!(map.is_empty());\n-        map.check();\n-    }\n-\n+    // Explicitly consumes the iterator and modifies values through it.\n     #[test]\n     fn mutating_and_keeping() {\n         let pairs = (0..3).map(|i| (i, i));\n@@ -921,6 +915,7 @@ mod test_drain_filter {\n         map.check();\n     }\n \n+    // Explicitly consumes the iterator and modifies values through it.\n     #[test]\n     fn mutating_and_removing() {\n         let pairs = (0..3).map(|i| (i, i));\n@@ -1094,7 +1089,7 @@ mod test_drain_filter {\n         struct D;\n         impl Drop for D {\n             fn drop(&mut self) {\n-                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                if DROPS.fetch_add(1, SeqCst) == 1 {\n                     panic!(\"panic in `drop`\");\n                 }\n             }\n@@ -1105,14 +1100,14 @@ mod test_drain_filter {\n \n         catch_unwind(move || {\n             drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                PREDS.fetch_add(1usize << i, SeqCst);\n                 true\n             }))\n         })\n         .unwrap_err();\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+        assert_eq!(PREDS.load(SeqCst), 0x011);\n+        assert_eq!(DROPS.load(SeqCst), 3);\n     }\n \n     #[test]\n@@ -1123,7 +1118,7 @@ mod test_drain_filter {\n         struct D;\n         impl Drop for D {\n             fn drop(&mut self) {\n-                DROPS.fetch_add(1, Ordering::SeqCst);\n+                DROPS.fetch_add(1, SeqCst);\n             }\n         }\n \n@@ -1132,7 +1127,7 @@ mod test_drain_filter {\n \n         catch_unwind(AssertUnwindSafe(|| {\n             drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                PREDS.fetch_add(1usize << i, SeqCst);\n                 match i {\n                     0 => true,\n                     _ => panic!(),\n@@ -1141,8 +1136,8 @@ mod test_drain_filter {\n         }))\n         .unwrap_err();\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(PREDS.load(SeqCst), 0x011);\n+        assert_eq!(DROPS.load(SeqCst), 1);\n         assert_eq!(map.len(), 2);\n         assert_eq!(map.first_entry().unwrap().key(), &4);\n         assert_eq!(map.last_entry().unwrap().key(), &8);\n@@ -1158,7 +1153,7 @@ mod test_drain_filter {\n         struct D;\n         impl Drop for D {\n             fn drop(&mut self) {\n-                DROPS.fetch_add(1, Ordering::SeqCst);\n+                DROPS.fetch_add(1, SeqCst);\n             }\n         }\n \n@@ -1167,7 +1162,7 @@ mod test_drain_filter {\n \n         {\n             let mut it = map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                PREDS.fetch_add(1usize << i, SeqCst);\n                 match i {\n                     0 => true,\n                     _ => panic!(),\n@@ -1180,8 +1175,8 @@ mod test_drain_filter {\n             assert!(matches!(result, Ok(None)));\n         }\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(PREDS.load(SeqCst), 0x011);\n+        assert_eq!(DROPS.load(SeqCst), 1);\n         assert_eq!(map.len(), 2);\n         assert_eq!(map.first_entry().unwrap().key(), &4);\n         assert_eq!(map.last_entry().unwrap().key(), &8);\n@@ -1315,8 +1310,6 @@ fn test_zst() {\n // undefined.\n #[test]\n fn test_bad_zst() {\n-    use std::cmp::Ordering;\n-\n     #[derive(Clone, Copy, Debug)]\n     struct Bad;\n \n@@ -1763,7 +1756,7 @@ fn test_append_drop_leak() {\n \n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == 0 {\n+            if DROPS.fetch_add(1, SeqCst) == 0 {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n@@ -1779,7 +1772,7 @@ fn test_append_drop_leak() {\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n \n-    assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n+    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n #[test]\n@@ -1894,7 +1887,7 @@ fn test_into_iter_drop_leak_height_0() {\n \n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == 3 {\n+            if DROPS.fetch_add(1, SeqCst) == 3 {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n@@ -1909,7 +1902,7 @@ fn test_into_iter_drop_leak_height_0() {\n \n     catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n-    assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n+    assert_eq!(DROPS.load(SeqCst), 5);\n }\n \n #[test]\n@@ -1921,18 +1914,18 @@ fn test_into_iter_drop_leak_height_1() {\n     struct D;\n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == PANIC_POINT.load(Ordering::SeqCst) {\n+            if DROPS.fetch_add(1, SeqCst) == PANIC_POINT.load(SeqCst) {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n     }\n \n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        DROPS.store(0, Ordering::SeqCst);\n-        PANIC_POINT.store(panic_point, Ordering::SeqCst);\n+        DROPS.store(0, SeqCst);\n+        PANIC_POINT.store(panic_point, SeqCst);\n         let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n-        assert_eq!(DROPS.load(Ordering::SeqCst), size);\n+        assert_eq!(DROPS.load(SeqCst), size);\n     }\n }\n "}, {"sha": "96ce7c15790463b3770285f6395859d64ea9afdc", "filename": "library/alloc/src/collections/btree/map/tests/ord_chaos.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -2,6 +2,7 @@ use std::cell::Cell;\n use std::cmp::Ordering::{self, *};\n use std::ptr;\n \n+// Minimal type with an `Ord` implementation violating transitivity.\n #[derive(Debug)]\n pub enum Cyclic3 {\n     A,\n@@ -34,6 +35,7 @@ impl PartialEq for Cyclic3 {\n \n impl Eq for Cyclic3 {}\n \n+// Controls the ordering of values wrapped by `Governed`.\n #[derive(Debug)]\n pub struct Governor {\n     flipped: Cell<bool>,\n@@ -49,6 +51,9 @@ impl Governor {\n     }\n }\n \n+// Type with an `Ord` implementation that forms a total order at any moment\n+// (assuming that `T` respects total order), but can suddenly be made to invert\n+// that total order.\n #[derive(Debug)]\n pub struct Governed<'a, T>(pub T, pub &'a Governor);\n "}, {"sha": "e3e555a72de027eaff23b382ef73e44634d8ce3c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -134,13 +134,13 @@ pub type Root<K, V> = NodeRef<marker::Owned, K, V, marker::LeafOrInternal>;\n \n impl<K, V> Root<K, V> {\n     /// Returns a new owned tree, with its own root node that is initially empty.\n-    pub fn new_leaf() -> Self {\n-        NodeRef::new().forget_type()\n+    pub fn new() -> Self {\n+        NodeRef::new_leaf().forget_type()\n     }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    fn new() -> Self {\n+    fn new_leaf() -> Self {\n         Self::from_new_leaf(Box::new(unsafe { LeafNode::new() }))\n     }\n "}, {"sha": "6886962106b02ea5dfd20c3df28f70c68a7af984", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -74,12 +74,12 @@ fn test_splitpoint() {\n \n #[test]\n fn test_partial_cmp_eq() {\n-    let mut root1 = NodeRef::new();\n+    let mut root1 = NodeRef::new_leaf();\n     let mut leaf1 = root1.borrow_mut();\n     leaf1.push(1, ());\n     let mut root1 = root1.forget_type();\n     root1.push_internal_level();\n-    let root2 = Root::new_leaf();\n+    let root2 = Root::new();\n     root1.reborrow().assert_back_pointers();\n     root2.reborrow().assert_back_pointers();\n "}, {"sha": "93de2d829ac8d9c6249d5da7efe38131cafca51b", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -50,7 +50,7 @@ where\n {\n     match search_linear(&node, key) {\n         (idx, true) => Found(unsafe { Handle::new_kv(node, idx) }),\n-        (idx, false) => SearchResult::GoDown(unsafe { Handle::new_edge(node, idx) }),\n+        (idx, false) => GoDown(unsafe { Handle::new_edge(node, idx) }),\n     }\n }\n "}, {"sha": "4d05bc4ebfa1e9aa5255d60f5103b123496f6504", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,9 +1,10 @@\n use super::super::DeterministicRng;\n use super::*;\n use crate::vec::Vec;\n+use std::cmp::Ordering;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering};\n+use std::sync::atomic::{AtomicU32, Ordering::SeqCst};\n \n #[test]\n fn test_clone_eq() {\n@@ -355,7 +356,7 @@ fn test_drain_filter_drop_panic_leak() {\n     struct D(i32);\n     impl Drop for D {\n         fn drop(&mut self) {\n-            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+            if DROPS.fetch_add(1, SeqCst) == 1 {\n                 panic!(\"panic in `drop`\");\n             }\n         }\n@@ -368,14 +369,14 @@ fn test_drain_filter_drop_panic_leak() {\n \n     catch_unwind(move || {\n         drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            PREDS.fetch_add(1u32 << d.0, SeqCst);\n             true\n         }))\n     })\n     .ok();\n \n-    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    assert_eq!(PREDS.load(SeqCst), 0x011);\n+    assert_eq!(DROPS.load(SeqCst), 3);\n }\n \n #[test]\n@@ -387,7 +388,7 @@ fn test_drain_filter_pred_panic_leak() {\n     struct D(i32);\n     impl Drop for D {\n         fn drop(&mut self) {\n-            DROPS.fetch_add(1, Ordering::SeqCst);\n+            DROPS.fetch_add(1, SeqCst);\n         }\n     }\n \n@@ -398,7 +399,7 @@ fn test_drain_filter_pred_panic_leak() {\n \n     catch_unwind(AssertUnwindSafe(|| {\n         drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            PREDS.fetch_add(1u32 << d.0, SeqCst);\n             match d.0 {\n                 0 => true,\n                 _ => panic!(),\n@@ -407,8 +408,8 @@ fn test_drain_filter_pred_panic_leak() {\n     }))\n     .ok();\n \n-    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n-    assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+    assert_eq!(PREDS.load(SeqCst), 0x011);\n+    assert_eq!(DROPS.load(SeqCst), 1);\n     assert_eq!(set.len(), 2);\n     assert_eq!(set.first().unwrap().0, 4);\n     assert_eq!(set.last().unwrap().0, 8);\n@@ -498,8 +499,6 @@ fn test_extend_ref() {\n \n #[test]\n fn test_recovery() {\n-    use std::cmp::Ordering;\n-\n     #[derive(Debug)]\n     struct Foo(&'static str, i32);\n "}, {"sha": "339d85902b83f06e8da0ef0a2f2a2a7d6852fb3a", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -50,7 +50,7 @@ impl Layout {\n     ///    must not overflow (i.e., the rounded value must be less than\n     ///    or equal to `usize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout\", since = \"1.50.0\")]\n     #[inline]\n     pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {\n         if !align.is_power_of_two() {\n@@ -96,15 +96,15 @@ impl Layout {\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout\", since = \"1.50.0\")]\n     #[inline]\n     pub const fn size(&self) -> usize {\n         self.size_\n     }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout\", since = \"1.50.0\")]\n     #[inline]\n     pub const fn align(&self) -> usize {\n         self.align_.get()"}, {"sha": "00164c631b305799cd760426cdfda0f08c752433", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -23,12 +23,10 @@ impl bool {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(bool_to_option)]\n-    ///\n     /// assert_eq!(false.then(|| 0), None);\n     /// assert_eq!(true.then(|| 0), Some(0));\n     /// ```\n-    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[stable(feature = \"lazy_bool_to_option\", since = \"1.50.0\")]\n     #[inline]\n     pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n         if self { Some(f()) } else { None }"}, {"sha": "e1b6307613b7303e9e9e541869270330b9ab1da0", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1027,7 +1027,6 @@ impl<T: Default> RefCell<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(refcell_take)]\n     /// use std::cell::RefCell;\n     ///\n     /// let c = RefCell::new(5);\n@@ -1036,7 +1035,7 @@ impl<T: Default> RefCell<T> {\n     /// assert_eq!(five, 5);\n     /// assert_eq!(c.into_inner(), 0);\n     /// ```\n-    #[unstable(feature = \"refcell_take\", issue = \"71395\")]\n+    #[stable(feature = \"refcell_take\", since = \"1.50.0\")]\n     pub fn take(&self) -> T {\n         self.replace(Default::default())\n     }"}, {"sha": "9753e1b43ba956aac96fc6c70d7c173ff316a4f4", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,6 +1,5 @@\n use crate::iter::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n-use crate::ops::Try;\n-use crate::usize;\n+use crate::{ops::Try, usize};\n \n /// An iterator that links two iterators together, in a chain.\n ///"}, {"sha": "7da47dcd2d1478d004d4042069f2b79f9fdc6181", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,139 @@\n+use crate::iter::adapters::{zip::try_get_unchecked, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned`]: Iterator::cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    it: I,\n+}\n+\n+impl<I> Cloned<I> {\n+    pub(in crate::iter) fn new(it: I) -> Cloned<I> {\n+        Cloned { it }\n+    }\n+}\n+\n+fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, elt| f(acc, elt.clone())\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_fold(init, clone_try_fold(f))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.map(T::clone).fold(init, f)\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_rfold(init, clone_try_fold(f))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.map(T::clone).rfold(init, f)\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Cloned<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Clone,\n+{\n+}"}, {"sha": "46f22354111a642faf838d9af3864af99b71b5ec", "filename": "library/core/src/iter/adapters/copied.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,155 @@\n+use crate::iter::adapters::{zip::try_get_unchecked, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: Iterator::copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    it: I,\n+}\n+\n+impl<I> Copied<I> {\n+    pub(in crate::iter) fn new(it: I) -> Copied<I> {\n+        Copied { it }\n+    }\n+}\n+\n+fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_fold(init, copy_try_fold(f))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, copy_fold(f))\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<T> {\n+        self.it.nth(n).copied()\n+    }\n+\n+    fn last(self) -> Option<T> {\n+        self.it.last().copied()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.it.count()\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        *unsafe { try_get_unchecked(&mut self.it, idx) }\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().copied()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_rfold(init, copy_try_fold(f))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, copy_fold(f))\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Copied<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Copy,\n+{\n+}"}, {"sha": "6e9a011f819afce629cb5411aa86807aac47460a", "filename": "library/core/src/iter/adapters/cycle.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,87 @@\n+use crate::{iter::FusedIterator, ops::Try};\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle`]: Iterator::cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n+}\n+\n+impl<I: Clone> Cycle<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Cycle<I> {\n+        Cycle { orig: iter.clone(), iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I>\n+where\n+    I: Clone + Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => {\n+                self.iter = self.orig.clone();\n+                self.iter.next()\n+            }\n+            y => y,\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None),\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // fully iterate the current iterator. this is necessary because\n+        // `self.iter` may be empty even when `self.orig` isn't\n+        acc = self.iter.try_fold(acc, &mut f)?;\n+        self.iter = self.orig.clone();\n+\n+        // complete a full cycle, keeping track of whether the cycled\n+        // iterator is empty or not. we need to return early in case\n+        // of an empty iterator to prevent an infinite loop\n+        let mut is_empty = true;\n+        acc = self.iter.try_fold(acc, |acc, x| {\n+            is_empty = false;\n+            f(acc, x)\n+        })?;\n+\n+        if is_empty {\n+            return try { acc };\n+        }\n+\n+        loop {\n+            self.iter = self.orig.clone();\n+            acc = self.iter.try_fold(acc, &mut f)?;\n+        }\n+    }\n+\n+    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n+    // and we can't do anything better than the default.\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}"}, {"sha": "5978c2da98c35796a3863e54712c6e110738ad49", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,238 @@\n+use crate::iter::adapters::{zip::try_get_unchecked, SourceIter, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::{Add, AddAssign, Try};\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate`]: Iterator::enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+impl<I> Enumerate<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Enumerate<I> {\n+        Enumerate { iter, count: 0 }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.next()?;\n+        let i = self.count;\n+        // Possible undefined overflow.\n+        AddAssign::add_assign(&mut self.count, 1);\n+        Some((i, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        let a = self.iter.nth(n)?;\n+        // Possible undefined overflow.\n+        let i = Add::add(self.count, n);\n+        self.count = Add::add(i, 1);\n+        Some((i, a))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn enumerate<'a, T, Acc, R>(\n+            count: &'a mut usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, item| {\n+                let acc = fold(acc, (*count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                let acc = fold(acc, (count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(&mut count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.fold(init, enumerate(self.count, fold))\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n+        (Add::add(self.count, idx), value)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.next_back()?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.nth_back(n)?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        fn enumerate<T, Acc, R>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n+        ) -> impl FnMut(Acc, T) -> R {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, enumerate(count, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.rfold(init, enumerate(count, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}"}, {"sha": "f8d684fcdda46ca9d7c52cb770a947579fb54add", "filename": "library/core/src/iter/adapters/filter.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,152 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::Try;\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter`]: Iterator::filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+impl<I, P> Filter<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n+        Filter { iter, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn filter_fold<T, Acc>(\n+    mut predicate: impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}\n+\n+fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n+    predicate: &'a mut impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        self.iter.find(&mut self.predicate)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    // this special case allows the compiler to make `.filter(_).count()`\n+    // branchless. Barring perfect branch prediction (which is unattainable in\n+    // the general case), this will be much faster in >90% of cases (containing\n+    // virtually all real workloads) and only a tiny bit slower in the rest.\n+    //\n+    // Having this specialization thus allows us to write `.filter(p).count()`\n+    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n+    // less readable and also less backwards-compatible to Rust before 1.10.\n+    //\n+    // Using the branchless version will also simplify the LLVM byte code, thus\n+    // leaving more budget for LLVM optimizations.\n+    #[inline]\n+    fn count(self) -> usize {\n+        #[inline]\n+        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n+            move |x| predicate(&x) as usize\n+        }\n+\n+        self.iter.map(to_usize(self.predicate)).sum()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, filter_fold(self.predicate, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        self.iter.rfind(&mut self.predicate)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, filter_fold(self.predicate, fold))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}"}, {"sha": "0dccf2c533b57e8f3455ad12d95c85bb7f790c2d", "filename": "library/core/src/iter/adapters/filter_map.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,150 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map`]: Iterator::filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> FilterMap<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> FilterMap<I, F> {\n+        FilterMap { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn filter_map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => acc,\n+    }\n+}\n+\n+fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n+    f: &'a mut impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => try { acc },\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.find_map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, filter_map_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        #[inline]\n+        fn find<T, B>(\n+            f: &mut impl FnMut(T) -> Option<B>,\n+        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n+            move |(), x| match f(x) {\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::CONTINUE,\n+            }\n+        }\n+\n+        self.iter.try_rfold((), find(&mut self.f)).break_value()\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, filter_map_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n+    F: FnMut(I::Item) -> Option<B>\n+{\n+}"}, {"sha": "ff85e114dc98262699267286c50691c033e7fab0", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,9 +1,7 @@\n use crate::fmt;\n+use crate::iter::{DoubleEndedIterator, Fuse, FusedIterator, Iterator, Map};\n use crate::ops::Try;\n \n-use super::super::{DoubleEndedIterator, Fuse, FusedIterator, Iterator};\n-use super::Map;\n-\n /// An iterator that maps each element to an iterator, and yields the elements\n /// of the produced iterators.\n ///\n@@ -14,8 +12,9 @@ use super::Map;\n pub struct FlatMap<I, U: IntoIterator, F> {\n     inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n }\n+\n impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n-    pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n         FlatMap { inner: FlattenCompat::new(iter.map(f)) }\n     }\n }"}, {"sha": "ae074065315935f8a96971d7c7ef845ab2fe3a53", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,9 +1,6 @@\n-use super::InPlaceIterable;\n use crate::intrinsics;\n-use crate::iter::adapters::zip::try_get_unchecked;\n-use crate::iter::adapters::SourceIter;\n-use crate::iter::TrustedRandomAccess;\n-use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n+use crate::iter::adapters::{zip::try_get_unchecked, InPlaceIterable, SourceIter};\n+use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedRandomAccess};\n use crate::ops::Try;\n \n /// An iterator that yields `None` forever after the underlying iterator"}, {"sha": "88f5ee61b6b7348b127f58c872d8d4a0673d8500", "filename": "library/core/src/iter/adapters/inspect.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,167 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::Try;\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect`]: Iterator::inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Inspect<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> Inspect<I, F> {\n+        Inspect { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+fn inspect_fold<T, Acc>(\n+    mut f: impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n+}\n+\n+fn inspect_try_fold<'a, T, Acc, R>(\n+    f: &'a mut impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, inspect_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, inspect_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}"}, {"sha": "12673806ec40d5d2ad74e267545e3588a1a24d5a", "filename": "library/core/src/iter/adapters/map.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,213 @@\n+use crate::fmt;\n+use crate::iter::adapters::{zip::try_get_unchecked, SourceIter, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map`]: Iterator::map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazily on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Map<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n+        Map { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+fn map_try_fold<'a, T, B, Acc, R>(\n+    f: &'a mut impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n+    }\n+\n+    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, map_fold(self.f, g))\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n+    }\n+\n+    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, map_fold(self.f, g))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<B, I, F> TrustedLen for Map<I, F>\n+where\n+    I: TrustedLen,\n+    F: FnMut(I::Item) -> B,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}"}, {"sha": "26114d5328498c39671b3dba3780cc9be94d0631", "filename": "library/core/src/iter/adapters/map_while.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,101 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n+///\n+/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map_while`]: Iterator::map_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+#[derive(Clone)]\n+pub struct MapWhile<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+\n+impl<I, P> MapWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n+        MapWhile { iter, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let x = self.iter.next()?;\n+        (self.predicate)(x)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        let Self { iter, predicate } = self;\n+        iter.try_fold(init, |acc, x| match predicate(x) {\n+            Some(item) => ControlFlow::from_try(fold(acc, item)),\n+            None => ControlFlow::Break(try { acc }),\n+        })\n+        .into_try()\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n+    P: FnMut(I::Item) -> Option<B>\n+{\n+}"}, {"sha": "5ef5717085e4ffb403e1f54783eb0c30bce62da5", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 40, "deletions": 2819, "changes": 2859, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,26 +1,51 @@\n-use crate::cmp;\n-use crate::fmt;\n-use crate::intrinsics;\n-use crate::ops::{Add, AddAssign, ControlFlow, Try};\n-\n-use super::from_fn;\n-use super::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, TrustedLen,\n-};\n+use crate::iter::{InPlaceIterable, Iterator};\n+use crate::ops::{ControlFlow, Try};\n \n mod chain;\n+mod cloned;\n+mod copied;\n+mod cycle;\n+mod enumerate;\n+mod filter;\n+mod filter_map;\n mod flatten;\n mod fuse;\n+mod inspect;\n+mod map;\n+mod map_while;\n+mod peekable;\n+mod rev;\n+mod scan;\n+mod skip;\n+mod skip_while;\n+mod step_by;\n+mod take;\n+mod take_while;\n mod zip;\n \n-pub use self::chain::Chain;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::flatten::{FlatMap, Flatten};\n-pub use self::fuse::Fuse;\n-use self::zip::try_get_unchecked;\n+pub use self::{\n+    chain::Chain, cycle::Cycle, enumerate::Enumerate, filter::Filter, filter_map::FilterMap,\n+    flatten::FlatMap, fuse::Fuse, inspect::Inspect, map::Map, peekable::Peekable, rev::Rev,\n+    scan::Scan, skip::Skip, skip_while::SkipWhile, take::Take, take_while::TakeWhile, zip::Zip,\n+};\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+pub use self::cloned::Cloned;\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+pub use self::step_by::StepBy;\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub use self::flatten::Flatten;\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+pub use self::copied::Copied;\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+pub use self::map_while::MapWhile;\n+\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n pub use self::zip::TrustedRandomAccess;\n-pub use self::zip::Zip;\n \n /// This trait provides transitive access to source-stage in an interator-adapter pipeline\n /// under the conditions that\n@@ -89,2810 +114,6 @@ pub unsafe trait SourceIter {\n     unsafe fn as_inner(&mut self) -> &mut Self::Source;\n }\n \n-/// A double-ended iterator with the direction inverted.\n-///\n-/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`rev`]: Iterator::rev\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rev<T> {\n-    iter: T,\n-}\n-impl<T> Rev<T> {\n-    pub(super) fn new(iter: T) -> Rev<T> {\n-        Rev { iter }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Rev<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next_back()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        self.iter.advance_back_by(n)\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth_back(n)\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.iter.try_rfold(init, f)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.iter.rfind(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Rev<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next()\n-    }\n-\n-    #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        self.iter.advance_by(n)\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth(n)\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.iter.try_fold(init, f)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, f)\n-    }\n-\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.iter.find(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Rev<I>\n-where\n-    I: ExactSizeIterator + DoubleEndedIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}\n-\n-/// An iterator that copies the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`copied`]: Iterator::copied\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Copied<I> {\n-    it: I,\n-}\n-\n-impl<I> Copied<I> {\n-    pub(super) fn new(it: I) -> Copied<I> {\n-        Copied { it }\n-    }\n-}\n-\n-fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n-    move |acc, &elt| f(acc, elt)\n-}\n-\n-fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n-    move |acc, &elt| f(acc, elt)\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> Iterator for Copied<I>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().copied()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_fold(init, copy_try_fold(f))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, copy_fold(f))\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<T> {\n-        self.it.nth(n).copied()\n-    }\n-\n-    fn last(self) -> Option<T> {\n-        self.it.last().copied()\n-    }\n-\n-    fn count(self) -> usize {\n-        self.it.count()\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        *unsafe { try_get_unchecked(&mut self.it, idx) }\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n-where\n-    I: DoubleEndedIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().copied()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_rfold(init, copy_try_fold(f))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, copy_fold(f))\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n-where\n-    I: ExactSizeIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Copied<I>\n-where\n-    I: FusedIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Copied<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n-where\n-    I: TrustedLen<Item = &'a T>,\n-    T: Copy,\n-{\n-}\n-\n-/// An iterator that clones the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cloned`]: Iterator::cloned\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Cloned<I> {\n-    it: I,\n-}\n-impl<I> Cloned<I> {\n-    pub(super) fn new(it: I) -> Cloned<I> {\n-        Cloned { it }\n-    }\n-}\n-\n-fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n-    move |acc, elt| f(acc, elt.clone())\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> Iterator for Cloned<I>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().cloned()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_fold(init, clone_try_fold(f))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.map(T::clone).fold(init, f)\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n-where\n-    I: DoubleEndedIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().cloned()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_rfold(init, clone_try_fold(f))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.map(T::clone).rfold(init, f)\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n-where\n-    I: ExactSizeIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n-where\n-    I: FusedIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Cloned<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n-where\n-    I: TrustedLen<Item = &'a T>,\n-    T: Clone,\n-{\n-}\n-\n-/// An iterator that repeats endlessly.\n-///\n-/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cycle`]: Iterator::cycle\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Cycle<I> {\n-    orig: I,\n-    iter: I,\n-}\n-impl<I: Clone> Cycle<I> {\n-    pub(super) fn new(iter: I) -> Cycle<I> {\n-        Cycle { orig: iter.clone(), iter }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cycle<I>\n-where\n-    I: Clone + Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        match self.iter.next() {\n-            None => {\n-                self.iter = self.orig.clone();\n-                self.iter.next()\n-            }\n-            y => y,\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // the cycle iterator is either empty or infinite\n-        match self.orig.size_hint() {\n-            sz @ (0, Some(0)) => sz,\n-            (0, _) => (0, None),\n-            _ => (usize::MAX, None),\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        // fully iterate the current iterator. this is necessary because\n-        // `self.iter` may be empty even when `self.orig` isn't\n-        acc = self.iter.try_fold(acc, &mut f)?;\n-        self.iter = self.orig.clone();\n-\n-        // complete a full cycle, keeping track of whether the cycled\n-        // iterator is empty or not. we need to return early in case\n-        // of an empty iterator to prevent an infinite loop\n-        let mut is_empty = true;\n-        acc = self.iter.try_fold(acc, |acc, x| {\n-            is_empty = false;\n-            f(acc, x)\n-        })?;\n-\n-        if is_empty {\n-            return try { acc };\n-        }\n-\n-        loop {\n-            self.iter = self.orig.clone();\n-            acc = self.iter.try_fold(acc, &mut f)?;\n-        }\n-    }\n-\n-    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n-    // and we can't do anything better than the default.\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n-\n-/// An iterator for stepping iterators by a custom amount.\n-///\n-/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n-/// its documentation for more.\n-///\n-/// [`step_by`]: Iterator::step_by\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-#[derive(Clone, Debug)]\n-pub struct StepBy<I> {\n-    iter: I,\n-    step: usize,\n-    first_take: bool,\n-}\n-impl<I> StepBy<I> {\n-    pub(super) fn new(iter: I, step: usize) -> StepBy<I> {\n-        assert!(step != 0);\n-        StepBy { iter, step: step - 1, first_take: true }\n-    }\n-}\n-\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> Iterator for StepBy<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            self.iter.next()\n-        } else {\n-            self.iter.nth(self.step)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        #[inline]\n-        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n-            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n-        }\n-\n-        #[inline]\n-        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n-            move |n| n / (step + 1)\n-        }\n-\n-        let (low, high) = self.iter.size_hint();\n-\n-        if self.first_take {\n-            let f = first_size(self.step);\n-            (f(low), high.map(f))\n-        } else {\n-            let f = other_size(self.step);\n-            (f(low), high.map(f))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            let first = self.iter.next();\n-            if n == 0 {\n-                return first;\n-            }\n-            n -= 1;\n-        }\n-        // n and self.step are indices, we need to add 1 to get the amount of elements\n-        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n-        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n-        let mut step = self.step + 1;\n-        // n + 1 could overflow\n-        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n-        if n == usize::MAX {\n-            self.iter.nth(step - 1);\n-        } else {\n-            n += 1;\n-        }\n-\n-        // overflow handling\n-        loop {\n-            let mul = n.checked_mul(step);\n-            {\n-                if intrinsics::likely(mul.is_some()) {\n-                    return self.iter.nth(mul.unwrap() - 1);\n-                }\n-            }\n-            let div_n = usize::MAX / n;\n-            let div_step = usize::MAX / step;\n-            let nth_n = div_n * n;\n-            let nth_step = div_step * step;\n-            let nth = if nth_n > nth_step {\n-                step -= div_n;\n-                nth_n\n-            } else {\n-                n -= div_step;\n-                nth_step\n-            };\n-            self.iter.nth(nth - 1);\n-        }\n-    }\n-\n-    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth(step)\n-        }\n-\n-        if self.first_take {\n-            self.first_take = false;\n-            match self.iter.next() {\n-                None => return try { acc },\n-                Some(x) => acc = f(acc, x)?,\n-            }\n-        }\n-        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n-    }\n-\n-    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth(step)\n-        }\n-\n-        if self.first_take {\n-            self.first_take = false;\n-            match self.iter.next() {\n-                None => return acc,\n-                Some(x) => acc = f(acc, x),\n-            }\n-        }\n-        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n-    }\n-}\n-\n-impl<I> StepBy<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    // The zero-based index starting from the end of the iterator of the\n-    // last element. Used in the `DoubleEndedIterator` implementation.\n-    fn next_back_index(&self) -> usize {\n-        let rem = self.iter.len() % (self.step + 1);\n-        if self.first_take {\n-            if rem == 0 { self.step } else { rem - 1 }\n-        } else {\n-            rem\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for StepBy<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.iter.nth_back(self.next_back_index())\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n-        // is out of bounds because the length of `self.iter` does not exceed\n-        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n-        // zero-indexed\n-        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n-        self.iter.nth_back(n)\n-    }\n-\n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn nth_back<I: DoubleEndedIterator>(\n-            iter: &mut I,\n-            step: usize,\n-        ) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth_back(step)\n-        }\n-\n-        match self.next_back() {\n-            None => try { init },\n-            Some(x) => {\n-                let acc = f(init, x)?;\n-                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n-    where\n-        Self: Sized,\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn nth_back<I: DoubleEndedIterator>(\n-            iter: &mut I,\n-            step: usize,\n-        ) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth_back(step)\n-        }\n-\n-        match self.next_back() {\n-            None => init,\n-            Some(x) => {\n-                let acc = f(init, x);\n-                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n-            }\n-        }\n-    }\n-}\n-\n-// StepBy can only make the iterator shorter, so the len will still fit.\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n-\n-/// An iterator that maps the values of `iter` with `f`.\n-///\n-/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map`]: Iterator::map\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Notes about side effects\n-///\n-/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n-/// you can also [`map`] backwards:\n-///\n-/// ```rust\n-/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n-///\n-/// assert_eq!(v, [4, 3, 2]);\n-/// ```\n-///\n-/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n-///\n-/// But if your closure has state, iterating backwards may act in a way you do\n-/// not expect. Let's go through an example. First, in the forward direction:\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) }) {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-///\n-/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n-///\n-/// Now consider this twist where we add a call to `rev`. This version will\n-/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n-/// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazily on each item, but we are popping items off the\n-/// back of the vector now, instead of shifting them from the front.\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) })\n-///                                .rev() {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Map<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> Map<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> Map<I, F> {\n-        Map { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn map_fold<T, B, Acc>(\n-    mut f: impl FnMut(T) -> B,\n-    mut g: impl FnMut(Acc, B) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, elt| g(acc, f(elt))\n-}\n-\n-fn map_try_fold<'a, T, B, Acc, R>(\n-    f: &'a mut impl FnMut(T) -> B,\n-    mut g: impl FnMut(Acc, B) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, elt| g(acc, f(elt))\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n-    where\n-        Self: Sized,\n-        G: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n-    }\n-\n-    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n-    where\n-        G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, map_fold(self.f, g))\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        self.iter.next_back().map(&mut self.f)\n-    }\n-\n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n-    where\n-        Self: Sized,\n-        G: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n-    }\n-\n-    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n-    where\n-        G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, map_fold(self.f, g))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<B, I, F> TrustedLen for Map<I, F>\n-where\n-    I: TrustedLen,\n-    F: FnMut(I::Item) -> B,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}\n-\n-/// An iterator that filters the elements of `iter` with `predicate`.\n-///\n-/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter`]: Iterator::filter\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Filter<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-impl<I, P> Filter<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> Filter<I, P> {\n-        Filter { iter, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn filter_fold<T, Acc>(\n-    mut predicate: impl FnMut(&T) -> bool,\n-    mut fold: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n-}\n-\n-fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n-    predicate: &'a mut impl FnMut(&T) -> bool,\n-    mut fold: impl FnMut(Acc, T) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        self.iter.find(&mut self.predicate)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    // this special case allows the compiler to make `.filter(_).count()`\n-    // branchless. Barring perfect branch prediction (which is unattainable in\n-    // the general case), this will be much faster in >90% of cases (containing\n-    // virtually all real workloads) and only a tiny bit slower in the rest.\n-    //\n-    // Having this specialization thus allows us to write `.filter(p).count()`\n-    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n-    // less readable and also less backwards-compatible to Rust before 1.10.\n-    //\n-    // Using the branchless version will also simplify the LLVM byte code, thus\n-    // leaving more budget for LLVM optimizations.\n-    #[inline]\n-    fn count(self) -> usize {\n-        #[inline]\n-        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n-            move |x| predicate(&x) as usize\n-        }\n-\n-        self.iter.map(to_usize(self.predicate)).sum()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, filter_fold(self.predicate, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        self.iter.rfind(&mut self.predicate)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, filter_fold(self.predicate, fold))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that uses `f` to both filter and map elements from `iter`.\n-///\n-/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter_map`]: Iterator::filter_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct FilterMap<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> FilterMap<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> FilterMap<I, F> {\n-        FilterMap { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn filter_map_fold<T, B, Acc>(\n-    mut f: impl FnMut(T) -> Option<B>,\n-    mut fold: impl FnMut(Acc, B) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| match f(item) {\n-        Some(x) => fold(acc, x),\n-        None => acc,\n-    }\n-}\n-\n-fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n-    f: &'a mut impl FnMut(T) -> Option<B>,\n-    mut fold: impl FnMut(Acc, B) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| match f(item) {\n-        Some(x) => fold(acc, x),\n-        None => try { acc },\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.find_map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, filter_map_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        #[inline]\n-        fn find<T, B>(\n-            f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n-            move |(), x| match f(x) {\n-                Some(x) => ControlFlow::Break(x),\n-                None => ControlFlow::CONTINUE,\n-            }\n-        }\n-\n-        self.iter.try_rfold((), find(&mut self.f)).break_value()\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, filter_map_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n-    F: FnMut(I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that yields the current count and the element during iteration.\n-///\n-/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`enumerate`]: Iterator::enumerate\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Enumerate<I> {\n-    iter: I,\n-    count: usize,\n-}\n-impl<I> Enumerate<I> {\n-    pub(super) fn new(iter: I) -> Enumerate<I> {\n-        Enumerate { iter, count: 0 }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Enumerate<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = (usize, <I as Iterator>::Item);\n-\n-    /// # Overflow Behavior\n-    ///\n-    /// The method does no guarding against overflows, so enumerating more than\n-    /// `usize::MAX` elements either produces the wrong result or panics. If\n-    /// debug assertions are enabled, a panic is guaranteed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Might panic if the index of the element overflows a `usize`.\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.next()?;\n-        let i = self.count;\n-        // Possible undefined overflow.\n-        AddAssign::add_assign(&mut self.count, 1);\n-        Some((i, a))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        let a = self.iter.nth(n)?;\n-        // Possible undefined overflow.\n-        let i = Add::add(self.count, n);\n-        self.count = Add::add(i, 1);\n-        Some((i, a))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn enumerate<'a, T, Acc, R>(\n-            count: &'a mut usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> R + 'a {\n-            move |acc, item| {\n-                let acc = fold(acc, (*count, item));\n-                // Possible undefined overflow.\n-                AddAssign::add_assign(count, 1);\n-                acc\n-            }\n-        }\n-\n-        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn enumerate<T, Acc>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n-        ) -> impl FnMut(Acc, T) -> Acc {\n-            move |acc, item| {\n-                let acc = fold(acc, (count, item));\n-                // Possible undefined overflow.\n-                AddAssign::add_assign(&mut count, 1);\n-                acc\n-            }\n-        }\n-\n-        self.iter.fold(init, enumerate(self.count, fold))\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n-        (Add::add(self.count, idx), value)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Enumerate<I>\n-where\n-    I: ExactSizeIterator + DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.next_back()?;\n-        let len = self.iter.len();\n-        // Can safely add, `ExactSizeIterator` promises that the number of\n-        // elements fits into a `usize`.\n-        Some((self.count + len, a))\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.nth_back(n)?;\n-        let len = self.iter.len();\n-        // Can safely add, `ExactSizeIterator` promises that the number of\n-        // elements fits into a `usize`.\n-        Some((self.count + len, a))\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        fn enumerate<T, Acc, R>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n-        ) -> impl FnMut(Acc, T) -> R {\n-            move |acc, item| {\n-                count -= 1;\n-                fold(acc, (count, item))\n-            }\n-        }\n-\n-        let count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, enumerate(count, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        fn enumerate<T, Acc>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n-        ) -> impl FnMut(Acc, T) -> Acc {\n-            move |acc, item| {\n-                count -= 1;\n-                fold(acc, (count, item))\n-            }\n-        }\n-\n-        let count = self.count + self.iter.len();\n-        self.iter.rfold(init, enumerate(count, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}\n-\n-/// An iterator with a `peek()` that returns an optional reference to the next\n-/// element.\n-///\n-/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`peekable`]: Iterator::peekable\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<I: Iterator> {\n-    iter: I,\n-    /// Remember a peeked value, even if it was None.\n-    peeked: Option<Option<I::Item>>,\n-}\n-impl<I: Iterator> Peekable<I> {\n-    pub(super) fn new(iter: I) -> Peekable<I> {\n-        Peekable { iter, peeked: None }\n-    }\n-}\n-\n-// Peekable must remember if a None has been seen in the `.peek()` method.\n-// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n-// underlying iterator at most once. This does not by itself make the iterator\n-// fused.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> Iterator for Peekable<I> {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(v) => v,\n-            None => self.iter.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(mut self) -> usize {\n-        match self.peeked.take() {\n-            Some(None) => 0,\n-            Some(Some(_)) => 1 + self.iter.count(),\n-            None => self.iter.count(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(None) => None,\n-            Some(v @ Some(_)) if n == 0 => v,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        let peek_opt = match self.peeked.take() {\n-            Some(None) => return None,\n-            Some(v) => v,\n-            None => None,\n-        };\n-        self.iter.last().or(peek_opt)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let peek_len = match self.peeked {\n-            Some(None) => return (0, Some(0)),\n-            Some(Some(_)) => 1,\n-            None => 0,\n-        };\n-        let (lo, hi) = self.iter.size_hint();\n-        let lo = lo.saturating_add(peek_len);\n-        let hi = match hi {\n-            Some(x) => x.checked_add(peek_len),\n-            None => None,\n-        };\n-        (lo, hi)\n-    }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let acc = match self.peeked.take() {\n-            Some(None) => return try { init },\n-            Some(Some(v)) => f(init, v)?,\n-            None => init,\n-        };\n-        self.iter.try_fold(acc, f)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let acc = match self.peeked {\n-            Some(None) => return init,\n-            Some(Some(v)) => fold(init, v),\n-            None => init,\n-        };\n-        self.iter.fold(acc, fold)\n-    }\n-}\n-\n-#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Peekable<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        match self.peeked.as_mut() {\n-            Some(v @ Some(_)) => self.iter.next_back().or_else(|| v.take()),\n-            Some(None) => None,\n-            None => self.iter.next_back(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        match self.peeked.take() {\n-            Some(None) => try { init },\n-            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n-                Ok(acc) => f(acc, v),\n-                Err(e) => {\n-                    self.peeked = Some(Some(v));\n-                    Try::from_error(e)\n-                }\n-            },\n-            None => self.iter.try_rfold(init, f),\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        match self.peeked {\n-            Some(None) => init,\n-            Some(Some(v)) => {\n-                let acc = self.iter.rfold(init, &mut fold);\n-                fold(acc, v)\n-            }\n-            None => self.iter.rfold(init, fold),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n-\n-impl<I: Iterator> Peekable<I> {\n-    /// Returns a reference to the next() value without advancing the iterator.\n-    ///\n-    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n-    /// But if the iteration is over, `None` is returned.\n-    ///\n-    /// [`next`]: Iterator::next\n-    ///\n-    /// Because `peek()` returns a reference, and many iterators iterate over\n-    /// references, there can be a possibly confusing situation where the\n-    /// return value is a double reference. You can see this effect in the\n-    /// examples below.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // peek() lets us see into the future\n-    /// assert_eq!(iter.peek(), Some(&&1));\n-    /// assert_eq!(iter.next(), Some(&1));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&2));\n-    ///\n-    /// // The iterator does not advance even if we `peek` multiple times\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&3));\n-    ///\n-    /// // After the iterator is finished, so is `peek()`\n-    /// assert_eq!(iter.peek(), None);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&mut self) -> Option<&I::Item> {\n-        let iter = &mut self.iter;\n-        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n-    }\n-\n-    /// Consume and return the next value of this iterator if a condition is true.\n-    ///\n-    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n-    /// Otherwise, return `None`.\n-    ///\n-    /// # Examples\n-    /// Consume a number if it's equal to 0.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (0..5).peekable();\n-    /// // The first item of the iterator is 0; consume it.\n-    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n-    /// // The next item returned is now 1, so `consume` will return `false`.\n-    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n-    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// ```\n-    ///\n-    /// Consume any number less than 10.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (1..20).peekable();\n-    /// // Consume all numbers less than 10\n-    /// while iter.next_if(|&x| x < 10).is_some() {}\n-    /// // The next value returned will be 10\n-    /// assert_eq!(iter.next(), Some(10));\n-    /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n-    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n-        match self.next() {\n-            Some(matched) if func(&matched) => Some(matched),\n-            other => {\n-                // Since we called `self.next()`, we consumed `self.peeked`.\n-                assert!(self.peeked.is_none());\n-                self.peeked = Some(other);\n-                None\n-            }\n-        }\n-    }\n-\n-    /// Consume and return the next item if it is equal to `expected`.\n-    ///\n-    /// # Example\n-    /// Consume a number if it's equal to 0.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (0..5).peekable();\n-    /// // The first item of the iterator is 0; consume it.\n-    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n-    /// // The next item returned is now 1, so `consume` will return `false`.\n-    /// assert_eq!(iter.next_if_eq(&0), None);\n-    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n-    pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n-    where\n-        T: ?Sized,\n-        I::Item: PartialEq<T>,\n-    {\n-        self.next_if(|next| next == expected)\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}\n-\n-/// An iterator that rejects elements while `predicate` returns `true`.\n-///\n-/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip_while`]: Iterator::skip_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct SkipWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-impl<I, P> SkipWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n-        SkipWhile { iter, flag: false, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        fn check<'a, T>(\n-            flag: &'a mut bool,\n-            pred: &'a mut impl FnMut(&T) -> bool,\n-        ) -> impl FnMut(&T) -> bool + 'a {\n-            move |x| {\n-                if *flag || !pred(x) {\n-                    *flag = true;\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-\n-        let flag = &mut self.flag;\n-        let pred = &mut self.predicate;\n-        self.iter.find(check(flag, pred))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v)?,\n-                None => return try { init },\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v),\n-                None => return init,\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for SkipWhile<I, P>\n-where\n-    I: FusedIterator,\n-    P: FnMut(&I::Item) -> bool,\n-{\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n-    F: FnMut(&I::Item) -> bool\n-{\n-}\n-\n-/// An iterator that only accepts elements while `predicate` returns `true`.\n-///\n-/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take_while`]: Iterator::take_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct TakeWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-impl<I, P> TakeWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n-        TakeWhile { iter, flag: false, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.flag {\n-            None\n-        } else {\n-            let x = self.iter.next()?;\n-            if (self.predicate)(&x) {\n-                Some(x)\n-            } else {\n-                self.flag = true;\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.flag {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper) // can't know a lower bound, due to the predicate\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n-            flag: &'a mut bool,\n-            p: &'a mut impl FnMut(&T) -> bool,\n-            mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| {\n-                if p(&x) {\n-                    ControlFlow::from_try(fold(acc, x))\n-                } else {\n-                    *flag = true;\n-                    ControlFlow::Break(try { acc })\n-                }\n-            }\n-        }\n-\n-        if self.flag {\n-            try { init }\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n-        }\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for TakeWhile<I, P>\n-where\n-    I: FusedIterator,\n-    P: FnMut(&I::Item) -> bool,\n-{\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n-    F: FnMut(&I::Item) -> bool\n-{\n-}\n-\n-/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n-///\n-/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map_while`]: Iterator::map_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-#[derive(Clone)]\n-pub struct MapWhile<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-\n-impl<I, P> MapWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n-        MapWhile { iter, predicate }\n-    }\n-}\n-\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n-where\n-    P: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        let x = self.iter.next()?;\n-        (self.predicate)(x)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        let Self { iter, predicate } = self;\n-        iter.try_fold(init, |acc, x| match predicate(x) {\n-            Some(item) => ControlFlow::from_try(fold(acc, item)),\n-            None => ControlFlow::Break(try { acc }),\n-        })\n-        .into_try()\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n-where\n-    P: FnMut(I::Item) -> Option<B>,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n-    P: FnMut(I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that skips over `n` elements of `iter`.\n-///\n-/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip`]: Iterator::skip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Skip<I> {\n-    iter: I,\n-    n: usize,\n-}\n-impl<I> Skip<I> {\n-    pub(super) fn new(iter: I, n: usize) -> Skip<I> {\n-        Skip { iter, n }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Skip<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.next()\n-        } else {\n-            let old_n = self.n;\n-            self.n = 0;\n-            self.iter.nth(old_n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // Can't just add n + self.n due to overflow.\n-        if self.n > 0 {\n-            let to_skip = self.n;\n-            self.n = 0;\n-            // nth(n) skips n+1\n-            self.iter.nth(to_skip - 1)?;\n-        }\n-        self.iter.nth(n)\n-    }\n-\n-    #[inline]\n-    fn count(mut self) -> usize {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return 0;\n-            }\n-        }\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            self.iter.nth(self.n - 1)?;\n-        }\n-        self.iter.last()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = lower.saturating_sub(self.n);\n-        let upper = match upper {\n-            Some(x) => Some(x.saturating_sub(self.n)),\n-            None => None,\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        let n = self.n;\n-        self.n = 0;\n-        if n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(n - 1).is_none() {\n-                return try { init };\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return init;\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n-impl<I> DoubleEndedIterator for Skip<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.len() > 0 { self.iter.next_back() } else { None }\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n-        let len = self.len();\n-        if n < len {\n-            self.iter.nth_back(n)\n-        } else {\n-            if len > 0 {\n-                // consume the original iterator\n-                self.iter.nth_back(len - 1);\n-            }\n-            None\n-        }\n-    }\n-\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<T, Acc, R: Try<Ok = Acc>>(\n-            mut n: usize,\n-            mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n-            move |acc, x| {\n-                n -= 1;\n-                let r = fold(acc, x);\n-                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n-            }\n-        }\n-\n-        let n = self.len();\n-        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n-    }\n-\n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_rfold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}\n-\n-/// An iterator that only iterates over the first `n` iterations of `iter`.\n-///\n-/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take`]: Iterator::take\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Take<I> {\n-    pub(super) iter: I,\n-    pub(super) n: usize,\n-}\n-impl<I> Take<I> {\n-    pub(super) fn new(iter: I, n: usize) -> Take<I> {\n-        Take { iter, n }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Take<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.n != 0 {\n-            self.n -= 1;\n-            self.iter.next()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.n > n {\n-            self.n -= n + 1;\n-            self.iter.nth(n)\n-        } else {\n-            if self.n > 0 {\n-                self.iter.nth(self.n - 1);\n-                self.n = 0;\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.n == 0 {\n-            return (0, Some(0));\n-        }\n-\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = cmp::min(lower, self.n);\n-\n-        let upper = match upper {\n-            Some(x) if x < self.n => Some(x),\n-            _ => Some(self.n),\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n-            n: &'a mut usize,\n-            mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| {\n-                *n -= 1;\n-                let r = fold(acc, x);\n-                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n-            }\n-        }\n-\n-        if self.n == 0 {\n-            try { init }\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, check(n, fold)).into_try()\n-        }\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n-\n-#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Take<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.n == 0 {\n-            None\n-        } else {\n-            let n = self.n;\n-            self.n -= 1;\n-            self.iter.nth_back(self.iter.len().saturating_sub(n))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        let len = self.iter.len();\n-        if self.n > n {\n-            let m = len.saturating_sub(self.n) + n;\n-            self.n -= n + 1;\n-            self.iter.nth_back(m)\n-        } else {\n-            if len > 0 {\n-                self.iter.nth_back(len - 1);\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if self.n == 0 {\n-            try { init }\n-        } else {\n-            let len = self.iter.len();\n-            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                try { init }\n-            } else {\n-                self.iter.try_rfold(init, fold)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n == 0 {\n-            init\n-        } else {\n-            let len = self.iter.len();\n-            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                init\n-            } else {\n-                self.iter.rfold(init, fold)\n-            }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n-\n-/// An iterator to maintain state while iterating another iterator.\n-///\n-/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`scan`]: Iterator::scan\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Scan<I, St, F> {\n-    iter: I,\n-    f: F,\n-    state: St,\n-}\n-impl<I, St, F> Scan<I, St, F> {\n-    pub(super) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n-        Scan { iter, state, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I, St, F> Iterator for Scan<I, St, F>\n-where\n-    I: Iterator,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        let a = self.iter.next()?;\n-        (self.f)(&mut self.state, a)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the scan function\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n-            state: &'a mut St,\n-            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n-            mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| match f(state, x) {\n-                None => ControlFlow::Break(try { acc }),\n-                Some(x) => ControlFlow::from_try(fold(acc, x)),\n-            }\n-        }\n-\n-        let state = &mut self.state;\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n-where\n-    I: SourceIter<Source = S>,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n-    F: FnMut(&mut St, I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that calls a function with a reference to each element before\n-/// yielding it.\n-///\n-/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`inspect`]: Iterator::inspect\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Inspect<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> Inspect<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> Inspect<I, F> {\n-        Inspect { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-impl<I: Iterator, F> Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n-        if let Some(ref a) = elt {\n-            (self.f)(a);\n-        }\n-\n-        elt\n-    }\n-}\n-\n-fn inspect_fold<T, Acc>(\n-    mut f: impl FnMut(&T),\n-    mut fold: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| {\n-        f(&item);\n-        fold(acc, item)\n-    }\n-}\n-\n-fn inspect_try_fold<'a, T, Acc, R>(\n-    f: &'a mut impl FnMut(&T),\n-    mut fold: impl FnMut(Acc, T) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| {\n-        f(&item);\n-        fold(acc, item)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, F> Iterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, inspect_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next_back();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, inspect_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}\n-\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///"}, {"sha": "e7fb3abc94265d6c315cebe390666ca499f19502", "filename": "library/core/src/iter/adapters/peekable.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,301 @@\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable`]: Iterator::peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    iter: I,\n+    /// Remember a peeked value, even if it was None.\n+    peeked: Option<Option<I::Item>>,\n+}\n+\n+impl<I: Iterator> Peekable<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Peekable<I> {\n+        Peekable { iter, peeked: None }\n+    }\n+}\n+\n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(v) => v,\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(None) => None,\n+            Some(v @ Some(_)) if n == 0 => v,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n+        let (lo, hi) = self.iter.size_hint();\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = match hi {\n+            Some(x) => x.checked_add(peek_len),\n+            None => None,\n+        };\n+        (lo, hi)\n+    }\n+\n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return try { init },\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Peekable<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        match self.peeked.as_mut() {\n+            Some(v @ Some(_)) => self.iter.next_back().or_else(|| v.take()),\n+            Some(None) => None,\n+            None => self.iter.next_back(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        match self.peeked.take() {\n+            Some(None) => try { init },\n+            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n+                Ok(acc) => f(acc, v),\n+                Err(e) => {\n+                    self.peeked = Some(Some(v));\n+                    Try::from_error(e)\n+                }\n+            },\n+            None => self.iter.try_rfold(init, f),\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        match self.peeked {\n+            Some(None) => init,\n+            Some(Some(v)) => {\n+                let acc = self.iter.rfold(init, &mut fold);\n+                fold(acc, v)\n+            }\n+            None => self.iter.rfold(init, fold),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n+    /// But if the iteration is over, `None` is returned.\n+    ///\n+    /// [`next`]: Iterator::next\n+    ///\n+    /// Because `peek()` returns a reference, and many iterators iterate over\n+    /// references, there can be a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // The iterator does not advance even if we `peek` multiple times\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // After the iterator is finished, so is `peek()`\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        let iter = &mut self.iter;\n+        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n+    }\n+\n+    /// Consume and return the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume and return the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n+    where\n+        T: ?Sized,\n+        I::Item: PartialEq<T>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}"}, {"sha": "105ed40a3ed117cbf2adc6ef25173bf47d8591da", "filename": "library/core/src/iter/adapters/rev.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,137 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::ops::Try;\n+\n+/// A double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev`]: Iterator::rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    iter: T,\n+}\n+\n+impl<T> Rev<T> {\n+    pub(in crate::iter) fn new(iter: T) -> Rev<T> {\n+        Rev { iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next_back()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_back_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth_back(n)\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.iter.rfind(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, f)\n+    }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.iter.find(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}"}, {"sha": "0214899295e351c88ac10c498fa228394ed8a6c5", "filename": "library/core/src/iter/adapters/scan.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,111 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan`]: Iterator::scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    iter: I,\n+    f: F,\n+    state: St,\n+}\n+\n+impl<I, St, F> Scan<I, St, F> {\n+    pub(in crate::iter) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n+        Scan { iter, state, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F>\n+where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let a = self.iter.next()?;\n+        (self.f)(&mut self.state, a)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n+            state: &'a mut St,\n+            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| match f(state, x) {\n+                None => ControlFlow::Break(try { acc }),\n+                Some(x) => ControlFlow::from_try(fold(acc, x)),\n+            }\n+        }\n+\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n+where\n+    I: SourceIter<Source = S>,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n+    F: FnMut(&mut St, I::Item) -> Option<B>\n+{\n+}"}, {"sha": "dd5325660c3427a80de015f6ff7f6bbe60da0234", "filename": "library/core/src/iter/adapters/skip.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,199 @@\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip`]: Iterator::skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    iter: I,\n+    n: usize,\n+}\n+\n+impl<I> Skip<I> {\n+    pub(in crate::iter) fn new(iter: I, n: usize) -> Skip<I> {\n+        Skip { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n > 0 {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            self.iter.nth(to_skip - 1)?;\n+        }\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn count(mut self) -> usize {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return 0;\n+            }\n+        }\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            self.iter.nth(self.n - 1)?;\n+        }\n+        self.iter.last()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = match upper {\n+            Some(x) => Some(x.saturating_sub(self.n)),\n+            None => None,\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return try { init };\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n+impl<I> DoubleEndedIterator for Skip<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 { self.iter.next_back() } else { None }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        let len = self.len();\n+        if n < len {\n+            self.iter.nth_back(n)\n+        } else {\n+            if len > 0 {\n+                // consume the original iterator\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<T, Acc, R: Try<Ok = Acc>>(\n+            mut n: usize,\n+            mut fold: impl FnMut(Acc, T) -> R,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n+            move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n+            }\n+        }\n+\n+        let n = self.len();\n+        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n+    }\n+\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}"}, {"sha": "efcb469fc957725b9d8b787f73e545ef89c9a5ca", "filename": "library/core/src/iter/adapters/skip_while.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,126 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::Try;\n+\n+/// An iterator that rejects elements while `predicate` returns `true`.\n+///\n+/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while`]: Iterator::skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> SkipWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n+        SkipWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        fn check<'a, T>(\n+            flag: &'a mut bool,\n+            pred: &'a mut impl FnMut(&T) -> bool,\n+        ) -> impl FnMut(&T) -> bool + 'a {\n+            move |x| {\n+                if *flag || !pred(x) {\n+                    *flag = true;\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(check(flag, pred))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return try { init },\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for SkipWhile<I, P>\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}"}, {"sha": "2ba56eeccba1729a23adb0d28a2bce1d43979326", "filename": "library/core/src/iter/adapters/step_by.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,235 @@\n+use crate::{intrinsics, iter::from_fn, ops::Try};\n+\n+/// An iterator for stepping iterators by a custom amount.\n+///\n+/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n+/// its documentation for more.\n+///\n+/// [`step_by`]: Iterator::step_by\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+#[derive(Clone, Debug)]\n+pub struct StepBy<I> {\n+    iter: I,\n+    step: usize,\n+    first_take: bool,\n+}\n+\n+impl<I> StepBy<I> {\n+    pub(in crate::iter) fn new(iter: I, step: usize) -> StepBy<I> {\n+        assert!(step != 0);\n+        StepBy { iter, step: step - 1, first_take: true }\n+    }\n+}\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> Iterator for StepBy<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            self.iter.next()\n+        } else {\n+            self.iter.nth(self.step)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        #[inline]\n+        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n+        }\n+\n+        #[inline]\n+        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| n / (step + 1)\n+        }\n+\n+        let (low, high) = self.iter.size_hint();\n+\n+        if self.first_take {\n+            let f = first_size(self.step);\n+            (f(low), high.map(f))\n+        } else {\n+            let f = other_size(self.step);\n+            (f(low), high.map(f))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            let first = self.iter.next();\n+            if n == 0 {\n+                return first;\n+            }\n+            n -= 1;\n+        }\n+        // n and self.step are indices, we need to add 1 to get the amount of elements\n+        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n+        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n+        let mut step = self.step + 1;\n+        // n + 1 could overflow\n+        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n+        if n == usize::MAX {\n+            self.iter.nth(step - 1);\n+        } else {\n+            n += 1;\n+        }\n+\n+        // overflow handling\n+        loop {\n+            let mul = n.checked_mul(step);\n+            {\n+                if intrinsics::likely(mul.is_some()) {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n+            }\n+            let div_n = usize::MAX / n;\n+            let div_step = usize::MAX / step;\n+            let nth_n = div_n * n;\n+            let nth_step = div_step * step;\n+            let nth = if nth_n > nth_step {\n+                step -= div_n;\n+                nth_n\n+            } else {\n+                n -= div_step;\n+                nth_step\n+            };\n+            self.iter.nth(nth - 1);\n+        }\n+    }\n+\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return try { acc },\n+                Some(x) => acc = f(acc, x)?,\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n+    }\n+\n+    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return acc,\n+                Some(x) => acc = f(acc, x),\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n+    }\n+}\n+\n+impl<I> StepBy<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    // The zero-based index starting from the end of the iterator of the\n+    // last element. Used in the `DoubleEndedIterator` implementation.\n+    fn next_back_index(&self) -> usize {\n+        let rem = self.iter.len() % (self.step + 1);\n+        if self.first_take {\n+            if rem == 0 { self.step } else { rem - 1 }\n+        } else {\n+            rem\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for StepBy<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.nth_back(self.next_back_index())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n+        // is out of bounds because the length of `self.iter` does not exceed\n+        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n+        // zero-indexed\n+        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n+        self.iter.nth_back(n)\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => try { init },\n+            Some(x) => {\n+                let acc = f(init, x)?;\n+                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n+    where\n+        Self: Sized,\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => init,\n+            Some(x) => {\n+                let acc = f(init, x);\n+                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n+            }\n+        }\n+    }\n+}\n+\n+// StepBy can only make the iterator shorter, so the len will still fit.\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}"}, {"sha": "9efc7a480aeb4a4f7001ee4fdcc69a8fad060075", "filename": "library/core/src/iter/adapters/take.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,209 @@\n+use crate::cmp;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take`]: Iterator::take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    iter: I,\n+    n: usize,\n+}\n+\n+impl<I> Take<I> {\n+    pub(in crate::iter) fn new(iter: I, n: usize) -> Take<I> {\n+        Take { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.n == 0 {\n+            return (0, Some(0));\n+        }\n+\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n),\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            n: &'a mut usize,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n+            }\n+        }\n+\n+        if self.n == 0 {\n+            try { init }\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, check(n, fold)).into_try()\n+        }\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n+\n+#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Take<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.n == 0 {\n+            None\n+        } else {\n+            let n = self.n;\n+            self.n -= 1;\n+            self.iter.nth_back(self.iter.len().saturating_sub(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.iter.len();\n+        if self.n > n {\n+            let m = len.saturating_sub(self.n) + n;\n+            self.n -= n + 1;\n+            self.iter.nth_back(m)\n+        } else {\n+            if len > 0 {\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if self.n == 0 {\n+            try { init }\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                try { init }\n+            } else {\n+                self.iter.try_rfold(init, fold)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n == 0 {\n+            init\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                init\n+            } else {\n+                self.iter.rfold(init, fold)\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}"}, {"sha": "746eb41f4c38742ec23a7764cc3aead95c8f8e86", "filename": "library/core/src/iter/adapters/take_while.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,139 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that only accepts elements while `predicate` returns `true`.\n+///\n+/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while`]: Iterator::take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> TakeWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n+        TakeWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            let x = self.iter.next()?;\n+            if (self.predicate)(&x) {\n+                Some(x)\n+            } else {\n+                self.flag = true;\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.flag {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(&T) -> bool,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| {\n+                if p(&x) {\n+                    ControlFlow::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    ControlFlow::Break(try { acc })\n+                }\n+            }\n+        }\n+\n+        if self.flag {\n+            try { init }\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n+        }\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for TakeWhile<I, P>\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}"}, {"sha": "8cd4c775231926d54ba38bc8dd3965dfd4d097c5", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,10 +1,7 @@\n use crate::cmp;\n use crate::fmt::{self, Debug};\n-\n-use super::super::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, SourceIter,\n-    TrustedLen,\n-};\n+use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n+use crate::iter::{InPlaceIterable, SourceIter, TrustedLen};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n@@ -21,7 +18,7 @@ pub struct Zip<A, B> {\n     len: usize,\n }\n impl<A: Iterator, B: Iterator> Zip<A, B> {\n-    pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {\n+    pub(in crate::iter) fn new(a: A, b: B) -> Zip<A, B> {\n         ZipImpl::new(a, b)\n     }\n     fn super_nth(&mut self, mut n: usize) -> Option<(A::Item, B::Item)> {"}, {"sha": "072373c00f679740ef3972c54b15199d6ba05561", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -335,37 +335,34 @@ pub use self::sources::{successors, Successors};\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n pub use self::traits::FusedIterator;\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub use self::traits::InPlaceIterable;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{DoubleEndedIterator, Extend, FromIterator, IntoIterator};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{ExactSizeIterator, Product, Sum};\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-pub use self::traits::InPlaceIterable;\n+pub use self::traits::{\n+    DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator, IntoIterator, Product, Sum,\n+};\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::adapters::Cloned;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n-\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::adapters::MapWhile;\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+#[unstable(feature = \"inplace_iteration\", issue = \"none\")]\n pub use self::adapters::SourceIter;\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n pub use self::adapters::StepBy;\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n pub use self::adapters::TrustedRandomAccess;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Chain, Cycle, Enumerate, Filter, FilterMap, Map, Rev, Zip};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{FlatMap, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Fuse, Inspect};\n+pub use self::adapters::{\n+    Chain, Cycle, Enumerate, Filter, FilterMap, FlatMap, Fuse, Inspect, Map, Peekable, Rev, Scan,\n+    Skip, SkipWhile, Take, TakeWhile, Zip,\n+};\n \n pub(crate) use self::adapters::process_results;\n "}, {"sha": "de0663141e25274cb5e95d1039047e58297c60a7", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 16, "deletions": 614, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -1,625 +1,27 @@\n-use crate::fmt;\n-use crate::marker;\n+mod empty;\n+mod from_fn;\n+mod once;\n+mod once_with;\n+mod repeat;\n+mod repeat_with;\n+mod successors;\n \n-use super::{FusedIterator, TrustedLen};\n+pub use self::repeat::{repeat, Repeat};\n \n-/// An iterator that repeats an element endlessly.\n-///\n-/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Repeat<A> {\n-    element: A,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Iterator for Repeat<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        Some(self.element.clone())\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        Some(self.element.clone())\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A: Clone> FusedIterator for Repeat<A> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n-\n-/// Creates a new iterator that endlessly repeats a single element.\n-///\n-/// The `repeat()` function repeats a single value over and over again.\n-///\n-/// Infinite iterators like `repeat()` are often used with adapters like\n-/// [`Iterator::take()`], in order to make them finite.\n-///\n-/// If the element type of the iterator you need does not implement `Clone`,\n-/// or if you do not want to keep the repeated element in memory, you can\n-/// instead use the [`repeat_with()`] function.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // the number four 4ever:\n-/// let mut fours = iter::repeat(4);\n-///\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-///\n-/// // yup, still four\n-/// assert_eq!(Some(4), fours.next());\n-/// ```\n-///\n-/// Going finite with [`Iterator::take()`]:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // that last example was too many fours. Let's only have four fours.\n-/// let mut four_fours = iter::repeat(4).take(4);\n-///\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-///\n-/// // ... and now we're done\n-/// assert_eq!(None, four_fours.next());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat { element: elt }\n-}\n-\n-/// An iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure `F: FnMut() -> A`.\n-///\n-/// This `struct` is created by the [`repeat_with()`] function.\n-/// See its documentation for more.\n-#[derive(Copy, Clone, Debug)]\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub struct RepeatWith<F> {\n-    repeater: F,\n-}\n-\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        Some((self.repeater)())\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n-\n-/// Creates a new iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n-///\n-/// The `repeat_with()` function calls the repeater over and over again.\n-///\n-/// Infinite iterators like `repeat_with()` are often used with adapters like\n-/// [`Iterator::take()`], in order to make them finite.\n-///\n-/// If the element type of the iterator you need implements [`Clone`], and\n-/// it is OK to keep the source element in memory, you should instead use\n-/// the [`repeat()`] function.\n-///\n-/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n-/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n-/// please open a GitHub issue explaining your use case.\n-///\n-/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // let's assume we have some value of a type that is not `Clone`\n-/// // or which don't want to have in memory just yet because it is expensive:\n-/// #[derive(PartialEq, Debug)]\n-/// struct Expensive;\n-///\n-/// // a particular value forever:\n-/// let mut things = iter::repeat_with(|| Expensive);\n-///\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// ```\n-///\n-/// Using mutation and going finite:\n-///\n-/// ```rust\n-/// use std::iter;\n-///\n-/// // From the zeroth to the third power of two:\n-/// let mut curr = 1;\n-/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n-///                     .take(4);\n-///\n-/// assert_eq!(Some(1), pow2.next());\n-/// assert_eq!(Some(2), pow2.next());\n-/// assert_eq!(Some(4), pow2.next());\n-/// assert_eq!(Some(8), pow2.next());\n-///\n-/// // ... and now we're done\n-/// assert_eq!(None, pow2.next());\n-/// ```\n-#[inline]\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n-    RepeatWith { repeater }\n-}\n-\n-/// An iterator that yields nothing.\n-///\n-/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-pub struct Empty<T>(marker::PhantomData<T>);\n-\n-#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n-unsafe impl<T> Send for Empty<T> {}\n-#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n-unsafe impl<T> Sync for Empty<T> {}\n+pub use self::empty::{empty, Empty};\n \n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<T> fmt::Debug for Empty<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.pad(\"Empty\")\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Iterator for Empty<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(0))\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> DoubleEndedIterator for Empty<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        None\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> ExactSizeIterator for Empty<T> {\n-    fn len(&self) -> usize {\n-        0\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Empty<T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Empty<T> {}\n-\n-// not #[derive] because that adds a Clone bound on T,\n-// which isn't necessary.\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Clone for Empty<T> {\n-    fn clone(&self) -> Empty<T> {\n-        Empty(marker::PhantomData)\n-    }\n-}\n-\n-// not #[derive] because that adds a Default bound on T,\n-// which isn't necessary.\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Default for Empty<T> {\n-    fn default() -> Empty<T> {\n-        Empty(marker::PhantomData)\n-    }\n-}\n-\n-/// Creates an iterator that yields nothing.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // this could have been an iterator over i32, but alas, it's just not.\n-/// let mut nope = iter::empty::<i32>();\n-///\n-/// assert_eq!(None, nope.next());\n-/// ```\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-#[rustc_const_stable(feature = \"const_iter_empty\", since = \"1.32.0\")]\n-pub const fn empty<T>() -> Empty<T> {\n-    Empty(marker::PhantomData)\n-}\n-\n-/// An iterator that yields an element exactly once.\n-///\n-/// This `struct` is created by the [`once()`] function. See its documentation for more.\n-#[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub struct Once<T> {\n-    inner: crate::option::IntoIter<T>,\n-}\n+pub use self::once::{once, Once};\n \n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> Iterator for Once<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.inner.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> DoubleEndedIterator for Once<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> ExactSizeIterator for Once<T> {\n-    fn len(&self) -> usize {\n-        self.inner.len()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Once<T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Once<T> {}\n-\n-/// Creates an iterator that yields an element exactly once.\n-///\n-/// This is commonly used to adapt a single value into a [`chain()`] of other\n-/// kinds of iteration. Maybe you have an iterator that covers almost\n-/// everything, but you need an extra special case. Maybe you have a function\n-/// which works on iterators, but you only need to process one value.\n-///\n-/// [`chain()`]: Iterator::chain\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // one is the loneliest number\n-/// let mut one = iter::once(1);\n-///\n-/// assert_eq!(Some(1), one.next());\n-///\n-/// // just one, that's all we get\n-/// assert_eq!(None, one.next());\n-/// ```\n-///\n-/// Chaining together with another iterator. Let's say that we want to iterate\n-/// over each file of the `.foo` directory, but also a configuration file,\n-/// `.foorc`:\n-///\n-/// ```no_run\n-/// use std::iter;\n-/// use std::fs;\n-/// use std::path::PathBuf;\n-///\n-/// let dirs = fs::read_dir(\".foo\").unwrap();\n-///\n-/// // we need to convert from an iterator of DirEntry-s to an iterator of\n-/// // PathBufs, so we use map\n-/// let dirs = dirs.map(|file| file.unwrap().path());\n-///\n-/// // now, our iterator just for our config file\n-/// let config = iter::once(PathBuf::from(\".foorc\"));\n-///\n-/// // chain the two iterators together into one big iterator\n-/// let files = dirs.chain(config);\n-///\n-/// // this will give us all of the files in .foo as well as .foorc\n-/// for f in files {\n-///     println!(\"{:?}\", f);\n-/// }\n-/// ```\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub fn once<T>(value: T) -> Once<T> {\n-    Once { inner: Some(value).into_iter() }\n-}\n-\n-/// An iterator that yields a single element of type `A` by\n-/// applying the provided closure `F: FnOnce() -> A`.\n-///\n-/// This `struct` is created by the [`once_with()`] function.\n-/// See its documentation for more.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-pub struct OnceWith<F> {\n-    gen: Option<F>,\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let f = self.gen.take()?;\n-        Some(f())\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.gen.iter().size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n-    fn next_back(&mut self) -> Option<A> {\n-        self.next()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n-    fn len(&self) -> usize {\n-        self.gen.iter().len()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n-\n-/// Creates an iterator that lazily generates a value exactly once by invoking\n-/// the provided closure.\n-///\n-/// This is commonly used to adapt a single value generator into a [`chain()`] of\n-/// other kinds of iteration. Maybe you have an iterator that covers almost\n-/// everything, but you need an extra special case. Maybe you have a function\n-/// which works on iterators, but you only need to process one value.\n-///\n-/// Unlike [`once()`], this function will lazily generate the value on request.\n-///\n-/// [`chain()`]: Iterator::chain\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // one is the loneliest number\n-/// let mut one = iter::once_with(|| 1);\n-///\n-/// assert_eq!(Some(1), one.next());\n-///\n-/// // just one, that's all we get\n-/// assert_eq!(None, one.next());\n-/// ```\n-///\n-/// Chaining together with another iterator. Let's say that we want to iterate\n-/// over each file of the `.foo` directory, but also a configuration file,\n-/// `.foorc`:\n-///\n-/// ```no_run\n-/// use std::iter;\n-/// use std::fs;\n-/// use std::path::PathBuf;\n-///\n-/// let dirs = fs::read_dir(\".foo\").unwrap();\n-///\n-/// // we need to convert from an iterator of DirEntry-s to an iterator of\n-/// // PathBufs, so we use map\n-/// let dirs = dirs.map(|file| file.unwrap().path());\n-///\n-/// // now, our iterator just for our config file\n-/// let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n-///\n-/// // chain the two iterators together into one big iterator\n-/// let files = dirs.chain(config);\n-///\n-/// // this will give us all of the files in .foo as well as .foorc\n-/// for f in files {\n-///     println!(\"{:?}\", f);\n-/// }\n-/// ```\n-#[inline]\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n-    OnceWith { gen: Some(gen) }\n-}\n-\n-/// Creates a new iterator where each iteration calls the provided closure\n-/// `F: FnMut() -> Option<T>`.\n-///\n-/// This allows creating a custom iterator with any behavior\n-/// without using the more verbose syntax of creating a dedicated type\n-/// and implementing the [`Iterator`] trait for it.\n-///\n-/// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n-/// and therefore conservatively does not implement [`FusedIterator`],\n-/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n-///\n-/// The closure can use captures and its environment to track state across iterations. Depending on\n-/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n-///\n-/// [`move`]: ../../std/keyword.move.html\n-///\n-/// # Examples\n-///\n-/// Let\u2019s re-implement the counter iterator from the [module-level documentation]:\n-///\n-/// [module-level documentation]: super\n-///\n-/// ```\n-/// let mut count = 0;\n-/// let counter = std::iter::from_fn(move || {\n-///     // Increment our count. This is why we started at zero.\n-///     count += 1;\n-///\n-///     // Check to see if we've finished counting or not.\n-///     if count < 6 {\n-///         Some(count)\n-///     } else {\n-///         None\n-///     }\n-/// });\n-/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n-/// ```\n-#[inline]\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub fn from_fn<T, F>(f: F) -> FromFn<F>\n-where\n-    F: FnMut() -> Option<T>,\n-{\n-    FromFn(f)\n-}\n-\n-/// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n-///\n-/// This `struct` is created by the [`iter::from_fn()`] function.\n-/// See its documentation for more.\n-///\n-/// [`iter::from_fn()`]: from_fn\n-#[derive(Clone)]\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub struct FromFn<F>(F);\n-\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-impl<T, F> Iterator for FromFn<F>\n-where\n-    F: FnMut() -> Option<T>,\n-{\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        (self.0)()\n-    }\n-}\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub use self::repeat_with::{repeat_with, RepeatWith};\n \n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-impl<F> fmt::Debug for FromFn<F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FromFn\").finish()\n-    }\n-}\n+pub use self::from_fn::{from_fn, FromFn};\n \n-/// Creates a new iterator where each successive item is computed based on the preceding one.\n-///\n-/// The iterator starts with the given first item (if any)\n-/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n-///\n-/// ```\n-/// use std::iter::successors;\n-///\n-/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n-/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n-/// ```\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n-where\n-    F: FnMut(&T) -> Option<T>,\n-{\n-    // If this function returned `impl Iterator<Item=T>`\n-    // it could be based on `unfold` and not need a dedicated type.\n-    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n-    Successors { next: first, succ }\n-}\n+pub use self::successors::{successors, Successors};\n \n-/// An new iterator where each successive item is computed based on the preceding one.\n-///\n-/// This `struct` is created by the [`iter::successors()`] function.\n-/// See its documentation for more.\n-///\n-/// [`iter::successors()`]: successors\n-#[derive(Clone)]\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub struct Successors<T, F> {\n-    next: Option<T>,\n-    succ: F,\n-}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> Iterator for Successors<T, F>\n-where\n-    F: FnMut(&T) -> Option<T>,\n-{\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let item = self.next.take()?;\n-        self.next = (self.succ)(&item);\n-        Some(item)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n-    }\n-}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n-    }\n-}\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub use self::once_with::{once_with, OnceWith};"}, {"sha": "5d4a9fe8c6cc0dde45f7609b323fbe4b40ec5a6c", "filename": "library/core/src/iter/sources/empty.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,92 @@\n+use crate::fmt;\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::marker;\n+\n+/// Creates an iterator that yields nothing.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // this could have been an iterator over i32, but alas, it's just not.\n+/// let mut nope = iter::empty::<i32>();\n+///\n+/// assert_eq!(None, nope.next());\n+/// ```\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+#[rustc_const_stable(feature = \"const_iter_empty\", since = \"1.32.0\")]\n+pub const fn empty<T>() -> Empty<T> {\n+    Empty(marker::PhantomData)\n+}\n+\n+/// An iterator that yields nothing.\n+///\n+/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub struct Empty<T>(marker::PhantomData<T>);\n+\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Send for Empty<T> {}\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Sync for Empty<T> {}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T> fmt::Debug for Empty<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Empty\")\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Iterator for Empty<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Empty<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Empty<T> {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Empty<T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Empty<T> {}\n+\n+// not #[derive] because that adds a Clone bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Clone for Empty<T> {\n+    fn clone(&self) -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+// not #[derive] because that adds a Default bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Default for Empty<T> {\n+    fn default() -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}"}, {"sha": "3cd3830471cfe9e99900f29f952041f1271eb142", "filename": "library/core/src/iter/sources/from_fn.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,78 @@\n+use crate::fmt;\n+\n+/// Creates a new iterator where each iteration calls the provided closure\n+/// `F: FnMut() -> Option<T>`.\n+///\n+/// This allows creating a custom iterator with any behavior\n+/// without using the more verbose syntax of creating a dedicated type\n+/// and implementing the [`Iterator`] trait for it.\n+///\n+/// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n+/// and therefore conservatively does not implement [`FusedIterator`],\n+/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n+///\n+/// The closure can use captures and its environment to track state across iterations. Depending on\n+/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n+///\n+/// [`move`]: ../../std/keyword.move.html\n+/// [`FusedIterator`]: crate::iter::FusedIterator\n+///\n+/// # Examples\n+///\n+/// Let\u2019s re-implement the counter iterator from [module-level documentation]:\n+///\n+/// [module-level documentation]: crate::iter\n+///\n+/// ```\n+/// let mut count = 0;\n+/// let counter = std::iter::from_fn(move || {\n+///     // Increment our count. This is why we started at zero.\n+///     count += 1;\n+///\n+///     // Check to see if we've finished counting or not.\n+///     if count < 6 {\n+///         Some(count)\n+///     } else {\n+///         None\n+///     }\n+/// });\n+/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n+/// ```\n+#[inline]\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub fn from_fn<T, F>(f: F) -> FromFn<F>\n+where\n+    F: FnMut() -> Option<T>,\n+{\n+    FromFn(f)\n+}\n+\n+/// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n+///\n+/// This `struct` is created by the [`iter::from_fn()`] function.\n+/// See its documentation for more.\n+///\n+/// [`iter::from_fn()`]: from_fn\n+#[derive(Clone)]\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub struct FromFn<F>(F);\n+\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+impl<T, F> Iterator for FromFn<F>\n+where\n+    F: FnMut() -> Option<T>,\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        (self.0)()\n+    }\n+}\n+\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+impl<F> fmt::Debug for FromFn<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FromFn\").finish()\n+    }\n+}"}, {"sha": "27bc3dcfd79e092c40765099519d3aee6a242e0a", "filename": "library/core/src/iter/sources/once.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,99 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates an iterator that yields an element exactly once.\n+///\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n+/// kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// [`chain()`]: Iterator::chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once(1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once(PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub fn once<T>(value: T) -> Once<T> {\n+    Once { inner: Some(value).into_iter() }\n+}\n+\n+/// An iterator that yields an element exactly once.\n+///\n+/// This `struct` is created by the [`once()`] function. See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub struct Once<T> {\n+    inner: crate::option::IntoIter<T>,\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> Iterator for Once<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Once<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Once<T> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Once<T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Once<T> {}"}, {"sha": "cf6a3c115245295de66ae010f0c50b85c6501f13", "filename": "library/core/src/iter/sources/once_with.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,109 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates an iterator that lazily generates a value exactly once by invoking\n+/// the provided closure.\n+///\n+/// This is commonly used to adapt a single value generator into a [`chain()`] of\n+/// other kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// Unlike [`once()`], this function will lazily generate the value on request.\n+///\n+/// [`chain()`]: Iterator::chain\n+/// [`once()`]: crate::iter::once\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once_with(|| 1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[inline]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n+    OnceWith { gen: Some(gen) }\n+}\n+\n+/// An iterator that yields a single element of type `A` by\n+/// applying the provided closure `F: FnOnce() -> A`.\n+///\n+/// This `struct` is created by the [`once_with()`] function.\n+/// See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub struct OnceWith<F> {\n+    gen: Option<F>,\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let f = self.gen.take()?;\n+        Some(f())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.gen.iter().size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n+    fn next_back(&mut self) -> Option<A> {\n+        self.next()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n+    fn len(&self) -> usize {\n+        self.gen.iter().len()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}"}, {"sha": "d1f2879235f1a93412c2d66b7a9f31365822d002", "filename": "library/core/src/iter/sources/repeat.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,93 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates a new iterator that endlessly repeats a single element.\n+///\n+/// The `repeat()` function repeats a single value over and over again.\n+///\n+/// Infinite iterators like `repeat()` are often used with adapters like\n+/// [`Iterator::take()`], in order to make them finite.\n+///\n+/// If the element type of the iterator you need does not implement `Clone`,\n+/// or if you do not want to keep the repeated element in memory, you can\n+/// instead use the [`repeat_with()`] function.\n+///\n+/// [`repeat_with()`]: crate::iter::repeat_with\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // the number four 4ever:\n+/// let mut fours = iter::repeat(4);\n+///\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+///\n+/// // yup, still four\n+/// assert_eq!(Some(4), fours.next());\n+/// ```\n+///\n+/// Going finite with [`Iterator::take()`]:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // that last example was too many fours. Let's only have four fours.\n+/// let mut four_fours = iter::repeat(4).take(4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n+    Repeat { element: elt }\n+}\n+\n+/// An iterator that repeats an element endlessly.\n+///\n+/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Repeat<A> {\n+    element: A,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A: Clone> FusedIterator for Repeat<A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Clone> TrustedLen for Repeat<A> {}"}, {"sha": "44bc6890c55b5e8ae3505759a2fe6c357fe07d06", "filename": "library/core/src/iter/sources/repeat_with.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,98 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates a new iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n+///\n+/// The `repeat_with()` function calls the repeater over and over again.\n+///\n+/// Infinite iterators like `repeat_with()` are often used with adapters like\n+/// [`Iterator::take()`], in order to make them finite.\n+///\n+/// If the element type of the iterator you need implements [`Clone`], and\n+/// it is OK to keep the source element in memory, you should instead use\n+/// the [`repeat()`] function.\n+///\n+/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n+/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n+/// please open a GitHub issue explaining your use case.\n+///\n+/// [`repeat()`]: crate::iter::repeat\n+/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // let's assume we have some value of a type that is not `Clone`\n+/// // or which don't want to have in memory just yet because it is expensive:\n+/// #[derive(PartialEq, Debug)]\n+/// struct Expensive;\n+///\n+/// // a particular value forever:\n+/// let mut things = iter::repeat_with(|| Expensive);\n+///\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// ```\n+///\n+/// Using mutation and going finite:\n+///\n+/// ```rust\n+/// use std::iter;\n+///\n+/// // From the zeroth to the third power of two:\n+/// let mut curr = 1;\n+/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+///                     .take(4);\n+///\n+/// assert_eq!(Some(1), pow2.next());\n+/// assert_eq!(Some(2), pow2.next());\n+/// assert_eq!(Some(4), pow2.next());\n+/// assert_eq!(Some(8), pow2.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, pow2.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n+    RepeatWith { repeater }\n+}\n+\n+/// An iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure `F: FnMut() -> A`.\n+///\n+/// This `struct` is created by the [`repeat_with()`] function.\n+/// See its documentation for more.\n+#[derive(Copy, Clone, Debug)]\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub struct RepeatWith<F> {\n+    repeater: F,\n+}\n+\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        Some((self.repeater)())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}"}, {"sha": "99f058a901a3103f3c8e069a4cebd54d88ccf076", "filename": "library/core/src/iter/sources/successors.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,66 @@\n+use crate::{fmt, iter::FusedIterator};\n+\n+/// Creates a new iterator where each successive item is computed based on the preceding one.\n+///\n+/// The iterator starts with the given first item (if any)\n+/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n+///\n+/// ```\n+/// use std::iter::successors;\n+///\n+/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+/// ```\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n+where\n+    F: FnMut(&T) -> Option<T>,\n+{\n+    // If this function returned `impl Iterator<Item=T>`\n+    // it could be based on `unfold` and not need a dedicated type.\n+    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n+    Successors { next: first, succ }\n+}\n+\n+/// An new iterator where each successive item is computed based on the preceding one.\n+///\n+/// This `struct` is created by the [`iter::successors()`] function.\n+/// See its documentation for more.\n+///\n+/// [`iter::successors()`]: successors\n+#[derive(Clone)]\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+pub struct Successors<T, F> {\n+    next: Option<T>,\n+    succ: F,\n+}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T, F> Iterator for Successors<T, F>\n+where\n+    F: FnMut(&T) -> Option<T>,\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let item = self.next.take()?;\n+        self.next = (self.succ)(&item);\n+        Some(item)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n+    }\n+}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n+    }\n+}"}, {"sha": "29364d0ce9b89130650c8f2c788ddee8d19503c5", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -156,18 +156,18 @@ pub trait StructuralPartialEq {\n /// Required trait for constants used in pattern matches.\n ///\n /// Any type that derives `Eq` automatically implements this trait, *regardless*\n-/// of whether its type-parameters implement `Eq`.\n+/// of whether its type parameters implement `Eq`.\n ///\n-/// This is a hack to workaround a limitation in our type-system.\n+/// This is a hack to work around a limitation in our type system.\n ///\n-/// Background:\n+/// # Background\n ///\n /// We want to require that types of consts used in pattern matches\n /// have the attribute `#[derive(PartialEq, Eq)]`.\n ///\n /// In a more ideal world, we could check that requirement by just checking that\n-/// the given type implements both (1.) the `StructuralPartialEq` trait *and*\n-/// (2.) the `Eq` trait. However, you can have ADTs that *do* `derive(PartialEq, Eq)`,\n+/// the given type implements both the `StructuralPartialEq` trait *and*\n+/// the `Eq` trait. However, you can have ADTs that *do* `derive(PartialEq, Eq)`,\n /// and be a case that we want the compiler to accept, and yet the constant's\n /// type fails to implement `Eq`.\n ///\n@@ -176,8 +176,11 @@ pub trait StructuralPartialEq {\n /// ```rust\n /// #[derive(PartialEq, Eq)]\n /// struct Wrap<X>(X);\n+///\n /// fn higher_order(_: &()) { }\n+///\n /// const CFN: Wrap<fn(&())> = Wrap(higher_order);\n+///\n /// fn main() {\n ///     match CFN {\n ///         CFN => {}"}, {"sha": "33df175bfc54d628ff3db0f9fd1763bd5b4e92eb", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -441,6 +441,32 @@ impl f32 {\n         self.abs_private() < Self::INFINITY\n     }\n \n+    /// Returns `true` if the number is [subnormal].\n+    ///\n+    /// ```\n+    /// #![feature(is_subnormal)]\n+    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n+    /// let max = f32::MAX;\n+    /// let lower_than_min = 1.0e-40_f32;\n+    /// let zero = 0.0_f32;\n+    ///\n+    /// assert!(!min.is_subnormal());\n+    /// assert!(!max.is_subnormal());\n+    ///\n+    /// assert!(!zero.is_subnormal());\n+    /// assert!(!f32::NAN.is_subnormal());\n+    /// assert!(!f32::INFINITY.is_subnormal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(lower_than_min.is_subnormal());\n+    /// ```\n+    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n+    #[unstable(feature = \"is_subnormal\", issue = \"79288\")]\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    #[inline]\n+    pub const fn is_subnormal(self) -> bool {\n+        matches!(self.classify(), FpCategory::Subnormal)\n+    }\n+\n     /// Returns `true` if the number is neither zero, infinite,\n     /// [subnormal], or `NaN`.\n     ///"}, {"sha": "b85e8deb6d22c47606b95456a5698b0b37a1e751", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -440,6 +440,32 @@ impl f64 {\n         self.abs_private() < Self::INFINITY\n     }\n \n+    /// Returns `true` if the number is [subnormal].\n+    ///\n+    /// ```\n+    /// #![feature(is_subnormal)]\n+    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308_f64\n+    /// let max = f64::MAX;\n+    /// let lower_than_min = 1.0e-308_f64;\n+    /// let zero = 0.0_f64;\n+    ///\n+    /// assert!(!min.is_subnormal());\n+    /// assert!(!max.is_subnormal());\n+    ///\n+    /// assert!(!zero.is_subnormal());\n+    /// assert!(!f64::NAN.is_subnormal());\n+    /// assert!(!f64::INFINITY.is_subnormal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(lower_than_min.is_subnormal());\n+    /// ```\n+    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n+    #[unstable(feature = \"is_subnormal\", issue = \"79288\")]\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    #[inline]\n+    pub const fn is_subnormal(self) -> bool {\n+        matches!(self.classify(), FpCategory::Subnormal)\n+    }\n+\n     /// Returns `true` if the number is neither zero, infinite,\n     /// [subnormal], or `NaN`.\n     ///"}, {"sha": "3463b8cdf1cbf5a81282a9bc4f70677fcaf2bb88", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -227,7 +227,6 @@\n #![feature(asm)]\n #![feature(associated_type_bounds)]\n #![feature(atomic_mut_ptr)]\n-#![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]\n@@ -297,7 +296,6 @@\n #![feature(raw)]\n #![feature(raw_ref_macros)]\n #![feature(ready_macro)]\n-#![feature(refcell_take)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n #![feature(shrink_to)]"}, {"sha": "f4c07655bc4a534547ab2e24bd93b8ad0766ab22", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -23,7 +23,6 @@\n #![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n #![feature(rustc_private)]\n #![feature(nll)]\n-#![feature(bool_to_option)]\n #![feature(available_concurrency)]\n #![feature(internal_output_capture)]\n #![feature(panic_unwind)]"}, {"sha": "658adae193e1453ac5424cb3b02c716383039f25", "filename": "src/test/ui/expr/compound-assignment/eval-order.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/src%2Ftest%2Fui%2Fexpr%2Fcompound-assignment%2Feval-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/src%2Ftest%2Fui%2Fexpr%2Fcompound-assignment%2Feval-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fcompound-assignment%2Feval-order.rs?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -0,0 +1,76 @@\n+// Test evaluation order of operands of the compound assignment operators\n+\n+// run-pass\n+\n+use std::ops::AddAssign;\n+\n+enum Side {\n+    Lhs,\n+    Rhs,\n+}\n+\n+// In the following tests, we place our value into a wrapper type so that we\n+// can do an element access as the outer place expression. If we just had the\n+// block expression, it'd be a value expression and not compile.\n+struct Wrapper<T>(T);\n+\n+// Evaluation order for `a op= b` where typeof(a) and typeof(b) are primitives\n+// is first `b` then `a`.\n+fn primitive_compound() {\n+    let mut side_order = vec![];\n+    let mut int = Wrapper(0);\n+\n+    {\n+        side_order.push(Side::Lhs);\n+        int\n+    }.0 += {\n+        side_order.push(Side::Rhs);\n+        0\n+    };\n+\n+    assert!(matches!(side_order[..], [Side::Rhs, Side::Lhs]));\n+}\n+\n+// Evaluation order for `a op=b` otherwise is first `a` then `b`.\n+fn generic_compound<T: AddAssign<T> + Default>() {\n+    let mut side_order = vec![];\n+    let mut add_assignable: Wrapper<T> = Wrapper(Default::default());\n+\n+    {\n+        side_order.push(Side::Lhs);\n+        add_assignable\n+    }.0 += {\n+        side_order.push(Side::Rhs);\n+        Default::default()\n+    };\n+\n+    assert!(matches!(side_order[..], [Side::Lhs, Side::Rhs]));\n+}\n+\n+fn custom_compound() {\n+    struct Custom;\n+\n+    impl AddAssign<()> for Custom {\n+        fn add_assign(&mut self, _: ()) {\n+            // this block purposely left blank\n+        }\n+    }\n+\n+    let mut side_order = vec![];\n+    let mut custom = Wrapper(Custom);\n+\n+    {\n+        side_order.push(Side::Lhs);\n+        custom\n+    }.0 += {\n+        side_order.push(Side::Rhs);\n+    };\n+\n+    assert!(matches!(side_order[..], [Side::Lhs, Side::Rhs]));\n+}\n+\n+fn main() {\n+    primitive_compound();\n+    generic_compound::<i32>();\n+    custom_compound();\n+}"}, {"sha": "d371703e29587379387388a4358bccce21f255fb", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -13,11 +13,13 @@ error[E0599]: no method named `collect` found for struct `Cloned<TakeWhile<&mut\n LL |         .collect();\n    |          ^^^^^^^ method not found in `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 9:6]>>`\n    | \n-  ::: $SRC_DIR/core/src/iter/adapters/mod.rs:LL:COL\n+  ::: $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n    |\n LL | pub struct Cloned<I> {\n    | -------------------- doesn't satisfy `_: Iterator`\n-...\n+   | \n+  ::: $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n+   |\n LL | pub struct TakeWhile<I, P> {\n    | -------------------------- doesn't satisfy `<_ as Iterator>::Item = &_`\n    |"}, {"sha": "2efd37b4738a5130bafa0bd3d255e9116d55fa94", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32da90b431919eedb3e281a91caea063ba4edb77/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32da90b431919eedb3e281a91caea063ba4edb77/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=32da90b431919eedb3e281a91caea063ba4edb77", "patch": "@@ -15,7 +15,7 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n    |                                       doesn't satisfy `<_ as FnOnce<(&&str,)>>::Output = bool`\n    |                                       doesn't satisfy `_: FnMut<(&&str,)>`\n    | \n-  ::: $SRC_DIR/core/src/iter/adapters/mod.rs:LL:COL\n+  ::: $SRC_DIR/core/src/iter/adapters/filter.rs:LL:COL\n    |\n LL | pub struct Filter<I, P> {\n    | ----------------------- doesn't satisfy `_: Iterator`"}]}