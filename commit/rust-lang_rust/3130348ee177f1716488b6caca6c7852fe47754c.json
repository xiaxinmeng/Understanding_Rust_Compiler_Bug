{"sha": "3130348ee177f1716488b6caca6c7852fe47754c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMzAzNDhlZTE3N2YxNzE2NDg4YjZjYWNhNmM3ODUyZmU0Nzc1NGM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-03-24T19:12:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-01T18:27:32Z"}, "message": "Started adding support for typestate checking.\n\nI added a new field to the ast \"ann\" type for typestate information.\nCurrently, the field contains a record of a precondition bit vector and\npostcondition vector, but I tried to structure things so as to make\nit easy to change the representation of the typestate annotation type.\nI also had to add annotations to some syntactic forms that didn't have\nthem before (fail, ret, be...), with all the boilerplate changes\nthat that would imply.\n\nThe main call to the typestate_check entry point is commented out and\nthe actual pre-postcondition algorithm only has a few cases\nimplemented, though the overall AST traversal is there. The rest of\nthe typestate algorithm isn't implemented yet.", "tree": {"sha": "ee090db0203277e2adf4686fe26bbc3d3f024fbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee090db0203277e2adf4686fe26bbc3d3f024fbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3130348ee177f1716488b6caca6c7852fe47754c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3130348ee177f1716488b6caca6c7852fe47754c", "html_url": "https://github.com/rust-lang/rust/commit/3130348ee177f1716488b6caca6c7852fe47754c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3130348ee177f1716488b6caca6c7852fe47754c/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69a34b992bccf0c8db8d0d45b5bdddde66874885", "url": "https://api.github.com/repos/rust-lang/rust/commits/69a34b992bccf0c8db8d0d45b5bdddde66874885", "html_url": "https://github.com/rust-lang/rust/commit/69a34b992bccf0c8db8d0d45b5bdddde66874885"}], "stats": {"total": 1049, "additions": 814, "deletions": 235}, "files": [{"sha": "a1fdb387d7fe6d5ce7893c71b679130c892c7a05", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -8,6 +8,7 @@ import middle.trans;\n import middle.resolve;\n import middle.ty;\n import middle.typeck;\n+import middle.typestate_check;\n import util.common;\n \n import std.map.mk_hashmap;\n@@ -63,11 +64,11 @@ impure fn compile_input(session.session sess,\n     auto crate = parse_input(sess, p, input);\n     crate = creader.read_crates(sess, crate, library_search_paths);\n     crate = resolve.resolve_crate(sess, crate);\n-\n     auto typeck_result = typeck.check_crate(sess, crate);\n     crate = typeck_result._0;\n     auto type_cache = typeck_result._1;\n-\n+    // FIXME: uncomment once typestate_check works\n+    // crate = typestate_check.check_crate(crate);\n     trans.trans_crate(sess, crate, type_cache, output, shared);\n }\n "}, {"sha": "46666a34378160f07cda1d2fc7195d4722b0a504", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -6,6 +6,7 @@ import util.common.span;\n import util.common.spanned;\n import util.common.ty_mach;\n import util.common.filename;\n+import util.typestate_ann.ts_ann;\n \n type ident = str;\n \n@@ -21,7 +22,9 @@ type ty_param = rec(ident ident, def_id id);\n // Annotations added during successive passes.\n tag ann {\n     ann_none;\n-    ann_type(@middle.ty.t, option.t[vec[@middle.ty.t]] /* ty param substs */);\n+    ann_type(@middle.ty.t,\n+             option.t[vec[@middle.ty.t]], /* ty param substs */\n+             option.t[@ts_ann]); /* pre- and postcondition for typestate */\n }\n \n tag def {\n@@ -274,14 +277,14 @@ tag expr_ {\n     expr_index(@expr, @expr, ann);\n     expr_path(path, option.t[def], ann);\n     expr_ext(path, vec[@expr], option.t[@expr], @expr, ann);\n-    expr_fail;\n-    expr_break;\n-    expr_cont;\n-    expr_ret(option.t[@expr]);\n-    expr_put(option.t[@expr]);\n-    expr_be(@expr);\n-    expr_log(@expr);\n-    expr_check_expr(@expr);\n+    expr_fail(ann);\n+    expr_break(ann);\n+    expr_cont(ann);\n+    expr_ret(option.t[@expr], ann);\n+    expr_put(option.t[@expr], ann);\n+    expr_be(@expr, ann);\n+    expr_log(@expr, ann);\n+    expr_check_expr(@expr, ann);\n     expr_port(ann);\n     expr_chan(@expr, ann);\n }"}, {"sha": "5a9c2b11dc0c606780519316ae61aae3a7dc28d6", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -419,7 +419,7 @@ impure fn scan_number(mutable char c, reader rdr) -> token.token {\n     if (is_dec_integer) {\n         accum_int = digits_to_string(dec_str);\n     }\n-\n+        \n     c = rdr.curr();\n     n = rdr.next();\n "}, {"sha": "4c3e6cf03bed09e888080fe0bd231a9354e68b05", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -794,14 +794,14 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.FAIL) {\n             p.bump();\n-            ex = ast.expr_fail;\n+            ex = ast.expr_fail(ast.ann_none);\n         }\n \n         case (token.LOG) {\n             p.bump();\n             auto e = parse_expr(p);\n             auto hi = e.span;\n-            ex = ast.expr_log(e);\n+            ex = ast.expr_log(e, ast.ann_none);\n         }\n \n         case (token.CHECK) {\n@@ -810,7 +810,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                 case (token.LPAREN) {\n                     auto e = parse_expr(p);\n                     auto hi = e.span;\n-                    ex = ast.expr_check_expr(e);\n+                    ex = ast.expr_check_expr(e, ast.ann_none);\n                 }\n                 case (_) {\n                     p.get_session().unimpl(\"constraint-check stmt\");\n@@ -822,36 +822,36 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n             p.bump();\n             alt (p.peek()) {\n                 case (token.SEMI) {\n-                    ex = ast.expr_ret(none[@ast.expr]);\n+                    ex = ast.expr_ret(none[@ast.expr], ast.ann_none);\n                 }\n                 case (_) {\n                     auto e = parse_expr(p);\n                     hi = e.span;\n-                    ex = ast.expr_ret(some[@ast.expr](e));\n+                    ex = ast.expr_ret(some[@ast.expr](e), ast.ann_none);\n                 }\n             }\n         }\n \n         case (token.BREAK) {\n             p.bump();\n-            ex = ast.expr_break;\n+            ex = ast.expr_break(ast.ann_none);\n         }\n \n         case (token.CONT) {\n             p.bump();\n-            ex = ast.expr_cont;\n+            ex = ast.expr_cont(ast.ann_none);\n         }\n \n         case (token.PUT) {\n             p.bump();\n             alt (p.peek()) {\n                 case (token.SEMI) {\n-                    ex = ast.expr_put(none[@ast.expr]);\n+                    ex = ast.expr_put(none[@ast.expr], ast.ann_none);\n                 }\n                 case (_) {\n                     auto e = parse_expr(p);\n                     hi = e.span;\n-                    ex = ast.expr_put(some[@ast.expr](e));\n+                    ex = ast.expr_put(some[@ast.expr](e), ast.ann_none);\n                 }\n             }\n         }\n@@ -862,7 +862,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n             // FIXME: Is this the right place for this check?\n             if /*check*/ (ast.is_call_expr(e)) {\n                     hi = e.span;\n-                    ex = ast.expr_be(e);\n+                    ex = ast.expr_be(e, ast.ann_none);\n             }\n             else {\n                 p.err(\"Non-call expression in tail call\");\n@@ -1651,14 +1651,14 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_field(_,_,_))    { ret true; }\n                 case (ast.expr_index(_,_,_))    { ret true; }\n                 case (ast.expr_path(_,_,_))     { ret true; }\n-                case (ast.expr_fail)            { ret true; }\n-                case (ast.expr_break)           { ret true; }\n-                case (ast.expr_cont)            { ret true; }\n-                case (ast.expr_ret(_))          { ret true; }\n-                case (ast.expr_put(_))          { ret true; }\n-                case (ast.expr_be(_))           { ret true; }\n-                case (ast.expr_log(_))          { ret true; }\n-                case (ast.expr_check_expr(_))   { ret true; }\n+                case (ast.expr_fail(_))         { ret true; }\n+                case (ast.expr_break(_))        { ret true; }\n+                case (ast.expr_cont(_))         { ret true; }\n+                case (ast.expr_ret(_,_))        { ret true; }\n+                case (ast.expr_put(_,_))        { ret true; }\n+                case (ast.expr_be(_,_))         { ret true; }\n+                case (ast.expr_log(_,_))        { ret true; }\n+                case (ast.expr_check_expr(_,_)) { ret true; }\n             }\n         }\n         // We should not be calling this on a cdir."}, {"sha": "d7a18783cbb00c21907c60d02a6227ace79887f5", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -178,26 +178,26 @@ type ast_fold[ENV] =\n          @expr expanded,\n          ann a) -> @expr)                         fold_expr_ext,\n \n-     (fn(&ENV e, &span sp) -> @expr)              fold_expr_fail,\n+     (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_fail,\n \n-     (fn(&ENV e, &span sp) -> @expr)              fold_expr_break,\n+     (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_break,\n \n-     (fn(&ENV e, &span sp) -> @expr)              fold_expr_cont,\n+     (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_cont,\n \n      (fn(&ENV e, &span sp,\n-         &option.t[@expr] rv) -> @expr)           fold_expr_ret,\n+         &option.t[@expr] rv, ann a) -> @expr)    fold_expr_ret,\n \n      (fn(&ENV e, &span sp,\n-         &option.t[@expr] rv) -> @expr)           fold_expr_put,\n+         &option.t[@expr] rv, ann a) -> @expr)    fold_expr_put,\n \n      (fn(&ENV e, &span sp,\n-         @expr e) -> @expr)                       fold_expr_be,\n+         @expr e, ann a) -> @expr)                fold_expr_be,\n \n      (fn(&ENV e, &span sp,\n-         @expr e) -> @expr)                       fold_expr_log,\n+         @expr e, ann a) -> @expr)                fold_expr_log,\n \n      (fn(&ENV e, &span sp,\n-         @expr e) -> @expr)                       fold_expr_check_expr,\n+         @expr e, ann a) -> @expr)                fold_expr_check_expr,\n \n      (fn(&ENV e, &span sp,\n          ann a) -> @expr)                         fold_expr_port,\n@@ -717,53 +717,53 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n                                   exp, t);\n         }\n \n-        case (ast.expr_fail) {\n-            ret fld.fold_expr_fail(env_, e.span);\n+        case (ast.expr_fail(?t)) {\n+            ret fld.fold_expr_fail(env_, e.span, t);\n         }\n \n-        case (ast.expr_break) {\n-            ret fld.fold_expr_break(env_, e.span);\n+        case (ast.expr_break(?t)) {\n+            ret fld.fold_expr_break(env_, e.span, t);\n         }\n \n-        case (ast.expr_cont) {\n-            ret fld.fold_expr_cont(env_, e.span);\n+        case (ast.expr_cont(?t)) {\n+            ret fld.fold_expr_cont(env_, e.span, t);\n         }\n \n-        case (ast.expr_ret(?oe)) {\n+        case (ast.expr_ret(?oe, ?t)) {\n             auto oee = none[@expr];\n             alt (oe) {\n                 case (some[@expr](?x)) {\n                     oee = some(fold_expr(env_, fld, x));\n                 }\n                 case (_) { /* fall through */  }\n             }\n-            ret fld.fold_expr_ret(env_, e.span, oee);\n+            ret fld.fold_expr_ret(env_, e.span, oee, t);\n         }\n \n-        case (ast.expr_put(?oe)) {\n+        case (ast.expr_put(?oe, ?t)) {\n             auto oee = none[@expr];\n             alt (oe) {\n                 case (some[@expr](?x)) {\n                     oee = some(fold_expr(env_, fld, x));\n                 }\n                 case (_) { /* fall through */  }\n             }\n-            ret fld.fold_expr_put(env_, e.span, oee);\n+            ret fld.fold_expr_put(env_, e.span, oee, t);\n         }\n \n-        case (ast.expr_be(?x)) {\n+        case (ast.expr_be(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n-            ret fld.fold_expr_be(env_, e.span, ee);\n+            ret fld.fold_expr_be(env_, e.span, ee, t);\n         }\n \n-        case (ast.expr_log(?x)) {\n+        case (ast.expr_log(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n-            ret fld.fold_expr_log(env_, e.span, ee);\n+            ret fld.fold_expr_log(env_, e.span, ee, t);\n         }\n \n-        case (ast.expr_check_expr(?x)) {\n+        case (ast.expr_check_expr(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n-            ret fld.fold_expr_check_expr(env_, e.span, ee);\n+            ret fld.fold_expr_check_expr(env_, e.span, ee, t);\n         }\n \n         case (ast.expr_port(?t)) {\n@@ -1308,38 +1308,40 @@ fn identity_fold_expr_ext[ENV](&ENV env, &span sp,\n     ret @respan(sp, ast.expr_ext(p, args, body, expanded, a));\n }\n \n-fn identity_fold_expr_fail[ENV](&ENV env, &span sp) -> @expr {\n-    ret @respan(sp, ast.expr_fail);\n+fn identity_fold_expr_fail[ENV](&ENV env, &span sp, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_fail(a));\n }\n \n-fn identity_fold_expr_break[ENV](&ENV env, &span sp) -> @expr {\n-    ret @respan(sp, ast.expr_break);\n+fn identity_fold_expr_break[ENV](&ENV env, &span sp, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_break(a));\n }\n \n-fn identity_fold_expr_cont[ENV](&ENV env, &span sp) -> @expr {\n-    ret @respan(sp, ast.expr_cont);\n+fn identity_fold_expr_cont[ENV](&ENV env, &span sp, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_cont(a));\n }\n \n fn identity_fold_expr_ret[ENV](&ENV env, &span sp,\n-                               &option.t[@expr] rv) -> @expr {\n-    ret @respan(sp, ast.expr_ret(rv));\n+                               &option.t[@expr] rv, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_ret(rv, a));\n }\n \n fn identity_fold_expr_put[ENV](&ENV env, &span sp,\n-                               &option.t[@expr] rv) -> @expr {\n-    ret @respan(sp, ast.expr_put(rv));\n+                               &option.t[@expr] rv, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_put(rv, a));\n }\n \n-fn identity_fold_expr_be[ENV](&ENV env, &span sp, @expr x) -> @expr {\n-    ret @respan(sp, ast.expr_be(x));\n+fn identity_fold_expr_be[ENV](&ENV env, &span sp, @expr x, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_be(x, a));\n }\n \n-fn identity_fold_expr_log[ENV](&ENV e, &span sp, @expr x) -> @expr {\n-    ret @respan(sp, ast.expr_log(x));\n+fn identity_fold_expr_log[ENV](&ENV e, &span sp, @expr x,\n+                               ann a) -> @expr {\n+    ret @respan(sp, ast.expr_log(x, a));\n }\n \n-fn identity_fold_expr_check_expr[ENV](&ENV e, &span sp, @expr x) -> @expr {\n-    ret @respan(sp, ast.expr_check_expr(x));\n+fn identity_fold_expr_check_expr[ENV](&ENV e, &span sp, @expr x, ann a)\n+    -> @expr {\n+    ret @respan(sp, ast.expr_check_expr(x, a));\n }\n \n fn identity_fold_expr_port[ENV](&ENV e, &span sp, ann a) -> @expr {\n@@ -1621,15 +1623,15 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n          fold_expr_path   = bind identity_fold_expr_path[ENV](_,_,_,_,_),\n          fold_expr_ext    = bind identity_fold_expr_ext[ENV](_,_,_,_,_,_,_),\n-         fold_expr_fail   = bind identity_fold_expr_fail[ENV](_,_),\n-         fold_expr_break  = bind identity_fold_expr_break[ENV](_,_),\n-         fold_expr_cont   = bind identity_fold_expr_cont[ENV](_,_),\n-         fold_expr_ret    = bind identity_fold_expr_ret[ENV](_,_,_),\n-         fold_expr_put    = bind identity_fold_expr_put[ENV](_,_,_),\n-         fold_expr_be     = bind identity_fold_expr_be[ENV](_,_,_),\n-         fold_expr_log    = bind identity_fold_expr_log[ENV](_,_,_),\n+         fold_expr_fail   = bind identity_fold_expr_fail[ENV](_,_,_),\n+         fold_expr_break  = bind identity_fold_expr_break[ENV](_,_,_),\n+         fold_expr_cont   = bind identity_fold_expr_cont[ENV](_,_,_),\n+         fold_expr_ret    = bind identity_fold_expr_ret[ENV](_,_,_,_),\n+         fold_expr_put    = bind identity_fold_expr_put[ENV](_,_,_,_),\n+         fold_expr_be     = bind identity_fold_expr_be[ENV](_,_,_,_),\n+         fold_expr_log    = bind identity_fold_expr_log[ENV](_,_,_,_),\n          fold_expr_check_expr\n-                          = bind identity_fold_expr_check_expr[ENV](_,_,_),\n+         = bind identity_fold_expr_check_expr[ENV](_,_,_,_),\n          fold_expr_port   = bind identity_fold_expr_port[ENV](_,_,_),\n          fold_expr_chan   = bind identity_fold_expr_chan[ENV](_,_,_,_),\n "}, {"sha": "eb848f768c87b93a173349ba7957d2db7fbdd016", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -2497,7 +2497,7 @@ fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n         case (ast.ann_none) {\n             cx.sess.bug(\"missing type annotation\");\n         }\n-        case (ast.ann_type(?t, _)) {\n+        case (ast.ann_type(?t, _, _)) {\n             ret target_type(cx, t);\n         }\n     }\n@@ -2509,7 +2509,7 @@ fn node_ann_ty_params(&ast.ann a) -> vec[@ty.t] {\n             log \"missing type annotation\";\n             fail;\n         }\n-        case (ast.ann_type(_, ?tps_opt)) {\n+        case (ast.ann_type(_, ?tps_opt, _)) {\n             alt (tps_opt) {\n                 case (none[vec[@ty.t]]) {\n                     log \"type annotation has no ty params\";\n@@ -3638,7 +3638,7 @@ fn lval_generic_fn(@block_ctxt cx,\n             cx.fcx.ccx.sess.bug(\"no type annotation for path!\");\n             fail;\n         }\n-        case (ast.ann_type(?monoty_, ?tps)) {\n+        case (ast.ann_type(?monoty_, ?tps, _)) {\n             monoty = monoty_;\n             tys = option.get[vec[@ty.t]](tps);\n         }\n@@ -4775,35 +4775,35 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_expr(cx, expanded);\n         }\n \n-        case (ast.expr_fail) {\n+        case (ast.expr_fail(_)) {\n             ret trans_fail(cx, e.span, \"explicit failure\");\n         }\n \n-        case (ast.expr_log(?a)) {\n+        case (ast.expr_log(?a, _)) {\n             ret trans_log(cx, a);\n         }\n \n-        case (ast.expr_check_expr(?a)) {\n+        case (ast.expr_check_expr(?a, _)) {\n             ret trans_check_expr(cx, a);\n         }\n \n-        case (ast.expr_break) {\n+        case (ast.expr_break(?a)) {\n             ret trans_break(cx);\n         }\n \n-        case (ast.expr_cont) {\n+        case (ast.expr_cont(?a)) {\n             ret trans_cont(cx);\n         }\n \n-        case (ast.expr_ret(?e)) {\n+        case (ast.expr_ret(?e, _)) {\n             ret trans_ret(cx, e);\n         }\n \n-        case (ast.expr_put(?e)) {\n+        case (ast.expr_put(?e, _)) {\n             ret trans_put(cx, e);\n         }\n \n-        case (ast.expr_be(?e)) {\n+        case (ast.expr_be(?e, _)) {\n             ret trans_be(cx, e);\n         }\n \n@@ -4855,6 +4855,7 @@ fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n \n     auto sub = trans_expr(cx, e);\n     auto e_ty = ty.expr_ty(e);\n+\n     if (ty.type_is_fp(e_ty)) {\n         let TypeRef tr;\n         let bool is32bit = false;"}, {"sha": "d0b5fe102cc0b4e87f3597db5060e9fd5db0c06b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -593,7 +593,7 @@ fn ann_to_type(&ast.ann ann) -> @t {\n             log \"ann_to_type() called on node with no type\";\n             fail;\n         }\n-        case (ast.ann_type(?ty, _)) {\n+        case (ast.ann_type(?ty, _, _)) {\n             ret ty;\n         }\n     }\n@@ -785,12 +785,12 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_send(_, _, ?ann))      { ret ann_to_type(ann); }\n         case (ast.expr_recv(_, _, ?ann))      { ret ann_to_type(ann); }\n \n-        case (ast.expr_fail)                  { ret plain_ty(ty_nil); }\n-        case (ast.expr_log(_))                { ret plain_ty(ty_nil); }\n-        case (ast.expr_check_expr(_))         { ret plain_ty(ty_nil); }\n-        case (ast.expr_ret(_))                { ret plain_ty(ty_nil); }\n-        case (ast.expr_put(_))                { ret plain_ty(ty_nil); }\n-        case (ast.expr_be(_))                 { ret plain_ty(ty_nil); }\n+        case (ast.expr_fail(_))               { ret plain_ty(ty_nil); }\n+        case (ast.expr_log(_,_))              { ret plain_ty(ty_nil); }\n+        case (ast.expr_check_expr(_,_))       { ret plain_ty(ty_nil); }\n+        case (ast.expr_ret(_,_))              { ret plain_ty(ty_nil); }\n+        case (ast.expr_put(_,_))              { ret plain_ty(ty_nil); }\n+        case (ast.expr_be(_,_))               { ret plain_ty(ty_nil); }\n     }\n     fail;\n }"}, {"sha": "f726ae588c9c8e114ccc4bc5e3dc27c445eb7ed3", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 120, "deletions": 131, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -1,5 +1,6 @@\n import front.ast;\n import front.ast.ann;\n+import front.ast.ann_none;\n import front.ast.mutability;\n import front.creader;\n import middle.fold;\n@@ -32,6 +33,8 @@ import std.option;\n import std.option.none;\n import std.option.some;\n \n+import util.typestate_ann.ts_ann;\n+\n type ty_table = hashmap[ast.def_id, @ty.t];\n \n tag any_item {\n@@ -54,6 +57,11 @@ type fn_ctxt = rec(@ty.t ret_ty,\n // Used for ast_ty_to_ty() below.\n type ty_getter = fn(ast.def_id) -> ty.ty_params_opt_and_ty;\n \n+// Turns a type into an ann_type, using defaults for other fields.\n+fn triv_ann(@ty.t t) -> ann {\n+    ret ast.ann_type(t, none[vec[@ty.t]], none[@ts_ann]);\n+}\n+\n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     state obj ty_generalizer(@crate_ctxt cx,\n@@ -227,7 +235,7 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_params_opt_and_ty tpt,\n         }\n     }\n \n-    ret ast.ann_type(t, ty_substs_opt);\n+    ret ast.ann_type(t, ty_substs_opt, none[@ts_ann]);\n }\n \n // Returns the type parameters and polytype of an item, if it's an item that\n@@ -674,9 +682,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n             auto tpt = tup(params_opt, result_ty);\n             type_cache.insert(variant.node.id, tpt);\n-\n-            auto variant_t = rec(\n-                ann=ast.ann_type(result_ty, none[vec[@ty.t]])\n+            auto variant_t = rec(ann=triv_ann(result_ty)\n                 with variant.node\n             );\n             result += vec(fold.respan[ast.variant_](variant.span, variant_t));\n@@ -767,8 +773,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                        ast.def_id id, ast.ann a) -> @ast.item {\n         check (e.type_cache.contains_key(id));\n         auto typ = e.type_cache.get(id)._1;\n-        auto item = ast.item_const(i, t, ex, id,\n-                                   ast.ann_type(typ, none[vec[@ty.t]]));\n+        auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -777,8 +782,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     ast.def_id id, ast.ann a) -> @ast.item {\n         check (e.type_cache.contains_key(id));\n         auto typ = e.type_cache.get(id)._1;\n-        auto item = ast.item_fn(i, f, ty_params, id,\n-                                ast.ann_type(typ, none[vec[@ty.t]]));\n+        auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -788,7 +792,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         check (e.type_cache.contains_key(id));\n         auto typ = e.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n-                                       ast.ann_type(typ, none[vec[@ty.t]]));\n+                                       triv_ann(typ));\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n@@ -832,8 +836,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.proto,\n                                               meth_ty.inputs,\n                                               meth_ty.output));\n-            m_ = rec(\n-                ann=ast.ann_type(meth_tfn, none[vec[@ty.t]])\n+            m_ = rec(ann=triv_ann(meth_tfn)\n                 with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n@@ -842,8 +845,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto g = bind getter(e.sess, e.id_to_ty_item, e.type_cache, _);\n         for (ast.obj_field fld in ob.fields) {\n             let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n-            let ast.obj_field f = rec(\n-                ann=ast.ann_type(fty, none[vec[@ty.t]])\n+            let ast.obj_field f = rec(ann=triv_ann(fty)\n                 with fld\n             );\n             _vec.push[ast.obj_field](fields, f);\n@@ -852,8 +854,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto ob_ = rec(methods = methods,\n                        fields = fields\n                        with ob);\n-        auto item = ast.item_obj(i, ob_, ty_params, odid,\n-                                 ast.ann_type(t, none[vec[@ty.t]]));\n+        auto item = ast.item_obj(i, ob_, ty_params, odid, triv_ann(t));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -862,8 +863,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     ast.def_id id, ast.ann a) -> @ast.item {\n         check (e.type_cache.contains_key(id));\n         auto typ = e.type_cache.get(id)._1;\n-        auto item = ast.item_ty(i, t, ty_params, id,\n-                                ast.ann_type(typ, none[vec[@ty.t]]));\n+        auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -879,7 +879,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                                                 ty_params);\n         auto typ = e.type_cache.get(id)._1;\n         auto item = ast.item_tag(i, variants_t, ty_params, id,\n-                                 ast.ann_type(typ, none[vec[@ty.t]]));\n+                                 ast.ann_type(typ, none[vec[@ty.t]],\n+                                              none[@ts_ann]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -1034,16 +1035,20 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n     alt (pat.node) {\n         case (ast.pat_wild(?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]]));\n+            p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]],\n+                                            none[@ts_ann]));\n         }\n         case (ast.pat_lit(?lit, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]]));\n+            p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]],\n+                                                none[@ts_ann]));\n         }\n         case (ast.pat_bind(?id, ?did, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n             fcx.locals.insert(did, t);\n-            p_1 = ast.pat_bind(id, did, ast.ann_type(t, none[vec[@ty.t]]));\n+            p_1 = ast.pat_bind(id, did, ast.ann_type(t,\n+                                                     none[vec[@ty.t]],\n+                                                     none[@ts_ann]));\n         }\n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n@@ -1086,7 +1091,8 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n                     // Nullary tag variant.\n                     check (subpats_len == 0u);\n                     p_1 = ast.pat_tag(id, subpats, vdef_opt,\n-                                      ast.ann_type(t, tps_opt));\n+                                      ast.ann_type(t, tps_opt,\n+                                                   none[@ts_ann]));\n                 }\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n                     // N-ary tag variant.\n@@ -1101,7 +1107,8 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n                         i += 1u;\n                     }\n                     p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n-                                      ast.ann_type(tag_ty, tps_opt));\n+                                      ast.ann_type(tag_ty, tps_opt,\n+                                                   none[@ts_ann]));\n                 }\n             }\n         }\n@@ -1142,7 +1149,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_vec(es_1, mut, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_vec(es_1, mut, triv_ann(t));\n         }\n         case (ast.expr_tup(?es_0, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n@@ -1161,7 +1168,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_tup(elts_1, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_tup(elts_1, triv_ann(t));\n         }\n         case (ast.expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1214,48 +1221,42 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_rec(fields_1, base_1,\n-                               ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_rec(fields_1, base_1, triv_ann(t));\n         }\n         case (ast.expr_bind(?sube, ?es, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_bind(sube, es, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_bind(sube, es, triv_ann(t));\n         }\n         case (ast.expr_call(?sube, ?es, ?ann)) {\n             // NB: we call 'demand_full' and pass in adk only in cases where\n             // e is an expression that could *possibly* produce a box; things\n             // like expr_binary or expr_bind can't, so there's no need.\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_call(sube, es, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_call(sube, es, triv_ann(t));\n         }\n         case (ast.expr_call_self(?sube, ?es, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_call_self(sube, \n-                                     es, \n-                                     ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_call_self(sube, es, triv_ann(t));\n         }\n         case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_binary(bop, lhs, rhs,\n-                                  ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_binary(bop, lhs, rhs, triv_ann(t));\n         }\n         case (ast.expr_unary(?uop, ?sube, ?ann)) {\n             // See note in expr_unary for why we're calling demand_full.\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_unary(uop, sube,\n-                                 ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_unary(uop, sube, triv_ann(t));\n         }\n         case (ast.expr_lit(?lit, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_lit(lit, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_lit(lit, triv_ann(t));\n         }\n         case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_cast(sube, ast_ty,\n-                                ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_cast(sube, ast_ty, triv_ann(t));\n         }\n         case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n@@ -1270,60 +1271,52 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     else_1 = some[@ast.expr](e_1);\n                 }\n             }\n-            e_1 = ast.expr_if(cond, then_1, else_1,\n-                              ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_if(cond, then_1, else_1, triv_ann(t));\n         }\n         case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for(decl, seq, bloc,\n-                               ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_for(decl, seq, bloc, triv_ann(t));\n         }\n         case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for_each(decl, seq, bloc,\n-                                    ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_for_each(decl, seq, bloc, triv_ann(t));\n         }\n         case (ast.expr_while(?cond, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_while(cond, bloc,\n-                                 ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_while(cond, bloc, triv_ann(t));\n         }\n         case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_do_while(bloc, cond,\n-                                    ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_do_while(bloc, cond, triv_ann(t));\n         }\n         case (ast.expr_block(?bloc, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_block(bloc, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_block(bloc, triv_ann(t));\n         }\n         case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign(lhs_1, rhs_1,\n-                                  ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_assign(lhs_1, rhs_1, triv_ann(t));\n         }\n         case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1,\n-                                     ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, triv_ann(t));\n         }\n         case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_field(lhs, rhs, triv_ann(t));\n         }\n         case (ast.expr_index(?base, ?index, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_index(base, index,\n-                                 ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_index(base, index, triv_ann(t));\n         }\n         case (ast.expr_path(?pth, ?d, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n@@ -1338,7 +1331,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                         \"did you pass it to check_expr() first?\";\n                     fail;\n                 }\n-                case (ast.ann_type(_, ?tps_opt)) {\n+                case (ast.ann_type(_, ?tps_opt, _)) {\n                     alt (tps_opt) {\n                         case (none[vec[@ty.t]]) {\n                             auto defn = option.get[ast.def](d);\n@@ -1359,26 +1352,28 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                 }\n             }\n \n-            e_1 = ast.expr_path(pth, d, ast.ann_type(t, ty_params_opt));\n+            e_1 = ast.expr_path(pth, d,\n+                                ast.ann_type(t, ty_params_opt,\n+                                             none[@ts_ann]));\n         }\n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_ext(p, args, body, expanded,\n-                               ast.ann_type(t, none[vec[@ty.t]]));\n-        }\n-        case (ast.expr_fail) { e_1 = e.node; }\n-        case (ast.expr_log(_)) { e_1 = e.node; }\n-        case (ast.expr_break) { e_1 = e.node; }\n-        case (ast.expr_cont) { e_1 = e.node; }\n-        case (ast.expr_ret(_)) { e_1 = e.node; }\n-        case (ast.expr_put(_)) { e_1 = e.node; }\n-        case (ast.expr_be(_)) { e_1 = e.node; }\n-        case (ast.expr_check_expr(_)) { e_1 = e.node; }\n+            e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n+        }\n+        /* FIXME: this should probably check the type annotations */\n+        case (ast.expr_fail(_))  { e_1 = e.node; } \n+        case (ast.expr_log(_,_)) { e_1 = e.node; } \n+        case (ast.expr_break(_)) { e_1 = e.node; }\n+        case (ast.expr_cont(_))  { e_1 = e.node; }\n+        case (ast.expr_ret(_,_)) { e_1 = e.node; }\n+        case (ast.expr_put(_,_)) { e_1 = e.node; }\n+        case (ast.expr_be(_,_))  { e_1 = e.node; }\n+        case (ast.expr_check_expr(_,_)) { e_1 = e.node; }\n \n         case (ast.expr_port(?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_port(ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_port(triv_ann(t));\n         }\n \n         case (ast.expr_chan(?es, ?ann)) {\n@@ -1394,7 +1389,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_chan(es_1, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_chan(es_1, triv_ann(t));\n         }\n \n         case (ast.expr_alt(?discrim, ?arms_0, ?ann)) {\n@@ -1407,8 +1402,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                                  index=arm_0.index);\n                 arms_1 += vec(arm_1);\n             }\n-            e_1 = ast.expr_alt(discrim, arms_1,\n-                               ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_alt(discrim, arms_1, triv_ann(t));\n         }\n \n         case (_) {\n@@ -1449,8 +1443,7 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n                               + local.ident);\n     }\n     auto local_ty = fcx.locals.get(local.id);\n-    auto local_wb = @rec(\n-        ann=ast.ann_type(local_ty, none[vec[@ty.t]])\n+    auto local_wb = @rec(ann=triv_ann(local_ty)\n         with *local\n     );\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n@@ -1502,15 +1495,13 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {\n-            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx.ccx),\n-                                                none[vec[@ty.t]]));\n+            new_pat = ast.pat_wild(triv_ann(next_ty_var(fcx.ccx)));\n         }\n         case (ast.pat_lit(?lt, _)) {\n-            new_pat = ast.pat_lit(lt, ast.ann_type(check_lit(lt),\n-                                                   none[vec[@ty.t]]));\n+            new_pat = ast.pat_lit(lt, triv_ann(check_lit(lt)));\n         }\n         case (ast.pat_bind(?id, ?def_id, _)) {\n-            auto ann = ast.ann_type(next_ty_var(fcx.ccx), none[vec[@ty.t]]);\n+            auto ann = triv_ann(next_ty_var(fcx.ccx));\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n@@ -1670,7 +1661,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n         auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n \n-        auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n+        auto ann = triv_ann(rhs_t0);\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1698,7 +1689,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n             auto typ = check_lit(lit);\n-            auto ann = ast.ann_type(typ, none[vec[@ty.t]]);\n+            auto ann = triv_ann(typ);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_lit(lit, ann));\n         }\n \n@@ -1726,7 +1717,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (_) { /* fall through */ }\n             }\n \n-            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n+            auto ann = triv_ann(t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_binary(binop, lhs_1, rhs_1,\n                                                         ann));\n@@ -1757,7 +1748,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (_) { oper_t = strip_boxes(oper_t); }\n             }\n \n-            auto ann = ast.ann_type(oper_t, none[vec[@ty.t]]);\n+            auto ann = triv_ann(oper_t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_unary(unop, oper_1, ann));\n         }\n@@ -1775,25 +1766,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(exp_);\n-            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n+            auto ann = triv_ann(t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_ext(p, args, body, exp_,\n                                                      ann));\n         }\n \n-        case (ast.expr_fail) {\n+        case (ast.expr_fail(_)) { // ??? ignoring ann\n             ret expr;\n         }\n \n-        case (ast.expr_break) {\n+        case (ast.expr_break(_)) {\n             ret expr;\n         }\n \n-        case (ast.expr_cont) {\n+        case (ast.expr_cont(_)) {\n             ret expr;\n         }\n \n-        case (ast.expr_ret(?expr_opt)) {\n+        case (ast.expr_ret(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n                     auto nil = plain_ty(ty.ty_nil);\n@@ -1808,13 +1799,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n-                    ret @fold.respan[ast.expr_](expr.span,\n-                                                ast.expr_ret(some(expr_1)));\n+                    ret @fold.respan[ast.expr_]\n+                        (expr.span, ast.expr_ret(some(expr_1), ann_none));\n                 }\n             }\n         }\n \n-        case (ast.expr_put(?expr_opt)) {\n+        case (ast.expr_put(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n                     auto nil = plain_ty(ty.ty_nil);\n@@ -1829,31 +1820,32 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n-                    ret @fold.respan[ast.expr_](expr.span,\n-                                                ast.expr_put(some(expr_1)));\n+                    ret @fold.respan[ast.expr_]\n+                        (expr.span, ast.expr_put(some(expr_1), ann_none));\n                 }\n             }\n         }\n \n-        case (ast.expr_be(?e)) {\n+        case (ast.expr_be(?e, _)) {\n             /* FIXME: prove instead of check */\n             check (ast.is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_be(expr_1));\n+                                        ast.expr_be(expr_1, ann_none));\n         }\n \n-        case (ast.expr_log(?e)) {\n+        case (ast.expr_log(?e,_)) {\n             auto expr_t = check_expr(fcx, e);\n-            ret @fold.respan[ast.expr_](expr.span, ast.expr_log(expr_t));\n+            ret @fold.respan[ast.expr_]\n+                (expr.span, ast.expr_log(expr_t, ann_none));\n         }\n \n-        case (ast.expr_check_expr(?e)) {\n+        case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n             demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_check_expr(expr_t));\n+            ret @fold.respan[ast.expr_]\n+                (expr.span, ast.expr_check_expr(expr_t, ann_none));\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n@@ -1891,7 +1883,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n             auto rhs_1 = demand_expr(fcx, item_t, rhs_0);\n \n-            auto ann = ast.ann_type(chan_t, none[vec[@ty.t]]);\n+            auto ann = triv_ann(chan_t);\n             auto newexpr = ast.expr_send(lhs_1, rhs_1, ann);\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n@@ -1914,7 +1906,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n             auto lhs_1 = demand_expr(fcx, item_t, lhs_0);\n \n-            auto ann = ast.ann_type(item_t, none[vec[@ty.t]]);\n+            auto ann = triv_ann(item_t);\n             auto newexpr = ast.expr_recv(lhs_1, rhs_1, ann);\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n@@ -1943,7 +1935,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto thn_1 = demand_block(fcx, elsopt_t, thn_0);\n \n-            auto ann = ast.ann_type(elsopt_t, none[vec[@ty.t]]);\n+            auto ann = triv_ann(elsopt_t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_if(cond_1, thn_1,\n                                                     elsopt_1, ann));\n@@ -1957,7 +1949,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n+            auto ann = triv_ann(plain_ty(ty.ty_nil));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -1968,7 +1960,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n+            auto ann = triv_ann(plain_ty(ty.ty_nil));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n@@ -1979,7 +1971,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n+            auto ann = triv_ann(plain_ty(ty.ty_nil));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n@@ -1989,7 +1981,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(block_ty(body_1), none[vec[@ty.t]]);\n+            auto ann = triv_ann(block_ty(body_1));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -2039,7 +2031,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto expr_1 = demand_expr(fcx, pattern_ty, expr_0);\n \n-            auto ann = ast.ann_type(result_ty, none[vec[@ty.t]]);\n+            auto ann = triv_ann(result_ty);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_alt(expr_1, arms_1, ann));\n         }\n@@ -2049,10 +2041,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast.expr](?expr)) {\n-                    ann = ast.ann_type(expr_ty(expr), none[vec[@ty.t]]);\n+                    ann = triv_ann(expr_ty(expr));\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n+                    ann = triv_ann(plain_ty(ty.ty_nil));\n                 }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -2092,7 +2084,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n \n             auto t_1 = plain_ty(ty.ty_fn(proto_1, arg_tys_1, rt_1));\n-            auto ann = ast.ann_type(t_1, none[vec[@ty.t]]);\n+            auto ann = triv_ann(t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n                                                       ann));\n@@ -2114,7 +2106,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n-            auto ann = ast.ann_type(rt_1, none[vec[@ty.t]]);\n+            auto ann = triv_ann(rt_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_call(f_1, args_1, ann));\n         }\n@@ -2143,7 +2135,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_task), none[vec[@ty.t]]);\n+            auto ann = triv_ann(plain_ty(ty.ty_task));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_spawn(dom, name,\n                                                        f_1, args_1, ann));\n@@ -2162,7 +2154,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                       +  ty_to_str(t_1));\n             }\n \n-            auto ann = ast.ann_type(t_1, none[vec[@ty.t]]);\n+            auto ann = triv_ann(t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_cast(e_1, t, ann));\n         }\n@@ -2186,7 +2178,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n \n             auto vec_sty = ty.ty_vec(rec(ty=t, mut=mut));\n-            auto ann = ast.ann_type(plain_ty(vec_sty), none[vec[@ty.t]]);\n+            auto ann = triv_ann(plain_ty(vec_sty));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, mut, ann));\n         }\n@@ -2202,8 +2194,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_mt)),\n-                                    none[vec[@ty.t]]);\n+            auto ann = triv_ann(plain_ty(ty.ty_tup(elts_mt)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n@@ -2234,8 +2225,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = ast.ann_type(plain_ty(ty.ty_rec(fields_t)),\n-                                       none[vec[@ty.t]]);\n+                    ann = triv_ann(plain_ty(ty.ty_rec(fields_t)));\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n@@ -2255,7 +2245,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         }\n                     }\n \n-                    ann = ast.ann_type(bexpr_t, none[vec[@ty.t]]);\n+                    ann = triv_ann(bexpr_t);\n \n                     for (ty.field f in fields_t) {\n                         auto found = false;\n@@ -2290,7 +2280,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = ast.ann_type(args.(ix).ty, none[vec[@ty.t]]);\n+                    auto ann = triv_ann(args.(ix).ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2304,8 +2294,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = ast.ann_type(fields.(ix).mt.ty,\n-                                            none[vec[@ty.t]]);\n+                    auto ann = triv_ann(fields.(ix).mt.ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2322,7 +2311,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     auto meth = methods.(ix);\n                     auto t = plain_ty(ty.ty_fn(meth.proto,\n                                                meth.inputs, meth.output));\n-                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n+                    auto ann = triv_ann(t);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2352,7 +2341,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto ann = ast.ann_type(mt.ty, none[vec[@ty.t]]);\n+                    auto ann = triv_ann(mt.ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2366,7 +2355,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              + ty_to_str(idx_t));\n                     }\n                     auto t = ty.ty_machine(common.ty_u8);\n-                    auto ann = ast.ann_type(plain_ty(t), none[vec[@ty.t]]);\n+                    auto ann = triv_ann(plain_ty(t));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2384,7 +2373,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_port(_)) {\n             auto t = next_ty_var(fcx.ccx);\n             auto pt = plain_ty(ty.ty_port(t));\n-            auto ann = ast.ann_type(pt, none[vec[@ty.t]]);\n+            auto ann = triv_ann(pt);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_port(ann));\n         }\n \n@@ -2394,7 +2383,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             alt (port_t.struct) {\n                 case (ty.ty_port(?subtype)) {\n                     auto ct = plain_ty(ty.ty_chan(subtype));\n-                    auto ann = ast.ann_type(ct, none[vec[@ty.t]]);\n+                    auto ann = triv_ann(ct);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_chan(expr_1, ann));\n                 }\n@@ -2573,7 +2562,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n     auto fn_sty = ty.ty_fn(f.proto, inputs, output_ty);\n-    auto fn_ann = ast.ann_type(plain_ty(fn_sty), none[vec[@ty.t]]);\n+    auto fn_ann = triv_ann(plain_ty(fn_sty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);"}, {"sha": "9b670fc1ea0b5e235b8ae6b3615b96af63b67713", "filename": "src/comp/middle/typestate_check.rs", "status": "added", "additions": 496, "deletions": 0, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -0,0 +1,496 @@\n+import front.ast;\n+import front.ast.ann;\n+import front.ast.ty;\n+import front.ast.mutability;\n+import front.ast.item;\n+import front.ast.block;\n+import front.ast.block_;\n+import front.ast.block_index_entry;\n+import front.ast.decl;\n+import front.ast.stmt;\n+import front.ast.stmt_;\n+import front.ast.stmt_decl;\n+import front.ast.stmt_expr;\n+import front.ast.decl_local;\n+import front.ast.decl_item;\n+import front.ast.ident;\n+import front.ast.def_id;\n+import front.ast.ann;\n+import front.ast.init;\n+import front.ast.expr;\n+import front.ast.expr_call;\n+import front.ast.expr_path;\n+import front.ast.expr_log;\n+import front.ast.path;\n+import front.ast.crate_directive;\n+import front.ast.fn_decl;\n+import front.ast._obj;\n+import front.ast.native_mod;\n+import front.ast.variant;\n+import front.ast.ty_param;\n+import front.ast.ty;\n+import front.ast.proto;\n+import front.ast.pat;\n+import front.ast.binop;\n+import front.ast.unop;\n+import front.ast.def;\n+import front.ast.lit;\n+import front.ast.init_op;\n+import front.ast.initializer;\n+import front.ast.local;\n+import front.ast._fn;\n+import front.ast.ann_none;\n+import front.ast.ann_type;\n+import front.ast._obj;\n+import front.ast._mod;\n+\n+import middle.fold;\n+import middle.fold.respan;\n+import driver.session;\n+import util.common;\n+import util.common.span;\n+import util.common.spanned;\n+import util.common.new_str_hash;\n+import util.typestate_ann;\n+import util.typestate_ann.ts_ann;\n+import util.typestate_ann.empty_pre_post;\n+import util.typestate_ann.true_precond;\n+import util.typestate_ann.true_postcond;\n+import util.typestate_ann.postcond;\n+import util.typestate_ann.precond;\n+import util.typestate_ann.pre_and_post;\n+import util.typestate_ann.get_pre;\n+import util.typestate_ann.get_post;\n+\n+import middle.ty;\n+import middle.ty.ann_to_type;\n+import middle.ty.arg;\n+import middle.ty.block_ty;\n+import middle.ty.expr_ty;\n+import middle.ty.ty_to_str;\n+\n+import pretty.pprust.print_block;\n+import pretty.pprust.print_expr;\n+import pretty.pp.mkstate;\n+import std.io.stdout;\n+import std.io.str_writer;\n+import std.io.string_writer;\n+import std._vec.map;\n+import std._vec;\n+import std._vec.len;\n+import std._vec.pop;\n+import std._vec.push;\n+import std._vec.slice;\n+import std.option;\n+import std.option.t;\n+import std.option.some;\n+import std.option.none;\n+import std.map.hashmap;\n+import std.list;\n+import std.list.list;\n+import std.list.cons;\n+import std.list.nil;\n+import std.list.foldl;\n+import std.list.find;\n+\n+import util.typestate_ann;\n+import util.typestate_ann.difference;\n+import util.typestate_ann.union;\n+import util.typestate_ann.pps_len;\n+import util.typestate_ann.require_and_preserve;\n+\n+/**********************************************************************/\n+/* mapping from variable name to bit number */\n+type fn_info = std.map.hashmap[ident, uint];\n+\n+fn bit_num(ident v, fn_info m) -> uint {\n+  ret m.get(v);\n+}\n+fn num_locals(fn_info m) -> uint {\n+  ret m.size();\n+}\n+\n+fn mk_fn_info(_fn f) -> fn_info {\n+  ret new_str_hash[uint](); /* FIXME: actually implement this */\n+}\n+/**********************************************************************/\n+fn expr_ann(&expr e) -> ann {\n+  alt(e.node) {\n+    case (ast.expr_vec(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_tup(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_rec(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_call(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_bind(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_binary(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_unary(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_lit(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_cast(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_if(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_while(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_for(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_for_each(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_do_while(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_alt(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_block(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_assign(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_assign_op(_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_send(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_recv(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_field(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_index(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_path(_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_ext(_,_,_,_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_fail(?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_ret(_,?a)) {\n+      ret a; \n+    }\n+    case (ast.expr_put(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_be(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_log(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_check_expr(_,?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_port(?a)) {\n+      ret a;\n+    }\n+    case (ast.expr_chan(_,?a)) {\n+      ret a;\n+    }\n+  }\n+}\n+\n+fn expr_pp(&@expr e) -> pre_and_post {\n+  alt (expr_ann(*e)) {\n+    case (ann_none) {\n+      log \"expr_pp: the impossible happened (no annotation)\";\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          log \"expr_pp: the impossible happened (no pre/post)\";\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret *p;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+fn expr_precond(&expr e) -> precond {\n+  ret (expr_pp(@e)).precondition;\n+}\n+\n+fn expr_postcond(&@expr e) -> postcond {\n+  ret (expr_pp(e)).postcondition;\n+}\n+\n+fn with_pp(ann a, @pre_and_post p) -> ann {\n+  alt (a) {\n+    case (ann_none) {\n+      log(\"with_pp: the impossible happened\");\n+      fail; /* shouldn't happen b/c code is typechecked */\n+    }\n+    case (ann_type(?t, ?ps, _)) {\n+      ret (ann_type(t, ps, some[@ts_ann](p)));\n+    }\n+  }\n+}\n+\n+// Given a list of pres and posts for exprs e0 ... en,\n+// return the precondition for evaluating each expr in order.\n+// So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n+// precondition shouldn't include x.\n+fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n+  let uint sz = len[pre_and_post](pps);\n+  \n+  if (sz == 0u) {\n+    ret true_precond(num_vars);\n+  }\n+  else {\n+    auto first   = pps.(0);\n+    check (pps_len(first) == num_vars);\n+    let precond rest = seq_preconds(num_vars,\n+                         slice[pre_and_post](pps, 1u, sz));\n+    difference(rest, first.postcondition);\n+    union(first.precondition, rest);\n+    ret (first.precondition);\n+  }\n+}\n+\n+fn union_postconds_go(postcond first, &vec[postcond] rest) -> postcond {\n+  auto other = rest.(0);\n+  union(first, other);\n+  union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n+  ret first;\n+}\n+\n+fn union_postconds(&vec[postcond] pcs) -> postcond {\n+  check (len[postcond](pcs) > 0u);\n+\n+  be union_postconds_go(pcs.(0), pcs);\n+}\n+\n+fn print_ident(&ident i) -> () {\n+  log(\" \" + i + \" \");\n+}\n+\n+fn print_idents(vec[ident] idents) -> () {\n+  if(len[ident](idents) == 0u) {\n+    ret;\n+  }\n+  else {\n+    log(\"an ident: \" + pop[ident](idents));\n+    print_idents(idents);\n+  }\n+}\n+\n+fn find_pre_post_mod(&_mod m) -> _mod {\n+  ret m; /* FIXME */\n+}\n+\n+fn find_pre_post_native_mod(&native_mod m) -> native_mod {\n+  ret m; /* FIXME */\n+}\n+ \n+fn find_pre_post_obj(_obj o) -> _obj {\n+  ret o; /* FIXME */\n+}\n+\n+impure fn find_pre_post_item(fn_info enclosing, &item i) -> item {\n+  alt (i.node) {\n+    case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n+      auto e_pp = find_pre_post_expr(enclosing, *e);\n+      ret (respan(i.span,\n+                   ast.item_const(id, t, e_pp, di,\n+                              with_pp(a, @expr_pp(e_pp)))));\n+    }\n+    case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n+      auto f_pp = find_pre_post_fn(f);\n+      ret (respan(i.span, \n+                   ast.item_fn(id, f_pp, ps, di, a)));\n+    }\n+    case (ast.item_mod(?id, ?m, ?di)) {\n+      auto m_pp = find_pre_post_mod(m);\n+      ret (respan(i.span,\n+                   ast.item_mod(id, m_pp, di)));\n+    }\n+    case (ast.item_native_mod(?id, ?nm, ?di)) {\n+      auto n_pp = find_pre_post_native_mod(nm);\n+      ret (respan(i.span,\n+                   ast.item_native_mod(id, n_pp, di)));\n+    }\n+    case (ast.item_ty(_,_,_,_,_)) {\n+      ret i;\n+    }\n+    case (ast.item_tag(_,_,_,_)) {\n+      ret i;\n+    }\n+    case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n+      auto o_pp = find_pre_post_obj(o);\n+      ret (respan(i.span,\n+                   ast.item_obj(id, o_pp, ps, di, a)));\n+    }\n+  }\n+}\n+\n+impure fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n+  auto num_local_vars = num_locals(enclosing);\n+\n+  fn do_rand_(fn_info enclosing, &@expr e) -> @expr {\n+    be find_pre_post_expr(enclosing, *e);\n+  }\n+\n+  auto do_rand = bind do_rand_(enclosing,_);\n+\n+  alt(e.node) {\n+    case(expr_call(?oper, ?rands, ?a)) {\n+      auto pp_oper = find_pre_post_expr(enclosing, *oper);\n+      \n+      auto f = do_rand;\n+      auto pp_rands = _vec.map[@expr, @expr](f, rands);\n+      \n+      auto g = expr_pp;\n+      auto pps = _vec.map[@expr, pre_and_post]      \n+        (g, pp_rands);\n+      _vec.push[pre_and_post](pps, expr_pp(pp_oper));\n+      auto h = get_post;\n+      auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n+      auto res_postcond = union_postconds(res_postconds);\n+      let @pre_and_post pp =\n+        @rec(precondition=seq_preconds(num_local_vars, pps),\n+             postcondition=res_postcond);\n+      let ann a_res = with_pp(a, pp);\n+      ret (@respan(e.span,\n+                   expr_call(pp_oper, pp_rands, a_res)));\n+                        \n+    }\n+    case(expr_path(?p, ?maybe_def, ?a)) {\n+      check (len[ident](p.node.idents) > 0u);\n+      auto referent = p.node.idents.(0);\n+      auto i = bit_num(referent, enclosing);\n+      auto res = empty_pre_post(num_local_vars);\n+      require_and_preserve(i, *res);\n+      ret (@respan\n+           (e.span,\n+            expr_path(p, maybe_def,\n+                      with_pp(a, res))));\n+    }\n+    case(expr_log(?e, ?a)) {\n+      auto e_pp = find_pre_post_expr(enclosing, *e);\n+      ret (@respan(e.span,\n+                   expr_log(e_pp, with_pp(a, @expr_pp(e_pp)))));\n+    }\n+    case(_) {\n+      log(\"this sort of expr isn't implemented!\");\n+      fail;\n+    }\n+  }\n+}\n+\n+impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n+  -> ast.stmt {\n+  auto num_local_vars = num_locals(enclosing);\n+\n+  alt(s.node) {\n+    case(ast.stmt_decl(?adecl)) {\n+      alt(adecl.node) {\n+        case(ast.decl_local(?alocal)) {\n+          alt(alocal.init) {\n+            case(some[ast.initializer](?an_init)) {\n+              let @expr r = find_pre_post_expr(enclosing, *an_init.expr);\n+              let init_op o = an_init.op;\n+              let initializer a_i = rec(op=o, expr=r);\n+              let ann res_ann = with_pp(alocal.ann, @expr_pp(r));\n+              let @local res_local =\n+                @rec(ty=alocal.ty, infer=alocal.infer,\n+                     ident=alocal.ident, init=some[initializer](a_i),\n+                     id=alocal.id, ann=res_ann);\n+              let stmt_ res = stmt_decl(@respan(adecl.span,\n+                                                decl_local(res_local)));\n+              ret (respan(s.span, res));\n+            }\n+            case(none[ast.initializer]) {\n+              // log(\"pre/post for init of \" + alocal.ident + \": none\");\n+              let ann res_ann = with_pp(alocal.ann,\n+                                        empty_pre_post(num_local_vars));\n+              let @local res_local =\n+                @rec(ty=alocal.ty, infer=alocal.infer,\n+                     ident=alocal.ident, init=none[initializer],\n+                     id=alocal.id, ann=res_ann);\n+              let stmt_ res =\n+                stmt_decl\n+                (@respan(adecl.span, decl_local(res_local)));\n+              ret (respan (s.span, res));\n+            }\n+          }\n+        }\n+        case(decl_item(?anitem)) {\n+          auto res_item = find_pre_post_item(enclosing, *anitem);\n+          ret (respan(s.span, stmt_decl(@respan(adecl.span,\n+                                               decl_item(@res_item))))); \n+        }\n+      }\n+    }\n+    case(stmt_expr(?e)) {\n+      let @expr e_pp = find_pre_post_expr(enclosing, *e);\n+      ret (respan(s.span, stmt_expr(e_pp)));\n+    }    \n+  }\n+}\n+\n+fn find_pre_post_block(fn_info enclosing, block b) -> block {\n+  fn do_one_(fn_info i, &@stmt s) -> @stmt {\n+    ret (@find_pre_post_for_each_stmt(i, *s));\n+  }\n+  auto do_one = bind do_one_(enclosing, _);\n+ \n+  auto ss = _vec.map[@stmt, @stmt](do_one, b.node.stmts);\n+  fn do_inner_(fn_info i, &@expr e) -> @expr {\n+    ret find_pre_post_expr(i, *e);\n+  }\n+  auto do_inner = bind do_inner_(enclosing, _);\n+  let option.t[@expr] e_ = option.map[@expr, @expr](do_inner, b.node.expr);\n+  let block_ b_res = rec(stmts=ss, expr=e_, index=b.node.index);\n+  ret respan(b.span, b_res);\n+}\n+\n+fn find_pre_post_fn(&_fn f) -> _fn {\n+  let fn_info fi = mk_fn_info(f);\n+  ret rec(decl=f.decl, proto=f.proto,\n+          body=find_pre_post_block(fi, f.body));\n+}\n+\n+fn check_item_fn(&@() ignore, &span sp, ident i, &ast._fn f,\n+                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+\n+  auto res_f = find_pre_post_fn(f);  \n+\n+  ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n+}\n+\n+fn check_crate(@ast.crate crate) -> @ast.crate {\n+  auto fld = fold.new_identity_fold[@()]();\n+\n+  fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n+\n+  ret fold.fold_crate[@()](@(), fld, crate);\n+}"}, {"sha": "b0d6fb94187fe5093b125b1deb76d004702cecec", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -611,16 +611,16 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n         case (ast.expr_path(?path,_,_)) {\n             print_path(s, path);\n         }\n-        case (ast.expr_fail) {\n+        case (ast.expr_fail(_)) {\n             wrd(s.s, \"fail\");\n         }\n-        case (ast.expr_break) {\n+        case (ast.expr_break(_)) {\n             wrd(s.s, \"break\");\n         }\n-        case (ast.expr_cont) {\n+        case (ast.expr_cont(_)) {\n             wrd(s.s, \"cont\");\n         }\n-        case (ast.expr_ret(?result)) {\n+        case (ast.expr_ret(?result,_)) {\n             wrd(s.s, \"ret\");\n             alt (result) {\n                 case (option.some[@ast.expr](?expr)) {\n@@ -630,7 +630,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n                 case (_) {}\n             }\n         }\n-        case (ast.expr_put(?result)) {\n+        case (ast.expr_put(?result,_)) {\n             wrd(s.s, \"put\");\n             alt (result) {\n                 case (option.some[@ast.expr](?expr)) {\n@@ -640,15 +640,15 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n                 case (_) {}\n             }\n         }\n-        case (ast.expr_be(?result)) {\n+        case (ast.expr_be(?result,_)) {\n             wrd1(s, \"be\");\n             print_expr(s, result);\n         }\n-        case (ast.expr_log(?expr)) {\n+        case (ast.expr_log(?expr,_)) {\n             wrd1(s, \"log\");\n             print_expr(s, expr);\n         }\n-        case (ast.expr_check_expr(?expr)) {\n+        case (ast.expr_check_expr(?expr,_)) {\n             wrd1(s, \"check\");\n             popen_h(s);\n             print_expr(s, expr);"}, {"sha": "afa8471170759e8722d3adbfef58a897c394397b", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -39,6 +39,7 @@ mod pretty {\n \n mod util {\n     mod common;\n+    mod typestate_ann;\n }\n \n auth driver.rustc.main = impure;\n@@ -55,8 +56,10 @@ auth middle.trans.copy_any_self_to_alloca = impure;\n auth middle.trans.copy_args_to_allocas = impure;\n auth middle.trans.trans_block = impure;\n auth middle.trans.alloc_ty = impure;\n+auth middle.typestate_check.log_expr = impure;\n auth lib.llvm = unsafe;\n auth pretty.pprust = impure;\n+auth middle.typestate_check.find_pre_post_block = impure;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "a4698c5d40fe8571b506d39487a386d278c57ba8", "filename": "src/comp/util/typestate_ann.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -0,0 +1,61 @@\n+import front.ast.ident;\n+import std._vec;\n+import std.bitv;\n+\n+/* \n+   This says: this expression requires the idents in <pre> to be initialized,\n+   and given the precondition, it guarantees that the idents in <post> are\n+   initialized.\n+ */\n+type precond  = bitv.t; /* 1 means \"this variable must be initialized\"\n+                           0 means \"don't care about this variable\" */\n+type postcond = bitv.t; /* 1 means \"this variable is initialized\"\n+                           0 means \"don't know about this variable */\n+\n+/* named thus so as not to confuse with prestate and poststate */\n+type pre_and_post = rec(precond precondition, postcond postcondition);\n+/* FIXME: once it's implemented: */\n+//  : ((*.precondition).nbits == (*.postcondition).nbits);\n+\n+type ts_ann = pre_and_post;\n+\n+fn true_precond(uint num_vars) -> precond {\n+  be bitv.create(num_vars, false);\n+}\n+\n+fn true_postcond(uint num_vars) -> postcond {\n+  be true_precond(num_vars);\n+}\n+\n+fn empty_pre_post(uint num_vars) -> @pre_and_post {\n+  ret(@rec(precondition=true_precond(num_vars),\n+           postcondition=true_postcond(num_vars)));\n+}\n+\n+fn get_pre(&pre_and_post p) -> precond {\n+  ret p.precondition;\n+}\n+\n+fn get_post(&pre_and_post p) -> postcond {\n+  ret p.postcondition;\n+}\n+\n+fn difference(&precond p1, &precond p2) -> bool {\n+  be bitv.difference(p1, p2);\n+}\n+\n+fn union(&precond p1, &precond p2) -> bool {\n+  be bitv.difference(p1, p2);\n+}\n+\n+fn pps_len(&pre_and_post p) -> uint {\n+  // gratuitous check\n+  check (p.precondition.nbits == p.postcondition.nbits);\n+  ret p.precondition.nbits;\n+}\n+\n+impure fn require_and_preserve(uint i, &pre_and_post p) -> () {\n+  // sets the ith bit in p's pre and post\n+  bitv.set(p.precondition, i, true);\n+  bitv.set(p.postcondition, i, false);\n+}\n\\ No newline at end of file"}, {"sha": "f2b169efb2c9532a1e98864d8e51493dff998e6e", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3130348ee177f1716488b6caca6c7852fe47754c/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3130348ee177f1716488b6caca6c7852fe47754c/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=3130348ee177f1716488b6caca6c7852fe47754c", "patch": "@@ -207,6 +207,29 @@ fn map2[T,U,V](&operator2[T,U,V] f, &vec[mutable? T] v0, &vec[mutable? U] v1)\n     ret u;\n }\n \n+fn find[T](fn (&T) -> bool f, &vec[mutable? T] v) -> option.t[T] {\n+    for (T elt in v) {\n+        if (f(elt)) {\n+            ret some[T](elt);\n+        }\n+    }\n+\n+    ret none[T];\n+}\n+\n+fn foldl[T, U](fn (&U, &T) -> U p, &U z, &vec[T] v) -> U {\n+    auto sz = len[T](v);\n+\n+    if (sz == 0u) {\n+        ret z;\n+    }\n+    else {\n+        auto rest = slice[T](v, 1u, sz);\n+\n+        ret (p(foldl[T,U](p, z, rest), v.(0)));\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}